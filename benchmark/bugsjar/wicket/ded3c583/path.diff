diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java
index 05e7c30..99f7afc 100755
--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java
+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java
@@ -16,6 +16,7 @@
  */
 package org.apache.wicket.core.request.mapper;
 
+import java.util.Iterator;
 import java.util.List;
 
 import org.apache.wicket.Application;
@@ -25,6 +26,7 @@
 import org.apache.wicket.request.Request;
 import org.apache.wicket.request.Url;
 import org.apache.wicket.request.mapper.IRequestMapperDelegate;
+import org.apache.wicket.request.mapper.info.PageComponentInfo;
 import org.apache.wicket.util.IProvider;
 import org.apache.wicket.util.crypt.ICrypt;
 import org.apache.wicket.util.crypt.ICryptFactory;
@@ -34,16 +37,37 @@
 import org.slf4j.LoggerFactory;
 
 /**
- * Request mapper that encrypts urls generated by another mapper. The original URL (both segments
- * and parameters) is encrypted and is represented as URL segment. To be able to handle relative
- * URLs for images in .css file the same amount of URL segments that the original URL had are
- * appended to the encrypted URL. Each segment has a precise 5 character value, calculated using a
- * checksum. This helps in calculating the relative distance from the original URL. When a URL is
- * returned by the browser, we iterate through these checksummed placeholder URL segments. If the
- * segment matches the expected checksum, then the segment it deemed to be the corresponding segment
- * in the encrypted URL. If the segment does not match the expected checksum, then the segment is
- * deemed a plain text sibling of the corresponding segment in the encrypted URL, and all subsequent
+ * <p>
+ * A request mapper that encrypts URLs generated by another mapper. This mapper encrypts the segments
+ * and query parameters of URLs starting with {@code /wicket/}, and the just the {@link PageComponentInfo}
+ * parameter for mounted URLs.
+ * </p>
+ * 
+ * <p>
+ * This mapper can be mounted before or after mounting other pages, but will only encrypt URLs for
+ * pages mounted before the {@link CryptoMapper}. If required, multiple {@link CryptoMapper}s may be
+ * installed in an {@link Application}.
+ * </p>
+ * 
+ * <p>
+ * When encrypting URLs in the Wicket namespace (starting with {@code /wicket/}), the entire URL, including
+ * segments and parameters, is encrypted, with the encrypted form stored in the first segment of the encrypted URL.
+ * </p>
+ * 
+ * <p>
+ * To be able to handle relative URLs, like for image URLs in a CSS file, checksum segments are appended to the
+ * encrypted URL until the encrypted URL has the same number of segments as the original URL had.
+ * Each checksum segment has a precise 5 character value, calculated using a checksum. This helps in calculating
+ * the relative distance from the original URL. When a URL is returned by the browser, we iterate through these
+ * checksummed placeholder URL segments. If the segment matches the expected checksum, then the segment it deemed
+ * to be the corresponding segment in the original URL. If the segment does not match the expected checksum, then
+ * the segment is deemed a plain text sibling of the corresponding segment in the original URL, and all subsequent
  * segments are considered plain text children of the current segment.
+ * </p>
+ * 
+ * <p>
+ * When encrypting mounted URLs, we look for the {@link PageComponentInfo} parameter, and encrypt only that parameter.
+ * </p>
  * 
  * @author igor.vaynberg
  * @author Jesse Long
@@ -53,6 +77,11 @@
 {
 	private static final Logger log = LoggerFactory.getLogger(CryptoMapper.class);
 
+	/**
+	 * Name of the parameter which contains encrypted page component info.
+	 */
+	private static final String ENCRYPTED_PAGE_COMPONENT_INFO_PARAMETER = "wicket";
+
 	private final IRequestMapper wrappedMapper;
 	private final IProvider<ICrypt> cryptProvider;
 
@@ -87,12 +116,34 @@ public CryptoMapper(final IRequestMapper wrappedMapper, final IProvider<ICrypt>
 		this.cryptProvider = Args.notNull(cryptProvider, "cryptProvider");
 	}
 
+	/**
+	 * {@inheritDoc}
+	 * <p>
+	 * This implementation decrypts the URL and passes the decrypted URL to the wrapped mapper.
+	 * </p>
+	 * @param request
+	 *		The request for which to get a compatability score.
+	 * 
+	 * @return The compatability score.
+	 */
 	@Override
 	public int getCompatibilityScore(final Request request)
 	{
-		return wrappedMapper.getCompatibilityScore(request);
+		Url decryptedUrl = decryptUrl(request, request.getUrl());
+
+		if (decryptedUrl == null)
+		{
+			return 0;
 		}
 
+		Request decryptedRequest = request.cloneWithUrl(decryptedUrl);
+
+		return wrappedMapper.getCompatibilityScore(decryptedRequest);
+	}
+
+	/**
+	 * {@inheritDoc}
+	 */
 	@Override
 	public Url mapHandler(final IRequestHandler requestHandler)
 	{
@@ -112,6 +163,9 @@ public Url mapHandler(final IRequestHandler requestHandler)
 		return encryptUrl(url);
 	}
 
+	/**
+	 * {@inheritDoc}
+	 */
 	@Override
 	public IRequestHandler mapRequest(final Request request)
 	{
@@ -119,7 +173,7 @@ public IRequestHandler mapRequest(final Request request)
 
 		if (url == null)
 		{
-			return wrappedMapper.mapRequest(request);
+			return null;
 		}
 
 		Request decryptedRequest = request.cloneWithUrl(url);
@@ -152,18 +206,44 @@ public final IRequestMapper getDelegateMapper()
 		return wrappedMapper;
 	}
 
+	/**
+	 * Encrypts a URL. This method should return a new, encrypted instance of the URL. If the URL starts with {@code /wicket/},
+	 * the entire URL is encrypted.
+	 * 
+	 * @param url
+	 *		The URL to encrypt.
+	 * 
+	 * @return A new, encrypted version of the URL.
+	 */
 	protected Url encryptUrl(final Url url)
 	{
-		if (url.getSegments().isEmpty())
+		if (url.getSegments().size() > 0
+			&& url.getSegments().get(0).equals(Application.get().getMapperContext().getNamespace()))
 		{
-			return url;
+			return encryptEntireUrl(url);
 		}
+		else
+		{
+			return encryptRequestListenerParameter(url);
+		}
+	}
+
+	/**
+	 * Encrypts an entire URL, segments and query parameters.
+	 * 
+	 * @param url
+	 *		The URL to encrypt.
+	 * 
+	 * @return An encrypted form of the URL.
+	 */
+	protected Url encryptEntireUrl(final Url url)
+	{
 		String encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());
 
 		Url encryptedUrl = new Url(url.getCharset());
 		encryptedUrl.getSegments().add(encryptedUrlString);
 
-		int numberOfSegments = url.getSegments().size();
+		int numberOfSegments = url.getSegments().size() - 1;
 		HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
 		for (int segNo = 0; segNo < numberOfSegments; segNo++)
 		{
@@ -172,25 +252,108 @@ protected Url encryptUrl(final Url url)
 		return encryptedUrl;
 	}
 
+	/**
+	 * Encrypts the {@link PageComponentInfo} query parameter in the URL, if any is found.
+	 * 
+	 * @param url
+	 *		The URL to encrypt.
+	 * 
+	 * @return An encrypted form of the URL.
+	 */
+	protected Url encryptRequestListenerParameter(final Url url)
+	{
+		Url encryptedUrl = new Url(url);
+
+		for (Iterator<Url.QueryParameter> it = encryptedUrl.getQueryParameters().iterator(); it.hasNext();)
+		{
+			Url.QueryParameter qp = it.next();
+
+			if (Strings.isEmpty(qp.getValue()) == true && Strings.isEmpty(qp.getName()) == false)
+			{
+				if (PageComponentInfo.parse(qp.getName()) != null)
+				{
+					it.remove();
+					String encryptedParameterValue = getCrypt().encryptUrlSafe(qp.getName());
+					Url.QueryParameter encryptedParameter
+						= new Url.QueryParameter(ENCRYPTED_PAGE_COMPONENT_INFO_PARAMETER, encryptedParameterValue);
+					encryptedUrl.getQueryParameters().add(0, encryptedParameter);
+					break;
+				}
+			}
+		}
+
+		return encryptedUrl;
+	}
+
+	/**
+	 * Decrypts a {@link Url}. This method should return {@code null} if the URL is not decryptable, or if the
+	 * URL should have been encrypted but was not. Returning {@code null} results in a 404 error.
+	 * 
+	 * @param request
+	 *		The {@link Request}.
+	 * @param encryptedUrl
+	 *		The encrypted {@link Url}.
+	 * 
+	 * @return Returns a decrypted {@link Url}.
+	 */
 	protected Url decryptUrl(final Request request, final Url encryptedUrl)
 	{
+		Url url = decryptEntireUrl(request, encryptedUrl);
+
+		if (url == null)
+		{
+			if (encryptedUrl.getSegments().size() > 0
+				&& encryptedUrl.getSegments().get(0).equals(Application.get().getMapperContext().getNamespace()))
+			{
 				/*
-		 * If the encrypted URL has no segments it is the home page URL, and does not need
-		 * decrypting.
+				 * This URL should have been encrypted, but was not. We should refuse to handle this, except when
+				 * there is more than one CryptoMapper installed, and the request was decrypted by some other
+				 * CryptoMapper.
 				 */
-		if (encryptedUrl.getSegments().isEmpty())
+				if (request.getOriginalUrl().getSegments().size() > 0
+					&& request.getOriginalUrl().getSegments().get(0).equals(Application.get().getMapperContext().getNamespace()))
+				{
+					return null;
+				}
+				else
 				{
 					return encryptedUrl;
 				}
+			}
+		}
 
-		List<String> encryptedSegments = encryptedUrl.getSegments();
+		if (url == null)
+		{
+			url = decryptRequestListenerParameter(request, encryptedUrl);
+		}
 
+		return url;
+	}
+
+	/**
+	 * Decrypts an entire URL, which was previously encrypted by {@link #encryptEntireUrl(org.apache.wicket.request.Url)}.
+	 * This method should return {@code null} if the URL is not decryptable.
+	 * 
+	 * @param request
+	 *		The request that was made.
+	 * @param encryptedUrl
+	 *		The encrypted URL.
+	 * 
+	 * @return A decrypted form of the URL, or {@code null} if the URL is not decryptable.
+	 */
+	protected Url decryptEntireUrl(final Request request, final Url encryptedUrl)
+	{
 		Url url = new Url(request.getCharset());
-		try
+
+		List<String> encryptedSegments = encryptedUrl.getSegments();
+
+		if (encryptedSegments.isEmpty())
 		{
+			return null;
+		}
+
 		/*
-			 * The first encrypted segment contains an encrypted version of the entire plain text
-			 * url.
+		 * The first encrypted segment contains an encrypted version of the entire plain text url.
 		 */
 		String encryptedUrlString = encryptedSegments.get(0);
 		if (Strings.isEmpty(encryptedUrlString))
@@ -198,7 +361,17 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)
 			return null;
 		}
 
-			String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);
+		String decryptedUrl;
+		try
+		{
+			decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);
+		}
+		catch (Exception e)
+		{
+			log.error("Error decrypting URL", e);
+			return null;
+		}
+
 		if (decryptedUrl == null)
 		{
 			return null;
@@ -208,6 +382,28 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)
 		int originalNumberOfSegments = originalUrl.getSegments().size();
 		int encryptedNumberOfSegments = encryptedUrl.getSegments().size();
 
+		if (originalNumberOfSegments > 0)
+		{
+			/*
+			 * This should always be true. Home page URLs are the only ones without
+			 * segments, and we dont encrypt those with this method.
+			 * 
+			 * We always add the first segment of the URL, because we encrypt a URL like:
+			 *	/path/to/something
+			 * to:
+			 *	/encrypted_full/hash/hash
+			 * 
+			 * Notice the consistent number of segments. If we applied the following relative URL:
+			 *	../../something
+			 * then the resultant URL would be:
+			 *	/something
+			 * 
+			 * Hence, the mere existence of the first, encrypted version of complete URL, segment
+			 * tells us that the first segment of the original URL is still to be used.
+			 */
+			url.getSegments().add(originalUrl.getSegments().get(0));
+		}
+
 		HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
 		int segNo = 1;
 		for (; segNo < encryptedNumberOfSegments; segNo++)
@@ -222,18 +418,18 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)
 			if (!next.equals(encryptedSegment))
 			{
 				/*
-					 * This segment received from the browser is not the same as the expected
-					 * segment generated by the HashSegmentGenerator. Hence it, and all subsequent
-					 * segments are considered plain text siblings of the original encrypted url.
+				 * This segment received from the browser is not the same as the expected segment generated
+				 * by the HashSegmentGenerator. Hence it, and all subsequent segments are considered plain
+				 * text siblings of the original encrypted url.
 				 */
 				break;
 			}
 
 			/*
-				 * This segments matches the expected checksum, so we add the corresponding segment
-				 * from the original URL.
+			 * This segments matches the expected checksum, so we add the corresponding segment from the
+			 * original URL.
 			 */
-				url.getSegments().add(originalUrl.getSegments().get(segNo - 1));
+			url.getSegments().add(originalUrl.getSegments().get(segNo));
 		}
 		/*
 		 * Add all remaining segments from the encrypted url as plain text segments.
@@ -247,11 +443,83 @@ protected Url decryptUrl(final Request request, final Url encryptedUrl)
 		url.getQueryParameters().addAll(originalUrl.getQueryParameters());
 		// WICKET-4923 additional parameters
 		url.getQueryParameters().addAll(encryptedUrl.getQueryParameters());
+
+		return url;
+	}
+
+	/**
+	 * Decrypts a URL which may contain an encrypted {@link PageComponentInfo} query parameter.
+	 * 
+	 * @param request
+	 *		The request that was made.
+	 * @param encryptedUrl
+	 *		The (potentially) encrypted URL.
+	 * 
+	 * @return A decrypted form of the URL.
+	 */
+	protected Url decryptRequestListenerParameter(final Request request, Url encryptedUrl)
+	{
+		Url url = new Url(encryptedUrl);
+
+		url.getQueryParameters().clear();
+
+		for (Url.QueryParameter qp : encryptedUrl.getQueryParameters())
+		{
+			if (Strings.isEmpty(qp.getValue()) && Strings.isEmpty(qp.getName()) == false)
+			{
+				if (PageComponentInfo.parse(qp.getName()) != null)
+				{
+					/*
+					 * Plain text request listener parameter found. This should have been encrypted, so we
+					 * refuse to map the request unless the original URL did not include this parameter, which
+					 * case there are likely to be multiple cryptomappers installed.
+					 */
+					if (request.getOriginalUrl().getQueryParameter(qp.getName()) == null)
+					{
+						url.getQueryParameters().add(qp);
+					}
+					else
+					{
+						return null;
+					}
+				}
+			}
+			else if (ENCRYPTED_PAGE_COMPONENT_INFO_PARAMETER.equals(qp.getName()))
+			{
+				String encryptedValue = qp.getValue();
+
+				if (Strings.isEmpty(encryptedValue))
+				{
+					url.getQueryParameters().add(qp);
+				}
+				else
+				{
+					String decryptedValue = null;
+
+					try
+					{
+						decryptedValue = getCrypt().decryptUrlSafe(encryptedValue);
 					}
 					catch (Exception e)
 					{
-			log.error("Error decrypting URL", e);
-			url = null;
+						log.error("Error decrypting encrypted request listener query parameter", e);
+					}
+
+					if (Strings.isEmpty(decryptedValue))
+					{
+						url.getQueryParameters().add(qp);
+					}
+					else
+					{
+						Url.QueryParameter decryptedParamter = new Url.QueryParameter(decryptedValue, "");
+						url.getQueryParameters().add(0, decryptedParamter);
+					}
+				}
+			}
+			else
+			{
+				url.getQueryParameters().add(qp);
+			}
 		}
 
 		return url;
