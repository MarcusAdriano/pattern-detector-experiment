diff --git a/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java b/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java
index f7df59e..42e1344 100644
--- a/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java
+++ b/wicket-core/src/main/java/org/apache/wicket/feedback/FencedFeedbackPanel.java
@@ -29,13 +29,13 @@
  * the nesting of these panels to work correctly without displaying the same feedback message twice.
  * A constructor that does not takes a fencing component creates a catch-all panel that shows
  * messages that do not come from inside any fence or from the {@link Session}.
- * 
+ * <p/>
  * <h2>IN DEPTH EXPLANATION</h2>
  * <p>
  * It is often very useful to have feedback panels that show feedback that comes from inside a
  * certain container only. For example given a page with the following structure:
  * </p>
- * 
+ * <p/>
  * <pre>
  * Page
  *   Form1
@@ -112,10 +112,9 @@ public FencedFeedbackPanel(String id, Component fence)
 	/**
 	 * Creates a catch-all instance with a filter.
 	 *
-	 * @see #FencedFeedbackPanel(String)
-	 * 
 	 * @param id
 	 * @param filter
+	 * @see #FencedFeedbackPanel(String)
 	 */
 	public FencedFeedbackPanel(String id, IFeedbackMessageFilter filter)
 	{
@@ -125,11 +124,10 @@ public FencedFeedbackPanel(String id, IFeedbackMessageFilter filter)
 	/**
 	 * Creates a fenced feedback panel with a filter.
 	 *
-	 * @see #FencedFeedbackPanel(String, Component)
-	 * 
 	 * @param id
 	 * @param fence
 	 * @param filter
+	 * @see #FencedFeedbackPanel(String, Component)
 	 */
 	public FencedFeedbackPanel(String id, Component fence, IFeedbackMessageFilter filter)
 	{
@@ -137,11 +135,16 @@ public FencedFeedbackPanel(String id, Component fence, IFeedbackMessageFilter fi
 		this.fence = fence;
 		if (fence != null)
 		{
+			incrementFenceCount();
+		}
+	}
+
+	private void incrementFenceCount()
+	{
 		Integer count = fence.getMetaData(FENCE_KEY);
 		count = count == null ? 1 : count + 1;
 		fence.setMetaData(FENCE_KEY, count);
 	}
-	}
 
 	@Override
 	protected void onRemove()
@@ -151,11 +154,16 @@ protected void onRemove()
 		{
 			// decrement the fence count
 
+			decrementFenceCount();
+		}
+	}
+
+	private void decrementFenceCount()
+	{
 		Integer count = fence.getMetaData(FENCE_KEY);
 		count = (count == null || count == 1) ? null : count - 1;
 		fence.setMetaData(FENCE_KEY, count);
 	}
-	}
 
 	@Override
 	protected FeedbackMessagesModel newFeedbackMessagesModel()
@@ -177,7 +185,7 @@ protected FeedbackMessagesModel newFeedbackMessagesModel()
 						@Override
 						protected boolean shouldRecurseInto(Component component)
 						{
-							return component.getMetaData(FENCE_KEY) == null;
+							return !componentIsMarkedAsFence(component);
 						}
 					}.collect(filter);
 				}
@@ -191,12 +199,29 @@ protected boolean shouldRecurseInto(Component component)
 						protected boolean shouldRecurseInto(Component component)
 						{
 							// only recurse into components that are not fences
-
-							return component.getMetaData(FENCE_KEY) == null;
+							return !componentIsMarkedAsFence(component);
 						}
 					}.setIncludeSession(false).collect(filter);
 				}
 			}
 		};
 	}
+
+	private boolean componentIsMarkedAsFence(Component component)
+	{
+		return component.getMetaData(FENCE_KEY) != null;
+	}
+
+	@Override
+	protected void onReAdd()
+	{
+		if (this.fence != null)
+		{
+			// The fence mark is removed when the feedback panel is removed from the hierarchy.
+			// see onRemove().
+			// when the panel is re-added, we recreate the fence mark.
+			incrementFenceCount();
+		}
+		super.onReAdd();
+	}
 }
