diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java
index 5858da2..09e517a 100644
--- a/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java
+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ByteParser.java
@@ -36,7 +36,8 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, B
 			startPos++;
 
 			// check for empty field with only the sign
-			if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {
+			if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, 
+				delimiter))) {
 				setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);
 				return -1;
 			}
@@ -44,6 +45,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, B
 
 		for (int i = startPos; i < limit; i++) {
 			if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
+				if (i == startPos) {
+					setErrorState(ParseErrorState.EMPTY_STRING);
+					return -1;
+				}
 				this.result = (byte) (neg ? -val : val);
 				return i + delimiter.length;
 			}
@@ -75,38 +80,35 @@ public Byte getLastResult() {
 	}
 
 	/**
-	 * Static utility to parse a field of type byte from a byte sequence that represents text characters
+	 * Static utility to parse a field of type byte from a byte sequence that represents text 
+	 * characters
 	 * (such as when read from a file stream).
 	 *
 	 * @param bytes    The bytes containing the text data that should be parsed.
 	 * @param startPos The offset to start the parsing.
 	 * @param length   The length of the byte sequence (counting from the offset).
-	 * 
 	 * @return The parsed value.
-	 * 
-	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
+	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text 
+	 * represents not a correct number.
 	 */
 	public static final byte parseField(byte[] bytes, int startPos, int length) {
 		return parseField(bytes, startPos, length, (char) 0xffff);
 	}
 
 	/**
-	 * Static utility to parse a field of type byte from a byte sequence that represents text characters
+	 * Static utility to parse a field of type byte from a byte sequence that represents text 
+	 * characters
 	 * (such as when read from a file stream).
 	 *
 	 * @param bytes     The bytes containing the text data that should be parsed.
 	 * @param startPos  The offset to start the parsing.
 	 * @param length    The length of the byte sequence (counting from the offset).
 	 * @param delimiter The delimiter that terminates the field.
-	 * 
 	 * @return The parsed value.
-	 * 
-	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
+	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text 
+	 * represents not a correct number.
 	 */
 	public static final byte parseField(byte[] bytes, int startPos, int length, char delimiter) {
-		if (length <= 0) {
-			throw new NumberFormatException("Invalid input: Empty string");
-		}
 		long val = 0;
 		boolean neg = false;
 
@@ -121,7 +123,7 @@ public static final byte parseField(byte[] bytes, int startPos, int length, char
 
 		for (; length > 0; startPos++, length--) {
 			if (bytes[startPos] == delimiter) {
-				return (byte) (neg ? -val : val);
+				throw new NumberFormatException("Empty field.");
 			}
 			if (bytes[startPos] < 48 || bytes[startPos] > 57) {
 				throw new NumberFormatException("Invalid character.");
diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java
index f9b36e4..612a1cb 100644
--- a/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java
+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ByteValueParser.java
@@ -52,6 +52,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, B
 		for (int i = startPos; i < limit; i++) {
 
 			if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
+				if (i == startPos) {
+					setErrorState(ParseErrorState.EMPTY_STRING);
+					return -1;
+				}
 				reusable.setValue((byte) (neg ? -val : val));
 				return i + delimiter.length;
 			}
diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java
index 947fdfe..086c1f5 100644
--- a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java
+++ b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleParser.java
@@ -42,11 +42,15 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, D
 		}
 
 		String str = new String(bytes, startPos, i - startPos);
+		int len = str.length();
+		if (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {
+			setErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);
+			return -1;
+		}
 		try {
 			this.result = Double.parseDouble(str);
 			return (i == limit) ? limit : i + delimiter.length;
-		}
-		catch (NumberFormatException e) {
+		} catch (NumberFormatException e) {
 			setErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);
 			return -1;
 		}
@@ -63,33 +67,33 @@ public Double getLastResult() {
 	}
 
 	/**
-	 * Static utility to parse a field of type double from a byte sequence that represents text characters
+	 * Static utility to parse a field of type double from a byte sequence that represents text 
+	 * characters
 	 * (such as when read from a file stream).
 	 *
 	 * @param bytes    The bytes containing the text data that should be parsed.
 	 * @param startPos The offset to start the parsing.
 	 * @param length   The length of the byte sequence (counting from the offset).
-	 * 
 	 * @return The parsed value.
-	 * 
-	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
+	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text 
+	 * represents not a correct number.
 	 */
 	public static final double parseField(byte[] bytes, int startPos, int length) {
 		return parseField(bytes, startPos, length, (char) 0xffff);
 	}
 
 	/**
-	 * Static utility to parse a field of type double from a byte sequence that represents text characters
+	 * Static utility to parse a field of type double from a byte sequence that represents text 
+	 * characters
 	 * (such as when read from a file stream).
 	 *
 	 * @param bytes     The bytes containing the text data that should be parsed.
 	 * @param startPos  The offset to start the parsing.
 	 * @param length    The length of the byte sequence (counting from the offset).
 	 * @param delimiter The delimiter that terminates the field.
-	 * 
 	 * @return The parsed value.
-	 * 
-	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
+	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text 
+	 * represents not a correct number.
 	 */
 	public static final double parseField(byte[] bytes, int startPos, int length, char delimiter) {
 		if (length <= 0) {
@@ -102,7 +106,12 @@ public static final double parseField(byte[] bytes, int startPos, int length, ch
 			i++;
 		}
 
-		String str = new String(bytes, startPos, i);
+		String str = new String(bytes, startPos, i - startPos);
+		int len = str.length();
+		if (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {
+			throw new NumberFormatException("There is leading or trailing whitespace in the " +
+				"numeric field: " + str);
+		}
 		return Double.parseDouble(str);
 	}
 }
diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java
index e225c1f..7751831 100644
--- a/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java
+++ b/flink-core/src/main/java/org/apache/flink/types/parser/DoubleValueParser.java
@@ -43,6 +43,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, D
 		}
 		
 		String str = new String(bytes, startPos, i - startPos);
+		if (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {
+			setErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);
+			return -1;
+		}
 		try {
 			double value = Double.parseDouble(str);
 			reusable.setValue(value);
diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java
index 33697fd..55e9915 100644
--- a/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java
+++ b/flink-core/src/main/java/org/apache/flink/types/parser/FieldParser.java
@@ -64,7 +64,13 @@
 		UNTERMINATED_QUOTED_STRING,
 
 		/** The parser found characters between the end of the quoted string and the delimiter. */
-		UNQUOTED_CHARS_AFTER_QUOTED_STRING
+		UNQUOTED_CHARS_AFTER_QUOTED_STRING,
+		
+		/** The string is empty. */
+		EMPTY_STRING,
+
+		/** There is whitespace in a numeric field. */
+		WHITESPACE_IN_NUMERIC_FIELD
 	}
 	
 	private ParseErrorState errorState = ParseErrorState.NONE;
diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java
index 7d166c7..be98aa1 100644
--- a/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java
+++ b/flink-core/src/main/java/org/apache/flink/types/parser/FloatParser.java
@@ -27,7 +27,8 @@
 	private float result;
 	
 	@Override
-	public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Float reusable) {
+	public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Float 
+		reusable) {
 
 		int i = startPos;
 
@@ -40,12 +41,17 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, F
 			i++;
 		}
 
+		if (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {
+			setErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);
+			return -1;
+		}
+
 		String str = new String(bytes, startPos, i - startPos);
+		int len = str.length();
 		try {
 			this.result = Float.parseFloat(str);
 			return (i == limit) ? limit : i + delimiter.length;
-		}
-		catch (NumberFormatException e) {
+		} catch (NumberFormatException e) {
 			setErrorState(ParseErrorState.NUMERIC_VALUE_FORMAT_ERROR);
 			return -1;
 		}
@@ -62,33 +68,33 @@ public Float getLastResult() {
 	}
 
 	/**
-	 * Static utility to parse a field of type float from a byte sequence that represents text characters
+	 * Static utility to parse a field of type float from a byte sequence that represents text 
+	 * characters
 	 * (such as when read from a file stream).
 	 *
 	 * @param bytes    The bytes containing the text data that should be parsed.
 	 * @param startPos The offset to start the parsing.
 	 * @param length   The length of the byte sequence (counting from the offset).
-	 * 
 	 * @return The parsed value.
-	 * 
-	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
+	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text 
+	 * represents not a correct number.
 	 */
 	public static final float parseField(byte[] bytes, int startPos, int length) {
 		return parseField(bytes, startPos, length, (char) 0xffff);
 	}
 
 	/**
-	 * Static utility to parse a field of type float from a byte sequence that represents text characters
+	 * Static utility to parse a field of type float from a byte sequence that represents text 
+	 * characters
 	 * (such as when read from a file stream).
 	 *
 	 * @param bytes     The bytes containing the text data that should be parsed.
 	 * @param startPos  The offset to start the parsing.
 	 * @param length    The length of the byte sequence (counting from the offset).
 	 * @param delimiter The delimiter that terminates the field.
-	 * 
 	 * @return The parsed value.
-	 * 
-	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
+	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text 
+	 * represents not a correct number.
 	 */
 	public static final float parseField(byte[] bytes, int startPos, int length, char delimiter) {
 		if (length <= 0) {
@@ -101,7 +107,12 @@ public static final float parseField(byte[] bytes, int startPos, int length, cha
 			i++;
 		}
 		
-		String str = new String(bytes, startPos, i);
+		String str = new String(bytes, startPos, i - startPos);
+		if (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {
+			throw new NumberFormatException("There is leading or trailing whitespace in the " +
+				"numeric field: " + str);
+		}
+		int len = str.length();
 		return Float.parseFloat(str);
 	}
 }
diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java
index af16d4c..e8caac2 100644
--- a/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java
+++ b/flink-core/src/main/java/org/apache/flink/types/parser/FloatValueParser.java
@@ -43,6 +43,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, F
 		}
 		
 		String str = new String(bytes, startPos, i - startPos);
+		if (Character.isWhitespace(bytes[startPos]) || Character.isWhitespace(bytes[Math.max(i - 1, 0)])) {
+			setErrorState(ParseErrorState.WHITESPACE_IN_NUMERIC_FIELD);
+			return -1;
+		}
 		try {
 			float value = Float.parseFloat(str);
 			reusable.setValue(value);
diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java
index c871f4a..dcd2ec2 100644
--- a/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java
+++ b/flink-core/src/main/java/org/apache/flink/types/parser/IntParser.java
@@ -32,7 +32,8 @@
 	private int result;
 
 	@Override
-	public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer reusable) {
+	public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, Integer 
+		reusable) {
 		long val = 0;
 		boolean neg = false;
 
@@ -43,7 +44,8 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, I
 			startPos++;
 
 			// check for empty field with only the sign
-			if (startPos == limit || ( startPos < delimLimit && delimiterNext(bytes, startPos, delimiter))) {
+			if (startPos == limit || (startPos < delimLimit && delimiterNext(bytes, startPos, 
+				delimiter))) {
 				setErrorState(ParseErrorState.NUMERIC_VALUE_ORPHAN_SIGN);
 				return -1;
 			}
@@ -51,6 +53,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, I
 
 		for (int i = startPos; i < limit; i++) {
 			if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
+				if (i == startPos) {
+					setErrorState(ParseErrorState.EMPTY_STRING);
+					return -1;
+				}
 				this.result = (int) (neg ? -val : val);
 				return i + delimiter.length;
 			}
@@ -82,38 +88,35 @@ public Integer getLastResult() {
 	}
 
 	/**
-	 * Static utility to parse a field of type int from a byte sequence that represents text characters
+	 * Static utility to parse a field of type int from a byte sequence that represents text 
+	 * characters
 	 * (such as when read from a file stream).
 	 *
 	 * @param bytes    The bytes containing the text data that should be parsed.
 	 * @param startPos The offset to start the parsing.
 	 * @param length   The length of the byte sequence (counting from the offset).
-	 * 
 	 * @return The parsed value.
-	 * 
-	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
+	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text 
+	 * represents not a correct number.
 	 */
 	public static final int parseField(byte[] bytes, int startPos, int length) {
 		return parseField(bytes, startPos, length, (char) 0xffff);
 	}
 
 	/**
-	 * Static utility to parse a field of type int from a byte sequence that represents text characters
+	 * Static utility to parse a field of type int from a byte sequence that represents text 
+	 * characters
 	 * (such as when read from a file stream).
 	 *
 	 * @param bytes     The bytes containing the text data that should be parsed.
 	 * @param startPos  The offset to start the parsing.
 	 * @param length    The length of the byte sequence (counting from the offset).
 	 * @param delimiter The delimiter that terminates the field.
-	 * 
 	 * @return The parsed value.
-	 * 
-	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
+	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text 
+	 * represents not a correct number.
 	 */
 	public static final int parseField(byte[] bytes, int startPos, int length, char delimiter) {
-		if (length <= 0) {
-			throw new NumberFormatException("Invalid input: Empty string");
-		}
 		long val = 0;
 		boolean neg = false;
 
@@ -128,7 +131,7 @@ public static final int parseField(byte[] bytes, int startPos, int length, char
 
 		for (; length > 0; startPos++, length--) {
 			if (bytes[startPos] == delimiter) {
-				return (int) (neg ? -val : val);
+				throw new NumberFormatException("Empty field.");
 			}
 			if (bytes[startPos] < 48 || bytes[startPos] > 57) {
 				throw new NumberFormatException("Invalid character.");
diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java
index 8cb8176..abd8615 100644
--- a/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java
+++ b/flink-core/src/main/java/org/apache/flink/types/parser/IntValueParser.java
@@ -54,6 +54,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, I
 		
 		for (int i = startPos; i < limit; i++) {
 			if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
+				if (i == startPos) {
+					setErrorState(ParseErrorState.EMPTY_STRING);
+					return -1;
+				}
 				reusable.setValue((int) (neg ? -val : val));
 				return i + delimiter.length;
 			}
diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java
index af17f15..bb6c7c9 100644
--- a/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java
+++ b/flink-core/src/main/java/org/apache/flink/types/parser/LongParser.java
@@ -47,6 +47,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, L
 
 		for (int i = startPos; i < limit; i++) {
 			if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
+				if (i == startPos) {
+					setErrorState(ParseErrorState.EMPTY_STRING);
+					return -1;
+				}
 				this.result = neg ? -val : val;
 				return i + delimiter.length;
 			}
@@ -123,9 +127,6 @@ public static final long parseField(byte[] bytes, int startPos, int length) {
 	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 	 */
 	public static final long parseField(byte[] bytes, int startPos, int length, char delimiter) {
-		if (length <= 0) {
-			throw new NumberFormatException("Invalid input: Empty string");
-		}
 		long val = 0;
 		boolean neg = false;
 
@@ -140,7 +141,7 @@ public static final long parseField(byte[] bytes, int startPos, int length, char
 
 		for (; length > 0; startPos++, length--) {
 			if (bytes[startPos] == delimiter) {
-				return neg ? -val : val;
+				throw new NumberFormatException("Empty field.");
 			}
 			if (bytes[startPos] < 48 || bytes[startPos] > 57) {
 				throw new NumberFormatException("Invalid character.");
diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java
index 8b697cc..a99a86e 100644
--- a/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java
+++ b/flink-core/src/main/java/org/apache/flink/types/parser/LongValueParser.java
@@ -51,6 +51,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, L
 		
 		for (int i = startPos; i < limit; i++) {
 			if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
+				if (i == startPos) {
+					setErrorState(ParseErrorState.EMPTY_STRING);
+					return -1;
+				}
 				reusable.setValue(neg ? -val : val);
 				return i + delimiter.length;
 			}
diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java
index a6f9898..6e04d60 100644
--- a/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java
+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ShortParser.java
@@ -51,6 +51,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, S
 
 		for (int i = startPos; i < limit; i++) {
 			if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
+				if (i == startPos) {
+					setErrorState(ParseErrorState.EMPTY_STRING);
+					return -1;
+				}
 				this.result = (short) (neg ? -val : val);
 				return i + delimiter.length;
 			}
@@ -111,9 +115,6 @@ public static final short parseField(byte[] bytes, int startPos, int length) {
 	 * @throws NumberFormatException Thrown when the value cannot be parsed because the text represents not a correct number.
 	 */
 	public static final short parseField(byte[] bytes, int startPos, int length, char delimiter) {
-		if (length <= 0) {
-			throw new NumberFormatException("Invalid input: Empty string");
-		}
 		long val = 0;
 		boolean neg = false;
 
@@ -128,7 +129,7 @@ public static final short parseField(byte[] bytes, int startPos, int length, cha
 
 		for (; length > 0; startPos++, length--) {
 			if (bytes[startPos] == delimiter) {
-				return (short) (neg ? -val : val);
+				throw new NumberFormatException("Empty field.");
 			}
 			if (bytes[startPos] < 48 || bytes[startPos] > 57) {
 				throw new NumberFormatException("Invalid character.");
diff --git a/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java b/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java
index f5168cc..4289d1a 100644
--- a/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java
+++ b/flink-core/src/main/java/org/apache/flink/types/parser/ShortValueParser.java
@@ -54,6 +54,10 @@ public int parseField(byte[] bytes, int startPos, int limit, byte[] delimiter, S
 		
 		for (int i = startPos; i < limit; i++) {
 			if (i < delimLimit && delimiterNext(bytes, i, delimiter)) {
+				if (i == startPos) {
+					setErrorState(ParseErrorState.EMPTY_STRING);
+					return -1;
+				}
 				reusable.setValue((short) (neg ? -val : val));
 				return i + delimiter.length;
 			}
