diff --git a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/PactCompiler.java b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/PactCompiler.java
index bf3d6af..5a0a3e1 100644
--- a/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/PactCompiler.java
+++ b/stratosphere-compiler/src/main/java/eu/stratosphere/compiler/PactCompiler.java
@@ -1218,42 +1218,19 @@ public void postVisit(PlanNode visitable) {
 			
 				PlanNode newUnionNode;
 
-				// if any input is cached, we keep this as a binary union and do not collapse it into a
-				// n-ary union
-//				if (in1.getTempMode().isCached() || in2.getTempMode().isCached()) {
-//					// replace this node by an explicit operator
-//					Channel cached, pipelined;
-//					if (in1.getTempMode().isCached()) {
-//						cached = in1;
-//						pipelined = in2;
-//					} else {
-//						cached = in2;
-//						pipelined = in1;
-//					}
-//					
-//					newUnionNode = new DualInputPlanNode(unionNode.getOriginalOptimizerNode(), cached, pipelined,
-//						DriverStrategy.UNION_WITH_CACHED);
-//					newUnionNode.initProperties(unionNode.getGlobalProperties(), new LocalProperties());
-//					
-//					in1.setTarget(newUnionNode);
-//					in2.setTarget(newUnionNode);
-//				} else {
-					// collect the union inputs to collapse this operator with 
-					// its collapsed predecessors. check whether an input is materialized to prevent
-					// collapsing
 				List<Channel> inputs = new ArrayList<Channel>();
 				collect(in1, inputs);
 				collect(in2, inputs);
 
 				newUnionNode = new NAryUnionPlanNode(unionNode.getOptimizerNode(), inputs, unionNode.getGlobalProperties());
 
-					// adjust the input channels to have their target point to the new union node
 				for (Channel c : inputs) {
 					c.setTarget(newUnionNode);
 				}
-//				}
 
-				unionNode.getOutgoingChannels().get(0).swapUnionNodes(newUnionNode);
+				for(Channel channel : unionNode.getOutgoingChannels()){
+					channel.swapUnionNodes(newUnionNode);
+				}
 			}
 		}
 		
