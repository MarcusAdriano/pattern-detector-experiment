diff --git a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
index 043f344..2de0d39 100644
--- a/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
+++ b/oak-core/src/main/java/org/apache/jackrabbit/oak/plugins/document/DocumentNodeStore.java
@@ -459,8 +459,11 @@ private void checkLastRevRecovery() {
     }
 
     public void dispose() {
-        runBackgroundOperations();
-        if (!isDisposed.getAndSet(true)) {
+        if (isDisposed.getAndSet(true)) {
+            // only dispose once
+            return;
+        }
+        // notify background threads waiting on isDisposed
         synchronized (isDisposed) {
             isDisposed.notifyAll();
         }
@@ -469,6 +472,11 @@ public void dispose() {
         } catch (InterruptedException e) {
             // ignore
         }
+
+        // do a final round of background operations after
+        // the background thread stopped
+        internalRunBackgroundOperations();
+
         if (leaseUpdateThread != null) {
             try {
                 leaseUpdateThread.join();
@@ -476,11 +484,13 @@ public void dispose() {
                 // ignore
             }
         }
+
+        // now mark this cluster node as inactive by
+        // disposing the clusterNodeInfo
         if (clusterNodeInfo != null) {
             clusterNodeInfo.dispose();
         }
         store.dispose();
-            LOG.info("Disposed DocumentNodeStore with clusterNodeId: {}", clusterId);
 
         if (blobStore instanceof Closeable) {
             try {
@@ -489,10 +499,10 @@ public void dispose() {
                 LOG.debug("Error closing blob store " + blobStore, ex);
             }
         }
-        }
         if (persistentCache != null) {
             persistentCache.close();
         }
+        LOG.info("Disposed DocumentNodeStore with clusterNodeId: {}", clusterId);
     }
 
     Revision setHeadRevision(@Nonnull Revision newHead) {
@@ -544,6 +554,7 @@ Commit newCommit(@Nullable Revision base,
             base = headRevision;
         }
         backgroundOperationLock.readLock().lock();
+        checkOpen();
         boolean success = false;
         Commit c;
         try {
@@ -573,6 +584,7 @@ MergeCommit newMergeCommit(@Nullable Revision base, int numBranchCommits) {
             base = headRevision;
         }
         backgroundOperationLock.readLock().lock();
+        checkOpen();
         boolean success = false;
         MergeCommit c;
         try {
@@ -1502,15 +1514,22 @@ public Revision getHeadRevision() {
 
     //----------------------< background operations >---------------------------
 
-    public synchronized void runBackgroundOperations() {
+    public void runBackgroundOperations() {
         if (isDisposed.get()) {
             return;
         }
-        if (simpleRevisionCounter != null) {
-            // only when using timestamp
+        try {
+            internalRunBackgroundOperations();
+        } catch (RuntimeException e) {
+            if (isDisposed.get()) {
+                LOG.warn("Background operation failed: " + e.toString(), e);
                 return;
             }
-        try {
+            throw e;
+        }
+    }
+
+    private synchronized void internalRunBackgroundOperations() {
         long start = clock.getTime();
         long time = start;
         // clean orphaned branches and collisions
@@ -1536,12 +1555,6 @@ public synchronized void runBackgroundOperations() {
         } else {
             LOG.debug(msg, cleanTime, splitTime, writeTime, readTime, readStats);
         }
-        } catch (RuntimeException e) {
-            if (isDisposed.get()) {
-                return;
-            }
-            throw e;
-        }
     }
 
     /**
@@ -1771,6 +1784,19 @@ void backgroundWrite() {
 
     //-----------------------------< internal >---------------------------------
 
+    /**
+     * Checks if this store is still open and throws an
+     * {@link IllegalStateException} if it is already disposed (or a dispose
+     * is in progress).
+     *
+     * @throws IllegalStateException if this store is disposed.
+     */
+    private void checkOpen() throws IllegalStateException {
+        if (isDisposed.get()) {
+            throw new IllegalStateException("This DocumentNodeStore is disposed");
+        }
+    }
+
     private boolean dispatch(@Nonnull String jsonDiff,
                              @Nonnull DocumentNodeState node,
                              @Nonnull DocumentNodeState base,
