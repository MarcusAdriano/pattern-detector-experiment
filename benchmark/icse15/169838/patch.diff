diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/ResultColumnDescriptor.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/ResultColumnDescriptor.java
index 4e2b9115..75a04258 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/ResultColumnDescriptor.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/ResultColumnDescriptor.java
@@ -47,23 +47,40 @@
 	String	getName();
 
 	/**
-	 * Get the name of the schema the Column is in, if any.
+	 * Get the name of the schema for the Column's base table, if any.
+	 * Following example queries will all return APP (assuming user is in schema APP)
+	 * select t.a from t
+	 * select b.a from t as b
+	 * select app.t.a from t
 	 *
-	 * @return	A String containing the name of the schema the Column
-	 *		is in.  If the column is not in a schema (i.e. is a
-	 * 		derived column), it returns NULL.
+	 * @return	The name of the schema of the Column's base table. If the column
+	 *		is not in a schema (i.e. is a derived column), it returns NULL.
 	 */
-	String	getSchemaName();
+	String	getSourceSchemaName();
 
 	/**
-	 * Get the name of the table the Column is in, if any.
+	 * Get the name of the underlying(base) table this column comes from, if any.
+	 * Following example queries will all return T
+	 * select a from t
+	 * select b.a from t as b
+	 * select t.a from t
 	 *
-	 * @return	A String containing the name of the table the Column
+	 * @return	A String containing the name of the base table of the Column
 	 *		is in. If the column is not in a table (i.e. is a
 	 * 		derived column), it returns NULL.
+	 * @return	The name of the Column's base table. If the column
+	 *		is not in a schema (i.e. is a derived column), it returns NULL.
 	 */
 	String	getSourceTableName();
 
+	/**
+	 * Return true if the column is wirtable by a positioned update.
+	 *
+	 * @return TRUE, if the column is a base column of a table and is 
+	 * writable by a positioned update.
+	 */
+	boolean updatableByCursor();
+
 	/**
 	 * Get the position of the Column.
 	 * NOTE - position is 1-based.
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/ColumnDescriptor.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/ColumnDescriptor.java
index 6bb4414c..e7da1791 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/ColumnDescriptor.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/ColumnDescriptor.java
@@ -220,7 +220,7 @@ public String	getColumnName()
 	}
 
 	/**
-	 * Sets the the column name in case of rename column.
+	 * Sets the column name in case of rename column.
 	 *
 	 * @param newColumnName	The new column name.
 	 */
@@ -229,6 +229,16 @@ public void	setColumnName(String newColumnName)
 		this.columnName = newColumnName;
 	}
 
+	/**
+	 * Sets the table descriptor for the column.
+	 *
+	 * @param tableDescriptor	The table descriptor for this column
+	 */
+	public void	setTableDescriptor(TableDescriptor tableDescriptor)
+	{
+		this.table = tableDescriptor;
+	}
+
 	/**
 	 * Get the ordinal position of the column (1 based)
 	 *
@@ -326,6 +336,10 @@ public boolean isAutoincrement()
 	{
 		return (autoincInc != 0);
 	}
+	public boolean updatableByCursor()
+	{
+		return false;
+	}
 
 	/**
 	 * Get the start value of an autoincrement column
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java
index c6fb8f85..b3768e48 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java
@@ -2043,11 +2043,19 @@ protected void checksBeforeUpdateXXX(String methodName, int columnIndex) throws
       //1)Make sure for updateXXX methods, the column position is not out of range
       ResultDescription rd = theResults.getResultDescription();
       if (columnIndex < 1 || columnIndex > rd.getColumnCount())
-        throw Util.generateCsSQLException(SQLState.LANG_INVALID_COLUMN_POSITION, new Integer(columnIndex), String.valueOf(rd.getColumnCount()));
+        throw Util.generateCsSQLException(SQLState.LANG_INVALID_COLUMN_POSITION,
+					new Integer(columnIndex), String.valueOf(rd.getColumnCount()));
 
       //2)Make sure the column corresponds to a column in the base table and it is not a derived column
       if (rd.getColumnDescriptor(columnIndex).getSourceTableName() == null)
-        throw Util.generateCsSQLException(SQLState.COLUMN_NOT_FROM_BASE_TABLE, methodName);
+        throw Util.generateCsSQLException(SQLState.COLUMN_NOT_FROM_BASE_TABLE,
+					methodName);
+
+      //3)If column not updatable then throw an exception
+      if (!getMetaData().isWritable(columnIndex))
+        throw Util.generateCsSQLException(SQLState.LANG_COLUMN_NOT_UPDATABLE_IN_CURSOR,
+					theResults.getResultDescription().getColumnDescriptor(columnIndex).getName(),
+					getCursorName());
 	}
 
 	//do following few checks before accepting updatable resultset api
@@ -3153,6 +3161,8 @@ public void updateRow() throws SQLException {
             boolean foundOneColumnAlready = false;
             StringBuffer updateWhereCurrentOfSQL = new StringBuffer("UPDATE ");
             CursorActivation activation = getEmbedConnection().getLanguageConnection().lookupCursorActivation(getCursorName());
+
+
             ExecCursorTableReference targetTable = activation.getPreparedStatement().getTargetTable();
             updateWhereCurrentOfSQL.append(getFullBaseTableName(targetTable));//got the underlying (schema.)table name
             updateWhereCurrentOfSQL.append(" SET ");
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedResultSetMetaData.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedResultSetMetaData.java
index 7da88f4c..a83b5567 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedResultSetMetaData.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedResultSetMetaData.java
@@ -204,7 +204,7 @@ public String getColumnName(int column) throws SQLException	{
 	public String getSchemaName(int column) throws SQLException	{
 		ResultColumnDescriptor cd = columnInfo[column - 1];
 
-		String s = cd.getSchemaName();
+		String s = cd.getSourceSchemaName();
 		// database returns null when no schema name to differentiate from empty name
 		return (s==null? "" : s);
 	}
@@ -308,9 +308,7 @@ public boolean isReadOnly(int column) throws SQLException {
      */
 	public boolean isWritable(int column) throws SQLException {
 		validColumnNumber(column);
-
-		// we just don't know if it is a base table column or not
-		return false;
+		return columnInfo[column - 1].updatableByCursor();
 	}
 
     /**
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/GenericColumnDescriptor.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/GenericColumnDescriptor.java
index 5aae4dd1..2f7bc759 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/GenericColumnDescriptor.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/GenericColumnDescriptor.java
@@ -66,6 +66,7 @@
 	private int					columnPos;
 	private DataTypeDescriptor	type;
 	private boolean 			isAutoincrement;
+	private boolean 			updatableByCursor;
 
 	/**
 	 * Niladic constructor for Formatable
@@ -92,10 +93,11 @@ public GenericColumnDescriptor(ResultColumnDescriptor rcd)
 	{
 		name = rcd.getName();
 		tableName = rcd.getSourceTableName();
-		schemaName = rcd.getSchemaName();
+ 		schemaName = rcd.getSourceSchemaName();
 		columnPos = rcd.getColumnPosition();
 		type = rcd.getType();
 		isAutoincrement = rcd.isAutoincrement();
+		updatableByCursor = rcd.updatableByCursor();
 	}
 
 	/**
@@ -121,23 +123,29 @@ public String	getName()
 	}
 
 	/**
-	 * Get the name of the schema the Column is in, if any.
+	 * Get the name of the schema for the Column's base table, if any.
+	 * Following example queries will all return APP (assuming user is in schema APP)
+	 * select t.a from t
+	 * select b.a from t as b
+	 * select app.t.a from t
 	 *
-	 * @return	A String containing the name of the schema the Column
-	 *		is in.  If the column is not in a schema (i.e. is a
-	 * 		derived column), it returns NULL.
+	 * @return	A String containing the name of the schema of the Column's table.
+	 *		If the column is not in a schema (i.e. is a derived column), it returns NULL.
 	 */
-	public String	getSchemaName()
+	public String	getSourceSchemaName()
 	{
 		return schemaName;
 	}
 
 	/**
-	 * Get the name of the table the Column is in, if any.
+	 * Get the name of the underlying(base) table this column comes from, if any.
+	 * Following example queries will all return T
+	 * select a from t
+	 * select b.a from t as b
+	 * select t.a from t
 	 *
-	 * @return	A String containing the name of the table the Column
-	 *		is in. If the column is not in a table (i.e. is a
-	 * 		derived column), it returns NULL.
+	 * @return	A String containing the name of the Column's base table.
+	 *		If the column is not in a table (i.e. is a derived column), it returns NULL.
 	 */
 	public String	getSourceTableName()
 	{
@@ -161,6 +169,11 @@ public boolean isAutoincrement()
 		return isAutoincrement;
 	}
 
+	public boolean updatableByCursor()
+	{
+		return updatableByCursor;
+	}
+
 	//////////////////////////////////////////////
 	//
 	// FORMATABLE
@@ -182,6 +195,7 @@ public void writeExternal(ObjectOutput out) throws IOException
 		fh.putInt("columnPos", columnPos);
 		fh.put("type", type);
 		fh.putBoolean("isAutoincrement", isAutoincrement);
+		fh.putBoolean("updatableByCursor", updatableByCursor);
 		out.writeObject(fh);
 		return;
 	}	
@@ -205,6 +219,7 @@ public void readExternal(ObjectInput in)
 		columnPos = fh.getInt("columnPos");
 		type = (DataTypeDescriptor)fh.get("type");
 		isAutoincrement = fh.getBoolean("isAutoincrement");
+		updatableByCursor = fh.getBoolean("updatableByCursor");
 	}
 	
 	/**
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BaseColumnNode.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BaseColumnNode.java
index a3481e5e..a33f20d5 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BaseColumnNode.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BaseColumnNode.java
@@ -111,6 +111,8 @@ public String getColumnName()
 	/**
 	 * Get the user-supplied table name of this column.  This will be null
 	 * if the user did not supply a name (for example, select a from t).
+	 * The method will return B for this example, select b.a from t as b
+	 * The method will return T for this example, select t.a from t
 	 *
 	 * @return	The user-supplied name of this column.  Null if no user-
 	 * 		supplied name.
@@ -121,6 +123,19 @@ public String getTableName()
 		return ( ( tableName != null) ? tableName.getTableName() : null );
 	}
 
+	/**
+	 * Get the user-supplied schema name for this column's table. This will be null
+	 * if the user did not supply a name (for example, select t.a from t).
+	 * Another example for null return value (for example, select b.a from t as b).
+	 * But for following query select app.t.a from t, this will return APP
+	 *
+	 * @return	The schema name for this column's table
+	 */
+	public String getSchemaName() throws StandardException
+	{
+		return ( ( tableName != null) ? tableName.getSchemaName() : null );
+	}
+
 	/**
 	 * Do the code generation for this node. Should never be called.
 	 *
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
index 35aa92d2..ae610f1f 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
@@ -489,6 +489,8 @@ public void setTableNumber(int tableNumber)
 	/**
 	 * Get the user-supplied table name of this column.  This will be null
 	 * if the user did not supply a name (for example, select a from t).
+	 * The method will return B for this example, select b.a from t as b
+	 * The method will return T for this example, select t.a from t
 	 *
 	 * @return	The user-supplied name of this column.  Null if no user-
 	 * 		supplied name.
@@ -500,16 +502,45 @@ public String getTableName()
 	}
 
 	/**
-	 * Get the name of the table this column comes from.
+	 * Get the name of the underlying(base) table this column comes from, if any.
+	 * Following example queries will all return T
+	 * select a from t
+	 * select b.a from t as b
+	 * select t.a from t
 	 *
-	 * @return	The name of the table that this column comes from.  
+	 * @return	The name of the base table that this column comes from.
 	 *			Null if not a ColumnReference.
 	 */
 
 	public String getSourceTableName()
 	{
-		return ( ( tableName != null) ? tableName.getTableName() : 
-					((source != null) ? source.getTableName() : null));
+		return ((source != null) ? source.getTableName() : null);
+	}
+
+	/**
+	 * Get the name of the schema for the Column's base table, if any.
+	 * Following example queries will all return APP (assuming user is in schema APP)
+	 * select t.a from t
+	 * select b.a from t as b
+	 * select app.t.a from t
+	 *
+	 * @return	The name of the schema for Column's base table. If the column
+	 *		is not in a schema (i.e. is a derived column), it returns NULL.
+	 */
+	public String getSourceSchemaName() throws StandardException
+	{
+		return ((source != null) ? source.getSchemaName() : null);
+	}
+
+	/**
+	 * Is the column wirtable by the cursor or not. (ie, is it in the list of FOR UPDATE columns list)
+	 *
+	 * @return TRUE, if the column is a base column of a table and is 
+	 * writable by cursor.
+	 */
+	public boolean updatableByCursor()
+	{
+		return ((source != null) ? source.updatableByCursor() : false);
 	}
 
 	/**
@@ -943,6 +974,9 @@ public void generateExpression(ExpressionClassBuilder acb,
 	/**
 	 * Get the user-supplied schema name of this column.  This will be null
 	 * if the user did not supply a name (for example, select t.a from t).
+	 * Another example for null return value (for example, select b.a from t as b).
+	 * But for following query select app.t.a from t, this will return APP
+	 * Code generation of aggregate functions relies on this method
 	 *
 	 * @return	The user-supplied schema name of this column.  Null if no user-
 	 * 		supplied name.
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CursorNode.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CursorNode.java
index 3211bfa5..9ab1778b 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CursorNode.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CursorNode.java
@@ -308,6 +308,11 @@ public QueryTreeNode bind() throws StandardException
 			if (updateTable instanceof FromTable)
 			{
 				((FromTable) updateTable).markUpdatableByCursor(updatableColumns);
+				//make sure that alongwith the FromTable, we keep other ResultSetLists
+				//in correct state too. ResultSetMetaData.isWritable looks at this to
+				//return the correct value.
+				resultSet.getResultColumns().markColumnsInSelectListUpdatableByCursor(
+					updatableColumns);
 			}
 		}
 
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java
index b3f9bb48..82e5dc77 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java
@@ -3459,6 +3459,12 @@ public ResultColumnList genResultColList()
 		{
 			/* Build a ResultColumn/BaseColumnNode pair for the column */
 			colDesc = (ColumnDescriptor) cdl.elementAt(index);
+			//A ColumnDescriptor instantiated through SYSCOLUMNSRowFactory only has 
+			//the uuid set on it and no table descriptor set on it. Since we know here
+			//that this columnDescriptor is tied to tableDescriptor, set it so using
+			//setTableDescriptor method. ColumnDescriptor's table descriptor is used
+			//to get ResultSetMetaData.getTableName & ResultSetMetaData.getSchemaName
+			colDesc.setTableDescriptor(tableDescriptor);
 
 			valueNode = (ValueNode) getNodeFactory().getNode(
 											C_NodeTypes.BASE_COLUMN_NODE,
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java
index 6648ab19..3bc98912 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java
@@ -85,6 +85,8 @@
 	String			exposedName;
 	String			tableName;
 	String			sourceTableName;
+	//Used by metadata api ResultSetMetaData.getSchemaName to get a column's table's schema.
+	String			sourceSchemaName;
 	ValueNode		expression;
 	ColumnDescriptor	columnDescriptor;
 	boolean			isGenerated;
@@ -215,7 +217,7 @@ public String getName()
 		return exposedName;
 	}
 
-	public String getSchemaName()
+	public String getSchemaName() throws StandardException
 	{
 		if ((columnDescriptor!=null) && 
 			(columnDescriptor.getTableDescriptor() != null)) 
@@ -255,6 +257,14 @@ public String getSourceTableName()
 		return sourceTableName;
 	}
 
+	/**
+	 * @see ResultColumnDescriptor#getSourceSchemaName
+	 */
+	public String getSourceSchemaName()
+	{
+		return sourceSchemaName;
+	}
+
 	/**
 	 * Clear the table name for the underlying ColumnReference.
 	 * See UpdateNode for full explaination.
@@ -785,6 +795,7 @@ public void bindResultColumnToExpression()
 			ColumnReference cr = (ColumnReference) expression;
 			tableName = cr.getTableName();
 			sourceTableName = cr.getSourceTableName();
+			sourceSchemaName = cr.getSourceSchemaName();
 		}
 	}
 
@@ -1335,11 +1346,11 @@ boolean updated()
 	}
 
 	/**
-	 * Tell whether this column is updatable bay a positioned update.
+	 * Tell whether this column is updatable by a positioned update.
 	 *
 	 * @return	true means this column is updatable
 	 */
-	boolean updatableByCursor()
+	public boolean updatableByCursor()
 	{
 		return updatableByCursor;
 	}
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
index 06066faa..9a680e2b 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
@@ -2422,7 +2422,7 @@ void markUpdated()
 	}
 
 	/**
-	 * Mark all the columns in this list as updatable by a positioned update
+	 * Mark all the (base) columns in this list as updatable by a positioned update
 	 * statement.  This is necessary
 	 * for positioned update statements, because we expand the column list
 	 * to include all the columns in the base table, and we need to be able
@@ -2438,6 +2438,8 @@ void markUpdatableByCursor()
 
 		for (int index = 0; index < size; index++)
 		{
+			//determine if the column is a base column and not a derived column
+			if (((ResultColumn) elementAt(index)).getSourceTableName() != null)
 			((ResultColumn) elementAt(index)).markUpdatableByCursor();
 		}
 	}
@@ -2615,17 +2617,33 @@ void markUpdated(ResultColumnList updateColumns)
 	}
 
 	/**
-	 * Mark as updatable all the columns in this result column list
-	 * that match the columns in the given update column list
+	 * Mark all the columns in the select sql that this result column list represents
+	 * as updatable if they match the columns in the given update column list.
 	 *
 	 * @param updateColumns		A Vector representing the columns
 	 *							to be updated.
 	 */
-	void markUpdatableByCursor(Vector updateColumns)
+	void markColumnsInSelectListUpdatableByCursor(Vector updateColumns)
+	{
+		commonCodeForUpdatableByCursor(updateColumns, true);
+	}
+
+	/**
+	 * dealingWithSelectResultColumnList true means we are dealing with
+	 * ResultColumnList for a select sql. When dealing with ResultColumnList for
+	 * select sql, it is possible that not all the updatable columns are
+	 * projected in the select column list and hence it is possible that we may
+	 * not find the column to be updated in the ResultColumnList and that is why
+	 * special handling is required when dealingWithSelectResultColumnList is true.
+	 * eg select c11, c13 from t1 for update of c11, c12
+	 * In the eg above, we will find updatable column c11 in the select column
+	 * list but we will not find updatable column c12 in the select column list
+	 */
+	private void commonCodeForUpdatableByCursor(Vector updateColumns, boolean dealingWithSelectResultColumnList)
 	{
 		/*
-		** If there is no update column list, or the list is empty,
-		** it means all the columns are updatable.
+		** If there is no update column list, or the list is empty, then it means that
+		** all the columns which have a base table associated with them are updatable.
 		*/
 		if ( (updateColumns == null) || (updateColumns.size() == 0) )
 		{
@@ -2642,22 +2660,35 @@ void markUpdatableByCursor(Vector updateColumns)
 				columnName = (String) updateColumns.elementAt(index); 
 
 				resultColumn = getResultColumn(columnName);
-
 				if (SanityManager.DEBUG)
 				{
-					if (resultColumn == null)
+					if (resultColumn == null && !dealingWithSelectResultColumnList)
 					{
-						SanityManager.THROWASSERT(
-							"No result column found with name " +
+						SanityManager.THROWASSERT("No result column found with name " +
 							columnName);
 					}
 				}
-
+				//Following if means the column specified in FOR UPDATE clause is not
+				//part of the select list
+				if (resultColumn == null && dealingWithSelectResultColumnList)
+					continue;
 				resultColumn.markUpdatableByCursor();
 			}
 		}
 	}
 
+	/**
+	 * Mark as updatable all the columns in this result column list
+	 * that match the columns in the given update column list
+	 *
+	 * @param updateColumns		A Vector representing the columns
+	 *							to be updated.
+	 */
+	void markUpdatableByCursor(Vector updateColumns)
+	{
+		commonCodeForUpdatableByCursor(updateColumns, false);
+	}
+
 	/**
 	 * Returns true if the given column position is for a column that will
 	 * be or could be updated by the positioned update of a cursor.
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java
index 139ca02b..63d102f9 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java
@@ -661,6 +661,11 @@ public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
 	}
 
 	/**
+	 * This returns the user-supplied schema name of the column.
+	 * At this class level, it simply returns null. But, the subclasses
+	 * of ValueNode will overwrite this method to return the
+	 * user-supplied schema name.
+	 * 
 	 * When the value node is in a result column of a select list,
 	 * the user can request metadata information. The result column
 	 * won't have a column descriptor, so we return some default
@@ -670,19 +675,39 @@ public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
 	 *
 	 * @return the default schema name for an expression -- null
 	 */
-	public String getSchemaName()
+	public String getSchemaName() throws StandardException
 	{
 		return null;
 	}
 
 	/**
-	 * @return the default schema name for an expression -- null
+	 * This returns the user-supplied table name of the column.
+	 * At this class level, it simply returns null. But, the subclasses
+	 * of ValueNode will overwrite this method to return the
+	 * user-supplied table name.
+	 *
+	 * When the value node is in a result column of a select list,
+	 * the user can request metadata information. The result column
+	 * won't have a column descriptor, so we return some default
+	 * information through the expression. This lets expressions that
+	 * are simply columns return all of the info, and others use
+	 * this supertype's default values.
+	 *
+	 * @return the default table name for an expression -- null
 	 */
 	public String getTableName()
 	{
 		return null;
 	}
 
+	/**
+	 * @return the default updatability for an expression - false
+	 */
+	public boolean updatableByCursor()
+	{
+		return false;
+	}
+
 	/**
 	 * This is null so that the caller will substitute in the resultset generated
 	 * name as needed.
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java
index 59a92f64..a540acb8 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java
@@ -122,6 +122,47 @@ public ResultColumn getSourceColumn()
 		return sourceColumn;
 	}
 
+	/**
+	 * Get the name of the table the ResultColumn is in, if any.  This will be null
+	 * if the user did not supply a name (for example, select a from t).
+	 * The method will return B for this example, select b.a from t as b
+	 * The method will return T for this example, select t.a from t
+	 *
+	 * @return	A String containing the name of the table the Column
+	 *		is in. If the column is not in a table (i.e. is a
+	 * 		derived column), it returns NULL.
+	 */
+	public String getTableName()
+	{
+		return ( ( sourceColumn != null) ? sourceColumn.getTableName() : null );
+	}
+
+	/**
+	 * Get the name of the schema the ResultColumn's table is in, if any.
+	 * The return value will be null if the user did not supply a schema name
+	 * (for example, select t.a from t).
+	 * Another example for null return value (for example, select b.a from t as b).
+	 * But for following query select app.t.a from t, this will return APP
+	 *
+	 * @return	A String containing the name of the schema for the Column's table.
+	 *		If the column is not in a schema (i.e. derived column), it returns NULL.
+	 */
+	public String getSchemaName() throws StandardException
+	{
+		return ( ( sourceColumn != null) ? sourceColumn.getSchemaName() : null );
+	}
+
+	/**
+	 * Return whether or not the ResultColumn is wirtable by a positioned update.
+	 *
+	 * @return TRUE, if the column is a base column of a table and is 
+	 * writable by a positioned update.
+	 */
+	public boolean updatableByCursor()
+	{
+		return ((sourceColumn != null) ? sourceColumn.updatableByCursor() : false);
+	}
+
 	/**
 	 * Return the ResultColumn that is the source of this VirtualColumnNode.
 	 *
diff --git a/incubator/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/resultset.java b/incubator/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/resultset.java
index f1f14589..fe227636 100644
--- a/incubator/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/resultset.java
+++ b/incubator/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/resultset.java
@@ -525,6 +525,7 @@ public static void main(String[] args) {
 			stmt.close();
 
 			testMutableValues(con);
+			testCorrelationNamesAndMetaDataCalls(con);
 			con.close();
 
 		}
@@ -541,6 +542,64 @@ public static void main(String[] args) {
     }
 
 
+	static private void testCorrelationNamesAndMetaDataCalls(Connection conn) throws Exception
+	{
+		Statement stmt = conn.createStatement();
+		stmt.executeUpdate("create table s (a int, b int, c int, d int, e int, f int)");
+		stmt.executeUpdate("insert into s values (0,1,2,3,4,5)");
+		stmt.executeUpdate("insert into s values (10,11,12,13,14,15)");
+		System.out.println("Run select * from s ss (f, e, d, c, b, a) where f = 0 and then try getTableName and getSchemaName on columns");
+		ResultSet rs = stmt.executeQuery("select * from s ss (f, e, d, c, b, a) where f = 0");
+    rs.next();
+    ResultSetMetaData met = rs.getMetaData();
+		System.out.println("getTableName(1): "+met.getTableName(1));
+		System.out.println("getSchemaName(1): "+met.getSchemaName(1));
+
+		System.out.println("Run select * from (select * from s) a and then try getTableName and getSchemaName on columns");
+		rs = stmt.executeQuery("select * from (select * from s) a");
+    rs.next();
+    met = rs.getMetaData();
+		System.out.println("getTableName(1): "+met.getTableName(1));
+		System.out.println("getSchemaName(1): "+met.getSchemaName(1));
+
+		stmt.executeUpdate("create schema s1");
+		stmt.executeUpdate("create table s1.t1 (c11 int, c12 int)");
+		stmt.executeUpdate("insert into s1.t1 values (11, 12), (21, 22)");
+		System.out.println("Run select * from s1.t1 as abc and then try getTableName and getSchemaName on columns");
+		rs = stmt.executeQuery("select * from s1.t1 as abc");
+		met = rs.getMetaData();
+		System.out.println("Table name of first column is " + met.getTableName(1));
+		System.out.println("Schema name of first column is " + met.getSchemaName(1));
+		System.out.println("Table name of second column is " + met.getTableName(2));
+		System.out.println("Schema name of second column is " + met.getSchemaName(2));
+		System.out.println("Run select abc.c11 from s1.t1 as abc and then try getTableName and getSchemaName on columns");
+		rs = stmt.executeQuery("select abc.c11 from s1.t1 as abc");
+		met = rs.getMetaData();
+		System.out.println("Table name of first column is " + met.getTableName(1));
+		System.out.println("Schema name of first column is " + met.getSchemaName(1));
+		System.out.println("Run select bcd.a, abc.c11 from s1.t1 as abc, s as bcd and then try getTableName and getSchemaName on columns");
+		rs = stmt.executeQuery("select bcd.a, abc.c11 from s1.t1 as abc, s as bcd");
+		met = rs.getMetaData();
+		System.out.println("Table name of first column is " + met.getTableName(1));
+		System.out.println("Schema name of first column is " + met.getSchemaName(1));
+		System.out.println("Table name of second column is " + met.getTableName(2));
+		System.out.println("Schema name of second column is " + met.getSchemaName(2));
+
+		stmt.executeUpdate("create schema app1");
+		stmt.executeUpdate("create table app1.t1 (c11 int, c12 int)");
+		stmt.executeUpdate("insert into app1.t1 values (11, 12), (21, 22)");
+		stmt.executeUpdate("create schema app2");
+		stmt.executeUpdate("create table app2.t1 (c11 int, c12 int)");
+		stmt.executeUpdate("insert into app2.t1 values (11, 12), (21, 22)");
+		System.out.println("Run select app1.t1.c11, app2.t1.c11 from app1.t1, app2.t1 and then try getTableName and getSchemaName on columns");
+		rs = stmt.executeQuery("select app1.t1.c11, app2.t1.c11 from app1.t1, app2.t1");
+		met = rs.getMetaData();
+		System.out.println("Table name of first column is " + met.getTableName(1));
+		System.out.println("Schema name of first column is " + met.getSchemaName(1));
+		System.out.println("Table name of second column is " + met.getTableName(2));
+		System.out.println("Schema name of second column is " + met.getSchemaName(2));
+	}
+
 	static private void doTheTests() throws Exception
 	{
 
diff --git a/incubator/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/updatableResultSet.java b/incubator/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/updatableResultSet.java
index c7a232e4..ff2ec1f6 100644
--- a/incubator/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/updatableResultSet.java
+++ b/incubator/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/updatableResultSet.java
@@ -33,8 +33,8 @@
 
 import org.apache.derby.tools.ij;
 import org.apache.derby.tools.JDBCDisplayUtil;
-import org.apache.derbyTesting.functionTests.util.TestUtil;
 import org.apache.derby.iapi.services.info.JVMInfo;
+import org.apache.derbyTesting.functionTests.util.TestUtil;
 
 import java.math.BigDecimal;
 import java.sql.Array;
@@ -154,7 +154,7 @@
 
 
 	//I have constructed following table based on if combination of datatype and updateXXX method would work or not.
-	public static final String[][]  updateXXXRulesTable = {
+	public static final String[][]  updateXXXRulesTableForEmbedded = {
 
   // Types.             u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u
 	//                    p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p
@@ -196,6 +196,49 @@
 
 	};                                                                         
 
+	//I have constructed following table for network server based on if combination of datatype and updateXXX method would work or not.
+	public static final String[][]  updateXXXRulesTableForNetworkServer = {
+
+  // Types.             u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u  u
+	//                    p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p  p
+	//                    d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d  d
+  //                    a  a  a  a  a  a  a  a  a  a  a  a  a  a  a  a  a  a  a  a  a
+  //                    t  t  t  t  t  t  t  t  t  t  t  t  t  t  t  t  t  t  t  t  t
+  //                    e  e  e  e  e  e  e  e  e  e  e  e  e  e  e  e  e  e  e  e  e
+  //                    S  I  L  B  F  D  S  A  C  B  B  B  C  D  T  T  B  B  N  A  R
+	//                    h  n  o  i  l  o  t  s  h  y  y  i  l  a  i  i  l  o  u  r  e
+	//                    o  t  n  g  o  u  r  c  a  t  t  n  o  t  m  m  o  o  l  r  f
+	//                    r     g  D  a  b  i  i  r  e  e  a  b  e  e  e  b  l  l  a
+	//                    t        e  t  l  n  i  c     s  r           s     e     y
+	//                             c     e  g  S  t        y           t     a
+	//                             i           t  e        S           a     n
+	//                             m           r  r        t           m
+	//                             a           e  S        r           p
+	//                             l           a  t        e
+	//                                         m  r        a
+	//                                            e        m
+	//                                            a
+	//                                            m
+/* 0 SMALLINT */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 1 INTEGER  */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 2 BIGINT   */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 3 DECIMAL  */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 4 REAL     */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 5 DOUBLE   */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 6 CHAR     */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "PASS", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 7 VARCHAR  */        { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "PASS", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 8 LONGVARCHAR */     { "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "PASS", "ERROR", "PASS", "PASS", "ERROR", "ERROR" },
+/* 9 CHAR FOR BIT */    { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+/* 10 VARCH. BIT   */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+/* 11 LONGVAR. BIT */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+/* 12 CLOB         */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+/* 13 DATE         */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "PASS", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+/* 14 TIME         */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+/* 15 TIMESTAMP    */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "PASS", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+/* 16 BLOB         */   { "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "PASS", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "ERROR", "PASS", "ERROR", "ERROR" },
+
+	};
+
 	public static void main(String[] args) {
 		System.out.println("Start testing delete and update using JDBC2.0 updateable resultset apis");
 
@@ -334,6 +377,7 @@ public static void main(String[] args) {
 			//have to close the resultset because by default, resultsets are held open over commit
 			rs.close();
 
+
 			System.out.println("Negative Test5 - request updatable resultset for sql with no FOR UPDATE clause");
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
 			rs = stmt.executeQuery("select * from t1");//notice that we forgot to give mandatory FOR UPDATE clause for updatable resultset
@@ -357,8 +401,6 @@ public static void main(String[] args) {
 				System.out.println("SQL State : " + e.getSQLState());
 				System.out.println("Got expected exception " + e.getMessage());
 			}
-			//have to close the resultset because by default, resultsets are held open over commit
-			rs.close();
       System.out.println("Now attempting to send a updateRow on a sql with no FOR UPDATE clause.");
 			try {
 				rs.updateRow();
@@ -369,10 +411,15 @@ public static void main(String[] args) {
 				System.out.println("Got expected exception " + e.getMessage());
 			}
 
+			//have to close the resultset because by default, resultsets are held open over commit
+			rs.close();
+
 			System.out.println("Negative Test6 - request updatable resultset for sql with FOR READ ONLY clause");
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
 			rs = stmt.executeQuery("select * from t1 FOR READ ONLY");
 			System.out.println("Make sure that we got CONCUR_READ_ONLY? " + (rs.getConcurrency() == ResultSet.CONCUR_READ_ONLY));
+			System.out.println("Jira issue Derby-159 : Warnings raised by Derby are not getting passed to the Client in Network Server Mode");
+			System.out.println("Will see the warnings in embedded mode only");
 			warnings = rs.getWarnings();
 			while (warnings != null)
 			{
@@ -402,10 +449,9 @@ public static void main(String[] args) {
 			//have to close the resultset because by default, resultsets are held open over commit
 			rs.close();
 
-			if (TestUtil.isEmbeddedFramework()) {
 			System.out.println("Negative Test7 - attempt to deleteRow & updateRow on updatable resultset when the resultset is not positioned on a row");
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
-      rs = stmt.executeQuery("SELECT 1, 2 FROM t1 FOR UPDATE");
+      rs = stmt.executeQuery("SELECT * FROM t1 FOR UPDATE");
 			System.out.println("Make sure that we got CONCUR_UPDATABLE? " + (rs.getConcurrency() == ResultSet.CONCUR_UPDATABLE));
       System.out.println("Now attempt a deleteRow without first doing next on the resultset.");
 			try {
@@ -417,9 +463,14 @@ public static void main(String[] args) {
 				System.out.println("Got expected exception " + e.getMessage());
 			}
       System.out.println("Now attempt a updateRow without first doing next on the resultset.");
+			System.out.println("In embedded mode, updateRow will check if it is on a row or not even though no changes have been made to the row using updateXXX");
+			System.out.println("In Network Server mode, if no updateXXX were issued before updateRow, then updateRow is a no-op and doesn't check if it is on a row or not");
 			try {
 				rs.updateRow();
-				System.out.println("FAIL!!! updateRow should have failed because resultset is not on a row");
+				if (TestUtil.isEmbeddedFramework()) 
+					System.out.println("FAIL!!! In embedded mode, this updateRow should have failed because resultset is not on a row");
+				else
+					System.out.println("PASS!!! In Network Server mode, this updateRow is a no-op because no updateXXX were issued before the updateRow");
 			}
 			catch (SQLException e) {
 				System.out.println("SQL State : " + e.getSQLState());
@@ -448,7 +499,7 @@ public static void main(String[] args) {
 
 			System.out.println("Negative Test8 - attempt deleteRow & updateRow on updatable resultset after closing the resultset");
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
-      rs = stmt.executeQuery("SELECT 1, 2 FROM t1 FOR UPDATE");
+      rs = stmt.executeQuery("SELECT * FROM t1 FOR UPDATE");
 			System.out.println("Make sure that we got CONCUR_UPDATABLE? " + (rs.getConcurrency() == ResultSet.CONCUR_UPDATABLE));
 			rs.next();
 			rs.close();
@@ -503,8 +554,9 @@ public static void main(String[] args) {
 
 			System.out.println("Negative Test12 - With autocommit on, attempt to drop a table when there is an open updatable resultset on it");
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
-      rs = stmt.executeQuery("SELECT 1, 2 FROM t1 FOR UPDATE");
+      rs = stmt.executeQuery("SELECT c1 FROM t1 FOR UPDATE");
 			rs.next();
+			rs.updateInt(1,123);
 			System.out.println("Opened an updatable resultset. Now trying to drop that table through another Statement");
 			stmt1 = conn.createStatement();
 			try {
@@ -535,7 +587,7 @@ public static void main(String[] args) {
 
 			System.out.println("Negative Test13 - foreign key constraint failure will cause deleteRow to fail");
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
-      rs = stmt.executeQuery("SELECT 1, 2 FROM tableWithPrimaryKey FOR UPDATE");
+      rs = stmt.executeQuery("SELECT * FROM tableWithPrimaryKey FOR UPDATE");
 			rs.next();
 			try {
 				rs.deleteRow();
@@ -548,6 +600,8 @@ public static void main(String[] args) {
 			System.out.println("Since autocommit is on, the constraint exception resulted in a runtime rollback causing updatable resultset object to close");
 			try {
 				rs.next();
+				if (TestUtil.isNetFramework())
+					System.out.println("Jira entry Derby-160 : for Network Server because next should have failed");
 				System.out.println("FAIL!!! next should have failed because foreign key constraint failure resulted in a runtime rollback");
 			}
 			catch (SQLException e) {
@@ -572,6 +626,8 @@ public static void main(String[] args) {
 			System.out.println("Since autocommit is on, the constraint exception resulted in a runtime rollback causing updatable resultset object to close");
 			try {
 				rs.next();
+				if (TestUtil.isNetFramework())
+					System.out.println("Jira entry Derby-160 : for Network Server because next should have failed");
 				System.out.println("FAIL!!! next should have failed because foreign key constraint failure resulted in a runtime rollback");
 			}
 			catch (SQLException e) {
@@ -581,7 +637,7 @@ public static void main(String[] args) {
 
 			System.out.println("Negative Test15 - Can't call updateXXX methods on columns that do not correspond to a column in the table");
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
-			rs = stmt.executeQuery("SELECT 1, 2 FROM tableWithPrimaryKey FOR UPDATE");
+			rs = stmt.executeQuery("SELECT 1, 2 FROM t1 FOR UPDATE");
 			rs.next();
 			try {
 				rs.updateInt(1,22);
@@ -623,13 +679,17 @@ public static void main(String[] args) {
       System.out.println("column 1 on this row before deleteRow is " + rs.getInt(1));
       System.out.println("column 2 on this row before deleteRow is " + rs.getString(2));
 			rs.deleteRow();
-      System.out.println("Since after deleteRow(), ResultSet is positioned before the next row, getXXX will fail");
+      System.out.println("Since after deleteRow(), in embedded mode, ResultSet is positioned before the next row, getXXX will fail");
+      System.out.println("In Network Server mode, the ResultSet stays on the deleted row after deleteRow and hence no error for getXXX");
 			try {
 				System.out.println("column 1 on this deleted row is " + rs.getInt(1));
 			}
 			catch (SQLException e) {
+				if (TestUtil.isEmbeddedFramework()) {
 				System.out.println("SQL State : " + e.getSQLState());
 				System.out.println("Got expected exception " + e.getMessage());
+				} else
+					System.out.println("Got unexpected exception " + e.getMessage());
 			}
       System.out.println("calling deleteRow again w/o first positioning the ResultSet on the next row will fail");
 			try {
@@ -647,6 +707,7 @@ public static void main(String[] args) {
 			//have to close the resultset because by default, resultsets are held open over commit
 			rs.close();
 
+			if (TestUtil.isEmbeddedFramework()) {
 			System.out.println("Positive Test1b - request updatable resultset for forward only type resultset");
 			reloadData();
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
@@ -664,7 +725,8 @@ public static void main(String[] args) {
 			System.out.println("column 2 on this row before updateString is " + rs.getString(2));
 			System.out.println("now updateRow on the row");
 			rs.updateRow();
-			System.out.println("Since after updateRow(), ResultSet is positioned before the next row, getXXX will fail");
+			System.out.println("Since after updateRow(), in embedded mode, ResultSet is positioned before the next row, getXXX will fail");
+      System.out.println("In Network Server mode, the ResultSet stays on the updated row after updateRow and hence no error for getXXX");
 			try {
 				System.out.println("column 1 on this updateRow row is " + rs.getInt(1));
 			}
@@ -975,19 +1037,56 @@ public static void main(String[] args) {
 			reloadData();
 			rs = stmt.executeQuery("SELECT c1, c2 FROM t1 abcde FOR UPDATE of c1");
 			rs.next();
-			rs.updateString(2,"bbbb");
 			try {
-				rs.updateRow();
-				System.out.println("FAIL!!! updateRow should have failed");
+				rs.updateString(2,"bbbb");
+				System.out.println("FAIL!!! updateString on readonly column should have failed");
 			}
 			catch (SQLException e) {
 				System.out.println("SQL State : " + e.getSQLState());
 				System.out.println("Got expected exception " + e.getMessage());
 			}
+			System.out.println("attempt to get an updatable resultset using correlation name for an readonly column. It should work");
+			System.out.println("The sql is SELECT c1, c2 as col2 FROM t1 abcde FOR UPDATE of c1");
+			rs = stmt.executeQuery("SELECT c1, c2 as col2 FROM t1 abcde FOR UPDATE of c1");
+			rs.next();
+			rs.updateInt(1,11);
+			rs.updateRow();
 			rs.close();
 			System.out.println("Table t1 after updateRow has following rows");
 			dumpRS(stmt.executeQuery("select * from t1"));
 
+			System.out.println("Positive Test9c - try to updateXXX on a readonly column. Should get error");
+			reloadData();
+			rs = stmt.executeQuery("SELECT c1, c2 FROM t1 abcde FOR UPDATE of c1");
+			rs.next();
+			try {
+				rs.updateString(2,"bbbb");
+				System.out.println("FAIL!!! updateString on readonly column should have failed");
+			}
+			catch (SQLException e) {
+				System.out.println("SQL State : " + e.getSQLState());
+				System.out.println("Got expected exception " + e.getMessage());
+			}
+			rs.close();
+			System.out.println("Table t1 has following rows");
+			dumpRS(stmt.executeQuery("select * from t1"));
+
+			System.out.println("Positive Test9d - try to updateXXX on a readonly column with correlation name. Should get error");
+			reloadData();
+			rs = stmt.executeQuery("SELECT c1, c2 as col2 FROM t1 abcde FOR UPDATE of c1");
+			rs.next();
+			try {
+				rs.updateString(2,"bbbb");
+				System.out.println("FAIL!!! updateString on readonly column should have failed");
+			}
+			catch (SQLException e) {
+				System.out.println("SQL State : " + e.getSQLState());
+				System.out.println("Got expected exception " + e.getMessage());
+			}
+			rs.close();
+			System.out.println("Table t1 has following rows");
+			dumpRS(stmt.executeQuery("select * from t1"));
+
 			System.out.println("Positive Test10 - 2 updatable resultsets going against the same table, will they conflict?");
 			conn.setAutoCommit(false);
       reloadData();
@@ -1543,7 +1642,7 @@ public static void main(String[] args) {
 									rs.updateRef(ColumnNames[sqlType-1], null);
               }
 							rs.updateRow();
-							if (updateXXXRulesTable[sqlType-1][updateXXXName-1].equals("ERROR")) {
+							if (updateXXXRulesTableForEmbedded[sqlType-1][updateXXXName-1].equals("ERROR")) {
 								System.out.println("FAILURE : We shouldn't reach here. The test should have failed earlier on updateXXX or updateRow call");
 								return;
 							}
@@ -1553,7 +1652,7 @@ public static void main(String[] args) {
 								return;
 							}
 						} catch (Throwable e) {
-							if (updateXXXRulesTable[sqlType-1][updateXXXName-1].equals("ERROR"))
+							if (updateXXXRulesTableForEmbedded[sqlType-1][updateXXXName-1].equals("ERROR"))
 								System.out.println("      Got expected exception : " + e.getMessage());
 							else {
 								if ((sqlType == 14 || sqlType == 15 || sqlType == 16) && //we are dealing with DATE/TIME/TIMESTAMP column types
@@ -1696,7 +1795,7 @@ else if (updateXXXName == 11){ //update column with updateBytes methods
 									continue;
 
 								rs.updateRow();
-								if (updateXXXRulesTable[sqlType-1][updateXXXName-1].equals("ERROR")) {
+								if (updateXXXRulesTableForEmbedded[sqlType-1][updateXXXName-1].equals("ERROR")) {
 									System.out.println("FAILURE : We shouldn't reach here. The test should have failed earlier on updateXXX or updateRow call");
 									return;
 								}
@@ -1706,7 +1805,7 @@ else if (updateXXXName == 11){ //update column with updateBytes methods
 									return;
 								}
 						} catch (Throwable e) {
-								if (updateXXXRulesTable[sqlType-1][updateXXXName-1].equals("ERROR"))
+								if (updateXXXRulesTableForEmbedded[sqlType-1][updateXXXName-1].equals("ERROR"))
 									System.out.println("    Got expected exception : " + e.getMessage());
 								else {
 									if ((sqlType == 14 || sqlType == 15 || sqlType == 16) && //we are dealing with DATE/TIME/TIMESTAMP column types
@@ -2065,10 +2164,9 @@ else if (updateXXXName == 11){ //update column with updateBytes methods
 			stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
 			rs = stmt.executeQuery("SELECT c1, c2 FROM t1 FOR UPDATE of c1");
 			rs.next();
-			rs.updateInt(2,22);
 			try {
-				rs.updateRow();
-				System.out.println("FAIL!!! updateRow should have failed because c12 is not the FOR UPDATE columns list.");
+				rs.updateInt(2,22);
+				System.out.println("FAIL!!! updateInt should have failed because c12 is not the FOR UPDATE columns list.");
 			}
 			catch (SQLException e) {
 				System.out.println("SQL State : " + e.getSQLState());
