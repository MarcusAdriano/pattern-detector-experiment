diff --git a/aries/trunk/application/application-deployment-management/src/main/java/org/apache/aries/application/deployment/management/impl/DeploymentManifestManagerImpl.java b/aries/trunk/application/application-deployment-management/src/main/java/org/apache/aries/application/deployment/management/impl/DeploymentManifestManagerImpl.java
index 1723b3f3..b9d1553f 100644
--- a/aries/trunk/application/application-deployment-management/src/main/java/org/apache/aries/application/deployment/management/impl/DeploymentManifestManagerImpl.java
+++ b/aries/trunk/application/application-deployment-management/src/main/java/org/apache/aries/application/deployment/management/impl/DeploymentManifestManagerImpl.java
@@ -66,7 +66,7 @@
 import org.apache.aries.application.utils.AppConstants;
 import org.apache.aries.application.utils.manifest.ContentFactory;
 import org.apache.aries.util.filesystem.FileSystem;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 import org.apache.aries.util.manifest.ManifestHeaderProcessor;
 import org.osgi.framework.Constants;
 import org.osgi.framework.Filter;
diff --git a/aries/trunk/application/application-management/src/main/java/org/apache/aries/application/management/impl/AriesApplicationImpl.java b/aries/trunk/application/application-management/src/main/java/org/apache/aries/application/management/impl/AriesApplicationImpl.java
index 9824be5e..8dc1f3f1 100644
--- a/aries/trunk/application/application-management/src/main/java/org/apache/aries/application/management/impl/AriesApplicationImpl.java
+++ b/aries/trunk/application/application-management/src/main/java/org/apache/aries/application/management/impl/AriesApplicationImpl.java
@@ -39,7 +39,7 @@
 import org.apache.aries.application.management.spi.convert.BundleConversion;
 import org.apache.aries.application.management.spi.runtime.LocalPlatform;
 import org.apache.aries.application.utils.AppConstants;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/aries/trunk/application/application-management/src/main/java/org/apache/aries/application/management/impl/AriesApplicationManagerImpl.java b/aries/trunk/application/application-management/src/main/java/org/apache/aries/application/management/impl/AriesApplicationManagerImpl.java
index 8434d5dd..b7a60d52 100644
--- a/aries/trunk/application/application-management/src/main/java/org/apache/aries/application/management/impl/AriesApplicationManagerImpl.java
+++ b/aries/trunk/application/application-management/src/main/java/org/apache/aries/application/management/impl/AriesApplicationManagerImpl.java
@@ -66,7 +66,7 @@
 import org.apache.aries.util.filesystem.FileSystem;
 import org.apache.aries.util.filesystem.IDirectory;
 import org.apache.aries.util.filesystem.IFile;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 import org.apache.aries.util.manifest.BundleManifest;
 import org.apache.aries.util.manifest.ManifestProcessor;
 import org.osgi.framework.BundleContext;
diff --git a/aries/trunk/application/application-management/src/test/java/org/apache/aries/application/management/impl/AriesApplicationManagerImplTest.java b/aries/trunk/application/application-management/src/test/java/org/apache/aries/application/management/impl/AriesApplicationManagerImplTest.java
index 6e562a81..eef48467 100644
--- a/aries/trunk/application/application-management/src/test/java/org/apache/aries/application/management/impl/AriesApplicationManagerImplTest.java
+++ b/aries/trunk/application/application-management/src/test/java/org/apache/aries/application/management/impl/AriesApplicationManagerImplTest.java
@@ -76,7 +76,7 @@
 import org.apache.aries.util.filesystem.FileSystem;
 import org.apache.aries.util.filesystem.IDirectory;
 import org.apache.aries.util.filesystem.IFile;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 import org.apache.aries.util.manifest.BundleManifest;
 import org.junit.Before;
 import org.junit.BeforeClass;
diff --git a/aries/trunk/application/application-management/src/test/java/org/apache/aries/unittest/utils/EbaUnitTestUtils.java b/aries/trunk/application/application-management/src/test/java/org/apache/aries/unittest/utils/EbaUnitTestUtils.java
index 792651f4..50c068ac 100644
--- a/aries/trunk/application/application-management/src/test/java/org/apache/aries/unittest/utils/EbaUnitTestUtils.java
+++ b/aries/trunk/application/application-management/src/test/java/org/apache/aries/unittest/utils/EbaUnitTestUtils.java
@@ -25,7 +25,7 @@
 import java.util.jar.Attributes;
 import java.util.jar.Manifest;
 
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 
 public class EbaUnitTestUtils {
 
diff --git a/aries/trunk/application/application-modeller/src/main/java/org/apache/aries/application/modelling/impl/ModelledResourceManagerImpl.java b/aries/trunk/application/application-modeller/src/main/java/org/apache/aries/application/modelling/impl/ModelledResourceManagerImpl.java
index f60a0f96..1ab29318 100644
--- a/aries/trunk/application/application-modeller/src/main/java/org/apache/aries/application/modelling/impl/ModelledResourceManagerImpl.java
+++ b/aries/trunk/application/application-modeller/src/main/java/org/apache/aries/application/modelling/impl/ModelledResourceManagerImpl.java
@@ -49,7 +49,7 @@
 import org.apache.aries.application.modelling.internal.MessageUtil;
 import org.apache.aries.util.filesystem.IDirectory;
 import org.apache.aries.util.filesystem.IFile;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 import org.apache.aries.util.manifest.BundleManifest;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
diff --git a/aries/trunk/application/application-modeller-common-test/src/test/java/org/apache/aries/application/modelling/ModellerTest.java b/aries/trunk/application/application-modeller-common-test/src/test/java/org/apache/aries/application/modelling/ModellerTest.java
index f7f50067..650fc8d9 100644
--- a/aries/trunk/application/application-modeller-common-test/src/test/java/org/apache/aries/application/modelling/ModellerTest.java
+++ b/aries/trunk/application/application-modeller-common-test/src/test/java/org/apache/aries/application/modelling/ModellerTest.java
@@ -20,7 +20,7 @@
 import org.apache.aries.application.modelling.standalone.OfflineModellingFactory;
 import org.apache.aries.mocks.BundleContextMock;
 import org.apache.aries.util.filesystem.FileSystem;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
diff --git a/aries/trunk/application/application-obr-resolver/src/main/java/org/apache/aries/application/resolver/obr/OBRAriesResolver.java b/aries/trunk/application/application-obr-resolver/src/main/java/org/apache/aries/application/resolver/obr/OBRAriesResolver.java
index 9ea8594d..3fe38593 100644
--- a/aries/trunk/application/application-obr-resolver/src/main/java/org/apache/aries/application/resolver/obr/OBRAriesResolver.java
+++ b/aries/trunk/application/application-obr-resolver/src/main/java/org/apache/aries/application/resolver/obr/OBRAriesResolver.java
@@ -62,7 +62,7 @@
 import org.apache.aries.application.utils.AppConstants;
 import org.apache.aries.application.utils.manifest.ContentFactory;
 import org.apache.aries.util.VersionRange;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 import org.apache.aries.util.manifest.ManifestHeaderProcessor;
 import org.apache.felix.bundlerepository.Capability;
 import org.apache.felix.bundlerepository.DataModelHelper;
diff --git a/aries/trunk/application/application-obr-resolver/src/main/java/org/apache/aries/application/resolver/obr/impl/RepositoryGeneratorImpl.java b/aries/trunk/application/application-obr-resolver/src/main/java/org/apache/aries/application/resolver/obr/impl/RepositoryGeneratorImpl.java
index 77bf1885..e05a708f 100644
--- a/aries/trunk/application/application-obr-resolver/src/main/java/org/apache/aries/application/resolver/obr/impl/RepositoryGeneratorImpl.java
+++ b/aries/trunk/application/application-obr-resolver/src/main/java/org/apache/aries/application/resolver/obr/impl/RepositoryGeneratorImpl.java
@@ -54,7 +54,7 @@
 import org.apache.aries.util.filesystem.FileSystem;
 import org.apache.aries.util.filesystem.FileUtils;
 import org.apache.aries.util.filesystem.IDirectory;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 import org.apache.felix.bundlerepository.Capability;
 import org.apache.felix.bundlerepository.Property;
 import org.apache.felix.bundlerepository.RepositoryAdmin;
diff --git a/aries/trunk/application/application-utils/src/main/java/org/apache/aries/application/impl/DeploymentMetadataFactoryImpl.java b/aries/trunk/application/application-utils/src/main/java/org/apache/aries/application/impl/DeploymentMetadataFactoryImpl.java
index ad85c959..1cbb2880 100644
--- a/aries/trunk/application/application-utils/src/main/java/org/apache/aries/application/impl/DeploymentMetadataFactoryImpl.java
+++ b/aries/trunk/application/application-utils/src/main/java/org/apache/aries/application/impl/DeploymentMetadataFactoryImpl.java
@@ -31,7 +31,7 @@
 import org.apache.aries.application.management.BundleInfo;
 import org.apache.aries.application.management.ResolverException;
 import org.apache.aries.util.filesystem.IFile;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 import org.apache.aries.util.manifest.ManifestProcessor;
 
 public class DeploymentMetadataFactoryImpl implements DeploymentMetadataFactory
diff --git a/aries/trunk/jpa/jpa-container/src/main/java/org/apache/aries/jpa/container/parsing/impl/PersistenceDescriptorParserImpl.java b/aries/trunk/jpa/jpa-container/src/main/java/org/apache/aries/jpa/container/parsing/impl/PersistenceDescriptorParserImpl.java
index dd29b7c1..35e58df9 100644
--- a/aries/trunk/jpa/jpa-container/src/main/java/org/apache/aries/jpa/container/parsing/impl/PersistenceDescriptorParserImpl.java
+++ b/aries/trunk/jpa/jpa-container/src/main/java/org/apache/aries/jpa/container/parsing/impl/PersistenceDescriptorParserImpl.java
@@ -20,7 +20,6 @@
 package org.apache.aries.jpa.container.parsing.impl;
 
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Collection;
 
@@ -32,6 +31,7 @@
 import org.apache.aries.jpa.container.parsing.PersistenceDescriptor;
 import org.apache.aries.jpa.container.parsing.PersistenceDescriptorParser;
 import org.apache.aries.jpa.container.parsing.PersistenceDescriptorParserException;
+import org.apache.aries.util.io.RememberingInputStream;
 import org.osgi.framework.Bundle;
 
 /**
@@ -40,152 +40,13 @@
  */
 public class PersistenceDescriptorParserImpl implements PersistenceDescriptorParser {
 
-  /**
-   * This class is used internally to prevent the first pass parse from
-   * closing the InputStream when it exits.
-   */
-  private static class RememberingInputStream extends InputStream {
-
-    /** The size by which to grow our array */
-    private static final int bufferGrowthSize = 0x4000;
-    /** The bytes that have been read so far */
-    private byte[] bytes = new byte[bufferGrowthSize];
-    /** Index of the next empty entry in the array */
-    private int pos = 0;
-    /** The input stream that actually holds the data */
-    private final InputStream stream;
-    /** Index of the last valid byte in the byte array */
-    private int maxRead = -1;
-    /** The point to reset to */
-    private int markPoint = -1;
-    
-    
-    public RememberingInputStream(InputStream in) throws IOException{
-      stream = in;
-      // Pre fill with data that we know we're going to need - it's 
-      // more efficient than the single byte reads are - hopefully
-      // someone reading a lot of data will do reads in bulk
-      
-      maxRead = stream.read(bytes) - 1;
-    }
-
-    @Override
-    public int read() throws IOException {
-      
-      if(pos <= maxRead)
-      {
-        //We can't return the byte directly, because it is signed
-        //We can pretend this is an unsigned byte by using boolean
-        //& to set the low end byte of an int.
-        return bytes[pos++] & 0xFF;
-      } else {
-        int i = stream.read();
-        if(i<0)
-          return i;
-      
-        ensureCapacity(0);
-        bytes[pos++] = (byte) i;
-        return i;
-      }
-    }
-
-    /**
-     * Ensure our internal byte array can hold enough data
-     * @param i one less than the number of bytes that need
-     *          to be held.
-     */
-    private void ensureCapacity(int i) {
-      if((pos + i) >= bytes.length) {
-        byte[] tmp = bytes;
-        int newLength = bytes.length + bufferGrowthSize;
-        while(newLength < pos + i) {
-          newLength += bufferGrowthSize;
-        }
-        bytes = new byte[newLength];
-        System.arraycopy(tmp, 0, bytes, 0, (maxRead >= pos) ? maxRead + 1 : pos);
-      }
-    }
-
-    @Override
-    public int read(byte[] b) throws IOException {
-      return read(b, 0, b.length);
-    }
-
-    @Override
-    public int read(byte[] b, int off, int len) throws IOException {
-      if(pos <= maxRead) {
-        if(pos + len <= maxRead)
-        {
-          System.arraycopy(bytes, pos, b, off, len);
-          pos += len;
-          return len;
-        } else {
-          int lengthLeftOfBuffer = (maxRead - pos) + 1;
-          System.arraycopy(bytes, pos, b, off, lengthLeftOfBuffer);
-          int read = stream.read(b, off + lengthLeftOfBuffer, len - lengthLeftOfBuffer);
-          if(read < 0) {
-            pos += lengthLeftOfBuffer;
-            return lengthLeftOfBuffer;
-          }
-          ensureCapacity(lengthLeftOfBuffer + read - 1);
-          System.arraycopy(b, off + lengthLeftOfBuffer, bytes, maxRead + 1, read);
-          pos +=  (lengthLeftOfBuffer + read);
-          return lengthLeftOfBuffer + read;
-        }
-      } else {
-        int i = stream.read(b, off, len);
-        if(i<0)
-          return i;
-        ensureCapacity(i - 1);
-        System.arraycopy(b, off, bytes, pos, i);
-        pos += i;
-        return i;
-      }
-    }
-
-    @Override
-    public long skip(long n) throws IOException {
-      throw new IOException("Skip is unsupported");
-    }
-
-    @Override
-    public int available() throws IOException {
-      if(pos <= maxRead) 
-        return (maxRead - pos) + 1;
-      else 
-        return stream.available(); 
-    }
-
-    @Override
-    public synchronized void mark(int readlimit) {
-      markPoint = pos;
-    }
-
-    @Override
-    public synchronized void reset() throws IOException {
-      if(maxRead < pos)
-        maxRead = pos - 1;
-      pos = markPoint;
-    }
-
-    @Override
-    public boolean markSupported() {
-      return true;
-    }
-
-    @Override
-    public void close() throws IOException {
-      //No op, don't close the parent.
-    }
-  }
-  
   /* (non-Javadoc)
    * @see org.apache.aries.jpa.container.parsing.impl.PersistenceDescriptorParser#parse(org.osgi.framework.Bundle, org.apache.aries.jpa.container.parsing.PersistenceDescriptor)
    */
   public Collection<? extends ParsedPersistenceUnit> parse(Bundle b, PersistenceDescriptor descriptor) throws PersistenceDescriptorParserException {
     Collection<ParsedPersistenceUnit> persistenceUnits = new ArrayList<ParsedPersistenceUnit>();
     SAXParserFactory parserFactory = SAXParserFactory.newInstance();
-    InputStream is = null;
+    RememberingInputStream is = null;
     boolean schemaFound = false;
     try {
       //Buffer the InputStream so we can mark it, though we'll be in 
@@ -220,7 +81,7 @@ public void close() throws IOException {
           + " in bundle " + b.getSymbolicName() + "_" + b.getVersion(), e);
     } finally {
       if(is != null) try {
-        is.close();
+        is.closeUnderlying();
       } catch (IOException e) {
         //No logging necessary, just consume
       }
diff --git a/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/IOUtils.java b/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/IOUtils.java
index dcf01185..e69de29b 100644
--- a/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/IOUtils.java
+++ b/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/IOUtils.java
@@ -1,293 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-
-package org.apache.aries.util.filesystem;
-
-import java.io.Closeable;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Set;
-import java.util.jar.JarOutputStream;
-import java.util.jar.Manifest;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipException;
-import java.util.zip.ZipFile;
-import java.util.zip.ZipInputStream;
-import java.util.zip.ZipOutputStream;
-
-import org.apache.aries.util.internal.MessageUtil;
-
-public class IOUtils
-{
-  /**
-   * Copy an InputStream to an OutputStream and close the InputStream afterwards.
-   */
-  public static void copy(InputStream in, OutputStream out) throws IOException
-  {
-    try {
-      copyAndDoNotCloseInputStream(in, out);
-    }
-    finally {
-      close(in);
-    }
-  }
-  
-  /**
-   * Copy an InputStream to an OutputStream and do not close the InputStream afterwards.
-   */
-  public static void copyAndDoNotCloseInputStream(InputStream in, OutputStream out) throws IOException
-  {
-    int len;
-    byte[] b = new byte[1024];
-    while ((len = in.read(b)) != -1)
-      out.write(b,0,len);
-  }
-  
-  /**
-   * Close some xStream for good :)
-   */
-  public static void close(Closeable c)
-  {
-    try {
-      if (c != null)
-        c.close();
-    }
-    catch (IOException e) {
-      c = null;
-    }
-  }
-  
-  /**
-   * A special version of close() for ZipFiles, which don't implement Closeable.
-   * @param file the file to close. ZipFiles seem prone to file locking problems
-   * on Windows, so to aid diagnostics we throw, not swallow, any exceptions. 
-   */
-  public static void close(ZipFile file) throws IOException
-  {
-    if (file != null) file.close();
-  }
-  
-  public static OutputStream getOutputStream(File outputDir, String relativePath) throws IOException
-  {
-    int lastSeparatorIndex = relativePath.replace(File.separatorChar,'/').lastIndexOf("/");
-    String dirName = null;
-    String fileName = null;
-    
-    File outputDirectory;
-    if (lastSeparatorIndex != -1)
-    {
-      dirName = relativePath.substring(0, lastSeparatorIndex);
-      fileName = relativePath.substring(lastSeparatorIndex + 1);
-
-      outputDirectory = new File(outputDir, dirName);
-      
-      if (!!!outputDirectory.exists() && !!!outputDirectory.mkdirs())
-        throw new IOException(MessageUtil.getMessage("UTIL0015E", relativePath));
-    }
-    else
-    {
-      outputDirectory = outputDir;
-      fileName = relativePath;
-    }
-    
-    File outputFile = new File(outputDirectory, fileName);
-    return new FileOutputStream(outputFile);
-  }
-  
-  /**
-   * Write the given InputStream to a file given by a root directory (outputDir) and a relative directory.
-   * Necessary subdirectories will be created. This method will close the supplied InputStream.
-   */
-  public static void writeOut(File outputDir, String relativePath, InputStream content) throws IOException
-  {
-    OutputStream out = null;
-    try {
-      out = getOutputStream(outputDir, relativePath);
-      IOUtils.copy(content, out);
-    }
-    finally {
-      close(out);
-    }
-  }
-  
-  /**
-   * Write the given InputStream to a file given by a root directory (outputDir) and a relative directory.
-   * Necessary subdirectories will be created. This method will not close the supplied InputStream.
-   */
-  public static void writeOutAndDontCloseInputStream(File outputDir, String relativePath, InputStream content) throws IOException
-  {
-    OutputStream out = null;
-    try {
-      out = getOutputStream(outputDir, relativePath);
-      IOUtils.copyAndDoNotCloseInputStream(content, out);
-    }
-    finally {
-      close(out);
-    }
-  }
-  
-   /** 
-   * Zip up all contents of rootDir (recursively) into targetStream
-   */
-  @SuppressWarnings("unchecked")
-  public static void zipUp (File rootDir, OutputStream targetStream) throws IOException
-  {
-    ZipOutputStream out = null;
-    try { 
-      out = new ZipOutputStream (targetStream);
-      zipUpRecursive(out, "", rootDir, (Set<String>) Collections.EMPTY_SET);
-    } finally { 
-      close(out);
-    }
-  }
-  
-  /**
-   * Zip up all contents of rootDir (recursively) into targetFile
-   */
-  @SuppressWarnings("unchecked")
-  public static void zipUp(File rootDir, File targetFile) throws IOException
-  {
-    ZipOutputStream out = null; 
-    try {
-      out = new ZipOutputStream(new FileOutputStream(targetFile));
-      zipUpRecursive(out, "", rootDir, (Set<String>) Collections.EMPTY_SET);
-    }
-    finally {
-      close(out);
-    }
-  }
-  
-  /**
-   * Jar up all the contents of rootDir (recursively) into targetFile and add the manifest
-   */
-  public static void jarUp(File rootDir, File targetFile, Manifest manifest) throws IOException
-  {
-    JarOutputStream out = null;
-    try {
-      out = new JarOutputStream(new FileOutputStream(targetFile), manifest);
-      zipUpRecursive(out, "", rootDir, new HashSet<String>(Arrays.asList("META-INF/MANIFEST.MF")));
-    }
-    finally {
-      close(out);
-    }
-  }
-  
-  /**
-   * Helper method used by zipUp
-   */
-  private static void zipUpRecursive(ZipOutputStream out, String prefix, 
-      File directory, Set<String> filesToExclude) throws IOException
-  {
-    File[] files = directory.listFiles();
-    if (files != null) 
-    {
-      for (File f : files)
-      {        
-        String fileName; 
-        if (f.isDirectory())
-          fileName = prefix + f.getName() + "/";
-        else
-          fileName = prefix + f.getName();
-        
-        if (filesToExclude.contains(fileName))
-          continue;
-        
-        ZipEntry ze = new ZipEntry(fileName);
-        ze.setSize(f.length());
-        ze.setTime(f.lastModified());
-        out.putNextEntry(ze);
-
-        if (f.isDirectory()) 
-          zipUpRecursive(out, fileName, f, filesToExclude);
-        else 
-        {
-          IOUtils.copy(new FileInputStream(f), out);
-        }
-      }
-    }
-  }
-  
-  /**
-   * Do rm -rf
-   */
-  public static boolean deleteRecursive(File root)
-  {
-    if (!!!root.exists())
-      return false;
-    else if (root.isFile())
-      return root.delete();
-    else {
-      boolean result = true;
-      for (File f : root.listFiles())
-      {
-        result = deleteRecursive(f) && result;
-      }
-      return root.delete() && result;
-    }
-  }
-  
-  /**
-   * Unpack the zip file into the outputDir
-   * @param zip
-   * @param outputDir
-   * @return true if the zip was expanded, false if the zip was found not to be a zip
-   * @throws IOException when there are unexpected issues handling the zip files.
-   */
-  public static boolean unpackZip(IFile zip, File outputDir) throws IOException{
-    boolean success=true;
-    //unpack from fileOnDisk into bundleDir.
-    ZipInputStream zis = null;
-    try{
-      boolean isZip = false;
-      ZipEntry zipEntry = null;
-      try {
-        zis = new ZipInputStream (zip.open());
-        zipEntry = zis.getNextEntry();
-        isZip = zipEntry != null; 
-      } catch (ZipException e) { // It's not a zip - that's ok, we'll return that below. 
-        isZip = false;
-      } catch (UnsupportedOperationException e) {  // This isn't declared, but is thrown in practice
-        isZip = false;                             // It's not a zip - that's ok, we'll return that below. 
-      }
-      if(isZip){
-        do { 
-          if (!zipEntry.isDirectory()) { 
-            writeOutAndDontCloseInputStream(outputDir, zipEntry.getName(), zis);
-          }
-          zis.closeEntry();
-          zipEntry = zis.getNextEntry();
-        } while (zipEntry != null);
-      }else{
-        success=false;
-      }
-    }finally{
-      IOUtils.close(zis);
-    }
-    return success;
-  }
-  
-
-}
diff --git a/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/FileSystemImpl.java b/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/FileSystemImpl.java
index 0ba2fd17..14de8088 100644
--- a/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/FileSystemImpl.java
+++ b/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/FileSystemImpl.java
@@ -8,7 +8,7 @@
 
 import org.apache.aries.util.filesystem.IDirectory;
 import org.apache.aries.util.filesystem.IFile;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/NestedCloseableDirectory.java b/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/NestedCloseableDirectory.java
index 12265671..f085bf21 100644
--- a/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/NestedCloseableDirectory.java
+++ b/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/NestedCloseableDirectory.java
@@ -24,7 +24,7 @@
 import java.util.zip.ZipFile;
 
 import org.apache.aries.util.filesystem.IFile;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 
 public class NestedCloseableDirectory extends CloseableDirectory {
 
diff --git a/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/NestedZipDirectory.java b/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/NestedZipDirectory.java
index 965f404b..455b660d 100644
--- a/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/NestedZipDirectory.java
+++ b/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/NestedZipDirectory.java
@@ -34,7 +34,7 @@
 import org.apache.aries.util.filesystem.ICloseableDirectory;
 import org.apache.aries.util.filesystem.IDirectory;
 import org.apache.aries.util.filesystem.IFile;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
diff --git a/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/ZipCloseableDirectory.java b/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/ZipCloseableDirectory.java
index 0924548b..c408796f 100644
--- a/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/ZipCloseableDirectory.java
+++ b/aries/trunk/util/src/main/java/org/apache/aries/util/filesystem/impl/ZipCloseableDirectory.java
@@ -22,7 +22,7 @@
 import java.io.IOException;
 import java.util.zip.ZipFile;
 
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 
 public class ZipCloseableDirectory extends CloseableDirectory {
 	private final ZipFile zip;
diff --git a/aries/trunk/util/src/main/java/org/apache/aries/util/io/IOUtils.java b/aries/trunk/util/src/main/java/org/apache/aries/util/io/IOUtils.java
index e69de29b..a926ea3f 100644
--- a/aries/trunk/util/src/main/java/org/apache/aries/util/io/IOUtils.java
+++ b/aries/trunk/util/src/main/java/org/apache/aries/util/io/IOUtils.java
@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.io;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.jar.JarOutputStream;
+import java.util.jar.Manifest;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipException;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipInputStream;
+import java.util.zip.ZipOutputStream;
+
+import org.apache.aries.util.filesystem.IFile;
+import org.apache.aries.util.internal.MessageUtil;
+
+public class IOUtils
+{
+  /**
+   * Copy an InputStream to an OutputStream and close the InputStream afterwards.
+   */
+  public static void copy(InputStream in, OutputStream out) throws IOException
+  {
+    try {
+      copyAndDoNotCloseInputStream(in, out);
+    }
+    finally {
+      close(in);
+    }
+  }
+  
+  /**
+   * Copy an InputStream to an OutputStream and do not close the InputStream afterwards.
+   */
+  public static void copyAndDoNotCloseInputStream(InputStream in, OutputStream out) throws IOException
+  {
+    int len;
+    byte[] b = new byte[1024];
+    while ((len = in.read(b)) != -1)
+      out.write(b,0,len);
+  }
+  
+  /**
+   * Close some xStream for good :)
+   */
+  public static void close(Closeable c)
+  {
+    try {
+      if (c != null)
+        c.close();
+    }
+    catch (IOException e) {
+      c = null;
+    }
+  }
+  
+  /**
+   * A special version of close() for ZipFiles, which don't implement Closeable.
+   * @param file the file to close. ZipFiles seem prone to file locking problems
+   * on Windows, so to aid diagnostics we throw, not swallow, any exceptions. 
+   */
+  public static void close(ZipFile file) throws IOException
+  {
+    if (file != null) file.close();
+  }
+  
+  public static OutputStream getOutputStream(File outputDir, String relativePath) throws IOException
+  {
+    int lastSeparatorIndex = relativePath.replace(File.separatorChar,'/').lastIndexOf("/");
+    String dirName = null;
+    String fileName = null;
+    
+    File outputDirectory;
+    if (lastSeparatorIndex != -1)
+    {
+      dirName = relativePath.substring(0, lastSeparatorIndex);
+      fileName = relativePath.substring(lastSeparatorIndex + 1);
+
+      outputDirectory = new File(outputDir, dirName);
+      
+      if (!!!outputDirectory.exists() && !!!outputDirectory.mkdirs())
+        throw new IOException(MessageUtil.getMessage("UTIL0015E", relativePath));
+    }
+    else
+    {
+      outputDirectory = outputDir;
+      fileName = relativePath;
+    }
+    
+    File outputFile = new File(outputDirectory, fileName);
+    return new FileOutputStream(outputFile);
+  }
+  
+  /**
+   * Write the given InputStream to a file given by a root directory (outputDir) and a relative directory.
+   * Necessary subdirectories will be created. This method will close the supplied InputStream.
+   */
+  public static void writeOut(File outputDir, String relativePath, InputStream content) throws IOException
+  {
+    OutputStream out = null;
+    try {
+      out = getOutputStream(outputDir, relativePath);
+      IOUtils.copy(content, out);
+    }
+    finally {
+      close(out);
+    }
+  }
+  
+  /**
+   * Write the given InputStream to a file given by a root directory (outputDir) and a relative directory.
+   * Necessary subdirectories will be created. This method will not close the supplied InputStream.
+   */
+  public static void writeOutAndDontCloseInputStream(File outputDir, String relativePath, InputStream content) throws IOException
+  {
+    OutputStream out = null;
+    try {
+      out = getOutputStream(outputDir, relativePath);
+      IOUtils.copyAndDoNotCloseInputStream(content, out);
+    }
+    finally {
+      close(out);
+    }
+  }
+  
+   /** 
+   * Zip up all contents of rootDir (recursively) into targetStream
+   */
+  @SuppressWarnings("unchecked")
+  public static void zipUp (File rootDir, OutputStream targetStream) throws IOException
+  {
+    ZipOutputStream out = null;
+    try { 
+      out = new ZipOutputStream (targetStream);
+      zipUpRecursive(out, "", rootDir, (Set<String>) Collections.EMPTY_SET);
+    } finally { 
+      close(out);
+    }
+  }
+  
+  /**
+   * Zip up all contents of rootDir (recursively) into targetFile
+   */
+  @SuppressWarnings("unchecked")
+  public static void zipUp(File rootDir, File targetFile) throws IOException
+  {
+    ZipOutputStream out = null; 
+    try {
+      out = new ZipOutputStream(new FileOutputStream(targetFile));
+      zipUpRecursive(out, "", rootDir, (Set<String>) Collections.EMPTY_SET);
+    }
+    finally {
+      close(out);
+    }
+  }
+  
+  /**
+   * Jar up all the contents of rootDir (recursively) into targetFile and add the manifest
+   */
+  public static void jarUp(File rootDir, File targetFile, Manifest manifest) throws IOException
+  {
+    JarOutputStream out = null;
+    try {
+      out = new JarOutputStream(new FileOutputStream(targetFile), manifest);
+      zipUpRecursive(out, "", rootDir, new HashSet<String>(Arrays.asList("META-INF/MANIFEST.MF")));
+    }
+    finally {
+      close(out);
+    }
+  }
+  
+  /**
+   * Helper method used by zipUp
+   */
+  private static void zipUpRecursive(ZipOutputStream out, String prefix, 
+      File directory, Set<String> filesToExclude) throws IOException
+  {
+    File[] files = directory.listFiles();
+    if (files != null) 
+    {
+      for (File f : files)
+      {        
+        String fileName; 
+        if (f.isDirectory())
+          fileName = prefix + f.getName() + "/";
+        else
+          fileName = prefix + f.getName();
+        
+        if (filesToExclude.contains(fileName))
+          continue;
+        
+        ZipEntry ze = new ZipEntry(fileName);
+        ze.setSize(f.length());
+        ze.setTime(f.lastModified());
+        out.putNextEntry(ze);
+
+        if (f.isDirectory()) 
+          zipUpRecursive(out, fileName, f, filesToExclude);
+        else 
+        {
+          IOUtils.copy(new FileInputStream(f), out);
+        }
+      }
+    }
+  }
+  
+  /**
+   * Do rm -rf
+   */
+  public static boolean deleteRecursive(File root)
+  {
+    if (!!!root.exists())
+      return false;
+    else if (root.isFile())
+      return root.delete();
+    else {
+      boolean result = true;
+      for (File f : root.listFiles())
+      {
+        result = deleteRecursive(f) && result;
+      }
+      return root.delete() && result;
+    }
+  }
+  
+  /**
+   * Unpack the zip file into the outputDir
+   * @param zip
+   * @param outputDir
+   * @return true if the zip was expanded, false if the zip was found not to be a zip
+   * @throws IOException when there are unexpected issues handling the zip files.
+   */
+  public static boolean unpackZip(IFile zip, File outputDir) throws IOException{
+    boolean success=true;
+    //unpack from fileOnDisk into bundleDir.
+    ZipInputStream zis = null;
+    try{
+      boolean isZip = false;
+      ZipEntry zipEntry = null;
+      try {
+        zis = new ZipInputStream (zip.open());
+        zipEntry = zis.getNextEntry();
+        isZip = zipEntry != null; 
+      } catch (ZipException e) { // It's not a zip - that's ok, we'll return that below. 
+        isZip = false;
+      } catch (UnsupportedOperationException e) {  // This isn't declared, but is thrown in practice
+        isZip = false;                             // It's not a zip - that's ok, we'll return that below. 
+      }
+      if(isZip){
+        do { 
+          if (!zipEntry.isDirectory()) { 
+            writeOutAndDontCloseInputStream(outputDir, zipEntry.getName(), zis);
+          }
+          zis.closeEntry();
+          zipEntry = zis.getNextEntry();
+        } while (zipEntry != null);
+      }else{
+        success=false;
+      }
+    }finally{
+      IOUtils.close(zis);
+    }
+    return success;
+  }
+  
+
+}
diff --git a/aries/trunk/util/src/main/java/org/apache/aries/util/io/RememberingInputStream.java b/aries/trunk/util/src/main/java/org/apache/aries/util/io/RememberingInputStream.java
index e934ea14..f48875e6 100644
--- a/aries/trunk/util/src/main/java/org/apache/aries/util/io/RememberingInputStream.java
+++ b/aries/trunk/util/src/main/java/org/apache/aries/util/io/RememberingInputStream.java
@@ -1,3 +1,158 @@
   + native
   + text/plain
   + Date Revision
+package org.apache.aries.util.io;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * This class can be used to buffer an arbitrary amount of content from an input stream and be able to reset to 
+ * the start.
+ */
+public class RememberingInputStream extends InputStream {
+
+  /** The size by which to grow our array */
+  private static final int bufferGrowthSize = 0x4000;
+  /** The bytes that have been read so far */
+  private byte[] bytes = new byte[bufferGrowthSize];
+  /** Index of the next empty entry in the array */
+  private int pos = 0;
+  /** The input stream that actually holds the data */
+  private final InputStream stream;
+  /** Index of the last valid byte in the byte array */
+  private int maxRead = -1;
+  /** The point to reset to */
+  private int markPoint = -1;
+  
+  
+  public RememberingInputStream(InputStream in) throws IOException{
+    stream = in;
+    // Pre fill with data that we know we're going to need - it's 
+    // more efficient than the single byte reads are - hopefully
+    // someone reading a lot of data will do reads in bulk
+    
+    maxRead = stream.read(bytes) - 1;
+  }
+
+  @Override
+  public int read() throws IOException {
+    
+    if(pos <= maxRead)
+    {
+      //We can't return the byte directly, because it is signed
+      //We can pretend this is an unsigned byte by using boolean
+      //& to set the low end byte of an int.
+      return bytes[pos++] & 0xFF;
+    } else {
+      int i = stream.read();
+      if(i<0)
+        return i;
+    
+      ensureCapacity(0);
+      bytes[pos++] = (byte) i;
+      return i;
+    }
+  }
+
+  /**
+   * Ensure our internal byte array can hold enough data
+   * @param i one less than the number of bytes that need
+   *          to be held.
+   */
+  private void ensureCapacity(int i) {
+    if((pos + i) >= bytes.length) {
+      byte[] tmp = bytes;
+      int newLength = bytes.length + bufferGrowthSize;
+      while(newLength < pos + i) {
+        newLength += bufferGrowthSize;
+      }
+      bytes = new byte[newLength];
+      System.arraycopy(tmp, 0, bytes, 0, (maxRead >= pos) ? maxRead + 1 : pos);
+    }
+  }
+
+  @Override
+  public int read(byte[] b) throws IOException {
+    return read(b, 0, b.length);
+  }
+
+  @Override
+  public int read(byte[] b, int off, int len) throws IOException {
+    if(pos <= maxRead) {
+      if(pos + len <= maxRead)
+      {
+        System.arraycopy(bytes, pos, b, off, len);
+        pos += len;
+        return len;
+      } else {
+        int lengthLeftOfBuffer = (maxRead - pos) + 1;
+        System.arraycopy(bytes, pos, b, off, lengthLeftOfBuffer);
+        int read = stream.read(b, off + lengthLeftOfBuffer, len - lengthLeftOfBuffer);
+        if(read < 0) {
+          pos += lengthLeftOfBuffer;
+          return lengthLeftOfBuffer;
+        }
+        ensureCapacity(lengthLeftOfBuffer + read - 1);
+        System.arraycopy(b, off + lengthLeftOfBuffer, bytes, maxRead + 1, read);
+        pos +=  (lengthLeftOfBuffer + read);
+        return lengthLeftOfBuffer + read;
+      }
+    } else {
+      int i = stream.read(b, off, len);
+      if(i<0)
+        return i;
+      ensureCapacity(i - 1);
+      System.arraycopy(b, off, bytes, pos, i);
+      pos += i;
+      return i;
+    }
+  }
+
+  @Override
+  public long skip(long n) throws IOException {
+    throw new IOException("Skip is unsupported");
+  }
+
+  @Override
+  public int available() throws IOException {
+    if(pos <= maxRead) 
+      return (maxRead - pos) + 1;
+    else 
+      return stream.available(); 
+  }
+
+  @Override
+  public synchronized void mark(int readlimit) {
+    markPoint = pos;
+  }
+
+  @Override
+  public synchronized void reset() throws IOException {
+    if(maxRead < pos)
+      maxRead = pos - 1;
+    pos = markPoint;
+  }
+
+  @Override
+  public boolean markSupported() {
+    return true;
+  }
+
+  /**
+   * Noop. Does not close the passed in archive, which is kept open for further reading.
+   */
+  @Override
+  public void close() throws IOException {
+    //No op, don't close the parent.
+  }
+  
+  /**
+   * Actually closes the underlying InputStream. Call this method instead of close, which is implemented as a no-op.
+   * Alternatively call close directly on the parent.
+   * @throws IOException
+   */
+  public void closeUnderlying() throws IOException {
+      stream.close();
+  }
+}
diff --git a/aries/trunk/util/src/main/java/org/apache/aries/util/manifest/BundleManifest.java b/aries/trunk/util/src/main/java/org/apache/aries/util/manifest/BundleManifest.java
index 822ccbb5..6a256bba 100644
--- a/aries/trunk/util/src/main/java/org/apache/aries/util/manifest/BundleManifest.java
+++ b/aries/trunk/util/src/main/java/org/apache/aries/util/manifest/BundleManifest.java
@@ -29,8 +29,8 @@
 import java.util.zip.ZipEntry;
 
 import org.apache.aries.util.filesystem.IFile;
-import org.apache.aries.util.filesystem.IOUtils;
 import org.apache.aries.util.internal.MessageUtil;
+import org.apache.aries.util.io.IOUtils;
 import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValueMap;
 import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValuePair;
 import org.osgi.framework.Constants;
diff --git a/aries/trunk/util/src/main/java/org/apache/aries/util/manifest/ManifestProcessor.java b/aries/trunk/util/src/main/java/org/apache/aries/util/manifest/ManifestProcessor.java
index f8f50391..54fdccd7 100644
--- a/aries/trunk/util/src/main/java/org/apache/aries/util/manifest/ManifestProcessor.java
+++ b/aries/trunk/util/src/main/java/org/apache/aries/util/manifest/ManifestProcessor.java
@@ -33,7 +33,7 @@
 
 import org.apache.aries.util.filesystem.IDirectory;
 import org.apache.aries.util.filesystem.IFile;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 
 /**
  * This class contains utilities for parsing manifests. It provides methods to
diff --git a/aries/trunk/util/src/test/java/org/apache/aries/util/filesystem/FileSystemTest.java b/aries/trunk/util/src/test/java/org/apache/aries/util/filesystem/FileSystemTest.java
index 73723a56..b1e283ce 100644
--- a/aries/trunk/util/src/test/java/org/apache/aries/util/filesystem/FileSystemTest.java
+++ b/aries/trunk/util/src/test/java/org/apache/aries/util/filesystem/FileSystemTest.java
@@ -44,7 +44,7 @@
 import org.apache.aries.util.filesystem.ICloseableDirectory;
 import org.apache.aries.util.filesystem.IDirectory;
 import org.apache.aries.util.filesystem.IFile;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
diff --git a/aries/trunk/util/src/test/java/org/apache/aries/util/filesystem/FileUtilsTest.java b/aries/trunk/util/src/test/java/org/apache/aries/util/filesystem/FileUtilsTest.java
index 03d3f698..e435f66f 100644
--- a/aries/trunk/util/src/test/java/org/apache/aries/util/filesystem/FileUtilsTest.java
+++ b/aries/trunk/util/src/test/java/org/apache/aries/util/filesystem/FileUtilsTest.java
@@ -32,7 +32,7 @@
 import org.apache.aries.unittest.fixture.ArchiveFixture;
 import org.apache.aries.unittest.fixture.ArchiveFixture.ZipFixture;
 import org.apache.aries.util.filesystem.FileUtils;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 import org.junit.Test;
 import org.osgi.framework.Constants;
 
diff --git a/aries/trunk/util/src/test/java/org/apache/aries/util/filesystem/IOUtilsTest.java b/aries/trunk/util/src/test/java/org/apache/aries/util/filesystem/IOUtilsTest.java
index beaff60f..0a8afbbe 100644
--- a/aries/trunk/util/src/test/java/org/apache/aries/util/filesystem/IOUtilsTest.java
+++ b/aries/trunk/util/src/test/java/org/apache/aries/util/filesystem/IOUtilsTest.java
@@ -38,7 +38,7 @@
 import org.apache.aries.util.filesystem.FileSystem;
 import org.apache.aries.util.filesystem.IDirectory;
 import org.apache.aries.util.filesystem.IFile;
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 import org.junit.AfterClass;
 import org.junit.Test;
 
diff --git a/aries/trunk/util/src/test/java/org/apache/aries/util/manifest/BundleManifestTest.java b/aries/trunk/util/src/test/java/org/apache/aries/util/manifest/BundleManifestTest.java
index fc221638..cd6ac26e 100644
--- a/aries/trunk/util/src/test/java/org/apache/aries/util/manifest/BundleManifestTest.java
+++ b/aries/trunk/util/src/test/java/org/apache/aries/util/manifest/BundleManifestTest.java
@@ -29,7 +29,7 @@
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipOutputStream;
 
-import org.apache.aries.util.filesystem.IOUtils;
+import org.apache.aries.util.io.IOUtils;
 import org.apache.aries.util.manifest.BundleManifest;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
