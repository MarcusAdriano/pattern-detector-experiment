diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthenticationRequest.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthenticationRequest.java
index 733fc425..828f2a40 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthenticationRequest.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthenticationRequest.java
@@ -283,15 +283,15 @@ public void read(TProtocol iprot) throws TException {
         case 1: // CREDENTIALS
           if (field.type == TType.MAP) {
             {
-              TMap _map20 = iprot.readMapBegin();
-              this.credentials = new HashMap<String,String>(2*_map20.size);
-              for (int _i21 = 0; _i21 < _map20.size; ++_i21)
+              TMap _map28 = iprot.readMapBegin();
+              this.credentials = new HashMap<String,String>(2*_map28.size);
+              for (int _i29 = 0; _i29 < _map28.size; ++_i29)
               {
-                String _key22;
-                String _val23;
-                _key22 = iprot.readString();
-                _val23 = iprot.readString();
-                this.credentials.put(_key22, _val23);
+                String _key30;
+                String _val31;
+                _key30 = iprot.readString();
+                _val31 = iprot.readString();
+                this.credentials.put(_key30, _val31);
               }
               iprot.readMapEnd();
             }
@@ -318,10 +318,10 @@ public void write(TProtocol oprot) throws TException {
       oprot.writeFieldBegin(CREDENTIALS_FIELD_DESC);
       {
         oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, this.credentials.size()));
-        for (Map.Entry<String, String> _iter24 : this.credentials.entrySet())
+        for (Map.Entry<String, String> _iter32 : this.credentials.entrySet())
         {
-          oprot.writeString(_iter24.getKey());
-          oprot.writeString(_iter24.getValue());
+          oprot.writeString(_iter32.getKey());
+          oprot.writeString(_iter32.getValue());
         }
         oprot.writeMapEnd();
       }
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java
index 969413f8..85617459 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java
@@ -75,6 +75,7 @@
 
     /**
      * Performs a get_slice for column_parent and predicate for the given keys in parallel.
+     * @Deprecated; use `scan`
      * 
      * @param keys
      * @param column_parent
@@ -107,6 +108,7 @@
 
     /**
      * returns a subset of columns for a range of keys.
+     * @Deprecated; use `scan`
      * 
      * @param column_parent
      * @param predicate
@@ -115,6 +117,26 @@
      */
     public List<KeySlice> get_range_slices(ColumnParent column_parent, SlicePredicate predicate, KeyRange range, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
 
+    /**
+     * Returns the subset of columns specified in SlicePredicate for the rows requested in RowsPredicate
+     * 
+     * @param column_parent
+     * @param row_predicate
+     * @param column_predicate
+     * @param consistency_level
+     */
+    public List<KeySlice> scan(ColumnParent column_parent, RowPredicate row_predicate, SlicePredicate column_predicate, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
+
+    /**
+     * Counts the subset of columns specified in SlicePredicate for the rows requested in RowsPredicate
+     * 
+     * @param column_parent
+     * @param row_predicate
+     * @param column_predicate
+     * @param consistency_level
+     */
+    public List<KeyCount> scan_count(ColumnParent column_parent, RowPredicate row_predicate, SlicePredicate column_predicate, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
+
     /**
      * Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
      * 
@@ -636,6 +658,96 @@ public void send_get_range_slices(ColumnParent column_parent, SlicePredicate pre
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_range_slices failed: unknown result");
     }
 
+    public List<KeySlice> scan(ColumnParent column_parent, RowPredicate row_predicate, SlicePredicate column_predicate, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
+    {
+      send_scan(column_parent, row_predicate, column_predicate, consistency_level);
+      return recv_scan();
+    }
+
+    public void send_scan(ColumnParent column_parent, RowPredicate row_predicate, SlicePredicate column_predicate, ConsistencyLevel consistency_level) throws TException
+    {
+      oprot_.writeMessageBegin(new TMessage("scan", TMessageType.CALL, seqid_));
+      scan_args args = new scan_args();
+      args.column_parent = column_parent;
+      args.row_predicate = row_predicate;
+      args.column_predicate = column_predicate;
+      args.consistency_level = consistency_level;
+      args.write(oprot_);
+      oprot_.writeMessageEnd();
+      oprot_.getTransport().flush();
+    }
+
+    public List<KeySlice> recv_scan() throws InvalidRequestException, UnavailableException, TimedOutException, TException
+    {
+      TMessage msg = iprot_.readMessageBegin();
+      if (msg.type == TMessageType.EXCEPTION) {
+        TApplicationException x = TApplicationException.read(iprot_);
+        iprot_.readMessageEnd();
+        throw x;
+      }
+      scan_result result = new scan_result();
+      result.read(iprot_);
+      iprot_.readMessageEnd();
+      if (result.isSetSuccess()) {
+        return result.success;
+      }
+      if (result.ire != null) {
+        throw result.ire;
+      }
+      if (result.ue != null) {
+        throw result.ue;
+      }
+      if (result.te != null) {
+        throw result.te;
+      }
+      throw new TApplicationException(TApplicationException.MISSING_RESULT, "scan failed: unknown result");
+    }
+
+    public List<KeyCount> scan_count(ColumnParent column_parent, RowPredicate row_predicate, SlicePredicate column_predicate, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
+    {
+      send_scan_count(column_parent, row_predicate, column_predicate, consistency_level);
+      return recv_scan_count();
+    }
+
+    public void send_scan_count(ColumnParent column_parent, RowPredicate row_predicate, SlicePredicate column_predicate, ConsistencyLevel consistency_level) throws TException
+    {
+      oprot_.writeMessageBegin(new TMessage("scan_count", TMessageType.CALL, seqid_));
+      scan_count_args args = new scan_count_args();
+      args.column_parent = column_parent;
+      args.row_predicate = row_predicate;
+      args.column_predicate = column_predicate;
+      args.consistency_level = consistency_level;
+      args.write(oprot_);
+      oprot_.writeMessageEnd();
+      oprot_.getTransport().flush();
+    }
+
+    public List<KeyCount> recv_scan_count() throws InvalidRequestException, UnavailableException, TimedOutException, TException
+    {
+      TMessage msg = iprot_.readMessageBegin();
+      if (msg.type == TMessageType.EXCEPTION) {
+        TApplicationException x = TApplicationException.read(iprot_);
+        iprot_.readMessageEnd();
+        throw x;
+      }
+      scan_count_result result = new scan_count_result();
+      result.read(iprot_);
+      iprot_.readMessageEnd();
+      if (result.isSetSuccess()) {
+        return result.success;
+      }
+      if (result.ire != null) {
+        throw result.ire;
+      }
+      if (result.ue != null) {
+        throw result.ue;
+      }
+      if (result.te != null) {
+        throw result.te;
+      }
+      throw new TApplicationException(TApplicationException.MISSING_RESULT, "scan_count failed: unknown result");
+    }
+
     public void insert(byte[] key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
       send_insert(key, column_parent, column, consistency_level);
@@ -1268,6 +1380,8 @@ public Processor(Iface iface)
       processMap_.put("get_count", new get_count());
       processMap_.put("multiget_count", new multiget_count());
       processMap_.put("get_range_slices", new get_range_slices());
+      processMap_.put("scan", new scan());
+      processMap_.put("scan_count", new scan_count());
       processMap_.put("insert", new insert());
       processMap_.put("remove", new remove());
       processMap_.put("batch_mutate", new batch_mutate());
@@ -1645,6 +1759,90 @@ public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TExcepti
 
     }
 
+    private class scan implements ProcessFunction {
+      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
+      {
+        scan_args args = new scan_args();
+        try {
+          args.read(iprot);
+        } catch (TProtocolException e) {
+          iprot.readMessageEnd();
+          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
+          oprot.writeMessageBegin(new TMessage("scan", TMessageType.EXCEPTION, seqid));
+          x.write(oprot);
+          oprot.writeMessageEnd();
+          oprot.getTransport().flush();
+          return;
+        }
+        iprot.readMessageEnd();
+        scan_result result = new scan_result();
+        try {
+          result.success = iface_.scan(args.column_parent, args.row_predicate, args.column_predicate, args.consistency_level);
+        } catch (InvalidRequestException ire) {
+          result.ire = ire;
+        } catch (UnavailableException ue) {
+          result.ue = ue;
+        } catch (TimedOutException te) {
+          result.te = te;
+        } catch (Throwable th) {
+          LOGGER.error("Internal error processing scan", th);
+          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing scan");
+          oprot.writeMessageBegin(new TMessage("scan", TMessageType.EXCEPTION, seqid));
+          x.write(oprot);
+          oprot.writeMessageEnd();
+          oprot.getTransport().flush();
+          return;
+        }
+        oprot.writeMessageBegin(new TMessage("scan", TMessageType.REPLY, seqid));
+        result.write(oprot);
+        oprot.writeMessageEnd();
+        oprot.getTransport().flush();
+      }
+
+    }
+
+    private class scan_count implements ProcessFunction {
+      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
+      {
+        scan_count_args args = new scan_count_args();
+        try {
+          args.read(iprot);
+        } catch (TProtocolException e) {
+          iprot.readMessageEnd();
+          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
+          oprot.writeMessageBegin(new TMessage("scan_count", TMessageType.EXCEPTION, seqid));
+          x.write(oprot);
+          oprot.writeMessageEnd();
+          oprot.getTransport().flush();
+          return;
+        }
+        iprot.readMessageEnd();
+        scan_count_result result = new scan_count_result();
+        try {
+          result.success = iface_.scan_count(args.column_parent, args.row_predicate, args.column_predicate, args.consistency_level);
+        } catch (InvalidRequestException ire) {
+          result.ire = ire;
+        } catch (UnavailableException ue) {
+          result.ue = ue;
+        } catch (TimedOutException te) {
+          result.te = te;
+        } catch (Throwable th) {
+          LOGGER.error("Internal error processing scan_count", th);
+          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing scan_count");
+          oprot.writeMessageBegin(new TMessage("scan_count", TMessageType.EXCEPTION, seqid));
+          x.write(oprot);
+          oprot.writeMessageEnd();
+          oprot.getTransport().flush();
+          return;
+        }
+        oprot.writeMessageBegin(new TMessage("scan_count", TMessageType.REPLY, seqid));
+        result.write(oprot);
+        oprot.writeMessageEnd();
+        oprot.getTransport().flush();
+      }
+
+    }
+
     private class insert implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
@@ -5681,14 +5879,14 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.LIST) {
               {
-                TList _list33 = iprot.readListBegin();
-                this.success = new ArrayList<ColumnOrSuperColumn>(_list33.size);
-                for (int _i34 = 0; _i34 < _list33.size; ++_i34)
+                TList _list41 = iprot.readListBegin();
+                this.success = new ArrayList<ColumnOrSuperColumn>(_list41.size);
+                for (int _i42 = 0; _i42 < _list41.size; ++_i42)
                 {
-                  ColumnOrSuperColumn _elem35;
-                  _elem35 = new ColumnOrSuperColumn();
-                  _elem35.read(iprot);
-                  this.success.add(_elem35);
+                  ColumnOrSuperColumn _elem43;
+                  _elem43 = new ColumnOrSuperColumn();
+                  _elem43.read(iprot);
+                  this.success.add(_elem43);
                 }
                 iprot.readListEnd();
               }
@@ -5738,9 +5936,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
-          for (ColumnOrSuperColumn _iter36 : this.success)
+          for (ColumnOrSuperColumn _iter44 : this.success)
           {
-            _iter36.write(oprot);
+            _iter44.write(oprot);
           }
           oprot.writeListEnd();
         }
@@ -6274,13 +6472,13 @@ public void read(TProtocol iprot) throws TException {
           case 1: // KEYS
             if (field.type == TType.LIST) {
               {
-                TList _list37 = iprot.readListBegin();
-                this.keys = new ArrayList<byte[]>(_list37.size);
-                for (int _i38 = 0; _i38 < _list37.size; ++_i38)
+                TList _list45 = iprot.readListBegin();
+                this.keys = new ArrayList<byte[]>(_list45.size);
+                for (int _i46 = 0; _i46 < _list45.size; ++_i46)
                 {
-                  byte[] _elem39;
-                  _elem39 = iprot.readBinary();
-                  this.keys.add(_elem39);
+                  byte[] _elem47;
+                  _elem47 = iprot.readBinary();
+                  this.keys.add(_elem47);
                 }
                 iprot.readListEnd();
               }
@@ -6330,9 +6528,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(KEYS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
-          for (byte[] _iter40 : this.keys)
+          for (byte[] _iter48 : this.keys)
           {
-            oprot.writeBinary(_iter40);
+            oprot.writeBinary(_iter48);
           }
           oprot.writeListEnd();
         }
@@ -6824,26 +7022,26 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.MAP) {
               {
-                TMap _map41 = iprot.readMapBegin();
-                this.success = new HashMap<byte[],List<ColumnOrSuperColumn>>(2*_map41.size);
-                for (int _i42 = 0; _i42 < _map41.size; ++_i42)
+                TMap _map49 = iprot.readMapBegin();
+                this.success = new HashMap<byte[],List<ColumnOrSuperColumn>>(2*_map49.size);
+                for (int _i50 = 0; _i50 < _map49.size; ++_i50)
                 {
-                  byte[] _key43;
-                  List<ColumnOrSuperColumn> _val44;
-                  _key43 = iprot.readBinary();
+                  byte[] _key51;
+                  List<ColumnOrSuperColumn> _val52;
+                  _key51 = iprot.readBinary();
                   {
-                    TList _list45 = iprot.readListBegin();
-                    _val44 = new ArrayList<ColumnOrSuperColumn>(_list45.size);
-                    for (int _i46 = 0; _i46 < _list45.size; ++_i46)
+                    TList _list53 = iprot.readListBegin();
+                    _val52 = new ArrayList<ColumnOrSuperColumn>(_list53.size);
+                    for (int _i54 = 0; _i54 < _list53.size; ++_i54)
                     {
-                      ColumnOrSuperColumn _elem47;
-                      _elem47 = new ColumnOrSuperColumn();
-                      _elem47.read(iprot);
-                      _val44.add(_elem47);
+                      ColumnOrSuperColumn _elem55;
+                      _elem55 = new ColumnOrSuperColumn();
+                      _elem55.read(iprot);
+                      _val52.add(_elem55);
                     }
                     iprot.readListEnd();
                   }
-                  this.success.put(_key43, _val44);
+                  this.success.put(_key51, _val52);
                 }
                 iprot.readMapEnd();
               }
@@ -6893,14 +7091,14 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.success.size()));
-          for (Map.Entry<byte[], List<ColumnOrSuperColumn>> _iter48 : this.success.entrySet())
+          for (Map.Entry<byte[], List<ColumnOrSuperColumn>> _iter56 : this.success.entrySet())
           {
-            oprot.writeBinary(_iter48.getKey());
+            oprot.writeBinary(_iter56.getKey());
             {
-              oprot.writeListBegin(new TList(TType.STRUCT, _iter48.getValue().size()));
-              for (ColumnOrSuperColumn _iter49 : _iter48.getValue())
+              oprot.writeListBegin(new TList(TType.STRUCT, _iter56.getValue().size()));
+              for (ColumnOrSuperColumn _iter57 : _iter56.getValue())
               {
-                _iter49.write(oprot);
+                _iter57.write(oprot);
               }
               oprot.writeListEnd();
             }
@@ -8617,13 +8815,13 @@ public void read(TProtocol iprot) throws TException {
           case 2: // KEYS
             if (field.type == TType.LIST) {
               {
-                TList _list50 = iprot.readListBegin();
-                this.keys = new ArrayList<byte[]>(_list50.size);
-                for (int _i51 = 0; _i51 < _list50.size; ++_i51)
+                TList _list58 = iprot.readListBegin();
+                this.keys = new ArrayList<byte[]>(_list58.size);
+                for (int _i59 = 0; _i59 < _list58.size; ++_i59)
                 {
-                  byte[] _elem52;
-                  _elem52 = iprot.readBinary();
-                  this.keys.add(_elem52);
+                  byte[] _elem60;
+                  _elem60 = iprot.readBinary();
+                  this.keys.add(_elem60);
                 }
                 iprot.readListEnd();
               }
@@ -8678,9 +8876,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(KEYS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
-          for (byte[] _iter53 : this.keys)
+          for (byte[] _iter61 : this.keys)
           {
-            oprot.writeBinary(_iter53);
+            oprot.writeBinary(_iter61);
           }
           oprot.writeListEnd();
         }
@@ -9179,15 +9377,15 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.MAP) {
               {
-                TMap _map54 = iprot.readMapBegin();
-                this.success = new HashMap<byte[],Integer>(2*_map54.size);
-                for (int _i55 = 0; _i55 < _map54.size; ++_i55)
+                TMap _map62 = iprot.readMapBegin();
+                this.success = new HashMap<byte[],Integer>(2*_map62.size);
+                for (int _i63 = 0; _i63 < _map62.size; ++_i63)
                 {
-                  byte[] _key56;
-                  int _val57;
-                  _key56 = iprot.readBinary();
-                  _val57 = iprot.readI32();
-                  this.success.put(_key56, _val57);
+                  byte[] _key64;
+                  int _val65;
+                  _key64 = iprot.readBinary();
+                  _val65 = iprot.readI32();
+                  this.success.put(_key64, _val65);
                 }
                 iprot.readMapEnd();
               }
@@ -9237,10 +9435,10 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.I32, this.success.size()));
-          for (Map.Entry<byte[], Integer> _iter58 : this.success.entrySet())
+          for (Map.Entry<byte[], Integer> _iter66 : this.success.entrySet())
           {
-            oprot.writeBinary(_iter58.getKey());
-            oprot.writeI32(_iter58.getValue());
+            oprot.writeBinary(_iter66.getKey());
+            oprot.writeI32(_iter66.getValue());
           }
           oprot.writeMapEnd();
         }
@@ -10323,14 +10521,14 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.LIST) {
               {
-                TList _list59 = iprot.readListBegin();
-                this.success = new ArrayList<KeySlice>(_list59.size);
-                for (int _i60 = 0; _i60 < _list59.size; ++_i60)
+                TList _list67 = iprot.readListBegin();
+                this.success = new ArrayList<KeySlice>(_list67.size);
+                for (int _i68 = 0; _i68 < _list67.size; ++_i68)
                 {
-                  KeySlice _elem61;
-                  _elem61 = new KeySlice();
-                  _elem61.read(iprot);
-                  this.success.add(_elem61);
+                  KeySlice _elem69;
+                  _elem69 = new KeySlice();
+                  _elem69.read(iprot);
+                  this.success.add(_elem69);
                 }
                 iprot.readListEnd();
               }
@@ -10380,9 +10578,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
-          for (KeySlice _iter62 : this.success)
+          for (KeySlice _iter70 : this.success)
           {
-            _iter62.write(oprot);
+            _iter70.write(oprot);
           }
           oprot.writeListEnd();
         }
@@ -10450,6 +10648,2290 @@ public void validate() throws TException {
 
   }
 
+  public static class scan_args implements TBase<scan_args._Fields>, java.io.Serializable, Cloneable, Comparable<scan_args>   {
+    private static final TStruct STRUCT_DESC = new TStruct("scan_args");
+
+    private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)1);
+    private static final TField ROW_PREDICATE_FIELD_DESC = new TField("row_predicate", TType.STRUCT, (short)2);
+    private static final TField COLUMN_PREDICATE_FIELD_DESC = new TField("column_predicate", TType.STRUCT, (short)3);
+    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)4);
+
+    public ColumnParent column_parent;
+    public RowPredicate row_predicate;
+    public SlicePredicate column_predicate;
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public ConsistencyLevel consistency_level;
+
+    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+    public enum _Fields implements TFieldIdEnum {
+      COLUMN_PARENT((short)1, "column_parent"),
+      ROW_PREDICATE((short)2, "row_predicate"),
+      COLUMN_PREDICATE((short)3, "column_predicate"),
+      /**
+       * 
+       * @see ConsistencyLevel
+       */
+      CONSISTENCY_LEVEL((short)4, "consistency_level");
+
+      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
+      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+      static {
+        for (_Fields field : EnumSet.allOf(_Fields.class)) {
+          byId.put((int)field._thriftId, field);
+          byName.put(field.getFieldName(), field);
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, or null if its not found.
+       */
+      public static _Fields findByThriftId(int fieldId) {
+        return byId.get(fieldId);
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, throwing an exception
+       * if it is not found.
+       */
+      public static _Fields findByThriftIdOrThrow(int fieldId) {
+        _Fields fields = findByThriftId(fieldId);
+        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+        return fields;
+      }
+
+      /**
+       * Find the _Fields constant that matches name, or null if its not found.
+       */
+      public static _Fields findByName(String name) {
+        return byName.get(name);
+      }
+
+      private final short _thriftId;
+      private final String _fieldName;
+
+      _Fields(short thriftId, String fieldName) {
+        _thriftId = thriftId;
+        _fieldName = fieldName;
+      }
+
+      public short getThriftFieldId() {
+        return _thriftId;
+      }
+
+      public String getFieldName() {
+        return _fieldName;
+      }
+    }
+
+    // isset id assignments
+
+    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
+      put(_Fields.COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, 
+          new StructMetaData(TType.STRUCT, ColumnParent.class)));
+      put(_Fields.ROW_PREDICATE, new FieldMetaData("row_predicate", TFieldRequirementType.REQUIRED, 
+          new StructMetaData(TType.STRUCT, RowPredicate.class)));
+      put(_Fields.COLUMN_PREDICATE, new FieldMetaData("column_predicate", TFieldRequirementType.REQUIRED, 
+          new StructMetaData(TType.STRUCT, SlicePredicate.class)));
+      put(_Fields.CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
+          new EnumMetaData(TType.ENUM, ConsistencyLevel.class)));
+    }});
+
+    static {
+      FieldMetaData.addStructMetaDataMap(scan_args.class, metaDataMap);
+    }
+
+    public scan_args() {
+      this.consistency_level = ConsistencyLevel.ONE;
+
+    }
+
+    public scan_args(
+      ColumnParent column_parent,
+      RowPredicate row_predicate,
+      SlicePredicate column_predicate,
+      ConsistencyLevel consistency_level)
+    {
+      this();
+      this.column_parent = column_parent;
+      this.row_predicate = row_predicate;
+      this.column_predicate = column_predicate;
+      this.consistency_level = consistency_level;
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public scan_args(scan_args other) {
+      if (other.isSetColumn_parent()) {
+        this.column_parent = new ColumnParent(other.column_parent);
+      }
+      if (other.isSetRow_predicate()) {
+        this.row_predicate = new RowPredicate(other.row_predicate);
+      }
+      if (other.isSetColumn_predicate()) {
+        this.column_predicate = new SlicePredicate(other.column_predicate);
+      }
+      if (other.isSetConsistency_level()) {
+        this.consistency_level = other.consistency_level;
+      }
+    }
+
+    public scan_args deepCopy() {
+      return new scan_args(this);
+    }
+
+    @Deprecated
+    public scan_args clone() {
+      return new scan_args(this);
+    }
+
+    public ColumnParent getColumn_parent() {
+      return this.column_parent;
+    }
+
+    public scan_args setColumn_parent(ColumnParent column_parent) {
+      this.column_parent = column_parent;
+      return this;
+    }
+
+    public void unsetColumn_parent() {
+      this.column_parent = null;
+    }
+
+    /** Returns true if field column_parent is set (has been asigned a value) and false otherwise */
+    public boolean isSetColumn_parent() {
+      return this.column_parent != null;
+    }
+
+    public void setColumn_parentIsSet(boolean value) {
+      if (!value) {
+        this.column_parent = null;
+      }
+    }
+
+    public RowPredicate getRow_predicate() {
+      return this.row_predicate;
+    }
+
+    public scan_args setRow_predicate(RowPredicate row_predicate) {
+      this.row_predicate = row_predicate;
+      return this;
+    }
+
+    public void unsetRow_predicate() {
+      this.row_predicate = null;
+    }
+
+    /** Returns true if field row_predicate is set (has been asigned a value) and false otherwise */
+    public boolean isSetRow_predicate() {
+      return this.row_predicate != null;
+    }
+
+    public void setRow_predicateIsSet(boolean value) {
+      if (!value) {
+        this.row_predicate = null;
+      }
+    }
+
+    public SlicePredicate getColumn_predicate() {
+      return this.column_predicate;
+    }
+
+    public scan_args setColumn_predicate(SlicePredicate column_predicate) {
+      this.column_predicate = column_predicate;
+      return this;
+    }
+
+    public void unsetColumn_predicate() {
+      this.column_predicate = null;
+    }
+
+    /** Returns true if field column_predicate is set (has been asigned a value) and false otherwise */
+    public boolean isSetColumn_predicate() {
+      return this.column_predicate != null;
+    }
+
+    public void setColumn_predicateIsSet(boolean value) {
+      if (!value) {
+        this.column_predicate = null;
+      }
+    }
+
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public ConsistencyLevel getConsistency_level() {
+      return this.consistency_level;
+    }
+
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public scan_args setConsistency_level(ConsistencyLevel consistency_level) {
+      this.consistency_level = consistency_level;
+      return this;
+    }
+
+    public void unsetConsistency_level() {
+      this.consistency_level = null;
+    }
+
+    /** Returns true if field consistency_level is set (has been asigned a value) and false otherwise */
+    public boolean isSetConsistency_level() {
+      return this.consistency_level != null;
+    }
+
+    public void setConsistency_levelIsSet(boolean value) {
+      if (!value) {
+        this.consistency_level = null;
+      }
+    }
+
+    public void setFieldValue(_Fields field, Object value) {
+      switch (field) {
+      case COLUMN_PARENT:
+        if (value == null) {
+          unsetColumn_parent();
+        } else {
+          setColumn_parent((ColumnParent)value);
+        }
+        break;
+
+      case ROW_PREDICATE:
+        if (value == null) {
+          unsetRow_predicate();
+        } else {
+          setRow_predicate((RowPredicate)value);
+        }
+        break;
+
+      case COLUMN_PREDICATE:
+        if (value == null) {
+          unsetColumn_predicate();
+        } else {
+          setColumn_predicate((SlicePredicate)value);
+        }
+        break;
+
+      case CONSISTENCY_LEVEL:
+        if (value == null) {
+          unsetConsistency_level();
+        } else {
+          setConsistency_level((ConsistencyLevel)value);
+        }
+        break;
+
+      }
+    }
+
+    public void setFieldValue(int fieldID, Object value) {
+      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
+    }
+
+    public Object getFieldValue(_Fields field) {
+      switch (field) {
+      case COLUMN_PARENT:
+        return getColumn_parent();
+
+      case ROW_PREDICATE:
+        return getRow_predicate();
+
+      case COLUMN_PREDICATE:
+        return getColumn_predicate();
+
+      case CONSISTENCY_LEVEL:
+        return getConsistency_level();
+
+      }
+      throw new IllegalStateException();
+    }
+
+    public Object getFieldValue(int fieldId) {
+      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
+    }
+
+    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
+    public boolean isSet(_Fields field) {
+      switch (field) {
+      case COLUMN_PARENT:
+        return isSetColumn_parent();
+      case ROW_PREDICATE:
+        return isSetRow_predicate();
+      case COLUMN_PREDICATE:
+        return isSetColumn_predicate();
+      case CONSISTENCY_LEVEL:
+        return isSetConsistency_level();
+      }
+      throw new IllegalStateException();
+    }
+
+    public boolean isSet(int fieldID) {
+      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof scan_args)
+        return this.equals((scan_args)that);
+      return false;
+    }
+
+    public boolean equals(scan_args that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_column_parent = true && this.isSetColumn_parent();
+      boolean that_present_column_parent = true && that.isSetColumn_parent();
+      if (this_present_column_parent || that_present_column_parent) {
+        if (!(this_present_column_parent && that_present_column_parent))
+          return false;
+        if (!this.column_parent.equals(that.column_parent))
+          return false;
+      }
+
+      boolean this_present_row_predicate = true && this.isSetRow_predicate();
+      boolean that_present_row_predicate = true && that.isSetRow_predicate();
+      if (this_present_row_predicate || that_present_row_predicate) {
+        if (!(this_present_row_predicate && that_present_row_predicate))
+          return false;
+        if (!this.row_predicate.equals(that.row_predicate))
+          return false;
+      }
+
+      boolean this_present_column_predicate = true && this.isSetColumn_predicate();
+      boolean that_present_column_predicate = true && that.isSetColumn_predicate();
+      if (this_present_column_predicate || that_present_column_predicate) {
+        if (!(this_present_column_predicate && that_present_column_predicate))
+          return false;
+        if (!this.column_predicate.equals(that.column_predicate))
+          return false;
+      }
+
+      boolean this_present_consistency_level = true && this.isSetConsistency_level();
+      boolean that_present_consistency_level = true && that.isSetConsistency_level();
+      if (this_present_consistency_level || that_present_consistency_level) {
+        if (!(this_present_consistency_level && that_present_consistency_level))
+          return false;
+        if (!this.consistency_level.equals(that.consistency_level))
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      return 0;
+    }
+
+    public int compareTo(scan_args other) {
+      if (!getClass().equals(other.getClass())) {
+        return getClass().getName().compareTo(other.getClass().getName());
+      }
+
+      int lastComparison = 0;
+      scan_args typedOther = (scan_args)other;
+
+      lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(typedOther.isSetColumn_parent());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetColumn_parent()) {        lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetRow_predicate()).compareTo(typedOther.isSetRow_predicate());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetRow_predicate()) {        lastComparison = TBaseHelper.compareTo(row_predicate, typedOther.row_predicate);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetColumn_predicate()).compareTo(typedOther.isSetColumn_predicate());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetColumn_predicate()) {        lastComparison = TBaseHelper.compareTo(column_predicate, typedOther.column_predicate);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(typedOther.isSetConsistency_level());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetConsistency_level()) {        lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      return 0;
+    }
+
+    public void read(TProtocol iprot) throws TException {
+      TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == TType.STOP) { 
+          break;
+        }
+        switch (field.id) {
+          case 1: // COLUMN_PARENT
+            if (field.type == TType.STRUCT) {
+              this.column_parent = new ColumnParent();
+              this.column_parent.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case 2: // ROW_PREDICATE
+            if (field.type == TType.STRUCT) {
+              this.row_predicate = new RowPredicate();
+              this.row_predicate.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case 3: // COLUMN_PREDICATE
+            if (field.type == TType.STRUCT) {
+              this.column_predicate = new SlicePredicate();
+              this.column_predicate.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case 4: // CONSISTENCY_LEVEL
+            if (field.type == TType.I32) {
+              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            TProtocolUtil.skip(iprot, field.type);
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+
+      // check for required fields of primitive type, which can't be checked in the validate method
+      validate();
+    }
+
+    public void write(TProtocol oprot) throws TException {
+      validate();
+
+      oprot.writeStructBegin(STRUCT_DESC);
+      if (this.column_parent != null) {
+        oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
+        this.column_parent.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      if (this.row_predicate != null) {
+        oprot.writeFieldBegin(ROW_PREDICATE_FIELD_DESC);
+        this.row_predicate.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      if (this.column_predicate != null) {
+        oprot.writeFieldBegin(COLUMN_PREDICATE_FIELD_DESC);
+        this.column_predicate.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      if (this.consistency_level != null) {
+        oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
+        oprot.writeI32(this.consistency_level.getValue());
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("scan_args(");
+      boolean first = true;
+
+      sb.append("column_parent:");
+      if (this.column_parent == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.column_parent);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("row_predicate:");
+      if (this.row_predicate == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.row_predicate);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("column_predicate:");
+      if (this.column_predicate == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.column_predicate);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("consistency_level:");
+      if (this.consistency_level == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.consistency_level);
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws TException {
+      // check for required fields
+      if (column_parent == null) {
+        throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
+      }
+      if (row_predicate == null) {
+        throw new TProtocolException("Required field 'row_predicate' was not present! Struct: " + toString());
+      }
+      if (column_predicate == null) {
+        throw new TProtocolException("Required field 'column_predicate' was not present! Struct: " + toString());
+      }
+      if (consistency_level == null) {
+        throw new TProtocolException("Required field 'consistency_level' was not present! Struct: " + toString());
+      }
+    }
+
+  }
+
+  public static class scan_result implements TBase<scan_result._Fields>, java.io.Serializable, Cloneable, Comparable<scan_result>   {
+    private static final TStruct STRUCT_DESC = new TStruct("scan_result");
+
+    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
+    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
+    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
+    private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short)3);
+
+    public List<KeySlice> success;
+    public InvalidRequestException ire;
+    public UnavailableException ue;
+    public TimedOutException te;
+
+    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+    public enum _Fields implements TFieldIdEnum {
+      SUCCESS((short)0, "success"),
+      IRE((short)1, "ire"),
+      UE((short)2, "ue"),
+      TE((short)3, "te");
+
+      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
+      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+      static {
+        for (_Fields field : EnumSet.allOf(_Fields.class)) {
+          byId.put((int)field._thriftId, field);
+          byName.put(field.getFieldName(), field);
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, or null if its not found.
+       */
+      public static _Fields findByThriftId(int fieldId) {
+        return byId.get(fieldId);
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, throwing an exception
+       * if it is not found.
+       */
+      public static _Fields findByThriftIdOrThrow(int fieldId) {
+        _Fields fields = findByThriftId(fieldId);
+        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+        return fields;
+      }
+
+      /**
+       * Find the _Fields constant that matches name, or null if its not found.
+       */
+      public static _Fields findByName(String name) {
+        return byName.get(name);
+      }
+
+      private final short _thriftId;
+      private final String _fieldName;
+
+      _Fields(short thriftId, String fieldName) {
+        _thriftId = thriftId;
+        _fieldName = fieldName;
+      }
+
+      public short getThriftFieldId() {
+        return _thriftId;
+      }
+
+      public String getFieldName() {
+        return _fieldName;
+      }
+    }
+
+    // isset id assignments
+
+    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
+      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
+          new ListMetaData(TType.LIST, 
+              new StructMetaData(TType.STRUCT, KeySlice.class))));
+      put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
+      put(_Fields.UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
+      put(_Fields.TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
+    }});
+
+    static {
+      FieldMetaData.addStructMetaDataMap(scan_result.class, metaDataMap);
+    }
+
+    public scan_result() {
+    }
+
+    public scan_result(
+      List<KeySlice> success,
+      InvalidRequestException ire,
+      UnavailableException ue,
+      TimedOutException te)
+    {
+      this();
+      this.success = success;
+      this.ire = ire;
+      this.ue = ue;
+      this.te = te;
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public scan_result(scan_result other) {
+      if (other.isSetSuccess()) {
+        List<KeySlice> __this__success = new ArrayList<KeySlice>();
+        for (KeySlice other_element : other.success) {
+          __this__success.add(new KeySlice(other_element));
+        }
+        this.success = __this__success;
+      }
+      if (other.isSetIre()) {
+        this.ire = new InvalidRequestException(other.ire);
+      }
+      if (other.isSetUe()) {
+        this.ue = new UnavailableException(other.ue);
+      }
+      if (other.isSetTe()) {
+        this.te = new TimedOutException(other.te);
+      }
+    }
+
+    public scan_result deepCopy() {
+      return new scan_result(this);
+    }
+
+    @Deprecated
+    public scan_result clone() {
+      return new scan_result(this);
+    }
+
+    public int getSuccessSize() {
+      return (this.success == null) ? 0 : this.success.size();
+    }
+
+    public java.util.Iterator<KeySlice> getSuccessIterator() {
+      return (this.success == null) ? null : this.success.iterator();
+    }
+
+    public void addToSuccess(KeySlice elem) {
+      if (this.success == null) {
+        this.success = new ArrayList<KeySlice>();
+      }
+      this.success.add(elem);
+    }
+
+    public List<KeySlice> getSuccess() {
+      return this.success;
+    }
+
+    public scan_result setSuccess(List<KeySlice> success) {
+      this.success = success;
+      return this;
+    }
+
+    public void unsetSuccess() {
+      this.success = null;
+    }
+
+    /** Returns true if field success is set (has been asigned a value) and false otherwise */
+    public boolean isSetSuccess() {
+      return this.success != null;
+    }
+
+    public void setSuccessIsSet(boolean value) {
+      if (!value) {
+        this.success = null;
+      }
+    }
+
+    public InvalidRequestException getIre() {
+      return this.ire;
+    }
+
+    public scan_result setIre(InvalidRequestException ire) {
+      this.ire = ire;
+      return this;
+    }
+
+    public void unsetIre() {
+      this.ire = null;
+    }
+
+    /** Returns true if field ire is set (has been asigned a value) and false otherwise */
+    public boolean isSetIre() {
+      return this.ire != null;
+    }
+
+    public void setIreIsSet(boolean value) {
+      if (!value) {
+        this.ire = null;
+      }
+    }
+
+    public UnavailableException getUe() {
+      return this.ue;
+    }
+
+    public scan_result setUe(UnavailableException ue) {
+      this.ue = ue;
+      return this;
+    }
+
+    public void unsetUe() {
+      this.ue = null;
+    }
+
+    /** Returns true if field ue is set (has been asigned a value) and false otherwise */
+    public boolean isSetUe() {
+      return this.ue != null;
+    }
+
+    public void setUeIsSet(boolean value) {
+      if (!value) {
+        this.ue = null;
+      }
+    }
+
+    public TimedOutException getTe() {
+      return this.te;
+    }
+
+    public scan_result setTe(TimedOutException te) {
+      this.te = te;
+      return this;
+    }
+
+    public void unsetTe() {
+      this.te = null;
+    }
+
+    /** Returns true if field te is set (has been asigned a value) and false otherwise */
+    public boolean isSetTe() {
+      return this.te != null;
+    }
+
+    public void setTeIsSet(boolean value) {
+      if (!value) {
+        this.te = null;
+      }
+    }
+
+    public void setFieldValue(_Fields field, Object value) {
+      switch (field) {
+      case SUCCESS:
+        if (value == null) {
+          unsetSuccess();
+        } else {
+          setSuccess((List<KeySlice>)value);
+        }
+        break;
+
+      case IRE:
+        if (value == null) {
+          unsetIre();
+        } else {
+          setIre((InvalidRequestException)value);
+        }
+        break;
+
+      case UE:
+        if (value == null) {
+          unsetUe();
+        } else {
+          setUe((UnavailableException)value);
+        }
+        break;
+
+      case TE:
+        if (value == null) {
+          unsetTe();
+        } else {
+          setTe((TimedOutException)value);
+        }
+        break;
+
+      }
+    }
+
+    public void setFieldValue(int fieldID, Object value) {
+      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
+    }
+
+    public Object getFieldValue(_Fields field) {
+      switch (field) {
+      case SUCCESS:
+        return getSuccess();
+
+      case IRE:
+        return getIre();
+
+      case UE:
+        return getUe();
+
+      case TE:
+        return getTe();
+
+      }
+      throw new IllegalStateException();
+    }
+
+    public Object getFieldValue(int fieldId) {
+      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
+    }
+
+    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
+    public boolean isSet(_Fields field) {
+      switch (field) {
+      case SUCCESS:
+        return isSetSuccess();
+      case IRE:
+        return isSetIre();
+      case UE:
+        return isSetUe();
+      case TE:
+        return isSetTe();
+      }
+      throw new IllegalStateException();
+    }
+
+    public boolean isSet(int fieldID) {
+      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof scan_result)
+        return this.equals((scan_result)that);
+      return false;
+    }
+
+    public boolean equals(scan_result that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_success = true && this.isSetSuccess();
+      boolean that_present_success = true && that.isSetSuccess();
+      if (this_present_success || that_present_success) {
+        if (!(this_present_success && that_present_success))
+          return false;
+        if (!this.success.equals(that.success))
+          return false;
+      }
+
+      boolean this_present_ire = true && this.isSetIre();
+      boolean that_present_ire = true && that.isSetIre();
+      if (this_present_ire || that_present_ire) {
+        if (!(this_present_ire && that_present_ire))
+          return false;
+        if (!this.ire.equals(that.ire))
+          return false;
+      }
+
+      boolean this_present_ue = true && this.isSetUe();
+      boolean that_present_ue = true && that.isSetUe();
+      if (this_present_ue || that_present_ue) {
+        if (!(this_present_ue && that_present_ue))
+          return false;
+        if (!this.ue.equals(that.ue))
+          return false;
+      }
+
+      boolean this_present_te = true && this.isSetTe();
+      boolean that_present_te = true && that.isSetTe();
+      if (this_present_te || that_present_te) {
+        if (!(this_present_te && that_present_te))
+          return false;
+        if (!this.te.equals(that.te))
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      return 0;
+    }
+
+    public int compareTo(scan_result other) {
+      if (!getClass().equals(other.getClass())) {
+        return getClass().getName().compareTo(other.getClass().getName());
+      }
+
+      int lastComparison = 0;
+      scan_result typedOther = (scan_result)other;
+
+      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(success, typedOther.success);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetUe()).compareTo(typedOther.isSetUe());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetUe()) {        lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetTe()).compareTo(typedOther.isSetTe());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetTe()) {        lastComparison = TBaseHelper.compareTo(te, typedOther.te);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      return 0;
+    }
+
+    public void read(TProtocol iprot) throws TException {
+      TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == TType.STOP) { 
+          break;
+        }
+        switch (field.id) {
+          case 0: // SUCCESS
+            if (field.type == TType.LIST) {
+              {
+                TList _list71 = iprot.readListBegin();
+                this.success = new ArrayList<KeySlice>(_list71.size);
+                for (int _i72 = 0; _i72 < _list71.size; ++_i72)
+                {
+                  KeySlice _elem73;
+                  _elem73 = new KeySlice();
+                  _elem73.read(iprot);
+                  this.success.add(_elem73);
+                }
+                iprot.readListEnd();
+              }
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case 1: // IRE
+            if (field.type == TType.STRUCT) {
+              this.ire = new InvalidRequestException();
+              this.ire.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case 2: // UE
+            if (field.type == TType.STRUCT) {
+              this.ue = new UnavailableException();
+              this.ue.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case 3: // TE
+            if (field.type == TType.STRUCT) {
+              this.te = new TimedOutException();
+              this.te.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            TProtocolUtil.skip(iprot, field.type);
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+
+      // check for required fields of primitive type, which can't be checked in the validate method
+      validate();
+    }
+
+    public void write(TProtocol oprot) throws TException {
+      oprot.writeStructBegin(STRUCT_DESC);
+
+      if (this.isSetSuccess()) {
+        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
+        {
+          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
+          for (KeySlice _iter74 : this.success)
+          {
+            _iter74.write(oprot);
+          }
+          oprot.writeListEnd();
+        }
+        oprot.writeFieldEnd();
+      } else if (this.isSetIre()) {
+        oprot.writeFieldBegin(IRE_FIELD_DESC);
+        this.ire.write(oprot);
+        oprot.writeFieldEnd();
+      } else if (this.isSetUe()) {
+        oprot.writeFieldBegin(UE_FIELD_DESC);
+        this.ue.write(oprot);
+        oprot.writeFieldEnd();
+      } else if (this.isSetTe()) {
+        oprot.writeFieldBegin(TE_FIELD_DESC);
+        this.te.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("scan_result(");
+      boolean first = true;
+
+      sb.append("success:");
+      if (this.success == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.success);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("ire:");
+      if (this.ire == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ire);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("ue:");
+      if (this.ue == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ue);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("te:");
+      if (this.te == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.te);
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws TException {
+      // check for required fields
+    }
+
+  }
+
+  public static class scan_count_args implements TBase<scan_count_args._Fields>, java.io.Serializable, Cloneable, Comparable<scan_count_args>   {
+    private static final TStruct STRUCT_DESC = new TStruct("scan_count_args");
+
+    private static final TField COLUMN_PARENT_FIELD_DESC = new TField("column_parent", TType.STRUCT, (short)1);
+    private static final TField ROW_PREDICATE_FIELD_DESC = new TField("row_predicate", TType.STRUCT, (short)2);
+    private static final TField COLUMN_PREDICATE_FIELD_DESC = new TField("column_predicate", TType.STRUCT, (short)3);
+    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)4);
+
+    public ColumnParent column_parent;
+    public RowPredicate row_predicate;
+    public SlicePredicate column_predicate;
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public ConsistencyLevel consistency_level;
+
+    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+    public enum _Fields implements TFieldIdEnum {
+      COLUMN_PARENT((short)1, "column_parent"),
+      ROW_PREDICATE((short)2, "row_predicate"),
+      COLUMN_PREDICATE((short)3, "column_predicate"),
+      /**
+       * 
+       * @see ConsistencyLevel
+       */
+      CONSISTENCY_LEVEL((short)4, "consistency_level");
+
+      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
+      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+      static {
+        for (_Fields field : EnumSet.allOf(_Fields.class)) {
+          byId.put((int)field._thriftId, field);
+          byName.put(field.getFieldName(), field);
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, or null if its not found.
+       */
+      public static _Fields findByThriftId(int fieldId) {
+        return byId.get(fieldId);
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, throwing an exception
+       * if it is not found.
+       */
+      public static _Fields findByThriftIdOrThrow(int fieldId) {
+        _Fields fields = findByThriftId(fieldId);
+        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+        return fields;
+      }
+
+      /**
+       * Find the _Fields constant that matches name, or null if its not found.
+       */
+      public static _Fields findByName(String name) {
+        return byName.get(name);
+      }
+
+      private final short _thriftId;
+      private final String _fieldName;
+
+      _Fields(short thriftId, String fieldName) {
+        _thriftId = thriftId;
+        _fieldName = fieldName;
+      }
+
+      public short getThriftFieldId() {
+        return _thriftId;
+      }
+
+      public String getFieldName() {
+        return _fieldName;
+      }
+    }
+
+    // isset id assignments
+
+    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
+      put(_Fields.COLUMN_PARENT, new FieldMetaData("column_parent", TFieldRequirementType.REQUIRED, 
+          new StructMetaData(TType.STRUCT, ColumnParent.class)));
+      put(_Fields.ROW_PREDICATE, new FieldMetaData("row_predicate", TFieldRequirementType.REQUIRED, 
+          new StructMetaData(TType.STRUCT, RowPredicate.class)));
+      put(_Fields.COLUMN_PREDICATE, new FieldMetaData("column_predicate", TFieldRequirementType.REQUIRED, 
+          new StructMetaData(TType.STRUCT, SlicePredicate.class)));
+      put(_Fields.CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
+          new EnumMetaData(TType.ENUM, ConsistencyLevel.class)));
+    }});
+
+    static {
+      FieldMetaData.addStructMetaDataMap(scan_count_args.class, metaDataMap);
+    }
+
+    public scan_count_args() {
+      this.consistency_level = ConsistencyLevel.ONE;
+
+    }
+
+    public scan_count_args(
+      ColumnParent column_parent,
+      RowPredicate row_predicate,
+      SlicePredicate column_predicate,
+      ConsistencyLevel consistency_level)
+    {
+      this();
+      this.column_parent = column_parent;
+      this.row_predicate = row_predicate;
+      this.column_predicate = column_predicate;
+      this.consistency_level = consistency_level;
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public scan_count_args(scan_count_args other) {
+      if (other.isSetColumn_parent()) {
+        this.column_parent = new ColumnParent(other.column_parent);
+      }
+      if (other.isSetRow_predicate()) {
+        this.row_predicate = new RowPredicate(other.row_predicate);
+      }
+      if (other.isSetColumn_predicate()) {
+        this.column_predicate = new SlicePredicate(other.column_predicate);
+      }
+      if (other.isSetConsistency_level()) {
+        this.consistency_level = other.consistency_level;
+      }
+    }
+
+    public scan_count_args deepCopy() {
+      return new scan_count_args(this);
+    }
+
+    @Deprecated
+    public scan_count_args clone() {
+      return new scan_count_args(this);
+    }
+
+    public ColumnParent getColumn_parent() {
+      return this.column_parent;
+    }
+
+    public scan_count_args setColumn_parent(ColumnParent column_parent) {
+      this.column_parent = column_parent;
+      return this;
+    }
+
+    public void unsetColumn_parent() {
+      this.column_parent = null;
+    }
+
+    /** Returns true if field column_parent is set (has been asigned a value) and false otherwise */
+    public boolean isSetColumn_parent() {
+      return this.column_parent != null;
+    }
+
+    public void setColumn_parentIsSet(boolean value) {
+      if (!value) {
+        this.column_parent = null;
+      }
+    }
+
+    public RowPredicate getRow_predicate() {
+      return this.row_predicate;
+    }
+
+    public scan_count_args setRow_predicate(RowPredicate row_predicate) {
+      this.row_predicate = row_predicate;
+      return this;
+    }
+
+    public void unsetRow_predicate() {
+      this.row_predicate = null;
+    }
+
+    /** Returns true if field row_predicate is set (has been asigned a value) and false otherwise */
+    public boolean isSetRow_predicate() {
+      return this.row_predicate != null;
+    }
+
+    public void setRow_predicateIsSet(boolean value) {
+      if (!value) {
+        this.row_predicate = null;
+      }
+    }
+
+    public SlicePredicate getColumn_predicate() {
+      return this.column_predicate;
+    }
+
+    public scan_count_args setColumn_predicate(SlicePredicate column_predicate) {
+      this.column_predicate = column_predicate;
+      return this;
+    }
+
+    public void unsetColumn_predicate() {
+      this.column_predicate = null;
+    }
+
+    /** Returns true if field column_predicate is set (has been asigned a value) and false otherwise */
+    public boolean isSetColumn_predicate() {
+      return this.column_predicate != null;
+    }
+
+    public void setColumn_predicateIsSet(boolean value) {
+      if (!value) {
+        this.column_predicate = null;
+      }
+    }
+
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public ConsistencyLevel getConsistency_level() {
+      return this.consistency_level;
+    }
+
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public scan_count_args setConsistency_level(ConsistencyLevel consistency_level) {
+      this.consistency_level = consistency_level;
+      return this;
+    }
+
+    public void unsetConsistency_level() {
+      this.consistency_level = null;
+    }
+
+    /** Returns true if field consistency_level is set (has been asigned a value) and false otherwise */
+    public boolean isSetConsistency_level() {
+      return this.consistency_level != null;
+    }
+
+    public void setConsistency_levelIsSet(boolean value) {
+      if (!value) {
+        this.consistency_level = null;
+      }
+    }
+
+    public void setFieldValue(_Fields field, Object value) {
+      switch (field) {
+      case COLUMN_PARENT:
+        if (value == null) {
+          unsetColumn_parent();
+        } else {
+          setColumn_parent((ColumnParent)value);
+        }
+        break;
+
+      case ROW_PREDICATE:
+        if (value == null) {
+          unsetRow_predicate();
+        } else {
+          setRow_predicate((RowPredicate)value);
+        }
+        break;
+
+      case COLUMN_PREDICATE:
+        if (value == null) {
+          unsetColumn_predicate();
+        } else {
+          setColumn_predicate((SlicePredicate)value);
+        }
+        break;
+
+      case CONSISTENCY_LEVEL:
+        if (value == null) {
+          unsetConsistency_level();
+        } else {
+          setConsistency_level((ConsistencyLevel)value);
+        }
+        break;
+
+      }
+    }
+
+    public void setFieldValue(int fieldID, Object value) {
+      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
+    }
+
+    public Object getFieldValue(_Fields field) {
+      switch (field) {
+      case COLUMN_PARENT:
+        return getColumn_parent();
+
+      case ROW_PREDICATE:
+        return getRow_predicate();
+
+      case COLUMN_PREDICATE:
+        return getColumn_predicate();
+
+      case CONSISTENCY_LEVEL:
+        return getConsistency_level();
+
+      }
+      throw new IllegalStateException();
+    }
+
+    public Object getFieldValue(int fieldId) {
+      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
+    }
+
+    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
+    public boolean isSet(_Fields field) {
+      switch (field) {
+      case COLUMN_PARENT:
+        return isSetColumn_parent();
+      case ROW_PREDICATE:
+        return isSetRow_predicate();
+      case COLUMN_PREDICATE:
+        return isSetColumn_predicate();
+      case CONSISTENCY_LEVEL:
+        return isSetConsistency_level();
+      }
+      throw new IllegalStateException();
+    }
+
+    public boolean isSet(int fieldID) {
+      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof scan_count_args)
+        return this.equals((scan_count_args)that);
+      return false;
+    }
+
+    public boolean equals(scan_count_args that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_column_parent = true && this.isSetColumn_parent();
+      boolean that_present_column_parent = true && that.isSetColumn_parent();
+      if (this_present_column_parent || that_present_column_parent) {
+        if (!(this_present_column_parent && that_present_column_parent))
+          return false;
+        if (!this.column_parent.equals(that.column_parent))
+          return false;
+      }
+
+      boolean this_present_row_predicate = true && this.isSetRow_predicate();
+      boolean that_present_row_predicate = true && that.isSetRow_predicate();
+      if (this_present_row_predicate || that_present_row_predicate) {
+        if (!(this_present_row_predicate && that_present_row_predicate))
+          return false;
+        if (!this.row_predicate.equals(that.row_predicate))
+          return false;
+      }
+
+      boolean this_present_column_predicate = true && this.isSetColumn_predicate();
+      boolean that_present_column_predicate = true && that.isSetColumn_predicate();
+      if (this_present_column_predicate || that_present_column_predicate) {
+        if (!(this_present_column_predicate && that_present_column_predicate))
+          return false;
+        if (!this.column_predicate.equals(that.column_predicate))
+          return false;
+      }
+
+      boolean this_present_consistency_level = true && this.isSetConsistency_level();
+      boolean that_present_consistency_level = true && that.isSetConsistency_level();
+      if (this_present_consistency_level || that_present_consistency_level) {
+        if (!(this_present_consistency_level && that_present_consistency_level))
+          return false;
+        if (!this.consistency_level.equals(that.consistency_level))
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      return 0;
+    }
+
+    public int compareTo(scan_count_args other) {
+      if (!getClass().equals(other.getClass())) {
+        return getClass().getName().compareTo(other.getClass().getName());
+      }
+
+      int lastComparison = 0;
+      scan_count_args typedOther = (scan_count_args)other;
+
+      lastComparison = Boolean.valueOf(isSetColumn_parent()).compareTo(typedOther.isSetColumn_parent());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetColumn_parent()) {        lastComparison = TBaseHelper.compareTo(column_parent, typedOther.column_parent);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetRow_predicate()).compareTo(typedOther.isSetRow_predicate());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetRow_predicate()) {        lastComparison = TBaseHelper.compareTo(row_predicate, typedOther.row_predicate);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetColumn_predicate()).compareTo(typedOther.isSetColumn_predicate());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetColumn_predicate()) {        lastComparison = TBaseHelper.compareTo(column_predicate, typedOther.column_predicate);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetConsistency_level()).compareTo(typedOther.isSetConsistency_level());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetConsistency_level()) {        lastComparison = TBaseHelper.compareTo(consistency_level, typedOther.consistency_level);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      return 0;
+    }
+
+    public void read(TProtocol iprot) throws TException {
+      TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == TType.STOP) { 
+          break;
+        }
+        switch (field.id) {
+          case 1: // COLUMN_PARENT
+            if (field.type == TType.STRUCT) {
+              this.column_parent = new ColumnParent();
+              this.column_parent.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case 2: // ROW_PREDICATE
+            if (field.type == TType.STRUCT) {
+              this.row_predicate = new RowPredicate();
+              this.row_predicate.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case 3: // COLUMN_PREDICATE
+            if (field.type == TType.STRUCT) {
+              this.column_predicate = new SlicePredicate();
+              this.column_predicate.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case 4: // CONSISTENCY_LEVEL
+            if (field.type == TType.I32) {
+              this.consistency_level = ConsistencyLevel.findByValue(iprot.readI32());
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            TProtocolUtil.skip(iprot, field.type);
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+
+      // check for required fields of primitive type, which can't be checked in the validate method
+      validate();
+    }
+
+    public void write(TProtocol oprot) throws TException {
+      validate();
+
+      oprot.writeStructBegin(STRUCT_DESC);
+      if (this.column_parent != null) {
+        oprot.writeFieldBegin(COLUMN_PARENT_FIELD_DESC);
+        this.column_parent.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      if (this.row_predicate != null) {
+        oprot.writeFieldBegin(ROW_PREDICATE_FIELD_DESC);
+        this.row_predicate.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      if (this.column_predicate != null) {
+        oprot.writeFieldBegin(COLUMN_PREDICATE_FIELD_DESC);
+        this.column_predicate.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      if (this.consistency_level != null) {
+        oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
+        oprot.writeI32(this.consistency_level.getValue());
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("scan_count_args(");
+      boolean first = true;
+
+      sb.append("column_parent:");
+      if (this.column_parent == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.column_parent);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("row_predicate:");
+      if (this.row_predicate == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.row_predicate);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("column_predicate:");
+      if (this.column_predicate == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.column_predicate);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("consistency_level:");
+      if (this.consistency_level == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.consistency_level);
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws TException {
+      // check for required fields
+      if (column_parent == null) {
+        throw new TProtocolException("Required field 'column_parent' was not present! Struct: " + toString());
+      }
+      if (row_predicate == null) {
+        throw new TProtocolException("Required field 'row_predicate' was not present! Struct: " + toString());
+      }
+      if (column_predicate == null) {
+        throw new TProtocolException("Required field 'column_predicate' was not present! Struct: " + toString());
+      }
+      if (consistency_level == null) {
+        throw new TProtocolException("Required field 'consistency_level' was not present! Struct: " + toString());
+      }
+    }
+
+  }
+
+  public static class scan_count_result implements TBase<scan_count_result._Fields>, java.io.Serializable, Cloneable, Comparable<scan_count_result>   {
+    private static final TStruct STRUCT_DESC = new TStruct("scan_count_result");
+
+    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
+    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
+    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
+    private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short)3);
+
+    public List<KeyCount> success;
+    public InvalidRequestException ire;
+    public UnavailableException ue;
+    public TimedOutException te;
+
+    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+    public enum _Fields implements TFieldIdEnum {
+      SUCCESS((short)0, "success"),
+      IRE((short)1, "ire"),
+      UE((short)2, "ue"),
+      TE((short)3, "te");
+
+      private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
+      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+      static {
+        for (_Fields field : EnumSet.allOf(_Fields.class)) {
+          byId.put((int)field._thriftId, field);
+          byName.put(field.getFieldName(), field);
+        }
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, or null if its not found.
+       */
+      public static _Fields findByThriftId(int fieldId) {
+        return byId.get(fieldId);
+      }
+
+      /**
+       * Find the _Fields constant that matches fieldId, throwing an exception
+       * if it is not found.
+       */
+      public static _Fields findByThriftIdOrThrow(int fieldId) {
+        _Fields fields = findByThriftId(fieldId);
+        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+        return fields;
+      }
+
+      /**
+       * Find the _Fields constant that matches name, or null if its not found.
+       */
+      public static _Fields findByName(String name) {
+        return byName.get(name);
+      }
+
+      private final short _thriftId;
+      private final String _fieldName;
+
+      _Fields(short thriftId, String fieldName) {
+        _thriftId = thriftId;
+        _fieldName = fieldName;
+      }
+
+      public short getThriftFieldId() {
+        return _thriftId;
+      }
+
+      public String getFieldName() {
+        return _fieldName;
+      }
+    }
+
+    // isset id assignments
+
+    public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
+      put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
+          new ListMetaData(TType.LIST, 
+              new StructMetaData(TType.STRUCT, KeyCount.class))));
+      put(_Fields.IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
+      put(_Fields.UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
+      put(_Fields.TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
+    }});
+
+    static {
+      FieldMetaData.addStructMetaDataMap(scan_count_result.class, metaDataMap);
+    }
+
+    public scan_count_result() {
+    }
+
+    public scan_count_result(
+      List<KeyCount> success,
+      InvalidRequestException ire,
+      UnavailableException ue,
+      TimedOutException te)
+    {
+      this();
+      this.success = success;
+      this.ire = ire;
+      this.ue = ue;
+      this.te = te;
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public scan_count_result(scan_count_result other) {
+      if (other.isSetSuccess()) {
+        List<KeyCount> __this__success = new ArrayList<KeyCount>();
+        for (KeyCount other_element : other.success) {
+          __this__success.add(new KeyCount(other_element));
+        }
+        this.success = __this__success;
+      }
+      if (other.isSetIre()) {
+        this.ire = new InvalidRequestException(other.ire);
+      }
+      if (other.isSetUe()) {
+        this.ue = new UnavailableException(other.ue);
+      }
+      if (other.isSetTe()) {
+        this.te = new TimedOutException(other.te);
+      }
+    }
+
+    public scan_count_result deepCopy() {
+      return new scan_count_result(this);
+    }
+
+    @Deprecated
+    public scan_count_result clone() {
+      return new scan_count_result(this);
+    }
+
+    public int getSuccessSize() {
+      return (this.success == null) ? 0 : this.success.size();
+    }
+
+    public java.util.Iterator<KeyCount> getSuccessIterator() {
+      return (this.success == null) ? null : this.success.iterator();
+    }
+
+    public void addToSuccess(KeyCount elem) {
+      if (this.success == null) {
+        this.success = new ArrayList<KeyCount>();
+      }
+      this.success.add(elem);
+    }
+
+    public List<KeyCount> getSuccess() {
+      return this.success;
+    }
+
+    public scan_count_result setSuccess(List<KeyCount> success) {
+      this.success = success;
+      return this;
+    }
+
+    public void unsetSuccess() {
+      this.success = null;
+    }
+
+    /** Returns true if field success is set (has been asigned a value) and false otherwise */
+    public boolean isSetSuccess() {
+      return this.success != null;
+    }
+
+    public void setSuccessIsSet(boolean value) {
+      if (!value) {
+        this.success = null;
+      }
+    }
+
+    public InvalidRequestException getIre() {
+      return this.ire;
+    }
+
+    public scan_count_result setIre(InvalidRequestException ire) {
+      this.ire = ire;
+      return this;
+    }
+
+    public void unsetIre() {
+      this.ire = null;
+    }
+
+    /** Returns true if field ire is set (has been asigned a value) and false otherwise */
+    public boolean isSetIre() {
+      return this.ire != null;
+    }
+
+    public void setIreIsSet(boolean value) {
+      if (!value) {
+        this.ire = null;
+      }
+    }
+
+    public UnavailableException getUe() {
+      return this.ue;
+    }
+
+    public scan_count_result setUe(UnavailableException ue) {
+      this.ue = ue;
+      return this;
+    }
+
+    public void unsetUe() {
+      this.ue = null;
+    }
+
+    /** Returns true if field ue is set (has been asigned a value) and false otherwise */
+    public boolean isSetUe() {
+      return this.ue != null;
+    }
+
+    public void setUeIsSet(boolean value) {
+      if (!value) {
+        this.ue = null;
+      }
+    }
+
+    public TimedOutException getTe() {
+      return this.te;
+    }
+
+    public scan_count_result setTe(TimedOutException te) {
+      this.te = te;
+      return this;
+    }
+
+    public void unsetTe() {
+      this.te = null;
+    }
+
+    /** Returns true if field te is set (has been asigned a value) and false otherwise */
+    public boolean isSetTe() {
+      return this.te != null;
+    }
+
+    public void setTeIsSet(boolean value) {
+      if (!value) {
+        this.te = null;
+      }
+    }
+
+    public void setFieldValue(_Fields field, Object value) {
+      switch (field) {
+      case SUCCESS:
+        if (value == null) {
+          unsetSuccess();
+        } else {
+          setSuccess((List<KeyCount>)value);
+        }
+        break;
+
+      case IRE:
+        if (value == null) {
+          unsetIre();
+        } else {
+          setIre((InvalidRequestException)value);
+        }
+        break;
+
+      case UE:
+        if (value == null) {
+          unsetUe();
+        } else {
+          setUe((UnavailableException)value);
+        }
+        break;
+
+      case TE:
+        if (value == null) {
+          unsetTe();
+        } else {
+          setTe((TimedOutException)value);
+        }
+        break;
+
+      }
+    }
+
+    public void setFieldValue(int fieldID, Object value) {
+      setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
+    }
+
+    public Object getFieldValue(_Fields field) {
+      switch (field) {
+      case SUCCESS:
+        return getSuccess();
+
+      case IRE:
+        return getIre();
+
+      case UE:
+        return getUe();
+
+      case TE:
+        return getTe();
+
+      }
+      throw new IllegalStateException();
+    }
+
+    public Object getFieldValue(int fieldId) {
+      return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
+    }
+
+    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
+    public boolean isSet(_Fields field) {
+      switch (field) {
+      case SUCCESS:
+        return isSetSuccess();
+      case IRE:
+        return isSetIre();
+      case UE:
+        return isSetUe();
+      case TE:
+        return isSetTe();
+      }
+      throw new IllegalStateException();
+    }
+
+    public boolean isSet(int fieldID) {
+      return isSet(_Fields.findByThriftIdOrThrow(fieldID));
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof scan_count_result)
+        return this.equals((scan_count_result)that);
+      return false;
+    }
+
+    public boolean equals(scan_count_result that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_success = true && this.isSetSuccess();
+      boolean that_present_success = true && that.isSetSuccess();
+      if (this_present_success || that_present_success) {
+        if (!(this_present_success && that_present_success))
+          return false;
+        if (!this.success.equals(that.success))
+          return false;
+      }
+
+      boolean this_present_ire = true && this.isSetIre();
+      boolean that_present_ire = true && that.isSetIre();
+      if (this_present_ire || that_present_ire) {
+        if (!(this_present_ire && that_present_ire))
+          return false;
+        if (!this.ire.equals(that.ire))
+          return false;
+      }
+
+      boolean this_present_ue = true && this.isSetUe();
+      boolean that_present_ue = true && that.isSetUe();
+      if (this_present_ue || that_present_ue) {
+        if (!(this_present_ue && that_present_ue))
+          return false;
+        if (!this.ue.equals(that.ue))
+          return false;
+      }
+
+      boolean this_present_te = true && this.isSetTe();
+      boolean that_present_te = true && that.isSetTe();
+      if (this_present_te || that_present_te) {
+        if (!(this_present_te && that_present_te))
+          return false;
+        if (!this.te.equals(that.te))
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      return 0;
+    }
+
+    public int compareTo(scan_count_result other) {
+      if (!getClass().equals(other.getClass())) {
+        return getClass().getName().compareTo(other.getClass().getName());
+      }
+
+      int lastComparison = 0;
+      scan_count_result typedOther = (scan_count_result)other;
+
+      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(success, typedOther.success);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetIre()).compareTo(typedOther.isSetIre());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetIre()) {        lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetUe()).compareTo(typedOther.isSetUe());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetUe()) {        lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      lastComparison = Boolean.valueOf(isSetTe()).compareTo(typedOther.isSetTe());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetTe()) {        lastComparison = TBaseHelper.compareTo(te, typedOther.te);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
+      return 0;
+    }
+
+    public void read(TProtocol iprot) throws TException {
+      TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == TType.STOP) { 
+          break;
+        }
+        switch (field.id) {
+          case 0: // SUCCESS
+            if (field.type == TType.LIST) {
+              {
+                TList _list75 = iprot.readListBegin();
+                this.success = new ArrayList<KeyCount>(_list75.size);
+                for (int _i76 = 0; _i76 < _list75.size; ++_i76)
+                {
+                  KeyCount _elem77;
+                  _elem77 = new KeyCount();
+                  _elem77.read(iprot);
+                  this.success.add(_elem77);
+                }
+                iprot.readListEnd();
+              }
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case 1: // IRE
+            if (field.type == TType.STRUCT) {
+              this.ire = new InvalidRequestException();
+              this.ire.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case 2: // UE
+            if (field.type == TType.STRUCT) {
+              this.ue = new UnavailableException();
+              this.ue.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case 3: // TE
+            if (field.type == TType.STRUCT) {
+              this.te = new TimedOutException();
+              this.te.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            TProtocolUtil.skip(iprot, field.type);
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+
+      // check for required fields of primitive type, which can't be checked in the validate method
+      validate();
+    }
+
+    public void write(TProtocol oprot) throws TException {
+      oprot.writeStructBegin(STRUCT_DESC);
+
+      if (this.isSetSuccess()) {
+        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
+        {
+          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
+          for (KeyCount _iter78 : this.success)
+          {
+            _iter78.write(oprot);
+          }
+          oprot.writeListEnd();
+        }
+        oprot.writeFieldEnd();
+      } else if (this.isSetIre()) {
+        oprot.writeFieldBegin(IRE_FIELD_DESC);
+        this.ire.write(oprot);
+        oprot.writeFieldEnd();
+      } else if (this.isSetUe()) {
+        oprot.writeFieldBegin(UE_FIELD_DESC);
+        this.ue.write(oprot);
+        oprot.writeFieldEnd();
+      } else if (this.isSetTe()) {
+        oprot.writeFieldBegin(TE_FIELD_DESC);
+        this.te.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("scan_count_result(");
+      boolean first = true;
+
+      sb.append("success:");
+      if (this.success == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.success);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("ire:");
+      if (this.ire == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ire);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("ue:");
+      if (this.ue == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ue);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("te:");
+      if (this.te == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.te);
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws TException {
+      // check for required fields
+    }
+
+  }
+
   public static class insert_args implements TBase<insert_args._Fields>, java.io.Serializable, Cloneable, Comparable<insert_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("insert_args");
 
@@ -12825,38 +15307,38 @@ public void read(TProtocol iprot) throws TException {
           case 1: // MUTATION_MAP
             if (field.type == TType.MAP) {
               {
-                TMap _map63 = iprot.readMapBegin();
-                this.mutation_map = new HashMap<byte[],Map<String,List<Mutation>>>(2*_map63.size);
-                for (int _i64 = 0; _i64 < _map63.size; ++_i64)
+                TMap _map79 = iprot.readMapBegin();
+                this.mutation_map = new HashMap<byte[],Map<String,List<Mutation>>>(2*_map79.size);
+                for (int _i80 = 0; _i80 < _map79.size; ++_i80)
                 {
-                  byte[] _key65;
-                  Map<String,List<Mutation>> _val66;
-                  _key65 = iprot.readBinary();
+                  byte[] _key81;
+                  Map<String,List<Mutation>> _val82;
+                  _key81 = iprot.readBinary();
                   {
-                    TMap _map67 = iprot.readMapBegin();
-                    _val66 = new HashMap<String,List<Mutation>>(2*_map67.size);
-                    for (int _i68 = 0; _i68 < _map67.size; ++_i68)
+                    TMap _map83 = iprot.readMapBegin();
+                    _val82 = new HashMap<String,List<Mutation>>(2*_map83.size);
+                    for (int _i84 = 0; _i84 < _map83.size; ++_i84)
                     {
-                      String _key69;
-                      List<Mutation> _val70;
-                      _key69 = iprot.readString();
+                      String _key85;
+                      List<Mutation> _val86;
+                      _key85 = iprot.readString();
                       {
-                        TList _list71 = iprot.readListBegin();
-                        _val70 = new ArrayList<Mutation>(_list71.size);
-                        for (int _i72 = 0; _i72 < _list71.size; ++_i72)
+                        TList _list87 = iprot.readListBegin();
+                        _val86 = new ArrayList<Mutation>(_list87.size);
+                        for (int _i88 = 0; _i88 < _list87.size; ++_i88)
                         {
-                          Mutation _elem73;
-                          _elem73 = new Mutation();
-                          _elem73.read(iprot);
-                          _val70.add(_elem73);
+                          Mutation _elem89;
+                          _elem89 = new Mutation();
+                          _elem89.read(iprot);
+                          _val86.add(_elem89);
                         }
                         iprot.readListEnd();
                       }
-                      _val66.put(_key69, _val70);
+                      _val82.put(_key85, _val86);
                     }
                     iprot.readMapEnd();
                   }
-                  this.mutation_map.put(_key65, _val66);
+                  this.mutation_map.put(_key81, _val82);
                 }
                 iprot.readMapEnd();
               }
@@ -12890,19 +15372,19 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(MUTATION_MAP_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.mutation_map.size()));
-          for (Map.Entry<byte[], Map<String,List<Mutation>>> _iter74 : this.mutation_map.entrySet())
+          for (Map.Entry<byte[], Map<String,List<Mutation>>> _iter90 : this.mutation_map.entrySet())
           {
-            oprot.writeBinary(_iter74.getKey());
+            oprot.writeBinary(_iter90.getKey());
             {
-              oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, _iter74.getValue().size()));
-              for (Map.Entry<String, List<Mutation>> _iter75 : _iter74.getValue().entrySet())
+              oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, _iter90.getValue().size()));
+              for (Map.Entry<String, List<Mutation>> _iter91 : _iter90.getValue().entrySet())
               {
-                oprot.writeString(_iter75.getKey());
+                oprot.writeString(_iter91.getKey());
                 {
-                  oprot.writeListBegin(new TList(TType.STRUCT, _iter75.getValue().size()));
-                  for (Mutation _iter76 : _iter75.getValue())
+                  oprot.writeListBegin(new TList(TType.STRUCT, _iter91.getValue().size()));
+                  for (Mutation _iter92 : _iter91.getValue())
                   {
-                    _iter76.write(oprot);
+                    _iter92.write(oprot);
                   }
                   oprot.writeListEnd();
                 }
@@ -14546,25 +17028,25 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.MAP) {
               {
-                TMap _map77 = iprot.readMapBegin();
-                this.success = new HashMap<String,List<String>>(2*_map77.size);
-                for (int _i78 = 0; _i78 < _map77.size; ++_i78)
+                TMap _map93 = iprot.readMapBegin();
+                this.success = new HashMap<String,List<String>>(2*_map93.size);
+                for (int _i94 = 0; _i94 < _map93.size; ++_i94)
                 {
-                  String _key79;
-                  List<String> _val80;
-                  _key79 = iprot.readString();
+                  String _key95;
+                  List<String> _val96;
+                  _key95 = iprot.readString();
                   {
-                    TList _list81 = iprot.readListBegin();
-                    _val80 = new ArrayList<String>(_list81.size);
-                    for (int _i82 = 0; _i82 < _list81.size; ++_i82)
+                    TList _list97 = iprot.readListBegin();
+                    _val96 = new ArrayList<String>(_list97.size);
+                    for (int _i98 = 0; _i98 < _list97.size; ++_i98)
                     {
-                      String _elem83;
-                      _elem83 = iprot.readString();
-                      _val80.add(_elem83);
+                      String _elem99;
+                      _elem99 = iprot.readString();
+                      _val96.add(_elem99);
                     }
                     iprot.readListEnd();
                   }
-                  this.success.put(_key79, _val80);
+                  this.success.put(_key95, _val96);
                 }
                 iprot.readMapEnd();
               }
@@ -14598,14 +17080,14 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.success.size()));
-          for (Map.Entry<String, List<String>> _iter84 : this.success.entrySet())
+          for (Map.Entry<String, List<String>> _iter100 : this.success.entrySet())
           {
-            oprot.writeString(_iter84.getKey());
+            oprot.writeString(_iter100.getKey());
             {
-              oprot.writeListBegin(new TList(TType.STRING, _iter84.getValue().size()));
-              for (String _iter85 : _iter84.getValue())
+              oprot.writeListBegin(new TList(TType.STRING, _iter100.getValue().size()));
+              for (String _iter101 : _iter100.getValue())
               {
-                oprot.writeString(_iter85);
+                oprot.writeString(_iter101);
               }
               oprot.writeListEnd();
             }
@@ -15073,13 +17555,13 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.SET) {
               {
-                TSet _set86 = iprot.readSetBegin();
-                this.success = new HashSet<String>(2*_set86.size);
-                for (int _i87 = 0; _i87 < _set86.size; ++_i87)
+                TSet _set102 = iprot.readSetBegin();
+                this.success = new HashSet<String>(2*_set102.size);
+                for (int _i103 = 0; _i103 < _set102.size; ++_i103)
                 {
-                  String _elem88;
-                  _elem88 = iprot.readString();
-                  this.success.add(_elem88);
+                  String _elem104;
+                  _elem104 = iprot.readString();
+                  this.success.add(_elem104);
                 }
                 iprot.readSetEnd();
               }
@@ -15105,9 +17587,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeSetBegin(new TSet(TType.STRING, this.success.size()));
-          for (String _iter89 : this.success)
+          for (String _iter105 : this.success)
           {
-            oprot.writeString(_iter89);
+            oprot.writeString(_iter105);
           }
           oprot.writeSetEnd();
         }
@@ -16679,14 +19161,14 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.LIST) {
               {
-                TList _list90 = iprot.readListBegin();
-                this.success = new ArrayList<TokenRange>(_list90.size);
-                for (int _i91 = 0; _i91 < _list90.size; ++_i91)
+                TList _list106 = iprot.readListBegin();
+                this.success = new ArrayList<TokenRange>(_list106.size);
+                for (int _i107 = 0; _i107 < _list106.size; ++_i107)
                 {
-                  TokenRange _elem92;
-                  _elem92 = new TokenRange();
-                  _elem92.read(iprot);
-                  this.success.add(_elem92);
+                  TokenRange _elem108;
+                  _elem108 = new TokenRange();
+                  _elem108.read(iprot);
+                  this.success.add(_elem108);
                 }
                 iprot.readListEnd();
               }
@@ -16720,9 +19202,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
-          for (TokenRange _iter93 : this.success)
+          for (TokenRange _iter109 : this.success)
           {
-            _iter93.write(oprot);
+            _iter109.write(oprot);
           }
           oprot.writeListEnd();
         }
@@ -17355,27 +19837,27 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.MAP) {
               {
-                TMap _map94 = iprot.readMapBegin();
-                this.success = new HashMap<String,Map<String,String>>(2*_map94.size);
-                for (int _i95 = 0; _i95 < _map94.size; ++_i95)
+                TMap _map110 = iprot.readMapBegin();
+                this.success = new HashMap<String,Map<String,String>>(2*_map110.size);
+                for (int _i111 = 0; _i111 < _map110.size; ++_i111)
                 {
-                  String _key96;
-                  Map<String,String> _val97;
-                  _key96 = iprot.readString();
+                  String _key112;
+                  Map<String,String> _val113;
+                  _key112 = iprot.readString();
                   {
-                    TMap _map98 = iprot.readMapBegin();
-                    _val97 = new HashMap<String,String>(2*_map98.size);
-                    for (int _i99 = 0; _i99 < _map98.size; ++_i99)
+                    TMap _map114 = iprot.readMapBegin();
+                    _val113 = new HashMap<String,String>(2*_map114.size);
+                    for (int _i115 = 0; _i115 < _map114.size; ++_i115)
                     {
-                      String _key100;
-                      String _val101;
-                      _key100 = iprot.readString();
-                      _val101 = iprot.readString();
-                      _val97.put(_key100, _val101);
+                      String _key116;
+                      String _val117;
+                      _key116 = iprot.readString();
+                      _val117 = iprot.readString();
+                      _val113.put(_key116, _val117);
                     }
                     iprot.readMapEnd();
                   }
-                  this.success.put(_key96, _val97);
+                  this.success.put(_key112, _val113);
                 }
                 iprot.readMapEnd();
               }
@@ -17409,15 +19891,15 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.success.size()));
-          for (Map.Entry<String, Map<String,String>> _iter102 : this.success.entrySet())
+          for (Map.Entry<String, Map<String,String>> _iter118 : this.success.entrySet())
           {
-            oprot.writeString(_iter102.getKey());
+            oprot.writeString(_iter118.getKey());
             {
-              oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter102.getValue().size()));
-              for (Map.Entry<String, String> _iter103 : _iter102.getValue().entrySet())
+              oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter118.getValue().size()));
+              for (Map.Entry<String, String> _iter119 : _iter118.getValue().entrySet())
               {
-                oprot.writeString(_iter103.getKey());
-                oprot.writeString(_iter103.getValue());
+                oprot.writeString(_iter119.getKey());
+                oprot.writeString(_iter119.getValue());
               }
               oprot.writeMapEnd();
             }
@@ -18349,13 +20831,13 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.LIST) {
               {
-                TList _list104 = iprot.readListBegin();
-                this.success = new ArrayList<String>(_list104.size);
-                for (int _i105 = 0; _i105 < _list104.size; ++_i105)
+                TList _list120 = iprot.readListBegin();
+                this.success = new ArrayList<String>(_list120.size);
+                for (int _i121 = 0; _i121 < _list120.size; ++_i121)
                 {
-                  String _elem106;
-                  _elem106 = iprot.readString();
-                  this.success.add(_elem106);
+                  String _elem122;
+                  _elem122 = iprot.readString();
+                  this.success.add(_elem122);
                 }
                 iprot.readListEnd();
               }
@@ -18381,9 +20863,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
-          for (String _iter107 : this.success)
+          for (String _iter123 : this.success)
           {
-            oprot.writeString(_iter107);
+            oprot.writeString(_iter123);
           }
           oprot.writeListEnd();
         }
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/CfDef.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/CfDef.java
index 36c17ef5..4873dce1 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/CfDef.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/CfDef.java
@@ -1156,14 +1156,14 @@ public void read(TProtocol iprot) throws TException {
         case 13: // COLUMN_METADATA
           if (field.type == TType.LIST) {
             {
-              TList _list25 = iprot.readListBegin();
-              this.column_metadata = new ArrayList<ColumnDef>(_list25.size);
-              for (int _i26 = 0; _i26 < _list25.size; ++_i26)
+              TList _list33 = iprot.readListBegin();
+              this.column_metadata = new ArrayList<ColumnDef>(_list33.size);
+              for (int _i34 = 0; _i34 < _list33.size; ++_i34)
               {
-                ColumnDef _elem27;
-                _elem27 = new ColumnDef();
-                _elem27.read(iprot);
-                this.column_metadata.add(_elem27);
+                ColumnDef _elem35;
+                _elem35 = new ColumnDef();
+                _elem35.read(iprot);
+                this.column_metadata.add(_elem35);
               }
               iprot.readListEnd();
             }
@@ -1263,9 +1263,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(COLUMN_METADATA_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.column_metadata.size()));
-          for (ColumnDef _iter28 : this.column_metadata)
+          for (ColumnDef _iter36 : this.column_metadata)
           {
-            _iter28.write(oprot);
+            _iter36.write(oprot);
           }
           oprot.writeListEnd();
         }
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Constants.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Constants.java
index d1fde4c9..93fa1ff2 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Constants.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Constants.java
@@ -42,6 +42,6 @@
 
 public class Constants {
 
-  public static final String VERSION = "8.2.0";
+  public static final String VERSION = "8.3.0";
 
 }
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/IndexClause.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/IndexClause.java
index e69de29b..015e03b3 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/IndexClause.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/IndexClause.java
@@ -0,0 +1,549 @@
+/**
+ * Autogenerated by Thrift
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ */
+package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.EnumMap;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.EnumSet;
+import java.util.Collections;
+import java.util.BitSet;
+import java.util.Arrays;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.thrift.*;
+import org.apache.thrift.meta_data.*;
+import org.apache.thrift.protocol.*;
+
+public class IndexClause implements TBase<IndexClause._Fields>, java.io.Serializable, Cloneable, Comparable<IndexClause> {
+  private static final TStruct STRUCT_DESC = new TStruct("IndexClause");
+
+  private static final TField EXPRESSIONS_FIELD_DESC = new TField("expressions", TType.LIST, (short)1);
+  private static final TField COUNT_FIELD_DESC = new TField("count", TType.I32, (short)2);
+  private static final TField START_KEY_FIELD_DESC = new TField("start_key", TType.STRING, (short)3);
+
+  public List<IndexExpression> expressions;
+  public int count;
+  public byte[] start_key;
+
+  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+  public enum _Fields implements TFieldIdEnum {
+    EXPRESSIONS((short)1, "expressions"),
+    COUNT((short)2, "count"),
+    START_KEY((short)3, "start_key");
+
+    private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
+    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+    static {
+      for (_Fields field : EnumSet.allOf(_Fields.class)) {
+        byId.put((int)field._thriftId, field);
+        byName.put(field.getFieldName(), field);
+      }
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, or null if its not found.
+     */
+    public static _Fields findByThriftId(int fieldId) {
+      return byId.get(fieldId);
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, throwing an exception
+     * if it is not found.
+     */
+    public static _Fields findByThriftIdOrThrow(int fieldId) {
+      _Fields fields = findByThriftId(fieldId);
+      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+      return fields;
+    }
+
+    /**
+     * Find the _Fields constant that matches name, or null if its not found.
+     */
+    public static _Fields findByName(String name) {
+      return byName.get(name);
+    }
+
+    private final short _thriftId;
+    private final String _fieldName;
+
+    _Fields(short thriftId, String fieldName) {
+      _thriftId = thriftId;
+      _fieldName = fieldName;
+    }
+
+    public short getThriftFieldId() {
+      return _thriftId;
+    }
+
+    public String getFieldName() {
+      return _fieldName;
+    }
+  }
+
+  // isset id assignments
+  private static final int __COUNT_ISSET_ID = 0;
+  private BitSet __isset_bit_vector = new BitSet(1);
+
+  public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
+    put(_Fields.EXPRESSIONS, new FieldMetaData("expressions", TFieldRequirementType.REQUIRED, 
+        new ListMetaData(TType.LIST, 
+            new StructMetaData(TType.STRUCT, IndexExpression.class))));
+    put(_Fields.COUNT, new FieldMetaData("count", TFieldRequirementType.REQUIRED, 
+        new FieldValueMetaData(TType.I32)));
+    put(_Fields.START_KEY, new FieldMetaData("start_key", TFieldRequirementType.OPTIONAL, 
+        new FieldValueMetaData(TType.STRING)));
+  }});
+
+  static {
+    FieldMetaData.addStructMetaDataMap(IndexClause.class, metaDataMap);
+  }
+
+  public IndexClause() {
+    this.count = 100;
+
+  }
+
+  public IndexClause(
+    List<IndexExpression> expressions,
+    int count)
+  {
+    this();
+    this.expressions = expressions;
+    this.count = count;
+    setCountIsSet(true);
+  }
+
+  /**
+   * Performs a deep copy on <i>other</i>.
+   */
+  public IndexClause(IndexClause other) {
+    __isset_bit_vector.clear();
+    __isset_bit_vector.or(other.__isset_bit_vector);
+    if (other.isSetExpressions()) {
+      List<IndexExpression> __this__expressions = new ArrayList<IndexExpression>();
+      for (IndexExpression other_element : other.expressions) {
+        __this__expressions.add(new IndexExpression(other_element));
+      }
+      this.expressions = __this__expressions;
+    }
+    this.count = other.count;
+    if (other.isSetStart_key()) {
+      this.start_key = new byte[other.start_key.length];
+      System.arraycopy(other.start_key, 0, start_key, 0, other.start_key.length);
+    }
+  }
+
+  public IndexClause deepCopy() {
+    return new IndexClause(this);
+  }
+
+  @Deprecated
+  public IndexClause clone() {
+    return new IndexClause(this);
+  }
+
+  public int getExpressionsSize() {
+    return (this.expressions == null) ? 0 : this.expressions.size();
+  }
+
+  public java.util.Iterator<IndexExpression> getExpressionsIterator() {
+    return (this.expressions == null) ? null : this.expressions.iterator();
+  }
+
+  public void addToExpressions(IndexExpression elem) {
+    if (this.expressions == null) {
+      this.expressions = new ArrayList<IndexExpression>();
+    }
+    this.expressions.add(elem);
+  }
+
+  public List<IndexExpression> getExpressions() {
+    return this.expressions;
+  }
+
+  public IndexClause setExpressions(List<IndexExpression> expressions) {
+    this.expressions = expressions;
+    return this;
+  }
+
+  public void unsetExpressions() {
+    this.expressions = null;
+  }
+
+  /** Returns true if field expressions is set (has been asigned a value) and false otherwise */
+  public boolean isSetExpressions() {
+    return this.expressions != null;
+  }
+
+  public void setExpressionsIsSet(boolean value) {
+    if (!value) {
+      this.expressions = null;
+    }
+  }
+
+  public int getCount() {
+    return this.count;
+  }
+
+  public IndexClause setCount(int count) {
+    this.count = count;
+    setCountIsSet(true);
+    return this;
+  }
+
+  public void unsetCount() {
+    __isset_bit_vector.clear(__COUNT_ISSET_ID);
+  }
+
+  /** Returns true if field count is set (has been asigned a value) and false otherwise */
+  public boolean isSetCount() {
+    return __isset_bit_vector.get(__COUNT_ISSET_ID);
+  }
+
+  public void setCountIsSet(boolean value) {
+    __isset_bit_vector.set(__COUNT_ISSET_ID, value);
+  }
+
+  public byte[] getStart_key() {
+    return this.start_key;
+  }
+
+  public IndexClause setStart_key(byte[] start_key) {
+    this.start_key = start_key;
+    return this;
+  }
+
+  public void unsetStart_key() {
+    this.start_key = null;
+  }
+
+  /** Returns true if field start_key is set (has been asigned a value) and false otherwise */
+  public boolean isSetStart_key() {
+    return this.start_key != null;
+  }
+
+  public void setStart_keyIsSet(boolean value) {
+    if (!value) {
+      this.start_key = null;
+    }
+  }
+
+  public void setFieldValue(_Fields field, Object value) {
+    switch (field) {
+    case EXPRESSIONS:
+      if (value == null) {
+        unsetExpressions();
+      } else {
+        setExpressions((List<IndexExpression>)value);
+      }
+      break;
+
+    case COUNT:
+      if (value == null) {
+        unsetCount();
+      } else {
+        setCount((Integer)value);
+      }
+      break;
+
+    case START_KEY:
+      if (value == null) {
+        unsetStart_key();
+      } else {
+        setStart_key((byte[])value);
+      }
+      break;
+
+    }
+  }
+
+  public void setFieldValue(int fieldID, Object value) {
+    setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
+  }
+
+  public Object getFieldValue(_Fields field) {
+    switch (field) {
+    case EXPRESSIONS:
+      return getExpressions();
+
+    case COUNT:
+      return new Integer(getCount());
+
+    case START_KEY:
+      return getStart_key();
+
+    }
+    throw new IllegalStateException();
+  }
+
+  public Object getFieldValue(int fieldId) {
+    return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
+  }
+
+  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
+  public boolean isSet(_Fields field) {
+    switch (field) {
+    case EXPRESSIONS:
+      return isSetExpressions();
+    case COUNT:
+      return isSetCount();
+    case START_KEY:
+      return isSetStart_key();
+    }
+    throw new IllegalStateException();
+  }
+
+  public boolean isSet(int fieldID) {
+    return isSet(_Fields.findByThriftIdOrThrow(fieldID));
+  }
+
+  @Override
+  public boolean equals(Object that) {
+    if (that == null)
+      return false;
+    if (that instanceof IndexClause)
+      return this.equals((IndexClause)that);
+    return false;
+  }
+
+  public boolean equals(IndexClause that) {
+    if (that == null)
+      return false;
+
+    boolean this_present_expressions = true && this.isSetExpressions();
+    boolean that_present_expressions = true && that.isSetExpressions();
+    if (this_present_expressions || that_present_expressions) {
+      if (!(this_present_expressions && that_present_expressions))
+        return false;
+      if (!this.expressions.equals(that.expressions))
+        return false;
+    }
+
+    boolean this_present_count = true;
+    boolean that_present_count = true;
+    if (this_present_count || that_present_count) {
+      if (!(this_present_count && that_present_count))
+        return false;
+      if (this.count != that.count)
+        return false;
+    }
+
+    boolean this_present_start_key = true && this.isSetStart_key();
+    boolean that_present_start_key = true && that.isSetStart_key();
+    if (this_present_start_key || that_present_start_key) {
+      if (!(this_present_start_key && that_present_start_key))
+        return false;
+      if (!java.util.Arrays.equals(this.start_key, that.start_key))
+        return false;
+    }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    return 0;
+  }
+
+  public int compareTo(IndexClause other) {
+    if (!getClass().equals(other.getClass())) {
+      return getClass().getName().compareTo(other.getClass().getName());
+    }
+
+    int lastComparison = 0;
+    IndexClause typedOther = (IndexClause)other;
+
+    lastComparison = Boolean.valueOf(isSetExpressions()).compareTo(typedOther.isSetExpressions());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetExpressions()) {      lastComparison = TBaseHelper.compareTo(expressions, typedOther.expressions);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    lastComparison = Boolean.valueOf(isSetCount()).compareTo(typedOther.isSetCount());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetCount()) {      lastComparison = TBaseHelper.compareTo(count, typedOther.count);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    lastComparison = Boolean.valueOf(isSetStart_key()).compareTo(typedOther.isSetStart_key());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetStart_key()) {      lastComparison = TBaseHelper.compareTo(start_key, typedOther.start_key);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    return 0;
+  }
+
+  public void read(TProtocol iprot) throws TException {
+    TField field;
+    iprot.readStructBegin();
+    while (true)
+    {
+      field = iprot.readFieldBegin();
+      if (field.type == TType.STOP) { 
+        break;
+      }
+      switch (field.id) {
+        case 1: // EXPRESSIONS
+          if (field.type == TType.LIST) {
+            {
+              TList _list12 = iprot.readListBegin();
+              this.expressions = new ArrayList<IndexExpression>(_list12.size);
+              for (int _i13 = 0; _i13 < _list12.size; ++_i13)
+              {
+                IndexExpression _elem14;
+                _elem14 = new IndexExpression();
+                _elem14.read(iprot);
+                this.expressions.add(_elem14);
+              }
+              iprot.readListEnd();
+            }
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        case 2: // COUNT
+          if (field.type == TType.I32) {
+            this.count = iprot.readI32();
+            setCountIsSet(true);
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        case 3: // START_KEY
+          if (field.type == TType.STRING) {
+            this.start_key = iprot.readBinary();
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        default:
+          TProtocolUtil.skip(iprot, field.type);
+      }
+      iprot.readFieldEnd();
+    }
+    iprot.readStructEnd();
+
+    // check for required fields of primitive type, which can't be checked in the validate method
+    if (!isSetCount()) {
+      throw new TProtocolException("Required field 'count' was not found in serialized data! Struct: " + toString());
+    }
+    validate();
+  }
+
+  public void write(TProtocol oprot) throws TException {
+    validate();
+
+    oprot.writeStructBegin(STRUCT_DESC);
+    if (this.expressions != null) {
+      oprot.writeFieldBegin(EXPRESSIONS_FIELD_DESC);
+      {
+        oprot.writeListBegin(new TList(TType.STRUCT, this.expressions.size()));
+        for (IndexExpression _iter15 : this.expressions)
+        {
+          _iter15.write(oprot);
+        }
+        oprot.writeListEnd();
+      }
+      oprot.writeFieldEnd();
+    }
+    oprot.writeFieldBegin(COUNT_FIELD_DESC);
+    oprot.writeI32(this.count);
+    oprot.writeFieldEnd();
+    if (this.start_key != null) {
+      if (isSetStart_key()) {
+        oprot.writeFieldBegin(START_KEY_FIELD_DESC);
+        oprot.writeBinary(this.start_key);
+        oprot.writeFieldEnd();
+      }
+    }
+    oprot.writeFieldStop();
+    oprot.writeStructEnd();
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("IndexClause(");
+    boolean first = true;
+
+    sb.append("expressions:");
+    if (this.expressions == null) {
+      sb.append("null");
+    } else {
+      sb.append(this.expressions);
+    }
+    first = false;
+    if (!first) sb.append(", ");
+    sb.append("count:");
+    sb.append(this.count);
+    first = false;
+    if (isSetStart_key()) {
+      if (!first) sb.append(", ");
+      sb.append("start_key:");
+      if (this.start_key == null) {
+        sb.append("null");
+      } else {
+          int __start_key_size = Math.min(this.start_key.length, 128);
+          for (int i = 0; i < __start_key_size; i++) {
+            if (i != 0) sb.append(" ");
+            sb.append(Integer.toHexString(this.start_key[i]).length() > 1 ? Integer.toHexString(this.start_key[i]).substring(Integer.toHexString(this.start_key[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.start_key[i]).toUpperCase());
+          }
+          if (this.start_key.length > 128) sb.append(" ...");
+      }
+      first = false;
+    }
+    sb.append(")");
+    return sb.toString();
+  }
+
+  public void validate() throws TException {
+    // check for required fields
+    if (expressions == null) {
+      throw new TProtocolException("Required field 'expressions' was not present! Struct: " + toString());
+    }
+    // alas, we cannot check 'count' because it's a primitive and you chose the non-beans generator.
+  }
+
+}
+
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/IndexExpression.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/IndexExpression.java
index e69de29b..d7f27a1b 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/IndexExpression.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/IndexExpression.java
@@ -0,0 +1,534 @@
+/**
+ * Autogenerated by Thrift
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ */
+package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.EnumMap;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.EnumSet;
+import java.util.Collections;
+import java.util.BitSet;
+import java.util.Arrays;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.thrift.*;
+import org.apache.thrift.meta_data.*;
+import org.apache.thrift.protocol.*;
+
+public class IndexExpression implements TBase<IndexExpression._Fields>, java.io.Serializable, Cloneable, Comparable<IndexExpression> {
+  private static final TStruct STRUCT_DESC = new TStruct("IndexExpression");
+
+  private static final TField COLUMN_NAME_FIELD_DESC = new TField("column_name", TType.STRING, (short)1);
+  private static final TField OP_FIELD_DESC = new TField("op", TType.I32, (short)2);
+  private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short)3);
+
+  public byte[] column_name;
+  /**
+   * 
+   * @see IndexOperator
+   */
+  public IndexOperator op;
+  public byte[] value;
+
+  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+  public enum _Fields implements TFieldIdEnum {
+    COLUMN_NAME((short)1, "column_name"),
+    /**
+     * 
+     * @see IndexOperator
+     */
+    OP((short)2, "op"),
+    VALUE((short)3, "value");
+
+    private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
+    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+    static {
+      for (_Fields field : EnumSet.allOf(_Fields.class)) {
+        byId.put((int)field._thriftId, field);
+        byName.put(field.getFieldName(), field);
+      }
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, or null if its not found.
+     */
+    public static _Fields findByThriftId(int fieldId) {
+      return byId.get(fieldId);
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, throwing an exception
+     * if it is not found.
+     */
+    public static _Fields findByThriftIdOrThrow(int fieldId) {
+      _Fields fields = findByThriftId(fieldId);
+      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+      return fields;
+    }
+
+    /**
+     * Find the _Fields constant that matches name, or null if its not found.
+     */
+    public static _Fields findByName(String name) {
+      return byName.get(name);
+    }
+
+    private final short _thriftId;
+    private final String _fieldName;
+
+    _Fields(short thriftId, String fieldName) {
+      _thriftId = thriftId;
+      _fieldName = fieldName;
+    }
+
+    public short getThriftFieldId() {
+      return _thriftId;
+    }
+
+    public String getFieldName() {
+      return _fieldName;
+    }
+  }
+
+  // isset id assignments
+
+  public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
+    put(_Fields.COLUMN_NAME, new FieldMetaData("column_name", TFieldRequirementType.REQUIRED, 
+        new FieldValueMetaData(TType.STRING)));
+    put(_Fields.OP, new FieldMetaData("op", TFieldRequirementType.REQUIRED, 
+        new EnumMetaData(TType.ENUM, IndexOperator.class)));
+    put(_Fields.VALUE, new FieldMetaData("value", TFieldRequirementType.REQUIRED, 
+        new FieldValueMetaData(TType.STRING)));
+  }});
+
+  static {
+    FieldMetaData.addStructMetaDataMap(IndexExpression.class, metaDataMap);
+  }
+
+  public IndexExpression() {
+  }
+
+  public IndexExpression(
+    byte[] column_name,
+    IndexOperator op,
+    byte[] value)
+  {
+    this();
+    this.column_name = column_name;
+    this.op = op;
+    this.value = value;
+  }
+
+  /**
+   * Performs a deep copy on <i>other</i>.
+   */
+  public IndexExpression(IndexExpression other) {
+    if (other.isSetColumn_name()) {
+      this.column_name = new byte[other.column_name.length];
+      System.arraycopy(other.column_name, 0, column_name, 0, other.column_name.length);
+    }
+    if (other.isSetOp()) {
+      this.op = other.op;
+    }
+    if (other.isSetValue()) {
+      this.value = new byte[other.value.length];
+      System.arraycopy(other.value, 0, value, 0, other.value.length);
+    }
+  }
+
+  public IndexExpression deepCopy() {
+    return new IndexExpression(this);
+  }
+
+  @Deprecated
+  public IndexExpression clone() {
+    return new IndexExpression(this);
+  }
+
+  public byte[] getColumn_name() {
+    return this.column_name;
+  }
+
+  public IndexExpression setColumn_name(byte[] column_name) {
+    this.column_name = column_name;
+    return this;
+  }
+
+  public void unsetColumn_name() {
+    this.column_name = null;
+  }
+
+  /** Returns true if field column_name is set (has been asigned a value) and false otherwise */
+  public boolean isSetColumn_name() {
+    return this.column_name != null;
+  }
+
+  public void setColumn_nameIsSet(boolean value) {
+    if (!value) {
+      this.column_name = null;
+    }
+  }
+
+  /**
+   * 
+   * @see IndexOperator
+   */
+  public IndexOperator getOp() {
+    return this.op;
+  }
+
+  /**
+   * 
+   * @see IndexOperator
+   */
+  public IndexExpression setOp(IndexOperator op) {
+    this.op = op;
+    return this;
+  }
+
+  public void unsetOp() {
+    this.op = null;
+  }
+
+  /** Returns true if field op is set (has been asigned a value) and false otherwise */
+  public boolean isSetOp() {
+    return this.op != null;
+  }
+
+  public void setOpIsSet(boolean value) {
+    if (!value) {
+      this.op = null;
+    }
+  }
+
+  public byte[] getValue() {
+    return this.value;
+  }
+
+  public IndexExpression setValue(byte[] value) {
+    this.value = value;
+    return this;
+  }
+
+  public void unsetValue() {
+    this.value = null;
+  }
+
+  /** Returns true if field value is set (has been asigned a value) and false otherwise */
+  public boolean isSetValue() {
+    return this.value != null;
+  }
+
+  public void setValueIsSet(boolean value) {
+    if (!value) {
+      this.value = null;
+    }
+  }
+
+  public void setFieldValue(_Fields field, Object value) {
+    switch (field) {
+    case COLUMN_NAME:
+      if (value == null) {
+        unsetColumn_name();
+      } else {
+        setColumn_name((byte[])value);
+      }
+      break;
+
+    case OP:
+      if (value == null) {
+        unsetOp();
+      } else {
+        setOp((IndexOperator)value);
+      }
+      break;
+
+    case VALUE:
+      if (value == null) {
+        unsetValue();
+      } else {
+        setValue((byte[])value);
+      }
+      break;
+
+    }
+  }
+
+  public void setFieldValue(int fieldID, Object value) {
+    setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
+  }
+
+  public Object getFieldValue(_Fields field) {
+    switch (field) {
+    case COLUMN_NAME:
+      return getColumn_name();
+
+    case OP:
+      return getOp();
+
+    case VALUE:
+      return getValue();
+
+    }
+    throw new IllegalStateException();
+  }
+
+  public Object getFieldValue(int fieldId) {
+    return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
+  }
+
+  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
+  public boolean isSet(_Fields field) {
+    switch (field) {
+    case COLUMN_NAME:
+      return isSetColumn_name();
+    case OP:
+      return isSetOp();
+    case VALUE:
+      return isSetValue();
+    }
+    throw new IllegalStateException();
+  }
+
+  public boolean isSet(int fieldID) {
+    return isSet(_Fields.findByThriftIdOrThrow(fieldID));
+  }
+
+  @Override
+  public boolean equals(Object that) {
+    if (that == null)
+      return false;
+    if (that instanceof IndexExpression)
+      return this.equals((IndexExpression)that);
+    return false;
+  }
+
+  public boolean equals(IndexExpression that) {
+    if (that == null)
+      return false;
+
+    boolean this_present_column_name = true && this.isSetColumn_name();
+    boolean that_present_column_name = true && that.isSetColumn_name();
+    if (this_present_column_name || that_present_column_name) {
+      if (!(this_present_column_name && that_present_column_name))
+        return false;
+      if (!java.util.Arrays.equals(this.column_name, that.column_name))
+        return false;
+    }
+
+    boolean this_present_op = true && this.isSetOp();
+    boolean that_present_op = true && that.isSetOp();
+    if (this_present_op || that_present_op) {
+      if (!(this_present_op && that_present_op))
+        return false;
+      if (!this.op.equals(that.op))
+        return false;
+    }
+
+    boolean this_present_value = true && this.isSetValue();
+    boolean that_present_value = true && that.isSetValue();
+    if (this_present_value || that_present_value) {
+      if (!(this_present_value && that_present_value))
+        return false;
+      if (!java.util.Arrays.equals(this.value, that.value))
+        return false;
+    }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    return 0;
+  }
+
+  public int compareTo(IndexExpression other) {
+    if (!getClass().equals(other.getClass())) {
+      return getClass().getName().compareTo(other.getClass().getName());
+    }
+
+    int lastComparison = 0;
+    IndexExpression typedOther = (IndexExpression)other;
+
+    lastComparison = Boolean.valueOf(isSetColumn_name()).compareTo(typedOther.isSetColumn_name());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetColumn_name()) {      lastComparison = TBaseHelper.compareTo(column_name, typedOther.column_name);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    lastComparison = Boolean.valueOf(isSetOp()).compareTo(typedOther.isSetOp());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetOp()) {      lastComparison = TBaseHelper.compareTo(op, typedOther.op);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    lastComparison = Boolean.valueOf(isSetValue()).compareTo(typedOther.isSetValue());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetValue()) {      lastComparison = TBaseHelper.compareTo(value, typedOther.value);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    return 0;
+  }
+
+  public void read(TProtocol iprot) throws TException {
+    TField field;
+    iprot.readStructBegin();
+    while (true)
+    {
+      field = iprot.readFieldBegin();
+      if (field.type == TType.STOP) { 
+        break;
+      }
+      switch (field.id) {
+        case 1: // COLUMN_NAME
+          if (field.type == TType.STRING) {
+            this.column_name = iprot.readBinary();
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        case 2: // OP
+          if (field.type == TType.I32) {
+            this.op = IndexOperator.findByValue(iprot.readI32());
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        case 3: // VALUE
+          if (field.type == TType.STRING) {
+            this.value = iprot.readBinary();
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        default:
+          TProtocolUtil.skip(iprot, field.type);
+      }
+      iprot.readFieldEnd();
+    }
+    iprot.readStructEnd();
+
+    // check for required fields of primitive type, which can't be checked in the validate method
+    validate();
+  }
+
+  public void write(TProtocol oprot) throws TException {
+    validate();
+
+    oprot.writeStructBegin(STRUCT_DESC);
+    if (this.column_name != null) {
+      oprot.writeFieldBegin(COLUMN_NAME_FIELD_DESC);
+      oprot.writeBinary(this.column_name);
+      oprot.writeFieldEnd();
+    }
+    if (this.op != null) {
+      oprot.writeFieldBegin(OP_FIELD_DESC);
+      oprot.writeI32(this.op.getValue());
+      oprot.writeFieldEnd();
+    }
+    if (this.value != null) {
+      oprot.writeFieldBegin(VALUE_FIELD_DESC);
+      oprot.writeBinary(this.value);
+      oprot.writeFieldEnd();
+    }
+    oprot.writeFieldStop();
+    oprot.writeStructEnd();
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("IndexExpression(");
+    boolean first = true;
+
+    sb.append("column_name:");
+    if (this.column_name == null) {
+      sb.append("null");
+    } else {
+        int __column_name_size = Math.min(this.column_name.length, 128);
+        for (int i = 0; i < __column_name_size; i++) {
+          if (i != 0) sb.append(" ");
+          sb.append(Integer.toHexString(this.column_name[i]).length() > 1 ? Integer.toHexString(this.column_name[i]).substring(Integer.toHexString(this.column_name[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.column_name[i]).toUpperCase());
+        }
+        if (this.column_name.length > 128) sb.append(" ...");
+    }
+    first = false;
+    if (!first) sb.append(", ");
+    sb.append("op:");
+    if (this.op == null) {
+      sb.append("null");
+    } else {
+      sb.append(this.op);
+    }
+    first = false;
+    if (!first) sb.append(", ");
+    sb.append("value:");
+    if (this.value == null) {
+      sb.append("null");
+    } else {
+        int __value_size = Math.min(this.value.length, 128);
+        for (int i = 0; i < __value_size; i++) {
+          if (i != 0) sb.append(" ");
+          sb.append(Integer.toHexString(this.value[i]).length() > 1 ? Integer.toHexString(this.value[i]).substring(Integer.toHexString(this.value[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.value[i]).toUpperCase());
+        }
+        if (this.value.length > 128) sb.append(" ...");
+    }
+    first = false;
+    sb.append(")");
+    return sb.toString();
+  }
+
+  public void validate() throws TException {
+    // check for required fields
+    if (column_name == null) {
+      throw new TProtocolException("Required field 'column_name' was not present! Struct: " + toString());
+    }
+    if (op == null) {
+      throw new TProtocolException("Required field 'op' was not present! Struct: " + toString());
+    }
+    if (value == null) {
+      throw new TProtocolException("Required field 'value' was not present! Struct: " + toString());
+    }
+  }
+
+}
+
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/IndexOperator.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/IndexOperator.java
index e69de29b..57f89c50 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/IndexOperator.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/IndexOperator.java
@@ -0,0 +1,62 @@
+/**
+ * Autogenerated by Thrift
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ */
+package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+
+
+import java.util.Map;
+import java.util.HashMap;
+import org.apache.thrift.TEnum;
+
+public enum IndexOperator implements TEnum {
+  EQ(0);
+
+  private final int value;
+
+  private IndexOperator(int value) {
+    this.value = value;
+  }
+
+  /**
+   * Get the integer value of this enum value, as defined in the Thrift IDL.
+   */
+  public int getValue() {
+    return value;
+  }
+
+  /**
+   * Find a the enum type by its integer value, as defined in the Thrift IDL.
+   * @return null if the value is not found.
+   */
+  public static IndexOperator findByValue(int value) { 
+    switch (value) {
+      case 0:
+        return EQ;
+      default:
+        return null;
+    }
+  }
+}
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeyCount.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeyCount.java
index e69de29b..b1f484a2 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeyCount.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeyCount.java
@@ -0,0 +1,422 @@
+/**
+ * Autogenerated by Thrift
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ */
+package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.EnumMap;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.EnumSet;
+import java.util.Collections;
+import java.util.BitSet;
+import java.util.Arrays;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.thrift.*;
+import org.apache.thrift.meta_data.*;
+import org.apache.thrift.protocol.*;
+
+public class KeyCount implements TBase<KeyCount._Fields>, java.io.Serializable, Cloneable, Comparable<KeyCount> {
+  private static final TStruct STRUCT_DESC = new TStruct("KeyCount");
+
+  private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)1);
+  private static final TField COUNT_FIELD_DESC = new TField("count", TType.I32, (short)2);
+
+  public byte[] key;
+  public int count;
+
+  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+  public enum _Fields implements TFieldIdEnum {
+    KEY((short)1, "key"),
+    COUNT((short)2, "count");
+
+    private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
+    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+    static {
+      for (_Fields field : EnumSet.allOf(_Fields.class)) {
+        byId.put((int)field._thriftId, field);
+        byName.put(field.getFieldName(), field);
+      }
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, or null if its not found.
+     */
+    public static _Fields findByThriftId(int fieldId) {
+      return byId.get(fieldId);
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, throwing an exception
+     * if it is not found.
+     */
+    public static _Fields findByThriftIdOrThrow(int fieldId) {
+      _Fields fields = findByThriftId(fieldId);
+      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+      return fields;
+    }
+
+    /**
+     * Find the _Fields constant that matches name, or null if its not found.
+     */
+    public static _Fields findByName(String name) {
+      return byName.get(name);
+    }
+
+    private final short _thriftId;
+    private final String _fieldName;
+
+    _Fields(short thriftId, String fieldName) {
+      _thriftId = thriftId;
+      _fieldName = fieldName;
+    }
+
+    public short getThriftFieldId() {
+      return _thriftId;
+    }
+
+    public String getFieldName() {
+      return _fieldName;
+    }
+  }
+
+  // isset id assignments
+  private static final int __COUNT_ISSET_ID = 0;
+  private BitSet __isset_bit_vector = new BitSet(1);
+
+  public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
+    put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, 
+        new FieldValueMetaData(TType.STRING)));
+    put(_Fields.COUNT, new FieldMetaData("count", TFieldRequirementType.REQUIRED, 
+        new FieldValueMetaData(TType.I32)));
+  }});
+
+  static {
+    FieldMetaData.addStructMetaDataMap(KeyCount.class, metaDataMap);
+  }
+
+  public KeyCount() {
+  }
+
+  public KeyCount(
+    byte[] key,
+    int count)
+  {
+    this();
+    this.key = key;
+    this.count = count;
+    setCountIsSet(true);
+  }
+
+  /**
+   * Performs a deep copy on <i>other</i>.
+   */
+  public KeyCount(KeyCount other) {
+    __isset_bit_vector.clear();
+    __isset_bit_vector.or(other.__isset_bit_vector);
+    if (other.isSetKey()) {
+      this.key = new byte[other.key.length];
+      System.arraycopy(other.key, 0, key, 0, other.key.length);
+    }
+    this.count = other.count;
+  }
+
+  public KeyCount deepCopy() {
+    return new KeyCount(this);
+  }
+
+  @Deprecated
+  public KeyCount clone() {
+    return new KeyCount(this);
+  }
+
+  public byte[] getKey() {
+    return this.key;
+  }
+
+  public KeyCount setKey(byte[] key) {
+    this.key = key;
+    return this;
+  }
+
+  public void unsetKey() {
+    this.key = null;
+  }
+
+  /** Returns true if field key is set (has been asigned a value) and false otherwise */
+  public boolean isSetKey() {
+    return this.key != null;
+  }
+
+  public void setKeyIsSet(boolean value) {
+    if (!value) {
+      this.key = null;
+    }
+  }
+
+  public int getCount() {
+    return this.count;
+  }
+
+  public KeyCount setCount(int count) {
+    this.count = count;
+    setCountIsSet(true);
+    return this;
+  }
+
+  public void unsetCount() {
+    __isset_bit_vector.clear(__COUNT_ISSET_ID);
+  }
+
+  /** Returns true if field count is set (has been asigned a value) and false otherwise */
+  public boolean isSetCount() {
+    return __isset_bit_vector.get(__COUNT_ISSET_ID);
+  }
+
+  public void setCountIsSet(boolean value) {
+    __isset_bit_vector.set(__COUNT_ISSET_ID, value);
+  }
+
+  public void setFieldValue(_Fields field, Object value) {
+    switch (field) {
+    case KEY:
+      if (value == null) {
+        unsetKey();
+      } else {
+        setKey((byte[])value);
+      }
+      break;
+
+    case COUNT:
+      if (value == null) {
+        unsetCount();
+      } else {
+        setCount((Integer)value);
+      }
+      break;
+
+    }
+  }
+
+  public void setFieldValue(int fieldID, Object value) {
+    setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
+  }
+
+  public Object getFieldValue(_Fields field) {
+    switch (field) {
+    case KEY:
+      return getKey();
+
+    case COUNT:
+      return new Integer(getCount());
+
+    }
+    throw new IllegalStateException();
+  }
+
+  public Object getFieldValue(int fieldId) {
+    return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
+  }
+
+  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
+  public boolean isSet(_Fields field) {
+    switch (field) {
+    case KEY:
+      return isSetKey();
+    case COUNT:
+      return isSetCount();
+    }
+    throw new IllegalStateException();
+  }
+
+  public boolean isSet(int fieldID) {
+    return isSet(_Fields.findByThriftIdOrThrow(fieldID));
+  }
+
+  @Override
+  public boolean equals(Object that) {
+    if (that == null)
+      return false;
+    if (that instanceof KeyCount)
+      return this.equals((KeyCount)that);
+    return false;
+  }
+
+  public boolean equals(KeyCount that) {
+    if (that == null)
+      return false;
+
+    boolean this_present_key = true && this.isSetKey();
+    boolean that_present_key = true && that.isSetKey();
+    if (this_present_key || that_present_key) {
+      if (!(this_present_key && that_present_key))
+        return false;
+      if (!java.util.Arrays.equals(this.key, that.key))
+        return false;
+    }
+
+    boolean this_present_count = true;
+    boolean that_present_count = true;
+    if (this_present_count || that_present_count) {
+      if (!(this_present_count && that_present_count))
+        return false;
+      if (this.count != that.count)
+        return false;
+    }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    return 0;
+  }
+
+  public int compareTo(KeyCount other) {
+    if (!getClass().equals(other.getClass())) {
+      return getClass().getName().compareTo(other.getClass().getName());
+    }
+
+    int lastComparison = 0;
+    KeyCount typedOther = (KeyCount)other;
+
+    lastComparison = Boolean.valueOf(isSetKey()).compareTo(typedOther.isSetKey());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetKey()) {      lastComparison = TBaseHelper.compareTo(key, typedOther.key);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    lastComparison = Boolean.valueOf(isSetCount()).compareTo(typedOther.isSetCount());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetCount()) {      lastComparison = TBaseHelper.compareTo(count, typedOther.count);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    return 0;
+  }
+
+  public void read(TProtocol iprot) throws TException {
+    TField field;
+    iprot.readStructBegin();
+    while (true)
+    {
+      field = iprot.readFieldBegin();
+      if (field.type == TType.STOP) { 
+        break;
+      }
+      switch (field.id) {
+        case 1: // KEY
+          if (field.type == TType.STRING) {
+            this.key = iprot.readBinary();
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        case 2: // COUNT
+          if (field.type == TType.I32) {
+            this.count = iprot.readI32();
+            setCountIsSet(true);
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        default:
+          TProtocolUtil.skip(iprot, field.type);
+      }
+      iprot.readFieldEnd();
+    }
+    iprot.readStructEnd();
+
+    // check for required fields of primitive type, which can't be checked in the validate method
+    if (!isSetCount()) {
+      throw new TProtocolException("Required field 'count' was not found in serialized data! Struct: " + toString());
+    }
+    validate();
+  }
+
+  public void write(TProtocol oprot) throws TException {
+    validate();
+
+    oprot.writeStructBegin(STRUCT_DESC);
+    if (this.key != null) {
+      oprot.writeFieldBegin(KEY_FIELD_DESC);
+      oprot.writeBinary(this.key);
+      oprot.writeFieldEnd();
+    }
+    oprot.writeFieldBegin(COUNT_FIELD_DESC);
+    oprot.writeI32(this.count);
+    oprot.writeFieldEnd();
+    oprot.writeFieldStop();
+    oprot.writeStructEnd();
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("KeyCount(");
+    boolean first = true;
+
+    sb.append("key:");
+    if (this.key == null) {
+      sb.append("null");
+    } else {
+        int __key_size = Math.min(this.key.length, 128);
+        for (int i = 0; i < __key_size; i++) {
+          if (i != 0) sb.append(" ");
+          sb.append(Integer.toHexString(this.key[i]).length() > 1 ? Integer.toHexString(this.key[i]).substring(Integer.toHexString(this.key[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.key[i]).toUpperCase());
+        }
+        if (this.key.length > 128) sb.append(" ...");
+    }
+    first = false;
+    if (!first) sb.append(", ");
+    sb.append("count:");
+    sb.append(this.count);
+    first = false;
+    sb.append(")");
+    return sb.toString();
+  }
+
+  public void validate() throws TException {
+    // check for required fields
+    if (key == null) {
+      throw new TProtocolException("Required field 'key' was not present! Struct: " + toString());
+    }
+    // alas, we cannot check 'count' because it's a primitive and you chose the non-beans generator.
+  }
+
+}
+
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeySlice.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeySlice.java
index 774c2213..646cda91 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeySlice.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeySlice.java
@@ -375,14 +375,14 @@ public void read(TProtocol iprot) throws TException {
         case 2: // COLUMNS
           if (field.type == TType.LIST) {
             {
-              TList _list12 = iprot.readListBegin();
-              this.columns = new ArrayList<ColumnOrSuperColumn>(_list12.size);
-              for (int _i13 = 0; _i13 < _list12.size; ++_i13)
+              TList _list20 = iprot.readListBegin();
+              this.columns = new ArrayList<ColumnOrSuperColumn>(_list20.size);
+              for (int _i21 = 0; _i21 < _list20.size; ++_i21)
               {
-                ColumnOrSuperColumn _elem14;
-                _elem14 = new ColumnOrSuperColumn();
-                _elem14.read(iprot);
-                this.columns.add(_elem14);
+                ColumnOrSuperColumn _elem22;
+                _elem22 = new ColumnOrSuperColumn();
+                _elem22.read(iprot);
+                this.columns.add(_elem22);
               }
               iprot.readListEnd();
             }
@@ -414,9 +414,9 @@ public void write(TProtocol oprot) throws TException {
       oprot.writeFieldBegin(COLUMNS_FIELD_DESC);
       {
         oprot.writeListBegin(new TList(TType.STRUCT, this.columns.size()));
-        for (ColumnOrSuperColumn _iter15 : this.columns)
+        for (ColumnOrSuperColumn _iter23 : this.columns)
         {
-          _iter15.write(oprot);
+          _iter23.write(oprot);
         }
         oprot.writeListEnd();
       }
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KsDef.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KsDef.java
index 65c7cde0..0ba38209 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KsDef.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KsDef.java
@@ -514,14 +514,14 @@ public void read(TProtocol iprot) throws TException {
         case 5: // CF_DEFS
           if (field.type == TType.LIST) {
             {
-              TList _list29 = iprot.readListBegin();
-              this.cf_defs = new ArrayList<CfDef>(_list29.size);
-              for (int _i30 = 0; _i30 < _list29.size; ++_i30)
+              TList _list37 = iprot.readListBegin();
+              this.cf_defs = new ArrayList<CfDef>(_list37.size);
+              for (int _i38 = 0; _i38 < _list37.size; ++_i38)
               {
-                CfDef _elem31;
-                _elem31 = new CfDef();
-                _elem31.read(iprot);
-                this.cf_defs.add(_elem31);
+                CfDef _elem39;
+                _elem39 = new CfDef();
+                _elem39.read(iprot);
+                this.cf_defs.add(_elem39);
               }
               iprot.readListEnd();
             }
@@ -564,9 +564,9 @@ public void write(TProtocol oprot) throws TException {
       oprot.writeFieldBegin(CF_DEFS_FIELD_DESC);
       {
         oprot.writeListBegin(new TList(TType.STRUCT, this.cf_defs.size()));
-        for (CfDef _iter32 : this.cf_defs)
+        for (CfDef _iter40 : this.cf_defs)
         {
-          _iter32.write(oprot);
+          _iter40.write(oprot);
         }
         oprot.writeListEnd();
       }
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/RowPredicate.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/RowPredicate.java
index e69de29b..a2dd5a3b 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/RowPredicate.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/RowPredicate.java
@@ -0,0 +1,539 @@
+/**
+ * Autogenerated by Thrift
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ */
+package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.EnumMap;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.EnumSet;
+import java.util.Collections;
+import java.util.BitSet;
+import java.util.Arrays;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.thrift.*;
+import org.apache.thrift.meta_data.*;
+import org.apache.thrift.protocol.*;
+
+public class RowPredicate implements TBase<RowPredicate._Fields>, java.io.Serializable, Cloneable, Comparable<RowPredicate> {
+  private static final TStruct STRUCT_DESC = new TStruct("RowPredicate");
+
+  private static final TField KEYS_FIELD_DESC = new TField("keys", TType.LIST, (short)1);
+  private static final TField KEY_RANGE_FIELD_DESC = new TField("key_range", TType.STRUCT, (short)2);
+  private static final TField INDEX_CLAUSE_FIELD_DESC = new TField("index_clause", TType.STRUCT, (short)3);
+
+  public List<byte[]> keys;
+  public KeyRange key_range;
+  public IndexClause index_clause;
+
+  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+  public enum _Fields implements TFieldIdEnum {
+    KEYS((short)1, "keys"),
+    KEY_RANGE((short)2, "key_range"),
+    INDEX_CLAUSE((short)3, "index_clause");
+
+    private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
+    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+    static {
+      for (_Fields field : EnumSet.allOf(_Fields.class)) {
+        byId.put((int)field._thriftId, field);
+        byName.put(field.getFieldName(), field);
+      }
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, or null if its not found.
+     */
+    public static _Fields findByThriftId(int fieldId) {
+      return byId.get(fieldId);
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, throwing an exception
+     * if it is not found.
+     */
+    public static _Fields findByThriftIdOrThrow(int fieldId) {
+      _Fields fields = findByThriftId(fieldId);
+      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+      return fields;
+    }
+
+    /**
+     * Find the _Fields constant that matches name, or null if its not found.
+     */
+    public static _Fields findByName(String name) {
+      return byName.get(name);
+    }
+
+    private final short _thriftId;
+    private final String _fieldName;
+
+    _Fields(short thriftId, String fieldName) {
+      _thriftId = thriftId;
+      _fieldName = fieldName;
+    }
+
+    public short getThriftFieldId() {
+      return _thriftId;
+    }
+
+    public String getFieldName() {
+      return _fieldName;
+    }
+  }
+
+  // isset id assignments
+
+  public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
+    put(_Fields.KEYS, new FieldMetaData("keys", TFieldRequirementType.OPTIONAL, 
+        new ListMetaData(TType.LIST, 
+            new FieldValueMetaData(TType.STRING))));
+    put(_Fields.KEY_RANGE, new FieldMetaData("key_range", TFieldRequirementType.OPTIONAL, 
+        new StructMetaData(TType.STRUCT, KeyRange.class)));
+    put(_Fields.INDEX_CLAUSE, new FieldMetaData("index_clause", TFieldRequirementType.OPTIONAL, 
+        new StructMetaData(TType.STRUCT, IndexClause.class)));
+  }});
+
+  static {
+    FieldMetaData.addStructMetaDataMap(RowPredicate.class, metaDataMap);
+  }
+
+  public RowPredicate() {
+  }
+
+  /**
+   * Performs a deep copy on <i>other</i>.
+   */
+  public RowPredicate(RowPredicate other) {
+    if (other.isSetKeys()) {
+      List<byte[]> __this__keys = new ArrayList<byte[]>();
+      for (byte[] other_element : other.keys) {
+        byte[] temp_binary_element = new byte[other_element.length];
+        System.arraycopy(other_element, 0, temp_binary_element, 0, other_element.length);
+        __this__keys.add(temp_binary_element);
+      }
+      this.keys = __this__keys;
+    }
+    if (other.isSetKey_range()) {
+      this.key_range = new KeyRange(other.key_range);
+    }
+    if (other.isSetIndex_clause()) {
+      this.index_clause = new IndexClause(other.index_clause);
+    }
+  }
+
+  public RowPredicate deepCopy() {
+    return new RowPredicate(this);
+  }
+
+  @Deprecated
+  public RowPredicate clone() {
+    return new RowPredicate(this);
+  }
+
+  public int getKeysSize() {
+    return (this.keys == null) ? 0 : this.keys.size();
+  }
+
+  public java.util.Iterator<byte[]> getKeysIterator() {
+    return (this.keys == null) ? null : this.keys.iterator();
+  }
+
+  public void addToKeys(byte[] elem) {
+    if (this.keys == null) {
+      this.keys = new ArrayList<byte[]>();
+    }
+    this.keys.add(elem);
+  }
+
+  public List<byte[]> getKeys() {
+    return this.keys;
+  }
+
+  public RowPredicate setKeys(List<byte[]> keys) {
+    this.keys = keys;
+    return this;
+  }
+
+  public void unsetKeys() {
+    this.keys = null;
+  }
+
+  /** Returns true if field keys is set (has been asigned a value) and false otherwise */
+  public boolean isSetKeys() {
+    return this.keys != null;
+  }
+
+  public void setKeysIsSet(boolean value) {
+    if (!value) {
+      this.keys = null;
+    }
+  }
+
+  public KeyRange getKey_range() {
+    return this.key_range;
+  }
+
+  public RowPredicate setKey_range(KeyRange key_range) {
+    this.key_range = key_range;
+    return this;
+  }
+
+  public void unsetKey_range() {
+    this.key_range = null;
+  }
+
+  /** Returns true if field key_range is set (has been asigned a value) and false otherwise */
+  public boolean isSetKey_range() {
+    return this.key_range != null;
+  }
+
+  public void setKey_rangeIsSet(boolean value) {
+    if (!value) {
+      this.key_range = null;
+    }
+  }
+
+  public IndexClause getIndex_clause() {
+    return this.index_clause;
+  }
+
+  public RowPredicate setIndex_clause(IndexClause index_clause) {
+    this.index_clause = index_clause;
+    return this;
+  }
+
+  public void unsetIndex_clause() {
+    this.index_clause = null;
+  }
+
+  /** Returns true if field index_clause is set (has been asigned a value) and false otherwise */
+  public boolean isSetIndex_clause() {
+    return this.index_clause != null;
+  }
+
+  public void setIndex_clauseIsSet(boolean value) {
+    if (!value) {
+      this.index_clause = null;
+    }
+  }
+
+  public void setFieldValue(_Fields field, Object value) {
+    switch (field) {
+    case KEYS:
+      if (value == null) {
+        unsetKeys();
+      } else {
+        setKeys((List<byte[]>)value);
+      }
+      break;
+
+    case KEY_RANGE:
+      if (value == null) {
+        unsetKey_range();
+      } else {
+        setKey_range((KeyRange)value);
+      }
+      break;
+
+    case INDEX_CLAUSE:
+      if (value == null) {
+        unsetIndex_clause();
+      } else {
+        setIndex_clause((IndexClause)value);
+      }
+      break;
+
+    }
+  }
+
+  public void setFieldValue(int fieldID, Object value) {
+    setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
+  }
+
+  public Object getFieldValue(_Fields field) {
+    switch (field) {
+    case KEYS:
+      return getKeys();
+
+    case KEY_RANGE:
+      return getKey_range();
+
+    case INDEX_CLAUSE:
+      return getIndex_clause();
+
+    }
+    throw new IllegalStateException();
+  }
+
+  public Object getFieldValue(int fieldId) {
+    return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
+  }
+
+  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
+  public boolean isSet(_Fields field) {
+    switch (field) {
+    case KEYS:
+      return isSetKeys();
+    case KEY_RANGE:
+      return isSetKey_range();
+    case INDEX_CLAUSE:
+      return isSetIndex_clause();
+    }
+    throw new IllegalStateException();
+  }
+
+  public boolean isSet(int fieldID) {
+    return isSet(_Fields.findByThriftIdOrThrow(fieldID));
+  }
+
+  @Override
+  public boolean equals(Object that) {
+    if (that == null)
+      return false;
+    if (that instanceof RowPredicate)
+      return this.equals((RowPredicate)that);
+    return false;
+  }
+
+  public boolean equals(RowPredicate that) {
+    if (that == null)
+      return false;
+
+    boolean this_present_keys = true && this.isSetKeys();
+    boolean that_present_keys = true && that.isSetKeys();
+    if (this_present_keys || that_present_keys) {
+      if (!(this_present_keys && that_present_keys))
+        return false;
+      if (!this.keys.equals(that.keys))
+        return false;
+    }
+
+    boolean this_present_key_range = true && this.isSetKey_range();
+    boolean that_present_key_range = true && that.isSetKey_range();
+    if (this_present_key_range || that_present_key_range) {
+      if (!(this_present_key_range && that_present_key_range))
+        return false;
+      if (!this.key_range.equals(that.key_range))
+        return false;
+    }
+
+    boolean this_present_index_clause = true && this.isSetIndex_clause();
+    boolean that_present_index_clause = true && that.isSetIndex_clause();
+    if (this_present_index_clause || that_present_index_clause) {
+      if (!(this_present_index_clause && that_present_index_clause))
+        return false;
+      if (!this.index_clause.equals(that.index_clause))
+        return false;
+    }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    return 0;
+  }
+
+  public int compareTo(RowPredicate other) {
+    if (!getClass().equals(other.getClass())) {
+      return getClass().getName().compareTo(other.getClass().getName());
+    }
+
+    int lastComparison = 0;
+    RowPredicate typedOther = (RowPredicate)other;
+
+    lastComparison = Boolean.valueOf(isSetKeys()).compareTo(typedOther.isSetKeys());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetKeys()) {      lastComparison = TBaseHelper.compareTo(keys, typedOther.keys);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    lastComparison = Boolean.valueOf(isSetKey_range()).compareTo(typedOther.isSetKey_range());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetKey_range()) {      lastComparison = TBaseHelper.compareTo(key_range, typedOther.key_range);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    lastComparison = Boolean.valueOf(isSetIndex_clause()).compareTo(typedOther.isSetIndex_clause());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetIndex_clause()) {      lastComparison = TBaseHelper.compareTo(index_clause, typedOther.index_clause);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    return 0;
+  }
+
+  public void read(TProtocol iprot) throws TException {
+    TField field;
+    iprot.readStructBegin();
+    while (true)
+    {
+      field = iprot.readFieldBegin();
+      if (field.type == TType.STOP) { 
+        break;
+      }
+      switch (field.id) {
+        case 1: // KEYS
+          if (field.type == TType.LIST) {
+            {
+              TList _list16 = iprot.readListBegin();
+              this.keys = new ArrayList<byte[]>(_list16.size);
+              for (int _i17 = 0; _i17 < _list16.size; ++_i17)
+              {
+                byte[] _elem18;
+                _elem18 = iprot.readBinary();
+                this.keys.add(_elem18);
+              }
+              iprot.readListEnd();
+            }
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        case 2: // KEY_RANGE
+          if (field.type == TType.STRUCT) {
+            this.key_range = new KeyRange();
+            this.key_range.read(iprot);
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        case 3: // INDEX_CLAUSE
+          if (field.type == TType.STRUCT) {
+            this.index_clause = new IndexClause();
+            this.index_clause.read(iprot);
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        default:
+          TProtocolUtil.skip(iprot, field.type);
+      }
+      iprot.readFieldEnd();
+    }
+    iprot.readStructEnd();
+
+    // check for required fields of primitive type, which can't be checked in the validate method
+    validate();
+  }
+
+  public void write(TProtocol oprot) throws TException {
+    validate();
+
+    oprot.writeStructBegin(STRUCT_DESC);
+    if (this.keys != null) {
+      if (isSetKeys()) {
+        oprot.writeFieldBegin(KEYS_FIELD_DESC);
+        {
+          oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
+          for (byte[] _iter19 : this.keys)
+          {
+            oprot.writeBinary(_iter19);
+          }
+          oprot.writeListEnd();
+        }
+        oprot.writeFieldEnd();
+      }
+    }
+    if (this.key_range != null) {
+      if (isSetKey_range()) {
+        oprot.writeFieldBegin(KEY_RANGE_FIELD_DESC);
+        this.key_range.write(oprot);
+        oprot.writeFieldEnd();
+      }
+    }
+    if (this.index_clause != null) {
+      if (isSetIndex_clause()) {
+        oprot.writeFieldBegin(INDEX_CLAUSE_FIELD_DESC);
+        this.index_clause.write(oprot);
+        oprot.writeFieldEnd();
+      }
+    }
+    oprot.writeFieldStop();
+    oprot.writeStructEnd();
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("RowPredicate(");
+    boolean first = true;
+
+    if (isSetKeys()) {
+      sb.append("keys:");
+      if (this.keys == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.keys);
+      }
+      first = false;
+    }
+    if (isSetKey_range()) {
+      if (!first) sb.append(", ");
+      sb.append("key_range:");
+      if (this.key_range == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.key_range);
+      }
+      first = false;
+    }
+    if (isSetIndex_clause()) {
+      if (!first) sb.append(", ");
+      sb.append("index_clause:");
+      if (this.index_clause == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.index_clause);
+      }
+      first = false;
+    }
+    sb.append(")");
+    return sb.toString();
+  }
+
+  public void validate() throws TException {
+    // check for required fields
+  }
+
+}
+
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/TokenRange.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/TokenRange.java
index 360bdfaf..d2e5c17b 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/TokenRange.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/TokenRange.java
@@ -439,13 +439,13 @@ public void read(TProtocol iprot) throws TException {
         case 3: // ENDPOINTS
           if (field.type == TType.LIST) {
             {
-              TList _list16 = iprot.readListBegin();
-              this.endpoints = new ArrayList<String>(_list16.size);
-              for (int _i17 = 0; _i17 < _list16.size; ++_i17)
+              TList _list24 = iprot.readListBegin();
+              this.endpoints = new ArrayList<String>(_list24.size);
+              for (int _i25 = 0; _i25 < _list24.size; ++_i25)
               {
-                String _elem18;
-                _elem18 = iprot.readString();
-                this.endpoints.add(_elem18);
+                String _elem26;
+                _elem26 = iprot.readString();
+                this.endpoints.add(_elem26);
               }
               iprot.readListEnd();
             }
@@ -482,9 +482,9 @@ public void write(TProtocol oprot) throws TException {
       oprot.writeFieldBegin(ENDPOINTS_FIELD_DESC);
       {
         oprot.writeListBegin(new TList(TType.STRING, this.endpoints.size()));
-        for (String _iter19 : this.endpoints)
+        for (String _iter27 : this.endpoints)
         {
-          oprot.writeString(_iter19);
+          oprot.writeString(_iter27);
         }
         oprot.writeListEnd();
       }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/cli/CliClient.java b/cassandra/trunk/src/java/org/apache/cassandra/cli/CliClient.java
index bed5272e..f1004322 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/cli/CliClient.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/cli/CliClient.java
@@ -22,6 +22,7 @@
 import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.thrift.*;
 
+import org.apache.cassandra.utils.FBUtilities;
 import org.apache.thrift.*;
 
 import org.antlr.runtime.tree.*;
@@ -229,19 +230,12 @@ else if (columnSpecCnt == 2)
             columnName = CliCompiler.getColumn(columnFamilySpec, 1).getBytes("UTF-8");
         }
 
-        Clock thrift_clock = new Clock().setTimestamp(timestampMicros());
+        Clock thrift_clock = new Clock().setTimestamp(FBUtilities.timestampMicros());
         thriftClient_.remove(key.getBytes(), new ColumnPath(columnFamily).setSuper_column(superColumnName).setColumn(columnName),
                              thrift_clock, ConsistencyLevel.ONE);
         css_.out.println(String.format("%s removed.", (columnSpecCnt == 0) ? "row" : "column"));
     }
 
-    private static long timestampMicros()
-    {
-        // we use microsecond resolution for compatibility with other client libraries, even though
-        // we can't actually get microsecond precision.
-        return System.currentTimeMillis() * 1000;
-    }
-
     private void doSlice(String keyspace, String key, String columnFamily, byte[] superColumnName)
             throws InvalidRequestException, UnavailableException, TimedOutException, TException, UnsupportedEncodingException, IllegalAccessException, NotFoundException, InstantiationException, NoSuchFieldException
     {
@@ -414,7 +408,7 @@ else if (columnSpecCnt == 1)
         }
         
         // do the insert
-        Clock thrift_clock = new Clock().setTimestamp(timestampMicros());
+        Clock thrift_clock = new Clock().setTimestamp(FBUtilities.timestampMicros());
         thriftClient_.insert(key.getBytes(), new ColumnParent(columnFamily).setSuper_column(superColumnName),
                              new Column(columnName, value.getBytes(), thrift_clock), ConsistencyLevel.ONE);
         
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java b/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
index af83354c..88d75469 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
@@ -110,7 +110,7 @@ static String getStorageConfigPath() throws ConfigurationException
             configFileName = getStorageConfigPath();
             
             if (logger.isDebugEnabled())
-                logger.debug("Loading settings from " + configFileName);
+                logger.info("Loading settings from " + configFileName);
             
             InputStream input = new FileInputStream(new File(configFileName));
             org.yaml.snakeyaml.constructor.Constructor constructor = new org.yaml.snakeyaml.constructor.Constructor(Config.class);
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/KSMetaData.java b/cassandra/trunk/src/java/org/apache/cassandra/config/KSMetaData.java
index b1c9550d..4828d9e1 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/KSMetaData.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/KSMetaData.java
@@ -48,7 +48,7 @@ public KSMetaData(String name, Class<? extends AbstractReplicationStrategy> stra
         Map<String, CFMetaData> cfmap = new HashMap<String, CFMetaData>();
         for (CFMetaData cfm : cfDefs)
             cfmap.put(cfm.cfName, cfm);
-        this.cfMetaData = Collections.<String, CFMetaData>unmodifiableMap(cfmap);
+        this.cfMetaData = Collections.unmodifiableMap(cfmap);
     }
     
     public boolean equals(Object obj)
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamily.java b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamily.java
index 5e9d8591..1681c083 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamily.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamily.java
@@ -30,14 +30,20 @@
 import org.apache.cassandra.db.IClock.ClockRelationship;
 import org.apache.cassandra.db.clock.AbstractReconciler;
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.dht.BytesToken;
+import org.apache.cassandra.dht.LocalPartitioner;
 import org.apache.cassandra.io.ICompactSerializer2;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.io.util.IIterableColumns;
 import org.apache.cassandra.utils.FBUtilities;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public class ColumnFamily implements IColumnContainer, IIterableColumns
 {
+    private static Logger logger = LoggerFactory.getLogger(ColumnFamily.class);
+
     /* The column serializer for this Column Family. Create based on config. */
     private static ColumnFamilySerializer serializer = new ColumnFamilySerializer();
 
@@ -58,8 +64,7 @@ public static ColumnFamily create(String tableName, String cfName)
 
     public static ColumnFamily create(CFMetaData cfm)
     {
-        if (cfm == null)
-            throw new IllegalArgumentException("Unknown column family.");
+        assert cfm != null;
         return new ColumnFamily(cfm.cfType, cfm.clockType, cfm.comparator, cfm.subcolumnComparator, cfm.reconciler, cfm.cfId);
     }
 
@@ -185,6 +190,11 @@ public void addColumn(QueryPath path, byte[] value, IClock clock, int timeToLive
         addColumn(path.superColumnName, column);
     }
 
+    public void deleteColumn(byte[] column, int localDeletionTime, IClock clock)
+    {
+        addColumn(null, new DeletedColumn(column, localDeletionTime, clock));
+    }
+
     public void deleteColumn(QueryPath path, int localDeletionTime, IClock clock)
     {
         assert path.columnName != null : path;
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index f76ee8bb..a901e4a1 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -22,7 +22,6 @@
 import java.io.FilenameFilter;
 import java.io.IOError;
 import java.io.IOException;
-import java.lang.management.ManagementFactory;
 import java.util.*;
 import java.util.concurrent.*;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -30,34 +29,40 @@
 import java.util.concurrent.locks.Condition;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
-import javax.management.MBeanServer;
-import javax.management.ObjectName;
 
-import com.google.common.base.Predicate;
 import com.google.common.collect.Iterables;
-import com.google.common.collect.Iterators;
 import org.apache.commons.collections.IteratorUtils;
+import org.apache.commons.lang.ArrayUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.concurrent.JMXEnabledThreadPoolExecutor;
 import org.apache.cassandra.concurrent.NamedThreadFactory;
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.config.ColumnDefinition;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.IClock.ClockRelationship;
+import org.apache.cassandra.db.clock.TimestampReconciler;
 import org.apache.cassandra.db.commitlog.CommitLog;
 import org.apache.cassandra.db.commitlog.CommitLogSegment;
 import org.apache.cassandra.db.filter.*;
 import org.apache.cassandra.db.marshal.AbstractType;
-import org.apache.cassandra.dht.AbstractBounds;
-import org.apache.cassandra.dht.Bounds;
-import org.apache.cassandra.dht.Range;
-import org.apache.cassandra.dht.Token;
-import org.apache.cassandra.io.sstable.*;
+import org.apache.cassandra.db.marshal.BytesType;
+import org.apache.cassandra.db.marshal.LocalByPartionerType;
+import org.apache.cassandra.dht.*;
+import org.apache.cassandra.io.sstable.Descriptor;
+import org.apache.cassandra.io.sstable.SSTable;
+import org.apache.cassandra.io.sstable.SSTableReader;
+import org.apache.cassandra.io.sstable.SSTableTracker;
 import org.apache.cassandra.io.util.FileUtils;
 import org.apache.cassandra.service.StorageService;
-import org.apache.cassandra.utils.*;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import org.apache.cassandra.thrift.IndexClause;
+import org.apache.cassandra.thrift.IndexExpression;
+import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.LatencyTracker;
+import org.apache.cassandra.utils.SimpleCondition;
+import org.apache.cassandra.utils.WrappedRunnable;
 
 public class ColumnFamilyStore implements ColumnFamilyStoreMBean
 {
@@ -106,6 +111,7 @@ public boolean accept(File dir, String name)
 
     private final String table_;
     public final String columnFamily_;
+    private final IPartitioner partitioner_;
 
     private volatile int memtableSwitchCount = 0;
 
@@ -115,6 +121,8 @@ public boolean accept(File dir, String name)
     /* active memtable associated with this ColumnFamilyStore. */
     private Memtable memtable_;
 
+    private final Map<byte[], ColumnFamilyStore> indexedColumns_;
+
     // TODO binarymemtable ops are not threadsafe (do they need to be?)
     private AtomicReference<BinaryMemtable> binaryMemtable_;
 
@@ -128,13 +136,17 @@ public boolean accept(File dir, String name)
     private long maxRowCompactedSize = 0L;
     private long rowsCompactedTotalSize = 0L;
     private long rowsCompactedCount = 0L;
+    final CFMetaData metadata;
     
-    ColumnFamilyStore(String table, String columnFamilyName, int indexValue)
+    ColumnFamilyStore(String table, String columnFamilyName, IPartitioner partitioner, int generation, CFMetaData metadata)
     {
+        assert metadata != null : "null metadata for " + table + ":" + columnFamilyName;
         table_ = table;
         columnFamily_ = columnFamilyName;
-        fileIndexGenerator_.set(indexValue);
-        memtable_ = new Memtable(this);
+        this.metadata = metadata;
+        this.partitioner_ = partitioner;
+        fileIndexGenerator_.set(generation);
+        memtable_ = new Memtable(this, partitioner_);
         binaryMemtable_ = new AtomicReference<BinaryMemtable>(new BinaryMemtable(this));
 
         if (logger_.isDebugEnabled())
@@ -197,7 +209,7 @@ public boolean accept(File dir, String name)
             SSTableReader sstable;
             try
             {
-                sstable = SSTableReader.open(filename);
+                sstable = SSTableReader.open(filename, partitioner_);
             }
             catch (IOException ex)
             {
@@ -208,6 +220,39 @@ public boolean accept(File dir, String name)
         }
         ssTables_ = new SSTableTracker(table, columnFamilyName);
         ssTables_.add(sstables);
+
+        indexedColumns_ = new TreeMap<byte[], ColumnFamilyStore>(BytesType.instance);
+        for (Map.Entry<byte[], ColumnDefinition> entry : metadata.column_metadata.entrySet())
+        {
+            byte[] column = entry.getKey();
+            ColumnDefinition info = entry.getValue();
+            if (info.index_type == null)
+                continue;
+
+            String indexedCfName = columnFamily_ + "." + (info.index_name == null ? FBUtilities.bytesToHex(column) : info.index_name);
+            IPartitioner rowPartitioner = StorageService.getPartitioner();
+            AbstractType columnComparator = (rowPartitioner instanceof OrderPreservingPartitioner || rowPartitioner instanceof ByteOrderedPartitioner)
+                                            ? BytesType.instance
+                                            : new LocalByPartionerType(StorageService.getPartitioner());
+            CFMetaData indexedCfMetadata = new CFMetaData(table,
+                                                          indexedCfName,
+                                                          ColumnFamilyType.Standard,
+                                                          ClockType.Timestamp,
+                                                          columnComparator,
+                                                          null,
+                                                          new TimestampReconciler(),
+                                                          "",
+                                                          0,
+                                                          false,
+                                                          0,
+                                                          0,
+                                                          Collections.<byte[], ColumnDefinition>emptyMap());
+            ColumnFamilyStore indexedCfs = ColumnFamilyStore.createColumnFamilyStore(table, 
+                                                                                     indexedCfName,
+                                                                                     new LocalPartitioner(metadata.column_metadata.get(column).validator),
+                                                                                     indexedCfMetadata);
+            indexedColumns_.put(column, indexedCfs);
+        }
     }
 
     public void addToCompactedRowStats(long rowsize)
@@ -239,6 +284,11 @@ public long getMeanRowCompactedSize()
     }
 
     public static ColumnFamilyStore createColumnFamilyStore(String table, String columnFamily)
+    {
+        return createColumnFamilyStore(table, columnFamily, StorageService.getPartitioner(), DatabaseDescriptor.getCFMetaData(table, columnFamily));
+    }
+
+    public static ColumnFamilyStore createColumnFamilyStore(String table, String columnFamily, IPartitioner partitioner, CFMetaData metadata)
     {
         /*
          * Get all data files associated with old Memtables for this table.
@@ -269,22 +319,7 @@ public static ColumnFamilyStore createColumnFamilyStore(String table, String col
         Collections.sort(generations);
         int value = (generations.size() > 0) ? (generations.get(generations.size() - 1)) : 0;
 
-        ColumnFamilyStore cfs = new ColumnFamilyStore(table, columnFamily, value);
-
-        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
-        try
-        {
-            ObjectName mbeanName = new ObjectName("org.apache.cassandra.db:type=ColumnFamilyStores,keyspace=" + table + ",columnfamily=" + columnFamily);
-            if (mbs.isRegistered(mbeanName))
-                mbs.unregisterMBean(mbeanName);
-            mbs.registerMBean(cfs, mbeanName);
-        }
-        catch (Exception e)
-        {
-            throw new RuntimeException(e);
-        }
-
-        return cfs;
+        return new ColumnFamilyStore(table, columnFamily, partitioner, value, metadata);
     }
 
     private Set<File> files()
@@ -367,7 +402,7 @@ public String getTempSSTablePath(String directory)
             final CommitLogSegment.CommitLogContext ctx = writeCommitLog ? CommitLog.instance().getContext() : null;
             logger_.info(columnFamily_ + " has reached its threshold; switching in a fresh Memtable at " + ctx);
             final Condition condition = submitFlush(oldMemtable);
-            memtable_ = new Memtable(this);
+            memtable_ = new Memtable(this, partitioner_);
             // a second executor that makes sure the onMemtableFlushes get called in the right order,
             // while keeping the wait-for-flush (future.get) out of anything latency-sensitive.
             return commitLogUpdater_.submit(new WrappedRunnable()
@@ -379,9 +414,8 @@ public void runMayThrow() throws InterruptedException, IOException
                     {
                         // if we're not writing to the commit log, we are replaying the log, so marking
                         // the log header with "you can discard anything written before the context" is not valid
-                        final Integer cfId = DatabaseDescriptor.getTableMetaData(table_).get(columnFamily_).cfId;
-                        logger_.debug("Discarding {}", cfId);
-                        CommitLog.instance().discardCompletedSegments(cfId, ctx);
+                        logger_.debug("Discarding {}", metadata.cfId);
+                        CommitLog.instance().discardCompletedSegments(metadata.cfId, ctx);
                     }
                 }
             });
@@ -800,7 +834,7 @@ private ColumnFamily getTopLevelColumns(QueryFilter filter, int gcBefore)
     {
         // we are querying top-level columns, do a merging fetch with indexes.
         List<IColumnIterator> iterators = new ArrayList<IColumnIterator>();
-        final ColumnFamily returnCF = ColumnFamily.create(table_, columnFamily_);
+        final ColumnFamily returnCF = ColumnFamily.create(metadata);
         try
         {
             IColumnIterator iter;
@@ -947,7 +981,7 @@ private boolean getRangeRows(List<Row> rows, byte[] superColumn, final AbstractB
         else
         {
             // wrapped range
-            Token min = StorageService.getPartitioner().getMinimumToken();
+            Token min = partitioner_.getMinimumToken();
             Range first = new Range(range.left, min);
             completed = getRangeRows(rows, super_column, first, keyMax, columnFilter);
             if (!completed && min.compareTo(range.right) < 0)
@@ -960,9 +994,42 @@ private boolean getRangeRows(List<Row> rows, byte[] superColumn, final AbstractB
         return rows;
     }
 
+    public List<Row> scan(IndexClause indexClause, IFilter dataFilter)
+    {
+        // TODO: use statistics to pick clause w/ highest selectivity
+        // TODO even later: allow merge join instead of just one index + loop
+        IndexExpression first = indexClause.expressions.get(0);
+        ColumnFamilyStore indexCFS = getIndexedColumnFamilyStore(first.column_name);
+        assert indexCFS != null;
+        DecoratedKey indexKey = indexCFS.partitioner_.decorateKey(first.value);
+        QueryFilter indexFilter = QueryFilter.getSliceFilter(indexKey,
+                                                             new QueryPath(indexCFS.getColumnFamilyName()),
+                                                             ArrayUtils.EMPTY_BYTE_ARRAY,
+                                                             ArrayUtils.EMPTY_BYTE_ARRAY,
+                                                             null,
+                                                             false,
+                                                             indexClause.count);
+
+        List<Row> rows = new ArrayList<Row>();
+        ColumnFamily indexRow = indexCFS.getColumnFamily(indexFilter);
+        if (indexRow == null)
+            return rows;
+
+        for (byte[] dataKey : indexRow.getColumnNames())
+        {
+            DecoratedKey dk = partitioner_.decorateKey(dataKey);
+            ColumnFamily data = getColumnFamily(new QueryFilter(dk, new QueryPath(columnFamily_), dataFilter));
+            rows.add(new Row(dk, data));
+        }
+
+        // TODO apply remaining expressions
+
+        return rows;
+    }
+
     public AbstractType getComparator()
     {
-        return DatabaseDescriptor.getComparator(table_, columnFamily_);
+        return metadata.comparator;
     }
 
     /**
@@ -1020,13 +1087,11 @@ public void snapshot(String snapshotName)
 
     public void loadRowCache()
     {
-        CFMetaData metadata = DatabaseDescriptor.getTableMetaData(table_).get(columnFamily_);
-        assert metadata != null;
         if (metadata.preloadRowCache)
         {
             logger_.debug(String.format("Loading cache for keyspace/columnfamily %s/%s", table_, columnFamily_));
             int ROWS = 4096;
-            Token min = StorageService.getPartitioner().getMinimumToken();
+            Token min = partitioner_.getMinimumToken();
             Token start = min;
             long i = 0;
             while (i < ssTables_.getRowCache().getCapacity())
@@ -1047,7 +1112,7 @@ public void loadRowCache()
                 if (result.size() < ROWS)
                     break;
 
-                start = DatabaseDescriptor.getPartitioner().getToken(result.get(ROWS - 1).key.key);
+                start = partitioner_.getToken(result.get(ROWS - 1).key.key);
             }
             logger_.info(String.format("Loaded %s rows into the %s cache", i, columnFamily_));
         }
@@ -1228,4 +1293,33 @@ public double getRecentBloomFilterFalseRatio()
             return 0d;
         return (double) falseCount / (trueCount + falseCount);
     }
+
+    public Set<byte[]> getIndexedColumns()
+    {
+        return indexedColumns_.keySet();
+    }
+
+    public ColumnFamilyStore getIndexedColumnFamilyStore(byte[] column)
+    {
+        return indexedColumns_.get(column);
+    }
+
+    public ColumnFamily newIndexedColumnFamily(byte[] column)
+    {
+        return ColumnFamily.create(indexedColumns_.get(column).metadata);
+    }
+
+    public DecoratedKey getIndexKeyFor(byte[] name, byte[] value)
+    {
+        return indexedColumns_.get(name).partitioner_.decorateKey(value);
+    }
+
+    @Override
+    public String toString()
+    {
+        return "ColumnFamilyStore(" +
+               "table='" + table_ + '\'' +
+               ", columnFamily='" + columnFamily_ + '\'' +
+               ')';
+    }
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/IndexScanCommand.java b/cassandra/trunk/src/java/org/apache/cassandra/db/IndexScanCommand.java
index e69de29b..03ba5194 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/IndexScanCommand.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/IndexScanCommand.java
@@ -0,0 +1,85 @@
+package org.apache.cassandra.db;
+
+import java.io.*;
+import java.util.Arrays;
+
+import org.apache.cassandra.concurrent.StageManager;
+import org.apache.cassandra.io.ICompactSerializer2;
+import org.apache.cassandra.io.util.DataOutputBuffer;
+import org.apache.cassandra.net.Message;
+import org.apache.cassandra.service.StorageService;
+import org.apache.cassandra.thrift.IndexClause;
+import org.apache.cassandra.thrift.SlicePredicate;
+import org.apache.cassandra.utils.FBUtilities;
+import org.apache.thrift.TDeserializer;
+import org.apache.thrift.TSerializer;
+import org.apache.thrift.protocol.TBinaryProtocol;
+
+public class IndexScanCommand
+{
+    private static final IndexScanCommandSerializer serializer = new IndexScanCommandSerializer();
+
+    public final String keyspace;
+    public final String column_family;
+    public final IndexClause index_clause;
+    public final SlicePredicate predicate;
+
+    public IndexScanCommand(String keyspace, String column_family, IndexClause index_clause, SlicePredicate predicate)
+    {
+
+        this.keyspace = keyspace;
+        this.column_family = column_family;
+        this.index_clause = index_clause;
+        this.predicate = predicate;
+    }
+
+    public Message getMessage()
+    {
+        DataOutputBuffer dob = new DataOutputBuffer();
+        try
+        {
+            serializer.serialize(this, dob);
+        }
+        catch (IOException e)
+        {
+            throw new IOError(e);
+        }
+        return new Message(FBUtilities.getLocalAddress(),
+                           StageManager.READ_STAGE,
+                           StorageService.Verb.INDEX_SCAN,
+                           Arrays.copyOf(dob.getData(), dob.getLength()));
+    }
+
+    public static IndexScanCommand read(Message message) throws IOException
+    {
+        byte[] bytes = message.getMessageBody();
+        ByteArrayInputStream bis = new ByteArrayInputStream(bytes);
+        return serializer.deserialize(new DataInputStream(bis));
+    }
+
+    private static class IndexScanCommandSerializer implements ICompactSerializer2<IndexScanCommand>
+    {
+        public void serialize(IndexScanCommand o, DataOutput out) throws IOException
+        {
+            out.writeUTF(o.keyspace);
+            out.writeUTF(o.column_family);
+            TSerializer ser = new TSerializer(new TBinaryProtocol.Factory());
+            FBUtilities.serialize(ser, o.index_clause, out);
+            FBUtilities.serialize(ser, o.predicate, out);
+        }
+
+        public IndexScanCommand deserialize(DataInput in) throws IOException
+        {
+            String keyspace = in.readUTF();
+            String columnFamily = in.readUTF();
+
+            TDeserializer dser = new TDeserializer(new TBinaryProtocol.Factory());
+            IndexClause indexClause = new IndexClause();
+            FBUtilities.deserialize(dser, indexClause, in);
+            SlicePredicate predicate = new SlicePredicate();
+            FBUtilities.deserialize(dser, predicate, in);
+
+            return new IndexScanCommand(keyspace, columnFamily, indexClause, predicate);
+        }
+    }
+}
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/Memtable.java b/cassandra/trunk/src/java/org/apache/cassandra/db/Memtable.java
index c30ed7d9..b6077896 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/Memtable.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/Memtable.java
@@ -55,13 +55,14 @@
 
     private final long creationTime;
     private final ConcurrentNavigableMap<DecoratedKey, ColumnFamily> columnFamilies = new ConcurrentSkipListMap<DecoratedKey, ColumnFamily>();
-    private final IPartitioner partitioner = StorageService.getPartitioner();
+    private final IPartitioner partitioner;
     private final ColumnFamilyStore cfs;
 
-    public Memtable(ColumnFamilyStore cfs)
+    public Memtable(ColumnFamilyStore cfs, IPartitioner partitioner)
     {
 
         this.cfs = cfs;
+        this.partitioner = partitioner;
         creationTime = System.currentTimeMillis();
     }
 
@@ -147,7 +148,7 @@ public String contents()
     private SSTableReader writeSortedContents() throws IOException
     {
         logger.info("Writing " + this);
-        SSTableWriter writer = new SSTableWriter(cfs.getFlushPath(), columnFamilies.size(), StorageService.getPartitioner());
+        SSTableWriter writer = new SSTableWriter(cfs.getFlushPath(), columnFamilies.size(), partitioner);
 
         DataOutputBuffer buffer = new DataOutputBuffer();
         for (Map.Entry<DecoratedKey, ColumnFamily> entry : columnFamilies.entrySet())
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/Table.java b/cassandra/trunk/src/java/org/apache/cassandra/db/Table.java
index b075fcbd..d5b58dd4 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/Table.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/Table.java
@@ -19,6 +19,7 @@
 package org.apache.cassandra.db;
 
 import java.io.IOError;
+import java.lang.management.ManagementFactory;
 import java.util.*;
 import java.io.IOException;
 import java.io.File;
@@ -28,17 +29,17 @@
 
 import com.google.common.base.Function;
 import com.google.common.collect.Iterables;
-import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.config.DatabaseDescriptor;
-import org.apache.cassandra.config.Config;
+
+import org.apache.cassandra.config.*;
 import org.apache.cassandra.db.commitlog.CommitLog;
-import org.apache.cassandra.db.commitlog.CommitLogSegment;
-import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.io.sstable.SSTableDeletingReference;
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.io.util.FileUtils;
 
-import java.net.InetAddress;
+import javax.management.MBeanServer;
+import javax.management.ObjectName;
+
+import org.apache.commons.lang.ArrayUtils;
 
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.db.filter.*;
@@ -84,6 +85,7 @@
     // cache application CFs since Range queries ask for them a _lot_
     private SortedSet<String> applicationColumnFamilies;
     private final TimerTask flushTask;
+    private final Object[] indexLocks;
     
     public static Table open(String table)
     {
@@ -215,6 +217,9 @@ public void forceCompaction()
     private Table(String table)
     {
         name = table;
+        indexLocks = new Object[DatabaseDescriptor.getConcurrentWriters() * 8];
+        for (int i = 0; i < indexLocks.length; i++)
+            indexLocks[i] = new Object();
         // create data directories.
         for (String dataDir : DatabaseDescriptor.getAllDataFileLocations())
         {
@@ -234,9 +239,23 @@ private Table(String table)
             }
         }
       
-        for (CFMetaData cfm : DatabaseDescriptor.getTableDefinition(table).cfMetaData().values())
+        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
+        for (CFMetaData cfm : new ArrayList<CFMetaData>(DatabaseDescriptor.getTableDefinition(table).cfMetaData().values()))
         {
-            columnFamilyStores.put(cfm.cfId, ColumnFamilyStore.createColumnFamilyStore(table, cfm.cfName));
+            ColumnFamilyStore cfs = ColumnFamilyStore.createColumnFamilyStore(table, cfm.cfName);
+            columnFamilyStores.put(cfm.cfId, cfs);
+            try
+            {
+                ObjectName mbeanName = new ObjectName("org.apache.cassandra.db:type=ColumnFamilyStores,keyspace=" + table + ",columnfamily=" + cfm.cfName);
+                if (mbs.isRegistered(mbeanName))
+                    mbs.unregisterMBean(mbeanName);
+                mbs.registerMBean(cfs, mbeanName);
+            }
+            catch (Exception e)
+            {
+                throw new RuntimeException(e);
+            }
+
          }
 
         // check 10x as often as the lifetime, so we can exceed lifetime by 10% at most
@@ -312,30 +331,78 @@ public void apply(RowMutation mutation, Object serializedMutation, boolean write
         try
         {
             if (writeCommitLog)
-            {
                 CommitLog.instance().add(mutation, serializedMutation);
-            }
         
             DecoratedKey key = StorageService.getPartitioner().decorateKey(mutation.key());
             for (ColumnFamily columnFamily : mutation.getColumnFamilies())
             {
-                Memtable memtableToFlush;
                 ColumnFamilyStore cfs = columnFamilyStores.get(columnFamily.id());
                 if (cfs == null)
                 {
                     logger.error("Attempting to mutate non-existant column family " + columnFamily.id());
+                    continue;
+                }
+
+                ColumnFamily oldIndexedColumns;
+                SortedSet<byte[]> mutatedIndexedColumns = null;
+                for (byte[] column : cfs.getIndexedColumns())
+                {
+                    if (columnFamily.getColumnNames().contains(column))
+                    {
+                        if (mutatedIndexedColumns == null)
+                            mutatedIndexedColumns = new TreeSet<byte[]>(FBUtilities.byteArrayComparator);
+                        mutatedIndexedColumns.add(column);
+                    }
+                }
+
+                if (mutatedIndexedColumns == null)
+                {
+                    // just update the actual value, no extra synchronization
+                    applyCF(cfs, key, columnFamily, memtablesToFlush);
                 }
                 else
                 {
-                    if ((memtableToFlush=cfs.apply(key, columnFamily)) != null)
-                        memtablesToFlush.put(cfs, memtableToFlush);
+                    synchronized (indexLocks[Arrays.hashCode(mutation.key()) % indexLocks.length])
+                    {
+                        // read old indexed values
+                        QueryFilter filter = QueryFilter.getNamesFilter(key, new QueryPath(cfs.getColumnFamilyName()), mutatedIndexedColumns);
+                        oldIndexedColumns = cfs.getColumnFamily(filter);
+
+                        // apply the mutation
+                        applyCF(cfs, key, columnFamily, memtablesToFlush);
+
+                        // add new index entries
+                        for (byte[] columnName : mutatedIndexedColumns)
+                        {
+                            IColumn column = columnFamily.getColumn(columnName);
+                            DecoratedKey valueKey = cfs.getIndexKeyFor(columnName, column.value());
+                            ColumnFamily cf = cfs.newIndexedColumnFamily(columnName);
+                            cf.addColumn(new Column(mutation.key(), ArrayUtils.EMPTY_BYTE_ARRAY, column.clock()));
+                            applyCF(cfs.getIndexedColumnFamilyStore(columnName), valueKey, cf, memtablesToFlush);
+                        }
+
+                        // remove the old index entries
+                        if (oldIndexedColumns != null)
+                        {
+                            int localDeletionTime = (int)(System.currentTimeMillis() / 1000);
+                            for (Map.Entry<byte[], IColumn> entry : oldIndexedColumns.getColumnsMap().entrySet())
+                            {
+                                byte[] columnName = entry.getKey();
+                                IColumn column = entry.getValue();
+                                DecoratedKey valueKey = cfs.getIndexKeyFor(columnName, column.value());
+                                ColumnFamily cf = cfs.newIndexedColumnFamily(columnName);
+                                cf.deleteColumn(mutation.key(), localDeletionTime, column.clock());
+                                applyCF(cfs, valueKey, cf, memtablesToFlush);
+                            }
+                        }
+                    }
+                }
     
                     ColumnFamily cachedRow = cfs.getRawCachedRow(key);
                     if (cachedRow != null)
                         cachedRow.addAll(columnFamily);
                 }
             }
-        }
         finally
         {
             flusherLock.readLock().unlock();
@@ -346,6 +413,13 @@ public void apply(RowMutation mutation, Object serializedMutation, boolean write
             entry.getKey().maybeSwitchMemtable(entry.getValue(), writeCommitLog);
     }
 
+    private static void applyCF(ColumnFamilyStore cfs, DecoratedKey key, ColumnFamily columnFamily, HashMap<ColumnFamilyStore, Memtable> memtablesToFlush)
+    {
+        Memtable memtableToFlush = cfs.apply(key, columnFamily);
+        if (memtableToFlush != null)
+            memtablesToFlush.put(cfs, memtableToFlush);
+    }
+
     public List<Future<?>> flush() throws IOException
     {
         List<Future<?>> futures = new ArrayList<Future<?>>();
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/QueryFilter.java b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/QueryFilter.java
index b452180c..a0e34714 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/QueryFilter.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/QueryFilter.java
@@ -31,9 +31,13 @@
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.IClock.ClockRelationship;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public class QueryFilter
 {
+    private static Logger logger = LoggerFactory.getLogger(QueryFilter.class);
+
     public final DecoratedKey key;
     public final QueryPath path;
     private final IFilter filter;
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/marshal/LocalByPartionerType.java b/cassandra/trunk/src/java/org/apache/cassandra/db/marshal/LocalByPartionerType.java
index e69de29b..f88da1a9 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/marshal/LocalByPartionerType.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/marshal/LocalByPartionerType.java
@@ -0,0 +1,26 @@
+package org.apache.cassandra.db.marshal;
+
+import org.apache.cassandra.dht.IPartitioner;
+import org.apache.cassandra.dht.Token;
+
+/** for sorting columns representing row keys in the row ordering as determined by a partitioner.
+ * Not intended for user-defined CFs, and will in fact error out if used with such. */
+public class LocalByPartionerType<T extends Token> extends AbstractType
+{
+    private final IPartitioner<T> partitioner;
+
+    public LocalByPartionerType(IPartitioner<T> partitioner)
+    {
+        this.partitioner = partitioner;
+    }
+
+    public String getString(byte[] bytes)
+    {
+        return null;
+    }
+
+    public int compare(byte[] o1, byte[] o2)
+    {
+        return partitioner.decorateKey(o1).compareTo(partitioner.decorateKey(o2));
+    }
+}
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
index f979c1c3..9f8fc3ff 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
@@ -92,9 +92,10 @@ public void applyModels() throws IOException
         {
             throw new IOException(ex);
         }
+        Table.open(cfm.tableName); // make sure it's init-ed w/ the old definitions first, since we're going to call initCf on the new one manually
+        DatabaseDescriptor.setTableDefinition(ksm, newVersion);
         if (!clientMode)
             Table.open(ksm.name).initCf(cfm.cfId, cfm.cfName);
-        DatabaseDescriptor.setTableDefinition(ksm, newVersion);
         
         if (!clientMode)
             // force creation of a new commit log segment.
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/dht/LocalPartitioner.java b/cassandra/trunk/src/java/org/apache/cassandra/dht/LocalPartitioner.java
index e69de29b..da44d767 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/dht/LocalPartitioner.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/dht/LocalPartitioner.java
@@ -0,0 +1,61 @@
+package org.apache.cassandra.dht;
+
+import org.apache.commons.lang.ArrayUtils;
+
+import org.apache.cassandra.db.DecoratedKey;
+import org.apache.cassandra.db.marshal.AbstractType;
+
+public class LocalPartitioner implements IPartitioner<LocalToken>
+{
+    private final AbstractType comparator;
+
+    public LocalPartitioner(AbstractType comparator)
+    {
+        this.comparator = comparator;
+    }
+
+    public DecoratedKey<LocalToken> convertFromDiskFormat(byte[] key)
+    {
+        return decorateKey(key);
+    }
+
+    public byte[] convertToDiskFormat(DecoratedKey<LocalToken> key)
+    {
+        return key.token.token;
+    }
+
+    public DecoratedKey<LocalToken> decorateKey(byte[] key)
+    {
+        return new DecoratedKey<LocalToken>(getToken(key), key);
+    }
+
+    public LocalToken midpoint(LocalToken left, LocalToken right)
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public LocalToken getMinimumToken()
+    {
+        return new LocalToken(comparator, ArrayUtils.EMPTY_BYTE_ARRAY);
+    }
+
+    public LocalToken getToken(byte[] key)
+    {
+        return new LocalToken(comparator, key);
+    }
+
+    public LocalToken getRandomToken()
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public Token.TokenFactory getTokenFactory()
+    {
+        throw new UnsupportedOperationException();
+    }
+
+    public boolean preservesOrder()
+    {
+        return true;
+    }
+}
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/dht/LocalToken.java b/cassandra/trunk/src/java/org/apache/cassandra/dht/LocalToken.java
index e69de29b..78ea288d 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/dht/LocalToken.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/dht/LocalToken.java
@@ -0,0 +1,66 @@
+/*
+* Licensed to the Apache Software Foundation (ASF) under one
+* or more contributor license agreements.  See the NOTICE file
+* distributed with this work for additional information
+* regarding copyright ownership.  The ASF licenses this file
+* to you under the Apache License, Version 2.0 (the
+* "License"); you may not use this file except in compliance
+* with the License.  You may obtain a copy of the License at
+*
+*    http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing,
+* software distributed under the License is distributed on an
+* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+* KIND, either express or implied.  See the License for the
+* specific language governing permissions and limitations
+* under the License.
+*/
+package org.apache.cassandra.dht;
+
+import java.util.Arrays;
+
+import org.apache.cassandra.db.marshal.AbstractType;
+import org.apache.cassandra.utils.FBUtilities;
+
+public class LocalToken extends Token<byte[]>
+{
+    private final AbstractType comparator;
+
+    public LocalToken(AbstractType comparator, byte... token)
+    {
+        super(token);
+        this.comparator = comparator;
+    }
+
+    @Override
+    public String toString()
+    {
+        return comparator.getString(token);
+    }
+
+    @Override
+    public int compareTo(Token<byte[]> o)
+    {
+        return comparator.compare(token, o.token);
+    }
+
+    @Override
+    public int hashCode()
+    {
+        final int prime = 31;
+        return prime + Arrays.hashCode(token);
+    }
+
+    @Override
+    public boolean equals(Object obj)
+    {
+        if (this == obj)
+            return true;
+        if (!(obj instanceof LocalToken))
+            return false;
+        LocalToken other = (LocalToken) obj;
+        return Arrays.equals(token, other.token);
+    }
+
+}
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/service/IndexScanVerbHandler.java b/cassandra/trunk/src/java/org/apache/cassandra/service/IndexScanVerbHandler.java
index e69de29b..072aa67e 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/service/IndexScanVerbHandler.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/service/IndexScanVerbHandler.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.service;
+
+import org.apache.cassandra.db.*;
+import org.apache.cassandra.db.filter.QueryFilter;
+import org.apache.cassandra.net.IVerbHandler;
+import org.apache.cassandra.net.Message;
+import org.apache.cassandra.net.MessagingService;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class IndexScanVerbHandler implements IVerbHandler
+{
+    private static final Logger logger = LoggerFactory.getLogger(IndexScanVerbHandler.class);
+
+    public void doVerb(Message message)
+    {
+        try
+        {
+            IndexScanCommand command = IndexScanCommand.read(message);
+            ColumnFamilyStore cfs = Table.open(command.keyspace).getColumnFamilyStore(command.column_family);
+            RangeSliceReply reply = new RangeSliceReply(cfs.scan(command.index_clause, QueryFilter.getFilter(command.predicate, cfs.getComparator())));
+            Message response = reply.getReply(message);
+            if (logger.isDebugEnabled())
+                logger.debug("Sending " + reply+ " to " + message.getMessageId() + "@" + message.getFrom());
+            MessagingService.instance.sendOneWay(response, message.getFrom());
+        }
+        catch (Exception ex)
+        {
+            throw new RuntimeException(ex);
+        }
+    }
+}
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/service/RangeSliceVerbHandler.java b/cassandra/trunk/src/java/org/apache/cassandra/service/RangeSliceVerbHandler.java
index a42718f4..1d8a7e72 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/service/RangeSliceVerbHandler.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/service/RangeSliceVerbHandler.java
@@ -32,7 +32,7 @@
 public class RangeSliceVerbHandler implements IVerbHandler
 {
 
-    private static final Logger logger = LoggerFactory.getLogger(RangeSliceVerbHandler.class);
+    private static final Logger logger = LoggerFactory.getLogger(IndexScanVerbHandler.class);
 
     public void doVerb(Message message)
     {
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/service/StorageProxy.java b/cassandra/trunk/src/java/org/apache/cassandra/service/StorageProxy.java
index ebbde860..8543389d 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/service/StorageProxy.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/service/StorageProxy.java
@@ -28,19 +28,19 @@
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
+import com.google.common.collect.AbstractIterator;
+import com.google.common.collect.Multimap;
 import org.apache.commons.lang.ArrayUtils;
 import org.apache.commons.lang.StringUtils;
-
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.google.common.collect.AbstractIterator;
-import com.google.common.collect.Multimap;
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.dht.AbstractBounds;
+import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.gms.Gossiper;
@@ -54,7 +54,6 @@
 import org.apache.cassandra.thrift.UnavailableException;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.LatencyTracker;
-import org.apache.cassandra.utils.Pair;
 import org.apache.cassandra.utils.WrappedRunnable;
 
 public class StorageProxy implements StorageProxyMBean
@@ -757,6 +756,28 @@ public double getRecentWriteLatencyMicros()
         return writeStats.getRecentLatencyMicros();
     }
 
+    public static List<Row> scan(IndexScanCommand command, ConsistencyLevel consistency_level)
+    throws IOException, TimeoutException
+    {
+        IPartitioner p = StorageService.getPartitioner();
+        Token startToken = command.index_clause.start_key == null ? p.getMinimumToken() : p.getToken(command.index_clause.start_key);
+        List<InetAddress> endpoints = StorageService.instance.getLiveNaturalEndpoints(command.keyspace, startToken);
+        // TODO iterate through endpoints in token order like getRangeSlice
+        Message message = command.getMessage();
+        RangeSliceResponseResolver resolver = new RangeSliceResponseResolver(command.keyspace, endpoints);
+        AbstractReplicationStrategy rs = StorageService.instance.getReplicationStrategy(command.keyspace);
+        QuorumResponseHandler<List<Row>> handler = rs.getQuorumResponseHandler(resolver, consistency_level, command.keyspace);
+        MessagingService.instance.sendRR(message, endpoints.get(0), handler);
+        try
+        {
+            return handler.get();
+        }
+        catch (DigestMismatchException e)
+        {
+            throw new RuntimeException(e);
+        }
+    }
+
     static class weakReadLocalCallable implements Callable<Object>
     {
         private ReadCommand command;
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/service/StorageService.java b/cassandra/trunk/src/java/org/apache/cassandra/service/StorageService.java
index 9d5bc66e..a616fd03 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/service/StorageService.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/service/StorageService.java
@@ -115,7 +115,7 @@
         DEFINITIONS_UPDATE_RESPONSE,
         TRUNCATE,
         SCHEMA_CHECK,
-        ;
+        INDEX_SCAN;
         // remember to add new verbs at the end, since we serialize by ordinal
     }
     public static final Verb[] VERBS = Verb.values();
@@ -223,6 +223,7 @@ public StorageService()
         MessagingService.instance.registerVerbHandlers(Verb.READ_REPAIR, new ReadRepairVerbHandler());
         MessagingService.instance.registerVerbHandlers(Verb.READ, new ReadVerbHandler());
         MessagingService.instance.registerVerbHandlers(Verb.RANGE_SLICE, new RangeSliceVerbHandler());
+        MessagingService.instance.registerVerbHandlers(Verb.INDEX_SCAN, new IndexScanVerbHandler());
         // see BootStrapper for a summary of how the bootstrap verbs interact
         MessagingService.instance.registerVerbHandlers(Verb.BOOTSTRAP_TOKEN, new BootStrapper.BootstrapTokenVerbHandler());
         MessagingService.instance.registerVerbHandlers(Verb.STREAM_REQUEST, new StreamRequestVerbHandler() );
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java b/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
index 67acb8c3..a6142dc5 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
@@ -490,6 +490,12 @@ private void doInsert(ConsistencyLevel consistency_level, RowMutation rm) throws
         String keyspace = keySpace.get();
         checkKeyspaceAndLoginAuthorized(AccessLevel.READONLY);
 
+        return getRangeSlicesInternal(keyspace, column_parent, range, predicate, consistency_level);
+    }
+
+    private List<KeySlice> getRangeSlicesInternal(String keyspace, ColumnParent column_parent, KeyRange range, SlicePredicate predicate, ConsistencyLevel consistency_level)
+    throws InvalidRequestException, UnavailableException, TimedOutException
+    {
         ThriftValidation.validateColumnParent(keyspace, column_parent);
         ThriftValidation.validatePredicate(keyspace, column_parent, predicate);
         ThriftValidation.validateKeyRange(range);
@@ -522,6 +528,11 @@ private void doInsert(ConsistencyLevel consistency_level, RowMutation rm) throws
             throw new RuntimeException(e);
         }
 
+        return thriftifyKeySlices(rows, column_parent, predicate);
+    }
+
+    private List<KeySlice> thriftifyKeySlices(List<Row> rows, ColumnParent column_parent, SlicePredicate predicate)
+    {
         List<KeySlice> keySlices = new ArrayList<KeySlice>(rows.size());
         boolean reversed = predicate.slice_range != null && predicate.slice_range.reversed;
         for (Row row : rows)
@@ -533,6 +544,71 @@ private void doInsert(ConsistencyLevel consistency_level, RowMutation rm) throws
         return keySlices;
     }
 
+    public List<KeySlice> scan(ColumnParent column_parent, RowPredicate row_predicate, SlicePredicate column_predicate, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
+    {
+        if (logger.isDebugEnabled())
+            logger.debug("scan");
+
+        checkKeyspaceAndLoginAuthorized(AccessLevel.READONLY);
+
+        if (row_predicate.keys != null)
+        {
+            Map<byte[], List<ColumnOrSuperColumn>> rowMap = multigetSliceInternal(keySpace.get(), row_predicate.keys, column_parent, column_predicate, consistency_level);
+            List<KeySlice> rows = new ArrayList<KeySlice>(rowMap.size());
+            for (Map.Entry<byte[], List<ColumnOrSuperColumn>> entry : rowMap.entrySet())
+            {
+                rows.add(new KeySlice(entry.getKey(), entry.getValue()));
+            }
+            return rows;
+        }
+
+        if (row_predicate.key_range != null)
+        {
+            return getRangeSlicesInternal(keySpace.get(), column_parent, row_predicate.key_range, column_predicate, consistency_level);
+        }
+
+        if (row_predicate.index_clause != null)
+        {
+            return scanIndexInternal(keySpace.get(), column_parent, row_predicate.index_clause, column_predicate, consistency_level);
+        }
+
+        throw new InvalidRequestException("row predicate must specify keys, key_range, or index_clause");
+    }
+
+    private List<KeySlice> scanIndexInternal(String keyspace, ColumnParent column_parent, IndexClause index_clause, SlicePredicate predicate, ConsistencyLevel consistency_level)
+    throws InvalidRequestException, TimedOutException
+    {
+        ThriftValidation.validateColumnParent(keyspace, column_parent);
+        ThriftValidation.validatePredicate(keyspace, column_parent, predicate);
+        ThriftValidation.validateIndexClauses(keyspace, column_parent.column_family, index_clause);
+
+        List<Row> rows = null;
+        try
+        {
+            rows = StorageProxy.scan(new IndexScanCommand(keyspace, column_parent.column_family, index_clause, predicate), consistency_level);
+        }
+        catch (IOException e)
+        {
+            throw new RuntimeException(e);
+        }
+        catch (TimeoutException e)
+        {
+            throw new TimedOutException();
+        }
+        return thriftifyKeySlices(rows, column_parent, predicate);
+    }
+
+    public List<KeyCount> scan_count(ColumnParent column_parent, RowPredicate row_predicate, SlicePredicate column_predicate, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
+    {
+        List<KeySlice> rows = scan(column_parent, row_predicate, column_predicate, consistency_level);
+        List<KeyCount> rowCounts = new ArrayList<KeyCount>(rows.size());
+        for (KeySlice slice : rows)
+        {
+            rowCounts.add(new KeyCount(slice.key, slice.columns.size()));
+        }
+        return rowCounts;
+    }
+
     public Set<String> describe_keyspaces() throws TException
     {
         return DatabaseDescriptor.getTables();
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/thrift/ThriftValidation.java b/cassandra/trunk/src/java/org/apache/cassandra/thrift/ThriftValidation.java
index 2ae5679f..eafc68b1 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/thrift/ThriftValidation.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/thrift/ThriftValidation.java
@@ -22,6 +22,7 @@
 
 import java.util.Arrays;
 import java.util.Comparator;
+import java.util.Set;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -370,4 +371,17 @@ public static void validateKeyRange(KeyRange range) throws InvalidRequestExcepti
             throw new InvalidRequestException("maxRows must be positive");
         }
     }
+
+    public static void validateIndexClauses(String keyspace, String columnFamily, IndexClause index_clause)
+    throws InvalidRequestException
+    {
+        if (index_clause.expressions.isEmpty())
+            throw new InvalidRequestException("index clause list may not be empty");
+        Set<byte[]> indexedColumns = Table.open(keyspace).getColumnFamilyStore(columnFamily).getIndexedColumns();
+        for (IndexExpression expression : index_clause.expressions)
+        {
+            if (!indexedColumns.contains(expression.column_name))
+                throw new InvalidRequestException("Unable to scan unindexed column");
+        }
+    }
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/utils/FBUtilities.java b/cassandra/trunk/src/java/org/apache/cassandra/utils/FBUtilities.java
index 61d60aad..32dcc699 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/utils/FBUtilities.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/utils/FBUtilities.java
@@ -511,4 +511,11 @@ public static String resourceToFile(String filename) throws ConfigurationExcepti
 
         return scpurl.getFile();
     }
+
+    public static long timestampMicros()
+    {
+        // we use microsecond resolution for compatibility with other client libraries, even though
+        // we can't actually get microsecond precision.
+        return System.currentTimeMillis() * 1000;
+    }
 }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
index 37104a5d..42eedab5 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
@@ -19,6 +19,7 @@
 package org.apache.cassandra.db;
 
 import java.io.IOException;
+import java.io.UnsupportedEncodingException;
 import java.util.*;
 import java.util.concurrent.ExecutionException;
 
@@ -31,6 +32,10 @@
 import org.apache.cassandra.Util;
 import org.apache.cassandra.db.filter.*;
 import org.apache.cassandra.service.StorageService;
+import org.apache.cassandra.thrift.IndexClause;
+import org.apache.cassandra.thrift.IndexExpression;
+import org.apache.cassandra.thrift.IndexOperator;
+import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.WrappedRunnable;
 
 import java.net.InetAddress;
@@ -159,6 +164,21 @@ public void testSkipStartKey() throws IOException, ExecutionException, Interrupt
         assert Arrays.equals(result.get(0).key.key, "key2".getBytes());
     }
 
+    @Test
+    public void testIndexScan() throws IOException
+    {
+        RowMutation rm;
+        rm = new RowMutation("Keyspace1", "k".getBytes());
+        rm.add(new QueryPath("Indexed1", null, "birthdate".getBytes("UTF8")), FBUtilities.toByteArray(1L), new TimestampClock(0));
+        rm.apply();
+
+        IndexExpression expr = new IndexExpression("birthdate".getBytes("UTF8"), IndexOperator.EQ, FBUtilities.toByteArray(1L));
+        IndexClause clause = new IndexClause(Arrays.asList(expr), 100);
+        IFilter filter = new IdentityQueryFilter();
+        List<Row> rows = Table.open("Keyspace1").getColumnFamilyStore("Indexed1").scan(clause, filter);
+        assert rows != null && rows.size() > 0;
+    }
+
     private ColumnFamilyStore insertKey1Key2() throws IOException, ExecutionException, InterruptedException
     {
         List<RowMutation> rms = new LinkedList<RowMutation>();
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
index 6e2537b5..f261d549 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
@@ -195,16 +195,17 @@ public void dropCf() throws ConfigurationException, IOException, ExecutionExcept
         
         // any write should fail.
         rm = new RowMutation(ks.name, dk.key);
+        boolean success = true;
         try
         {
             rm.add(new QueryPath("Standard1", null, "col0".getBytes()), "value0".getBytes(), new TimestampClock(1L));
             rm.apply();
-            assert false : "This mutation should have failed since the CF no longer exists.";
         }
         catch (Throwable th)
         {
-            assert th instanceof IllegalArgumentException;
+            success = false;
         }
+        assert !success : "This mutation should have failed since the CF no longer exists.";
         
         // verify that the files are gone.
         assert DefsTable.getFiles(cfm.tableName, cfm.cfName).size() == 0;
@@ -308,16 +309,17 @@ public void dropKS() throws ConfigurationException, IOException, ExecutionExcept
         
         // write should fail.
         rm = new RowMutation(ks.name, dk.key);
+        boolean success = true;
         try
         {
             rm.add(new QueryPath("Standard1", null, "col0".getBytes()), "value0".getBytes(), new TimestampClock(1L));
             rm.apply();
-            throw new AssertionError("This mutation should have failed since the CF no longer exists.");
         }
         catch (Throwable th)
         {
-            assert th instanceof IllegalArgumentException;
+            success = false;
         }
+        assert !success : "This mutation should have failed since the CF no longer exists.";
         
         // reads should fail too.
         try
@@ -375,16 +377,17 @@ public void renameKs() throws ConfigurationException, IOException, ExecutionExce
         
         // write on old should fail.
         rm = new RowMutation(oldKs.name, "any key will do".getBytes());
+        boolean success = true;
         try
         {
             rm.add(new QueryPath(cfName, null, "col0".getBytes()), "value0".getBytes(), new TimestampClock(1L));
             rm.apply();
-            throw new AssertionError("This mutation should have failed since the CF/Table no longer exists.");
         }
         catch (Throwable th)
         {
-            assert th instanceof IllegalArgumentException;
+            success = false;
         }
+        assert !success : "This mutation should have failed since the CF/Table no longer exists.";
         
         // write on new should work.
         rm = new RowMutation(newKsName, dk.key);
