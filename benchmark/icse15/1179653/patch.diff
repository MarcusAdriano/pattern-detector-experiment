diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/AlterTableConstantAction.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/AlterTableConstantAction.java
index 051243ca..d3d408ce 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/AlterTableConstantAction.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/AlterTableConstantAction.java
@@ -29,6 +29,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import java.util.Vector;
 
 import org.apache.derby.catalog.DefaultInfo;
+import org.apache.derby.catalog.Dependable;
 import org.apache.derby.catalog.DependableFinder;
 import org.apache.derby.catalog.IndexDescriptor;
 import org.apache.derby.catalog.UUID;
@@ -1672,49 +1673,6 @@ else if (referencedColsInTriggerAction[j] == droppedColumnPosition)
 		dd.addDescriptorArray(cdlArray, td,
 							  DataDictionary.SYSCOLUMNS_CATALOG_NUM, false, tc);
 
-		List deps = dd.getProvidersDescriptorList(td.getObjectID().toString());
-		for (Iterator depsIterator = deps.listIterator(); 
-             depsIterator.hasNext();)
-		{
-			DependencyDescriptor depDesc = 
-                (DependencyDescriptor) depsIterator.next();
-
-			DependableFinder finder = depDesc.getProviderFinder();
-			if (finder instanceof DDColumnDependableFinder)
-			{
-				DDColumnDependableFinder colFinder = 
-                    (DDColumnDependableFinder) finder;
-				FormatableBitSet oldColumnBitMap = 
-                    new FormatableBitSet(colFinder.getColumnBitMap());
-				FormatableBitSet newColumnBitMap = 
-                    new FormatableBitSet(oldColumnBitMap);
-				newColumnBitMap.clear();
-				int bitLen = oldColumnBitMap.getLength();
-				for (int i = 0; i < bitLen; i++)
-				{
-					if (i < droppedColumnPosition && oldColumnBitMap.isSet(i))
-						newColumnBitMap.set(i);
-					if (i > droppedColumnPosition && oldColumnBitMap.isSet(i))
-						newColumnBitMap.set(i - 1);
-				}
-				if (newColumnBitMap.equals(oldColumnBitMap))
-					continue;
-				dd.dropStoredDependency(depDesc, tc);
-				colFinder.setColumnBitMap(newColumnBitMap.getByteArray());
-				dd.addDescriptor(depDesc, null,
-								 DataDictionary.SYSDEPENDS_CATALOG_NUM,
-								 true, tc);
-			}
-		}
-		// Adjust the column permissions rows in SYSCOLPERMS to reflect the
-		// changed column positions due to the dropped column:
-		dd.updateSYSCOLPERMSforDropColumn(td.getUUID(), tc, columnDescriptor);
-
-        // remove column descriptor from table descriptor. this fixes up the
-        // list in case we were called recursively in order to cascade-drop a
-        // dependent generated column.
-        tab_cdl.remove( td.getColumnDescriptor( columnName ) );
-
         // By this time, the column has been removed from the table descriptor.
         // Now, go through all the triggers and regenerate their trigger action
         // SPS and rebind the generated trigger action sql. If the trigger  
@@ -1749,12 +1707,59 @@ else if (referencedColsInTriggerAction[j] == droppedColumnPosition)
         // rebind would have still found the column being dropped in the
         // table descriptor and hence use of such a column in the trigger
         // action rebind would not have been caught.
-		GenericDescriptorList tdlAfterColumnDrop = dd.getTriggerDescriptors(td);
-		Enumeration descsAfterColumnDrop = tdlAfterColumnDrop.elements();
-		while (descsAfterColumnDrop.hasMoreElements())
-		{
-			TriggerDescriptor trd = (TriggerDescriptor) descsAfterColumnDrop.nextElement();
-			dd.dropTriggerDescriptor(trd, tc);
+
+		//For the table on which ALTER TABLE is getting performed, find out
+		// all the SPSDescriptors that use that table as a provider. We are
+		// looking for SPSDescriptors that have been created internally for
+		// trigger action SPSes. Through those SPSDescriptors, we will be
+		// able to get to the triggers dependent on the table being altered
+		//Following will get all the dependent objects that are using
+		// ALTER TABLE table as provider
+		List depsOnAlterTableList = dd.getProvidersDescriptorList(td.getObjectID().toString());
+		for (Iterator depsOnAlterTableIterator = depsOnAlterTableList.listIterator(); 
+			depsOnAlterTableIterator.hasNext();)
+		{
+			//Go through all the dependent objects on the table being altered 
+			DependencyDescriptor depOnAlterTableDesc = 
+				(DependencyDescriptor) depsOnAlterTableIterator.next();
+			DependableFinder dependent = depOnAlterTableDesc.getDependentFinder();
+			//For the given dependent, we are only interested in it if it is a
+			// stored prepared statement.
+			if (dependent.getSQLObjectType().equals(Dependable.STORED_PREPARED_STATEMENT))
+			{
+				//Look for all the dependent objects that are using this 
+				// stored prepared statement as provider. We are only 
+				// interested in dependents that are triggers.
+				List depsTrigger = dd.getProvidersDescriptorList(depOnAlterTableDesc.getUUID().toString());
+				for (Iterator depsTriggerIterator = depsTrigger.listIterator();
+					depsTriggerIterator.hasNext();)
+				{
+					DependencyDescriptor depsTriggerDesc = 
+						(DependencyDescriptor) depsTriggerIterator.next();
+					DependableFinder providerIsTrigger = depsTriggerDesc.getDependentFinder();
+					//For the given dependent, we are only interested in it if
+					// it is a trigger
+					if (providerIsTrigger.getSQLObjectType().equals(Dependable.TRIGGER)) {
+						//Drop and recreate the trigger after regenerating 
+						// it's trigger action plan. If the trigger action
+						// depends on the column being dropped, it will be
+						// caught here.
+						TriggerDescriptor trdToBeDropped  = dd.getTriggerDescriptor(depsTriggerDesc.getUUID());
+						columnDroppedAndTriggerDependencies(trdToBeDropped,
+								cascade, columnName);
+					}
+				}
+			}
+		}
+		// Adjust the column permissions rows in SYSCOLPERMS to reflect the
+		// changed column positions due to the dropped column:
+		dd.updateSYSCOLPERMSforDropColumn(td.getUUID(), tc, columnDescriptor);
+
+        // remove column descriptor from table descriptor. this fixes up the
+        // list in case we were called recursively in order to cascade-drop a
+        // dependent generated column.
+        tab_cdl.remove( td.getColumnDescriptor( columnName ) );
+	}
 			
 			// For the trigger, get the trigger action sql provided by the user
 			// in the create trigger sql. This sql is saved in the system
@@ -1762,6 +1767,10 @@ else if (referencedColsInTriggerAction[j] == droppedColumnPosition)
 			// the trigger action sql may not be valid anymore. To establish
 			// that, we need to regenerate the internal representation of that 
 			// sql and bind it again.
+	private void columnDroppedAndTriggerDependencies(TriggerDescriptor trd,
+			boolean cascade, String columnName)
+	throws StandardException {
+		dd.dropTriggerDescriptor(trd, tc);
 
 			// Here we get the trigger action sql and use the parser to build
 			// the parse tree for it.
@@ -1839,7 +1848,44 @@ else if (referencedColsInTriggerAction[j] == droppedColumnPosition)
 				stmtnode.bindStatement();
 			} catch (StandardException se)
 			{
-				if (se.getMessageId().equals(SQLState.LANG_COLUMN_NOT_FOUND))
+			//Need to catch for few different kinds of sql states depending
+			// on what kind of trigger action sql is using the column being 
+			// dropped. Following are examples for different sql states
+			//
+			//SQLState.LANG_COLUMN_NOT_FOUND is thrown for following usage in
+			// trigger action sql of column being dropped atdc_12.b
+			//        create trigger atdc_12_trigger_1 after update 
+			//           of a on atdc_12 
+			//           for each row 
+			//           select a,b from atdc_12
+			//
+			//SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE is thrown for following
+			// usage in trigger action sql of column being dropped  
+			// atdc_14_tab2a2 with restrict clause
+			//        create trigger atdc_14_trigger_1 after update 
+			//           on atdc_14_tab1 REFERENCING NEW AS newt 
+			//           for each row 
+			//           update atdc_14_tab2 set a2 = newt.a1
+			//
+			// SQLState.LANG_DB2_INVALID_COLS_SPECIFIED is thrown for following
+			//  usage in trigger action sql of column being dropped  
+			//  ATDC_13_TAB1_BACKUP.c11 with restrict clause
+			//         create trigger ATDC_13_TAB1_trigger_1 after update
+			//           on ATDC_13_TAB1 for each row
+			//           INSERT INTO ATDC_13_TAB1_BACKUP
+			//           SELECT C31, C32 from ATDC_13_TAB3
+			//
+			//SQLState.LANG_TABLE_NOT_FOUND is thrown for following scenario
+			//   create view ATDC_13_VIEW2 as select c12 from ATDC_13_TAB3 where c12>0
+			//Has following trigger defined
+			//         create trigger ATDC_13_TAB1_trigger_3 after update
+			//           on ATDC_13_TAB1 for each row
+			//           SELECT * from ATDC_13_VIEW2
+			// Ane drop column ATDC_13_TAB3.c12 is issued
+			if (se.getMessageId().equals(SQLState.LANG_COLUMN_NOT_FOUND)||
+					(se.getMessageId().equals(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE) ||
+					(se.getMessageId().equals(SQLState.LANG_DB2_INVALID_COLS_SPECIFIED) ||
+					(se.getMessageId().equals(SQLState.LANG_TABLE_NOT_FOUND)))))
 				{
 					if (cascade)
 					{
@@ -1848,7 +1894,7 @@ else if (referencedColsInTriggerAction[j] == droppedColumnPosition)
 							StandardException.newWarning(
                                 SQLState.LANG_TRIGGER_DROPPED, 
                                 trd.getName(), td.getName()));
-						continue;
+					return;
 					}
 					else
 					{	// we'd better give an error if don't drop it,
@@ -1878,9 +1924,6 @@ else if (referencedColsInTriggerAction[j] == droppedColumnPosition)
 			dd.addDescriptor(trd, sd,
 					 DataDictionary.SYSTRIGGERS_CATALOG_NUM,
 					 false, tc);
-
-		}
-		
 	}
 
     private void modifyColumnType(int ix)
diff --git a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AlterTableTest.java b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AlterTableTest.java
index a684e6af..c0423b84 100644
--- a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AlterTableTest.java
+++ b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AlterTableTest.java
@@ -1860,6 +1860,188 @@ public void testAlterTableAndSysdepends() throws Exception {
         		numberOfRowsInSysdepends(st),sysdependsRowCountBeforeTestStart+5);
     }
 
+    //A test for ALTER TABLE DROP COLUMN with synonyms and trigger combination.
+    // Trigger uses synonym in it's trigger action and when a column is 
+    // dropped(in cascade mode), the trigger gets dropped because the synonym 
+    // in it's trigger action relied on that column.
+    public void testTriggersAndSynonyms() throws Exception {
+        Statement st = createStatement();
+        
+        st.executeUpdate("create table atdcSynonymTab_1 (c11 integer, c12 integer)");
+        st.executeUpdate("create table atdcSynonymTab_2 (c21 integer, c22 integer)");
+		st.executeUpdate("CREATE SYNONYM synonymTab2 FOR atdcSynonymTab_2");
+        st.executeUpdate(
+                "create trigger syn_tr1t1 after update of c11 on atdcSynonymTab_1 " +
+                "for each row mode db2sql " +
+                "insert into atdcSynonymTab_2(c21, c22) values(9,9)");
+
+        //Verify there is no data in tables before the start of the test
+        JDBC.assertEmpty(st.executeQuery(
+                " select * from atdcSynonymTab_1"));
+        JDBC.assertEmpty(st.executeQuery(
+                " select * from synonymTab2"));
+        st.executeUpdate(
+                " insert into atdcSynonymTab_1 values(11,12)");
+        //Followng will fire the trigger and insert a row in table on which
+        // there is a synonym defined
+        st.executeUpdate(
+                " update atdcSynonymTab_1 set c11=99");
+        //A new row in the table with synonym defined on it
+        JDBC.assertFullResultSet(
+        		st.executeQuery("select * from synonymTab2"),
+                new String[][]{{"9","9"}});
+        //delete data to get ready for next test which will attempt to do
+        // ALTER TABLE DROP COLUMN RESTRICT and fail because there is a
+        // trigger using the column being dropped
+        st.executeUpdate(
+                " delete from atdcSynonymTab_1");
+        st.executeUpdate(
+                " delete from synonymTab2");
+        
+        //Following will fail because there is a trigger using that 
+        // column
+        assertStatementError("X0Y25", st,
+                " alter table atdcSynonymTab_2 drop column c21 restrict");
+        //Run through the trigger firing test again to see that trigger is
+        // still intact
+        JDBC.assertEmpty(st.executeQuery(
+                " select * from atdcSynonymTab_1"));
+        JDBC.assertEmpty(st.executeQuery(
+                " select * from synonymTab2"));
+        st.executeUpdate(
+                " insert into atdcSynonymTab_1 values(11,12)");
+        //Followng will fire the trigger and insert a row in table on which
+        // there is a synonym defined
+        st.executeUpdate(
+                " update atdcSynonymTab_1 set c11=99");
+        //A new row in the table with synonym defined on it
+        JDBC.assertFullResultSet(
+        		st.executeQuery("select * from synonymTab2"),
+                new String[][]{{"9","9"}});
+        //delete data to get ready for next test which will attempt to do
+        // ALTER TABLE DROP COLUMN and will dropped the trigger using the 
+        // column being dropped
+        st.executeUpdate(
+                " delete from atdcSynonymTab_1");
+        st.executeUpdate(
+                " delete from synonymTab2");
+        
+        //Following will drop three triggers using the column being dropped
+        st.executeUpdate(
+                " alter table atdcSynonymTab_2 drop column c21");
+        //Run through the trigger firing test again and we will see the trigger
+        // is not there anymore since no new row gets inserted through the
+        // trigger
+        JDBC.assertEmpty(st.executeQuery(
+                " select * from atdcSynonymTab_1"));
+        JDBC.assertEmpty(st.executeQuery(
+                " select * from synonymTab2"));
+        st.executeUpdate(
+                " insert into atdcSynonymTab_1 values(11,12)");
+        st.executeUpdate(
+                " update atdcSynonymTab_1 set c11=99");
+        //Will still be empty because trigger which would have caused a row
+        // insertion got dropped as a result of ALTER TABLE DROP COLUMN
+        JDBC.assertEmpty(st.executeQuery(
+                " select * from synonymTab2"));
+    }
+
+    // Column being dropped is getting used in two triggers. A trigger defined
+    //  on the table whose column is getting dropped and a trigger defined on
+    //  another table but using the table whose column is getting dropped in
+    //  it's trigger action
+    public void testDropColumnTriggerDependency() throws Exception {
+        Statement st = createStatement();
+        createTestObjects(st);
+
+        st.executeUpdate("create table atdctd_1 (c11 integer, c12 integer)");
+        st.executeUpdate("create table atdctd_2 (c21 integer, c22 integer)");
+        st.executeUpdate("create table atdctd_3 (c31 integer, c32 integer)");
+
+        st.executeUpdate(
+                "create trigger tr1t1 after update of c11 on atdctd_1 " +
+                "for each row mode db2sql " +
+                "insert into atdctd_3(c31, c32) values(9,9)");
+
+        st.executeUpdate(
+                "create trigger tr1t2 after insert on atdctd_2 " +
+                "for each row mode db2sql " +
+                "insert into atdctd_3(c31, c32) " +
+                "select c11, c12 from atdctd_1");
+        st.executeUpdate(
+                "create trigger tr2t2 after insert on atdctd_2 " +
+                "for each row mode db2sql " +
+                "insert into atdctd_3(c31) " +
+                "select c11 from atdctd_1");
+
+        JDBC.assertEmpty(st.executeQuery(
+                " select * from atdctd_3"));
+        st.executeUpdate(
+                " insert into atdctd_1 values(11,12)");
+        st.executeUpdate(
+                " update atdctd_1 set c11=99");
+        JDBC.assertFullResultSet(
+        		st.executeQuery("select * from atdctd_3"),
+                new String[][]{{"9","9"}});
+        st.executeUpdate(
+                " insert into atdctd_2 values(21,22)");
+        JDBC.assertFullResultSet(
+        		st.executeQuery("select * from atdctd_3 order by c32"),
+                new String[][]{{"9","9"}, {"99","12"},{"99",null}});
+        st.executeUpdate(
+                " delete from atdctd_3");
+        st.executeUpdate(
+                " delete from atdctd_1");
+        st.executeUpdate(
+                " delete from atdctd_2");
+        
+        //Following will fail because there are three triggers using that 
+        // column
+        assertStatementError("X0Y25", st,
+                " alter table atdctd_1 drop column c11 restrict");
+        JDBC.assertEmpty(st.executeQuery(
+        		" select * from atdctd_3"));
+        st.executeUpdate(
+        		" insert into atdctd_1 values(11,12)");
+        st.executeUpdate(
+        		" update atdctd_1 set c11=99");
+        JDBC.assertFullResultSet(
+        		st.executeQuery("select * from atdctd_3"),
+                new String[][]{{"9","9"}});
+        st.executeUpdate(
+                " insert into atdctd_2 values(21,22)");
+        JDBC.assertFullResultSet(
+        		st.executeQuery("select * from atdctd_3 order by c32"),
+                new String[][]{{"9","9"}, {"99","12"},{"99",null}});
+        st.executeUpdate(
+                " delete from atdctd_3");
+        st.executeUpdate(
+                " delete from atdctd_1");
+        st.executeUpdate(
+                " delete from atdctd_2");
+        
+        //Following will drop three triggers using the column being dropped
+        st.executeUpdate(
+                " alter table atdctd_1 drop column c11");
+        JDBC.assertEmpty(st.executeQuery(
+                " select * from atdctd_3"));
+        st.executeUpdate(
+                " insert into atdctd_1 values(12)");
+        st.executeUpdate(
+                " update atdctd_1 set c12=99");
+        //Will still be empty because trigger which would have added a row into
+        // atdctd_3 got dropped as a result of ALTER TABLE DROP COLUMN earlier
+        JDBC.assertEmpty(st.executeQuery(
+                " select * from atdctd_3"));
+        st.executeUpdate(
+                " insert into atdctd_2 values(21,22)");
+        //Will still be empty because triggers which would have added a row 
+        // each into atdctd_3 got dropped as a result of ALTER TABLE DROP 
+        // COLUMN earlier
+        JDBC.assertEmpty(st.executeQuery(
+                " select * from atdctd_3"));
+    }
+
     // alter table tests for ALTER TABLE DROP COLUMN. The 
     // overall syntax is:    ALTER TABLE tablename DROP [ 
     // COLUMN ] columnname [ CASCADE | RESTRICT ]
@@ -2475,8 +2657,7 @@ public void testDropColumn() throws Exception {
         // Another test DERBY-5044
         //Following test case involves two tables. The trigger is defined 
         //on table 1 and it uses the column from table 2 in it's trigger  
-    	//action. This dependency of the trigger on a column from another 
-        //table is not detected by Derby.
+    	//action. 
         createTableAndInsertData(st, "ATDC_14_TAB1", "A1", "B1");
         createTableAndInsertData(st, "ATDC_14_TAB2", "A2", "B2");
         sysdependsRowCountBeforeCreateTrigger = numberOfRowsInSysdepends(st);
@@ -2487,42 +2668,73 @@ public void testDropColumn() throws Exception {
                 "update atdc_14_tab2 set a2 = newt.a1");
         sysdependsRowCountAfterCreateTrigger = numberOfRowsInSysdepends(st);
 
-        // following is not the right behavior. we should have gotten an error
-        // because column being dropped is getting used in a trigger action 
-        st.executeUpdate("alter table atdc_14_tab2 drop column a2 restrict");
+        assertStatementError("X0Y25", st,
+		"alter table atdc_14_tab2 drop column a2 restrict");
         triggersExist(st, new String[][]{{"ATDC_14_TRIGGER_1"}});
-        // following is wrong. 
-        Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
 
         //Now try ALTER TABLE DROP COLUMN CASCADE where the column being
         //dropped is in trigger action of trigger defined on a different table
-        st.executeUpdate("drop trigger atdc_14_trigger_1");
-        st.executeUpdate("drop table atdc_14_tab1");
-        st.executeUpdate("drop table atdc_14_tab2");
-        createTableAndInsertData(st, "ATDC_14_TAB1", "A1", "B1");
-        createTableAndInsertData(st, "ATDC_14_TAB2", "A2", "B2");
+        st.executeUpdate("alter table atdc_14_tab2 drop column a2");
+        checkWarning(st, "01502");
+        // the trigger will get dropped as a result of cascade
+        JDBC.assertEmpty(st.executeQuery(
+        		" select triggername from sys.systriggers where " +
+        		"triggername in ('ATDC_14_TRIGGER_1')"));
+        Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
+        		numberOfRowsInSysdepends(st),sysdependsRowCountBeforeCreateTrigger);
+        st.executeUpdate("drop table ATDC_14_TAB1");
+        st.executeUpdate("drop table ATDC_14_TAB2");
+
+        // Start of another test for DERBY-5044
+        createTableAndInsertData(st, "ATDC_13_TAB1", "C11", "C12");
+        createTableAndInsertData(st, "ATDC_13_TAB1_BACKUP", "C11", "C12");
+        createTableAndInsertData(st, "ATDC_13_TAB2", "C21", "C22");
+        createTableAndInsertData(st, "ATDC_13_TAB3", "C31", "C32");
         sysdependsRowCountBeforeCreateTrigger = numberOfRowsInSysdepends(st);
         st.executeUpdate(
-                " create trigger atdc_14_trigger_1 after update " +
-                "on atdc_14_tab1 REFERENCING NEW AS newt " +
-                "for each row " +
-                "update atdc_14_tab2 set a2 = newt.a1");
+                " create trigger ATDC_13_TAB1_trigger_1 after update " +
+                "on ATDC_13_TAB1 for each row " +
+                "INSERT INTO ATDC_13_TAB1_BACKUP " +
+                " SELECT C31, C32 from ATDC_13_TAB3");
+        st.executeUpdate(
+                " create trigger ATDC_13_TAB1_trigger_2 after update " +
+                "on ATDC_13_TAB1 for each row " +
+                "INSERT INTO ATDC_13_TAB1_BACKUP " +
+                " SELECT * from ATDC_13_TAB3");
+        countAfter2Triggers = numberOfRowsInSysdepends(st);
+        st.executeUpdate(
+                " create trigger ATDC_13_TAB1_trigger_3 after update " +
+                "on ATDC_13_TAB1 for each row " +
+                "INSERT INTO ATDC_13_TAB1_BACKUP VALUES(1,1)");
+        int countAfter3rdTrigger = numberOfRowsInSysdepends(st);
+        st.executeUpdate(
+                " create trigger ATDC_13_TAB1_trigger_4 after update " +
+                "on ATDC_13_TAB1 for each row " +
+                "INSERT INTO ATDC_13_TAB1_BACKUP(C11) " +
+                " SELECT C21 from ATDC_13_TAB2");
+        int countAfter4thTrigger = numberOfRowsInSysdepends(st);
         sysdependsRowCountAfterCreateTrigger = numberOfRowsInSysdepends(st);
+        Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
+        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
+        st.executeUpdate("update ATDC_13_TAB1 set c12=11");
+        Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
+        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
+        rs = st.executeQuery("select * from ATDC_13_TAB1_BACKUP ORDER BY C11, C12");
+        JDBC.assertFullResultSet(rs, new String[][]{
+        		{"1","1"}, {"1","11"}, {"1","11"}, {"1","11"}, {"1",null} });
+        st.executeUpdate("delete from ATDC_13_TAB1_BACKUP");
 
-        // following is not the right behavior. we should have dropped 
-        // trigger ATDC_14_TRIGGER_1 because of DROP COLUMN CASCADE
-        st.executeUpdate("alter table atdc_14_tab2 drop column a2");
-        rs =
-                st.executeQuery(
-                " select triggername from sys.systriggers where " +
-                "triggername = 'ATDC_14_TRIGGER_1' ");
-        JDBC.assertFullResultSet(rs, new String[][]{{"ATDC_14_TRIGGER_1"}});
-        // following is wrong. 
+        assertStatementError("X0Y25", st,
+		"alter table ATDC_13_TAB2 drop column c21 restrict");
+        triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
+            	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"},
+            	{"ATDC_13_TAB1_TRIGGER_4"}});
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
         		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
-        st.executeUpdate("drop table ATDC_14_TAB1");
-        st.executeUpdate("drop table ATDC_14_TAB2");
+        st.executeUpdate("drop table ATDC_13_TAB1_BACKUP");
+        st.executeUpdate("drop table ATDC_13_TAB1");
+        st.executeUpdate("drop table ATDC_13_TAB2");
+        st.executeUpdate("drop table ATDC_13_TAB3");
         
         // Start of another test for DERBY-5044. Test INSERT/DELETE/UPDATE
         // inside the trigger action from base tables
@@ -2556,67 +2768,46 @@ public void testDropColumn() throws Exception {
                 " SELECT C21 from ATDC_13_TAB2");
         countAfter4Triggers = numberOfRowsInSysdepends(st);
         sysdependsRowCountAfterCreateTrigger = numberOfRowsInSysdepends(st);
-/*
-        DERBY-5120
-        Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
         st.executeUpdate("update ATDC_13_TAB1 set c12=11");
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
         		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
         rs = st.executeQuery("select * from ATDC_13_TAB1_BACKUP ORDER BY C11, C12");
-        Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
         JDBC.assertFullResultSet(rs, new String[][]{
         		{"1","1"}, {"1","11"}, {"1","11"}, {"1","11"}, {"1",null} });
-        Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
         st.executeUpdate("delete from ATDC_13_TAB1_BACKUP");
-*/
-        // following is not the right behavior. we should have gotten an error
-        // because column being dropped is getting used in a trigger action 
-        st.executeUpdate("alter table ATDC_13_TAB2 drop column c21 restrict");
+        //We will get an error because column being dropped is getting used 
+        // in a trigger action 
+        assertStatementError("X0Y25", st,
+        		"alter table ATDC_13_TAB2 drop column c21 restrict");
         triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
             	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"},
             	{"ATDC_13_TAB1_TRIGGER_4"}});
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
         		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
-        // After DERBY-5044 is fixed, following won't be needed
-        st.executeUpdate("alter table ATDC_13_TAB2 add column c21 int");
         
-        // following is not the right behavior. we should have dropped 
-        // dependent triggers  
+        // We will drop the dependent triggers  
         st.executeUpdate("alter table ATDC_13_TAB2 drop column c21");
+        checkWarning(st, "01502");
         triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
-            	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"},
-            	{"ATDC_13_TAB1_TRIGGER_4"}});
+            	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"}});
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should reduce",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
+        		numberOfRowsInSysdepends(st),countAfter3Triggers);
         st.executeUpdate("alter table ATDC_13_TAB2 add column c21 int");
         
-        // following is not the right behavior. we should have gotten an error
-        // because column being dropped is getting used in a trigger action 
-        st.executeUpdate("alter table ATDC_13_TAB1_BACKUP drop column c11 restrict");
+        //We will get an error because column being dropped is getting used 
+        // in a trigger action 
+        assertStatementError("X0Y25", st,
+        		"alter table ATDC_13_TAB1_BACKUP drop column c11 restrict");
         triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
-            	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"},
-            	{"ATDC_13_TAB1_TRIGGER_4"}});
+            	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"}});
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
-        // After DERBY-5044 is fixed, following won't be needed
-        st.executeUpdate("alter table ATDC_13_TAB1_BACKUP add column c11 int");
-        // following is not the right behavior. we should have gotten an error
-        // because column being dropped is getting used in a trigger action 
+        		numberOfRowsInSysdepends(st),countAfter3Triggers);
+        
+        // We will drop the dependent triggers  
         st.executeUpdate("alter table ATDC_13_TAB1_BACKUP drop column c11");
-        triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
-            	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"},
-            	{"ATDC_13_TAB1_TRIGGER_4"}});
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
+        		numberOfRowsInSysdepends(st),sysdependsRowCountBeforeCreateTrigger);
         st.executeUpdate("alter table ATDC_13_TAB1_BACKUP add column c11 int");
-        //Done testing triggers with trigger action doing INSERT
-        st.executeUpdate("drop trigger ATDC_13_TAB1_TRIGGER_1");
-        st.executeUpdate("drop trigger ATDC_13_TAB1_TRIGGER_2");
-        st.executeUpdate("drop trigger ATDC_13_TAB1_TRIGGER_3");
-        st.executeUpdate("drop trigger ATDC_13_TAB1_TRIGGER_4");
         
         //Test triggers with trigger action doing UPDATE
         sysdependsRowCountBeforeCreateTrigger = numberOfRowsInSysdepends(st);
@@ -2639,75 +2830,47 @@ public void testDropColumn() throws Exception {
         countAfter3Triggers = numberOfRowsInSysdepends(st);
         sysdependsRowCountAfterCreateTrigger = numberOfRowsInSysdepends(st);
 
-        // following is not the right behavior. we should have gotten an error
-        // because column being dropped is getting used in a trigger action 
-        st.executeUpdate("alter table ATDC_13_TAB3 drop column c31 restrict");
+        assertStatementError("X0Y25", st,
+        		"alter table ATDC_13_TAB3 drop column c31 restrict");
         triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
             	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"}});
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
         		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
-        // After DERBY-5044 is fixed, following won't be needed
-        st.executeUpdate("alter table ATDC_13_TAB3 add column c31 int");
         
-        // following is not the right behavior. we should have dropped 
-        // dependent triggers  
+        // We will drop the dependent trigger
         st.executeUpdate("alter table ATDC_13_TAB3 drop column c31");
         triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
-            	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"}});
-        // DERBY-5044 The row count in systriggers should  have been 
-        // countAfter2Triggers
+            	{"ATDC_13_TAB1_TRIGGER_2"}});
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should reduce",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
+        		numberOfRowsInSysdepends(st),countAfter2Triggers);
         // After DERBY-5044 is fixed, following should be rewritten
         st.executeUpdate("alter table ATDC_13_TAB3 add column c31 int");
 
-        // following is not the right behavior. we should have gotten an error
-        // because column being dropped is getting used in a trigger action 
-        st.executeUpdate("alter table ATDC_13_TAB2 drop column c21 restrict");
+        assertStatementError("X0Y25", st,
+        		"alter table ATDC_13_TAB2 drop column c21 restrict");
         triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
-            	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"}});
+            	{"ATDC_13_TAB1_TRIGGER_2"}});
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
-        // After DERBY-5044 is fixed, following won't be needed
-        st.executeUpdate("alter table ATDC_13_TAB2 add column c21 int");
+        		numberOfRowsInSysdepends(st),countAfter2Triggers);
         
-        // following is not the right behavior. we should have dropped 
-        // dependent triggers  
+        // We will drop the dependent trigger
         st.executeUpdate("alter table ATDC_13_TAB2 drop column c21");
-        triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
-            	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"}});
-        // DERBY-5044 The row count in systriggers should  have been 
-        // countAfter1Trigger
+        triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"}});
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should reduce",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
-        // After DERBY-5044 is fixed, following should be rewritten
-        st.executeUpdate("alter table ATDC_13_TAB2 add column c21 int");
+        		numberOfRowsInSysdepends(st),countAfter1Trigger);
 
-        // following is not the right behavior. we should have gotten an error
-        // because column being dropped is getting used in a trigger action 
-        st.executeUpdate("alter table ATDC_13_TAB1_BACKUP drop column c12 restrict");
-        triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
-            	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"}});
+        assertStatementError("X0Y25", st,
+        		"alter table ATDC_13_TAB1_BACKUP drop column c12 restrict");
+        triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"}});
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
-        // After DERBY-5044 is fixed, following won't be needed
-        st.executeUpdate("alter table ATDC_13_TAB1_BACKUP add column c12 int");
+        		numberOfRowsInSysdepends(st),countAfter1Trigger);
         
-        // following is not the right behavior. we should have dropped 
-        // dependent triggers  
+        // We will drop the dependent trigger
         st.executeUpdate("alter table ATDC_13_TAB1_BACKUP drop column c12");
-        triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
-            	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"}});
-        // DERBY-5044 The row count in systriggers should  have been 
-        // countAfter1Trigger
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should reduce",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
+        		numberOfRowsInSysdepends(st),sysdependsRowCountBeforeCreateTrigger);
         // After DERBY-5044 is fixed, following should be rewritten
         st.executeUpdate("alter table ATDC_13_TAB1_BACKUP add column c12 int");
-        //Done testing triggers with trigger action doing UPDATE
-        st.executeUpdate("drop trigger ATDC_13_TAB1_TRIGGER_1");
-        st.executeUpdate("drop trigger ATDC_13_TAB1_TRIGGER_2");
-        st.executeUpdate("drop trigger ATDC_13_TAB1_TRIGGER_3");
 
         //Test triggers with trigger action doing DELETE
         sysdependsRowCountBeforeCreateTrigger = numberOfRowsInSysdepends(st);
@@ -2725,54 +2888,29 @@ public void testDropColumn() throws Exception {
         countAfter2Triggers = numberOfRowsInSysdepends(st);
         sysdependsRowCountAfterCreateTrigger = numberOfRowsInSysdepends(st);
 
-        // following is not the right behavior. we should have gotten an error
-        // because column being dropped is getting used in a trigger action 
-        st.executeUpdate("alter table ATDC_13_TAB3 drop column c32 restrict");
+        assertStatementError("X0Y25", st,
+        		"alter table ATDC_13_TAB3 drop column c32 restrict");
         triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
             	{"ATDC_13_TAB1_TRIGGER_2"}});
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
         		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
-        // After DERBY-5044 is fixed, following won't be needed
-        st.executeUpdate("alter table ATDC_13_TAB3 add column c32 int");
         
-        // following is not the right behavior. we should have dropped 
-        // dependent triggers  
+        // We will drop the dependent trigger
         st.executeUpdate("alter table ATDC_13_TAB3 drop column c32");
-        triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
-            	{"ATDC_13_TAB1_TRIGGER_2"}});
-        // DERBY-5044 The row count in systriggers should  have been 
-        // countAfter1Trigger
+        triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"}});
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should reduce",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
-        // After DERBY-5044 is fixed, following should be rewritten
-        st.executeUpdate("alter table ATDC_13_TAB3 add column c32 int");
+        		numberOfRowsInSysdepends(st),countAfter1Trigger);
 
-        // following is not the right behavior. we should have gotten an error
-        // because column being dropped is getting used in a trigger action 
-        st.executeUpdate("alter table ATDC_13_TAB1_BACKUP drop column c12 restrict");
-        triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
-            	{"ATDC_13_TAB1_TRIGGER_2"}});
+        assertStatementError("X0Y25", st,
+        		"alter table ATDC_13_TAB1_BACKUP drop column c12 restrict");
+        triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"}});
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
-        // After DERBY-5044 is fixed, following won't be needed
-        st.executeUpdate("alter table ATDC_13_TAB1_BACKUP add column c12 int");
+        		numberOfRowsInSysdepends(st),countAfter1Trigger);
         
-        // following is not the right behavior. we should have dropped 
-        // dependent triggers  
+        // We will drop the dependent trigger
         st.executeUpdate("alter table ATDC_13_TAB1_BACKUP drop column c12");
-        triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
-            	{"ATDC_13_TAB1_TRIGGER_2"}});
-        // DERBY-5044 The row count in systriggers should  have been 
-        // countAfter1Trigger
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should reduce",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
-        // After DERBY-5044 is fixed, following should be rewritten
-        st.executeUpdate("alter table ATDC_13_TAB1_BACKUP add column c12 int");
-
-        //Done testing triggers with trigger action doing DELETE
-        st.executeUpdate("drop trigger ATDC_13_TAB1_TRIGGER_1");
-        st.executeUpdate("drop trigger ATDC_13_TAB1_TRIGGER_2");
-
+        		numberOfRowsInSysdepends(st),sysdependsRowCountBeforeCreateTrigger);
         st.executeUpdate("drop table ATDC_13_TAB1");
         st.executeUpdate("drop table ATDC_13_TAB1_BACKUP");
         st.executeUpdate("drop table ATDC_13_TAB2");
@@ -2786,12 +2924,14 @@ public void testDropColumn() throws Exception {
         createTableAndInsertData(st, "ATDC_13_TAB1", "C11", "C12");
         createTableAndInsertData(st, "ATDC_13_TAB2", "C11", "C12");
         createTableAndInsertData(st, "ATDC_13_TAB3", "C11", "C12");
+        
         st.executeUpdate("create view ATDC_13_VIEW1 as " +
         		"select c11 from ATDC_13_TAB2");
-        st.executeUpdate("create view ATDC_13_VIEW2 as " +
-        		"select c12 from ATDC_13_TAB3 where c12>0");
         st.executeUpdate("create view ATDC_13_VIEW3 as " +
 		"select * from ATDC_13_TAB2");
+        st.executeUpdate("create view ATDC_13_VIEW2 as " +
+        		"select c12 from ATDC_13_TAB3 where c12>0");
+        
         //Test triggers with trigger action using views
         sysdependsRowCountBeforeCreateTrigger = numberOfRowsInSysdepends(st);
         st.executeUpdate(
@@ -2802,12 +2942,12 @@ public void testDropColumn() throws Exception {
         st.executeUpdate(
                 " create trigger ATDC_13_TAB1_trigger_2 after update " +
                 "on ATDC_13_TAB1 for each row " +
-                "SELECT * from ATDC_13_VIEW2 ");
+                "SELECT * from ATDC_13_VIEW3");
         countAfter2Triggers = numberOfRowsInSysdepends(st);
         st.executeUpdate(
                 " create trigger ATDC_13_TAB1_trigger_3 after update " +
                 "on ATDC_13_TAB1 for each row " +
-                "SELECT * from ATDC_13_VIEW3");
+                "SELECT * from ATDC_13_VIEW2 ");
         countAfter3Triggers = numberOfRowsInSysdepends(st);
         sysdependsRowCountAfterCreateTrigger = numberOfRowsInSysdepends(st);
 
@@ -2819,43 +2959,32 @@ public void testDropColumn() throws Exception {
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
         		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
         
-        // following is not the right behavior. we should have dropped 
-        // dependent triggers while dropping dependent view
         st.executeUpdate("alter table ATDC_13_TAB3 drop column c12");
         triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
-            	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"}});
+            	{"ATDC_13_TAB1_TRIGGER_2"}});
         // One row from sysdepends got dropped because of a view getting
-        // dropped
-        sysdependsRowCountAfterCreateTrigger = sysdependsRowCountAfterCreateTrigger-1;
+        // dropped and that is why we are checking for countAfter2Triggers-1
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should reduce",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
-        // After DERBY-5044 is fixed, following should be rewritten
-        st.executeUpdate("alter table ATDC_13_TAB3 add column c32 int");
+        		numberOfRowsInSysdepends(st),countAfter2Triggers-1);
 
-        // DROP COLUMN RESTRICT fails because there is a view using the column
+        // DROP COLUMN RESTRICT fails as there are 2 views using the column
         assertStatementError("X0Y23", st,
 		"alter table ATDC_13_TAB2 drop column c11 restrict");
         triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
-            	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"}});
+            	{"ATDC_13_TAB1_TRIGGER_2"}});
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should not change",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
+        		numberOfRowsInSysdepends(st),countAfter2Triggers-1);
         
-        // following is not the right behavior. we should have dropped 
-        // dependent triggers while dropping dependent view
+        // We have dropped dependent triggers while dropping dependent view
         st.executeUpdate("alter table ATDC_13_TAB2 drop column c11");
-        triggersExist(st, new String[][]{{"ATDC_13_TAB1_TRIGGER_1"},
-            	{"ATDC_13_TAB1_TRIGGER_2"}, {"ATDC_13_TAB1_TRIGGER_3"}});
         // Two rows from sysdepends got dropped because of 2 views getting
-        // dropped
-        sysdependsRowCountAfterCreateTrigger = sysdependsRowCountAfterCreateTrigger-2;
-        // DERBY-5044 The row count in systriggers should  have been 
-        // countAfter1Trigger
+        // dropped from the drop column c11 from ATDC_13_TAB2. Additionally,
+        // another view was dropped from drop of c12 from ATDC_13_TAB3.
+        // So 3 dependencies altogether got lost from sysdepends in
+        // addition to the dependencies that triggers had required.
         Assert.assertEquals("# of rows in SYS.SYSDEPENDS should reduce",
-        		numberOfRowsInSysdepends(st),sysdependsRowCountAfterCreateTrigger);
-        // After DERBY-5044 is fixed, following should be rewritten
-        st.executeUpdate("alter table ATDC_13_TAB2 add column c11 int");
+        		numberOfRowsInSysdepends(st),sysdependsRowCountBeforeCreateTrigger-3);
 
-        st.executeUpdate("drop trigger ATDC_13_TAB1_TRIGGER_1");
         st.executeUpdate("drop table ATDC_13_TAB1");
         st.executeUpdate("drop table ATDC_13_TAB2");
         st.executeUpdate("drop table ATDC_13_TAB3");
diff --git a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/GrantRevokeDDLTest.java b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/GrantRevokeDDLTest.java
index d6fa1863..1ad6ea68 100644
--- a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/GrantRevokeDDLTest.java
+++ b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/GrantRevokeDDLTest.java
@@ -10362,4 +10362,205 @@ public void test_derby_4502() throws Exception
         st_mamta1.execute("drop schema mamta1 restrict");
     }
     
+    // DERBY-5044 During alter table drop column, we recompile all the 
+    //  dependent trigger's action plans to see if they are dependent
+    //  on the column being dropped. The database may have been created
+    //  with authorization on and hence different actions might require
+    //  relevant privileges. This test will ensure that during the
+    //  recompile of trigger action, we will not loose the privilege
+    //  requirements for the triggers
+    public void testAlterTablePrivilegesIntace() throws Exception {
+        Statement st = createStatement();
+        ResultSet rs = null;
+        
+        Connection user1Connection = openUserConnection("user1");
+        Statement st_user1Connection = user1Connection.createStatement();
+        
+        st = createStatement();
+        
+        st_user1Connection.executeUpdate(
+        		"create table user1.t11 (c111 int, c112 int, c113 int)");
+        st_user1Connection.executeUpdate(
+        		"create table user1.t12 (c121 int, c122 int)");
+        st_user1Connection.executeUpdate(
+        		"create table user1.t13 (c131 int, c132 int)");        
+        st_user1Connection.executeUpdate(
+                " insert into user1.t11 values(1,2,3)");
+        st_user1Connection.executeUpdate(
+                " grant trigger on user1.t12 to user2");
+        st_user1Connection.executeUpdate(
+                " grant update(c112, c113) on user1.t11 to user2");
+        st_user1Connection.executeUpdate(
+                " grant select on user1.t11 to user2");
+        st_user1Connection.executeUpdate(
+                " grant insert on user1.t13 to user2");
+
+        Connection user2Connection = openUserConnection("user2");
+        Statement st_user2Connection = user2Connection.createStatement();
+        st_user2Connection.executeUpdate(
+                "create trigger tr1t12 after insert on user1.t12 " +
+                "for each row mode db2sql " +
+                "update user1.t11 set c112=222");
+        st_user2Connection.executeUpdate(
+                "create trigger tr2t12 after insert on user1.t12 " +
+                "for each row mode db2sql " +
+                "insert into user1.t13(c131, c132) " +
+                "select c111, c113 from user1.t11");
+
+        JDBC.assertFullResultSet(
+        		st_user1Connection.executeQuery(" select * from user1.t11"),
+                new String[][]{{"1","2","3"}});
+        JDBC.assertEmpty(st_user1Connection.executeQuery(
+                " select * from user1.t13"));
+		st_user1Connection.executeUpdate(" insert into user1.t12 values(91,91)");
+        JDBC.assertFullResultSet(
+        		st_user1Connection.executeQuery(" select * from user1.t11"),
+                new String[][]{{"1","222","3"}});
+        JDBC.assertFullResultSet(
+        		st_user1Connection.executeQuery(" select * from user1.t13"),
+                new String[][]{{"1","3"}});
+        st_user1Connection.executeUpdate(
+                "delete from user1.t11");        
+        st_user1Connection.executeUpdate(
+                "delete from user1.t13");        
+        st_user1Connection.executeUpdate(
+                " insert into user1.t11 values(1,2,3)");
+  
+        assertStatementError("X0Y25", st_user1Connection,
+                "alter table t11 drop column c112 restrict");
+        JDBC.assertFullResultSet(
+        		st_user1Connection.executeQuery(" select * from user1.t11"),
+                new String[][]{{"1","2","3"}});
+        JDBC.assertEmpty(st_user1Connection.executeQuery(
+                " select * from user1.t13"));
+		st_user1Connection.executeUpdate(" insert into user1.t12 values(92,92)");
+        JDBC.assertFullResultSet(
+        		st_user1Connection.executeQuery(" select * from user1.t11"),
+                new String[][]{{"1","222","3"}});
+        JDBC.assertFullResultSet(
+        		st_user1Connection.executeQuery(" select * from user1.t13"),
+                new String[][]{{"1","3"}});
+        st_user1Connection.executeUpdate(
+                "delete from user1.t11");        
+        st_user1Connection.executeUpdate(
+                "delete from user1.t13");        
+        st_user1Connection.executeUpdate(
+                " insert into user1.t11 values(1,2,3)");
+        
+        st_user1Connection.executeUpdate("alter table t11 drop column c112");
+        JDBC.assertFullResultSet(
+        		st_user1Connection.executeQuery(" select * from user1.t11"),
+                new String[][]{{"1","3"}});
+        JDBC.assertEmpty(st_user1Connection.executeQuery(
+                " select * from user1.t13"));
+		st_user1Connection.executeUpdate(" insert into user1.t12 values(93,93)");
+        JDBC.assertFullResultSet(
+        		st_user1Connection.executeQuery(" select * from user1.t11"),
+                new String[][]{{"1","3"}});
+        JDBC.assertFullResultSet(
+        		st_user1Connection.executeQuery(" select * from user1.t13"),
+                new String[][]{{"1","3"}});
+        st_user1Connection.executeUpdate(
+                "delete from user1.t11");        
+        st_user1Connection.executeUpdate(
+                "delete from user1.t13");        
+        st_user1Connection.executeUpdate(
+                " insert into user1.t11 values(1,3)");
+        
+        st_user1Connection.executeUpdate(
+        		"revoke insert on table user1.t13 from user2");
+        JDBC.assertFullResultSet(
+        		st_user1Connection.executeQuery(" select * from user1.t11"),
+                new String[][]{{"1","3"}});
+        JDBC.assertEmpty(st_user1Connection.executeQuery(
+                " select * from user1.t13"));
+		st_user1Connection.executeUpdate(" insert into user1.t12 values(94,94)");
+        JDBC.assertFullResultSet(
+        		st_user1Connection.executeQuery(" select * from user1.t11"),
+                new String[][]{{"1","3"}});
+        JDBC.assertEmpty(st_user1Connection.executeQuery(
+        		" select * from user1.t13"));
+        st_user1Connection.executeUpdate(
+        		"drop table user1.t11");
+        st_user1Connection.executeUpdate(
+        		"drop table user1.t12");
+        st_user1Connection.executeUpdate(
+        		"drop table user1.t13");
+    }
+
+    // DERBY-5044 During alter table drop column, we recompile all the 
+    //  dependent trigger's action plans to see if they are dependent
+    //  on the column being dropped. Some of these triggers may have
+    //  been created by a user different than one doing the alter table.
+    //  The test below shows that we are able to handle such a case
+    //  and able to detect trigger dependencies even if they are created
+    //  by a different user
+    public void testAlterTableWithPrivileges() throws Exception {
+        Statement st = createStatement();
+        ResultSet rs = null;
+        
+        Connection user1Connection = openUserConnection("user1");
+        Statement st_user1Connection = user1Connection.createStatement();
+        
+        st = createStatement();
+        
+        st_user1Connection.executeUpdate(
+        		"create table user1.t11 (c111 int, c112 int)");
+        st_user1Connection.executeUpdate(
+        		"create table user1.t12 (c121 int, c122 int)");
+        
+        Connection user2Connection = openUserConnection("user2");
+        Statement st_user2Connection = user2Connection.createStatement();
+  
+        // following create trigger fails because it is getting created on 
+        //  non-granted object
+        assertStatementError("42500", st_user2Connection,
+            "create trigger tr1t12 after insert on user1.t12 for each row " +
+            "mode db2sql insert into user1.t11(c112) values (1)");
+        
+        st_user1Connection.executeUpdate(
+        		" grant insert on user1.t11 to user2");
+        st_user1Connection.executeUpdate(
+        		" grant trigger on user1.t12 to user2");
+        
+        // following create trigger should pass because user2 now has necessary
+        //  privileges
+        st_user2Connection.executeUpdate(
+                "create trigger tr1t12 after insert on user1.t12 " +
+                "for each row mode db2sql " +
+                "insert into user1.t11(c112) values (1)");
+        
+        st_user1Connection.executeUpdate(
+                " insert into user1.t12 values(91,91)");
+        JDBC.assertFullResultSet(
+        		st_user1Connection.executeQuery(" select * from user1.t11"),
+                new String[][]{{null, "1"}});
+        
+        // following should fail because there is a dependent trigger on 
+        //  t11.c112 and drop column is getting done in restrict mode
+        assertStatementError("X0Y25", st_user1Connection,
+                "alter table t11 drop column c112 restrict");
+        st_user1Connection.executeUpdate(
+                " insert into user1.t12 values(92,92)");
+        JDBC.assertFullResultSet(
+                st_user1Connection.executeQuery(" select * from user1.t11"),
+                new String[][]{{null, "1"}, {null,"1"}});
+        // following should pass because drop column is getting done in 
+        //  cascade mode and so the dependent trigger will be dropped
+        st_user1Connection.executeUpdate(
+                "alter table t11 drop column c112");        
+        //No new row will be inserted into user1.t11 because the trigger has
+        //  been dropped
+        st_user1Connection.executeUpdate(
+                " insert into user1.t12 values(93,93)");
+        JDBC.assertFullResultSet(
+        		st_user1Connection.executeQuery(" select * from user1.t11"),
+                new String[][]{{null}, {null}});
+        st_user1Connection.executeUpdate(
+                "drop table user1.t11");
+        st_user1Connection.executeUpdate(
+                "drop table user1.t12");
+    }
+
+    
 }
diff --git a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/BasicSetup.java b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/BasicSetup.java
index 8b6c569f..ac491443 100644
--- a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/BasicSetup.java
+++ b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/BasicSetup.java
@@ -456,11 +456,11 @@ public void testDERBY5120NumRowsInSydependsForTrigger() throws Exception
 
         case PH_SOFT_UPGRADE:
         case PH_HARD_UPGRADE:
-        	//During soft/hard upgrade, the sps regeneration in 10.9 has 
-        	// been fixed and hence we won't loose the dependency between 
-        	// trigger action sps and trigger table. During upgrade process, 
-        	// all the spses get marked invalid and hence they will be 
-        	// regenerated during the next time they get fired.
+        	//During soft/hard upgrade, the sps regeneration has been 
+        	// fixed and hence we won't loose the dependency between 
+        	// trigger action sps and trigger table. During upgrade 
+        	// process, all the spses get marked invalid and hence they 
+        	// will be regenerated during the next time they get fired.
             assertStatementError("42802", s, " update ATDC_TAB1 set c11=2");
         	break;
         	
@@ -500,6 +500,353 @@ private int numberOfRowsInSysdepends(Statement st)
     	return(rs.getInt(1));
     }
     
+    /**
+     * Following test is for checking the upgrade scenario for DERBY-5044
+     *  and DERBY-5120.
+     */
+    public void testDERBY5044_And_DERBY5120_DropColumn() throws Exception {
+    	// ALTER TABLE DROP COLUMN was introduced in 10.3 so no point running
+    	// this test with earlier releases
+    	if (!oldAtLeast(10, 3)) return;
+
+        //During the upgrade time, the clearing of stored statements(including 
+        // trigger action spses) happened conditionally before DERBY-4835 was 
+        // fixed. DERBY-4835 made changes so that the stored statements get 
+        // marked invalid unconditionally during the upgrade phase. But these
+        // changes for DERBY-4835 did not make into 10.5.1.1, 10.5.3.0, 
+        // 10.6.1.0 and 10.6.2.1. Because of this missing fix, trigger 
+        // action spses do not get marked invalid when the database is taken 
+        // after soft upgrade back to the original db release(if the original 
+        // db release is one of the releases mentioned above). Following test 
+        // relies on trigger action spses getting invalid during upgrade phase 
+        // and getting recompiled when they are fired next time around thus 
+        // altering the number of rows in sysdepends. Because of this, I have
+        // disabled this test for those 4 releases.
+        if (oldIs(10,5,1,1) || oldIs(10,5,3,0) ||
+        	oldIs(10,6,1,0) || oldIs(10,6,2,1))
+            		return;
+    
+    	Statement s = createStatement();
+    	ResultSet rs;
+        
+        switch ( getPhase() )
+        {
+        case PH_SOFT_UPGRADE:
+        case PH_HARD_UPGRADE:
+        case PH_POST_HARD_UPGRADE:
+        case PH_POST_SOFT_UPGRADE:
+        	//Run the results on the data setup by the earlier upgrade phase.
+        	// For the CREATE phase, we won't do this because CREATE is the
+        	// first phase and hence there won't be any data setup already.
+        	//For all the other phases, we want to know how the change in
+        	// phase affects the behavior of ALTER TABLE DROP COLUMN
+            dropColumn_triggersql_DERBY5044_And_DERBY5120(s);
+            //After the above testing, go to the following code where we
+            // set up the data all over again in the current phase and see
+            // how ALTER TABLE DROP COLUMN behaves.
+        case PH_CREATE: 
+            //Repeat the whole test in soft upgrade mode. It will work fine
+            // because both DERBY-5120 and DERBY-5044 are fixed. As a result,
+            // ALTER TABLE DROP COLUMN will detect dependency of TAB1_TRG1 
+            // on column getting dropped and hence will drop trigger 
+            // TAB1_TRG1.
+        	//Setup data for the test
+        	preapreForDERBY5044_And_DERBY5120();
+           	//Execute a sql which will fire the relevant triggers. 
+            triggersql_for_DERBY5044_And_DERBY5120(s);
+            dropColumn_triggersql_DERBY5044_And_DERBY5120(s);
+
+            //Recreate the test data so we can test ALTER TABLE DROP COLUMN
+            // behavior in the next phase for the data setup by this phase.
+            preapreForDERBY5044_And_DERBY5120();
+        	triggersql_for_DERBY5044_And_DERBY5120(s);
+
+        	//Now, take this data to the next upgrade phase and check
+            // ALTER TABLE DROP COLUMN behavior
+            break;
+        }
+    }
+
+    //Test for combination of DERBY-5120 and DERBY-5044. ALTER TABLE DROP 
+    // COLUMN will detect the trigger dependency in this test only in a 
+    // release with both DERBY-5120 and DERBY-5044 fixes.
+    private void dropColumn_triggersql_DERBY5044_And_DERBY5120(
+    		Statement s) throws Exception
+    {
+    	ResultSet rs;
+
+    	//If we are in soft/hard/post-hard upgrade mode, then ALTER TABLE
+    	// DROP COLUMN will find out that trigger TAB1_TRG1 is dependent 
+    	// on the column being dropped. But this won't be detected in 
+    	// create/post-softupgrade modes because of missing fixes for
+    	// DERBY-5120 and DERBY-5044.
+        switch ( getPhase() )
+        {
+        case PH_CREATE: 
+        case PH_POST_SOFT_UPGRADE:
+        	//For the CREATE and PH_POST_SOFT_UPGRADE upgrade phases, 
+        	// ALTER TABLE DROP COLUMN will not detect that trigger 
+        	// TAB1_TRG1 depends on the column being dropped. This is 
+        	// because of DERBY-5120 and DERBY-5044
+        	s.executeUpdate("alter table BKUP1_5044_5120 drop column c112");
+            //Since ALTER TABLE DROP COLUMN did not drop dependent trigger,
+            // following UPDATE sql will fail because trigger TAB1_TRG1 will
+        	// get fired. Trigger TAB1_TRG1 will fail because it is expecting 
+            // more column in BKUP1_5044_5120 than are actually available
+            assertStatementError("42802", s, " update TAB1_5044_5120 set c11=999");
+            //Confirm the behavior mentioned by looking at the table data
+        	rs = s.executeQuery("select * from TAB1_5044_5120");
+            JDBC.assertFullResultSet(rs,
+               		new String[][]{{"99","11"}});        		
+            //No row in BKUP1_5044_5120 because update failed
+        	rs = s.executeQuery("select * from BKUP1_5044_5120");
+            JDBC.assertEmpty(rs);
+        	break;
+
+        case PH_SOFT_UPGRADE:
+        case PH_HARD_UPGRADE:
+        case PH_POST_HARD_UPGRADE:
+        	//Because both DERBY-5120 and DERBY-5044 are fixed, following 
+        	// will drop trigger TAB1_TRG1 which is dependent on the column 
+        	// being dropped.
+            s.executeUpdate("alter table BKUP1_5044_5120 drop column c112");
+            //Following triggering sql will not fail because trigger TAB1_TRG1
+            // doesn't exist anymore
+        	s.executeUpdate("update TAB1_5044_5120 set c11=999");
+            //Confirm the behavior mentioned by looking at the table data
+        	rs = s.executeQuery("select * from TAB1_5044_5120");
+            JDBC.assertFullResultSet(rs,
+               		new String[][]{{"999","11"}});        		
+            //No row in BKUP1_5044_5120 because trigger which insetts data in
+            // this table got dropped as a result of ALTER TABLE DROP COLUMN
+        	rs = s.executeQuery("select * from BKUP1_5044_5120");
+            JDBC.assertEmpty(rs);
+            break;
+        }
+    }
+
+    //Prepare tables and data for DERBY-5120 and DERBY-5044
+    private void preapreForDERBY5044_And_DERBY5120() throws Exception
+    {
+        Statement s = createStatement();
+        boolean modeDb2SqlOptional = oldAtLeast(10, 3);
+
+        dropTable("BKUP1_5044_5120");
+        dropTable("TAB1_5044_5120");
+        s.execute("create table TAB1_5044_5120(c11 int, c12 int)");
+        s.execute("insert into TAB1_5044_5120 values (1,11)");
+        s.execute("create table BKUP1_5044_5120(c111 int, c112 int)");
+        s.execute("create trigger TAB1_TRG1 after update "+
+           		"of C11 on TAB1_5044_5120 REFERENCING old_table as old " +
+           		"for each statement " + 
+       			(modeDb2SqlOptional?"":"MODE DB2SQL ") +
+                "insert into BKUP1_5044_5120 select * from old");
+        //Even though following trigger really doesn't do anything meaninful,
+        // we still need it to make DERBY-5120 kick-in. Do not remove this
+        // trigger. Creation of following trigger is going to mark the
+        // earlier trigger invalid and we need that to make sure DERBY-5120
+        // scenario kicks in
+        s.execute("create trigger TAB1_TRG2 after update " + 
+                "on TAB1_5044_5120 for each row " + 
+     			(modeDb2SqlOptional?"":"MODE DB2SQL ") +
+                "values(1,2)");
+    }
+
+    //Execute the trigger which will fire the triggers. Check the data
+    // to make sure that the triggers fired correctly.
+    private void triggersql_for_DERBY5044_And_DERBY5120(
+    		Statement s) throws Exception
+	{
+    	ResultSet rs;
+    	
+    	//Confirm the data and the number of rows in the tables which
+    	// will be touched by the triggering sql and firing trigger
+    	rs = s.executeQuery("select * from TAB1_5044_5120");
+        JDBC.assertFullResultSet(rs,
+           		new String[][]{{"1","11"}});        		
+    	rs = s.executeQuery("select * from BKUP1_5044_5120");
+        JDBC.assertEmpty(rs);
+        //Following triggering sql will fire triggers
+    	s.executeUpdate("update TAB1_5044_5120 set c11=99");
+    	//The content of following table changed by the triggering sql
+    	rs = s.executeQuery("select * from TAB1_5044_5120");
+        JDBC.assertFullResultSet(rs,
+           		new String[][]{{"99","11"}});        		
+        //The firing trigger inserted row into BKUP1_5044_5120
+    	rs = s.executeQuery("select * from BKUP1_5044_5120");
+        JDBC.assertFullResultSet(rs,
+           		new String[][]{{"1","11"}});
+        //Clean data for next test
+    	s.executeUpdate("delete from BKUP1_5044_5120");
+	}
+    
+    /**
+     * DERBY-5044(ALTER TABLE DROP COLUMN will not detect triggers defined 
+     *  on other tables with their trigger action using the column being 
+     *  dropped)
+     *  
+     * ALTER TABLE DROP COLUMN should detect triggers defined on other table
+     *  but using the table being altered in their trigger action. If the 
+     *  column getting dropped is used in such a trigger, then ALTER TABLE
+     *  DROP COLUMN .. RESTRICT should fail and ALTER TABLE DROP COLUMN ..
+     *  CASCADE should drop such triggers.
+     */
+    public void testDERBY5044AlterTableDropColumn() throws Exception {
+    	// ALTER TABLE DROP COLUMN was introduced in 10.3 so no point running
+    	// this test with earlier releases
+    	if (!oldAtLeast(10, 3)) return;
+
+    	Statement s = createStatement();
+    	ResultSet rs;
+        
+        switch ( getPhase() )
+        {
+        case PH_CREATE: 
+        case PH_POST_SOFT_UPGRADE:
+        	//Get data ready for the test
+        	preapreFortDERBY5044();
+        	//After the setup, verify the number of rows in the tables who
+        	// will be impacted by subsequent trigger firing.
+        	rs = s.executeQuery("select * from ATDC_13_TAB1_BACKUP");
+            JDBC.assertFullResultSet(rs,
+               		new String[][]{{"1","11"}});        		
+        	rs = s.executeQuery("select * from ATDC_13_TAB2");
+            JDBC.assertFullResultSet(rs,
+               		new String[][]{{"1","11"}});
+
+            //Following will fire 2 triggers which will delete rows from
+            // the two tables whose row count we checked earlier.
+            s.executeUpdate("update ATDC_13_TAB1 set c12=999");
+            //There should be no data in the following tables as a result
+            // of triggers which were fired by the UPDATE sql above
+        	rs = s.executeQuery("select * from ATDC_13_TAB1_BACKUP");
+            JDBC.assertEmpty(rs);
+        	rs = s.executeQuery("select * from ATDC_13_TAB2");
+            JDBC.assertEmpty(rs);
+            //Reload the data for the next test
+            s.execute("insert into ATDC_13_TAB1_BACKUP values (1,11)");
+            s.execute("insert into ATDC_13_TAB2 values (1,11)");
+
+            //Following does not detect that column c22 is getting used by
+        	// trigger ATDC_13_TAB1_trg2 defined on ATDC_13_TAB1
+            s.executeUpdate("alter table ATDC_13_TAB2 drop column c22 " +
+            		"restrict");
+            //Following will fail because trigger ATDC_13_TAB1_trg2 will be
+            // fired and it will detect that column ATDC_13_TAB2.c22 getting
+            // used in it's trigger action does not exist anymore
+            assertStatementError("42X04", s,
+               		"update ATDC_13_TAB1 set c12=999");
+            //The number of rows in the tables above didn't change because 
+            // UPDATE sql above failed and hence triggers didn't fire.
+        	rs = s.executeQuery("select * from ATDC_13_TAB1_BACKUP");
+            JDBC.assertFullResultSet(rs,
+               		new String[][]{{"1","11"}});        		
+        	rs = s.executeQuery("select * from ATDC_13_TAB2");
+            JDBC.assertFullResultSet(rs,
+               		new String[][]{{"1"}});
+        	break;
+
+        case PH_SOFT_UPGRADE:
+        case PH_HARD_UPGRADE:
+        case PH_POST_HARD_UPGRADE:
+        	//Get data ready for the test
+        	preapreFortDERBY5044();
+        	//After the setup, verify the number of rows in the tables who
+        	// will be impacted by subsequent trigger firing.
+        	rs = s.executeQuery("select * from ATDC_13_TAB1_BACKUP");
+            JDBC.assertFullResultSet(rs,
+               		new String[][]{{"1","11"}});        		
+        	rs = s.executeQuery("select * from ATDC_13_TAB2");
+            JDBC.assertFullResultSet(rs,
+               		new String[][]{{"1","11"}});
+
+            //Following will fire 2 triggers which will delete rows from
+            // the two tables whose row count we checked earlier.
+        	s.executeUpdate("update ATDC_13_TAB1 set c12=999");
+            //There should be no data in the following tables as a result
+            // of triggers which were fired by the UPDATE sql above
+        	rs = s.executeQuery("select * from ATDC_13_TAB1_BACKUP");
+            JDBC.assertEmpty(rs);  
+        	rs = s.executeQuery("select * from ATDC_13_TAB2");
+            JDBC.assertEmpty(rs);  
+            //Reload the data for the next test
+            s.execute("insert into ATDC_13_TAB1_BACKUP values (1,11)");
+            s.execute("insert into ATDC_13_TAB2 values (1,11)");
+
+            //With the fix DERBY-5044, following ALTER TABLE DROP COLUMN 
+            // will detect that trigger ATDC_13_TAB1_trg2 is using
+            // the column being dropped and hence ALTER TABLE will fail.
+            assertStatementError("X0Y25", s,
+            		"alter table ATDC_13_TAB2 drop column c22 restrict");
+        	//Verify the number of rows in the tables who will be impacted 
+            // by subsequent trigger firing.
+        	rs = s.executeQuery("select * from ATDC_13_TAB1_BACKUP");
+            JDBC.assertFullResultSet(rs,
+               		new String[][]{{"1","11"}});        		
+        	rs = s.executeQuery("select * from ATDC_13_TAB2");
+            JDBC.assertFullResultSet(rs,
+               		new String[][]{{"1","11"}});
+            //Following will fire 2 triggers which will delete rows from
+            // the two tables whose row count we checked earlier.
+        	s.executeUpdate("update ATDC_13_TAB1 set c12=999");
+            //There should be no data in the following tables as a result
+            // of triggers which were fired by the UPDATE sql above
+        	rs = s.executeQuery("select * from ATDC_13_TAB1_BACKUP");
+            JDBC.assertEmpty(rs);  
+        	rs = s.executeQuery("select * from ATDC_13_TAB2");
+            JDBC.assertEmpty(rs);  
+            s.execute("insert into ATDC_13_TAB1_BACKUP values (1,11)");
+            s.execute("insert into ATDC_13_TAB2 values (1,11)");
+            
+            //This time, issue ALTER TABLE DROP COLUMN in CASCADE mode.
+            // This should drop the dependent trigger ATDC_13_TAB1_trg2
+            s.executeUpdate("alter table ATDC_13_TAB2 drop column c22 ");
+            //Verify that trigger ATDC_13_TAB1_trg2 got dropped by issuing
+            // the trigger sql which would normally cause firing of 
+            // ATDC_13_TAB1_trg2.
+        	s.executeUpdate("update ATDC_13_TAB1 set c12=999");
+        	//sql above caused ATDC_13_TAB1_trg1 to fire which will delete
+        	// row from ATDC_13_TAB1_BACKUP
+        	rs = s.executeQuery("select * from ATDC_13_TAB1_BACKUP");
+            JDBC.assertEmpty(rs);  
+            //But the row from ATDC_13_TAB2 will not be deleted because
+            // trigger ATDC_13_TAB1_trg2 does not exist anymore. Notice
+            // though that ATDC_13_TAB2 now has only one column rather than 2
+        	rs = s.executeQuery("select * from ATDC_13_TAB2");
+            JDBC.assertFullResultSet(rs,
+               		new String[][]{{"1"}});
+        	break;
+        }
+    }
+
+    public void preapreFortDERBY5044() throws Exception
+    {
+        Statement s = createStatement();
+        boolean modeDb2SqlOptional = oldAtLeast(10, 3);
+
+        dropTable("ATDC_13_TAB1");
+        dropTable("ATDC_13_TAB1_BACKUP");
+        dropTable("ATDC_13_TAB2");
+        s.execute("create table ATDC_13_TAB1(c11 int, c12 int)");
+        s.execute("insert into ATDC_13_TAB1 values (1,11)");
+        s.execute("create table ATDC_13_TAB1_BACKUP(c11 int, c12 int)");
+        s.execute("insert into ATDC_13_TAB1_BACKUP values (1,11)");
+        s.execute("create table ATDC_13_TAB2(c21 int, c22 int)");
+        s.execute("insert into ATDC_13_TAB2 values (1,11)");
+        s.executeUpdate(
+                " create trigger ATDC_13_TAB1_trg1 after update " +
+                "on ATDC_13_TAB1 for each row " +
+    			(modeDb2SqlOptional?"":"MODE DB2SQL ") +
+                "DELETE FROM ATDC_13_TAB1_BACKUP " +
+                "WHERE C12>=1");
+        s.executeUpdate(
+                " create trigger ATDC_13_TAB1_trg2 after update " +
+                "on ATDC_13_TAB1 for each row " +
+    			(modeDb2SqlOptional?"":"MODE DB2SQL ") +
+                "DELETE FROM ATDC_13_TAB2 WHERE "+
+                "C22 IN (values(11))");
+    }
+    
     /**
      * Changes made for DERBY-1482 caused corruption which is being logged 
      *  under DERBY-5121. The issue is that the generated trigger action
