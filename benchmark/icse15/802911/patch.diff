diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/BatchMutation.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/BatchMutation.java
index e6fdc914..ac97c769 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/BatchMutation.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/BatchMutation.java
@@ -76,8 +76,9 @@ public String getKey() {
     return this.key;
   }
 
-  public void setKey(String key) {
+  public BatchMutation setKey(String key) {
     this.key = key;
+    return this;
   }
 
   public void unsetKey() {
@@ -95,23 +96,13 @@ public void setKeyIsSet(boolean value) {
     }
   }
 
-  public int getCfmapSize() {
-    return (this.cfmap == null) ? 0 : this.cfmap.size();
-  }
-
-  public void putToCfmap(String key, List<Column> val) {
-    if (this.cfmap == null) {
-      this.cfmap = new HashMap<String,List<Column>>();
-    }
-    this.cfmap.put(key, val);
-  }
-
   public Map<String,List<Column>> getCfmap() {
     return this.cfmap;
   }
 
-  public void setCfmap(Map<String,List<Column>> cfmap) {
+  public BatchMutation setCfmap(Map<String,List<Column>> cfmap) {
     this.cfmap = cfmap;
+    return this;
   }
 
   public void unsetCfmap() {
diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/BatchMutationSuper.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/BatchMutationSuper.java
index 9a2f23a4..14dd9630 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/BatchMutationSuper.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/BatchMutationSuper.java
@@ -76,8 +76,9 @@ public String getKey() {
     return this.key;
   }
 
-  public void setKey(String key) {
+  public BatchMutationSuper setKey(String key) {
     this.key = key;
+    return this;
   }
 
   public void unsetKey() {
@@ -95,23 +96,13 @@ public void setKeyIsSet(boolean value) {
     }
   }
 
-  public int getCfmapSize() {
-    return (this.cfmap == null) ? 0 : this.cfmap.size();
-  }
-
-  public void putToCfmap(String key, List<SuperColumn> val) {
-    if (this.cfmap == null) {
-      this.cfmap = new HashMap<String,List<SuperColumn>>();
-    }
-    this.cfmap.put(key, val);
-  }
-
   public Map<String,List<SuperColumn>> getCfmap() {
     return this.cfmap;
   }
 
-  public void setCfmap(Map<String,List<SuperColumn>> cfmap) {
+  public BatchMutationSuper setCfmap(Map<String,List<SuperColumn>> cfmap) {
     this.cfmap = cfmap;
+    return this;
   }
 
   public void unsetCfmap() {
diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Cassandra.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Cassandra.java
index d45d6ac0..f459fc82 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Cassandra.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Cassandra.java
@@ -32,7 +32,7 @@
 
     public void batch_insert(String keyspace, BatchMutation batch_mutation, int consistency_level) throws InvalidRequestException, UnavailableException, TException;
 
-    public void remove(String keyspace, String key, ColumnPath column_path_or_parent, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TException;
+    public void remove(String keyspace, String key, ColumnPath column_path, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TException;
 
     public void batch_insert_super_column(String keyspace, BatchMutationSuper batch_mutation_super, int consistency_level) throws InvalidRequestException, UnavailableException, TException;
 
@@ -44,8 +44,6 @@
 
     public Map<String,Map<String,String>> describe_keyspace(String keyspace) throws NotFoundException, TException;
 
-    public CqlResult execute_query(String query) throws TException;
-
   }
 
   public static class Client implements Iface {
@@ -278,19 +276,19 @@ public void recv_batch_insert() throws InvalidRequestException, UnavailableExcep
       return;
     }
 
-    public void remove(String keyspace, String key, ColumnPath column_path_or_parent, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TException
+    public void remove(String keyspace, String key, ColumnPath column_path, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TException
     {
-      send_remove(keyspace, key, column_path_or_parent, timestamp, consistency_level);
+      send_remove(keyspace, key, column_path, timestamp, consistency_level);
       recv_remove();
     }
 
-    public void send_remove(String keyspace, String key, ColumnPath column_path_or_parent, long timestamp, int consistency_level) throws TException
+    public void send_remove(String keyspace, String key, ColumnPath column_path, long timestamp, int consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("remove", TMessageType.CALL, seqid_));
       remove_args args = new remove_args();
       args.keyspace = keyspace;
       args.key = key;
-      args.column_path_or_parent = column_path_or_parent;
+      args.column_path = column_path;
       args.timestamp = timestamp;
       args.consistency_level = consistency_level;
       args.write(oprot_);
@@ -498,39 +496,6 @@ public void send_describe_keyspace(String keyspace) throws TException
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "describe_keyspace failed: unknown result");
     }
 
-    public CqlResult execute_query(String query) throws TException
-    {
-      send_execute_query(query);
-      return recv_execute_query();
-    }
-
-    public void send_execute_query(String query) throws TException
-    {
-      oprot_.writeMessageBegin(new TMessage("execute_query", TMessageType.CALL, seqid_));
-      execute_query_args args = new execute_query_args();
-      args.query = query;
-      args.write(oprot_);
-      oprot_.writeMessageEnd();
-      oprot_.getTransport().flush();
-    }
-
-    public CqlResult recv_execute_query() throws TException
-    {
-      TMessage msg = iprot_.readMessageBegin();
-      if (msg.type == TMessageType.EXCEPTION) {
-        TApplicationException x = TApplicationException.read(iprot_);
-        iprot_.readMessageEnd();
-        throw x;
-      }
-      execute_query_result result = new execute_query_result();
-      result.read(iprot_);
-      iprot_.readMessageEnd();
-      if (result.isSetSuccess()) {
-        return result.success;
-      }
-      throw new TApplicationException(TApplicationException.MISSING_RESULT, "execute_query failed: unknown result");
-    }
-
   }
   public static class Processor implements TProcessor {
     private static final Logger LOGGER = Logger.getLogger(Processor.class.getName());
@@ -548,7 +513,6 @@ public Processor(Iface iface)
       processMap_.put("get_string_property", new get_string_property());
       processMap_.put("get_string_list_property", new get_string_list_property());
       processMap_.put("describe_keyspace", new describe_keyspace());
-      processMap_.put("execute_query", new execute_query());
     }
 
     protected static interface ProcessFunction {
@@ -733,7 +697,7 @@ public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TExcepti
         iprot.readMessageEnd();
         remove_result result = new remove_result();
         try {
-          iface_.remove(args.keyspace, args.key, args.column_path_or_parent, args.timestamp, args.consistency_level);
+          iface_.remove(args.keyspace, args.key, args.column_path, args.timestamp, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
@@ -873,22 +837,6 @@ public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TExcepti
 
     }
 
-    private class execute_query implements ProcessFunction {
-      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
-      {
-        execute_query_args args = new execute_query_args();
-        args.read(iprot);
-        iprot.readMessageEnd();
-        execute_query_result result = new execute_query_result();
-        result.success = iface_.execute_query(args.query);
-        oprot.writeMessageBegin(new TMessage("execute_query", TMessageType.REPLY, seqid));
-        result.write(oprot);
-        oprot.writeMessageEnd();
-        oprot.getTransport().flush();
-      }
-
-    }
-
   }
 
   public static class get_slice_args implements TBase, java.io.Serializable, Cloneable   {
@@ -907,6 +855,10 @@ public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TExcepti
     public static final int COLUMN_PARENT = 3;
     public SlicePredicate predicate;
     public static final int PREDICATE = 4;
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
     public int consistency_level;
     public static final int CONSISTENCY_LEVEL = 5;
 
@@ -982,8 +934,9 @@ public String getKeyspace() {
       return this.keyspace;
     }
 
-    public void setKeyspace(String keyspace) {
+    public get_slice_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
+      return this;
     }
 
     public void unsetKeyspace() {
@@ -1005,8 +958,9 @@ public String getKey() {
       return this.key;
     }
 
-    public void setKey(String key) {
+    public get_slice_args setKey(String key) {
       this.key = key;
+      return this;
     }
 
     public void unsetKey() {
@@ -1028,8 +982,9 @@ public ColumnParent getColumn_parent() {
       return this.column_parent;
     }
 
-    public void setColumn_parent(ColumnParent column_parent) {
+    public get_slice_args setColumn_parent(ColumnParent column_parent) {
       this.column_parent = column_parent;
+      return this;
     }
 
     public void unsetColumn_parent() {
@@ -1051,8 +1006,9 @@ public SlicePredicate getPredicate() {
       return this.predicate;
     }
 
-    public void setPredicate(SlicePredicate predicate) {
+    public get_slice_args setPredicate(SlicePredicate predicate) {
       this.predicate = predicate;
+      return this;
     }
 
     public void unsetPredicate() {
@@ -1070,13 +1026,22 @@ public void setPredicateIsSet(boolean value) {
       }
     }
 
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
     public int getConsistency_level() {
       return this.consistency_level;
     }
 
-    public void setConsistency_level(int consistency_level) {
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public get_slice_args setConsistency_level(int consistency_level) {
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
+      return this;
     }
 
     public void unsetConsistency_level() {
@@ -1469,27 +1434,13 @@ public get_slice_result clone() {
       return new get_slice_result(this);
     }
 
-    public int getSuccessSize() {
-      return (this.success == null) ? 0 : this.success.size();
-    }
-
-    public java.util.Iterator<ColumnOrSuperColumn> getSuccessIterator() {
-      return (this.success == null) ? null : this.success.iterator();
-    }
-
-    public void addToSuccess(ColumnOrSuperColumn elem) {
-      if (this.success == null) {
-        this.success = new ArrayList<ColumnOrSuperColumn>();
-      }
-      this.success.add(elem);
-    }
-
     public List<ColumnOrSuperColumn> getSuccess() {
       return this.success;
     }
 
-    public void setSuccess(List<ColumnOrSuperColumn> success) {
+    public get_slice_result setSuccess(List<ColumnOrSuperColumn> success) {
       this.success = success;
+      return this;
     }
 
     public void unsetSuccess() {
@@ -1511,8 +1462,9 @@ public InvalidRequestException getIre() {
       return this.ire;
     }
 
-    public void setIre(InvalidRequestException ire) {
+    public get_slice_result setIre(InvalidRequestException ire) {
       this.ire = ire;
+      return this;
     }
 
     public void unsetIre() {
@@ -1534,8 +1486,9 @@ public NotFoundException getNfe() {
       return this.nfe;
     }
 
-    public void setNfe(NotFoundException nfe) {
+    public get_slice_result setNfe(NotFoundException nfe) {
       this.nfe = nfe;
+      return this;
     }
 
     public void unsetNfe() {
@@ -1798,6 +1751,10 @@ public void validate() throws TException {
     public static final int KEY = 2;
     public ColumnPath column_path;
     public static final int COLUMN_PATH = 3;
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
     public int consistency_level;
     public static final int CONSISTENCY_LEVEL = 4;
 
@@ -1866,8 +1823,9 @@ public String getKeyspace() {
       return this.keyspace;
     }
 
-    public void setKeyspace(String keyspace) {
+    public get_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
+      return this;
     }
 
     public void unsetKeyspace() {
@@ -1889,8 +1847,9 @@ public String getKey() {
       return this.key;
     }
 
-    public void setKey(String key) {
+    public get_args setKey(String key) {
       this.key = key;
+      return this;
     }
 
     public void unsetKey() {
@@ -1912,8 +1871,9 @@ public ColumnPath getColumn_path() {
       return this.column_path;
     }
 
-    public void setColumn_path(ColumnPath column_path) {
+    public get_args setColumn_path(ColumnPath column_path) {
       this.column_path = column_path;
+      return this;
     }
 
     public void unsetColumn_path() {
@@ -1931,13 +1891,22 @@ public void setColumn_pathIsSet(boolean value) {
       }
     }
 
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
     public int getConsistency_level() {
       return this.consistency_level;
     }
 
-    public void setConsistency_level(int consistency_level) {
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public get_args setConsistency_level(int consistency_level) {
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
+      return this;
     }
 
     public void unsetConsistency_level() {
@@ -2286,8 +2255,9 @@ public ColumnOrSuperColumn getSuccess() {
       return this.success;
     }
 
-    public void setSuccess(ColumnOrSuperColumn success) {
+    public get_result setSuccess(ColumnOrSuperColumn success) {
       this.success = success;
+      return this;
     }
 
     public void unsetSuccess() {
@@ -2309,8 +2279,9 @@ public InvalidRequestException getIre() {
       return this.ire;
     }
 
-    public void setIre(InvalidRequestException ire) {
+    public get_result setIre(InvalidRequestException ire) {
       this.ire = ire;
+      return this;
     }
 
     public void unsetIre() {
@@ -2332,8 +2303,9 @@ public NotFoundException getNfe() {
       return this.nfe;
     }
 
-    public void setNfe(NotFoundException nfe) {
+    public get_result setNfe(NotFoundException nfe) {
       this.nfe = nfe;
+      return this;
     }
 
     public void unsetNfe() {
@@ -2580,6 +2552,10 @@ public void validate() throws TException {
     public static final int KEY = 2;
     public ColumnParent column_parent;
     public static final int COLUMN_PARENT = 3;
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
     public int consistency_level;
     public static final int CONSISTENCY_LEVEL = 5;
 
@@ -2648,8 +2624,9 @@ public String getKeyspace() {
       return this.keyspace;
     }
 
-    public void setKeyspace(String keyspace) {
+    public get_count_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
+      return this;
     }
 
     public void unsetKeyspace() {
@@ -2671,8 +2648,9 @@ public String getKey() {
       return this.key;
     }
 
-    public void setKey(String key) {
+    public get_count_args setKey(String key) {
       this.key = key;
+      return this;
     }
 
     public void unsetKey() {
@@ -2694,8 +2672,9 @@ public ColumnParent getColumn_parent() {
       return this.column_parent;
     }
 
-    public void setColumn_parent(ColumnParent column_parent) {
+    public get_count_args setColumn_parent(ColumnParent column_parent) {
       this.column_parent = column_parent;
+      return this;
     }
 
     public void unsetColumn_parent() {
@@ -2713,13 +2692,22 @@ public void setColumn_parentIsSet(boolean value) {
       }
     }
 
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
     public int getConsistency_level() {
       return this.consistency_level;
     }
 
-    public void setConsistency_level(int consistency_level) {
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public get_count_args setConsistency_level(int consistency_level) {
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
+      return this;
     }
 
     public void unsetConsistency_level() {
@@ -3059,9 +3047,10 @@ public int getSuccess() {
       return this.success;
     }
 
-    public void setSuccess(int success) {
+    public get_count_result setSuccess(int success) {
       this.success = success;
       this.__isset.success = true;
+      return this;
     }
 
     public void unsetSuccess() {
@@ -3081,8 +3070,9 @@ public InvalidRequestException getIre() {
       return this.ire;
     }
 
-    public void setIre(InvalidRequestException ire) {
+    public get_count_result setIre(InvalidRequestException ire) {
       this.ire = ire;
+      return this;
     }
 
     public void unsetIre() {
@@ -3289,6 +3279,10 @@ public void validate() throws TException {
     public static final int VALUE = 4;
     public long timestamp;
     public static final int TIMESTAMP = 5;
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
     public int consistency_level;
     public static final int CONSISTENCY_LEVEL = 6;
 
@@ -3373,8 +3367,9 @@ public String getKeyspace() {
       return this.keyspace;
     }
 
-    public void setKeyspace(String keyspace) {
+    public insert_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
+      return this;
     }
 
     public void unsetKeyspace() {
@@ -3396,8 +3391,9 @@ public String getKey() {
       return this.key;
     }
 
-    public void setKey(String key) {
+    public insert_args setKey(String key) {
       this.key = key;
+      return this;
     }
 
     public void unsetKey() {
@@ -3419,8 +3415,9 @@ public ColumnPath getColumn_path() {
       return this.column_path;
     }
 
-    public void setColumn_path(ColumnPath column_path) {
+    public insert_args setColumn_path(ColumnPath column_path) {
       this.column_path = column_path;
+      return this;
     }
 
     public void unsetColumn_path() {
@@ -3442,8 +3439,9 @@ public void setColumn_pathIsSet(boolean value) {
       return this.value;
     }
 
-    public void setValue(byte[] value) {
+    public insert_args setValue(byte[] value) {
       this.value = value;
+      return this;
     }
 
     public void unsetValue() {
@@ -3465,9 +3463,10 @@ public long getTimestamp() {
       return this.timestamp;
     }
 
-    public void setTimestamp(long timestamp) {
+    public insert_args setTimestamp(long timestamp) {
       this.timestamp = timestamp;
       this.__isset.timestamp = true;
+      return this;
     }
 
     public void unsetTimestamp() {
@@ -3483,13 +3482,22 @@ public void setTimestampIsSet(boolean value) {
       this.__isset.timestamp = value;
     }
 
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
     public int getConsistency_level() {
       return this.consistency_level;
     }
 
-    public void setConsistency_level(int consistency_level) {
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public insert_args setConsistency_level(int consistency_level) {
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
+      return this;
     }
 
     public void unsetConsistency_level() {
@@ -3912,8 +3920,9 @@ public InvalidRequestException getIre() {
       return this.ire;
     }
 
-    public void setIre(InvalidRequestException ire) {
+    public insert_result setIre(InvalidRequestException ire) {
       this.ire = ire;
+      return this;
     }
 
     public void unsetIre() {
@@ -3935,8 +3944,9 @@ public UnavailableException getUe() {
       return this.ue;
     }
 
-    public void setUe(UnavailableException ue) {
+    public insert_result setUe(UnavailableException ue) {
       this.ue = ue;
+      return this;
     }
 
     public void unsetUe() {
@@ -4138,6 +4148,10 @@ public void validate() throws TException {
     public static final int KEYSPACE = 1;
     public BatchMutation batch_mutation;
     public static final int BATCH_MUTATION = 2;
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
     public int consistency_level;
     public static final int CONSISTENCY_LEVEL = 3;
 
@@ -4199,8 +4213,9 @@ public String getKeyspace() {
       return this.keyspace;
     }
 
-    public void setKeyspace(String keyspace) {
+    public batch_insert_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
+      return this;
     }
 
     public void unsetKeyspace() {
@@ -4222,8 +4237,9 @@ public BatchMutation getBatch_mutation() {
       return this.batch_mutation;
     }
 
-    public void setBatch_mutation(BatchMutation batch_mutation) {
+    public batch_insert_args setBatch_mutation(BatchMutation batch_mutation) {
       this.batch_mutation = batch_mutation;
+      return this;
     }
 
     public void unsetBatch_mutation() {
@@ -4241,13 +4257,22 @@ public void setBatch_mutationIsSet(boolean value) {
       }
     }
 
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
     public int getConsistency_level() {
       return this.consistency_level;
     }
 
-    public void setConsistency_level(int consistency_level) {
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public batch_insert_args setConsistency_level(int consistency_level) {
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
+      return this;
     }
 
     public void unsetConsistency_level() {
@@ -4544,8 +4569,9 @@ public InvalidRequestException getIre() {
       return this.ire;
     }
 
-    public void setIre(InvalidRequestException ire) {
+    public batch_insert_result setIre(InvalidRequestException ire) {
       this.ire = ire;
+      return this;
     }
 
     public void unsetIre() {
@@ -4567,8 +4593,9 @@ public UnavailableException getUe() {
       return this.ue;
     }
 
-    public void setUe(UnavailableException ue) {
+    public batch_insert_result setUe(UnavailableException ue) {
       this.ue = ue;
+      return this;
     }
 
     public void unsetUe() {
@@ -4764,7 +4791,7 @@ public void validate() throws TException {
     private static final TStruct STRUCT_DESC = new TStruct("remove_args");
     private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)2);
-    private static final TField COLUMN_PATH_OR_PARENT_FIELD_DESC = new TField("column_path_or_parent", TType.STRUCT, (short)3);
+    private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)3);
     private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)4);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)5);
 
@@ -4772,10 +4799,14 @@ public void validate() throws TException {
     public static final int KEYSPACE = 1;
     public String key;
     public static final int KEY = 2;
-    public ColumnPath column_path_or_parent;
-    public static final int COLUMN_PATH_OR_PARENT = 3;
+    public ColumnPath column_path;
+    public static final int COLUMN_PATH = 3;
     public long timestamp;
     public static final int TIMESTAMP = 4;
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
     public int consistency_level;
     public static final int CONSISTENCY_LEVEL = 5;
 
@@ -4790,7 +4821,7 @@ public void validate() throws TException {
           new FieldValueMetaData(TType.STRING)));
       put(KEY, new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRING)));
-      put(COLUMN_PATH_OR_PARENT, new FieldMetaData("column_path_or_parent", TFieldRequirementType.DEFAULT, 
+      put(COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.DEFAULT, 
           new StructMetaData(TType.STRUCT, ColumnPath.class)));
       put(TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.I64)));
@@ -4810,14 +4841,14 @@ public remove_args() {
     public remove_args(
       String keyspace,
       String key,
-      ColumnPath column_path_or_parent,
+      ColumnPath column_path,
       long timestamp,
       int consistency_level)
     {
       this();
       this.keyspace = keyspace;
       this.key = key;
-      this.column_path_or_parent = column_path_or_parent;
+      this.column_path = column_path;
       this.timestamp = timestamp;
       this.__isset.timestamp = true;
       this.consistency_level = consistency_level;
@@ -4834,8 +4865,8 @@ public remove_args(remove_args other) {
       if (other.isSetKey()) {
         this.key = other.key;
       }
-      if (other.isSetColumn_path_or_parent()) {
-        this.column_path_or_parent = new ColumnPath(other.column_path_or_parent);
+      if (other.isSetColumn_path()) {
+        this.column_path = new ColumnPath(other.column_path);
       }
       __isset.timestamp = other.__isset.timestamp;
       this.timestamp = other.timestamp;
@@ -4852,8 +4883,9 @@ public String getKeyspace() {
       return this.keyspace;
     }
 
-    public void setKeyspace(String keyspace) {
+    public remove_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
+      return this;
     }
 
     public void unsetKeyspace() {
@@ -4875,8 +4907,9 @@ public String getKey() {
       return this.key;
     }
 
-    public void setKey(String key) {
+    public remove_args setKey(String key) {
       this.key = key;
+      return this;
     }
 
     public void unsetKey() {
@@ -4894,26 +4927,27 @@ public void setKeyIsSet(boolean value) {
       }
     }
 
-    public ColumnPath getColumn_path_or_parent() {
-      return this.column_path_or_parent;
+    public ColumnPath getColumn_path() {
+      return this.column_path;
     }
 
-    public void setColumn_path_or_parent(ColumnPath column_path_or_parent) {
-      this.column_path_or_parent = column_path_or_parent;
+    public remove_args setColumn_path(ColumnPath column_path) {
+      this.column_path = column_path;
+      return this;
     }
 
-    public void unsetColumn_path_or_parent() {
-      this.column_path_or_parent = null;
+    public void unsetColumn_path() {
+      this.column_path = null;
     }
 
-    // Returns true if field column_path_or_parent is set (has been asigned a value) and false otherwise
-    public boolean isSetColumn_path_or_parent() {
-      return this.column_path_or_parent != null;
+    // Returns true if field column_path is set (has been asigned a value) and false otherwise
+    public boolean isSetColumn_path() {
+      return this.column_path != null;
     }
 
-    public void setColumn_path_or_parentIsSet(boolean value) {
+    public void setColumn_pathIsSet(boolean value) {
       if (!value) {
-        this.column_path_or_parent = null;
+        this.column_path = null;
       }
     }
 
@@ -4921,9 +4955,10 @@ public long getTimestamp() {
       return this.timestamp;
     }
 
-    public void setTimestamp(long timestamp) {
+    public remove_args setTimestamp(long timestamp) {
       this.timestamp = timestamp;
       this.__isset.timestamp = true;
+      return this;
     }
 
     public void unsetTimestamp() {
@@ -4939,13 +4974,22 @@ public void setTimestampIsSet(boolean value) {
       this.__isset.timestamp = value;
     }
 
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
     public int getConsistency_level() {
       return this.consistency_level;
     }
 
-    public void setConsistency_level(int consistency_level) {
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public remove_args setConsistency_level(int consistency_level) {
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
+      return this;
     }
 
     public void unsetConsistency_level() {
@@ -4979,11 +5023,11 @@ public void setFieldValue(int fieldID, Object value) {
         }
         break;
 
-      case COLUMN_PATH_OR_PARENT:
+      case COLUMN_PATH:
         if (value == null) {
-          unsetColumn_path_or_parent();
+          unsetColumn_path();
         } else {
-          setColumn_path_or_parent((ColumnPath)value);
+          setColumn_path((ColumnPath)value);
         }
         break;
 
@@ -5016,8 +5060,8 @@ public Object getFieldValue(int fieldID) {
       case KEY:
         return getKey();
 
-      case COLUMN_PATH_OR_PARENT:
-        return getColumn_path_or_parent();
+      case COLUMN_PATH:
+        return getColumn_path();
 
       case TIMESTAMP:
         return new Long(getTimestamp());
@@ -5037,8 +5081,8 @@ public boolean isSet(int fieldID) {
         return isSetKeyspace();
       case KEY:
         return isSetKey();
-      case COLUMN_PATH_OR_PARENT:
-        return isSetColumn_path_or_parent();
+      case COLUMN_PATH:
+        return isSetColumn_path();
       case TIMESTAMP:
         return isSetTimestamp();
       case CONSISTENCY_LEVEL:
@@ -5079,12 +5123,12 @@ public boolean equals(remove_args that) {
           return false;
       }
 
-      boolean this_present_column_path_or_parent = true && this.isSetColumn_path_or_parent();
-      boolean that_present_column_path_or_parent = true && that.isSetColumn_path_or_parent();
-      if (this_present_column_path_or_parent || that_present_column_path_or_parent) {
-        if (!(this_present_column_path_or_parent && that_present_column_path_or_parent))
+      boolean this_present_column_path = true && this.isSetColumn_path();
+      boolean that_present_column_path = true && that.isSetColumn_path();
+      if (this_present_column_path || that_present_column_path) {
+        if (!(this_present_column_path && that_present_column_path))
           return false;
-        if (!this.column_path_or_parent.equals(that.column_path_or_parent))
+        if (!this.column_path.equals(that.column_path))
           return false;
       }
 
@@ -5139,10 +5183,10 @@ public void read(TProtocol iprot) throws TException {
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
-          case COLUMN_PATH_OR_PARENT:
+          case COLUMN_PATH:
             if (field.type == TType.STRUCT) {
-              this.column_path_or_parent = new ColumnPath();
-              this.column_path_or_parent.read(iprot);
+              this.column_path = new ColumnPath();
+              this.column_path.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
@@ -5190,9 +5234,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeString(this.key);
         oprot.writeFieldEnd();
       }
-      if (this.column_path_or_parent != null) {
-        oprot.writeFieldBegin(COLUMN_PATH_OR_PARENT_FIELD_DESC);
-        this.column_path_or_parent.write(oprot);
+      if (this.column_path != null) {
+        oprot.writeFieldBegin(COLUMN_PATH_FIELD_DESC);
+        this.column_path.write(oprot);
         oprot.writeFieldEnd();
       }
       oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
@@ -5226,11 +5270,11 @@ public String toString() {
       }
       first = false;
       if (!first) sb.append(", ");
-      sb.append("column_path_or_parent:");
-      if (this.column_path_or_parent == null) {
+      sb.append("column_path:");
+      if (this.column_path == null) {
         sb.append("null");
       } else {
-        sb.append(this.column_path_or_parent);
+        sb.append(this.column_path);
       }
       first = false;
       if (!first) sb.append(", ");
@@ -5321,8 +5365,9 @@ public InvalidRequestException getIre() {
       return this.ire;
     }
 
-    public void setIre(InvalidRequestException ire) {
+    public remove_result setIre(InvalidRequestException ire) {
       this.ire = ire;
+      return this;
     }
 
     public void unsetIre() {
@@ -5344,8 +5389,9 @@ public UnavailableException getUe() {
       return this.ue;
     }
 
-    public void setUe(UnavailableException ue) {
+    public remove_result setUe(UnavailableException ue) {
       this.ue = ue;
+      return this;
     }
 
     public void unsetUe() {
@@ -5547,6 +5593,10 @@ public void validate() throws TException {
     public static final int KEYSPACE = 1;
     public BatchMutationSuper batch_mutation_super;
     public static final int BATCH_MUTATION_SUPER = 2;
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
     public int consistency_level;
     public static final int CONSISTENCY_LEVEL = 3;
 
@@ -5608,8 +5658,9 @@ public String getKeyspace() {
       return this.keyspace;
     }
 
-    public void setKeyspace(String keyspace) {
+    public batch_insert_super_column_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
+      return this;
     }
 
     public void unsetKeyspace() {
@@ -5631,8 +5682,9 @@ public BatchMutationSuper getBatch_mutation_super() {
       return this.batch_mutation_super;
     }
 
-    public void setBatch_mutation_super(BatchMutationSuper batch_mutation_super) {
+    public batch_insert_super_column_args setBatch_mutation_super(BatchMutationSuper batch_mutation_super) {
       this.batch_mutation_super = batch_mutation_super;
+      return this;
     }
 
     public void unsetBatch_mutation_super() {
@@ -5650,13 +5702,22 @@ public void setBatch_mutation_superIsSet(boolean value) {
       }
     }
 
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
     public int getConsistency_level() {
       return this.consistency_level;
     }
 
-    public void setConsistency_level(int consistency_level) {
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public batch_insert_super_column_args setConsistency_level(int consistency_level) {
       this.consistency_level = consistency_level;
       this.__isset.consistency_level = true;
+      return this;
     }
 
     public void unsetConsistency_level() {
@@ -5953,8 +6014,9 @@ public InvalidRequestException getIre() {
       return this.ire;
     }
 
-    public void setIre(InvalidRequestException ire) {
+    public batch_insert_super_column_result setIre(InvalidRequestException ire) {
       this.ire = ire;
+      return this;
     }
 
     public void unsetIre() {
@@ -5976,8 +6038,9 @@ public UnavailableException getUe() {
       return this.ue;
     }
 
-    public void setUe(UnavailableException ue) {
+    public batch_insert_super_column_result setUe(UnavailableException ue) {
       this.ue = ue;
+      return this;
     }
 
     public void unsetUe() {
@@ -6264,8 +6327,9 @@ public String getKeyspace() {
       return this.keyspace;
     }
 
-    public void setKeyspace(String keyspace) {
+    public get_key_range_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
+      return this;
     }
 
     public void unsetKeyspace() {
@@ -6287,8 +6351,9 @@ public String getColumn_family() {
       return this.column_family;
     }
 
-    public void setColumn_family(String column_family) {
+    public get_key_range_args setColumn_family(String column_family) {
       this.column_family = column_family;
+      return this;
     }
 
     public void unsetColumn_family() {
@@ -6310,8 +6375,9 @@ public String getStart() {
       return this.start;
     }
 
-    public void setStart(String start) {
+    public get_key_range_args setStart(String start) {
       this.start = start;
+      return this;
     }
 
     public void unsetStart() {
@@ -6333,8 +6399,9 @@ public String getFinish() {
       return this.finish;
     }
 
-    public void setFinish(String finish) {
+    public get_key_range_args setFinish(String finish) {
       this.finish = finish;
+      return this;
     }
 
     public void unsetFinish() {
@@ -6356,9 +6423,10 @@ public int getCount() {
       return this.count;
     }
 
-    public void setCount(int count) {
+    public get_key_range_args setCount(int count) {
       this.count = count;
       this.__isset.count = true;
+      return this;
     }
 
     public void unsetCount() {
@@ -6728,27 +6796,13 @@ public get_key_range_result clone() {
       return new get_key_range_result(this);
     }
 
-    public int getSuccessSize() {
-      return (this.success == null) ? 0 : this.success.size();
-    }
-
-    public java.util.Iterator<String> getSuccessIterator() {
-      return (this.success == null) ? null : this.success.iterator();
-    }
-
-    public void addToSuccess(String elem) {
-      if (this.success == null) {
-        this.success = new ArrayList<String>();
-      }
-      this.success.add(elem);
-    }
-
     public List<String> getSuccess() {
       return this.success;
     }
 
-    public void setSuccess(List<String> success) {
+    public get_key_range_result setSuccess(List<String> success) {
       this.success = success;
+      return this;
     }
 
     public void unsetSuccess() {
@@ -6770,8 +6824,9 @@ public InvalidRequestException getIre() {
       return this.ire;
     }
 
-    public void setIre(InvalidRequestException ire) {
+    public get_key_range_result setIre(InvalidRequestException ire) {
       this.ire = ire;
+      return this;
     }
 
     public void unsetIre() {
@@ -7026,8 +7081,9 @@ public String getProperty() {
       return this.property;
     }
 
-    public void setProperty(String property) {
+    public get_string_property_args setProperty(String property) {
       this.property = property;
+      return this;
     }
 
     public void unsetProperty() {
@@ -7225,8 +7281,9 @@ public String getSuccess() {
       return this.success;
     }
 
-    public void setSuccess(String success) {
+    public get_string_property_result setSuccess(String success) {
       this.success = success;
+      return this;
     }
 
     public void unsetSuccess() {
@@ -7423,8 +7480,9 @@ public String getProperty() {
       return this.property;
     }
 
-    public void setProperty(String property) {
+    public get_string_list_property_args setProperty(String property) {
       this.property = property;
+      return this;
     }
 
     public void unsetProperty() {
@@ -7623,27 +7681,13 @@ public get_string_list_property_result clone() {
       return new get_string_list_property_result(this);
     }
 
-    public int getSuccessSize() {
-      return (this.success == null) ? 0 : this.success.size();
-    }
-
-    public java.util.Iterator<String> getSuccessIterator() {
-      return (this.success == null) ? null : this.success.iterator();
-    }
-
-    public void addToSuccess(String elem) {
-      if (this.success == null) {
-        this.success = new ArrayList<String>();
-      }
-      this.success.add(elem);
-    }
-
     public List<String> getSuccess() {
       return this.success;
     }
 
-    public void setSuccess(List<String> success) {
+    public get_string_list_property_result setSuccess(List<String> success) {
       this.success = success;
+      return this;
     }
 
     public void unsetSuccess() {
@@ -7856,8 +7900,9 @@ public String getKeyspace() {
       return this.keyspace;
     }
 
-    public void setKeyspace(String keyspace) {
+    public describe_keyspace_args setKeyspace(String keyspace) {
       this.keyspace = keyspace;
+      return this;
     }
 
     public void unsetKeyspace() {
@@ -8088,23 +8133,13 @@ public describe_keyspace_result clone() {
       return new describe_keyspace_result(this);
     }
 
-    public int getSuccessSize() {
-      return (this.success == null) ? 0 : this.success.size();
-    }
-
-    public void putToSuccess(String key, Map<String,String> val) {
-      if (this.success == null) {
-        this.success = new HashMap<String,Map<String,String>>();
-      }
-      this.success.put(key, val);
-    }
-
     public Map<String,Map<String,String>> getSuccess() {
       return this.success;
     }
 
-    public void setSuccess(Map<String,Map<String,String>> success) {
+    public describe_keyspace_result setSuccess(Map<String,Map<String,String>> success) {
       this.success = success;
+      return this;
     }
 
     public void unsetSuccess() {
@@ -8126,8 +8161,9 @@ public NotFoundException getNfe() {
       return this.nfe;
     }
 
-    public void setNfe(NotFoundException nfe) {
+    public describe_keyspace_result setNfe(NotFoundException nfe) {
       this.nfe = nfe;
+      return this;
     }
 
     public void unsetNfe() {
@@ -8356,402 +8392,4 @@ public void validate() throws TException {
 
   }
 
-  public static class execute_query_args implements TBase, java.io.Serializable, Cloneable   {
-    private static final TStruct STRUCT_DESC = new TStruct("execute_query_args");
-    private static final TField QUERY_FIELD_DESC = new TField("query", TType.STRING, (short)1);
-
-    public String query;
-    public static final int QUERY = 1;
-
-    private final Isset __isset = new Isset();
-    private static final class Isset implements java.io.Serializable {
-    }
-
-    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
-      put(QUERY, new FieldMetaData("query", TFieldRequirementType.DEFAULT, 
-          new FieldValueMetaData(TType.STRING)));
-    }});
-
-    static {
-      FieldMetaData.addStructMetaDataMap(execute_query_args.class, metaDataMap);
-    }
-
-    public execute_query_args() {
-    }
-
-    public execute_query_args(
-      String query)
-    {
-      this();
-      this.query = query;
-    }
-
-    /**
-     * Performs a deep copy on <i>other</i>.
-     */
-    public execute_query_args(execute_query_args other) {
-      if (other.isSetQuery()) {
-        this.query = other.query;
-      }
-    }
-
-    @Override
-    public execute_query_args clone() {
-      return new execute_query_args(this);
-    }
-
-    public String getQuery() {
-      return this.query;
-    }
-
-    public void setQuery(String query) {
-      this.query = query;
-    }
-
-    public void unsetQuery() {
-      this.query = null;
-    }
-
-    // Returns true if field query is set (has been asigned a value) and false otherwise
-    public boolean isSetQuery() {
-      return this.query != null;
-    }
-
-    public void setQueryIsSet(boolean value) {
-      if (!value) {
-        this.query = null;
-      }
-    }
-
-    public void setFieldValue(int fieldID, Object value) {
-      switch (fieldID) {
-      case QUERY:
-        if (value == null) {
-          unsetQuery();
-        } else {
-          setQuery((String)value);
-        }
-        break;
-
-      default:
-        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
-      }
-    }
-
-    public Object getFieldValue(int fieldID) {
-      switch (fieldID) {
-      case QUERY:
-        return getQuery();
-
-      default:
-        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
-      }
-    }
-
-    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
-    public boolean isSet(int fieldID) {
-      switch (fieldID) {
-      case QUERY:
-        return isSetQuery();
-      default:
-        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
-      }
-    }
-
-    @Override
-    public boolean equals(Object that) {
-      if (that == null)
-        return false;
-      if (that instanceof execute_query_args)
-        return this.equals((execute_query_args)that);
-      return false;
-    }
-
-    public boolean equals(execute_query_args that) {
-      if (that == null)
-        return false;
-
-      boolean this_present_query = true && this.isSetQuery();
-      boolean that_present_query = true && that.isSetQuery();
-      if (this_present_query || that_present_query) {
-        if (!(this_present_query && that_present_query))
-          return false;
-        if (!this.query.equals(that.query))
-          return false;
-      }
-
-      return true;
-    }
-
-    @Override
-    public int hashCode() {
-      return 0;
-    }
-
-    public void read(TProtocol iprot) throws TException {
-      TField field;
-      iprot.readStructBegin();
-      while (true)
-      {
-        field = iprot.readFieldBegin();
-        if (field.type == TType.STOP) { 
-          break;
-        }
-        switch (field.id)
-        {
-          case QUERY:
-            if (field.type == TType.STRING) {
-              this.query = iprot.readString();
-            } else { 
-              TProtocolUtil.skip(iprot, field.type);
-            }
-            break;
-          default:
-            TProtocolUtil.skip(iprot, field.type);
-            break;
-        }
-        iprot.readFieldEnd();
-      }
-      iprot.readStructEnd();
-
-
-      // check for required fields of primitive type, which can't be checked in the validate method
-      validate();
-    }
-
-    public void write(TProtocol oprot) throws TException {
-      validate();
-
-      oprot.writeStructBegin(STRUCT_DESC);
-      if (this.query != null) {
-        oprot.writeFieldBegin(QUERY_FIELD_DESC);
-        oprot.writeString(this.query);
-        oprot.writeFieldEnd();
-      }
-      oprot.writeFieldStop();
-      oprot.writeStructEnd();
-    }
-
-    @Override
-    public String toString() {
-      StringBuilder sb = new StringBuilder("execute_query_args(");
-      boolean first = true;
-
-      sb.append("query:");
-      if (this.query == null) {
-        sb.append("null");
-      } else {
-        sb.append(this.query);
-      }
-      first = false;
-      sb.append(")");
-      return sb.toString();
-    }
-
-    public void validate() throws TException {
-      // check for required fields
-      // check that fields of type enum have valid values
-    }
-
-  }
-
-  public static class execute_query_result implements TBase, java.io.Serializable, Cloneable   {
-    private static final TStruct STRUCT_DESC = new TStruct("execute_query_result");
-    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
-
-    public CqlResult success;
-    public static final int SUCCESS = 0;
-
-    private final Isset __isset = new Isset();
-    private static final class Isset implements java.io.Serializable {
-    }
-
-    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
-      put(SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
-          new StructMetaData(TType.STRUCT, CqlResult.class)));
-    }});
-
-    static {
-      FieldMetaData.addStructMetaDataMap(execute_query_result.class, metaDataMap);
-    }
-
-    public execute_query_result() {
-    }
-
-    public execute_query_result(
-      CqlResult success)
-    {
-      this();
-      this.success = success;
-    }
-
-    /**
-     * Performs a deep copy on <i>other</i>.
-     */
-    public execute_query_result(execute_query_result other) {
-      if (other.isSetSuccess()) {
-        this.success = new CqlResult(other.success);
-      }
-    }
-
-    @Override
-    public execute_query_result clone() {
-      return new execute_query_result(this);
-    }
-
-    public CqlResult getSuccess() {
-      return this.success;
-    }
-
-    public void setSuccess(CqlResult success) {
-      this.success = success;
-    }
-
-    public void unsetSuccess() {
-      this.success = null;
-    }
-
-    // Returns true if field success is set (has been asigned a value) and false otherwise
-    public boolean isSetSuccess() {
-      return this.success != null;
-    }
-
-    public void setSuccessIsSet(boolean value) {
-      if (!value) {
-        this.success = null;
-      }
-    }
-
-    public void setFieldValue(int fieldID, Object value) {
-      switch (fieldID) {
-      case SUCCESS:
-        if (value == null) {
-          unsetSuccess();
-        } else {
-          setSuccess((CqlResult)value);
-        }
-        break;
-
-      default:
-        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
-      }
-    }
-
-    public Object getFieldValue(int fieldID) {
-      switch (fieldID) {
-      case SUCCESS:
-        return getSuccess();
-
-      default:
-        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
-      }
-    }
-
-    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
-    public boolean isSet(int fieldID) {
-      switch (fieldID) {
-      case SUCCESS:
-        return isSetSuccess();
-      default:
-        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
-      }
-    }
-
-    @Override
-    public boolean equals(Object that) {
-      if (that == null)
-        return false;
-      if (that instanceof execute_query_result)
-        return this.equals((execute_query_result)that);
-      return false;
-    }
-
-    public boolean equals(execute_query_result that) {
-      if (that == null)
-        return false;
-
-      boolean this_present_success = true && this.isSetSuccess();
-      boolean that_present_success = true && that.isSetSuccess();
-      if (this_present_success || that_present_success) {
-        if (!(this_present_success && that_present_success))
-          return false;
-        if (!this.success.equals(that.success))
-          return false;
-      }
-
-      return true;
-    }
-
-    @Override
-    public int hashCode() {
-      return 0;
-    }
-
-    public void read(TProtocol iprot) throws TException {
-      TField field;
-      iprot.readStructBegin();
-      while (true)
-      {
-        field = iprot.readFieldBegin();
-        if (field.type == TType.STOP) { 
-          break;
-        }
-        switch (field.id)
-        {
-          case SUCCESS:
-            if (field.type == TType.STRUCT) {
-              this.success = new CqlResult();
-              this.success.read(iprot);
-            } else { 
-              TProtocolUtil.skip(iprot, field.type);
-            }
-            break;
-          default:
-            TProtocolUtil.skip(iprot, field.type);
-            break;
-        }
-        iprot.readFieldEnd();
-      }
-      iprot.readStructEnd();
-
-
-      // check for required fields of primitive type, which can't be checked in the validate method
-      validate();
-    }
-
-    public void write(TProtocol oprot) throws TException {
-      oprot.writeStructBegin(STRUCT_DESC);
-
-      if (this.isSetSuccess()) {
-        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
-        this.success.write(oprot);
-        oprot.writeFieldEnd();
-      }
-      oprot.writeFieldStop();
-      oprot.writeStructEnd();
-    }
-
-    @Override
-    public String toString() {
-      StringBuilder sb = new StringBuilder("execute_query_result(");
-      boolean first = true;
-
-      sb.append("success:");
-      if (this.success == null) {
-        sb.append("null");
-      } else {
-        sb.append(this.success);
-      }
-      first = false;
-      sb.append(")");
-      return sb.toString();
-    }
-
-    public void validate() throws TException {
-      // check for required fields
-      // check that fields of type enum have valid values
-    }
-
-  }
-
 }
diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Column.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Column.java
index 5443ab6d..b10e2452 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Column.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Column.java
@@ -89,8 +89,9 @@ public Column clone() {
     return this.name;
   }
 
-  public void setName(byte[] name) {
+  public Column setName(byte[] name) {
     this.name = name;
+    return this;
   }
 
   public void unsetName() {
@@ -112,8 +113,9 @@ public void setNameIsSet(boolean value) {
     return this.value;
   }
 
-  public void setValue(byte[] value) {
+  public Column setValue(byte[] value) {
     this.value = value;
+    return this;
   }
 
   public void unsetValue() {
@@ -135,9 +137,10 @@ public long getTimestamp() {
     return this.timestamp;
   }
 
-  public void setTimestamp(long timestamp) {
+  public Column setTimestamp(long timestamp) {
     this.timestamp = timestamp;
     this.__isset.timestamp = true;
+    return this;
   }
 
   public void unsetTimestamp() {
diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ColumnOrSuperColumn.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ColumnOrSuperColumn.java
index 7d091c7d..1793ddaf 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ColumnOrSuperColumn.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ColumnOrSuperColumn.java
@@ -76,8 +76,9 @@ public Column getColumn() {
     return this.column;
   }
 
-  public void setColumn(Column column) {
+  public ColumnOrSuperColumn setColumn(Column column) {
     this.column = column;
+    return this;
   }
 
   public void unsetColumn() {
@@ -99,8 +100,9 @@ public SuperColumn getSuper_column() {
     return this.super_column;
   }
 
-  public void setSuper_column(SuperColumn super_column) {
+  public ColumnOrSuperColumn setSuper_column(SuperColumn super_column) {
     this.super_column = super_column;
+    return this;
   }
 
   public void unsetSuper_column() {
@@ -250,15 +252,19 @@ public void write(TProtocol oprot) throws TException {
 
     oprot.writeStructBegin(STRUCT_DESC);
     if (this.column != null) {
+      if (isSetColumn()) {
       oprot.writeFieldBegin(COLUMN_FIELD_DESC);
       this.column.write(oprot);
       oprot.writeFieldEnd();
     }
+    }
     if (this.super_column != null) {
+      if (isSetSuper_column()) {
       oprot.writeFieldBegin(SUPER_COLUMN_FIELD_DESC);
       this.super_column.write(oprot);
       oprot.writeFieldEnd();
     }
+    }
     oprot.writeFieldStop();
     oprot.writeStructEnd();
   }
diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ColumnParent.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ColumnParent.java
index 65ce1a5e..1b8591af 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ColumnParent.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ColumnParent.java
@@ -77,8 +77,9 @@ public String getColumn_family() {
     return this.column_family;
   }
 
-  public void setColumn_family(String column_family) {
+  public ColumnParent setColumn_family(String column_family) {
     this.column_family = column_family;
+    return this;
   }
 
   public void unsetColumn_family() {
@@ -100,8 +101,9 @@ public void setColumn_familyIsSet(boolean value) {
     return this.super_column;
   }
 
-  public void setSuper_column(byte[] super_column) {
+  public ColumnParent setSuper_column(byte[] super_column) {
     this.super_column = super_column;
+    return this;
   }
 
   public void unsetSuper_column() {
@@ -254,10 +256,12 @@ public void write(TProtocol oprot) throws TException {
       oprot.writeFieldEnd();
     }
     if (this.super_column != null) {
+      if (isSetSuper_column()) {
       oprot.writeFieldBegin(SUPER_COLUMN_FIELD_DESC);
       oprot.writeBinary(this.super_column);
       oprot.writeFieldEnd();
     }
+    }
     oprot.writeFieldStop();
     oprot.writeStructEnd();
   }
diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ColumnPath.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ColumnPath.java
index be712ef8..7f317626 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ColumnPath.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ColumnPath.java
@@ -88,8 +88,9 @@ public String getColumn_family() {
     return this.column_family;
   }
 
-  public void setColumn_family(String column_family) {
+  public ColumnPath setColumn_family(String column_family) {
     this.column_family = column_family;
+    return this;
   }
 
   public void unsetColumn_family() {
@@ -111,8 +112,9 @@ public void setColumn_familyIsSet(boolean value) {
     return this.super_column;
   }
 
-  public void setSuper_column(byte[] super_column) {
+  public ColumnPath setSuper_column(byte[] super_column) {
     this.super_column = super_column;
+    return this;
   }
 
   public void unsetSuper_column() {
@@ -134,8 +136,9 @@ public void setSuper_columnIsSet(boolean value) {
     return this.column;
   }
 
-  public void setColumn(byte[] column) {
+  public ColumnPath setColumn(byte[] column) {
     this.column = column;
+    return this;
   }
 
   public void unsetColumn() {
@@ -317,15 +320,19 @@ public void write(TProtocol oprot) throws TException {
       oprot.writeFieldEnd();
     }
     if (this.super_column != null) {
+      if (isSetSuper_column()) {
       oprot.writeFieldBegin(SUPER_COLUMN_FIELD_DESC);
       oprot.writeBinary(this.super_column);
       oprot.writeFieldEnd();
     }
+    }
     if (this.column != null) {
+      if (isSetColumn()) {
       oprot.writeFieldBegin(COLUMN_FIELD_DESC);
       oprot.writeBinary(this.column);
       oprot.writeFieldEnd();
     }
+    }
     oprot.writeFieldStop();
     oprot.writeStructEnd();
   }
diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ConsistencyLevel.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ConsistencyLevel.java
index 0ce14bd3..04323d8b 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ConsistencyLevel.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/ConsistencyLevel.java
@@ -19,7 +19,12 @@
   public static final int QUORUM = 2;
   public static final int ALL = 3;
 
-  public static final IntRangeSet VALID_VALUES = new IntRangeSet(ZERO, ONE, QUORUM, ALL);
+  public static final IntRangeSet VALID_VALUES = new IntRangeSet(
+    ZERO, 
+    ONE, 
+    QUORUM, 
+    ALL );
+
   public static final Map<Integer, String> VALUES_TO_NAMES = new HashMap<Integer, String>() {{
     put(ZERO, "ZERO");
     put(ONE, "ONE");
diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/CqlResult.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/CqlResult.java
index 4ae562ea..9004fe2b 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/CqlResult.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/CqlResult.java
@@ -87,9 +87,10 @@ public int getError_code() {
     return this.error_code;
   }
 
-  public void setError_code(int error_code) {
+  public CqlResult setError_code(int error_code) {
     this.error_code = error_code;
     this.__isset.error_code = true;
+    return this;
   }
 
   public void unsetError_code() {
@@ -109,8 +110,9 @@ public String getError_txt() {
     return this.error_txt;
   }
 
-  public void setError_txt(String error_txt) {
+  public CqlResult setError_txt(String error_txt) {
     this.error_txt = error_txt;
+    return this;
   }
 
   public void unsetError_txt() {
@@ -128,27 +130,13 @@ public void setError_txtIsSet(boolean value) {
     }
   }
 
-  public int getResult_setSize() {
-    return (this.result_set == null) ? 0 : this.result_set.size();
-  }
-
-  public java.util.Iterator<Map<String,String>> getResult_setIterator() {
-    return (this.result_set == null) ? null : this.result_set.iterator();
-  }
-
-  public void addToResult_set(Map<String,String> elem) {
-    if (this.result_set == null) {
-      this.result_set = new ArrayList<Map<String,String>>();
-    }
-    this.result_set.add(elem);
-  }
-
   public List<Map<String,String>> getResult_set() {
     return this.result_set;
   }
 
-  public void setResult_set(List<Map<String,String>> result_set) {
+  public CqlResult setResult_set(List<Map<String,String>> result_set) {
     this.result_set = result_set;
+    return this;
   }
 
   public void unsetResult_set() {
diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/InvalidRequestException.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/InvalidRequestException.java
index 524bc0c4..84aed87c 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/InvalidRequestException.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/InvalidRequestException.java
@@ -66,8 +66,9 @@ public String getWhy() {
     return this.why;
   }
 
-  public void setWhy(String why) {
+  public InvalidRequestException setWhy(String why) {
     this.why = why;
+    return this;
   }
 
   public void unsetWhy() {
diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/SlicePredicate.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/SlicePredicate.java
index 31a6b46c..8434e2fd 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/SlicePredicate.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/SlicePredicate.java
@@ -79,27 +79,13 @@ public SlicePredicate clone() {
     return new SlicePredicate(this);
   }
 
-  public int getColumn_namesSize() {
-    return (this.column_names == null) ? 0 : this.column_names.size();
-  }
-
-  public java.util.Iterator<byte[]> getColumn_namesIterator() {
-    return (this.column_names == null) ? null : this.column_names.iterator();
-  }
-
-  public void addToColumn_names(byte[] elem) {
-    if (this.column_names == null) {
-      this.column_names = new ArrayList<byte[]>();
-    }
-    this.column_names.add(elem);
-  }
-
   public List<byte[]> getColumn_names() {
     return this.column_names;
   }
 
-  public void setColumn_names(List<byte[]> column_names) {
+  public SlicePredicate setColumn_names(List<byte[]> column_names) {
     this.column_names = column_names;
+    return this;
   }
 
   public void unsetColumn_names() {
@@ -121,8 +107,9 @@ public SliceRange getSlice_range() {
     return this.slice_range;
   }
 
-  public void setSlice_range(SliceRange slice_range) {
+  public SlicePredicate setSlice_range(SliceRange slice_range) {
     this.slice_range = slice_range;
+    return this;
   }
 
   public void unsetSlice_range() {
@@ -281,6 +268,7 @@ public void write(TProtocol oprot) throws TException {
 
     oprot.writeStructBegin(STRUCT_DESC);
     if (this.column_names != null) {
+      if (isSetColumn_names()) {
       oprot.writeFieldBegin(COLUMN_NAMES_FIELD_DESC);
       {
         oprot.writeListBegin(new TList(TType.STRING, this.column_names.size()));
@@ -291,11 +279,14 @@ public void write(TProtocol oprot) throws TException {
       }
       oprot.writeFieldEnd();
     }
+    }
     if (this.slice_range != null) {
+      if (isSetSlice_range()) {
       oprot.writeFieldBegin(SLICE_RANGE_FIELD_DESC);
       this.slice_range.write(oprot);
       oprot.writeFieldEnd();
     }
+    }
     oprot.writeFieldStop();
     oprot.writeStructEnd();
   }
diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/SliceRange.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/SliceRange.java
index c9bd6e84..49e7476e 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/SliceRange.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/SliceRange.java
@@ -104,8 +104,9 @@ public SliceRange clone() {
     return this.start;
   }
 
-  public void setStart(byte[] start) {
+  public SliceRange setStart(byte[] start) {
     this.start = start;
+    return this;
   }
 
   public void unsetStart() {
@@ -127,8 +128,9 @@ public void setStartIsSet(boolean value) {
     return this.finish;
   }
 
-  public void setFinish(byte[] finish) {
+  public SliceRange setFinish(byte[] finish) {
     this.finish = finish;
+    return this;
   }
 
   public void unsetFinish() {
@@ -150,9 +152,10 @@ public boolean isIs_ascending() {
     return this.is_ascending;
   }
 
-  public void setIs_ascending(boolean is_ascending) {
+  public SliceRange setIs_ascending(boolean is_ascending) {
     this.is_ascending = is_ascending;
     this.__isset.is_ascending = true;
+    return this;
   }
 
   public void unsetIs_ascending() {
@@ -172,9 +175,10 @@ public int getCount() {
     return this.count;
   }
 
-  public void setCount(int count) {
+  public SliceRange setCount(int count) {
     this.count = count;
     this.__isset.count = true;
+    return this;
   }
 
   public void unsetCount() {
diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/SuperColumn.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/SuperColumn.java
index 88637238..3fa2831c 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/SuperColumn.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/SuperColumn.java
@@ -82,8 +82,9 @@ public SuperColumn clone() {
     return this.name;
   }
 
-  public void setName(byte[] name) {
+  public SuperColumn setName(byte[] name) {
     this.name = name;
+    return this;
   }
 
   public void unsetName() {
@@ -101,27 +102,13 @@ public void setNameIsSet(boolean value) {
     }
   }
 
-  public int getColumnsSize() {
-    return (this.columns == null) ? 0 : this.columns.size();
-  }
-
-  public java.util.Iterator<Column> getColumnsIterator() {
-    return (this.columns == null) ? null : this.columns.iterator();
-  }
-
-  public void addToColumns(Column elem) {
-    if (this.columns == null) {
-      this.columns = new ArrayList<Column>();
-    }
-    this.columns.add(elem);
-  }
-
   public List<Column> getColumns() {
     return this.columns;
   }
 
-  public void setColumns(List<Column> columns) {
+  public SuperColumn setColumns(List<Column> columns) {
     this.columns = columns;
+    return this;
   }
 
   public void unsetColumns() {
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cli/CliClient.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cli/CliClient.java
index e345aef3..250e991c 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cli/CliClient.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cli/CliClient.java
@@ -146,8 +146,7 @@ private void executeGet(CommonTree ast) throws TException, NotFoundException, In
                 }
                 catch (UnsupportedEncodingException e)
                 {
-                    css_.out.printf("Cannot display results (UTF-8 not supported).");
-                    break;
+                    throw new RuntimeException(e);
                 }
             }
             css_.out.println("Returned " + size + " rows.");
@@ -161,14 +160,16 @@ private void executeGet(CommonTree ast) throws TException, NotFoundException, In
             try
             {
                 cosc = thriftClient_.get(tableName, key, new ColumnPath(columnFamily, null, columnName.getBytes("UTF-8")), ConsistencyLevel.ONE);
+                Column column = cosc.column;
+                css_.out.printf("==> (name=%s, value=%s; timestamp=%d)\n",
+                        new String(column.name, "UTF-8"),
+                        new String(column.value, "UTF-8"),
+                        column.timestamp);
             }
             catch (UnsupportedEncodingException e)
             {
                 throw new RuntimeException(e);
             }
-            Column column = cosc.column;
-            css_.out.printf("==> (name=%s, value=%s; timestamp=%d)\n",
-                            column.name, column.value, column.timestamp);
         }
     }
 
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/BindOperand.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/BindOperand.java
index 2ea2b9af..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/BindOperand.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/BindOperand.java
@@ -1,51 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-import org.apache.cassandra.cql.execution.RuntimeErrorMsg;
-
-/**
- * BindOperand: 
- * Represents a bind variable in the CQL statement. Lives
- * in the shared execution plan.
- */
-public class BindOperand implements OperandDef 
-{
-    int bindIndex_;  // bind position
-
-    public BindOperand(int bindIndex)
-    {
-        bindIndex_ = bindIndex;
-    }
-
-    public Object get()
-    {
-        // TODO: Once bind variables are supported, the get() will extract
-        // the value of the bind at position "bindIndex_" from the execution
-        // context.
-        throw new RuntimeException(RuntimeErrorMsg.IMPLEMENTATION_RESTRICTION
-                                   .getMsg("bind params not yet supported"));
-    }
-    
-    public String explain()
-    {
-        return "Bind #: " + bindIndex_;
-    }
-
-};
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/CExpr.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/CExpr.java
index fe78a2f3..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/CExpr.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/CExpr.java
@@ -1,30 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-//Note: This class is CQL related work in progress.
-public class CExpr
-{
-    public static interface Expr
-    {
-        CType  getType();
-        String toString();
-    };
-}
-
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/CType.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/CType.java
index 04de09ab..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/CType.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/CType.java
@@ -1,77 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.cassandra.cql.common;
-
-import java.util.ArrayList;
-
-//Note: This class is CQL related work in progress.
-public class CType
-{
-    public static interface Type
-    {
-        String toString(); 
-    };
-
-    public static class IntegerType implements Type
-    {
-        public String toString() { return "Integer"; };
-    }
-
-    public static class StringType implements Type
-    {
-        public String toString() { return "String"; };
-    }
-
-    public static class RowType implements Type
-    {
-        ArrayList<Type> types_;
-        public RowType(ArrayList<Type> types)
-        {
-            types_ = types;
-        }
-
-        public String toString()
-        {
-            StringBuilder sb = new StringBuilder("<");
-            for (int idx = types_.size(); idx > 0; idx--)
-            {
-                sb.append(types_.toString());
-                if (idx != 1)
-                {
-                    sb.append(", ");
-                }
-            }
-            sb.append(">");
-            return sb.toString();
-        }
-    }
-
-    public static class ArrayType
-    {
-        Type elementType_;
-        public ArrayType(Type elementType)
-        {
-            elementType_ = elementType;
-        }
-
-        public String toString()
-        {
-            return "Array(" + elementType_.toString() + ")";
-        }
-    }
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ColumnMapExpr.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ColumnMapExpr.java
index 35f40723..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ColumnMapExpr.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ColumnMapExpr.java
@@ -1,25 +0,0 @@
-/* Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-import java.util.ArrayList;
-
-public class ColumnMapExpr extends ArrayList<Pair<OperandDef, OperandDef>>
-{
-    private static final long serialVersionUID = 1L;
-};
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ColumnRangeQueryRSD.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ColumnRangeQueryRSD.java
index ea301a1c..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ColumnRangeQueryRSD.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ColumnRangeQueryRSD.java
@@ -1,163 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.Map;
-import java.util.List;
-import java.io.UnsupportedEncodingException;
-
-import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.cql.execution.RuntimeErrorMsg;
-import org.apache.cassandra.db.*;
-import org.apache.cassandra.db.filter.QueryPath;
-import org.apache.cassandra.service.ConsistencyLevel;
-import org.apache.cassandra.service.StorageProxy;
-import org.apache.cassandra.service.StorageService;
-import org.apache.cassandra.utils.LogUtil;
-import org.apache.log4j.Logger;
-import org.apache.commons.lang.ArrayUtils;
-
-/**
- * A Row Source Defintion (RSD) for doing a range query on a column map
- * (in Standard or Super Column Family).
- */
-public class ColumnRangeQueryRSD extends RowSourceDef
-{
-    private final static Logger logger_ = Logger.getLogger(ColumnRangeQueryRSD.class);
-    private CFMetaData cfMetaData_;
-    private OperandDef rowKey_;
-    private OperandDef superColumnKey_;
-    private int        limit_;
-
-    /**
-     * Set up a range query on column map in a simple column family.
-     * The column map in a simple column family is identified by the rowKey.
-     * 
-     * Note: "limit" of -1 is the equivalent of no limit.
-     *       "offset" specifies the number of rows to skip. An offset of 0 implies from the first row.
-     */
-    public ColumnRangeQueryRSD(CFMetaData cfMetaData, OperandDef rowKey, int limit)
-    {
-        cfMetaData_     = cfMetaData;
-        rowKey_         = rowKey;
-        superColumnKey_ = null;
-        limit_          = limit;
-    }
-
-    /**
-     * Setup a range query on a column map in a super column family.
-     * The column map in a super column family is identified by the rowKey & superColumnKey.
-     *  
-     * Note: "limit" of -1 is the equivalent of no limit.
-     *       "offset" specifies the number of rows to skip. An offset of 0 implies the first row.  
-     */
-    public ColumnRangeQueryRSD(CFMetaData cfMetaData, ConstantOperand rowKey, ConstantOperand superColumnKey, int limit)
-    {
-        cfMetaData_     = cfMetaData;
-        rowKey_         = rowKey;
-        superColumnKey_ = superColumnKey;
-        limit_          = limit;
-    }
-
-    public List<Map<String,String>> getRows() throws UnsupportedEncodingException
-    {
-        QueryPath path;
-        String superColumnKey = null;
-
-        if (superColumnKey_ != null)
-        {
-            superColumnKey = (String)(superColumnKey_.get());
-            path = new QueryPath(cfMetaData_.cfName, superColumnKey.getBytes("UTF-8"));
-        }
-        else
-        {
-            path = new QueryPath(cfMetaData_.cfName);
-        }
-
-        Row row = null;
-        try
-        {
-            String key = (String)(rowKey_.get());
-            ReadCommand readCommand = new SliceFromReadCommand(cfMetaData_.tableName, key, path, ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, limit_);
-            row = StorageProxy.readProtocol(readCommand, ConsistencyLevel.ONE);
-        }
-        catch (Exception e)
-        {
-            logger_.error(LogUtil.throwableToString(e));
-            throw new RuntimeException(RuntimeErrorMsg.GENERIC_ERROR.getMsg());
-        }
-
-        List<Map<String, String>> rows = new LinkedList<Map<String, String>>();
-        if (row != null)
-        {
-            ColumnFamily cfamily = row.getColumnFamily(cfMetaData_.cfName);
-            if (cfamily != null)
-            {
-                Collection<IColumn> columns = null;
-                if (superColumnKey_ != null)
-                {
-                    // this is the super column case
-                    IColumn column = cfamily.getColumn(superColumnKey.getBytes("UTF-8"));
-                    if (column != null)
-                        columns = column.getSubColumns();
-                }
-                else
-                {
-                    columns = cfamily.getSortedColumns();
-                }
-
-                if (columns != null && columns.size() > 0)
-                {
-                    for (IColumn column : columns)
-                    {
-                        Map<String, String> result = new HashMap<String, String>();
-
-                        result.put(cfMetaData_.n_columnKey, new String(column.name(), "UTF-8"));
-                        result.put(cfMetaData_.n_columnValue, new String(column.value()));
-                        result.put(cfMetaData_.n_columnTimestamp, Long.toString(column.timestamp()));
-
-                        rows.add(result);
-                    }
-                }
-            }
-        }
-        return rows;
-    }
-
-    public String explainPlan()
-    {
-        return String.format("%s Column Family: Column Range Query: \n" +
-                "  Table Name:       %s\n" +
-                "  Column Family:    %s\n" +
-                "  RowKey:           %s\n" +
-                "%s"                   +
-                "  Limit:            %d\n" +
-                "  Order By:         %s",
-                cfMetaData_.columnType,
-                cfMetaData_.tableName,
-                cfMetaData_.cfName,
-                rowKey_.explain(),
-                (superColumnKey_ == null) ? "" : "  SuperColumnKey:   " + superColumnKey_.explain() + "\n",
-                limit_,
-                cfMetaData_.comparator);
-    }
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ConstantOperand.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ConstantOperand.java
index cfabb500..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ConstantOperand.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ConstantOperand.java
@@ -1,43 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-/**
- * ConstantOperand:
- * Represents a literal/constant operand in the CQL statement.
- * Lives as part of the shared execution plan.
- */
-public class ConstantOperand implements OperandDef 
-{
-    Object value_;
-    public ConstantOperand(Object value)
-    {
-        value_ = value;
-    }
-
-    public Object get()
-    {
-        return value_;
-    }
-
-    public String explain()
-    {
-        return "Constant: '" + value_ + "'";
-    }
-};
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/CqlResult.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/CqlResult.java
index 2908e86e..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/CqlResult.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/CqlResult.java
@@ -1,36 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.cassandra.cql.common;
-
-import java.util.List;
-import java.util.Map;
-
-public class CqlResult
-{
-    public int                       errorCode; // 0 - success
-    public String                    errorTxt;
-    public List<Map<String, String>> resultSet;
-
-    public CqlResult(List<Map<String, String>> rows)
-    {
-        resultSet = rows;
-        errorTxt  = null;
-        errorCode = 0; // success
-    }
-    
-};
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/DMLPlan.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/DMLPlan.java
index c592473d..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/DMLPlan.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/DMLPlan.java
@@ -1,25 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-/**
- * This class represents the execution plan for DML (data manipulation language)
- * CQL statements. 
- */
-public abstract class DMLPlan extends Plan {};
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ExplainPlan.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ExplainPlan.java
index ed421ab2..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ExplainPlan.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/ExplainPlan.java
@@ -1,66 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-import java.util.*;
-import org.apache.log4j.Logger;
-
-/**
- * The "Plan" for the EXPLAIN PLAN statement itself!
- * 
- * It is nothing but a simple wrapper around the "Plan" for the statement
- * on which an EXPLAIN PLAN has been requested.
- */
-public class ExplainPlan extends Plan
-{
-    private final static Logger logger_ = Logger.getLogger(ExplainPlan.class);
-    
-    // the execution plan for the statement on which an 
-    // EXPLAIN PLAN was requested.
-    private Plan plan_ = null;
-
-    /**
-     *  Construct an ExplainPlan instance for the statement whose
-     * "plan" has been passed in.
-     */
-    public ExplainPlan(Plan plan)
-    {
-        plan_ = plan;
-    }
-
-    public CqlResult execute()
-    {
-        String planText = plan_.explainPlan();
-
-        List<Map<String, String>> rows = new LinkedList<Map<String, String>>(); 
-        Map<String, String> row = new HashMap<String, String>();
-        row.put("PLAN", planText);
-        rows.add(row);
-        
-        return new CqlResult(rows);
-    }
-
-    public String explainPlan()
-    {
-        // We never expect this method to get invoked for ExplainPlan instances
-        // (i.e. those that correspond to the EXPLAIN PLAN statement).
-        logger_.error("explainPlan() invoked on an ExplainPlan instance");
-        return null;
-    }
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/OperandDef.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/OperandDef.java
index fa91e112..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/OperandDef.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/OperandDef.java
@@ -1,33 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-/**
- * OperandDef:
- *
- * The abstract definition of an operand (i.e. data item) in 
- * CQL compiler/runtime. Examples, include a Constant operand
- * or a Bind operand. This is the part of an operand definition
- * that lives in the share-able execution plan.
- */
-public abstract interface OperandDef
-{
-    public abstract Object get();
-    public abstract String explain();
-};
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/Pair.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/Pair.java
index 59523bbd..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/Pair.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/Pair.java
@@ -1,53 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-/* Would have expected java.util.* to have this class!
- * Code cut-paste from wikipedia.
- */
-
-/**
- * Generic for representing a "typed" 2-tuple.
- */
-public class Pair<T, S>
-{
-  public Pair(T f, S s)
-  { 
-    first = f;
-    second = s;   
-  }
-
-  public T getFirst()
-  {
-    return first;
-  }
- 
-  public S getSecond() 
-  {
-    return second;
-  }
- 
-  public String toString()
-  { 
-    return "(" + first.toString() + ", " + second.toString() + ")"; 
-  }
- 
-  private T first;
-  private S second;
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/Plan.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/Plan.java
index a846f04c..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/Plan.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/Plan.java
@@ -1,32 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-import java.io.UnsupportedEncodingException;
-
-/**
- * Abstract class representing the shared execution plan for a CQL
- * statement (query or DML operation).
- * 
- */
-public abstract class Plan
-{
-    public abstract CqlResult execute() throws UnsupportedEncodingException;
-    public abstract String explainPlan();
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/QueryPlan.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/QueryPlan.java
index df399c0a..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/QueryPlan.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/QueryPlan.java
@@ -1,62 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-import java.io.UnsupportedEncodingException;
-
-import org.apache.log4j.Logger;
-
-/**
- * This class represents the execution plan for Query (data retrieval) statement. 
- */
-public class QueryPlan extends Plan
-{
-    private final static Logger logger_ = Logger.getLogger(QueryPlan.class);    
-
-    public RowSourceDef root;    // the root of the row source tree
-
-    public QueryPlan(RowSourceDef rwsDef)
-    {
-        root = rwsDef;
-    }
-    
-    public CqlResult execute()
-    {
-        if (root != null)
-        {
-            try
-            {
-                return new CqlResult(root.getRows());
-            }
-            catch (UnsupportedEncodingException e)
-            {
-                throw new RuntimeException(e);
-            }
-        }
-        else
-            logger_.error("No rowsource to execute");
-        return null;
-    }
-    
-    public String explainPlan()
-    {
-        return root.explainPlan();
-    }
-    
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/RowSourceDef.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/RowSourceDef.java
index cf8f2aad..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/RowSourceDef.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/RowSourceDef.java
@@ -1,49 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-import java.util.List;
-import java.util.Map;
-import java.io.UnsupportedEncodingException;
-
-/**
- * The abstract notion of a row source definition. A row source
- * is literally just anything that returns rows back.
- * 
- * The concrete implementations of row source might be things like a 
- * column family row source, a "super column family" row source, 
- * a table row source, etc.
- *
- * Note: Instances of sub-classes of this class are part of the "shared" 
- * execution plan of CQL. And hence they should not contain any mutable
- * (i.e. session specific) execution state. Mutable state, such a bind
- * variable values (corresponding to say a rowKey or a column Key) are
- * note part of the RowSourceDef tree.
- * 
- * [Eventually the notion of a "mutable" portion of the RowSource (RowSourceMut)
- * will be introduced to hold session-specific execution state of the RowSource.
- * For example, this would be needed when implementing iterator style rowsources
- * that yields rows back one at a time as opposed to returning them in one
- * shot.]
- */
-public abstract class RowSourceDef
-{
-    public abstract List<Map<String,String>> getRows() throws UnsupportedEncodingException;
-    public abstract String explainPlan();  
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SetColumnMap.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SetColumnMap.java
index e484be93..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SetColumnMap.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SetColumnMap.java
@@ -1,133 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.cql.execution.RuntimeErrorMsg;
-import org.apache.cassandra.db.RowMutation;
-import org.apache.cassandra.service.StorageProxy;
-import org.apache.cassandra.utils.LogUtil;
-import org.apache.log4j.Logger;
-import org.apache.cassandra.cql.execution.*;
-import org.apache.cassandra.db.*;
-import org.apache.cassandra.db.filter.QueryPath;
-import org.apache.cassandra.service.*;
-
-/**
- * Execution plan for batch setting a set of columns in a Simple/Super column family.
- *   SET table.standard_cf[<rowKey>] = <columnMapExpr>;                
- *   SET table.super_cf[<rowKey>][<superColumn>] = <columnMapExpr>;
- */
-public class SetColumnMap extends DMLPlan
-{
-    private final static Logger logger_ = Logger.getLogger(SetUniqueKey.class);    
-    private CFMetaData    cfMetaData_;
-    private OperandDef    rowKey_;
-    private OperandDef    superColumnKey_;
-    private ColumnMapExpr columnMapExpr_;
-
-    /**
-     *  construct an execution plan node to set the column map for a Standard Column Family.
-     *
-     *    SET table.standard_cf[<rowKey>] = <columnMapExpr>;                
-     */
-    public SetColumnMap(CFMetaData cfMetaData, OperandDef rowKey, ColumnMapExpr columnMapExpr)
-    {
-        cfMetaData_     = cfMetaData;
-        rowKey_         = rowKey;
-        superColumnKey_ = null;        
-        columnMapExpr_  = columnMapExpr;
-    }
-
-    /**
-     * Construct an execution plan node to set the column map for a Super Column Family
-     * 
-     *   SET table.super_cf[<rowKey>][<superColumn>] = <columnMapExpr>;
-     */
-    public SetColumnMap(CFMetaData cfMetaData, OperandDef rowKey, OperandDef superColumnKey, ColumnMapExpr columnMapExpr)
-    {
-        cfMetaData_     = cfMetaData;
-        rowKey_         = rowKey;
-        superColumnKey_ = superColumnKey;
-        columnMapExpr_  = columnMapExpr;
-    }
-
-    public CqlResult execute()
-    {
-        try
-        {
-            RowMutation rm = new RowMutation(cfMetaData_.tableName, (String)(rowKey_.get()));
-            long time = System.currentTimeMillis();
-
-            for (Pair<OperandDef, OperandDef> entry : columnMapExpr_)
-            {
-                OperandDef columnKey = entry.getFirst();
-                OperandDef value     = entry.getSecond();
-
-                QueryPath path;
-                if (superColumnKey_ != null)
-                {
-                    String superColumnKey = (String)(superColumnKey_.get());
-                    path = new QueryPath(cfMetaData_.cfName, superColumnKey.getBytes("UTF-8"), ((String)columnKey.get()).getBytes("UTF-8"));
-                }
-                else
-                {
-                    path = new QueryPath(cfMetaData_.cfName, null, ((String)columnKey.get()).getBytes("UTF-8"));
-                }
-
-                rm.add(path, ((String)value.get()).getBytes(), time);
-            }
-            StorageProxy.insert(rm);
-        }
-        catch (Exception e)
-        {
-            logger_.error(LogUtil.throwableToString(e));
-            throw new RuntimeException(RuntimeErrorMsg.GENERIC_ERROR.getMsg());            
-        }
-        return null;
-    }
-
-    public String explainPlan()
-    {
-        StringBuilder sb = new StringBuilder();
-        
-        String prefix =
-            String.format("%s Column Family: Batch SET a set of columns: \n" +
-            "   Table Name:     %s\n" +
-            "   Column Famly:   %s\n" +
-            "   RowKey:         %s\n" +
-            "%s",
-            cfMetaData_.columnType,
-            cfMetaData_.tableName,
-            cfMetaData_.cfName,
-            rowKey_.explain(),
-            (superColumnKey_ == null) ? "" : "   SuperColumnKey: " + superColumnKey_.explain() + "\n");                
-
-        for (Pair<OperandDef, OperandDef> entry : columnMapExpr_)
-        {
-            OperandDef columnKey = entry.getFirst();
-            OperandDef value     = entry.getSecond();
-            sb.append(String.format("   ColumnKey:        %s\n" +
-                                    "   Value:            %s\n",
-                                    columnKey.explain(), value.explain()));
-        }
-        
-        return prefix + sb.toString();
-    }
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SetSuperColumnMap.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SetSuperColumnMap.java
index 7652243f..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SetSuperColumnMap.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SetSuperColumnMap.java
@@ -1,119 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.cql.execution.RuntimeErrorMsg;
-import org.apache.cassandra.db.RowMutation;
-import org.apache.cassandra.db.filter.QueryPath;
-import org.apache.cassandra.service.StorageProxy;
-import org.apache.cassandra.utils.LogUtil;
-import org.apache.log4j.Logger;
-import org.apache.cassandra.cql.execution.*;
-
-/**
- * Execution plan for batch setting a set of super columns in a Super column family.
-  *   SET table.super_cf[<rowKey>] = <superColumnMapExpr>;
- */
-public class SetSuperColumnMap extends DMLPlan
-{
-    private final static Logger logger_ = Logger.getLogger(SetUniqueKey.class);    
-    private CFMetaData         cfMetaData_;
-    private OperandDef         rowKey_;
-    private SuperColumnMapExpr superColumnMapExpr_;
-
-    /**
-     *  construct an execution plan node to batch set a bunch of super columns in a 
-     *  super column family.
-     *
-     *    SET table.super_cf[<rowKey>] = <superColumnMapExpr>;
-     */
-    public SetSuperColumnMap(CFMetaData cfMetaData, OperandDef rowKey, SuperColumnMapExpr superColumnMapExpr)
-    {
-        cfMetaData_         = cfMetaData;
-        rowKey_             = rowKey;
-        superColumnMapExpr_ = superColumnMapExpr;
-    }
-    
-    public CqlResult execute()
-    {
-        try
-        {
-            RowMutation rm = new RowMutation(cfMetaData_.tableName, (String)(rowKey_.get()));
-            long time = System.currentTimeMillis();
-
-            for (Pair<OperandDef, ColumnMapExpr> superColumn : superColumnMapExpr_)
-            {
-                OperandDef    superColumnKey = superColumn.getFirst();
-                ColumnMapExpr columnMapExpr = superColumn.getSecond();
-                
-                for (Pair<OperandDef, OperandDef> entry : columnMapExpr)
-                {
-                    OperandDef columnKey = entry.getFirst();
-                    OperandDef value     = entry.getSecond();
-                    QueryPath path = new QueryPath(cfMetaData_.cfName, ((String)(superColumnKey.get())).getBytes("UTF-8"), ((String)(columnKey.get())).getBytes("UTF-8"));
-                    rm.add(path, ((String)value.get()).getBytes(), time);
-                }
-            }
-            StorageProxy.insert(rm);
-        }
-        catch (Exception e)
-        {
-            logger_.error(LogUtil.throwableToString(e));
-            throw new RuntimeException(RuntimeErrorMsg.GENERIC_ERROR.getMsg());            
-        }
-        return null;
-
-    }
-
-    public String explainPlan()
-    {
-        StringBuilder sb = new StringBuilder();
-        
-        String prefix =
-            String.format("%s Column Family: Batch SET a set of Super Columns: \n" +
-            "   Table Name:     %s\n" +
-            "   Column Famly:   %s\n" +
-            "   RowKey:         %s\n",
-            cfMetaData_.columnType,
-            cfMetaData_.tableName,
-            cfMetaData_.cfName,
-            rowKey_.explain());
-
-        for (Pair<OperandDef, ColumnMapExpr> superColumn : superColumnMapExpr_)
-        {
-            OperandDef    superColumnKey = superColumn.getFirst();
-            ColumnMapExpr columnMapExpr = superColumn.getSecond();
-
-            for (Pair<OperandDef, OperandDef> entry : columnMapExpr)
-            {
-                OperandDef columnKey = entry.getFirst();
-                OperandDef value     = entry.getSecond();
-                sb.append(String.format("     SuperColumnKey: %s\n" + 
-                                        "     ColumnKey:      %s\n" +
-                                        "     Value:          %s\n",
-                                        superColumnKey.explain(),
-                                        columnKey.explain(),
-                                        value.explain()));
-            }
-        }
-        
-        return prefix + sb.toString();
-    }
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SetUniqueKey.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SetUniqueKey.java
index a38ebb6e..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SetUniqueKey.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SetUniqueKey.java
@@ -1,121 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-import java.io.UnsupportedEncodingException;
-
-import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.cql.execution.RuntimeErrorMsg;
-import org.apache.cassandra.db.RowMutation;
-import org.apache.cassandra.db.filter.QueryPath;
-import org.apache.cassandra.service.StorageProxy;
-import org.apache.cassandra.utils.LogUtil;
-import org.apache.log4j.Logger;
-
-
-/**
- * Execution plan for setting a specific column in a Simple/Super column family.
- *   SET table.standard_cf[<rowKey>][<columnKey>] = <value>;
- *   SET table.super_cf[<rowKey>][<superColumnKey>][<columnKey>] = <value>; 
- */
-public class SetUniqueKey extends DMLPlan
-{
-    private final static Logger logger_ = Logger.getLogger(SetUniqueKey.class);    
-    private CFMetaData cfMetaData_;
-    private OperandDef rowKey_;
-    private OperandDef superColumnKey_;
-    private OperandDef columnKey_;
-    private OperandDef value_;
-
-    /**
-     *  Construct an execution plan for setting a column in a simple column family
-     * 
-     *   SET table.standard_cf[<rowKey>][<columnKey>] = <value>;
-     */
-    public SetUniqueKey(CFMetaData cfMetaData, OperandDef rowKey, OperandDef columnKey, OperandDef value)
-    {
-        cfMetaData_     = cfMetaData;
-        rowKey_         = rowKey;
-        columnKey_      = columnKey;
-        superColumnKey_ = null;
-        value_          = value;
-    }
-    
-    /**
-     * Construct execution plan for setting a column in a super column family.
-     * 
-     *  SET table.super_cf[<rowKey>][<superColumnKey>][<columnKey>] = <value>;
-     */
-    public SetUniqueKey(CFMetaData cfMetaData, OperandDef rowKey, OperandDef superColumnKey, OperandDef columnKey, OperandDef value)
-    {
-        cfMetaData_     = cfMetaData;
-        rowKey_         = rowKey;
-        superColumnKey_ = superColumnKey;
-        columnKey_      = columnKey;
-        value_          = value;
-    }
-
-    public CqlResult execute() throws UnsupportedEncodingException
-    {
-        String columnKey = (String)(columnKey_.get());
-        QueryPath path;
-
-        if (superColumnKey_ != null)
-        {
-            String superColumnKey = (String)(superColumnKey_.get());
-            path = new QueryPath(cfMetaData_.cfName, superColumnKey.getBytes("UTF-8"), columnKey.getBytes("UTF-8"));
-        }
-        else
-        {
-            path = new QueryPath(cfMetaData_.cfName, null, columnKey.getBytes("UTF-8"));
-        }
-
-        try
-        {
-            RowMutation rm = new RowMutation(cfMetaData_.tableName, (String)(rowKey_.get()));
-            rm.add(path, ((String)value_.get()).getBytes(), System.currentTimeMillis());
-            StorageProxy.insert(rm);
-        }
-        catch (Exception e)
-        {
-            logger_.error(LogUtil.throwableToString(e));
-            throw new RuntimeException(RuntimeErrorMsg.GENERIC_ERROR.getMsg());            
-        }
-        return null;
-    }
-
-    public String explainPlan()
-    {
-        return
-            String.format("%s Column Family: Unique Key SET: \n" +
-                "   Table Name:     %s\n" +
-                "   Column Famly:   %s\n" +
-                "   RowKey:         %s\n" +
-                "%s" +
-                "   ColumnKey:      %s\n" +
-                "   Value:          %s\n",
-                cfMetaData_.columnType,
-                cfMetaData_.tableName,
-                cfMetaData_.cfName,
-                rowKey_.explain(),
-                (superColumnKey_ == null) ? "" : "   SuperColumnKey: " + superColumnKey_.explain() + "\n",                
-                columnKey_.explain(),
-                value_.explain());
-    }
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SuperColumnMapExpr.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SuperColumnMapExpr.java
index 57f6d276..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SuperColumnMapExpr.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SuperColumnMapExpr.java
@@ -1,25 +0,0 @@
-/* Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-import java.util.ArrayList;
-
-public class SuperColumnMapExpr extends ArrayList<Pair<OperandDef, ColumnMapExpr>>
-{
-    private static final long serialVersionUID = 1L;
-};
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SuperColumnRangeQueryRSD.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SuperColumnRangeQueryRSD.java
index 3e4aee3a..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SuperColumnRangeQueryRSD.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/SuperColumnRangeQueryRSD.java
@@ -1,122 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.Map;
-import java.util.List;
-import java.io.UnsupportedEncodingException;
-
-import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.cql.execution.RuntimeErrorMsg;
-import org.apache.cassandra.db.*;
-import org.apache.cassandra.db.filter.QueryPath;
-import org.apache.cassandra.service.ConsistencyLevel;
-import org.apache.cassandra.service.StorageProxy;
-import org.apache.cassandra.service.StorageService;
-import org.apache.cassandra.utils.LogUtil;
-import org.apache.log4j.Logger;
-import org.apache.commons.lang.ArrayUtils;
-
-/**
- * A Row Source Definition (RSD) for doing a super column range query on a Super Column Family.
- */
-public class SuperColumnRangeQueryRSD extends RowSourceDef
-{
-    private final static Logger logger_ = Logger.getLogger(SuperColumnRangeQueryRSD.class);
-    private CFMetaData cfMetaData_;
-    private OperandDef rowKey_;
-    private int        limit_;
-
-    /**
-     * Set up a range query on super column map in a super column family.
-     * The super column map is identified by the rowKey.
-     * 
-     * Note: "limit" of -1 is the equivalent of no limit.
-     *       "offset" specifies the number of rows to skip.
-     *        An offset of 0 implies from the first row.
-     */
-    public SuperColumnRangeQueryRSD(CFMetaData cfMetaData, OperandDef rowKey, int limit)
-    {
-        cfMetaData_     = cfMetaData;
-        rowKey_         = rowKey;
-        limit_          = limit;
-    }
-
-    public List<Map<String,String>> getRows() throws UnsupportedEncodingException
-    {
-        Row row = null;
-        try
-        {
-            String key = (String)(rowKey_.get());
-            ReadCommand readCommand = new SliceFromReadCommand(cfMetaData_.tableName, key, new QueryPath(cfMetaData_.cfName), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, true, limit_);
-            row = StorageProxy.readProtocol(readCommand, ConsistencyLevel.ONE);
-        }
-        catch (Exception e)
-        {
-            logger_.error(LogUtil.throwableToString(e));
-            throw new RuntimeException(RuntimeErrorMsg.GENERIC_ERROR.getMsg());
-        }
-
-        List<Map<String, String>> rows = new LinkedList<Map<String, String>>();
-        if (row != null)
-        {
-            ColumnFamily cfamily = row.getColumnFamily(cfMetaData_.cfName);
-            if (cfamily != null)
-            {
-                Collection<IColumn> columns = cfamily.getSortedColumns();
-                if (columns != null && columns.size() > 0)
-                {
-                    for (IColumn column : columns)
-                    {
-                        Collection<IColumn> subColumns = column.getSubColumns();
-                        for( IColumn subColumn : subColumns )
-                        {
-                           Map<String, String> result = new HashMap<String, String>();
-                           result.put(cfMetaData_.n_superColumnKey, new String(column.name(), "UTF-8"));
-                           result.put(cfMetaData_.n_columnKey, new String(subColumn.name(), "UTF-8"));
-                           result.put(cfMetaData_.n_columnValue, new String(subColumn.value()));
-                           result.put(cfMetaData_.n_columnTimestamp, Long.toString(subColumn.timestamp()));
-                           rows.add(result);
-                        }
-                    }
-                }
-            }
-        }
-        return rows;
-    }
-
-    public String explainPlan()
-    {
-        return String.format("%s Column Family: Super Column Range Query: \n" +
-                "  Table Name:       %s\n" +
-                "  Column Family:    %s\n" +
-                "  RowKey:           %s\n" +
-                "  Limit:            %d\n" +
-                "  Order By:         %s",
-                cfMetaData_.columnType,
-                cfMetaData_.tableName,
-                cfMetaData_.cfName,
-                rowKey_.explain(),
-                limit_,
-                cfMetaData_.comparator);
-    }
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/UniqueKeyQueryRSD.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/UniqueKeyQueryRSD.java
index a763215f..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/UniqueKeyQueryRSD.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/UniqueKeyQueryRSD.java
@@ -1,157 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-import java.util.*;
-import java.io.UnsupportedEncodingException;
-
-import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.cql.execution.RuntimeErrorMsg;
-import org.apache.cassandra.db.*;
-import org.apache.cassandra.db.filter.QueryPath;
-import org.apache.cassandra.service.ConsistencyLevel;
-import org.apache.cassandra.service.StorageProxy;
-import org.apache.cassandra.service.StorageService;
-import org.apache.cassandra.utils.LogUtil;
-import org.apache.log4j.Logger;
-
-/**
- * A Row Source Defintion (RSD) for looking up a unique column within a column family.
- */
-public class UniqueKeyQueryRSD extends RowSourceDef
-{
-    private final static Logger logger_ = Logger.getLogger(UniqueKeyQueryRSD.class);    
-    private CFMetaData cfMetaData_;
-    private OperandDef rowKey_;
-    private OperandDef superColumnKey_;
-    private OperandDef columnKey_;
-
-    // super column family
-    public UniqueKeyQueryRSD(CFMetaData cfMetaData, OperandDef rowKey, OperandDef superColumnKey, OperandDef columnKey)
-    {
-        cfMetaData_     = cfMetaData;
-        rowKey_         = rowKey;
-        superColumnKey_ = superColumnKey;
-        columnKey_      = columnKey;
-    }
-
-    // simple column family
-    public UniqueKeyQueryRSD(CFMetaData cfMetaData, OperandDef rowKey, OperandDef columnKey)
-    {
-        cfMetaData_ = cfMetaData;
-        rowKey_     = rowKey;
-        columnKey_  = columnKey;
-        superColumnKey_ = null;
-    }
-
-    // specific column lookup
-    public List<Map<String,String>> getRows() throws UnsupportedEncodingException
-    {
-        String columnKey = (String)(columnKey_.get());
-        QueryPath path = null;
-        String superColumnKey = null;
-
-        if (superColumnKey_ != null)
-        {
-            superColumnKey = (String)(superColumnKey_.get());
-            path = new QueryPath(cfMetaData_.cfName, superColumnKey.getBytes("UTF-8"));
-        }
-        else
-        {
-            path = new QueryPath(cfMetaData_.cfName);
-        }
-
-        Row row = null;
-        try
-        {
-            String key = (String)(rowKey_.get());
-            ReadCommand readCommand = new SliceByNamesReadCommand(cfMetaData_.tableName, key, path, Arrays.asList(columnKey.getBytes("UTF-8")));
-            row = StorageProxy.readProtocol(readCommand, ConsistencyLevel.ONE);
-        }
-        catch (Exception e)
-        {
-            logger_.error(LogUtil.throwableToString(e));
-            throw new RuntimeException(RuntimeErrorMsg.GENERIC_ERROR.getMsg());
-        }
-
-        if (row != null)
-        {
-            ColumnFamily cfamily = row.getColumnFamily(cfMetaData_.cfName);
-            if (cfamily != null)
-            {
-                Collection<IColumn> columns = null;
-                if (superColumnKey_ != null)
-                {
-                    // this is the super column case
-                    IColumn column = cfamily.getColumn(superColumnKey.getBytes("UTF-8"));
-                    if (column != null)
-                        columns = column.getSubColumns();
-                }
-                else
-                {
-                    columns = cfamily.getSortedColumns();
-                }
-
-                if (columns != null && columns.size() > 0)
-                {
-                    if (columns.size() > 1)
-                    {
-                        // We are looking up by a rowKey & columnKey. There should
-                        // be at most one column that matches. If we find more than
-                        // one, then it is an internal error.
-                        throw new RuntimeException(RuntimeErrorMsg.INTERNAL_ERROR.getMsg("Too many columns found for: " + columnKey));
-                    }
-                    for (IColumn column : columns)
-                    {
-                        List<Map<String, String>> rows = new LinkedList<Map<String, String>>();
-
-                        Map<String, String> result = new HashMap<String, String>();
-                        result.put(cfMetaData_.n_columnKey, new String(column.name(), "UTF-8"));
-                        result.put(cfMetaData_.n_columnValue, new String(column.value()));
-                        result.put(cfMetaData_.n_columnTimestamp, Long.toString(column.timestamp()));
-
-                        rows.add(result);
-
-                        // at this point, due to the prior checks, we are guaranteed that
-                        // there is only one item in "columns".
-                        return rows;
-                    }
-                    return null;
-                }
-            }
-        }
-        throw new RuntimeException(RuntimeErrorMsg.NO_DATA_FOUND.getMsg());
-    }
-
-    public String explainPlan()
-    {
-        return String.format("%s Column Family: Unique Key Query: \n" +
-                "   Table Name:     %s\n" +
-                "   Column Famly:   %s\n" +
-                "   RowKey:         %s\n" +
-                "%s" +
-                "   ColumnKey:      %s",
-                cfMetaData_.columnType,
-                cfMetaData_.tableName,
-                cfMetaData_.cfName,
-                rowKey_.explain(),
-                (superColumnKey_ == null) ? "" : "   SuperColumnKey: " + superColumnKey_.explain() + "\n",                
-                columnKey_.explain());
-    }
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/Utils.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/Utils.java
index e030d84e..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/Utils.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/common/Utils.java
@@ -1,62 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.common;
-
-public class Utils
-{
-    /*
-     * Strips leading and trailing "'" characters, and handles
-     * and escaped characters such as \n, \r, etc.
-     * [Shameless clone from hive.]
-     */
-    public static String unescapeSQLString(String b) 
-    {
-        assert(b.charAt(0) == '\'');
-        assert(b.charAt(b.length()-1) == '\'');
-        StringBuilder sb = new StringBuilder(b.length());
-        
-        for (int i=1; i+1<b.length(); i++)
-        {
-            if (b.charAt(i) == '\\' && i+2<b.length())
-            {
-                char n=b.charAt(i+1);
-                switch(n)
-                {
-                case '0': sb.append("\0"); break;
-                case '\'': sb.append("'"); break;
-                case '"': sb.append("\""); break;
-                case 'b': sb.append("\b"); break;
-                case 'n': sb.append("\n"); break;
-                case 'r': sb.append("\r"); break;
-                case 't': sb.append("\t"); break;
-                case 'Z': sb.append("\u001A"); break;
-                case '\\': sb.append("\\"); break;
-                case '%': sb.append("%"); break;
-                case '_': sb.append("_"); break;
-                default: sb.append(n);
-                }
-            } 
-            else
-            {
-                sb.append(b.charAt(i));
-            }
-        }
-        return sb.toString();
-    } 
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/common/CompilerErrorMsg.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/common/CompilerErrorMsg.java
index 73927e53..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/common/CompilerErrorMsg.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/common/CompilerErrorMsg.java
@@ -1,70 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.cassandra.cql.compiler.common;
-
-import org.antlr.runtime.tree.CommonTree;
-
-/**
- * List of error messages thrown by the CQL Compiler
- **/
-
-public enum CompilerErrorMsg
-{
-    // Error messages with String.format() style format specifiers
-    GENERIC_ERROR("CQL Compilation Error"),
-    INTERNAL_ERROR("CQL Compilation Internal Error"),
-    INVALID_TABLE("Table '%s' does not exist"),
-    INVALID_COLUMN_FAMILY("Column Family '%s' not found in table '%s'"),
-    TOO_MANY_DIMENSIONS("Too many dimensions specified for %s Column Family"),
-    INVALID_TYPE("Expression is of invalid type")
-    ;
-
-    private String mesg;
-    CompilerErrorMsg(String mesg)
-    {
-        this.mesg = mesg;
-    }
-    
-    private static String getLineAndPosition(CommonTree tree) 
-    {
-        if (tree.getChildCount() == 0)
-        {
-            return tree.getToken().getLine() + ":" + tree.getToken().getCharPositionInLine();
-        }
-        return getLineAndPosition((CommonTree)tree.getChild(0));
-    }
-
-    // Returns the formatted error message. Derives line/position information
-    // from the "tree" node passed in.
-    public String getMsg(CommonTree tree, Object... args)
-    {
-        // We allocate another array since we want to add line and position as an 
-        // implicit additional first argument to pass on to String.format.
-        Object[] newArgs = new Object[args.length + 1];
-        newArgs[0] = getLineAndPosition(tree);
-        System.arraycopy(args, 0, newArgs, 1, args.length);
-
-        // note: mesg itself might contain other format specifiers...
-        return String.format("line %s " + mesg, newArgs);
-    } 
-
-    String getMsg()
-    {
-        return mesg;
-    } 
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/common/CqlCompiler.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/common/CqlCompiler.java
index b5414736..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/common/CqlCompiler.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/common/CqlCompiler.java
@@ -1,149 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.compiler.common;
-
-
-import org.apache.cassandra.cql.common.*;
-import org.apache.cassandra.cql.compiler.parse.*;
-import org.apache.cassandra.cql.compiler.sem.*;
-
-import java.util.ArrayList;
-
-import org.antlr.runtime.*;
-import org.antlr.runtime.tree.*;
-import org.apache.cassandra.cql.common.Plan;
-import org.apache.cassandra.cql.compiler.parse.CqlLexer;
-import org.apache.cassandra.cql.compiler.parse.CqlParser;
-import org.apache.cassandra.cql.compiler.parse.ParseError;
-import org.apache.cassandra.cql.compiler.parse.ParseException;
-import org.apache.cassandra.cql.compiler.sem.SemanticException;
-import org.apache.cassandra.cql.compiler.sem.SemanticPhase;
-
-public class CqlCompiler
-{
-    // ANTLR does not provide case-insensitive tokenization support
-    // out of the box. So we override the LA (lookahead) function
-    // of the ANTLRStringStream class. Note: This doesn't change the
-    // token text-- but just relaxes the matching rules to match
-    // in upper case. [Logic borrowed from Hive code.]
-    // 
-    // Also see discussion on this topic in:
-    // http://www.antlr.org/wiki/pages/viewpage.action?pageId=1782.
-    public class ANTLRNoCaseStringStream  extends ANTLRStringStream
-    {
-        public ANTLRNoCaseStringStream(String input)
-        {
-            super(input);
-        }
-    
-        public int LA(int i)
-        {
-            int returnChar = super.LA(i);
-            if (returnChar == CharStream.EOF)
-            {
-                return returnChar; 
-            }
-            else if (returnChar == 0) 
-            {
-                return returnChar;
-            }
-
-            return Character.toUpperCase((char)returnChar);
-        }
-    }
-
-    // Override CQLParser. This gives flexibility in altering default error
-    // messages as well as accumulating multiple errors.
-    public class CqlParserX extends CqlParser
-    {
-        private ArrayList<ParseError> errors;
-
-        public CqlParserX(TokenStream input)
-        {
-            super(input);
-            errors = new ArrayList<ParseError>();
-        }
-
-        protected void mismatch(IntStream input, int ttype, BitSet follow) throws RecognitionException
-        {
-            throw new MismatchedTokenException(ttype, input);
-        }
-
-        public Object recoverFromMismatchedSet(IntStream input,
-                                             RecognitionException re,
-                                             BitSet follow) throws RecognitionException
-        {
-            throw re;
-        }
-
-        public void displayRecognitionError(String[] tokenNames,
-                                            RecognitionException e)
-        {
-            errors.add(new ParseError(this, e, tokenNames));
-        }
-
-        public ArrayList<ParseError> getErrors()
-        {
-            return errors;
-        }
-    }
-
-    // Compile a CQL query
-    public Plan compileQuery(String query) throws ParseException, SemanticException
-    {
-        CommonTree queryTree = null;
-        CqlLexer lexer = null;
-        CqlParserX parser = null;
-        CommonTokenStream tokens = null;
-
-        ANTLRStringStream input = new ANTLRNoCaseStringStream(query);
-
-        lexer = new CqlLexer(input);
-        tokens = new CommonTokenStream(lexer);
-        parser = new CqlParserX(tokens);
-
-        // built AST
-        try
-        {
-            queryTree = (CommonTree)(parser.root().getTree());
-        }
-        catch (RecognitionException e)
-        {
-            throw new ParseException(parser.getErrors());            
-        }
-        catch (RewriteEmptyStreamException e)
-        {
-            throw new ParseException(parser.getErrors());            
-        }
-
-        if (!parser.getErrors().isEmpty())
-        {
-            throw new ParseException(parser.getErrors());
-        }
-
-        if (!parser.errors.isEmpty())
-        {
-            throw new ParseException("parser error");
-        }
-
-        // Semantic analysis and code-gen.
-        // Eventually, I anticipate, I'll be forking these off into two separate phases.
-        return SemanticPhase.doSemanticAnalysis(queryTree);
-    }
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/parse/ParseError.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/parse/ParseError.java
index d5baa642..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/parse/ParseError.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/parse/ParseError.java
@@ -1,50 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.compiler.parse;
-
-import org.antlr.runtime.*;
-
-public class ParseError {
-  private BaseRecognizer br;
-  private RecognitionException re;
-  private String[] tokenNames;
-  
-  public ParseError(BaseRecognizer br, RecognitionException re, String[] tokenNames) {
-    this.br = br;
-    this.re = re;
-    this.tokenNames = tokenNames;
-    }
-  
-  public BaseRecognizer getBaseRecognizer() {
-    return br;
-  }
-
-  public RecognitionException getRecognitionException() {
-    return re;
-  }
-  
-  public String[] getTokenNames() {
-    return tokenNames;
-  }
-
-  public String getMessage() {
-    return br.getErrorHeader(re) + " " + br.getErrorMessage(re, tokenNames);
-  }
-
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/parse/ParseException.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/parse/ParseException.java
index d89ce28d..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/parse/ParseException.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/parse/ParseException.java
@@ -1,57 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.compiler.parse;
-
-/**
- * Exception from the CQL Parser
- */
-
-import java.util.ArrayList;
-
-public class ParseException extends Exception {
-
-    private static final long serialVersionUID = 1L;
-    ArrayList<ParseError> errors = null;
-
-    public ParseException(ArrayList<ParseError> errors)
-    {
-      super();
-      this.errors = errors;
-    }
-
-    public ParseException(String message)
-    {
-        super(message);
-    }
-
-    public String getMessage() {
-
-      if (errors == null)
-          return super.getMessage();
-
-      StringBuilder sb = new StringBuilder();
-      for(ParseError err: errors) {
-        sb.append(err.getMessage());
-        sb.append("\n");
-      }
-
-      return sb.toString();
-    }
-
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/sem/SemanticException.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/sem/SemanticException.java
index 72a17f64..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/sem/SemanticException.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/sem/SemanticException.java
@@ -1,49 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.compiler.sem;
-
-
-/**
- * Exception from the CQL SemanticAnalyzer
- */
-
-public class SemanticException extends Exception
-{
-    private static final long serialVersionUID = 1L;
-
-    public SemanticException()
-    {
-        super();
-    }
-    
-    public SemanticException(String message)
-    {
-        super(message);
-    }
-    
-    public SemanticException(Throwable cause)
-    {
-        super(cause);
-    }
-    
-    public SemanticException(String message, Throwable cause)
-    {
-        super(message, cause);
-    }
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/sem/SemanticPhase.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/sem/SemanticPhase.java
index 60e5158b..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/sem/SemanticPhase.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/compiler/sem/SemanticPhase.java
@@ -1,343 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.cql.compiler.sem;
-
-import java.util.Map;
-
-import org.antlr.runtime.tree.CommonTree;
-
-import org.apache.cassandra.cql.common.*;
-import org.apache.cassandra.cql.compiler.common.*;
-import org.apache.cassandra.cql.compiler.parse.*;
-
-import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.config.DatabaseDescriptor;
-import org.apache.cassandra.cql.common.ColumnMapExpr;
-import org.apache.cassandra.cql.common.ColumnRangeQueryRSD;
-import org.apache.cassandra.cql.common.ConstantOperand;
-import org.apache.cassandra.cql.common.ExplainPlan;
-import org.apache.cassandra.cql.common.OperandDef;
-import org.apache.cassandra.cql.common.Pair;
-import org.apache.cassandra.cql.common.Plan;
-import org.apache.cassandra.cql.common.QueryPlan;
-import org.apache.cassandra.cql.common.RowSourceDef;
-import org.apache.cassandra.cql.common.SetColumnMap;
-import org.apache.cassandra.cql.common.SetSuperColumnMap;
-import org.apache.cassandra.cql.common.SetUniqueKey;
-import org.apache.cassandra.cql.common.SuperColumnMapExpr;
-import org.apache.cassandra.cql.common.SuperColumnRangeQueryRSD;
-import org.apache.cassandra.cql.common.UniqueKeyQueryRSD;
-import org.apache.cassandra.cql.common.Utils;
-import org.apache.cassandra.cql.compiler.common.CompilerErrorMsg;
-import org.apache.cassandra.cql.compiler.parse.CqlParser;
-import org.apache.log4j.Logger;
-
-//
-// Note: This class is CQL related work in progress.
-//
-// Currently, this phase combines both semantic analysis and code-gen.
-// I expect that as my ideas get refined/cleared up, I'll be drawing
-// a more clear distinction between semantic analysis phase and code-gen.
-//
-public class SemanticPhase
-{
-    private final static Logger logger_ = Logger.getLogger(SemanticPhase.class);    
-
-    // Current code-gen also happens in this phase!
-    public static Plan doSemanticAnalysis(CommonTree ast) throws SemanticException
-    {
-        Plan plan = null;
-
-        if (logger_.isDebugEnabled())
-            logger_.debug("AST: " + ast.toStringTree());
-
-        switch (ast.getType())
-        {
-        case CqlParser.A_GET:
-            plan = compileGet(ast);
-            break;
-        case CqlParser.A_SET:
-            plan = compileSet(ast);
-            break;
-        case CqlParser.A_DELETE:
-            compileDelete(ast);
-            break;
-        case CqlParser.A_SELECT:
-            compileSelect(ast);
-            break;
-        case CqlParser.A_EXPLAIN_PLAN:
-            // Case: EXPLAN PLAN <stmt>
-            // first, generate a plan for <stmt>
-            // and then, wrapper it with a special ExplainPlan plan
-            // whose execution will result in an explain plan rather
-            // than a normal execution of the statement.
-            plan = doSemanticAnalysis((CommonTree)(ast.getChild(0)));
-            plan = new ExplainPlan(plan);
-            break;
-        default:
-            // Unhandled AST node. Raise an internal error. 
-            throw new SemanticException(CompilerErrorMsg.INTERNAL_ERROR.getMsg(ast, "Unknown Node Type: " + ast.getType()));
-        }
-        return plan;
-    }
-
-    /** 
-     * Given a CommonTree AST node of type, A_COLUMN_ACCESS related functions, do semantic
-     * checking to ensure table name, column family name, and number of key dimensions
-     * specified are all valid. 
-     */
-    private static CFMetaData getColumnFamilyInfo(CommonTree ast) throws SemanticException
-    {
-        assert(ast.getType() == CqlParser.A_COLUMN_ACCESS);
-
-        CommonTree columnFamilyNode = (CommonTree)(ast.getChild(1)); 
-        CommonTree tableNode = (CommonTree)(ast.getChild(0));
-
-        String columnFamily = columnFamilyNode.getText();
-        String table = tableNode.getText();
-
-        Map<String, CFMetaData> columnFamilies = DatabaseDescriptor.getTableMetaData(table);
-        if (columnFamilies == null)
-        {
-            throw new SemanticException(CompilerErrorMsg.INVALID_TABLE.getMsg(ast, table));
-        }
-
-        CFMetaData cfMetaData = columnFamilies.get(columnFamily);
-        if (cfMetaData == null)
-        {
-            throw new SemanticException(CompilerErrorMsg.INVALID_COLUMN_FAMILY.getMsg(ast, columnFamily, table));
-        }
-
-        // Once you have drilled down to a row using a rowKey, a super column
-        // map can be indexed only 2 further levels deep; and a column map may
-        // be indexed up to 1 level deep.
-        int dimensions = numColumnDimensions(ast);
-        if (("Super".equals(cfMetaData.columnType) && (dimensions > 2)) ||
-            ("Standard".equals(cfMetaData.columnType) && dimensions > 1))
-        {
-            throw new SemanticException(CompilerErrorMsg.TOO_MANY_DIMENSIONS.getMsg(ast, cfMetaData.columnType));
-        }
-
-        return cfMetaData; 
-    }
-
-    private static String getRowKey(CommonTree ast)
-    {
-        assert(ast.getType() == CqlParser.A_COLUMN_ACCESS);
-        return Utils.unescapeSQLString(ast.getChild(2).getText());
-    }
-
-    private static int numColumnDimensions(CommonTree ast)
-    {
-        // Skip over table name, column family and rowKey
-        return ast.getChildCount() - 3;
-    }
-
-    // Returns the pos'th (0-based index) column specifier in the astNode
-    private static String getColumn(CommonTree ast, int pos)
-    {
-        // Skip over table name, column family and rowKey
-        return Utils.unescapeSQLString(ast.getChild(pos + 3).getText()); 
-    }
-
-    // Compile a GET statement
-    private static Plan compileGet(CommonTree ast) throws SemanticException
-    {
-        int childCount = ast.getChildCount();
-        assert(childCount == 1);
-
-        CommonTree columnFamilySpec = (CommonTree)ast.getChild(0);
-        assert(columnFamilySpec.getType() == CqlParser.A_COLUMN_ACCESS);
-
-        CFMetaData cfMetaData = getColumnFamilyInfo(columnFamilySpec);
-        ConstantOperand rowKey = new ConstantOperand(getRowKey(columnFamilySpec));
-        int dimensionCnt = numColumnDimensions(columnFamilySpec);
-
-        RowSourceDef rwsDef;
-        if ("Super".equals(cfMetaData.columnType))
-        {
-            if (dimensionCnt > 2)
-            {
-                // We don't expect this case to arise, since Cql.g grammar disallows this.
-                // therefore, raise this case as an "internal error".
-                throw new SemanticException(CompilerErrorMsg.INTERNAL_ERROR.getMsg(columnFamilySpec));
-            }
-
-            if (dimensionCnt == 2)
-            {
-                // Case: table.super_cf[<rowKey>][<superColumnKey>][<columnKey>]
-                ConstantOperand superColumnKey = new ConstantOperand(getColumn(columnFamilySpec, 0));                
-                ConstantOperand columnKey = new ConstantOperand(getColumn(columnFamilySpec, 1));
-                rwsDef = new UniqueKeyQueryRSD(cfMetaData, rowKey, superColumnKey, columnKey);
-            }
-            else if (dimensionCnt == 1)
-            {
-                // Case: table.super_cf[<rowKey>][<superColumnKey>]
-                ConstantOperand superColumnKey = new ConstantOperand(getColumn(columnFamilySpec, 0));                
-                rwsDef = new ColumnRangeQueryRSD(cfMetaData, rowKey, superColumnKey, Integer.MAX_VALUE);
-            }
-            else
-            {
-                // Case: table.super_cf[<rowKey>]             
-                rwsDef = new SuperColumnRangeQueryRSD(cfMetaData, rowKey, Integer.MAX_VALUE);
-            }
-        }
-        else  // Standard Column Family
-        {
-            if (dimensionCnt == 1)
-            {
-                // Case: table.standard_cf[<rowKey>][<columnKey>]
-                ConstantOperand columnKey = new ConstantOperand(getColumn(columnFamilySpec, 0));
-                rwsDef = new UniqueKeyQueryRSD(cfMetaData, rowKey, columnKey);
-            }
-            else
-            {
-                // Case: table.standard_cf[<rowKey>]
-                logger_.assertLog((dimensionCnt == 0), "invalid dimensionCnt: " + dimensionCnt);
-                rwsDef = new ColumnRangeQueryRSD(cfMetaData, rowKey, Integer.MAX_VALUE);
-            }
-        }
-        return new QueryPlan(rwsDef);
-    }
-    
-    private static OperandDef  getSimpleExpr(CommonTree ast) throws SemanticException
-    {
-        int type = ast.getType();
-
-        // for now, the only simple expressions support are of string type
-        if (type != CqlParser.StringLiteral)
-        {
-            throw new SemanticException(CompilerErrorMsg.INVALID_TYPE.getMsg(ast));
-        }
-        return new ConstantOperand(Utils.unescapeSQLString(ast.getText()));
-    }
-
-    private static ColumnMapExpr getColumnMapExpr(CommonTree ast) throws SemanticException
-    {
-        int type = ast.getType();
-        if (type != CqlParser.A_COLUMN_MAP_VALUE)
-        {
-            throw new SemanticException(CompilerErrorMsg.INVALID_TYPE.getMsg(ast));
-        }
-        
-        int size = ast.getChildCount();
-        ColumnMapExpr result = new ColumnMapExpr();
-        for (int idx = 0; idx < size; idx++)
-        {
-            CommonTree entryNode = (CommonTree)(ast.getChild(idx));
-            OperandDef columnKey   = getSimpleExpr((CommonTree)(entryNode.getChild(0)));
-            OperandDef columnValue = getSimpleExpr((CommonTree)(entryNode.getChild(1)));            
-
-            Pair<OperandDef, OperandDef> entry = new Pair<OperandDef, OperandDef>(columnKey, columnValue);
-            result.add(entry);
-        }
-        return result;
-    }
-
-    private static SuperColumnMapExpr getSuperColumnMapExpr(CommonTree ast) throws SemanticException
-    {
-        int type = ast.getType();        
-        if (type != CqlParser.A_SUPERCOLUMN_MAP_VALUE)
-        {
-            throw new SemanticException(CompilerErrorMsg.INVALID_TYPE.getMsg(ast));
-        }
-        int size = ast.getChildCount();
-        SuperColumnMapExpr result = new SuperColumnMapExpr();
-        for (int idx = 0; idx < size; idx++)
-        {
-            CommonTree entryNode = (CommonTree)(ast.getChild(idx));
-            OperandDef    superColumnKey = getSimpleExpr((CommonTree)(entryNode.getChild(0)));
-            ColumnMapExpr columnMapExpr  = getColumnMapExpr((CommonTree)(entryNode.getChild(1)));            
-
-            Pair<OperandDef, ColumnMapExpr> entry = new Pair<OperandDef, ColumnMapExpr>(superColumnKey, columnMapExpr);
-            result.add(entry);
-        }
-        return result;
-    }
-
-    // compile a SET statement
-    private static Plan compileSet(CommonTree ast) throws SemanticException
-    {
-        int childCount = ast.getChildCount();
-        assert(childCount == 2);
-
-        CommonTree columnFamilySpec = (CommonTree)ast.getChild(0);
-        assert(columnFamilySpec.getType() == CqlParser.A_COLUMN_ACCESS);
-
-        CFMetaData cfMetaData = getColumnFamilyInfo(columnFamilySpec);
-        ConstantOperand rowKey = new ConstantOperand(getRowKey(columnFamilySpec));
-        int dimensionCnt = numColumnDimensions(columnFamilySpec);
-
-        CommonTree  valueNode = (CommonTree)(ast.getChild(1));
-
-        Plan plan = null;
-        if ("Super".equals(cfMetaData.columnType))
-        {
-            if (dimensionCnt == 2)
-            {
-                // Case: set table.super_cf['key']['supercolumn']['column'] = 'value'
-                OperandDef value = getSimpleExpr(valueNode);
-                ConstantOperand superColumnKey = new ConstantOperand(getColumn(columnFamilySpec, 0));
-                ConstantOperand columnKey = new ConstantOperand(getColumn(columnFamilySpec, 1));
-                plan = new SetUniqueKey(cfMetaData, rowKey, superColumnKey, columnKey, value);
-            }
-            else if (dimensionCnt == 1)
-            {
-                // Case: set table.super_cf['key']['supercolumn'] = <column_map>;
-                ColumnMapExpr columnMapExpr = getColumnMapExpr(valueNode);                
-                ConstantOperand superColumnKey = new ConstantOperand(getColumn(columnFamilySpec, 0));
-                plan = new SetColumnMap(cfMetaData, rowKey, superColumnKey, columnMapExpr);
-            }
-            else
-            {
-                // Case: set table.super_cf['key'] = <super_column_map>;
-                logger_.assertLog(dimensionCnt == 0, "invalid dimensionCnt: " + dimensionCnt);
-                SuperColumnMapExpr superColumnMapExpr = getSuperColumnMapExpr(valueNode);                
-                plan = new SetSuperColumnMap(cfMetaData, rowKey, superColumnMapExpr);
-            }
-        }
-        else  // Standard column family
-        {
-            if (dimensionCnt == 1)
-            {
-                // Case: set table.standard_cf['key']['column'] = 'value'
-                OperandDef value = getSimpleExpr(valueNode);                
-                ConstantOperand columnKey = new ConstantOperand(getColumn(columnFamilySpec, 0));
-                plan = new SetUniqueKey(cfMetaData, rowKey, columnKey, value);
-            } 
-            else
-            {
-                // Case: set table.standard_cf['key'] = <column_map>;
-                logger_.assertLog(dimensionCnt == 0, "invalid dimensionCnt: " + dimensionCnt);
-                ColumnMapExpr columnMapExpr = getColumnMapExpr(valueNode);                
-                plan = new SetColumnMap(cfMetaData, rowKey, columnMapExpr);
-            }
-        }
-        return plan;
-    }
-
-    private static void compileSelect(CommonTree ast) throws SemanticException
-    {
-        // stub; tbd.
-    }
-    private static void compileDelete(CommonTree ast) throws SemanticException
-    {
-        // stub; tbd.
-    }
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/driver/CqlDriver.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/driver/CqlDriver.java
index 63c0c207..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/driver/CqlDriver.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/driver/CqlDriver.java
@@ -1,70 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.cassandra.cql.driver;
-
-import org.apache.cassandra.cql.common.CqlResult;
-import org.apache.cassandra.cql.common.Plan;
-import org.apache.cassandra.cql.compiler.common.CqlCompiler;
-import org.apache.cassandra.cql.compiler.parse.ParseException;
-import org.apache.cassandra.cql.compiler.sem.SemanticException;
-import org.apache.cassandra.utils.LogUtil;
-import org.apache.log4j.Logger;
-
-// Server side driver class for CQL
-public class CqlDriver 
-{
-    private final static Logger logger_ = Logger.getLogger(CqlDriver.class);
-
-    // Execute a CQL Statement 
-    public static CqlResult executeQuery(String query)
-    {
-        CqlCompiler compiler = new CqlCompiler();
-
-        try
-        {
-            if (logger_.isDebugEnabled())
-                logger_.debug("Compiling CQL query ...");
-            Plan plan = compiler.compileQuery(query);
-            if (plan != null)
-            {
-                if (logger_.isDebugEnabled())
-                    logger_.debug("Executing CQL query ...");            
-                return plan.execute();
-            }
-        }
-        catch (Exception e)
-        {
-            CqlResult result = new CqlResult(null);
-            result.errorTxt = e.getMessage();           
-
-            Class<? extends Exception> excpClass = e.getClass();
-            if ((excpClass != SemanticException.class)
-                && (excpClass != ParseException.class)
-                && (excpClass != RuntimeException.class))
-            {
-                result.errorTxt = "CQL Internal Error: " + result.errorTxt;
-                result.errorCode = 1; // failure
-                logger_.error(LogUtil.throwableToString(e));
-            }
-
-            return result;
-        }
-
-        return null;
-    }
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/execution/RuntimeErrorMsg.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/execution/RuntimeErrorMsg.java
index 8e066dc6..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/execution/RuntimeErrorMsg.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/cql/execution/RuntimeErrorMsg.java
@@ -1,44 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.cassandra.cql.execution;
-
-/**
- * List of error messages thrown by CQL's Execution Layer
- **/
-public enum RuntimeErrorMsg
-{
-    // Error messages with String.format() style format specifiers
-    GENERIC_ERROR("CQL Execution Error"),
-    INTERNAL_ERROR("CQL Internal Error: %s"),
-    IMPLEMENTATION_RESTRICTION("Implementation Restriction: %s"),
-    NO_DATA_FOUND("No data found")
-    ;
-
-    private String mesg;
-    RuntimeErrorMsg(String mesg) 
-    {
-        this.mesg = mesg;
-    }
-
-    // Returns the formatted error message. 
-    public String getMsg(Object... args)
-    {
-        // note: mesg itself might contain other format specifiers...
-        return String.format(mesg, args);
-    }
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/CassandraServer.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/CassandraServer.java
index b41f9ecd..6db09daa 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/CassandraServer.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/CassandraServer.java
@@ -30,8 +30,6 @@
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.DatabaseDescriptor;
-import org.apache.cassandra.cql.common.CqlResult;
-import org.apache.cassandra.cql.driver.CqlDriver;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.db.filter.QueryPath;
@@ -471,22 +469,6 @@ else if (propertyName.equals("version"))
         return columnFamiliesMap;
     }
 
-    public org.apache.cassandra.service.CqlResult execute_query(String query) throws TException
-    {
-        org.apache.cassandra.service.CqlResult result = new org.apache.cassandra.service.CqlResult();
-
-        CqlResult cqlResult = CqlDriver.executeQuery(query);
-        
-        // convert CQL result type to Thrift specific return type
-        if (cqlResult != null)
-        {
-            result.error_txt = cqlResult.errorTxt;
-            result.result_set = cqlResult.resultSet;
-            result.error_code = cqlResult.errorCode;
-        }
-        return result;
-    }
-
     public List<String> get_key_range(String tablename, String columnFamily, String startWith, String stopAt, int maxResults) throws InvalidRequestException, TException
     {
         if (logger.isDebugEnabled())
