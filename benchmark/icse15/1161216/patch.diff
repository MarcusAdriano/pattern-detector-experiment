diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/AbstractCassandraConnection.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/AbstractCassandraConnection.java
index e69de29b..99d982bb 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/AbstractCassandraConnection.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/AbstractCassandraConnection.java
@@ -0,0 +1,129 @@
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+package org.apache.cassandra.cql.jdbc;
+
+import java.sql.Array;
+import java.sql.Blob;
+import java.sql.CallableStatement;
+import java.sql.Clob;
+import java.sql.NClob;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.sql.SQLFeatureNotSupportedException;
+import java.sql.SQLXML;
+import java.sql.Savepoint;
+import java.sql.Struct;
+import java.util.Map;
+
+public class AbstractCassandraConnection
+{
+    protected static final String NOT_SUPPORTED = "the Cassandra implementation does not support this method";
+
+    public Array createArrayOf(String arg0, Object[] arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Blob createBlob() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Clob createClob() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public NClob createNClob() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public SQLXML createSQLXML() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Struct createStruct(String arg0, Object[] arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Map<String, Class<?>> getTypeMap() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+    
+    public CallableStatement prepareCall(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+    
+    public CallableStatement prepareCall(String arg0, int arg1, int arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public CallableStatement prepareCall(String arg0, int arg1, int arg2, int arg3) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public PreparedStatement prepareStatement(String arg0, int arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public PreparedStatement prepareStatement(String arg0, int[] arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public PreparedStatement prepareStatement(String arg0, String[] arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void releaseSavepoint(Savepoint arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void rollback(Savepoint arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Savepoint setSavepoint() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+    public Savepoint setSavepoint(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+    
+    public void setTypeMap(Map<String, Class<?>> arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+}
diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/AbstractResultSet.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/AbstractResultSet.java
index e69de29b..de16e64f 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/AbstractResultSet.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/AbstractResultSet.java
@@ -0,0 +1,636 @@
+package org.apache.cassandra.cql.jdbc;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+import java.io.InputStream;
+import java.io.Reader;
+import java.math.BigDecimal;
+import java.sql.*;
+import java.util.Map;
+
+/** a class to hold all the unimplemented crap */
+class AbstractResultSet
+{
+    protected static final String NOT_SUPPORTED = "the Cassandra implementation does not support this method";
+
+    public void cancelRowUpdates() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void deleteRow() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Array getArray(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Array getArray(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public InputStream getAsciiStream(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public InputStream getAsciiStream(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public InputStream getBinaryStream(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public InputStream getBinaryStream(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Blob getBlob(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Blob getBlob(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Reader getCharacterStream(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Reader getCharacterStream(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Clob getClob(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Clob getClob(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public String getCursorName() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Reader getNCharacterStream(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Reader getNCharacterStream(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public NClob getNClob(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public NClob getNClob(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public String getNString(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public String getNString(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Object getObject(int arg0, Map<String, Class<?>> arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Object getObject(String arg0, Map<String, Class<?>> arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Ref getRef(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public Ref getRef(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public RowId getRowId(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public SQLXML getSQLXML(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public SQLXML getSQLXML(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public InputStream getUnicodeStream(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public InputStream getUnicodeStream(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void insertRow() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void moveToCurrentRow() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void moveToInsertRow() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void refreshRow() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public boolean rowDeleted() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public boolean rowInserted() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public boolean rowUpdated() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    //
+    // all the update methods are unsupported, requires a separate statement in Cassandra
+    //
+
+    public void updateArray(int arg0, Array arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateArray(String arg0, Array arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateAsciiStream(int arg0, InputStream arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateAsciiStream(int arg0, InputStream arg1, int arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateAsciiStream(int arg0, InputStream arg1, long arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateAsciiStream(String arg0, InputStream arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateAsciiStream(String arg0, InputStream arg1, int arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateAsciiStream(String arg0, InputStream arg1, long arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBigDecimal(int arg0, BigDecimal arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBigDecimal(String arg0, BigDecimal arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBinaryStream(int arg0, InputStream arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBinaryStream(int arg0, InputStream arg1, int arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBinaryStream(int arg0, InputStream arg1, long arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBinaryStream(String arg0, InputStream arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBinaryStream(String arg0, InputStream arg1, int arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBinaryStream(String arg0, InputStream arg1, long arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBlob(int arg0, Blob arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBlob(int arg0, InputStream arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBlob(int arg0, InputStream arg1, long arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBlob(String arg0, Blob arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBlob(String arg0, InputStream arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBlob(String arg0, InputStream arg1, long arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBoolean(int arg0, boolean arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBoolean(String arg0, boolean arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateByte(int arg0, byte arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateByte(String arg0, byte arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBytes(int arg0, byte[] arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateBytes(String arg0, byte[] arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateCharacterStream(int arg0, Reader arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateCharacterStream(int arg0, Reader arg1, int arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateCharacterStream(int arg0, Reader arg1, long arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateCharacterStream(String arg0, Reader arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateCharacterStream(String arg0, Reader arg1, int arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateCharacterStream(String arg0, Reader arg1, long arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateClob(int arg0, Clob arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateClob(int arg0, Reader arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateClob(int arg0, Reader arg1, long arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateClob(String arg0, Clob arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateClob(String arg0, Reader arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateClob(String arg0, Reader arg1, long arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateDate(int arg0, Date arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateDate(String arg0, Date arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateDouble(int arg0, double arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateDouble(String arg0, double arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateFloat(int arg0, float arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateFloat(String arg0, float arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateInt(int arg0, int arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateInt(String arg0, int arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateLong(int arg0, long arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateLong(String arg0, long arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateNCharacterStream(int arg0, Reader arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateNCharacterStream(int arg0, Reader arg1, long arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateNCharacterStream(String arg0, Reader arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateNCharacterStream(String arg0, Reader arg1, long arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateNClob(int arg0, NClob arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateNClob(int arg0, Reader arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateNClob(int arg0, Reader arg1, long arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateNClob(String arg0, NClob arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateNClob(String arg0, Reader arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateNClob(String arg0, Reader arg1, long arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateNString(int arg0, String arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateNString(String arg0, String arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateNull(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateNull(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateObject(int arg0, Object arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateObject(int arg0, Object arg1, int arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateObject(String arg0, Object arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateObject(String arg0, Object arg1, int arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateRef(int arg0, Ref arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateRef(String arg0, Ref arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateRow() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateRowId(int arg0, RowId arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateRowId(String arg0, RowId arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateShort(int arg0, short arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateShort(String arg0, short arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateSQLXML(int arg0, SQLXML arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateSQLXML(String arg0, SQLXML arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateString(int arg0, String arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateString(String arg0, String arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateTime(int arg0, Time arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateTime(String arg0, Time arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateTimestamp(int arg0, Timestamp arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void updateTimestamp(String arg0, Timestamp arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+}
diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/AbstractStatement.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/AbstractStatement.java
index e69de29b..12cc1c11 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/AbstractStatement.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/AbstractStatement.java
@@ -0,0 +1,64 @@
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+package org.apache.cassandra.cql.jdbc;
+
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.SQLFeatureNotSupportedException;
+
+public class AbstractStatement
+{
+    protected static final String NOT_SUPPORTED = "the Cassandra implementation does not support this method";
+
+    public void cancel() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+    
+    public boolean execute(String arg0, int[] arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public boolean execute(String arg0, String[] arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public int executeUpdate(String arg0, int[] arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+    
+    public int executeUpdate(String arg0, String[] arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+    public ResultSet getGeneratedKeys() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+   
+    public void setCursorName(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+}
diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CResultSet.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CResultSet.java
index e69de29b..c5c8bb85 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CResultSet.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CResultSet.java
@@ -0,0 +1,1069 @@
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+package org.apache.cassandra.cql.jdbc;
+
+import static org.apache.cassandra.cql.jdbc.Utils.*;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.sql.*;
+import java.sql.Date;
+import java.util.*;
+
+import org.apache.cassandra.db.marshal.CounterColumnType;
+import org.apache.cassandra.thrift.Column;
+import org.apache.cassandra.thrift.CqlResult;
+import org.apache.cassandra.thrift.CqlRow;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
+public class CResultSet extends AbstractResultSet implements CassandraResultSet
+{
+    public static final int DEFAULT_TYPE = ResultSet.TYPE_FORWARD_ONLY;
+    public static final int DEFAULT_CONCURRENCY = ResultSet.CONCUR_READ_ONLY;
+    public static final int DEFAULT_HOLDABILITY = ResultSet.HOLD_CURSORS_OVER_COMMIT;
+
+    private final ColumnDecoder decoder;
+    private final String keyspace;
+
+    private final String columnFamily;
+
+    /**
+     * The r set iter.
+     */
+    private Iterator<CqlRow> rSetIter;
+
+    int rowNumber = 0;
+    // the current row key when iterating through results.
+    private byte[] curRowKey = null;
+
+    private TypedColumn typedCurRowKey = null;
+
+    /**
+     * The values.
+     */
+    private List<TypedColumn> values = new ArrayList<TypedColumn>();
+
+    /**
+     * The value map.
+     */
+    private Map<String, TypedColumn> valueMap = new HashMap<String, TypedColumn>();
+
+    /**
+     * The index map.
+     */
+    private Map<String, Integer> indexMap = new HashMap<String, Integer>();
+
+    private final CResultSetMetaData meta;
+
+    private final Statement statement;
+
+    private int resultSetType;
+
+    private int fetchDirection;
+
+    private int fetchSize;
+
+    private boolean wasNull;
+
+    /**
+     * no argument constructor.
+     */
+    CResultSet()
+    {
+        keyspace = null;
+        columnFamily = null;
+        decoder = null;
+        statement = null;
+        meta = new CResultSetMetaData();
+    }
+
+    /**
+     * Instantiates a new cassandra result set.
+     */
+    CResultSet(Statement statement, CqlResult resultSet, ColumnDecoder decoder, String keyspace, String columnFamily) throws SQLException
+    {
+        this.statement = statement;
+        this.resultSetType = statement.getResultSetType();
+        this.fetchDirection = statement.getFetchDirection();
+        this.fetchSize = statement.getFetchSize();
+
+        this.decoder = decoder;
+        this.keyspace = keyspace;
+        this.columnFamily = columnFamily;
+        rSetIter = resultSet.getRowsIterator();
+        meta = new CResultSetMetaData();
+    }
+
+    public boolean absolute(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void afterLast() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void beforeFirst() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    private final void checkIndex(int index) throws SQLException
+    {
+        // 1 <= index <= size()
+        if (index < 1 || index > values.size())
+            throw new SQLSyntaxErrorException(String.format(MUST_BE_POSITIVE, String.valueOf(index)));
+    }
+
+    private final void checkName(String name) throws SQLException
+    {
+        if (valueMap.get(name) == null) throw new SQLSyntaxErrorException(String.format(VALID_LABELS, name));
+    }
+
+    private final void checkNotClosed() throws SQLException
+    {
+        if (isClosed()) throw new SQLRecoverableException(WAS_CLOSED_RSLT);
+    }
+
+    public void clearWarnings() throws SQLException
+    {
+        // This implementation does not support the collection of warnings so clearing is a no-op
+        // but it is still an exception to call this on a closed connection.
+        checkNotClosed();
+    }
+
+    public void close() throws SQLException
+    {
+        valueMap = null;
+        values = null;
+    }
+
+    public int findColumn(String name) throws SQLException
+    {
+        checkNotClosed();
+        checkName(name);
+        return indexMap.get(name).intValue();
+    }
+
+    public boolean first() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    // Big Decimal (awaiting a new AbstractType implementation)
+
+    public BigDecimal getBigDecimal(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public BigDecimal getBigDecimal(int arg0, int arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public BigDecimal getBigDecimal(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public BigDecimal getBigDecimal(String arg0, int arg1) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public BigInteger getBigInteger(int index) throws SQLException
+    {
+        checkIndex(index);
+        return getBigInteger(values.get(index - 1));
+    }
+
+    public BigInteger getBigInteger(String name) throws SQLException
+    {
+        checkName(name);
+        return getBigInteger(valueMap.get(name));
+    }
+
+    private BigInteger getBigInteger(TypedColumn column) throws SQLException
+    {
+        checkNotClosed();
+        Object value = column.getValue();
+        wasNull = value == null;
+
+        if (wasNull) return BigInteger.ZERO;
+
+        if (value instanceof Long) return BigInteger.valueOf((Long) value);
+
+        if (value instanceof BigInteger) return (BigInteger) value;
+
+        try
+        {
+            if (value instanceof String) return (new BigInteger((String) value));
+        }
+        catch (NumberFormatException e)
+        {
+            throw new SQLSyntaxErrorException(e);
+        }
+
+        throw new SQLSyntaxErrorException(String.format(NOT_TRANSLATABLE, value.getClass().getSimpleName(), "BigInteger"));
+    }
+
+    public boolean getBoolean(int index) throws SQLException
+    {
+        checkIndex(index);
+        return getBoolean(values.get(index - 1));
+    }
+
+    public boolean getBoolean(String name) throws SQLException
+    {
+        checkName(name);
+        return getBoolean(valueMap.get(name));
+    }
+
+    private final Boolean getBoolean(TypedColumn column) throws SQLException
+    {
+        checkNotClosed();
+        Object value = column.getValue();
+        wasNull = value == null;
+
+        if (wasNull) return false;
+
+        if (value instanceof Long) return Boolean.valueOf(((Long) value) == 0 ? false : true);
+
+        if (value instanceof BigInteger) return Boolean.valueOf(((BigInteger) value).intValue() == 0 ? false : true);
+
+        if (value instanceof String)
+        {
+            String str = (String) value;
+            if (str.equalsIgnoreCase("true")) return true;
+            if (str.equalsIgnoreCase("false")) return false;
+
+            throw new SQLSyntaxErrorException(String.format(NOT_BOOLEAN, str));
+        }
+
+        throw new SQLSyntaxErrorException(String.format(NOT_TRANSLATABLE, value.getClass().getSimpleName(), "Boolean"));
+    }
+
+    public byte getByte(int index) throws SQLException
+    {
+        checkIndex(index);
+        return getByte(values.get(index - 1));
+    }
+
+    public byte getByte(String name) throws SQLException
+    {
+        checkName(name);
+        return getByte(valueMap.get(name));
+    }
+
+    private final Byte getByte(TypedColumn column) throws SQLException
+    {
+        checkNotClosed();
+        Object value = column.getValue();
+        wasNull = value == null;
+
+        if (wasNull) return 0;
+
+        if (value instanceof Long) return ((Long) value).byteValue();
+
+        if (value instanceof BigInteger) return ((BigInteger) value).byteValue();
+
+        try
+        {
+            if (value instanceof String) return (new Byte((String) value));
+        }
+        catch (NumberFormatException e)
+        {
+            throw new SQLSyntaxErrorException(e);
+        }
+
+        throw new SQLSyntaxErrorException(String.format(NOT_TRANSLATABLE, value.getClass().getSimpleName(), "Byte"));
+    }
+
+    public byte[] getBytes(int index) throws SQLException
+    {
+        return getBytes(values.get(index - 1));
+    }
+
+    public byte[] getBytes(String name) throws SQLException
+    {
+        return getBytes(valueMap.get(name));
+    }
+
+    private byte[] getBytes(TypedColumn column) throws SQLException
+    {
+        checkNotClosed();
+        ByteBuffer value = (ByteBuffer) column.getValue();
+        wasNull = value == null;
+        return value == null ? null : ByteBufferUtil.clone(value).array();
+    }
+
+    public TypedColumn getColumn(int index) throws SQLException
+    {
+        checkIndex(index);
+        checkNotClosed();
+        return values.get(index);
+    }
+
+    public TypedColumn getColumn(String name) throws SQLException
+    {
+        checkName(name);
+        checkNotClosed();
+        return valueMap.get(name);
+    }
+
+    public int getConcurrency() throws SQLException
+    {
+        checkNotClosed();
+        return statement.getResultSetConcurrency();
+    }
+
+    public Date getDate(int index) throws SQLException
+    {
+        checkIndex(index);
+        return getDate(values.get(index - 1));
+    }
+
+    public Date getDate(int index, Calendar calendar) throws SQLException
+    {
+        checkIndex(index);
+        // silently ignore the Calendar argument; its a hint we do not need
+        return getDate(index);
+    }
+
+    public Date getDate(String name) throws SQLException
+    {
+        checkName(name);
+        return getDate(valueMap.get(name));
+    }
+
+    public Date getDate(String name, Calendar calendar) throws SQLException
+    {
+        checkName(name);
+        // silently ignore the Calendar argument; its a hint we do not need
+        return getDate(name);
+    }
+
+    private Date getDate(TypedColumn column) throws SQLException
+    {
+        checkNotClosed();
+        Object value = column.getValue();
+        wasNull = value == null;
+
+        if (wasNull) return null;
+
+        if (value instanceof Long) return new Date((Long) value);
+
+        if (value instanceof java.util.Date) return new Date(((java.util.Date) value).getTime());
+
+        try
+        {
+            if (value instanceof String) return Date.valueOf((String) value);
+        }
+        catch (IllegalArgumentException e)
+        {
+            throw new SQLSyntaxErrorException(e);
+        }
+
+        throw new SQLSyntaxErrorException(String.format(NOT_TRANSLATABLE, value.getClass().getSimpleName(), "SQL Date"));
+    }
+
+    public double getDouble(int index) throws SQLException
+    {
+        checkIndex(index);
+        return getDouble(values.get(index - 1));
+    }
+
+    public double getDouble(String name) throws SQLException
+    {
+        checkName(name);
+        return getDouble(valueMap.get(name));
+    }
+
+    private final Double getDouble(TypedColumn column) throws SQLException
+    {
+        checkNotClosed();
+        Object value = column.getValue();
+        wasNull = value == null;
+
+        if (wasNull) return 0.0;
+
+        if (value instanceof Long) return new Double((Long) value);
+
+        if (value instanceof BigInteger) return new Double(((BigInteger) value).doubleValue());
+
+        if (value instanceof Double) return ((Double) value);
+
+        if (value instanceof Float) return ((Float) value).doubleValue();
+
+        try
+        {
+            if (value instanceof String) return new Double((String) value);
+        }
+        catch (NumberFormatException e)
+        {
+            throw new SQLSyntaxErrorException(e);
+        }
+
+        throw new SQLSyntaxErrorException(String.format(NOT_TRANSLATABLE, value.getClass().getSimpleName(), "Double"));
+    }
+
+    public int getFetchDirection() throws SQLException
+    {
+        checkNotClosed();
+        return fetchDirection;
+    }
+
+    public int getFetchSize() throws SQLException
+    {
+        checkNotClosed();
+        return fetchSize;
+    }
+
+    public float getFloat(int index) throws SQLException
+    {
+        checkIndex(index);
+        return getFloat(values.get(index - 1));
+    }
+
+    public float getFloat(String name) throws SQLException
+    {
+        checkName(name);
+        return getFloat(valueMap.get(name));
+    }
+
+    private final Float getFloat(TypedColumn column) throws SQLException
+    {
+        checkNotClosed();
+        Object value = column.getValue();
+        wasNull = value == null;
+
+        if (wasNull) return (float) 0.0;
+
+        if (value instanceof Long) return new Float((Long) value);
+
+        if (value instanceof BigInteger) return new Float(((BigInteger) value).floatValue());
+
+        if (value instanceof Float) return ((Float) value);
+
+        if (value instanceof Double) return ((Double) value).floatValue();
+
+        try
+        {
+            if (value instanceof String) return new Float((String) value);
+        }
+        catch (NumberFormatException e)
+        {
+            throw new SQLException(e);
+        }
+
+        throw new SQLSyntaxErrorException(String.format(NOT_TRANSLATABLE, value.getClass().getSimpleName(), "Float"));
+    }
+
+    public int getHoldability() throws SQLException
+    {
+        checkNotClosed();
+        return statement.getResultSetHoldability();
+    }
+
+    public int getInt(int index) throws SQLException
+    {
+        checkIndex(index);
+        return getInt(values.get(index - 1));
+    }
+
+    public int getInt(String name) throws SQLException
+    {
+        checkName(name);
+        return getInt(valueMap.get(name));
+    }
+
+    private int getInt(TypedColumn column) throws SQLException
+    {
+        checkNotClosed();
+        Object value = column.getValue();
+        wasNull = value == null;
+
+        if (wasNull) return 0;
+
+        // bit of a hack, this, but asking for getInt seems so common that we should accommodate it
+        if (value instanceof BigInteger) return ((BigInteger) value).intValue();
+
+        if (value instanceof Long) return ((Long) value).intValue();
+
+        try
+        {
+            if (value instanceof String) return (Integer.parseInt((String) value));
+        }
+        catch (NumberFormatException e)
+        {
+            throw new SQLSyntaxErrorException(e);
+        }
+
+        throw new SQLSyntaxErrorException(String.format(NOT_TRANSLATABLE, value.getClass().getSimpleName(), "int"));
+    }
+
+    public byte[] getKey() throws SQLException
+    {
+        return curRowKey;
+    }
+
+    public long getLong(int index) throws SQLException
+    {
+        checkIndex(index);
+        return getLong(values.get(index - 1));
+    }
+
+    public long getLong(String name) throws SQLException
+    {
+        checkName(name);
+        return getLong(valueMap.get(name));
+    }
+
+    private Long getLong(TypedColumn column) throws SQLException
+    {
+        checkNotClosed();
+        Object value = column.getValue();
+        wasNull = value == null;
+
+        if (wasNull) return 0L;
+
+        if (value instanceof BigInteger) return getBigInteger(column).longValue();
+
+        if (value instanceof Long) return (Long) value;
+
+        try
+        {
+            if (value instanceof String) return (Long.parseLong((String) value));
+        }
+        catch (NumberFormatException e)
+        {
+            throw new SQLSyntaxErrorException(e);
+        }
+
+        throw new SQLSyntaxErrorException(String.format(NOT_TRANSLATABLE, value.getClass().getSimpleName(), "Long"));
+    }
+
+    public ResultSetMetaData getMetaData() throws SQLException
+    {
+        checkNotClosed();
+        return meta;
+    }
+
+    public Object getObject(int index) throws SQLException
+    {
+        checkIndex(index);
+        return getObject(values.get(index - 1));
+    }
+
+    public Object getObject(String name) throws SQLException
+    {
+        checkName(name);
+        return getObject(valueMap.get(name));
+    }
+
+
+    private Object getObject(TypedColumn column) throws SQLException
+    {
+        checkNotClosed();
+        Object value = column.getValue();
+        wasNull = value == null;
+        return (wasNull) ? null : value;
+    }
+
+    public int getRow() throws SQLException
+    {
+        checkNotClosed();
+        return rowNumber;
+    }
+
+    // RowId (shall we just store the raw bytes as it is kept in C* ? Probably...
+    public RowId getRowId(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public short getShort(int index) throws SQLException
+    {
+        checkIndex(index);
+        return getShort(values.get(index - 1));
+    }
+
+    public short getShort(String name) throws SQLException
+    {
+        checkName(name);
+        return getShort(valueMap.get(name));
+    }
+
+    private final Short getShort(TypedColumn column) throws SQLException
+    {
+        checkNotClosed();
+        Object value = column.getValue();
+        wasNull = value == null;
+
+        if (wasNull) return 0;
+
+        if (value instanceof Long) return ((Long) value).shortValue();
+
+        if (value instanceof BigInteger) return ((BigInteger) value).shortValue();
+
+        try
+        {
+            if (value instanceof String) return (new Short((String) value));
+        }
+        catch (NumberFormatException e)
+        {
+            throw new SQLSyntaxErrorException(e);
+        }
+
+        throw new SQLSyntaxErrorException(String.format(NOT_TRANSLATABLE, value.getClass().getSimpleName(), "Short"));
+    }
+
+    public Statement getStatement() throws SQLException
+    {
+        checkNotClosed();
+        return statement;
+    }
+
+    public String getString(int index) throws SQLException
+    {
+        checkIndex(index);
+        return getString(values.get(index - 1));
+    }
+
+    public String getString(String name) throws SQLException
+    {
+        checkName(name);
+        return getString(valueMap.get(name));
+    }
+
+    private String getString(TypedColumn column) throws SQLException
+    {
+        checkNotClosed();
+        Object value = column.getValue();
+        wasNull = value == null;
+        return (wasNull) ? null : value.toString();
+    }
+
+    public Time getTime(int index) throws SQLException
+    {
+        checkIndex(index);
+        return getTime(values.get(index - 1));
+    }
+
+    public Time getTime(int index, Calendar calendar) throws SQLException
+    {
+        checkIndex(index);
+        // silently ignore the Calendar argument; its a hint we do not need
+        return getTime(index);
+    }
+
+    public Time getTime(String name) throws SQLException
+    {
+        checkName(name);
+        return getTime(valueMap.get(name));
+    }
+
+    public Time getTime(String name, Calendar calendar) throws SQLException
+    {
+        checkName(name);
+        // silently ignore the Calendar argument; its a hint we do not need
+        return getTime(name);
+    }
+
+    private Time getTime(TypedColumn column) throws SQLException
+    {
+        checkNotClosed();
+        Object value = column.getValue();
+        wasNull = value == null;
+
+        if (wasNull) return null;
+
+        if (value instanceof Long) return new Time((Long) value);
+
+        if (value instanceof java.util.Date) return new Time(((java.util.Date) value).getTime());
+
+        try
+        {
+            if (value instanceof String) return Time.valueOf((String) value);
+        }
+        catch (IllegalArgumentException e)
+        {
+            throw new SQLSyntaxErrorException(e);
+        }
+
+        throw new SQLSyntaxErrorException(String.format(NOT_TRANSLATABLE, value.getClass().getSimpleName(), "SQL Time"));
+    }
+
+    public Timestamp getTimestamp(int index) throws SQLException
+    {
+        checkIndex(index);
+        return getTimestamp(values.get(index - 1));
+    }
+
+    public Timestamp getTimestamp(int index, Calendar calendar) throws SQLException
+    {
+        checkIndex(index);
+        // silently ignore the Calendar argument; its a hint we do not need
+        return getTimestamp(index);
+    }
+
+    public Timestamp getTimestamp(String name) throws SQLException
+    {
+        checkName(name);
+        return getTimestamp(valueMap.get(name));
+    }
+
+    public Timestamp getTimestamp(String name, Calendar calendar) throws SQLException
+    {
+        checkName(name);
+        // silently ignore the Calendar argument; its a hint we do not need
+        return getTimestamp(name);
+    }
+
+    private Timestamp getTimestamp(TypedColumn column) throws SQLException
+    {
+        checkNotClosed();
+        Object value = column.getValue();
+        wasNull = value == null;
+
+        if (wasNull) return null;
+
+        if (value instanceof Long) return new Timestamp((Long) value);
+
+        if (value instanceof java.util.Date) return new Timestamp(((java.util.Date) value).getTime());
+
+        try
+        {
+            if (value instanceof String) return Timestamp.valueOf((String) value);
+        }
+        catch (IllegalArgumentException e)
+        {
+            throw new SQLSyntaxErrorException(e);
+        }
+
+        throw new SQLSyntaxErrorException(String.format(NOT_TRANSLATABLE, value.getClass().getSimpleName(), "SQL Timestamp"));
+    }
+
+    public int getType() throws SQLException
+    {
+        checkNotClosed();
+        return resultSetType;
+    }
+
+    public TypedColumn getTypedKey() throws SQLException
+    {
+        return typedCurRowKey;
+    }
+
+    // URL (awaiting some clarifications as to how it is stored in C* ... just a validated Sting in URL format?
+    public URL getURL(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public URL getURL(String arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    // These Methods are planned to be  implemented soon; but not right now...
+    // Each set of methods has a more detailed set of issues that should be considered fully...
+
+
+    public SQLWarning getWarnings() throws SQLException
+    {
+        checkNotClosed();
+        // the rationale is there are no warnings to return in this implementation...
+        return null;
+    }
+
+
+    public boolean isAfterLast() throws SQLException
+    {
+        checkNotClosed();
+        return rowNumber == Integer.MAX_VALUE;
+    }
+
+    public boolean isBeforeFirst() throws SQLException
+    {
+        checkNotClosed();
+        return rowNumber == 0;
+    }
+
+    public boolean isClosed() throws SQLException
+    {
+        return valueMap == null;
+    }
+
+    public boolean isFirst() throws SQLException
+    {
+        checkNotClosed();
+        return rowNumber == 1;
+    }
+
+    public boolean isLast() throws SQLException
+    {
+        checkNotClosed();
+        return !rSetIter.hasNext();
+    }
+
+    public boolean isWrapperFor(Class<?> iface) throws SQLException
+    {
+        return CassandraResultSet.class.isAssignableFrom(iface);
+    }
+
+    // Navigation between rows within the returned set of rows
+    // Need to use a list iterator so next() needs completely re-thought
+
+    public boolean last() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public synchronized boolean next() throws SQLException
+    {
+        if (!values.isEmpty() || !valueMap.isEmpty())
+        {
+            values.clear();
+            valueMap.clear();
+        }
+        if (rSetIter != null && rSetIter.hasNext())
+        {
+            CqlRow row = rSetIter.next();
+            rowNumber++;
+            curRowKey = row.getKey();
+            typedCurRowKey = decoder.makeKeyColumn(keyspace, columnFamily, curRowKey);
+            List<Column> cols = row.getColumns();
+            for (Column col : cols)
+            {
+
+                TypedColumn c = decoder.makeCol(keyspace, columnFamily, col);
+                String columnName = decoder.colNameAsString(keyspace, columnFamily, col.name);
+                values.add(c);
+                indexMap.put(columnName, values.size()); // one greater than 0 based index of a list
+                valueMap.put(columnName, c);
+            }
+            return !(values.isEmpty() || valueMap.isEmpty());
+        }
+        else
+        {
+            rowNumber = Integer.MAX_VALUE;
+            return false;
+        }
+    }
+
+    public boolean previous() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public boolean relative(int arg0) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setFetchDirection(int direction) throws SQLException
+    {
+        checkNotClosed();
+
+        if (direction == FETCH_FORWARD || direction == FETCH_REVERSE || direction == FETCH_UNKNOWN)
+        {
+            if ((getType() == TYPE_FORWARD_ONLY) && (direction != FETCH_FORWARD))
+                throw new SQLSyntaxErrorException("attempt to set an illegal direction : " + direction);
+            fetchDirection = direction;
+        }
+        throw new SQLSyntaxErrorException(String.format(BAD_FETCH_DIR, direction));
+    }
+
+    public void setFetchSize(int size) throws SQLException
+    {
+        checkNotClosed();
+        if (size < 0) throw new SQLException(String.format(BAD_FETCH_SIZE, size));
+        fetchSize = size;
+    }
+
+    public <T> T unwrap(Class<T> iface) throws SQLException
+    {
+        if (iface.equals(CassandraResultSet.class)) return (T) this;
+
+        throw new SQLFeatureNotSupportedException(String.format(NO_INTERFACE, iface.getSimpleName()));
+    }
+
+    public boolean wasNull() throws SQLException
+    {
+        return wasNull;
+    }
+
+    /**
+     * RSMD implementation.  The metadata returned refers to the column
+     * values, not the column names.
+     */
+    class CResultSetMetaData implements ResultSetMetaData
+    {
+        public String getCatalogName(int column) throws SQLException
+        {
+            checkIndex(column);
+            return "";
+        }
+
+        public String getColumnClassName(int column) throws SQLException
+        {
+            checkIndex(column);
+            return values.get(column - 1).getValueType().getType().getName();
+        }
+
+        public int getColumnCount() throws SQLException
+        {
+            return values.size();
+        }
+
+        public int getColumnDisplaySize(int column) throws SQLException
+        {
+            checkIndex(column);
+            return values.get(column - 1).getValueString().length();
+        }
+
+        public String getColumnLabel(int column) throws SQLException
+        {
+            checkIndex(column);
+            return getColumnName(column);
+        }
+
+        public String getColumnName(int column) throws SQLException
+        {
+            checkIndex(column);
+            return values.get(column - 1).getNameString();
+        }
+
+        public int getColumnType(int column) throws SQLException
+        {
+            checkIndex(column);
+            return values.get(column - 1).getValueType().getJdbcType();
+        }
+
+        // Spec says "database specific type name". For Cassandra this means the abstract type.
+        public String getColumnTypeName(int column) throws SQLException
+        {
+            checkIndex(column);
+            return values.get(column - 1).getValueType().getClass().getSimpleName();
+        }
+
+        public int getPrecision(int column) throws SQLException
+        {
+            checkIndex(column);
+            TypedColumn col = values.get(column - 1);
+            return col.getValueType().getPrecision(col.getValue());
+        }
+
+        public int getScale(int column) throws SQLException
+        {
+            checkIndex(column);
+            TypedColumn tc = values.get(column - 1);
+            return tc.getValueType().getScale(tc.getValue());
+        }
+
+        public String getSchemaName(int column) throws SQLException
+        {
+            checkIndex(column);
+            return keyspace;
+        }
+
+        public String getTableName(int column) throws SQLException
+        {
+            checkIndex(column);
+            return columnFamily;
+        }
+
+        public boolean isAutoIncrement(int column) throws SQLException
+        {
+            checkIndex(column);
+            return values.get(column - 1).getValueType() instanceof CounterColumnType; // todo: check Value is correct.
+        }
+
+        public boolean isCaseSensitive(int column) throws SQLException
+        {
+            checkIndex(column);
+            TypedColumn tc = values.get(column - 1);
+            return tc.getValueType().isCaseSensitive();
+        }
+
+        public boolean isCurrency(int column) throws SQLException
+        {
+            checkIndex(column);
+            TypedColumn tc = values.get(column - 1);
+            return tc.getValueType().isCurrency();
+        }
+
+        public boolean isDefinitelyWritable(int column) throws SQLException
+        {
+            checkIndex(column);
+            return isWritable(column);
+        }
+
+        /**
+         * absence is the equivalent of null in Cassandra
+         */
+        public int isNullable(int column) throws SQLException
+        {
+            checkIndex(column);
+            return ResultSetMetaData.columnNullable;
+        }
+
+        public boolean isReadOnly(int column) throws SQLException
+        {
+            checkIndex(column);
+            return column == 0;
+        }
+
+        public boolean isSearchable(int column) throws SQLException
+        {
+            checkIndex(column);
+            return false;
+        }
+
+        public boolean isSigned(int column) throws SQLException
+        {
+            checkIndex(column);
+            TypedColumn tc = values.get(column - 1);
+            return tc.getValueType().isSigned();
+        }
+
+        public boolean isWrapperFor(Class<?> iface) throws SQLException
+        {
+            return false;
+        }
+
+        public boolean isWritable(int column) throws SQLException
+        {
+            checkIndex(column);
+            return column > 0;
+        }
+
+        public <T> T unwrap(Class<T> iface) throws SQLException
+        {
+            throw new SQLFeatureNotSupportedException(String.format(NO_INTERFACE, iface.getSimpleName()));
+        }
+    }
+}
diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraConnection.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraConnection.java
index e69de29b..c34801b5 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraConnection.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraConnection.java
@@ -0,0 +1,459 @@
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+package org.apache.cassandra.cql.jdbc;
+
+import static org.apache.cassandra.cql.jdbc.Utils.ALWAYS_AUTOCOMMIT;
+import static org.apache.cassandra.cql.jdbc.Utils.BAD_TIMEOUT;
+import static org.apache.cassandra.cql.jdbc.Utils.NO_INTERFACE;
+import static org.apache.cassandra.cql.jdbc.Utils.NO_TRANSACTIONS;
+import static org.apache.cassandra.cql.jdbc.Utils.PROTOCOL;
+import static org.apache.cassandra.cql.jdbc.Utils.SCHEMA_MISMATCH;
+import static org.apache.cassandra.cql.jdbc.Utils.TAG_SERVER_NAME;
+import static org.apache.cassandra.cql.jdbc.Utils.TAG_DATABASE_NAME;
+import static org.apache.cassandra.cql.jdbc.Utils.TAG_PASSWORD;
+import static org.apache.cassandra.cql.jdbc.Utils.TAG_PORT_NUMBER;
+import static org.apache.cassandra.cql.jdbc.Utils.TAG_USER;
+import static org.apache.cassandra.cql.jdbc.Utils.WAS_CLOSED_CON;
+import static org.apache.cassandra.cql.jdbc.Utils.createSubName;
+import static org.apache.cassandra.cql.jdbc.Utils.determineCurrentKeyspace;
+
+import java.sql.Connection;
+import java.sql.DatabaseMetaData;
+import java.sql.PreparedStatement;
+import java.sql.SQLClientInfoException;
+import java.sql.SQLException;
+import java.sql.SQLFeatureNotSupportedException;
+import java.sql.SQLInvalidAuthorizationSpecException;
+import java.sql.SQLNonTransientConnectionException;
+import java.sql.SQLRecoverableException;
+import java.sql.SQLSyntaxErrorException;
+import java.sql.SQLTimeoutException;
+import java.sql.SQLTransientConnectionException;
+import java.sql.SQLWarning;
+import java.sql.Statement;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+
+import org.apache.cassandra.thrift.AuthenticationException;
+import org.apache.cassandra.thrift.AuthenticationRequest;
+import org.apache.cassandra.thrift.AuthorizationException;
+import org.apache.cassandra.thrift.Cassandra;
+import org.apache.cassandra.thrift.Compression;
+import org.apache.cassandra.thrift.CqlResult;
+import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.thrift.SchemaDisagreementException;
+import org.apache.cassandra.thrift.TimedOutException;
+import org.apache.cassandra.thrift.UnavailableException;
+import org.apache.thrift.TException;
+import org.apache.thrift.protocol.TBinaryProtocol;
+import org.apache.thrift.protocol.TProtocol;
+import org.apache.thrift.transport.TFramedTransport;
+import org.apache.thrift.transport.TSocket;
+import org.apache.thrift.transport.TTransport;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Implementation class for {@link Connection}.
+ */
+class CassandraConnection extends AbstractCassandraConnection implements Connection
+{
+
+    private static final Logger logger = LoggerFactory.getLogger(CassandraConnection.class);
+
+    public static final int DB_MAJOR_VERSION = 0;
+    public static final int DB_MINOR_VERSION = 8;
+    public static final String DB_PRODUCT_NAME = "Cassandra";
+
+    public static Compression defaultCompression = Compression.GZIP;
+
+    private final boolean autoCommit = true;
+
+    private final int transactionIsolation = Connection.TRANSACTION_NONE;
+
+    /**
+     * Client Info Properties (currently unused)
+     */
+    private Properties clientInfo = new Properties();
+
+    /**
+     * List of all Statements that have been created by this connection
+     */
+    private List<Statement> statements;
+
+    private Cassandra.Client client;
+    private TTransport transport;
+
+    protected long timeOfLastFailure = 0;
+    protected int numFailures = 0;
+    protected String username = null;
+    protected String url = null;
+    String currentKeyspace;
+    ColumnDecoder decoder;
+
+
+    /**
+     * Instantiates a new CassandraConnection.
+     */
+    public CassandraConnection(Properties props) throws SQLException
+    {
+        statements = new ArrayList<Statement>();
+        clientInfo = new Properties();
+        url = PROTOCOL + createSubName(props);
+        try
+        {
+            String host = props.getProperty(TAG_SERVER_NAME);
+            int port = Integer.parseInt(props.getProperty(TAG_PORT_NUMBER));
+            String keyspace = props.getProperty(TAG_DATABASE_NAME);
+            username = props.getProperty(TAG_USER);
+            String password = props.getProperty(TAG_PASSWORD);
+
+            TSocket socket = new TSocket(host, port);
+            transport = new TFramedTransport(socket);
+            TProtocol protocol = new TBinaryProtocol(transport);
+            client = new Cassandra.Client(protocol);
+            socket.open();
+            decoder = new ColumnDecoder(client.describe_keyspaces());
+
+            if (username != null)
+            {
+                Map<String, String> credentials = new HashMap<String, String>();
+                credentials.put("username", username);
+                if (password != null) credentials.put("password", password);
+                AuthenticationRequest areq = new AuthenticationRequest(credentials);
+                client.login(areq);
+
+            }
+
+            logger.info("Connected to {}:{}", host, port);
+
+
+            if (keyspace != null)
+            {
+                execute("USE " + keyspace);
+            }
+        }
+        catch (SchemaDisagreementException e)
+        {
+            throw new SQLRecoverableException(SCHEMA_MISMATCH);
+        }
+        catch (InvalidRequestException e)
+        {
+            throw new SQLSyntaxErrorException(e);
+        }
+        catch (UnavailableException e)
+        {
+            throw new SQLNonTransientConnectionException(e);
+        }
+        catch (TimedOutException e)
+        {
+            throw new SQLTransientConnectionException(e);
+        }
+        catch (TException e)
+        {
+            throw new SQLNonTransientConnectionException(e);
+        }
+        catch (AuthenticationException e)
+        {
+            throw new SQLInvalidAuthorizationSpecException(e);
+        }
+        catch (AuthorizationException e)
+        {
+            throw new SQLInvalidAuthorizationSpecException(e);
+        }
+    }
+
+    private final void checkNotClosed() throws SQLException
+    {
+        if (isClosed()) throw new SQLNonTransientConnectionException(WAS_CLOSED_CON);
+    }
+
+    public void clearWarnings() throws SQLException
+    {
+        // This implementation does not support the collection of warnings so clearing is a no-op
+        // but it is still an exception to call this on a closed connection.
+        checkNotClosed();
+    }
+
+    /**
+     * On close of connection.
+     */
+    public synchronized void close() throws SQLException
+    {
+        if (isConnected())
+        {
+            // spec says to close all statements associated with this connection upon close
+            for (Statement statement : statements) statement.close();
+            // then disconnect from the transport                
+            disconnect();
+        }
+    }
+
+    public void commit() throws SQLException
+    {
+        checkNotClosed();
+        throw new SQLFeatureNotSupportedException(ALWAYS_AUTOCOMMIT);
+    }
+
+    public Statement createStatement() throws SQLException
+    {
+        checkNotClosed();
+        statements.add(new CassandraStatement(this));
+        return statements.get(statements.size() - 1);
+    }
+
+    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException
+    {
+        checkNotClosed();
+        statements.add(new CassandraStatement(this, null, resultSetType, resultSetConcurrency));
+        return statements.get(statements.size() - 1);
+    }
+
+    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException
+    {
+        checkNotClosed();
+        statements.add(new CassandraStatement(this, null, resultSetType, resultSetConcurrency, resultSetHoldability));
+        return statements.get(statements.size() - 1);
+    }
+
+    public boolean getAutoCommit() throws SQLException
+    {
+        checkNotClosed();
+        return autoCommit;
+    }
+
+    public String getCatalog() throws SQLException
+    {
+        // This implementation does not support the catalog names so null is always returned if the connection is open.
+        // but it is still an exception to call this on a closed connection.
+        checkNotClosed();
+        return null;
+    }
+
+    public Properties getClientInfo() throws SQLException
+    {
+        checkNotClosed();
+        return clientInfo;
+    }
+
+    public String getClientInfo(String label) throws SQLException
+    {
+        checkNotClosed();
+        return clientInfo.getProperty(label);
+    }
+
+    public int getHoldability() throws SQLException
+    {
+        checkNotClosed();
+        // the rationale is there are really no commits in Cassandra so no boundary...
+        return CResultSet.DEFAULT_HOLDABILITY;
+    }
+
+    public DatabaseMetaData getMetaData() throws SQLException
+    {
+        checkNotClosed();
+        return new CassandraDatabaseMetaData(this);
+    }
+
+    public int getTransactionIsolation() throws SQLException
+    {
+        checkNotClosed();
+        return transactionIsolation;
+    }
+
+    public SQLWarning getWarnings() throws SQLException
+    {
+        checkNotClosed();
+        // the rationale is there are no warnings to return in this implementation...
+        return null;
+    }
+
+    public synchronized boolean isClosed() throws SQLException
+    {
+
+        return !isConnected();
+    }
+
+    public boolean isReadOnly() throws SQLException
+    {
+        checkNotClosed();
+        return false;
+    }
+
+    public boolean isValid(int timeout) throws SQLException
+    {
+        checkNotClosed();
+        if (timeout < 0) throw new SQLTimeoutException(BAD_TIMEOUT);
+
+        // this needs to be more robust. Some query needs to be made to verify connection is really up.
+        return !isClosed();
+    }
+
+    public boolean isWrapperFor(Class<?> arg0) throws SQLException
+    {
+        return false;
+    }
+
+    public String nativeSQL(String sql) throws SQLException
+    {
+        checkNotClosed();
+        // the rationale is there are no distinction between grammars in this implementation...
+        // so we are just return the input argument
+        return sql;
+    }
+
+    public PreparedStatement prepareStatement(String sql) throws SQLException
+    {
+        checkNotClosed();
+        statements.add(new CassandraPreparedStatement(this, sql));
+        return (PreparedStatement) statements.get(statements.size() - 1);
+    }
+
+    public PreparedStatement prepareStatement(String arg0, int arg1, int arg2) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public PreparedStatement prepareStatement(String arg0, int arg1, int arg2, int arg3) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void rollback() throws SQLException
+    {
+        checkNotClosed();
+        throw new SQLFeatureNotSupportedException(ALWAYS_AUTOCOMMIT);
+    }
+
+    public void setAutoCommit(boolean autoCommit) throws SQLException
+    {
+        checkNotClosed();
+        if (!autoCommit) throw new SQLFeatureNotSupportedException(ALWAYS_AUTOCOMMIT);
+    }
+
+    public void setCatalog(String arg0) throws SQLException
+    {
+        checkNotClosed();
+        // the rationale is there are no catalog name to set in this implementation...
+        // so we are "silently ignoring" the request
+    }
+
+    public void setClientInfo(Properties props) throws SQLClientInfoException
+    {
+        // we don't use them but we will happily collect them for now...
+        if (props != null) clientInfo = props;
+    }
+
+    public void setClientInfo(String key, String value) throws SQLClientInfoException
+    {
+        // we don't use them but we will happily collect them for now...
+        clientInfo.setProperty(key, value);
+    }
+
+    public void setHoldability(int arg0) throws SQLException
+    {
+        checkNotClosed();
+        // the rationale is there are no holdability to set in this implementation...
+        // so we are "silently ignoring" the request
+    }
+
+    public void setReadOnly(boolean arg0) throws SQLException
+    {
+        checkNotClosed();
+        // the rationale is all connections are read/write in the Cassandra implementation...
+        // so we are "silently ignoring" the request
+    }
+
+    public void setTransactionIsolation(int level) throws SQLException
+    {
+        checkNotClosed();
+        if (level != Connection.TRANSACTION_NONE) throw new SQLFeatureNotSupportedException(NO_TRANSACTIONS);
+    }
+
+    public <T> T unwrap(Class<T> iface) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(String.format(NO_INTERFACE, iface.getSimpleName()));
+    }
+
+    /**
+     * Execute a CQL query.
+     *
+     * @param queryStr    a CQL query string
+     * @param compression query compression to use
+     * @return the query results encoded as a CqlResult structure
+     * @throws InvalidRequestException     on poorly constructed or illegal requests
+     * @throws UnavailableException        when not all required replicas could be created/read
+     * @throws TimedOutException           when a cluster operation timed out
+     * @throws SchemaDisagreementException when the client side and server side are at different versions of schema (Thrift)
+     * @throws TException                  when there is a error in Thrift processing
+     */
+    public CqlResult execute(String queryStr, Compression compression) throws InvalidRequestException, UnavailableException, TimedOutException, SchemaDisagreementException, TException
+    {
+        currentKeyspace = determineCurrentKeyspace(queryStr, currentKeyspace);
+
+        try
+        {
+            return client.execute_cql_query(Utils.compressQuery(queryStr, compression), compression);
+        }
+        catch (TException error)
+        {
+            numFailures++;
+            timeOfLastFailure = System.currentTimeMillis();
+            throw error;
+        }
+    }
+
+    /**
+     * Execute a CQL query using the default compression methodology.
+     *
+     * @param queryStr a CQL query string
+     * @return the query results encoded as a CqlResult structure
+     * @throws InvalidRequestException     on poorly constructed or illegal requests
+     * @throws UnavailableException        when not all required replicas could be created/read
+     * @throws TimedOutException           when a cluster operation timed out
+     * @throws SchemaDisagreementException when the client side and server side are at different versions of schema (Thrift)
+     * @throws TException                  when there is a error in Thrift processing
+     */
+    public CqlResult execute(String queryStr) throws InvalidRequestException, UnavailableException, TimedOutException, SchemaDisagreementException, TException
+    {
+        return execute(queryStr, defaultCompression);
+    }
+
+    /**
+     * Shutdown the remote connection
+     */
+    public void disconnect()
+    {
+        transport.close();
+    }
+
+    /**
+     * Connection state.
+     */
+    public boolean isConnected()
+    {
+        return transport.isOpen();
+    }
+}
diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraDataSource.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraDataSource.java
index e69de29b..cdb42a27 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraDataSource.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraDataSource.java
@@ -0,0 +1,168 @@
+
+package org.apache.cassandra.cql.jdbc;
+
+import static org.apache.cassandra.cql.jdbc.Utils.HOST_REQUIRED;
+import static org.apache.cassandra.cql.jdbc.Utils.NO_INTERFACE;
+import static org.apache.cassandra.cql.jdbc.Utils.PROTOCOL;
+import static org.apache.cassandra.cql.jdbc.Utils.TAG_SERVER_NAME;
+import static org.apache.cassandra.cql.jdbc.Utils.TAG_DATABASE_NAME;
+import static org.apache.cassandra.cql.jdbc.Utils.TAG_PASSWORD;
+import static org.apache.cassandra.cql.jdbc.Utils.TAG_PORT_NUMBER;
+import static org.apache.cassandra.cql.jdbc.Utils.TAG_USER;
+import static org.apache.cassandra.cql.jdbc.Utils.createSubName;
+
+import java.io.PrintWriter;
+import java.sql.Connection;
+import java.sql.DriverManager;
+import java.sql.SQLException;
+import java.sql.SQLFeatureNotSupportedException;
+import java.sql.SQLNonTransientConnectionException;
+import java.util.Properties;
+
+import javax.sql.DataSource;
+
+public class CassandraDataSource implements DataSource
+{
+
+    static
+    {
+        try
+        {
+            Class.forName("org.apache.cassandra.cql.jdbc.CassandraDriver");
+        }
+        catch (ClassNotFoundException e)
+        {
+            throw new RuntimeException(e);
+        }
+    }
+
+    protected static final String description = "Cassandra Data Source";
+
+    protected String serverName;
+
+    protected int    portNumber = 9160;
+
+    protected String databaseName;
+
+    protected String user;
+
+    protected String password;
+
+    public CassandraDataSource(String host, int port, String keyspace, String user, String password)
+    {
+        if (host != null) setServerName(host);
+        if (port != -1) setPortNumber(port);
+        setDatabaseName(keyspace);
+        setUser(user);
+        setPassword(password);
+    }
+
+    public String getDescription()
+    {
+        return description;
+    }
+
+    public String getServerName()
+    {
+        return serverName;
+    }
+
+    public void setServerName(String serverName)
+    {
+        this.serverName = serverName;
+    }
+
+    public int getPortNumber()
+    {
+        return portNumber;
+    }
+
+    public void setPortNumber(int portNumber)
+    {
+        this.portNumber = portNumber;
+    }
+
+    public String getDatabaseName()
+    {
+        return databaseName;
+    }
+
+    public void setDatabaseName(String databaseName)
+    {
+        this.databaseName = databaseName;
+    }
+
+    public String getUser()
+    {
+        return user;
+    }
+
+    public void setUser(String user)
+    {
+        this.user = user;
+    }
+
+    public String getPassword()
+    {
+        return password;
+    }
+
+    public void setPassword(String password)
+    {
+        this.password = password;
+    }
+
+    public Connection getConnection() throws SQLException
+    {
+        return getConnection(null, null);
+    }
+
+    public Connection getConnection(String user, String password) throws SQLException
+    {
+        Properties props = new Properties();
+        
+        this.user = user;
+        this.password = password;
+        
+        if (this.serverName!=null) props.setProperty(TAG_SERVER_NAME, this.serverName);
+        else throw new SQLNonTransientConnectionException(HOST_REQUIRED);
+        props.setProperty(TAG_PORT_NUMBER, ""+this.portNumber);
+        if (this.databaseName!=null) props.setProperty(TAG_DATABASE_NAME, this.databaseName);
+        if (user!=null) props.setProperty(TAG_USER, user);
+        if (password!=null) props.setProperty(TAG_PASSWORD, password);
+
+        String url = PROTOCOL+createSubName(props);
+        return DriverManager.getConnection(url, props);
+    }
+
+    public int getLoginTimeout() throws SQLException
+    {
+        return DriverManager.getLoginTimeout();
+    }
+
+    public PrintWriter getLogWriter() throws SQLException
+    {
+        return DriverManager.getLogWriter();
+    }
+
+    public void setLoginTimeout(int timeout) throws SQLException
+    {
+        DriverManager.setLoginTimeout(timeout);
+    }
+
+    public void setLogWriter(PrintWriter writer) throws SQLException
+    {
+        DriverManager.setLogWriter(writer);
+    }
+
+    public boolean isWrapperFor(Class<?> iface) throws SQLException
+    {
+        return iface.isAssignableFrom(getClass());
+    }
+
+    public <T> T unwrap(Class<T> iface) throws SQLException
+    {
+        if (iface.isAssignableFrom(getClass())) return iface.cast(this);
+        throw new SQLFeatureNotSupportedException(String.format(NO_INTERFACE, iface.getSimpleName()));
+    }      
+}
diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraDatabaseMetaData.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraDatabaseMetaData.java
index e69de29b..502a9b15 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraDatabaseMetaData.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraDatabaseMetaData.java
@@ -0,0 +1,922 @@
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+package org.apache.cassandra.cql.jdbc;
+
+import static org.apache.cassandra.cql.jdbc.Utils.NO_INTERFACE;
+
+import java.sql.Connection;
+import java.sql.DatabaseMetaData;
+import java.sql.ResultSet;
+import java.sql.RowIdLifetime;
+import java.sql.SQLException;
+import java.sql.SQLFeatureNotSupportedException;
+
+import org.apache.cassandra.db.DBConstants;
+import org.apache.cassandra.utils.FBUtilities;
+
+public class CassandraDatabaseMetaData implements DatabaseMetaData
+{
+    private CassandraConnection connection;
+    
+    public CassandraDatabaseMetaData(CassandraConnection connection)
+    {
+        this.connection = connection;
+    }
+    
+    public boolean isWrapperFor(Class<?> iface) throws SQLException
+    {
+        return iface.isAssignableFrom(getClass());
+    }
+
+    public <T> T unwrap(Class<T> iface) throws SQLException
+    {
+        if (iface.isAssignableFrom(getClass())) return iface.cast(this);
+        throw new SQLFeatureNotSupportedException(String.format(NO_INTERFACE, iface.getSimpleName()));
+    }      
+
+    public boolean allProceduresAreCallable() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean allTablesAreSelectable() throws SQLException
+    {
+        return true;
+    }
+
+    public boolean autoCommitFailureClosesAllResultSets() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean dataDefinitionCausesTransactionCommit() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean dataDefinitionIgnoredInTransactions() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean deletesAreDetected(int arg0) throws SQLException
+    {
+        return false;
+    }
+
+    public boolean doesMaxRowSizeIncludeBlobs() throws SQLException
+    {
+        return false;
+    }
+
+    public ResultSet getAttributes(String arg0, String arg1, String arg2, String arg3) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public ResultSet getBestRowIdentifier(String arg0, String arg1, String arg2, int arg3, boolean arg4) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public String getCatalogSeparator() throws SQLException
+    {
+        return "";
+    }
+
+    public String getCatalogTerm() throws SQLException
+    {
+        return "";
+    }
+
+    public ResultSet getCatalogs() throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public ResultSet getClientInfoProperties() throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public ResultSet getColumnPrivileges(String arg0, String arg1, String arg2, String arg3) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public ResultSet getColumns(String arg0, String arg1, String arg2, String arg3) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public Connection getConnection() throws SQLException
+    {
+        return connection;
+    }
+
+    public ResultSet getCrossReference(String arg0, String arg1, String arg2, String arg3, String arg4, String arg5) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public int getDatabaseMajorVersion() throws SQLException
+    {
+        return CassandraConnection.DB_MAJOR_VERSION;
+    }
+
+    public int getDatabaseMinorVersion() throws SQLException
+    {
+        return CassandraConnection.DB_MINOR_VERSION;
+    }
+
+    public String getDatabaseProductName() throws SQLException
+    {
+        return CassandraConnection.DB_PRODUCT_NAME;
+    }
+
+    public String getDatabaseProductVersion() throws SQLException
+    {
+        return String.format("%d.%d", CassandraConnection.DB_MAJOR_VERSION,CassandraConnection.DB_MINOR_VERSION);
+    }
+
+    public int getDefaultTransactionIsolation() throws SQLException
+    {
+        return Connection.TRANSACTION_NONE;
+    }
+
+    public int getDriverMajorVersion()
+    {
+        return CassandraDriver.DVR_MAJOR_VERSION;
+    }
+
+    public int getDriverMinorVersion()
+    {
+        return CassandraDriver.DVR_MINOR_VERSION;
+    }
+
+    public String getDriverName() throws SQLException
+    {
+        return CassandraDriver.DVR_NAME;
+    }
+
+    public String getDriverVersion() throws SQLException
+    {
+        return String.format("%d.%d.%d", CassandraDriver.DVR_MAJOR_VERSION,CassandraDriver.DVR_MINOR_VERSION,CassandraDriver.DVR_PATCH_VERSION);
+    }
+
+    public ResultSet getExportedKeys(String arg0, String arg1, String arg2) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public String getExtraNameCharacters() throws SQLException
+    {
+        return "";
+    }
+
+    public ResultSet getFunctionColumns(String arg0, String arg1, String arg2, String arg3) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public ResultSet getFunctions(String arg0, String arg1, String arg2) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public String getIdentifierQuoteString() throws SQLException
+    {
+        return "'";
+    }
+
+    public ResultSet getImportedKeys(String arg0, String arg1, String arg2) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public ResultSet getIndexInfo(String arg0, String arg1, String arg2, boolean arg3, boolean arg4) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public int getJDBCMajorVersion() throws SQLException
+    {
+        return 4;
+    }
+
+    public int getJDBCMinorVersion() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxBinaryLiteralLength() throws SQLException
+    {
+        // Cassandra can represent a 2GB value, but CQL has to encode it in hex
+        return Integer.MAX_VALUE / 2;
+    }
+
+    public int getMaxCatalogNameLength() throws SQLException
+    {
+        return Short.MAX_VALUE;
+    }
+
+    public int getMaxCharLiteralLength() throws SQLException
+    {
+        return Integer.MAX_VALUE;
+    }
+
+    public int getMaxColumnNameLength() throws SQLException
+    {
+        return Short.MAX_VALUE;
+    }
+
+    public int getMaxColumnsInGroupBy() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxColumnsInIndex() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxColumnsInOrderBy() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxColumnsInSelect() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxColumnsInTable() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxConnections() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxCursorNameLength() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxIndexLength() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxProcedureNameLength() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxRowSize() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxSchemaNameLength() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxStatementLength() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxStatements() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxTableNameLength() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxTablesInSelect() throws SQLException
+    {
+        return 0;
+    }
+
+    public int getMaxUserNameLength() throws SQLException
+    {
+        return 0;
+    }
+
+    public String getNumericFunctions() throws SQLException
+    {
+        return null;
+    }
+
+    public ResultSet getPrimaryKeys(String arg0, String arg1, String arg2) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public ResultSet getProcedureColumns(String arg0, String arg1, String arg2, String arg3) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public String getProcedureTerm() throws SQLException
+    {
+        return "";
+    }
+
+    public ResultSet getProcedures(String arg0, String arg1, String arg2) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public int getResultSetHoldability() throws SQLException
+    {
+        return CResultSet.DEFAULT_HOLDABILITY;
+    }
+
+    public RowIdLifetime getRowIdLifetime() throws SQLException
+    {
+        return RowIdLifetime.ROWID_UNSUPPORTED;
+    }
+
+    public String getSQLKeywords() throws SQLException
+    {
+        return "";
+    }
+
+    public int getSQLStateType() throws SQLException
+    {
+        return sqlStateSQL;
+    }
+
+    public String getSchemaTerm() throws SQLException
+    {
+        return "";
+    }
+
+    public ResultSet getSchemas() throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public ResultSet getSchemas(String arg0, String arg1) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public String getSearchStringEscape() throws SQLException
+    {
+        return "\\";
+    }
+
+    public String getStringFunctions() throws SQLException
+    {
+        return "";
+    }
+
+    public ResultSet getSuperTables(String arg0, String arg1, String arg2) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public ResultSet getSuperTypes(String arg0, String arg1, String arg2) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public String getSystemFunctions() throws SQLException
+    {
+        return "";
+    }
+
+    public ResultSet getTablePrivileges(String arg0, String arg1, String arg2) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public ResultSet getTableTypes() throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public ResultSet getTables(String arg0, String arg1, String arg2, String[] arg3) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public String getTimeDateFunctions() throws SQLException
+    {
+        return "";
+    }
+
+    public ResultSet getTypeInfo() throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public ResultSet getUDTs(String arg0, String arg1, String arg2, int[] arg3) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public String getURL() throws SQLException
+    {
+        return connection.url;
+    }
+
+    public String getUserName() throws SQLException
+    {
+        return (connection.username==null) ? "" : connection.username;
+    }
+
+    public ResultSet getVersionColumns(String arg0, String arg1, String arg2) throws SQLException
+    {
+        return new CResultSet();
+    }
+
+    public boolean insertsAreDetected(int arg0) throws SQLException
+    {
+        return false;
+    }
+
+    public boolean isCatalogAtStart() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean isReadOnly() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean locatorsUpdateCopy() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean nullPlusNonNullIsNull() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean nullsAreSortedAtEnd() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean nullsAreSortedAtStart() throws SQLException
+    {
+        return true;
+    }
+
+    public boolean nullsAreSortedHigh() throws SQLException
+    {
+        return true;
+    }
+
+    public boolean nullsAreSortedLow() throws SQLException
+    {
+
+        return false;
+    }
+
+    public boolean othersDeletesAreVisible(int arg0) throws SQLException
+    {
+        return false;
+    }
+
+    public boolean othersInsertsAreVisible(int arg0) throws SQLException
+    {
+        return false;
+    }
+
+    public boolean othersUpdatesAreVisible(int arg0) throws SQLException
+    {
+        return false;
+    }
+
+    public boolean ownDeletesAreVisible(int arg0) throws SQLException
+    {
+        return false;
+    }
+
+    public boolean ownInsertsAreVisible(int arg0) throws SQLException
+    {
+        return false;
+    }
+
+    public boolean ownUpdatesAreVisible(int arg0) throws SQLException
+    {
+        return false;
+    }
+
+    public boolean storesLowerCaseIdentifiers() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean storesLowerCaseQuotedIdentifiers() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean storesMixedCaseIdentifiers() throws SQLException
+    {
+        return true;
+    }
+
+    public boolean storesMixedCaseQuotedIdentifiers() throws SQLException
+    {
+        return true;
+    }
+
+    public boolean storesUpperCaseIdentifiers() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean storesUpperCaseQuotedIdentifiers() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsANSI92EntryLevelSQL() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsANSI92FullSQL() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsANSI92IntermediateSQL() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsAlterTableWithAddColumn() throws SQLException
+    {
+        return true;
+    }
+
+    public boolean supportsAlterTableWithDropColumn() throws SQLException
+    {
+        return true;
+    }
+
+    public boolean supportsBatchUpdates() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsCatalogsInDataManipulation() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsCatalogsInIndexDefinitions() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsCatalogsInPrivilegeDefinitions() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsCatalogsInProcedureCalls() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsCatalogsInTableDefinitions() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsColumnAliasing() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsConvert() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsConvert(int arg0, int arg1) throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsCoreSQLGrammar() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsCorrelatedSubqueries() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsDataDefinitionAndDataManipulationTransactions() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsDataManipulationTransactionsOnly() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsDifferentTableCorrelationNames() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsExpressionsInOrderBy() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsExtendedSQLGrammar() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsFullOuterJoins() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsGetGeneratedKeys() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsGroupBy() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsGroupByBeyondSelect() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsGroupByUnrelated() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsIntegrityEnhancementFacility() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsLikeEscapeClause() throws SQLException
+    {
+
+        return false;
+    }
+
+    public boolean supportsLimitedOuterJoins() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsMinimumSQLGrammar() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsMixedCaseIdentifiers() throws SQLException
+    {
+        return true;
+    }
+
+    public boolean supportsMixedCaseQuotedIdentifiers() throws SQLException
+    {
+        return true;
+    }
+
+    public boolean supportsMultipleOpenResults() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsMultipleResultSets() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsMultipleTransactions() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsNamedParameters() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsNonNullableColumns() throws SQLException
+    {
+
+        return false;
+    }
+
+    public boolean supportsOpenCursorsAcrossCommit() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsOpenCursorsAcrossRollback() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsOpenStatementsAcrossCommit() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsOpenStatementsAcrossRollback() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsOrderByUnrelated() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsOuterJoins() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsPositionedDelete() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsPositionedUpdate() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsResultSetConcurrency(int arg0, int arg1) throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsResultSetHoldability(int holdability) throws SQLException
+    {
+
+        return ResultSet.HOLD_CURSORS_OVER_COMMIT==holdability;
+    }
+
+    public boolean supportsResultSetType(int type) throws SQLException
+    {
+
+        return ResultSet.TYPE_FORWARD_ONLY==type;
+    }
+
+    public boolean supportsSavepoints() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsSchemasInDataManipulation() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsSchemasInIndexDefinitions() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsSchemasInPrivilegeDefinitions() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsSchemasInProcedureCalls() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsSchemasInTableDefinitions() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsSelectForUpdate() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsStatementPooling() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsStoredFunctionsUsingCallSyntax() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsStoredProcedures() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsSubqueriesInComparisons() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsSubqueriesInExists() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsSubqueriesInIns() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsSubqueriesInQuantifieds() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsTableCorrelationNames() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsTransactionIsolationLevel(int level) throws SQLException
+    {
+
+        return Connection.TRANSACTION_NONE==level;
+    }
+
+    public boolean supportsTransactions() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsUnion() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean supportsUnionAll() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean updatesAreDetected(int arg0) throws SQLException
+    {
+        return false;
+    }
+
+    public boolean usesLocalFilePerTable() throws SQLException
+    {
+        return false;
+    }
+
+    public boolean usesLocalFiles() throws SQLException
+    {
+        return false;
+    }
+
+}
diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraDriver.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraDriver.java
index e69de29b..31edfd7e 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraDriver.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraDriver.java
@@ -0,0 +1,139 @@
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+package org.apache.cassandra.cql.jdbc;
+
+import static org.apache.cassandra.cql.jdbc.Utils.PROTOCOL;
+import static org.apache.cassandra.cql.jdbc.Utils.TAG_PASSWORD;
+import static org.apache.cassandra.cql.jdbc.Utils.TAG_USER;
+
+import java.sql.Connection;
+import java.sql.Driver;
+import java.sql.DriverManager;
+import java.sql.DriverPropertyInfo;
+import java.sql.SQLException;
+import java.util.Properties;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * The Class CassandraDriver.
+ */
+public class CassandraDriver implements Driver
+{
+    public static final int DVR_MAJOR_VERSION = 1;
+
+    public static final int DVR_MINOR_VERSION = 0;
+
+    public static final int DVR_PATCH_VERSION = 4;
+
+    public static final String DVR_NAME = "Cassandra JDBC Driver";
+
+    private static final Logger logger = LoggerFactory.getLogger(CassandraDriver.class);
+
+    static
+    {
+        // Register the CassandraDriver with DriverManager
+        try
+        {
+            CassandraDriver driverInst = new CassandraDriver();
+            DriverManager.registerDriver(driverInst);
+        }
+        catch (SQLException e)
+        {
+            throw new RuntimeException(e.getMessage());
+        }
+    }
+
+    /**
+     * Method to validate whether provided connection url matches with pattern or not.
+     */
+    public boolean acceptsURL(String url) throws SQLException
+    {
+        return url.startsWith(PROTOCOL);
+    }
+
+    /**
+     * Method to return connection instance for given connection url and connection props.
+     */
+    public Connection connect(String url, Properties props) throws SQLException
+    {
+        Properties finalProps;
+        if (acceptsURL(url))
+        {
+            // parse the URL into a set of Properties
+            finalProps = Utils.parseURL(url);
+
+            // override any matching values in finalProps with values from props
+            finalProps.putAll(props);
+
+            if (logger.isDebugEnabled()) logger.debug("Final Properties to Connection: {}", finalProps);
+
+            return new CassandraConnection(finalProps);
+        }
+        else
+        {
+            return null; // signal it is the wrong driver for this protocol:subprotocol
+        }
+    }
+
+    /**
+     * Returns default major version.
+     */
+    public int getMajorVersion()
+    {
+        return DVR_MAJOR_VERSION;
+    }
+
+    /**
+     * Returns default minor version.
+     */
+    public int getMinorVersion()
+    {
+        return DVR_MINOR_VERSION;
+    }
+
+    /**
+     * Returns default driver property info object.
+     */
+    public DriverPropertyInfo[] getPropertyInfo(String url, Properties props) throws SQLException
+    {
+        if (props == null) props = new Properties();
+
+        DriverPropertyInfo[] info = new DriverPropertyInfo[2];
+
+        info[0] = new DriverPropertyInfo(TAG_USER, props.getProperty(TAG_USER));
+        info[0].description = "The 'user' property";
+
+        info[1] = new DriverPropertyInfo(TAG_PASSWORD, props.getProperty(TAG_PASSWORD));
+        info[1].description = "The 'password' property";
+
+        return info;
+    }
+
+    /**
+     * Returns true, if it is jdbc compliant.
+     */
+    public boolean jdbcCompliant()
+    {
+        return false;
+    }
+}
diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraPreparedStatement.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraPreparedStatement.java
index e69de29b..348dfc65 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraPreparedStatement.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraPreparedStatement.java
@@ -0,0 +1,556 @@
+package org.apache.cassandra.cql.jdbc;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+import static org.apache.cassandra.cql.jdbc.Utils.determineCurrentKeyspace;
+import static org.apache.cassandra.cql.jdbc.Utils.determineCurrentColumnFamily;
+import static org.apache.cassandra.cql.jdbc.Utils.NO_CF;
+import static org.apache.cassandra.cql.jdbc.Utils.NO_COMPARATOR;
+import static org.apache.cassandra.cql.jdbc.Utils.NO_VALIDATOR;
+
+import org.apache.cassandra.db.marshal.*;
+
+import java.io.InputStream;
+import java.io.Reader;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.net.URL;
+import java.nio.ByteBuffer;
+import java.sql.Array;
+import java.sql.Blob;
+import java.sql.Clob;
+import java.sql.Date;
+import java.sql.NClob;
+import java.sql.ParameterMetaData;
+import java.sql.PreparedStatement;
+import java.sql.Ref;
+import java.sql.ResultSet;
+import java.sql.ResultSetMetaData;
+import java.sql.RowId;
+import java.sql.SQLDataException;
+import java.sql.SQLException;
+import java.sql.SQLFeatureNotSupportedException;
+import java.sql.SQLTransientException;
+import java.sql.SQLXML;
+import java.sql.Time;
+import java.sql.Timestamp;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class CassandraPreparedStatement extends CassandraStatement implements PreparedStatement
+{
+    //    private static final Pattern Parameterizable = Pattern.compile("(SELECT|DELETE|UPDATE)\\s+.*", Pattern.CASE_INSENSITIVE);
+    private static final Pattern Select = Pattern.compile("SELECT[\\s+FIRST\\s+\\d+]?[\\s+REVERSED]?\\s+(.*)WHERE\\s+(.*)", Pattern.CASE_INSENSITIVE);
+    private static final Pattern Update = Pattern.compile("UPDATE\\s+\\w+.*\\s+SET\\s+(.*)\\s+WHERE KEY(.*)", Pattern.CASE_INSENSITIVE);
+    private static final Pattern Delete = Pattern.compile("DELETE\\s+(.*)\\s+FROM\\s+\\w+\\s+WHERE KEY(.*)", Pattern.CASE_INSENSITIVE);
+
+    // current set of bound variables.
+    private final Map<Integer, Object> variables = new HashMap<Integer, Object>();
+
+    // for batching. These are the queries that have been batched and not executed.
+    private final List<String> queries = new ArrayList<String>();
+
+    CassandraPreparedStatement(CassandraConnection con, String cql) throws SQLException
+    {
+        super(con, cql);
+    }
+
+    // impl specific methods start here.
+
+    // double quotes strings (in parameters)
+    private static String makeCqlString(String s)
+    {
+        // escape any single-quotes with double single-quotes.
+        return s.replaceAll("\'", "\'\'");
+    }
+
+    // null type means just call param.toString() and quote it (default for keys).
+    private static String applySimpleBindings(String q, AbstractType type, ParameterIterator params) throws SQLException
+    {
+        assert type != null;
+        // we need to keep track of whether or not we are between quotes and ignore any question marks within them
+        // so that they are not substituted.  
+        StringBuffer sb = new StringBuffer();
+        boolean between = false;
+        for (char c : q.toCharArray())
+        {
+            if (c == '\'')
+                between = !between;
+            if (between)
+                sb.append(c);
+            else if (c == '?') // !between if we got here.
+            {
+                try
+                {
+                    // perform substitution!
+                    Object param = params.nextParam();
+                    String stringParam = type == null ? param.toString() : type.toString(param);
+                    stringParam = makeCqlString(stringParam);
+                    if (type == null || type.needsQuotes())
+                        stringParam = "'" + stringParam + "'";
+                    sb.append(stringParam);
+                }
+                catch (ClassCastException ex)
+                {
+                    throw new SQLException("Mismatched types: " + ex.getLocalizedMessage());
+                }
+            }
+            else
+                sb.append(c);
+
+        }
+        return sb.toString();
+    }
+
+    private static String applyDualBindings(String q, AbstractType ltype, AbstractType rtype, ParameterIterator params) throws SQLException
+    {
+        StringBuffer sb = new StringBuffer();
+        boolean between = false;
+        boolean left = true; // we always start on the left-hand side of a statement. we switch state if we reach a comma and we are not between.
+        for (char c : q.toCharArray())
+        {
+            if (c == '\'')
+                between = !between;
+            if (c == '=' && !between)
+                left = false;
+            if (c == ',' && !between)
+                left = true;
+
+            if (c == '?' && !between)
+            {
+                try
+                {
+                    Object param = params.nextParam();
+                    AbstractType type = left ? ltype : rtype;
+                    String stringParam = makeCqlString(type.toString(param));
+                    if (type.needsQuotes())
+                        stringParam = "'" + stringParam + "'";
+                    sb.append(stringParam);
+                }
+                catch (ClassCastException ex)
+                {
+                    throw new SQLException("Mismatched types: " + ex.getLocalizedMessage());
+                }
+            }
+            else
+                sb.append(c);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * applies current bindings to produce a string that can be sent to the server.
+     */
+    public synchronized String makeCql() throws SQLException
+    {
+        // break cql up
+        Matcher m;
+        m = Delete.matcher(cql);
+        if (m.matches())
+            return makeDelete(m.end(1));
+        m = Update.matcher(cql);
+        if (m.matches())
+            return makeUpdate(m.end(1));
+        m = Select.matcher(cql);
+        if (m.matches())
+            return makeSelect(m.end(1));
+
+        // if we made it this far, cql is not parameterizable. this isn't bad, there is just nothing to be done.
+        return cql;
+    }
+
+    // subs parameters into a delete statement.
+    private String makeDelete(int pivot) throws SQLException
+    {
+        String keyspace = determineCurrentKeyspace(cql, connection.currentKeyspace);
+        String columnFamily = determineCurrentColumnFamily(cql);
+        if (columnFamily == null) throw new SQLTransientException(NO_CF);
+
+        ParameterIterator params = new ParameterIterator();
+        String left = cql.substring(0, pivot);
+        AbstractType leftType = connection.decoder.getComparator(keyspace, columnFamily);
+        if (leftType == null) throw new SQLDataException(String.format(NO_COMPARATOR, keyspace, columnFamily));
+        left = applySimpleBindings(left, leftType, params);
+
+        String right = cql.substring(pivot);
+        AbstractType keyVald = connection.decoder.getKeyValidator(keyspace, columnFamily);
+        if (keyVald == null) throw new SQLDataException(String.format(NO_VALIDATOR, keyspace, columnFamily));
+        right = applySimpleBindings(right, keyVald, params);
+        return left + right;
+    }
+
+    // subs parameters into a select statement.
+    private String makeSelect(int pivot) throws SQLException
+    {
+        String keyspace = determineCurrentKeyspace(cql, connection.currentKeyspace);
+        String columnFamily = determineCurrentColumnFamily(cql);
+        if (columnFamily == null) throw new SQLTransientException(NO_CF);
+
+        ParameterIterator params = new ParameterIterator();
+        String left = cql.substring(0, pivot);
+        AbstractType leftType = connection.decoder.getComparator(keyspace, columnFamily);
+        if (leftType == null) throw new SQLDataException(String.format(NO_COMPARATOR, keyspace, columnFamily));
+        left = applySimpleBindings(left, leftType, params);
+
+        String right = cql.substring(pivot);
+        AbstractType keyVald = connection.decoder.getKeyValidator(keyspace, columnFamily);
+        if (keyVald == null) throw new SQLDataException(String.format(NO_VALIDATOR, keyspace, columnFamily));
+        right = applySimpleBindings(right, keyVald, params);
+        return left + right;
+    }
+
+    // subs parameters into an update statement.
+    private String makeUpdate(int pivot) throws SQLException
+    {
+        // this one is a little bit different. left contains key=value pairs. we use the comparator for the left side,
+        // the validator for the right side.  right side is treated as a key.
+        String keyspace = determineCurrentKeyspace(cql, connection.currentKeyspace);
+        String columnFamily = determineCurrentColumnFamily(cql);
+        if (columnFamily == null) throw new SQLTransientException(NO_CF);
+
+        ParameterIterator params = new ParameterIterator();
+        String left = cql.substring(0, pivot);
+        AbstractType leftComp = connection.decoder.getComparator(keyspace, columnFamily);
+        if (leftComp == null) throw new SQLDataException(String.format(NO_COMPARATOR, keyspace, columnFamily));
+
+        AbstractType leftVald = connection.decoder.getComparator(keyspace, columnFamily);
+        if (leftVald == null) throw new SQLDataException(String.format(NO_VALIDATOR, keyspace, columnFamily));
+        left = applyDualBindings(left, leftComp, leftVald, params);
+
+        String right = cql.substring(pivot);
+        AbstractType keyVald = connection.decoder.getKeyValidator(keyspace, columnFamily);
+        if (keyVald == null) throw new SQLDataException(String.format(NO_VALIDATOR, keyspace, columnFamily));
+        right = applySimpleBindings(right, keyVald, params);
+        return left + right;
+    }
+
+
+    // standard API methods follow.
+
+    public void addBatch() throws SQLException
+    {
+        queries.add(makeCql());
+    }
+
+    public synchronized void clearParameters() throws SQLException
+    {
+        variables.clear();
+    }
+
+    public boolean execute() throws SQLException
+    {
+        return this.cql != null && super.execute(makeCql());
+    }
+
+    public ResultSet executeQuery() throws SQLException
+    {
+        return this.cql == null ? null : super.executeQuery(makeCql());
+    }
+
+    public int executeUpdate() throws SQLException
+    {
+        return this.cql == null ? 0 : super.executeUpdate(makeCql());
+    }
+
+    public ResultSetMetaData getMetaData() throws SQLException
+    {
+        // todo: current impl of RSMD relies on knowing the results. implementing this will require refactoring CRSMD into 
+        // two classes: the first will be an implementation whose methods don't rely on knowing the results, the second
+        // will implement the full CRSMD interface and extend or compose the first.
+        throw new SQLFeatureNotSupportedException("PreparedStatement.getMetaData() hasn't been implemented yet.");
+    }
+
+    public void setByte(int parameterIndex, byte x) throws SQLException
+    {
+        setObject(parameterIndex, new byte[]{ x });
+    }
+
+    public void setBytes(int parameterIndex, byte[] x) throws SQLException
+    {
+        setObject(parameterIndex, ByteBuffer.wrap(x));
+    }
+
+    public void setInt(int parameterIndex, int x) throws SQLException
+    {
+        setObject(parameterIndex, new BigInteger(Integer.toString(x)));
+    }
+
+    public void setLong(int parameterIndex, long x) throws SQLException
+    {
+        setObject(parameterIndex, x);
+    }
+
+    public void setNString(int parameterIndex, String value) throws SQLException
+    {
+        setString(parameterIndex, value);
+    }
+
+    public void setObject(int parameterIndex, Object x) throws SQLException
+    {
+        variables.put(parameterIndex, x);
+    }
+
+    public void setShort(int parameterIndex, short x) throws SQLException
+    {
+        setInt(parameterIndex, x);
+    }
+
+    public void setString(int parameterIndex, String x) throws SQLException
+    {
+        setObject(parameterIndex, x);
+    }
+
+
+    // everything below here is not implemented and will let you know about it.
+
+
+    public ParameterMetaData getParameterMetaData() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException("PreparedStatement.getParameterMetaData() hasn't been implemented yet.");
+    }
+
+    public void setArray(int parameterIndex, Array x) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setAsciiStream(int parameterIndex, InputStream x) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setAsciiStream(int parameterIndex, InputStream x, int length) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setBinaryStream(int parameterIndex, InputStream x) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setBinaryStream(int parameterIndex, InputStream x, int length) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setBinaryStream(int parameterIndex, InputStream x, long length) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setBlob(int parameterIndex, Blob x) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setBlob(int parameterIndex, InputStream inputStream) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setBlob(int parameterIndex, InputStream inputStream, long length) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setBoolean(int parameterIndex, boolean x) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setCharacterStream(int parameterIndex, Reader reader) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setCharacterStream(int parameterIndex, Reader reader, int length) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setClob(int parameterIndex, Clob x) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException("method not supported");
+    }
+
+    public void setClob(int parameterIndex, Reader reader) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setClob(int parameterIndex, Reader reader, long length) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setDate(int parameterIndex, Date x) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setDate(int parameterIndex, Date x, Calendar cal) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setDouble(int parameterIndex, double x) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setFloat(int parameterIndex, float x) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setNClob(int parameterIndex, NClob value) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setNClob(int parameterIndex, Reader reader) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setNClob(int parameterIndex, Reader reader, long length) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setNull(int parameterIndex, int sqlType) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setNull(int parameterIndex, int sqlType, String typeName) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setObject(int parameterIndex, Object x, int targetSqlType) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setRef(int parameterIndex, Ref x) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setRowId(int parameterIndex, RowId x) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setTime(int parameterIndex, Time x) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setTime(int parameterIndex, Time x, Calendar cal) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setTimestamp(int parameterIndex, Timestamp x) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setTimestamp(int parameterIndex, Timestamp x, Calendar cal) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setURL(int parameterIndex, URL x) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+    public void setUnicodeStream(int parameterIndex, InputStream x, int length) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NOT_SUPPORTED);
+    }
+
+
+    // done with API methods.
+
+
+    // provides a way to iterate through the parameters. it will blow up if it discovers any missing parameters.
+    // not thread-safe.
+    private class ParameterIterator
+    {
+        private Map<Integer, Object> params = new HashMap<Integer, Object>(variables);
+        private int index = 1;
+
+        // throws SQLException if a parameter is not specified.
+        private Object nextParam() throws SQLException
+        {
+            Object p = params.get(index++);
+            if (p == null)
+                throw new SQLException("No parameter bound to " + (index - 1));
+            return p;
+        }
+
+    }
+}
diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraResultSet.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraResultSet.java
index e69de29b..1ac806e2 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraResultSet.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraResultSet.java
@@ -0,0 +1,45 @@
+package org.apache.cassandra.cql.jdbc;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+import java.math.BigInteger;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+
+public interface CassandraResultSet extends ResultSet
+{
+    /**
+     * @return the current row key
+     */
+    public byte[] getKey()throws SQLException;;
+    
+    public TypedColumn getTypedKey()throws SQLException;;
+
+    /** @return a BigInteger value for the given column offset*/
+    public BigInteger getBigInteger(int i) throws SQLException;
+    /** @return a BigInteger value for the given column name */
+    public BigInteger getBigInteger(String name) throws SQLException;
+
+    /** @return the raw column data for the given column offset */
+    public TypedColumn getColumn(int i) throws SQLException;
+    /** @return the raw column data for the given column name */
+    public TypedColumn getColumn(String name) throws SQLException;
+}
diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraStatement.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraStatement.java
index e69de29b..4e974884 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraStatement.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/CassandraStatement.java
@@ -0,0 +1,427 @@
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+package org.apache.cassandra.cql.jdbc;
+
+import static org.apache.cassandra.cql.jdbc.Utils.*;
+
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.SQLFeatureNotSupportedException;
+import java.sql.SQLNonTransientConnectionException;
+import java.sql.SQLNonTransientException;
+import java.sql.SQLRecoverableException;
+import java.sql.SQLSyntaxErrorException;
+import java.sql.SQLTransientConnectionException;
+import java.sql.SQLWarning;
+import java.sql.Statement;
+import java.util.regex.Pattern;
+
+import org.apache.cassandra.thrift.CqlResult;
+import org.apache.cassandra.thrift.InvalidRequestException;
+import org.apache.cassandra.thrift.SchemaDisagreementException;
+import org.apache.cassandra.thrift.TimedOutException;
+import org.apache.cassandra.thrift.UnavailableException;
+import org.apache.thrift.TException;
+
+/**
+ * Cassandra statement: implementation class for {@link PreparedStatement}.
+ */
+
+class CassandraStatement extends AbstractStatement implements Statement
+{
+    /**
+     * The connection.
+     */
+    protected CassandraConnection connection;
+
+    /**
+     * The cql.
+     */
+    protected String cql;
+
+    protected int fetchDirection = ResultSet.FETCH_FORWARD;
+
+    protected int fetchSize = 0;
+
+    protected int maxFieldSize = 0;
+
+    protected int maxRows = 0;
+
+    protected int resultSetType = CResultSet.DEFAULT_TYPE;
+
+    protected int resultSetConcurrency = CResultSet.DEFAULT_CONCURRENCY;
+
+    protected int resultSetHoldability = CResultSet.DEFAULT_HOLDABILITY;
+
+    protected ResultSet currentResultSet = null;
+
+    protected int updateCount = -1;
+
+    protected boolean escapeProcessing = true;
+
+    CassandraStatement(CassandraConnection con) throws SQLException
+    {
+        this(con, null);
+    }
+
+    CassandraStatement(CassandraConnection con, String cql) throws SQLException
+    {
+        this.connection = con;
+        this.cql = cql;
+    }
+
+    CassandraStatement(CassandraConnection con, String cql, int resultSetType, int resultSetConcurrency) throws SQLException
+    {
+        this(con, cql, resultSetType, resultSetConcurrency, ResultSet.HOLD_CURSORS_OVER_COMMIT);
+    }
+
+    CassandraStatement(CassandraConnection con, String cql, int resultSetType, int resultSetConcurrency,
+                       int resultSetHoldability) throws SQLException
+    {
+        this.connection = con;
+        this.cql = cql;
+
+        if (!(resultSetType == ResultSet.TYPE_FORWARD_ONLY
+              || resultSetType == ResultSet.TYPE_SCROLL_INSENSITIVE
+              || resultSetType == ResultSet.TYPE_SCROLL_SENSITIVE)) throw new SQLSyntaxErrorException(BAD_TYPE_RSET);
+        this.resultSetType = resultSetType;
+
+        if (!(resultSetConcurrency == ResultSet.CONCUR_READ_ONLY
+              || resultSetConcurrency == ResultSet.CONCUR_UPDATABLE)) throw new SQLSyntaxErrorException(BAD_TYPE_RSET);
+        this.resultSetConcurrency = resultSetConcurrency;
+
+
+        if (!(resultSetHoldability == ResultSet.HOLD_CURSORS_OVER_COMMIT
+              || resultSetHoldability == ResultSet.CLOSE_CURSORS_AT_COMMIT))
+            throw new SQLSyntaxErrorException(BAD_HOLD_RSET);
+        this.resultSetHoldability = resultSetHoldability;
+    }
+
+    public void addBatch(String arg0) throws SQLException
+    {
+        checkNotClosed();
+        throw new SQLFeatureNotSupportedException(NO_BATCH);
+    }
+
+    private final void checkNotClosed() throws SQLException
+    {
+        if (isClosed()) throw new SQLRecoverableException(WAS_CLOSED_STMT);
+    }
+
+    public void clearBatch() throws SQLException
+    {
+        checkNotClosed();
+        throw new SQLFeatureNotSupportedException(NO_BATCH);
+    }
+
+    public void clearWarnings() throws SQLException
+    {
+        // This implementation does not support the collection of warnings so clearing is a no-op
+        // but it is still an exception to call this on a closed connection.
+        checkNotClosed();
+    }
+
+    public void close() throws SQLException
+    {
+        connection = null;
+        cql = null;
+    }
+
+    private void doExecute(String sql) throws SQLException
+    {
+        try
+        {
+            resetResults();
+            CqlResult rSet = connection.execute(sql);
+            String keyspace = connection.currentKeyspace;
+            String columnfamily = determineCurrentColumnFamily(sql);
+
+            switch (rSet.getType())
+            {
+                case ROWS:
+                    currentResultSet = new CResultSet(this, rSet, connection.decoder, keyspace, columnfamily);
+                    break;
+                case INT:
+                    updateCount = rSet.getNum();
+                    break;
+                case VOID:
+                    updateCount = 0;
+                    break;
+            }
+        }
+        catch (InvalidRequestException e)
+        {
+            throw new SQLSyntaxErrorException(e.getWhy());
+        }
+        catch (UnavailableException e)
+        {
+            throw new SQLNonTransientConnectionException(NO_SERVER, e);
+        }
+        catch (TimedOutException e)
+        {
+            throw new SQLTransientConnectionException(e.getMessage());
+        }
+        catch (SchemaDisagreementException e)
+        {
+            throw new SQLRecoverableException(SCHEMA_MISMATCH);
+        }
+        catch (TException e)
+        {
+            throw new SQLNonTransientConnectionException(e.getMessage());
+        }
+
+    }
+
+    public boolean execute(String query) throws SQLException
+    {
+        checkNotClosed();
+        doExecute(query);
+        return !(currentResultSet == null);
+    }
+
+    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException
+    {
+        checkNotClosed();
+
+        if (!(autoGeneratedKeys == RETURN_GENERATED_KEYS || autoGeneratedKeys == NO_GENERATED_KEYS))
+            throw new SQLSyntaxErrorException(BAD_AUTO_GEN);
+
+        if (autoGeneratedKeys == RETURN_GENERATED_KEYS) throw new SQLFeatureNotSupportedException(NO_GEN_KEYS);
+
+        return execute(sql);
+    }
+
+    public int[] executeBatch() throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(NO_BATCH);
+    }
+
+    public ResultSet executeQuery(String query) throws SQLException
+    {
+        checkNotClosed();
+        doExecute(query);
+        if (currentResultSet == null)
+            throw new SQLNonTransientException(NO_RESULTSET);
+        return currentResultSet;
+    }
+
+    public int executeUpdate(String query) throws SQLException
+    {
+        checkNotClosed();
+        doExecute(query);
+        if (currentResultSet != null)
+            throw new SQLNonTransientException(NO_UPDATE_COUNT);
+        return updateCount;
+    }
+
+    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException
+    {
+        checkNotClosed();
+
+        if (!(autoGeneratedKeys == RETURN_GENERATED_KEYS || autoGeneratedKeys == NO_GENERATED_KEYS))
+            throw new SQLFeatureNotSupportedException(BAD_AUTO_GEN);
+
+        return executeUpdate(sql);
+    }
+
+    public Connection getConnection() throws SQLException
+    {
+        checkNotClosed();
+        return (Connection) connection;
+    }
+
+    public int getFetchDirection() throws SQLException
+    {
+        checkNotClosed();
+        return fetchDirection;
+    }
+
+    public int getFetchSize() throws SQLException
+    {
+        checkNotClosed();
+        return fetchSize;
+    }
+
+    public int getMaxFieldSize() throws SQLException
+    {
+        checkNotClosed();
+        return maxFieldSize;
+    }
+
+    public int getMaxRows() throws SQLException
+    {
+        checkNotClosed();
+        return maxRows;
+    }
+
+    public boolean getMoreResults() throws SQLException
+    {
+        checkNotClosed();
+        resetResults();
+        // in the current Cassandra implementation there are never MORE results
+        return false;
+    }
+
+    public boolean getMoreResults(int current) throws SQLException
+    {
+        checkNotClosed();
+
+        switch (current)
+        {
+            case CLOSE_CURRENT_RESULT:
+                resetResults();
+                break;
+
+            case CLOSE_ALL_RESULTS:
+            case KEEP_CURRENT_RESULT:
+                throw new SQLFeatureNotSupportedException(NO_MULTIPLE);
+
+            default:
+                throw new SQLSyntaxErrorException(String.format(BAD_KEEP_RSET, current));
+        }
+        // in the current Cassandra implementation there are never MORE results
+        return false;
+    }
+
+    public int getQueryTimeout() throws SQLException
+    {
+        // the Cassandra implementation does not support timeouts on queries
+        return 0;
+    }
+
+    public ResultSet getResultSet() throws SQLException
+    {
+        checkNotClosed();
+        return currentResultSet;
+    }
+
+    public int getResultSetConcurrency() throws SQLException
+    {
+        checkNotClosed();
+        return ResultSet.CONCUR_READ_ONLY;
+    }
+
+    public int getResultSetHoldability() throws SQLException
+    {
+        checkNotClosed();
+        // the Cassandra implementations does not support commits so this is the closest match
+        return ResultSet.HOLD_CURSORS_OVER_COMMIT;
+    }
+
+    public int getResultSetType() throws SQLException
+    {
+        checkNotClosed();
+        return ResultSet.TYPE_FORWARD_ONLY;
+    }
+
+    public int getUpdateCount() throws SQLException
+    {
+        checkNotClosed();
+        return updateCount;
+    }
+
+    public SQLWarning getWarnings() throws SQLException
+    {
+        checkNotClosed();
+        return null;
+    }
+
+    public boolean isClosed() throws SQLException
+    {
+        return connection == null;
+    }
+
+    public boolean isPoolable() throws SQLException
+    {
+        checkNotClosed();
+        return false;
+    }
+
+    public boolean isWrapperFor(Class<?> iface) throws SQLException
+    {
+        return false;
+    }
+
+    private final void resetResults()
+    {
+        currentResultSet = null;
+        updateCount = -1;
+    }
+
+    public void setEscapeProcessing(boolean enable) throws SQLException
+    {
+        checkNotClosed();
+        // the Cassandra implementation does not currently look at this
+        escapeProcessing = enable;
+    }
+
+    public void setFetchDirection(int direction) throws SQLException
+    {
+        checkNotClosed();
+
+        if (direction == ResultSet.FETCH_FORWARD || direction == ResultSet.FETCH_REVERSE || direction == ResultSet.FETCH_UNKNOWN)
+        {
+            if ((getResultSetType() == ResultSet.TYPE_FORWARD_ONLY) && (direction != ResultSet.FETCH_FORWARD))
+                throw new SQLSyntaxErrorException(String.format(BAD_FETCH_DIR, direction));
+            fetchDirection = direction;
+        }
+        else throw new SQLSyntaxErrorException(String.format(BAD_FETCH_DIR, direction));
+    }
+
+
+    public void setFetchSize(int size) throws SQLException
+    {
+        checkNotClosed();
+        if (size < 0) throw new SQLSyntaxErrorException(String.format(BAD_FETCH_SIZE, size));
+        fetchSize = size;
+    }
+
+    public void setMaxFieldSize(int arg0) throws SQLException
+    {
+        checkNotClosed();
+        // silently ignore this setting. always use default 0 (unlimited)
+    }
+
+    public void setMaxRows(int arg0) throws SQLException
+    {
+        checkNotClosed();
+        // silently ignore this setting. always use default 0 (unlimited)
+    }
+
+    public void setPoolable(boolean poolable) throws SQLException
+    {
+        checkNotClosed();
+        // silently ignore any attempt to set this away from the current default (false)
+    }
+
+    public void setQueryTimeout(int arg0) throws SQLException
+    {
+        checkNotClosed();
+        // silently ignore any attempt to set this away from the current default (0)
+    }
+
+    public <T> T unwrap(Class<T> iface) throws SQLException
+    {
+        throw new SQLFeatureNotSupportedException(String.format(NO_INTERFACE, iface.getSimpleName()));
+    }
+}
diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/ColumnDecoder.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/ColumnDecoder.java
index e69de29b..1de564fa 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/ColumnDecoder.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/ColumnDecoder.java
@@ -0,0 +1,142 @@
+package org.apache.cassandra.cql.jdbc;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+
+import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.config.ColumnDefinition;
+import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.db.marshal.AbstractType;
+import org.apache.cassandra.db.marshal.AsciiType;
+import org.apache.cassandra.thrift.*;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
+//import org.slf4j.Logger;
+//import org.slf4j.LoggerFactory;
+
+import java.nio.ByteBuffer;
+import java.nio.charset.CharacterCodingException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Decodes columns from bytes into instances of their respective expected types.
+ */
+class ColumnDecoder
+{
+//    private static final Logger logger = LoggerFactory.getLogger(ColumnDecoder.class);
+
+    private final Map<String, CFMetaData> metadata = new HashMap<String, CFMetaData>();
+
+    /**
+     * is specific per set of keyspace definitions.
+     */
+    public ColumnDecoder(List<KsDef> defs)
+    {
+        for (KsDef ks : defs)
+        {
+            for (CfDef cf : ks.getCf_defs())
+            {
+                try
+                {
+                    metadata.put(String.format("%s.%s", ks.getName(), cf.getName()), CFMetaData.fromThrift(cf));
+                }
+                catch (InvalidRequestException e)
+                {
+                    throw new RuntimeException(e);
+                }
+                catch (ConfigurationException e)
+                {
+                    throw new RuntimeException(e);
+                }
+            }
+        }
+    }
+
+    AbstractType<?> getComparator(String keyspace, String columnFamily)
+    {
+        CFMetaData md = metadata.get(String.format("%s.%s", keyspace, columnFamily));
+        return (md == null) ? null : md.comparator;
+    }
+
+    AbstractType<?> getNameType(String keyspace, String columnFamily, ByteBuffer name)
+    {
+        CFMetaData md = metadata.get(String.format("%s.%s", keyspace, columnFamily));
+        try
+        {
+            if (ByteBufferUtil.string(name).equalsIgnoreCase(ByteBufferUtil.string(md.getKeyName())))
+                return AsciiType.instance;
+        }
+        catch (CharacterCodingException e)
+        {
+            // not be the key name
+        }
+        return md.comparator;
+    }
+
+    AbstractType<?> getValueType(String keyspace, String columnFamily, ByteBuffer name)
+    {
+        CFMetaData md = metadata.get(String.format("%s.%s", keyspace, columnFamily));
+        try
+        {
+            if (ByteBufferUtil.string(name).equalsIgnoreCase(ByteBufferUtil.string(md.getKeyName())))
+                return md.getKeyValidator();
+        }
+        catch (CharacterCodingException e)
+        {
+            // not be the key name
+        }
+        ColumnDefinition cd = md.getColumnDefinition(name);
+        return cd == null ? md.getDefaultValidator() : cd.getValidator();
+    }
+
+    public AbstractType<?> getKeyValidator(String keyspace, String columnFamily)
+    {
+        CFMetaData md = metadata.get(String.format("%s.%s", keyspace, columnFamily));
+        return (md == null) ? null : md.getKeyValidator();
+    }
+
+    /** uses the AbstractType to map a column name to a string. */
+    public String colNameAsString(String keyspace, String columnFamily, ByteBuffer name)
+    {
+        AbstractType<?> comparator = getNameType(keyspace, columnFamily, name);
+        return comparator.getString(name);
+    }
+
+    /** constructs a typed column */
+    public TypedColumn makeCol(String keyspace, String columnFamily, Column column)
+    {
+        return new TypedColumn(column,
+                               getNameType(keyspace, columnFamily, column.name),
+                               getValueType(keyspace, columnFamily, column.name));
+    }
+
+    /** constructs a typed column to hold the key */
+    public TypedColumn makeKeyColumn(String keyspace, String columnFamily, byte[] key)
+    {
+        CFMetaData md = metadata.get(String.format("%s.%s", keyspace, columnFamily));
+        Column column = new Column(md.getKeyName()).setValue(key).setTimestamp(-1);
+        return new TypedColumn(column,
+                               getNameType(keyspace, columnFamily, md.getKeyName()),
+                               getValueType(keyspace, columnFamily, md.getKeyName()));
+    }
+}
diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/DriverResolverException.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/DriverResolverException.java
index e69de29b..d07507ef 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/DriverResolverException.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/DriverResolverException.java
@@ -0,0 +1,39 @@
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+package org.apache.cassandra.cql.jdbc;
+/**
+ * Runtime exception handling in case of runtime error during Driver resolving. 
+ */
+public class DriverResolverException extends RuntimeException {
+
+	/**
+	 * Default serial version UID. 
+	 */
+	private static final long serialVersionUID = 1L;
+
+	/**
+	 * Constructor using fields.
+	 * @param errMsg error message.
+	 */
+	public DriverResolverException(String errMsg) {
+		super(errMsg);
+	}
+}
diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/InvalidUrlException.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/InvalidUrlException.java
index e69de29b..5b9fd222 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/InvalidUrlException.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/InvalidUrlException.java
@@ -0,0 +1,41 @@
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+package org.apache.cassandra.cql.jdbc;
+
+/**
+ * Runtime exception handling during incorrect connection url provided.
+ */
+public class InvalidUrlException extends RuntimeException {
+	
+	/**
+	 *  Default serial version UID
+	 */
+	private static final long serialVersionUID = 1L;
+
+	/**
+	 * Constructor using fields.
+	 * @param errMsg error message.
+	 */
+	public InvalidUrlException(String errMsg) {
+		super(errMsg);
+	}
+
+}
diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/TypedColumn.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/TypedColumn.java
index e69de29b..9c8df80f 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/TypedColumn.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/TypedColumn.java
@@ -0,0 +1,77 @@
+package org.apache.cassandra.cql.jdbc;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+
+import org.apache.cassandra.db.marshal.AbstractType;
+import org.apache.cassandra.thrift.Column;
+
+
+public class TypedColumn
+{
+    private final Column rawColumn;
+
+    // we cache the frequently-accessed forms: java object for value, String for name.
+    // Note that {N|V}.toString() isn't always the same as Type.getString
+    // (a good example is byte buffers).
+    private final Object value;
+    private final String nameString;
+    private final AbstractType<?> nameType, valueType;
+
+    public TypedColumn(Column column, AbstractType<?> comparator, AbstractType<?> validator)
+    {
+        rawColumn = column;
+        this.value = column.value == null ? null : validator.compose(column.value);
+        nameString = comparator.getString(column.name);
+        nameType = comparator;
+        valueType = validator;
+    }
+
+    public Column getRawColumn()
+    {
+        return rawColumn;
+    }
+    
+    public Object getValue()
+    {
+        return value;
+    }
+    
+    public String getNameString()
+    {
+        return nameString;
+    }
+    
+    public String getValueString()
+    {
+        return valueType.getString(rawColumn.value);
+    }
+    
+    public AbstractType getNameType()
+    {
+        return nameType;
+    }
+
+    public AbstractType getValueType()
+    {
+        return valueType;
+    }
+}
diff --git a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/Utils.java b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/Utils.java
index e69de29b..376f4fdd 100644
--- a/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/Utils.java
+++ b/cassandra/trunk/drivers/java/src/org/apache/cassandra/cql/jdbc/Utils.java
@@ -0,0 +1,254 @@
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+package org.apache.cassandra.cql.jdbc;
+
+import java.io.ByteArrayOutputStream;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.nio.ByteBuffer;
+import java.sql.SQLException;
+import java.sql.SQLNonTransientConnectionException;
+import java.sql.SQLSyntaxErrorException;
+import java.util.Properties;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.zip.Deflater;
+
+import org.apache.cassandra.thrift.Compression;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.google.common.base.Charsets;
+
+/**
+ * A set of static utility methods used by the JDBC Suite, and various default values and error message strings
+ * that can be shared across classes.
+ */
+class Utils
+{
+    private static final Pattern KEYSPACE_PATTERN = Pattern.compile("USE (\\w+);?", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);
+    private static final Pattern SELECT_PATTERN = Pattern.compile("(?:SELECT|DELETE)\\s+.+\\s+FROM\\s+(\\w+).*", Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);
+    private static final Pattern UPDATE_PATTERN = Pattern.compile("UPDATE\\s+(\\w+)\\s+.*", Pattern.CASE_INSENSITIVE);
+
+    public static final String PROTOCOL = "jdbc:cassandra:";
+    public static final String DEFAULT_HOST = "localhost";
+    public static final int DEFAULT_PORT = 9160;
+
+    public static final String TAG_DESCRIPTION = "description";
+    public static final String TAG_USER = "user";
+    public static final String TAG_PASSWORD = "password";
+    public static final String TAG_DATABASE_NAME = "databaseName";
+    public static final String TAG_SERVER_NAME = "serverName";
+    public static final String TAG_PORT_NUMBER = "portNumber";
+
+    protected static final String WAS_CLOSED_CON = "method was called on a closed Connection";
+    protected static final String WAS_CLOSED_STMT = "method was called on a closed Statement";
+    protected static final String WAS_CLOSED_RSLT = "method was called on a closed ResultSet";
+    protected static final String NO_INTERFACE = "no object was found that matched the provided interface: %s";
+    protected static final String NO_TRANSACTIONS = "the Cassandra implementation does not support transactions";
+    protected static final String NO_SERVER = "no Cassandra server is available";
+    protected static final String ALWAYS_AUTOCOMMIT = "the Cassandra implementation is always in auto-commit mode";
+    protected static final String BAD_TIMEOUT = "the timeout value was less than zero";
+    protected static final String SCHEMA_MISMATCH = "schema does not match across nodes, (try again later)";
+    protected static final String NOT_SUPPORTED = "the Cassandra implementation does not support this method";
+    protected static final String NO_GEN_KEYS = "the Cassandra implementation does not currently support returning generated  keys";
+    protected static final String NO_BATCH = "the Cassandra implementation does not currently support this batch in Statement";
+    protected static final String NO_MULTIPLE = "the Cassandra implementation does not currently support multiple open Result Sets";
+    protected static final String NO_VALIDATOR = "Could not find key validator for: %s.%s";
+    protected static final String NO_COMPARATOR = "Could not find key comparator for: %s.%s";
+    protected static final String NO_RESULTSET = "No ResultSet returned from the CQL statement passed in an 'executeQuery()' method";
+    protected static final String NO_UPDATE_COUNT = "No Update Count was returned from the CQL statement passed in an 'executeUpdate()' method";
+    protected static final String NO_CF = "no column family reference could be extracted from the provided CQL statement";
+    protected static final String BAD_KEEP_RSET = "the argument for keeping the current result set : %s is not a valid value";
+    protected static final String BAD_TYPE_RSET = "the argument for result set type : %s is not a valid value";
+    protected static final String BAD_CONCUR_RSET = "the argument for result set concurrency : %s is not a valid value";
+    protected static final String BAD_HOLD_RSET = "the argument for result set holdability : %s is not a valid value";
+    protected static final String BAD_FETCH_DIR = "fetch direction value of : %s is illegal";
+    protected static final String BAD_AUTO_GEN = "auto key generation value of : %s is illegal";
+    protected static final String BAD_FETCH_SIZE = "fetch size of : %s rows may not be negative";
+    protected static final String MUST_BE_POSITIVE = "index must be a positive number less or equal the count of returned columns: %s";
+    protected static final String VALID_LABELS = "name provided was not in the list of valid column labels: %s";
+    protected static final String NOT_TRANSLATABLE = "column was stored in %s format which is not translatable to %s";
+    protected static final String NOT_BOOLEAN = "string value was neither 'true' nor 'false' :  %s";
+    protected static final String HOST_IN_URL = "Connection url must specify a host, e.g., jdbc:cassandra://localhost:9170/Keyspace1";
+    protected static final String HOST_REQUIRED = "a 'host' name is required to build a Connection";
+    protected static final String BAD_KEYSPACE = "Keyspace names must be composed of alphanumerics and underscores (parsed: '%s')";
+    protected static final String URI_IS_SIMPLE = "Connection url may only include host, port, and keyspace, e.g., jdbc:cassandra://localhost:9170/Keyspace1";
+
+    protected static final Logger logger = LoggerFactory.getLogger(Utils.class);
+
+    /**
+     * Use the Compression object method to deflate the query string
+     *
+     * @param queryStr An un-compressed CQL query string
+     * @param compression The compression object
+     * @return A compressed string
+     */
+    public static ByteBuffer compressQuery(String queryStr, Compression compression)
+    {
+        byte[] data = queryStr.getBytes(Charsets.UTF_8);
+        Deflater compressor = new Deflater();
+        compressor.setInput(data);
+        compressor.finish();
+
+        ByteArrayOutputStream byteArray = new ByteArrayOutputStream();
+        byte[] buffer = new byte[1024];
+
+        while (!compressor.finished())
+        {
+            int size = compressor.deflate(buffer);
+            byteArray.write(buffer, 0, size);
+        }
+
+        logger.trace("Compressed query statement {} bytes in length to {} bytes", data.length, byteArray.size());
+
+        return ByteBuffer.wrap(byteArray.toByteArray());
+    }
+
+    /**
+     * Parse a URL for the Cassandra JDBC Driver
+     * <p/>
+     * The URL must start with the Protocol: "jdbc:cassandra:"
+     * The URI part(the "Subname") must contain a host and an optional port and optional keyspace name
+     * ie. "//localhost:9160/Test1"
+     *
+     * @param url The full JDBC URL to be parsed
+     * @return A list of properties that were parsed from the Subname
+     * @throws SQLException
+     */
+    public static final Properties parseURL(String url) throws SQLException
+    {
+        Properties props = new Properties();
+
+        if (!(url == null))
+        {
+            props.setProperty(TAG_PORT_NUMBER, "" + DEFAULT_PORT);
+            String rawUri = url.substring(PROTOCOL.length());
+            URI uri = null;
+            try
+            {
+                uri = new URI(rawUri);
+            }
+            catch (URISyntaxException e)
+            {
+                throw new SQLSyntaxErrorException(e);
+            }
+
+            String host = uri.getHost();
+            if (host == null) throw new SQLNonTransientConnectionException(HOST_IN_URL);
+            props.setProperty(TAG_SERVER_NAME, host);
+
+            int port = uri.getPort() >= 0 ? uri.getPort() : DEFAULT_PORT;
+            props.setProperty(TAG_PORT_NUMBER, "" + port);
+
+            String keyspace = uri.getPath();
+            if ((keyspace != null) && (!keyspace.isEmpty()))
+            {
+                if (keyspace.startsWith("/")) keyspace = keyspace.substring(1);
+                if (!keyspace.matches("[a-zA-Z]\\w+"))
+                    throw new SQLNonTransientConnectionException(String.format(BAD_KEYSPACE, keyspace));
+                props.setProperty(TAG_DATABASE_NAME, keyspace);
+            }
+
+            if (uri.getUserInfo() != null)
+                throw new SQLNonTransientConnectionException(URI_IS_SIMPLE);
+        }
+
+        if (logger.isTraceEnabled()) logger.trace("URL : '{}' parses to: {}", url, props);
+
+        return props;
+    }
+
+    /**
+     * Create a "Subname" portion of a JDBC URL from properties.
+     * 
+     * @param props A Properties file containing all the properties to be considered.
+     * @return A constructed "Subname" portion of a JDBC URL in the form of a CLI (ie: //myhost:9160/Test1 )
+     * @throws SQLException
+     */
+    public static final String createSubName(Properties props)throws SQLException
+    {
+        // make keyspace always start with a "/" for URI
+        String keyspace = props.getProperty(TAG_DATABASE_NAME);
+     
+        // if keyspace is null then do not bother ...
+        if (keyspace != null) 
+            if (!keyspace.startsWith("/")) keyspace = "/"  + keyspace;
+        
+        String host = props.getProperty(TAG_SERVER_NAME);
+        if (host==null)throw new SQLNonTransientConnectionException(HOST_REQUIRED);
+        
+        // construct a valid URI from parts... 
+        URI uri;
+        try
+        {
+            uri = new URI(
+                null,
+                null,
+                host,
+                props.getProperty(TAG_PORT_NUMBER)==null ? DEFAULT_PORT : Integer.parseInt(props.getProperty(TAG_PORT_NUMBER)),
+                keyspace,
+                null,
+                null);
+        }
+        catch (Exception e)
+        {
+            throw new SQLNonTransientConnectionException(e);
+        }
+        
+        if (logger.isTraceEnabled()) logger.trace("Subname : '{}' created from : {}",uri.toString(), props);
+        
+        return uri.toString();
+    }
+    
+    /**
+     * Determine the current keyspace by inspecting the CQL string to see if a USE statement is provided; which would change the keyspace.
+     *
+     * @param cql     A CQL query string
+     * @param current The current keyspace stored as state in the connection
+     * @return the provided keyspace name or the keyspace from the contents of the CQL string
+     */
+    public static String determineCurrentKeyspace(String cql, String current)
+    {
+        String ks = current;
+        Matcher isKeyspace = KEYSPACE_PATTERN.matcher(cql);
+        if (isKeyspace.matches()) ks = isKeyspace.group(1);
+        return ks;
+    }
+
+    /**
+     * Determine the current column family by inspecting the CQL to find a CF reference.
+     *
+     * @param cql A CQL query string
+     * @return The column family name from the contents of the CQL string or null in none was found
+     */
+    public static String determineCurrentColumnFamily(String cql)
+    {
+        String cf = null;
+        Matcher isSelect = SELECT_PATTERN.matcher(cql);
+        if (isSelect.matches()) cf = isSelect.group(1);
+        Matcher isUpdate = UPDATE_PATTERN.matcher(cql);
+        if (isUpdate.matches()) cf = isUpdate.group(1);
+        return cf;
+    }
+}
diff --git a/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/EmbeddedServiceBase.java b/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/EmbeddedServiceBase.java
index e69de29b..b61bfd1a 100644
--- a/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/EmbeddedServiceBase.java
+++ b/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/EmbeddedServiceBase.java
@@ -0,0 +1,106 @@
+package org.apache.cassandra.cql;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+
+import java.io.IOException;
+import java.net.Socket;
+import java.net.UnknownHostException;
+
+import org.apache.cassandra.CleanupHelper;
+import org.apache.cassandra.SchemaLoader;
+import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.config.KSMetaData;
+import org.apache.cassandra.service.EmbeddedCassandraService;
+import org.junit.BeforeClass;
+
+/**
+ * The abstract BaseClass.
+ */
+public abstract class EmbeddedServiceBase
+{
+
+    /** The embedded server cassandra. */
+    private static EmbeddedCassandraService cassandra;
+    
+    @BeforeClass 
+    public static void cleanUpOldStuff() throws IOException
+    {
+        CleanupHelper.cleanupAndLeaveDirs();
+    }
+    
+    /**
+     * Start cassandra server.
+     * @throws ConfigurationException 
+     *
+     * @throws Exception the exception
+     */
+    public static void startCassandraServer() throws IOException, ConfigurationException
+    {
+        if (!checkIfServerRunning())
+        {
+            loadData();
+            cassandra = new EmbeddedCassandraService();
+            cassandra.start();
+        }
+    }
+
+    
+    /**
+     * Load yaml tables.
+     *
+     * @throws ConfigurationException the configuration exception
+     */
+    static void loadData() throws ConfigurationException
+    {
+        for (KSMetaData table : SchemaLoader.schemaDefinition())
+        {
+            for (CFMetaData cfm : table.cfMetaData().values())
+            {
+                CFMetaData.map(cfm);
+            }
+            DatabaseDescriptor.setTableDefinition(table, DatabaseDescriptor.getDefsVersion());
+        }
+    }
+    /**
+     * Check if server running.
+     *
+     * @return true, if successful
+     */
+    static boolean checkIfServerRunning()
+    {
+        try
+        {
+            Socket socket = new Socket("127.0.0.1", 9170);
+            return socket.getInetAddress() != null;
+        } 
+        catch (UnknownHostException e)
+        {
+            return false;
+        }
+        catch (IOException e)
+        {
+            return false;
+        }
+    }
+}
diff --git a/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/JdbcDriverTest.java b/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/JdbcDriverTest.java
index e69de29b..f5811caa 100644
--- a/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/JdbcDriverTest.java
+++ b/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/JdbcDriverTest.java
@@ -0,0 +1,511 @@
+package org.apache.cassandra.cql;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+import java.io.File;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.math.BigInteger;
+import java.nio.ByteBuffer;
+import java.sql.*;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.cassandra.cql.jdbc.CassandraResultSet;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import org.apache.cassandra.db.marshal.*;
+import org.apache.cassandra.utils.ByteBufferUtil;
+import org.apache.cassandra.utils.FBUtilities;
+
+import static junit.framework.Assert.assertEquals;
+
+/**
+ * Test case for unit test of various methods of JDBC implementation.
+ */
+public class JdbcDriverTest extends EmbeddedServiceBase
+{
+    private static java.sql.Connection con = null;
+    private static final String first = FBUtilities.bytesToHex("first".getBytes());
+    private static final String firstrec = FBUtilities.bytesToHex("firstrec".getBytes());
+    private static final String last = FBUtilities.bytesToHex("last".getBytes());
+    private static final String lastrec = FBUtilities.bytesToHex("lastrec".getBytes());
+    private static final String jsmith = FBUtilities.bytesToHex("jsmith".getBytes());
+
+    /** SetUp */
+    @BeforeClass
+    public static void startServer() throws Exception
+    {
+        startCassandraServer();
+        Class.forName("org.apache.cassandra.cql.jdbc.CassandraDriver");
+        con = DriverManager.getConnection("jdbc:cassandra://localhost:9170/Keyspace1");
+        String[] inserts = 
+        {
+            String.format("UPDATE Standard1 SET '%s' = '%s', '%s' = '%s' WHERE KEY = '%s'", first, firstrec, last, lastrec, jsmith),    
+            "UPDATE JdbcInteger SET 1 = 11, 2 = 22, 42='fortytwo' WHERE KEY = '" + jsmith + "'",
+            "UPDATE JdbcInteger SET 3 = 33, 4 = 44 WHERE KEY = '" + jsmith + "'",
+            "UPDATE JdbcLong SET 1 = 11, 2 = 22 WHERE KEY = '" + jsmith + "'",
+            "UPDATE JdbcAscii SET 'first' = 'firstrec', last = 'lastrec' WHERE key = '" + jsmith + "'",
+            String.format("UPDATE JdbcBytes SET '%s' = '%s', '%s' = '%s' WHERE key = '%s'", first, firstrec, last, lastrec, jsmith),
+            "UPDATE JdbcUtf8 SET 'first' = 'firstrec', fortytwo = '42', last = 'lastrec' WHERE key = '" + jsmith + "'",
+        };
+        for (String q : inserts)
+        {
+            try 
+            {
+                executeNoResults(con, q);
+            }
+            catch (SQLException ex)
+            {
+                throw new AssertionError(ex.getMessage() + ", query:" + q);
+            }
+        }
+    }
+
+    private static void expectedMetaData(ResultSetMetaData md, int col, String colClass, String table, String schema,
+                                  String label, int type, String typeName, boolean signed, boolean caseSensitive) throws SQLException
+    {
+        assertEquals(colClass, md.getColumnClassName(col)); // full class name of type<T>
+        assertEquals(table, md.getTableName(col));
+        assertEquals(schema, md.getSchemaName(col));
+        assertEquals(label, md.getColumnLabel(col));
+        assertEquals(label, md.getColumnName(col));
+        assertEquals(type, md.getColumnType(col));
+        assertEquals(typeName, md.getColumnTypeName(col));
+        assertEquals(signed, md.isSigned(col));
+        assertEquals(caseSensitive, md.isCaseSensitive(col));
+    }
+    
+    private static void expectedMetaData(ResultSetMetaData md, int col,
+                                         String valuClass, int valuType, String valuTypeName, boolean valuSigned, boolean valuCaseSense) throws SQLException
+    {
+        assertEquals(valuClass, md.getColumnClassName(col));
+        assertEquals(valuType, md.getColumnType(col));
+        assertEquals(valuTypeName, md.getColumnTypeName(col));
+        assertEquals(valuSigned, md.isSigned(col));
+        assertEquals(valuCaseSense, md.isCaseSensitive(col));
+    }
+
+    @Test(expected=SQLNonTransientConnectionException.class)
+    public void testNoHost() throws SQLException
+    {
+        DriverManager.getConnection("jdbc:cassandra:localhost");
+    }
+
+    @Test(expected=SQLNonTransientConnectionException.class)
+    public void testBadKeyspace() throws SQLException
+    {
+        DriverManager.getConnection("jdbc:cassandra://localhost/Keysp@ce");
+    }
+
+    @Test(expected=SQLNonTransientConnectionException.class)
+    public void testBadUserinfo() throws SQLException
+    {
+        DriverManager.getConnection("jdbc:cassandra://root;root@localhost");
+    }
+
+    @Test
+    public void testNonDefaultColumnValidators() throws SQLException
+    {
+        String key = FBUtilities.bytesToHex("Integer".getBytes());
+        Statement stmt = con.createStatement();
+        stmt.executeUpdate("update JdbcInteger set 1=36893488147419103232, 42='fortytwofortytwo' where key='" + key + "'");
+        ResultSet rs = stmt.executeQuery("select 1, 2, 42 from JdbcInteger where key='" + key + "'");
+        assert rs.next();
+        assert rs.getObject("1").equals(new BigInteger("36893488147419103232"));
+        assert rs.getString("42").equals("fortytwofortytwo") : rs.getString("42");
+        
+        ResultSetMetaData md = rs.getMetaData();
+        assert md.getColumnCount() == 3;
+        expectedMetaData(md, 1, BigInteger.class.getName(), "JdbcInteger", "Keyspace1", "1", Types.BIGINT, IntegerType.class.getSimpleName(), true, false);
+        expectedMetaData(md, 2, BigInteger.class.getName(), "JdbcInteger", "Keyspace1", "2", Types.BIGINT, IntegerType.class.getSimpleName(), true, false);
+        expectedMetaData(md, 3, String.class.getName(), "JdbcInteger", "Keyspace1", "42", Types.VARCHAR, UTF8Type.class.getSimpleName(), false, true);
+        
+        rs = stmt.executeQuery("select key, 1, 2, 42 from JdbcInteger where key='" + key + "'");
+        assert rs.next();
+        assert Arrays.equals(rs.getBytes("key"), FBUtilities.hexToBytes(key));
+        assert rs.getObject("1").equals(new BigInteger("36893488147419103232"));
+        assert rs.getString("42").equals("fortytwofortytwo") : rs.getString("42");
+
+        stmt.executeUpdate("update JdbcUtf8 set a='aa', b='bb', fortytwo='4242' where key='" + key + "'");
+        rs = stmt.executeQuery("select a, b, fortytwo from JdbcUtf8 where key='" + key + "'");
+        assert rs.next();
+        assert rs.getString("a").equals("aa");
+        assert rs.getString("b").equals("bb");
+        assert rs.getInt("fortytwo") == 4242L;
+        
+        md = rs.getMetaData();
+        expectedMetaData(md, 1, String.class.getName(), "JdbcUtf8", "Keyspace1", "a", Types.VARCHAR, UTF8Type.class.getSimpleName(), false, true);
+        expectedMetaData(md, 2, String.class.getName(), "JdbcUtf8", "Keyspace1", "b", Types.VARCHAR, UTF8Type.class.getSimpleName(), false, true);
+        expectedMetaData(md, 3, BigInteger.class.getName(), "JdbcUtf8", "Keyspace1", "fortytwo", Types.BIGINT, IntegerType.class.getSimpleName(), true, false);
+    }
+        
+    @Test
+    public void testLongMetadata() throws SQLException
+    {
+        String key = FBUtilities.bytesToHex("Long".getBytes());
+        Statement stmt = con.createStatement();
+        stmt.executeUpdate("UPDATE JdbcLong SET 1=111, 2=222 WHERE KEY = '" + key + "'");
+        ResultSet rs = stmt.executeQuery("SELECT 1, 2 from JdbcLong WHERE KEY = '" + key + "'");
+        assert rs.next();
+        assert rs.getLong("1") == 111;
+        assert rs.getLong("2") == 222;
+        
+        ResultSetMetaData md = rs.getMetaData();
+        assert md.getColumnCount() == 2;
+        expectedMetaData(md, 1, Long.class.getName(), "JdbcLong", "Keyspace1", "1", Types.INTEGER, LongType.class.getSimpleName(), true, false);
+        expectedMetaData(md, 2, Long.class.getName(), "JdbcLong", "Keyspace1", "2", Types.INTEGER, LongType.class.getSimpleName(), true, false);
+        
+        for (int i = 0; i < md.getColumnCount(); i++)
+            expectedMetaData(md, i + 1, Long.class.getName(), Types.INTEGER, LongType.class.getSimpleName(), true, false);
+    }
+
+    @Test
+    public void testStringMetadata() throws SQLException
+    {
+        String aKey = FBUtilities.bytesToHex("ascii".getBytes());
+        String uKey = FBUtilities.bytesToHex("utf8".getBytes());
+        Statement stmt = con.createStatement();
+        stmt.executeUpdate("UPDATE JdbcAscii SET a='aa', b='bb' WHERE KEY = '" + aKey + "'");
+        stmt.executeUpdate("UPDATE JdbcUtf8 SET a='aa', b='bb' WHERE KEY = '" + uKey + "'");
+        ResultSet rs0 = stmt.executeQuery("SELECT a, b FROM JdbcAscii WHERE KEY = '" + aKey + "'");
+        ResultSet rs1 = stmt.executeQuery("SELECT a, b FROM JdbcUtf8 WHERE KEY = '" + uKey + "'");
+        for (ResultSet rs : new ResultSet[] { rs0, rs1 }) 
+        {
+            assert rs.next();
+            assert rs.getString("a").equals("aa");
+            assert rs.getString("b").equals("bb");
+        }
+        
+        ResultSetMetaData md = rs0.getMetaData();
+        assert md.getColumnCount() == 2;
+        expectedMetaData(md, 1, String.class.getName(), "JdbcAscii", "Keyspace1", "a", Types.VARCHAR, AsciiType.class.getSimpleName(), false, true);
+        expectedMetaData(md, 2, String.class.getName(), "JdbcAscii", "Keyspace1", "b", Types.VARCHAR, AsciiType.class.getSimpleName(), false, true);
+        md = rs1.getMetaData();
+        assert md.getColumnCount() == 2;
+        expectedMetaData(md, 1, String.class.getName(), "JdbcUtf8", "Keyspace1", "a", Types.VARCHAR, UTF8Type.class.getSimpleName(), false, true);
+        expectedMetaData(md, 2, String.class.getName(), "JdbcUtf8", "Keyspace1", "b", Types.VARCHAR, UTF8Type.class.getSimpleName(), false, true);
+
+        for (int i = 0; i < 2; i++)
+        {
+            expectedMetaData(rs0.getMetaData(),
+                             i + 1,
+                             String.class.getName(),
+                             Types.VARCHAR,
+                             AsciiType.class.getSimpleName(),
+                             false,
+                             true);
+            expectedMetaData(rs1.getMetaData(),
+                             i + 1,
+                             String.class.getName(),
+                             Types.VARCHAR,
+                             UTF8Type.class.getSimpleName(),
+                             false,
+                             true);
+
+        }
+    }
+    
+    @Test
+    public void testBytesMetadata() throws SQLException 
+    {
+        String key = FBUtilities.bytesToHex("bytes".getBytes());
+        Statement stmt = con.createStatement();
+        byte[] a = "a_".getBytes();
+        byte[] b = "b_".getBytes();
+        byte[] aa = "_aa_".getBytes();
+        byte[] bb = "_bb_".getBytes();
+        stmt.executeUpdate(String.format(
+                "UPDATE JdbcBytes set '%s'='%s', '%s'='%s' WHERE KEY = '" + key + "'",
+                FBUtilities.bytesToHex(a),
+                FBUtilities.bytesToHex(aa),
+                FBUtilities.bytesToHex(b),
+                FBUtilities.bytesToHex(bb)));
+        ResultSet rs = stmt.executeQuery(String.format(
+                "SELECT '%s', '%s' from JdbcBytes WHERE KEY = '" + key + "'",
+                FBUtilities.bytesToHex(a),
+                FBUtilities.bytesToHex(b)));
+        assert rs.next();
+        assert Arrays.equals(aa, rs.getBytes(1));
+        assert Arrays.equals(bb, rs.getBytes(2));
+        assert Arrays.equals(aa, rs.getBytes(FBUtilities.bytesToHex(a)));
+        assert Arrays.equals(bb, rs.getBytes(FBUtilities.bytesToHex(b)));
+        ResultSetMetaData md = rs.getMetaData();
+        assert md.getColumnCount() == 2;
+        expectedMetaData(md, 1, ByteBuffer.class.getName(), "JdbcBytes", "Keyspace1", FBUtilities.bytesToHex(a), Types.BINARY, BytesType.class.getSimpleName(), false, false);
+        expectedMetaData(md, 2, ByteBuffer.class.getName(), "JdbcBytes", "Keyspace1", FBUtilities.bytesToHex(b), Types.BINARY, BytesType.class.getSimpleName(), false, false);
+        
+        for (int i = 0; i < md.getColumnCount(); i++)
+            expectedMetaData(md, i + 1, ByteBuffer.class.getName(), Types.BINARY, BytesType.class.getSimpleName(), false, false);
+    }
+
+    @Test
+    public void testWithStatementBytesType() throws SQLException
+    {
+        Statement stmt = con.createStatement();
+        
+        String selectQ = String.format("SELECT '%s', '%s' FROM Standard1 WHERE KEY='%s'", first, last, jsmith);
+        checkResultSet(stmt.executeQuery(selectQ), "Bytes", 1, first, last);
+        
+        selectQ = String.format("SELECT '%s', '%s' FROM JdbcBytes WHERE KEY='%s'", first, last, jsmith);
+        checkResultSet(stmt.executeQuery(selectQ), "Bytes", 1, first, last);
+    }
+    
+    /** Method to test statement. */
+    @Test
+    public void testWithStatement() throws SQLException
+    {
+        Statement stmt = con.createStatement();
+        List<String> keys = Arrays.asList(jsmith);
+        String selectQ = "SELECT 1, 2 FROM JdbcInteger WHERE KEY='" + jsmith + "'";
+        checkResultSet(stmt.executeQuery(selectQ), "Int", 1, keys, "1", "2");
+        
+        selectQ = "SELECT 3, 4 FROM JdbcInteger WHERE KEY='" + jsmith + "'";
+        checkResultSet(stmt.executeQuery(selectQ), "Int", 1, keys, "3", "4");
+        
+        selectQ = "SELECT 1, 2, 3, 4 FROM JdbcInteger WHERE KEY='" + jsmith + "'";
+        checkResultSet(stmt.executeQuery(selectQ), "Int", 1, keys, "1", "2", "3", "4");
+        
+        selectQ = "SELECT 1, 2 FROM JdbcLong WHERE KEY='" + jsmith + "'";
+        checkResultSet(stmt.executeQuery(selectQ), "Long", 1, keys, "1", "2");
+        
+        selectQ = "SELECT 'first', last FROM JdbcAscii WHERE KEY='" + jsmith + "'";
+        checkResultSet(stmt.executeQuery(selectQ), "String", 1, keys, "first", "last");
+        
+        selectQ = String.format("SELECT '%s', '%s' FROM JdbcBytes WHERE KEY='%s'", first, last, jsmith);
+        checkResultSet(stmt.executeQuery(selectQ), "Bytes", 1, keys, first, last);
+        
+        selectQ = "SELECT 'first', last FROM JdbcUtf8 WHERE KEY='" + jsmith + "'";
+        checkResultSet(stmt.executeQuery(selectQ), "String", 1, keys, "first", "last");
+
+        String badKey = FBUtilities.bytesToHex(String.format("jsmith-%s", System.currentTimeMillis()).getBytes());
+        selectQ = "SELECT 1, 2 FROM JdbcInteger WHERE KEY IN ('" + badKey + "', '" + jsmith + "')";
+        checkResultSet(stmt.executeQuery(selectQ), "Int", 1, keys, "1", "2");
+    }
+    
+    @Test
+    public void testWithPreparedStatementBytesType() throws SQLException
+    {
+        String selectQ = String.format("SELECT '%s', '%s' FROM Standard1 WHERE KEY='%s'", first, last, jsmith);
+        checkResultSet(executePreparedStatementWithResults(con, selectQ), "Bytes", 1, first, last);
+        
+        selectQ = String.format("SELECT '%s', '%s' FROM JdbcBytes WHERE KEY='%s'", first, last, jsmith);
+        checkResultSet(executePreparedStatementWithResults(con, selectQ), "Bytes", 1, first, last);
+    }
+
+   /** Method to test with prepared statement.*/
+   @Test
+    public void testWithPreparedStatement() throws SQLException
+    {
+        List<String> keys = Arrays.asList(jsmith);
+
+        String selectQ = String.format("SELECT '%s', '%s' FROM Standard1 WHERE KEY='%s'", first, last, jsmith);
+        checkResultSet(executePreparedStatementWithResults(con, selectQ), "Bytes", 1, keys, first, last);
+        
+        selectQ = "SELECT 1, 2 FROM JdbcInteger WHERE KEY='" + jsmith + "'";
+        checkResultSet(executePreparedStatementWithResults(con, selectQ), "Int", 1, keys, "1", "2");
+        
+        selectQ = "SELECT 3, 4 FROM JdbcInteger WHERE KEY='" + jsmith + "'";
+        checkResultSet(executePreparedStatementWithResults(con, selectQ), "Int", 1, keys, "3", "4");
+        
+        selectQ = "SELECT 1, 2, 3, 4 FROM JdbcInteger WHERE KEY='" + jsmith + "'";
+        checkResultSet(executePreparedStatementWithResults(con, selectQ), "Int", 1, keys, "1", "2", "3", "4");
+        
+        selectQ = "SELECT 1, 2 FROM JdbcLong WHERE KEY='" + jsmith + "'";
+        checkResultSet(executePreparedStatementWithResults(con, selectQ), "Long", 1, keys, "1", "2");
+        
+        selectQ = "SELECT 'first', last FROM JdbcAscii WHERE KEY='" + jsmith + "'";
+        checkResultSet(executePreparedStatementWithResults(con, selectQ), "String", 1, keys, "first", "last");
+        
+        selectQ = String.format("SELECT '%s', '%s' FROM JdbcBytes WHERE KEY='%s'", first, last, jsmith);
+        checkResultSet(executePreparedStatementWithResults(con, selectQ), "Bytes", 1, keys, first, last);
+        
+        selectQ = "SELECT 'first', last FROM JdbcUtf8 WHERE KEY='" + jsmith + "'";
+        checkResultSet(executePreparedStatementWithResults(con, selectQ), "String", 1, keys, "first", "last");
+
+        String badKey = FBUtilities.bytesToHex(String.format("jsmith-%s", System.currentTimeMillis()).getBytes());
+        selectQ = "SELECT 1, 2 FROM JdbcInteger WHERE KEY IN ('" + badKey + "', '" + jsmith + "')";
+        checkResultSet(executePreparedStatementWithResults(con, selectQ), "Int", 1, keys, "1", "2");
+    }
+
+    /* Method to test with Delete statement. */
+    @Test
+    public void testWithDeleteStatement() throws SQLException
+    {
+        // the pattern: 0) a deltion, 1) ensure deletion 2) ensure deletion wasn't over-eager.
+        String[] statements = 
+        {
+                String.format("DELETE '%s', '%s' FROM Standard1 WHERE KEY='%s'",
+                              FBUtilities.bytesToHex("firstN".getBytes()),
+                              FBUtilities.bytesToHex("lastN".getBytes()),
+                              jsmith),
+                String.format("SELECT '%s', '%s' FROM Standard1 WHERE KEY='%s'",
+                              FBUtilities.bytesToHex("firstN".getBytes()),
+                              FBUtilities.bytesToHex("lastN".getBytes()),
+                              jsmith),
+                String.format("SELECT '%s' FROM Standard1 WHERE KEY='%s'",
+                              first,
+                              jsmith),
+                
+                "DELETE 1, 3 FROM JdbcInteger WHERE KEY='" + jsmith + "'",
+                "SELECT 1, 3 FROM JdbcInteger WHERE KEY='" + jsmith + "'",
+                "SELECT 2, 4 FROM JdbcInteger WHERE KEY='" + jsmith + "'",
+                
+                "DELETE 1 FROM JdbcLong WHERE KEY='" + jsmith + "'",
+                "SELECT 1 FROM JdbcLong WHERE KEY='" + jsmith + "'",
+                "SELECT 2 FROM JdbcLong WHERE KEY='" + jsmith + "'",
+                
+                "DELETE 'first' FROM JdbcAscii WHERE KEY='" + jsmith + "'",
+                "SELECT 'first' FROM JdbcAscii WHERE KEY='" + jsmith + "'",
+                "SELECT last FROM JdbcAscii WHERE KEY='" + jsmith + "'",
+                
+                String.format("DELETE '%s' FROM JdbcBytes WHERE KEY='%s'", first, jsmith),
+                String.format("SELECT '%s' FROM JdbcBytes WHERE KEY='%s'", first, jsmith),
+                String.format("SELECT '%s' FROM JdbcBytes WHERE KEY='%s'", last, jsmith),
+                
+                "DELETE 'first' FROM JdbcUtf8 WHERE KEY='" + jsmith + "'",
+                "SELECT 'first' FROM JdbcUtf8 WHERE KEY='" + jsmith + "'",
+                "SELECT last FROM JdbcUtf8 WHERE KEY='" + jsmith + "'",
+        };
+        
+        for (int i = 0; i < statements.length/3; i++) 
+        {
+            executeNoResults(con, statements[3*i]);
+            ResultSet rs = executePreparedStatementWithResults(con, statements[3*i+1]);
+            rs.next();
+            rs.getObject(1);
+            assert rs.wasNull();
+            rs.close();
+
+            rs = executePreparedStatementWithResults(con, statements[3*i+2]);
+            assert rs.next() : statements[3*i+2];
+        }
+    }
+
+    @AfterClass
+    public static void stopServer() throws SQLException
+    {
+        if (con != null)
+        {
+            String[] stmts = 
+            {
+                "TRUNCATE Standard1",
+                "TRUNCATE JdbcAscii", // todo: this one is broken for some reason.
+                "TRUNCATE JdbcInteger",
+                "TRUNCATE JdbcLong",
+                "TRUNCATE JdbcBytes",
+                "TRUNCATE JdbcUtf8",
+            };
+            for (String stmt : stmts)
+            {
+                try 
+                {
+                    executeNoResults(con, stmt);
+                }
+                catch (SQLException ex)
+                {
+                    throw new SQLException(stmt, ex);
+                }
+            }
+            con.close();
+            con = null;
+        }
+        
+        // Cleanup backup links
+        File backups = new File("build/test/cassandra/data/Keyspace1/backups");
+        if (backups.exists())
+            for (String fname : backups.list())
+                new File("build/test/cassandra/data/Keyspace1/backups" + File.separator + fname).delete();
+    }
+    
+    // todo: check expected values as well.
+    /** iterates over a result set checking columns */
+    private static void checkResultSet(ResultSet rs, String accessor, int expectedRows, String... cols) throws SQLException
+    {
+        checkResultSet(rs, accessor, expectedRows, null, cols);
+    }
+
+    private static void checkResultSet(ResultSet rs, String accessor, int expectedRows, List<String> keys,  String... cols) throws SQLException
+    {
+        int actualRows = 0;
+        assert rs != null;
+        Iterator<String> keyIter = (keys == null) ? null : keys.iterator();
+        CassandraResultSet cassandraRs = (CassandraResultSet)rs;
+        while (rs.next())
+        {
+            actualRows++;
+            if (keyIter != null)
+            {
+                assert cassandraRs.getTypedKey().getValueString().equals(keyIter.next());
+            }
+
+            for (int c = 0; c < cols.length; c++)
+            {
+                // getObject should always work.
+                assert rs.getObject(cols[c]) != null;
+                assert rs.getObject(c+1) != null;
+                
+                // now call the accessor.
+                try
+                {
+                    Method byInt = rs.getClass().getDeclaredMethod("get" + accessor, int.class);
+                    byInt.setAccessible(true);
+                    assert byInt.invoke(rs, c+1) != null;
+                    
+                    Method byString = rs.getClass().getDeclaredMethod("get" + accessor, String.class);
+                    byString.setAccessible(true);
+                    assert byString.invoke(rs, cols[c]) != null;
+                }
+                catch (NoSuchMethodException ex)
+                {
+                    throw new RuntimeException(ex);
+                }
+                catch (IllegalAccessException ex)
+                {
+                    throw new RuntimeException(ex);
+                }
+                catch (InvocationTargetException ex) 
+                {
+                    throw new RuntimeException(ex);
+                }
+            }
+        }
+        
+        assert actualRows == expectedRows : String.format("expected %d rows, got %d", expectedRows, actualRows);
+    }
+    
+    /** executes a prepared statement */
+    private static ResultSet executePreparedStatementWithResults(final Connection con, final String selectQ) throws SQLException
+    {
+        PreparedStatement statement = con.prepareStatement(selectQ);
+        return statement.executeQuery();
+    }
+
+    /** executes an prepared statement */
+    private static void executeNoResults(final Connection con, final String cql) throws SQLException
+    {
+        PreparedStatement statement = con.prepareStatement(cql);
+        statement.execute();
+    }
+}
diff --git a/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/jdbc/DataSourceTest.java b/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/jdbc/DataSourceTest.java
index e69de29b..0c16cce6 100644
--- a/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/jdbc/DataSourceTest.java
+++ b/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/jdbc/DataSourceTest.java
@@ -0,0 +1,111 @@
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+package org.apache.cassandra.cql.jdbc;
+
+import static org.junit.Assert.*;
+
+import java.io.PrintWriter;
+import java.sql.SQLFeatureNotSupportedException;
+
+import javax.sql.DataSource;
+
+import org.apache.cassandra.cql.EmbeddedServiceBase;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class DataSourceTest extends EmbeddedServiceBase
+{
+    private static final String HOST = "localhost";
+    private static final int PORT = 9170;
+    private static final String KEYSPACE = "Test";
+    private static final String USER = "JohnDoe";
+    private static final String PASSWORD = "secret";
+
+
+    @BeforeClass
+    public static void setUpBeforeClass() throws Exception
+    {
+        startCassandraServer();
+    }
+
+    @Test
+    public void testConstructor() throws Exception
+    {
+        CassandraDataSource cds = new CassandraDataSource(HOST,PORT,KEYSPACE,USER,PASSWORD);
+        assertEquals(HOST,cds.getServerName());
+        assertEquals(PORT,cds.getPortNumber());
+        assertEquals(KEYSPACE,cds.getDatabaseName());
+        assertEquals(USER,cds.getUser());
+        assertEquals(PASSWORD,cds.getPassword());
+        
+        DataSource ds = new CassandraDataSource(HOST,PORT,KEYSPACE,USER,PASSWORD);
+        assertNotNull(ds);
+        
+        PrintWriter pw = new PrintWriter(System.err);
+        
+        // null username and password
+        java.sql.Connection cnx = ds.getConnection(null, null);
+        assertFalse(cnx.isClosed());
+        ds.setLoginTimeout(5);
+        assertEquals(5, ds.getLoginTimeout());
+        ds.setLogWriter(pw);
+        assertNotNull(ds.getLogWriter());
+        
+        // no username and password
+        cnx = ds.getConnection();
+        assertFalse(cnx.isClosed());
+        ds.setLoginTimeout(5);
+        assertEquals(5, ds.getLoginTimeout());
+        ds.setLogWriter(pw);
+        assertNotNull(ds.getLogWriter());
+    }
+
+    
+    @Test
+    public void testIsWrapperFor() throws Exception
+    {
+        DataSource ds = new CassandraDataSource(HOST,PORT,KEYSPACE,USER,PASSWORD);
+        
+        boolean isIt = false;
+                
+        // it is a wrapper for DataSource
+        isIt = ds.isWrapperFor(DataSource.class);        
+        assertTrue(isIt);
+        
+        // it is not a wrapper for this test class
+        isIt = ds.isWrapperFor(this.getClass());        
+        assertFalse(isIt);
+    }
+ 
+    @Test(expected=SQLFeatureNotSupportedException.class)
+    public void testUnwrap() throws Exception
+    {
+        DataSource ds = new CassandraDataSource(HOST,PORT,KEYSPACE,USER,PASSWORD);
+
+        // it is a wrapper for DataSource
+        DataSource newds = ds.unwrap(DataSource.class);        
+        assertNotNull(newds);
+        
+        // it is not a wrapper for this test class
+        newds = (DataSource) ds.unwrap(this.getClass());        
+        assertNotNull(newds);
+    }
+}
diff --git a/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/jdbc/PreparedStatementTest.java b/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/jdbc/PreparedStatementTest.java
index e69de29b..d0d8741a 100644
--- a/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/jdbc/PreparedStatementTest.java
+++ b/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/jdbc/PreparedStatementTest.java
@@ -0,0 +1,384 @@
+package org.apache.cassandra.cql.jdbc;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+
+import org.apache.cassandra.cql.EmbeddedServiceBase;
+import org.apache.cassandra.utils.FBUtilities;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.sql.DriverManager;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+
+public class PreparedStatementTest extends EmbeddedServiceBase
+{ 
+    private static java.sql.Connection con = null;
+    
+    @BeforeClass
+    public static void waxOn() throws Exception
+    {
+        startCassandraServer();
+        Class.forName("org.apache.cassandra.cql.jdbc.CassandraDriver");
+        con = DriverManager.getConnection("jdbc:cassandra://localhost:9170/Keyspace1");
+    }
+    
+    @Test
+    public void testBytes() throws SQLException
+    {
+        // insert
+        PreparedStatement stmt = con.prepareStatement("update JdbcBytes set ?=?, ?=? where key=?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setBytes(1, FBUtilities.toByteArray(i));
+            stmt.setBytes(2, FBUtilities.toByteArray((i+1)*10));
+            stmt.setBytes(3, FBUtilities.toByteArray(i+100));
+            stmt.setBytes(4, FBUtilities.toByteArray((i+1)*10+1));
+            stmt.setBytes(5, key);
+            stmt.executeUpdate();
+        }
+        
+        // verify
+        stmt = con.prepareStatement("select ?, ? from JdbcBytes where key=?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setBytes(1, FBUtilities.toByteArray(i));
+            stmt.setBytes(2, FBUtilities.toByteArray(i+100));
+            stmt.setBytes(3, key);
+            ResultSet rs = stmt.executeQuery();
+            assert rs.next();
+            assert Arrays.equals(rs.getBytes(FBUtilities.bytesToHex(FBUtilities.toByteArray(i))), FBUtilities.toByteArray((i+1)*10));
+            assert Arrays.equals(rs.getBytes(FBUtilities.bytesToHex(FBUtilities.toByteArray(i+100))), FBUtilities.toByteArray((i+1)*10+1));
+            assert Arrays.equals(rs.getBytes(1), FBUtilities.toByteArray((i+1)*10));
+            assert Arrays.equals(rs.getBytes(2), FBUtilities.toByteArray((i+1)*10+1));
+            assert !rs.next();
+            rs.close();
+        }
+        
+        // delete
+        stmt = con.prepareStatement("delete ?, ? from JdbcBytes where key=?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setBytes(1, FBUtilities.toByteArray(i));
+            stmt.setBytes(2, FBUtilities.toByteArray(i+100));
+            stmt.setBytes(3, key);
+            stmt.execute();
+        }
+        
+        // verify
+        stmt = con.prepareStatement("select ?, ? from JdbcBytes where key=?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setBytes(1, FBUtilities.toByteArray(i));
+            stmt.setBytes(2, FBUtilities.toByteArray(i+100));
+            stmt.setBytes(3, key);
+            ResultSet rs = stmt.executeQuery();
+            rs.next();
+            assert rs.getString(1) == null;  assert rs.getString(2) == null;
+            rs.close();
+        }
+    }
+    
+    @Test
+    public void testUtf8() throws SQLException
+    {
+        // insert.
+        PreparedStatement stmt = con.prepareStatement("update JdbcUtf8 set ?=?, ?=? where key = ?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setString(1, "1\u6543\u3435\u6554");
+            stmt.setString(2, "abc\u6543\u3435\u6554");
+            stmt.setString(3, "2\u6543\u3435\u6554");
+            stmt.setString(4, "def\u6543\u3435\u6554");
+            stmt.setBytes(5, key);
+            stmt.executeUpdate();
+        }
+        
+        // verify
+        stmt = con.prepareStatement("select ?, ? from JdbcUtf8 where key=?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setString(1, "1\u6543\u3435\u6554");
+            stmt.setString(2, "2\u6543\u3435\u6554");
+            stmt.setBytes(3, key);
+            ResultSet rs = stmt.executeQuery();
+            assert rs.next();
+            assert rs.getString("1\u6543\u3435\u6554").equals("abc\u6543\u3435\u6554");
+            assert rs.getString("2\u6543\u3435\u6554").equals("def\u6543\u3435\u6554");
+            assert rs.getString(1).equals("abc\u6543\u3435\u6554");
+            assert rs.getString(2).equals("def\u6543\u3435\u6554");
+            assert !rs.next();
+            rs.close();
+        }
+        
+        // delete
+        stmt = con.prepareStatement("delete ?, ? from JdbcUtf8 where key=?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setString(1, "1\u6543\u3435\u6554");
+            stmt.setString(2, "2\u6543\u3435\u6554");
+            stmt.setBytes(3, key);
+            stmt.execute();
+        }
+        
+        // verify
+        stmt = con.prepareStatement("select ?, ? from JdbcUtf8 where key=?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setString(1, "1\u6543\u3435\u6554");
+            stmt.setString(2, "2\u6543\u3435\u6554");
+            stmt.setBytes(3, key);
+            ResultSet rs = stmt.executeQuery();
+            rs.next();
+            assert rs.getString(1) == null;  assert rs.getString(2) == null;
+            rs.close();
+        }
+    }
+    
+    @Test
+    public void testAscii() throws SQLException
+    {
+        // insert.
+        PreparedStatement stmt = con.prepareStatement("update JdbcAscii set ?=?, ?=? where key = ?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setString(1, "1");
+            stmt.setString(2, "abc");
+            stmt.setString(3, "2");
+            stmt.setString(4, "def");
+            stmt.setBytes(5, key);
+            stmt.executeUpdate();
+        }
+        
+        // verify
+        stmt = con.prepareStatement("select ?, ? from JdbcAscii where key=?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setString(1, "1");
+            stmt.setString(2, "2");
+            stmt.setBytes(3, key);
+            ResultSet rs = stmt.executeQuery();
+            assert rs.next();
+            assert rs.getString("1").equals("abc");
+            assert rs.getString("2").equals("def");
+            assert rs.getString(1).equals("abc");
+            assert rs.getString(2).equals("def");
+            assert !rs.next();
+            rs.close();
+        }
+        
+        // delete
+        stmt = con.prepareStatement("delete ?, ? from JdbcAscii where key=?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setString(1, "1");
+            stmt.setString(2, "2");
+            stmt.setBytes(3, key);
+            stmt.execute();
+        }
+        
+        // verify
+        stmt = con.prepareStatement("select ?, ? from JdbcAscii where key=?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setString(1, "1");
+            stmt.setString(2, "2");
+            stmt.setBytes(3, key);
+            ResultSet rs = stmt.executeQuery();
+            rs.next();
+            assert rs.getString(1) == null;  assert rs.getString(2) == null;
+            rs.close();
+        }
+    }
+    
+    @Test
+    public void testLong() throws SQLException
+    {
+        PreparedStatement stmt = con.prepareStatement("update JdbcLong set ?=?, ?=? where key = ?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setLong(1, 1);
+            stmt.setLong(2, (i+1)*10);
+            stmt.setLong(3, 2);
+            stmt.setLong(4, (i+1)*10+1);
+            stmt.setBytes(5, key);
+            stmt.executeUpdate();
+        }
+        stmt.close();
+        
+        // verify.
+        stmt = con.prepareStatement("select ?, ? from JdbcLong where key = ?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setLong(1, 1);
+            stmt.setLong(2, 2);
+            stmt.setBytes(3, key);
+            ResultSet rs = stmt.executeQuery();
+            assert rs.next();
+            assert rs.getLong("1") == (i+1)*10;
+            assert rs.getLong("2") == (i+1)*10+1;
+            assert rs.getLong(1) == (i+1)*10;
+            assert rs.getLong(2) == (i+1)*10+1;
+            assert !rs.next();
+            rs.close();
+        }
+        
+        // delete
+        stmt = con.prepareStatement("delete ?, ? from JdbcLong where key = ?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setLong(1, 1);
+            stmt.setLong(2, 2);
+            stmt.setBytes(3, key);
+            stmt.execute();
+        }
+        
+        // verify.
+        stmt = con.prepareStatement("select ?, ? from JdbcLong where key = ?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setLong(1, 1);
+            stmt.setLong(2, 2);
+            stmt.setBytes(3, key);
+            ResultSet rs = stmt.executeQuery();
+            rs.next();
+            rs.getLong(1);
+            assert rs.wasNull();
+            rs.close();
+        }
+    }
+    
+    @Test
+    public void testInteger() throws SQLException
+    {
+        PreparedStatement stmt = con.prepareStatement("update JdbcInteger set ?=?, ?=? where key = ?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setInt(1, 1);
+            stmt.setInt(2, (i+1)*10);
+            stmt.setInt(3, 2);
+            stmt.setInt(4, (i+1)*10+1);
+            stmt.setBytes(5, key);
+            stmt.executeUpdate();
+        }
+        stmt.close();
+        
+        // verify.
+        stmt = con.prepareStatement("select ?, ? from JdbcInteger where key = ?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setInt(1, 1);
+            stmt.setInt(2, 2);
+            stmt.setBytes(3, key);
+            ResultSet rs = stmt.executeQuery();
+            assert rs.next();
+            assert rs.getInt("1") == (i+1)*10;
+            assert rs.getInt("2") == (i+1)*10+1;
+            assert rs.getInt(1) == (i+1)*10;
+            assert rs.getInt(2) == (i+1)*10+1;
+            assert !rs.next();
+            rs.close();
+        }
+        
+        // delete
+        stmt = con.prepareStatement("delete ?, ? from JdbcInteger where key = ?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setInt(1, 1);
+            stmt.setInt(2, 2);
+            stmt.setBytes(3, key);
+            stmt.execute();
+        }
+        
+        // verify.
+        stmt = con.prepareStatement("select ?, ? from JdbcInteger where key = ?");
+        for (int i = 0; i < 5; i++)
+        {
+            byte[] key = Integer.toString(i).getBytes();
+            stmt.setInt(1, 1);
+            stmt.setInt(2, 2);
+            stmt.setBytes(3, key);
+            ResultSet rs = stmt.executeQuery();
+            rs.next();
+            rs.getInt(1);
+            assert rs.wasNull();
+            rs.close();
+        }
+    }
+    
+    @Test
+    public void testParamSubstitution() throws SQLException
+    {
+        byte[] key = "key".getBytes();
+        String q = "SELECT 'fo??est', ?, ? from JdbcUtf8 WHERE KEY = ?";
+        CassandraPreparedStatement stmt = (CassandraPreparedStatement)con.prepareStatement(q);
+        stmt.setString(1, "pathological param: ?'make it?? '' sto'p?'");
+        stmt.setString(2, "simple");
+        stmt.setBytes(3, key);
+        String qq = stmt.makeCql();
+        assert qq.equals("SELECT 'fo??est', 'pathological param: ?''make it?? '''' sto''p?''', 'simple' from JdbcUtf8 WHERE KEY = '6b6579'");
+        
+        q = "UPDATE JdbcUtf8 USING CONSISTENCY ONE SET 'fru??us'=?, ?='gr''d?', ?=?, ?=? WHERE key=?";
+        stmt = (CassandraPreparedStatement)con.prepareStatement(q);
+        stmt.setString(1, "o?e");
+        stmt.setString(2, "tw'o");
+        stmt.setString(3, "thr'?'ee");
+        stmt.setString(4, "fo''?'ur");
+        stmt.setString(5, "five");
+        stmt.setString(6, "six");
+        stmt.setBytes(7, key);
+        qq = stmt.makeCql();
+        assert qq.equals("UPDATE JdbcUtf8 USING CONSISTENCY ONE SET 'fru??us'='o?e', 'tw''o'='gr''d?', 'thr''?''ee'='fo''''?''ur', 'five'='six' WHERE key='6b6579'");
+        
+        q = "DELETE ?, ? FROM JdbcUtf8 WHERE KEY=?";
+        stmt = (CassandraPreparedStatement)con.prepareStatement(q);
+        stmt.setString(1, "on'?'");
+        stmt.setString(2, "two");
+        stmt.setBytes(3, key);
+        qq = stmt.makeCql();
+        assert qq.equals("DELETE 'on''?''', 'two' FROM JdbcUtf8 WHERE KEY='6b6579'");
+    }
+}
