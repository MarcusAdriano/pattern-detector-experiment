diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Cassandra.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Cassandra.java
index d21e8f8b..187b9c20 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Cassandra.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Cassandra.java
@@ -166,6 +166,8 @@
      */
     public void remove(String keyspace, String key, ColumnPath column_path, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
 
+    public void batch_mutate(String keyspace, Map<String,Map<String,List<Mutation>>> mutation_map, int consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
+
     /**
      * get property whose value is of type string.
      * 
@@ -670,6 +672,47 @@ public void recv_remove() throws InvalidRequestException, UnavailableException,
       return;
     }
 
+    public void batch_mutate(String keyspace, Map<String,Map<String,List<Mutation>>> mutation_map, int consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
+    {
+      send_batch_mutate(keyspace, mutation_map, consistency_level);
+      recv_batch_mutate();
+    }
+
+    public void send_batch_mutate(String keyspace, Map<String,Map<String,List<Mutation>>> mutation_map, int consistency_level) throws TException
+    {
+      oprot_.writeMessageBegin(new TMessage("batch_mutate", TMessageType.CALL, seqid_));
+      batch_mutate_args args = new batch_mutate_args();
+      args.keyspace = keyspace;
+      args.mutation_map = mutation_map;
+      args.consistency_level = consistency_level;
+      args.write(oprot_);
+      oprot_.writeMessageEnd();
+      oprot_.getTransport().flush();
+    }
+
+    public void recv_batch_mutate() throws InvalidRequestException, UnavailableException, TimedOutException, TException
+    {
+      TMessage msg = iprot_.readMessageBegin();
+      if (msg.type == TMessageType.EXCEPTION) {
+        TApplicationException x = TApplicationException.read(iprot_);
+        iprot_.readMessageEnd();
+        throw x;
+      }
+      batch_mutate_result result = new batch_mutate_result();
+      result.read(iprot_);
+      iprot_.readMessageEnd();
+      if (result.ire != null) {
+        throw result.ire;
+      }
+      if (result.ue != null) {
+        throw result.ue;
+      }
+      if (result.te != null) {
+        throw result.te;
+      }
+      return;
+    }
+
     public String get_string_property(String property) throws TException
     {
       send_get_string_property(property);
@@ -788,6 +831,7 @@ public Processor(Iface iface)
       processMap_.put("insert", new insert());
       processMap_.put("batch_insert", new batch_insert());
       processMap_.put("remove", new remove());
+      processMap_.put("batch_mutate", new batch_mutate());
       processMap_.put("get_string_property", new get_string_property());
       processMap_.put("get_string_list_property", new get_string_list_property());
       processMap_.put("describe_keyspace", new describe_keyspace());
@@ -1141,6 +1185,38 @@ public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TExcepti
 
     }
 
+    private class batch_mutate implements ProcessFunction {
+      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
+      {
+        batch_mutate_args args = new batch_mutate_args();
+        args.read(iprot);
+        iprot.readMessageEnd();
+        batch_mutate_result result = new batch_mutate_result();
+        try {
+          iface_.batch_mutate(args.keyspace, args.mutation_map, args.consistency_level);
+        } catch (InvalidRequestException ire) {
+          result.ire = ire;
+        } catch (UnavailableException ue) {
+          result.ue = ue;
+        } catch (TimedOutException te) {
+          result.te = te;
+        } catch (Throwable th) {
+          LOGGER.error("Internal error processing batch_mutate", th);
+          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing batch_mutate");
+          oprot.writeMessageBegin(new TMessage("batch_mutate", TMessageType.EXCEPTION, seqid));
+          x.write(oprot);
+          oprot.writeMessageEnd();
+          oprot.getTransport().flush();
+          return;
+        }
+        oprot.writeMessageBegin(new TMessage("batch_mutate", TMessageType.REPLY, seqid));
+        result.write(oprot);
+        oprot.writeMessageEnd();
+        oprot.getTransport().flush();
+      }
+
+    }
+
     private class get_string_property implements ProcessFunction {
       public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
       {
@@ -11951,6 +12027,881 @@ public void validate() throws TException {
 
   }
 
+  public static class batch_mutate_args implements TBase, java.io.Serializable, Cloneable   {
+    private static final TStruct STRUCT_DESC = new TStruct("batch_mutate_args");
+    private static final TField KEYSPACE_FIELD_DESC = new TField("keyspace", TType.STRING, (short)1);
+    private static final TField MUTATION_MAP_FIELD_DESC = new TField("mutation_map", TType.MAP, (short)2);
+    private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)3);
+
+    public String keyspace;
+    public Map<String,Map<String,List<Mutation>>> mutation_map;
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public int consistency_level;
+    public static final int KEYSPACE = 1;
+    public static final int MUTATION_MAP = 2;
+    public static final int CONSISTENCY_LEVEL = 3;
+
+    // isset id assignments
+    private static final int __CONSISTENCY_LEVEL_ISSET_ID = 0;
+    private BitSet __isset_bit_vector = new BitSet(1);
+
+    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
+      put(KEYSPACE, new FieldMetaData("keyspace", TFieldRequirementType.REQUIRED, 
+          new FieldValueMetaData(TType.STRING)));
+      put(MUTATION_MAP, new FieldMetaData("mutation_map", TFieldRequirementType.REQUIRED, 
+          new MapMetaData(TType.MAP, 
+              new FieldValueMetaData(TType.STRING), 
+              new MapMetaData(TType.MAP, 
+                  new FieldValueMetaData(TType.STRING), 
+                  new ListMetaData(TType.LIST, 
+                      new StructMetaData(TType.STRUCT, Mutation.class))))));
+      put(CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.REQUIRED, 
+          new FieldValueMetaData(TType.I32)));
+    }});
+
+    static {
+      FieldMetaData.addStructMetaDataMap(batch_mutate_args.class, metaDataMap);
+    }
+
+    public batch_mutate_args() {
+      this.consistency_level = 0;
+
+    }
+
+    public batch_mutate_args(
+      String keyspace,
+      Map<String,Map<String,List<Mutation>>> mutation_map,
+      int consistency_level)
+    {
+      this();
+      this.keyspace = keyspace;
+      this.mutation_map = mutation_map;
+      this.consistency_level = consistency_level;
+      setConsistency_levelIsSet(true);
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public batch_mutate_args(batch_mutate_args other) {
+      __isset_bit_vector.clear();
+      __isset_bit_vector.or(other.__isset_bit_vector);
+      if (other.isSetKeyspace()) {
+        this.keyspace = other.keyspace;
+      }
+      if (other.isSetMutation_map()) {
+        Map<String,Map<String,List<Mutation>>> __this__mutation_map = new HashMap<String,Map<String,List<Mutation>>>();
+        for (Map.Entry<String, Map<String,List<Mutation>>> other_element : other.mutation_map.entrySet()) {
+
+          String other_element_key = other_element.getKey();
+          Map<String,List<Mutation>> other_element_value = other_element.getValue();
+
+          String __this__mutation_map_copy_key = other_element_key;
+
+          Map<String,List<Mutation>> __this__mutation_map_copy_value = new HashMap<String,List<Mutation>>();
+          for (Map.Entry<String, List<Mutation>> other_element_value_element : other_element_value.entrySet()) {
+
+            String other_element_value_element_key = other_element_value_element.getKey();
+            List<Mutation> other_element_value_element_value = other_element_value_element.getValue();
+
+            String __this__mutation_map_copy_value_copy_key = other_element_value_element_key;
+
+            List<Mutation> __this__mutation_map_copy_value_copy_value = new ArrayList<Mutation>();
+            for (Mutation other_element_value_element_value_element : other_element_value_element_value) {
+              __this__mutation_map_copy_value_copy_value.add(new Mutation(other_element_value_element_value_element));
+      }
+
+            __this__mutation_map_copy_value.put(__this__mutation_map_copy_value_copy_key, __this__mutation_map_copy_value_copy_value);
+    }
+
+          __this__mutation_map.put(__this__mutation_map_copy_key, __this__mutation_map_copy_value);
+        }
+        this.mutation_map = __this__mutation_map;
+      }
+      this.consistency_level = other.consistency_level;
+    }
+
+    public batch_mutate_args deepCopy() {
+      return new batch_mutate_args(this);
+    }
+
+    @Deprecated
+    public batch_mutate_args clone() {
+      return new batch_mutate_args(this);
+    }
+
+    public String getKeyspace() {
+      return this.keyspace;
+    }
+
+    public batch_mutate_args setKeyspace(String keyspace) {
+      this.keyspace = keyspace;
+      return this;
+    }
+
+    public void unsetKeyspace() {
+      this.keyspace = null;
+    }
+
+    // Returns true if field keyspace is set (has been asigned a value) and false otherwise
+    public boolean isSetKeyspace() {
+      return this.keyspace != null;
+    }
+
+    public void setKeyspaceIsSet(boolean value) {
+      if (!value) {
+        this.keyspace = null;
+      }
+    }
+
+    public int getMutation_mapSize() {
+      return (this.mutation_map == null) ? 0 : this.mutation_map.size();
+    }
+
+    public void putToMutation_map(String key, Map<String,List<Mutation>> val) {
+      if (this.mutation_map == null) {
+        this.mutation_map = new HashMap<String,Map<String,List<Mutation>>>();
+      }
+      this.mutation_map.put(key, val);
+    }
+
+    public Map<String,Map<String,List<Mutation>>> getMutation_map() {
+      return this.mutation_map;
+    }
+
+    public batch_mutate_args setMutation_map(Map<String,Map<String,List<Mutation>>> mutation_map) {
+      this.mutation_map = mutation_map;
+      return this;
+    }
+
+    public void unsetMutation_map() {
+      this.mutation_map = null;
+    }
+
+    // Returns true if field mutation_map is set (has been asigned a value) and false otherwise
+    public boolean isSetMutation_map() {
+      return this.mutation_map != null;
+    }
+
+    public void setMutation_mapIsSet(boolean value) {
+      if (!value) {
+        this.mutation_map = null;
+      }
+    }
+
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public int getConsistency_level() {
+      return this.consistency_level;
+    }
+
+    /**
+     * 
+     * @see ConsistencyLevel
+     */
+    public batch_mutate_args setConsistency_level(int consistency_level) {
+      this.consistency_level = consistency_level;
+      setConsistency_levelIsSet(true);
+      return this;
+      }
+
+    public void unsetConsistency_level() {
+      __isset_bit_vector.clear(__CONSISTENCY_LEVEL_ISSET_ID);
+    }
+
+    // Returns true if field consistency_level is set (has been asigned a value) and false otherwise
+    public boolean isSetConsistency_level() {
+      return __isset_bit_vector.get(__CONSISTENCY_LEVEL_ISSET_ID);
+    }
+
+    public void setConsistency_levelIsSet(boolean value) {
+      __isset_bit_vector.set(__CONSISTENCY_LEVEL_ISSET_ID, value);
+    }
+
+    public void setFieldValue(int fieldID, Object value) {
+      switch (fieldID) {
+      case KEYSPACE:
+        if (value == null) {
+          unsetKeyspace();
+        } else {
+          setKeyspace((String)value);
+        }
+        break;
+
+      case MUTATION_MAP:
+        if (value == null) {
+          unsetMutation_map();
+        } else {
+          setMutation_map((Map<String,Map<String,List<Mutation>>>)value);
+        }
+        break;
+
+      case CONSISTENCY_LEVEL:
+        if (value == null) {
+          unsetConsistency_level();
+        } else {
+          setConsistency_level((Integer)value);
+        }
+        break;
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    public Object getFieldValue(int fieldID) {
+      switch (fieldID) {
+      case KEYSPACE:
+        return getKeyspace();
+
+      case MUTATION_MAP:
+        return getMutation_map();
+
+      case CONSISTENCY_LEVEL:
+        return getConsistency_level();
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
+    public boolean isSet(int fieldID) {
+      switch (fieldID) {
+      case KEYSPACE:
+        return isSetKeyspace();
+      case MUTATION_MAP:
+        return isSetMutation_map();
+      case CONSISTENCY_LEVEL:
+        return isSetConsistency_level();
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof batch_mutate_args)
+        return this.equals((batch_mutate_args)that);
+      return false;
+    }
+
+    public boolean equals(batch_mutate_args that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_keyspace = true && this.isSetKeyspace();
+      boolean that_present_keyspace = true && that.isSetKeyspace();
+      if (this_present_keyspace || that_present_keyspace) {
+        if (!(this_present_keyspace && that_present_keyspace))
+          return false;
+        if (!this.keyspace.equals(that.keyspace))
+          return false;
+      }
+
+      boolean this_present_mutation_map = true && this.isSetMutation_map();
+      boolean that_present_mutation_map = true && that.isSetMutation_map();
+      if (this_present_mutation_map || that_present_mutation_map) {
+        if (!(this_present_mutation_map && that_present_mutation_map))
+          return false;
+        if (!this.mutation_map.equals(that.mutation_map))
+          return false;
+      }
+
+      boolean this_present_consistency_level = true;
+      boolean that_present_consistency_level = true;
+      if (this_present_consistency_level || that_present_consistency_level) {
+        if (!(this_present_consistency_level && that_present_consistency_level))
+          return false;
+        if (this.consistency_level != that.consistency_level)
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      return 0;
+    }
+
+    public void read(TProtocol iprot) throws TException {
+      TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == TType.STOP) { 
+          break;
+        }
+        switch (field.id)
+        {
+          case KEYSPACE:
+            if (field.type == TType.STRING) {
+              this.keyspace = iprot.readString();
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case MUTATION_MAP:
+            if (field.type == TType.MAP) {
+              {
+                TMap _map55 = iprot.readMapBegin();
+                this.mutation_map = new HashMap<String,Map<String,List<Mutation>>>(2*_map55.size);
+                for (int _i56 = 0; _i56 < _map55.size; ++_i56)
+                {
+                  String _key57;
+                  Map<String,List<Mutation>> _val58;
+                  _key57 = iprot.readString();
+                  {
+                    TMap _map59 = iprot.readMapBegin();
+                    _val58 = new HashMap<String,List<Mutation>>(2*_map59.size);
+                    for (int _i60 = 0; _i60 < _map59.size; ++_i60)
+                    {
+                      String _key61;
+                      List<Mutation> _val62;
+                      _key61 = iprot.readString();
+                      {
+                        TList _list63 = iprot.readListBegin();
+                        _val62 = new ArrayList<Mutation>(_list63.size);
+                        for (int _i64 = 0; _i64 < _list63.size; ++_i64)
+                        {
+                          Mutation _elem65;
+                          _elem65 = new Mutation();
+                          _elem65.read(iprot);
+                          _val62.add(_elem65);
+                        }
+                        iprot.readListEnd();
+                      }
+                      _val58.put(_key61, _val62);
+                    }
+                    iprot.readMapEnd();
+                  }
+                  this.mutation_map.put(_key57, _val58);
+                }
+                iprot.readMapEnd();
+              }
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case CONSISTENCY_LEVEL:
+            if (field.type == TType.I32) {
+              this.consistency_level = iprot.readI32();
+              setConsistency_levelIsSet(true);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            TProtocolUtil.skip(iprot, field.type);
+            break;
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+
+
+      // check for required fields of primitive type, which can't be checked in the validate method
+      if (!isSetConsistency_level()) {
+        throw new TProtocolException("Required field 'consistency_level' was not found in serialized data! Struct: " + toString());
+      }
+      validate();
+    }
+
+    public void write(TProtocol oprot) throws TException {
+      validate();
+
+      oprot.writeStructBegin(STRUCT_DESC);
+      if (this.keyspace != null) {
+        oprot.writeFieldBegin(KEYSPACE_FIELD_DESC);
+        oprot.writeString(this.keyspace);
+        oprot.writeFieldEnd();
+      }
+      if (this.mutation_map != null) {
+        oprot.writeFieldBegin(MUTATION_MAP_FIELD_DESC);
+        {
+          oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.mutation_map.size()));
+          for (Map.Entry<String, Map<String,List<Mutation>>> _iter66 : this.mutation_map.entrySet())
+          {
+            oprot.writeString(_iter66.getKey());
+            {
+              oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, _iter66.getValue().size()));
+              for (Map.Entry<String, List<Mutation>> _iter67 : _iter66.getValue().entrySet())
+              {
+                oprot.writeString(_iter67.getKey());
+                {
+                  oprot.writeListBegin(new TList(TType.STRUCT, _iter67.getValue().size()));
+                  for (Mutation _iter68 : _iter67.getValue())
+                  {
+                    _iter68.write(oprot);
+                  }
+                  oprot.writeListEnd();
+                }
+              }
+              oprot.writeMapEnd();
+            }
+          }
+          oprot.writeMapEnd();
+        }
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
+      oprot.writeI32(this.consistency_level);
+      oprot.writeFieldEnd();
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("batch_mutate_args(");
+      boolean first = true;
+
+      sb.append("keyspace:");
+      if (this.keyspace == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.keyspace);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("mutation_map:");
+      if (this.mutation_map == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.mutation_map);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("consistency_level:");
+      String consistency_level_name = ConsistencyLevel.VALUES_TO_NAMES.get(this.consistency_level);
+      if (consistency_level_name != null) {
+        sb.append(consistency_level_name);
+        sb.append(" (");
+      }
+      sb.append(this.consistency_level);
+      if (consistency_level_name != null) {
+        sb.append(")");
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws TException {
+      // check for required fields
+      if (keyspace == null) {
+        throw new TProtocolException("Required field 'keyspace' was not present! Struct: " + toString());
+      }
+      if (mutation_map == null) {
+        throw new TProtocolException("Required field 'mutation_map' was not present! Struct: " + toString());
+      }
+      // alas, we cannot check 'consistency_level' because it's a primitive and you chose the non-beans generator.
+      // check that fields of type enum have valid values
+      if (isSetConsistency_level() && !ConsistencyLevel.VALID_VALUES.contains(consistency_level)){
+        throw new TProtocolException("The field 'consistency_level' has been assigned the invalid value " + consistency_level);
+      }
+    }
+
+  }
+
+  public static class batch_mutate_result implements TBase, java.io.Serializable, Cloneable, Comparable<batch_mutate_result>   {
+    private static final TStruct STRUCT_DESC = new TStruct("batch_mutate_result");
+    private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
+    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
+    private static final TField TE_FIELD_DESC = new TField("te", TType.STRUCT, (short)3);
+
+    public InvalidRequestException ire;
+    public UnavailableException ue;
+    public TimedOutException te;
+    public static final int IRE = 1;
+    public static final int UE = 2;
+    public static final int TE = 3;
+
+    // isset id assignments
+
+    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
+      put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
+      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
+      put(TE, new FieldMetaData("te", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
+    }});
+
+    static {
+      FieldMetaData.addStructMetaDataMap(batch_mutate_result.class, metaDataMap);
+    }
+
+    public batch_mutate_result() {
+    }
+
+    public batch_mutate_result(
+      InvalidRequestException ire,
+      UnavailableException ue,
+      TimedOutException te)
+    {
+      this();
+      this.ire = ire;
+      this.ue = ue;
+      this.te = te;
+    }
+
+    /**
+     * Performs a deep copy on <i>other</i>.
+     */
+    public batch_mutate_result(batch_mutate_result other) {
+      if (other.isSetIre()) {
+        this.ire = new InvalidRequestException(other.ire);
+      }
+      if (other.isSetUe()) {
+        this.ue = new UnavailableException(other.ue);
+      }
+      if (other.isSetTe()) {
+        this.te = new TimedOutException(other.te);
+      }
+    }
+
+    public batch_mutate_result deepCopy() {
+      return new batch_mutate_result(this);
+    }
+
+    @Deprecated
+    public batch_mutate_result clone() {
+      return new batch_mutate_result(this);
+    }
+
+    public InvalidRequestException getIre() {
+      return this.ire;
+    }
+
+    public batch_mutate_result setIre(InvalidRequestException ire) {
+      this.ire = ire;
+      return this;
+    }
+
+    public void unsetIre() {
+      this.ire = null;
+    }
+
+    // Returns true if field ire is set (has been asigned a value) and false otherwise
+    public boolean isSetIre() {
+      return this.ire != null;
+    }
+
+    public void setIreIsSet(boolean value) {
+      if (!value) {
+        this.ire = null;
+      }
+    }
+
+    public UnavailableException getUe() {
+      return this.ue;
+    }
+
+    public batch_mutate_result setUe(UnavailableException ue) {
+      this.ue = ue;
+      return this;
+    }
+
+    public void unsetUe() {
+      this.ue = null;
+    }
+
+    // Returns true if field ue is set (has been asigned a value) and false otherwise
+    public boolean isSetUe() {
+      return this.ue != null;
+    }
+
+    public void setUeIsSet(boolean value) {
+      if (!value) {
+        this.ue = null;
+      }
+    }
+
+    public TimedOutException getTe() {
+      return this.te;
+    }
+
+    public batch_mutate_result setTe(TimedOutException te) {
+      this.te = te;
+      return this;
+    }
+
+    public void unsetTe() {
+      this.te = null;
+    }
+
+    // Returns true if field te is set (has been asigned a value) and false otherwise
+    public boolean isSetTe() {
+      return this.te != null;
+    }
+
+    public void setTeIsSet(boolean value) {
+      if (!value) {
+        this.te = null;
+      }
+    }
+
+    public void setFieldValue(int fieldID, Object value) {
+      switch (fieldID) {
+      case IRE:
+        if (value == null) {
+          unsetIre();
+        } else {
+          setIre((InvalidRequestException)value);
+        }
+        break;
+
+      case UE:
+        if (value == null) {
+          unsetUe();
+        } else {
+          setUe((UnavailableException)value);
+        }
+        break;
+
+      case TE:
+        if (value == null) {
+          unsetTe();
+        } else {
+          setTe((TimedOutException)value);
+        }
+        break;
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    public Object getFieldValue(int fieldID) {
+      switch (fieldID) {
+      case IRE:
+        return getIre();
+
+      case UE:
+        return getUe();
+
+      case TE:
+        return getTe();
+
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
+    public boolean isSet(int fieldID) {
+      switch (fieldID) {
+      case IRE:
+        return isSetIre();
+      case UE:
+        return isSetUe();
+      case TE:
+        return isSetTe();
+      default:
+        throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+      }
+    }
+
+    @Override
+    public boolean equals(Object that) {
+      if (that == null)
+        return false;
+      if (that instanceof batch_mutate_result)
+        return this.equals((batch_mutate_result)that);
+      return false;
+    }
+
+    public boolean equals(batch_mutate_result that) {
+      if (that == null)
+        return false;
+
+      boolean this_present_ire = true && this.isSetIre();
+      boolean that_present_ire = true && that.isSetIre();
+      if (this_present_ire || that_present_ire) {
+        if (!(this_present_ire && that_present_ire))
+          return false;
+        if (!this.ire.equals(that.ire))
+          return false;
+      }
+
+      boolean this_present_ue = true && this.isSetUe();
+      boolean that_present_ue = true && that.isSetUe();
+      if (this_present_ue || that_present_ue) {
+        if (!(this_present_ue && that_present_ue))
+          return false;
+        if (!this.ue.equals(that.ue))
+          return false;
+      }
+
+      boolean this_present_te = true && this.isSetTe();
+      boolean that_present_te = true && that.isSetTe();
+      if (this_present_te || that_present_te) {
+        if (!(this_present_te && that_present_te))
+          return false;
+        if (!this.te.equals(that.te))
+          return false;
+      }
+
+      return true;
+    }
+
+    @Override
+    public int hashCode() {
+      return 0;
+    }
+
+    public int compareTo(batch_mutate_result other) {
+      if (!getClass().equals(other.getClass())) {
+        return getClass().getName().compareTo(other.getClass().getName());
+      }
+
+      int lastComparison = 0;
+      batch_mutate_result typedOther = (batch_mutate_result)other;
+
+      lastComparison = Boolean.valueOf(isSetIre()).compareTo(isSetIre());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(ire, typedOther.ire);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = Boolean.valueOf(isSetTe()).compareTo(isSetTe());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(te, typedOther.te);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      return 0;
+    }
+
+    public void read(TProtocol iprot) throws TException {
+      TField field;
+      iprot.readStructBegin();
+      while (true)
+      {
+        field = iprot.readFieldBegin();
+        if (field.type == TType.STOP) { 
+          break;
+        }
+        switch (field.id)
+        {
+          case IRE:
+            if (field.type == TType.STRUCT) {
+              this.ire = new InvalidRequestException();
+              this.ire.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case UE:
+            if (field.type == TType.STRUCT) {
+              this.ue = new UnavailableException();
+              this.ue.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          case TE:
+            if (field.type == TType.STRUCT) {
+              this.te = new TimedOutException();
+              this.te.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            TProtocolUtil.skip(iprot, field.type);
+            break;
+        }
+        iprot.readFieldEnd();
+      }
+      iprot.readStructEnd();
+
+
+      // check for required fields of primitive type, which can't be checked in the validate method
+      validate();
+    }
+
+    public void write(TProtocol oprot) throws TException {
+      oprot.writeStructBegin(STRUCT_DESC);
+
+      if (this.isSetIre()) {
+        oprot.writeFieldBegin(IRE_FIELD_DESC);
+        this.ire.write(oprot);
+        oprot.writeFieldEnd();
+      } else if (this.isSetUe()) {
+        oprot.writeFieldBegin(UE_FIELD_DESC);
+        this.ue.write(oprot);
+        oprot.writeFieldEnd();
+      } else if (this.isSetTe()) {
+        oprot.writeFieldBegin(TE_FIELD_DESC);
+        this.te.write(oprot);
+        oprot.writeFieldEnd();
+      }
+      oprot.writeFieldStop();
+      oprot.writeStructEnd();
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder sb = new StringBuilder("batch_mutate_result(");
+      boolean first = true;
+
+      sb.append("ire:");
+      if (this.ire == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ire);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("ue:");
+      if (this.ue == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ue);
+      }
+      first = false;
+      if (!first) sb.append(", ");
+      sb.append("te:");
+      if (this.te == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.te);
+      }
+      first = false;
+      sb.append(")");
+      return sb.toString();
+    }
+
+    public void validate() throws TException {
+      // check for required fields
+      // check that fields of type enum have valid values
+    }
+
+  }
+
   public static class get_string_property_args implements TBase, java.io.Serializable, Cloneable, Comparable<get_string_property_args>   {
     private static final TStruct STRUCT_DESC = new TStruct("get_string_property_args");
     private static final TField PROPERTY_FIELD_DESC = new TField("property", TType.STRING, (short)1);
@@ -12807,13 +13758,13 @@ public void read(TProtocol iprot) throws TException {
           case SUCCESS:
             if (field.type == TType.LIST) {
               {
-                TList _list55 = iprot.readListBegin();
-                this.success = new ArrayList<String>(_list55.size);
-                for (int _i56 = 0; _i56 < _list55.size; ++_i56)
+                TList _list69 = iprot.readListBegin();
+                this.success = new ArrayList<String>(_list69.size);
+                for (int _i70 = 0; _i70 < _list69.size; ++_i70)
                 {
-                  String _elem57;
-                  _elem57 = iprot.readString();
-                  this.success.add(_elem57);
+                  String _elem71;
+                  _elem71 = iprot.readString();
+                  this.success.add(_elem71);
                 }
                 iprot.readListEnd();
               }
@@ -12841,9 +13792,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
-          for (String _iter58 : this.success)
+          for (String _iter72 : this.success)
           {
-            oprot.writeString(_iter58);
+            oprot.writeString(_iter72);
           }
           oprot.writeListEnd();
         }
@@ -13343,27 +14294,27 @@ public void read(TProtocol iprot) throws TException {
           case SUCCESS:
             if (field.type == TType.MAP) {
               {
-                TMap _map59 = iprot.readMapBegin();
-                this.success = new HashMap<String,Map<String,String>>(2*_map59.size);
-                for (int _i60 = 0; _i60 < _map59.size; ++_i60)
+                TMap _map73 = iprot.readMapBegin();
+                this.success = new HashMap<String,Map<String,String>>(2*_map73.size);
+                for (int _i74 = 0; _i74 < _map73.size; ++_i74)
                 {
-                  String _key61;
-                  Map<String,String> _val62;
-                  _key61 = iprot.readString();
+                  String _key75;
+                  Map<String,String> _val76;
+                  _key75 = iprot.readString();
                   {
-                    TMap _map63 = iprot.readMapBegin();
-                    _val62 = new HashMap<String,String>(2*_map63.size);
-                    for (int _i64 = 0; _i64 < _map63.size; ++_i64)
+                    TMap _map77 = iprot.readMapBegin();
+                    _val76 = new HashMap<String,String>(2*_map77.size);
+                    for (int _i78 = 0; _i78 < _map77.size; ++_i78)
                     {
-                      String _key65;
-                      String _val66;
-                      _key65 = iprot.readString();
-                      _val66 = iprot.readString();
-                      _val62.put(_key65, _val66);
+                      String _key79;
+                      String _val80;
+                      _key79 = iprot.readString();
+                      _val80 = iprot.readString();
+                      _val76.put(_key79, _val80);
                     }
                     iprot.readMapEnd();
                   }
-                  this.success.put(_key61, _val62);
+                  this.success.put(_key75, _val76);
                 }
                 iprot.readMapEnd();
               }
@@ -13399,15 +14350,15 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.success.size()));
-          for (Map.Entry<String, Map<String,String>> _iter67 : this.success.entrySet())
+          for (Map.Entry<String, Map<String,String>> _iter81 : this.success.entrySet())
           {
-            oprot.writeString(_iter67.getKey());
+            oprot.writeString(_iter81.getKey());
             {
-              oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter67.getValue().size()));
-              for (Map.Entry<String, String> _iter68 : _iter67.getValue().entrySet())
+              oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter81.getValue().size()));
+              for (Map.Entry<String, String> _iter82 : _iter81.getValue().entrySet())
               {
-                oprot.writeString(_iter68.getKey());
-                oprot.writeString(_iter68.getValue());
+                oprot.writeString(_iter82.getKey());
+                oprot.writeString(_iter82.getValue());
               }
               oprot.writeMapEnd();
             }
diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Deletion.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Deletion.java
index 3f24d583..dbac913c 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Deletion.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Deletion.java
@@ -1 +1,450 @@
   + native
+/**
+ * Autogenerated by Thrift
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ */
+package org.apache.cassandra.service;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.Collections;
+import java.util.BitSet;
+import java.util.Arrays;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.thrift.*;
+import org.apache.thrift.meta_data.*;
+import org.apache.thrift.protocol.*;
+
+public class Deletion implements TBase, java.io.Serializable, Cloneable, Comparable<Deletion> {
+  private static final TStruct STRUCT_DESC = new TStruct("Deletion");
+  private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)1);
+  private static final TField SUPER_COLUMN_FIELD_DESC = new TField("super_column", TType.STRING, (short)2);
+  private static final TField PREDICATE_FIELD_DESC = new TField("predicate", TType.STRUCT, (short)3);
+
+  public long timestamp;
+  public byte[] super_column;
+  public SlicePredicate predicate;
+  public static final int TIMESTAMP = 1;
+  public static final int SUPER_COLUMN = 2;
+  public static final int PREDICATE = 3;
+
+  // isset id assignments
+  private static final int __TIMESTAMP_ISSET_ID = 0;
+  private BitSet __isset_bit_vector = new BitSet(1);
+
+  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
+    put(TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.REQUIRED, 
+        new FieldValueMetaData(TType.I64)));
+    put(SUPER_COLUMN, new FieldMetaData("super_column", TFieldRequirementType.OPTIONAL, 
+        new FieldValueMetaData(TType.STRING)));
+    put(PREDICATE, new FieldMetaData("predicate", TFieldRequirementType.OPTIONAL, 
+        new StructMetaData(TType.STRUCT, SlicePredicate.class)));
+  }});
+
+  static {
+    FieldMetaData.addStructMetaDataMap(Deletion.class, metaDataMap);
+  }
+
+  public Deletion() {
+  }
+
+  public Deletion(
+    long timestamp,
+    byte[] super_column,
+    SlicePredicate predicate)
+  {
+    this();
+    this.timestamp = timestamp;
+    setTimestampIsSet(true);
+    this.super_column = super_column;
+    this.predicate = predicate;
+  }
+
+  /**
+   * Performs a deep copy on <i>other</i>.
+   */
+  public Deletion(Deletion other) {
+    __isset_bit_vector.clear();
+    __isset_bit_vector.or(other.__isset_bit_vector);
+    this.timestamp = other.timestamp;
+    if (other.isSetSuper_column()) {
+      this.super_column = new byte[other.super_column.length];
+      System.arraycopy(other.super_column, 0, super_column, 0, other.super_column.length);
+    }
+    if (other.isSetPredicate()) {
+      this.predicate = new SlicePredicate(other.predicate);
+    }
+  }
+
+  public Deletion deepCopy() {
+    return new Deletion(this);
+  }
+
+  @Deprecated
+  public Deletion clone() {
+    return new Deletion(this);
+  }
+
+  public long getTimestamp() {
+    return this.timestamp;
+  }
+
+  public Deletion setTimestamp(long timestamp) {
+    this.timestamp = timestamp;
+    setTimestampIsSet(true);
+    return this;
+  }
+
+  public void unsetTimestamp() {
+    __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
+  }
+
+  // Returns true if field timestamp is set (has been asigned a value) and false otherwise
+  public boolean isSetTimestamp() {
+    return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
+  }
+
+  public void setTimestampIsSet(boolean value) {
+    __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
+  }
+
+  public byte[] getSuper_column() {
+    return this.super_column;
+  }
+
+  public Deletion setSuper_column(byte[] super_column) {
+    this.super_column = super_column;
+    return this;
+  }
+
+  public void unsetSuper_column() {
+    this.super_column = null;
+  }
+
+  // Returns true if field super_column is set (has been asigned a value) and false otherwise
+  public boolean isSetSuper_column() {
+    return this.super_column != null;
+  }
+
+  public void setSuper_columnIsSet(boolean value) {
+    if (!value) {
+      this.super_column = null;
+    }
+  }
+
+  public SlicePredicate getPredicate() {
+    return this.predicate;
+  }
+
+  public Deletion setPredicate(SlicePredicate predicate) {
+    this.predicate = predicate;
+    return this;
+  }
+
+  public void unsetPredicate() {
+    this.predicate = null;
+  }
+
+  // Returns true if field predicate is set (has been asigned a value) and false otherwise
+  public boolean isSetPredicate() {
+    return this.predicate != null;
+  }
+
+  public void setPredicateIsSet(boolean value) {
+    if (!value) {
+      this.predicate = null;
+    }
+  }
+
+  public void setFieldValue(int fieldID, Object value) {
+    switch (fieldID) {
+    case TIMESTAMP:
+      if (value == null) {
+        unsetTimestamp();
+      } else {
+        setTimestamp((Long)value);
+      }
+      break;
+
+    case SUPER_COLUMN:
+      if (value == null) {
+        unsetSuper_column();
+      } else {
+        setSuper_column((byte[])value);
+      }
+      break;
+
+    case PREDICATE:
+      if (value == null) {
+        unsetPredicate();
+      } else {
+        setPredicate((SlicePredicate)value);
+      }
+      break;
+
+    default:
+      throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+    }
+  }
+
+  public Object getFieldValue(int fieldID) {
+    switch (fieldID) {
+    case TIMESTAMP:
+      return new Long(getTimestamp());
+
+    case SUPER_COLUMN:
+      return getSuper_column();
+
+    case PREDICATE:
+      return getPredicate();
+
+    default:
+      throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+    }
+  }
+
+  // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
+  public boolean isSet(int fieldID) {
+    switch (fieldID) {
+    case TIMESTAMP:
+      return isSetTimestamp();
+    case SUPER_COLUMN:
+      return isSetSuper_column();
+    case PREDICATE:
+      return isSetPredicate();
+    default:
+      throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+    }
+  }
+
+  @Override
+  public boolean equals(Object that) {
+    if (that == null)
+      return false;
+    if (that instanceof Deletion)
+      return this.equals((Deletion)that);
+    return false;
+  }
+
+  public boolean equals(Deletion that) {
+    if (that == null)
+      return false;
+
+    boolean this_present_timestamp = true;
+    boolean that_present_timestamp = true;
+    if (this_present_timestamp || that_present_timestamp) {
+      if (!(this_present_timestamp && that_present_timestamp))
+        return false;
+      if (this.timestamp != that.timestamp)
+        return false;
+    }
+
+    boolean this_present_super_column = true && this.isSetSuper_column();
+    boolean that_present_super_column = true && that.isSetSuper_column();
+    if (this_present_super_column || that_present_super_column) {
+      if (!(this_present_super_column && that_present_super_column))
+        return false;
+      if (!java.util.Arrays.equals(this.super_column, that.super_column))
+        return false;
+    }
+
+    boolean this_present_predicate = true && this.isSetPredicate();
+    boolean that_present_predicate = true && that.isSetPredicate();
+    if (this_present_predicate || that_present_predicate) {
+      if (!(this_present_predicate && that_present_predicate))
+        return false;
+      if (!this.predicate.equals(that.predicate))
+        return false;
+    }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    return 0;
+  }
+
+  public int compareTo(Deletion other) {
+    if (!getClass().equals(other.getClass())) {
+      return getClass().getName().compareTo(other.getClass().getName());
+    }
+
+    int lastComparison = 0;
+    Deletion typedOther = (Deletion)other;
+
+    lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(isSetTimestamp());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    lastComparison = TBaseHelper.compareTo(timestamp, typedOther.timestamp);
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    lastComparison = Boolean.valueOf(isSetSuper_column()).compareTo(isSetSuper_column());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    lastComparison = TBaseHelper.compareTo(super_column, typedOther.super_column);
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    lastComparison = Boolean.valueOf(isSetPredicate()).compareTo(isSetPredicate());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    lastComparison = TBaseHelper.compareTo(predicate, typedOther.predicate);
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    return 0;
+  }
+
+  public void read(TProtocol iprot) throws TException {
+    TField field;
+    iprot.readStructBegin();
+    while (true)
+    {
+      field = iprot.readFieldBegin();
+      if (field.type == TType.STOP) { 
+        break;
+      }
+      switch (field.id)
+      {
+        case TIMESTAMP:
+          if (field.type == TType.I64) {
+            this.timestamp = iprot.readI64();
+            setTimestampIsSet(true);
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        case SUPER_COLUMN:
+          if (field.type == TType.STRING) {
+            this.super_column = iprot.readBinary();
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        case PREDICATE:
+          if (field.type == TType.STRUCT) {
+            this.predicate = new SlicePredicate();
+            this.predicate.read(iprot);
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        default:
+          TProtocolUtil.skip(iprot, field.type);
+          break;
+      }
+      iprot.readFieldEnd();
+    }
+    iprot.readStructEnd();
+
+
+    // check for required fields of primitive type, which can't be checked in the validate method
+    if (!isSetTimestamp()) {
+      throw new TProtocolException("Required field 'timestamp' was not found in serialized data! Struct: " + toString());
+    }
+    validate();
+  }
+
+  public void write(TProtocol oprot) throws TException {
+    validate();
+
+    oprot.writeStructBegin(STRUCT_DESC);
+    oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
+    oprot.writeI64(this.timestamp);
+    oprot.writeFieldEnd();
+    if (this.super_column != null) {
+      if (isSetSuper_column()) {
+        oprot.writeFieldBegin(SUPER_COLUMN_FIELD_DESC);
+        oprot.writeBinary(this.super_column);
+        oprot.writeFieldEnd();
+      }
+    }
+    if (this.predicate != null) {
+      if (isSetPredicate()) {
+        oprot.writeFieldBegin(PREDICATE_FIELD_DESC);
+        this.predicate.write(oprot);
+        oprot.writeFieldEnd();
+      }
+    }
+    oprot.writeFieldStop();
+    oprot.writeStructEnd();
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("Deletion(");
+    boolean first = true;
+
+    sb.append("timestamp:");
+    sb.append(this.timestamp);
+    first = false;
+    if (isSetSuper_column()) {
+      if (!first) sb.append(", ");
+      sb.append("super_column:");
+      if (this.super_column == null) {
+        sb.append("null");
+      } else {
+          int __super_column_size = Math.min(this.super_column.length, 128);
+          for (int i = 0; i < __super_column_size; i++) {
+            if (i != 0) sb.append(" ");
+            sb.append(Integer.toHexString(this.super_column[i]).length() > 1 ? Integer.toHexString(this.super_column[i]).substring(Integer.toHexString(this.super_column[i]).length() - 2).toUpperCase() : "0" + Integer.toHexString(this.super_column[i]).toUpperCase());
+          }
+          if (this.super_column.length > 128) sb.append(" ...");
+      }
+      first = false;
+    }
+    if (isSetPredicate()) {
+      if (!first) sb.append(", ");
+      sb.append("predicate:");
+      if (this.predicate == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.predicate);
+      }
+      first = false;
+    }
+    sb.append(")");
+    return sb.toString();
+  }
+
+  public void validate() throws TException {
+    // check for required fields
+    // alas, we cannot check 'timestamp' because it's a primitive and you chose the non-beans generator.
+    // check that fields of type enum have valid values
+  }
+
+}
+
diff --git a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Mutation.java b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Mutation.java
index e69de29b..a67b47ba 100644
--- a/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Mutation.java
+++ b/incubator/cassandra/trunk/interface/gen-java/org/apache/cassandra/service/Mutation.java
@@ -0,0 +1,364 @@
+/**
+ * Autogenerated by Thrift
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ */
+package org.apache.cassandra.service;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.Collections;
+import java.util.BitSet;
+import java.util.Arrays;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.thrift.*;
+import org.apache.thrift.meta_data.*;
+import org.apache.thrift.protocol.*;
+
+/**
+ * A Mutation is either an insert, represented by filling column_or_supercolumn, or a deletion, represented by filling the deletion attribute.
+ * @param column_or_supercolumn. An insert to a column or supercolumn
+ * @param deletion. A deletion of a column or supercolumn
+ */
+public class Mutation implements TBase, java.io.Serializable, Cloneable, Comparable<Mutation> {
+  private static final TStruct STRUCT_DESC = new TStruct("Mutation");
+  private static final TField COLUMN_OR_SUPERCOLUMN_FIELD_DESC = new TField("column_or_supercolumn", TType.STRUCT, (short)1);
+  private static final TField DELETION_FIELD_DESC = new TField("deletion", TType.STRUCT, (short)2);
+
+  public ColumnOrSuperColumn column_or_supercolumn;
+  public Deletion deletion;
+  public static final int COLUMN_OR_SUPERCOLUMN = 1;
+  public static final int DELETION = 2;
+
+  // isset id assignments
+
+  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{
+    put(COLUMN_OR_SUPERCOLUMN, new FieldMetaData("column_or_supercolumn", TFieldRequirementType.OPTIONAL, 
+        new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class)));
+    put(DELETION, new FieldMetaData("deletion", TFieldRequirementType.OPTIONAL, 
+        new StructMetaData(TType.STRUCT, Deletion.class)));
+  }});
+
+  static {
+    FieldMetaData.addStructMetaDataMap(Mutation.class, metaDataMap);
+  }
+
+  public Mutation() {
+  }
+
+  public Mutation(
+    ColumnOrSuperColumn column_or_supercolumn,
+    Deletion deletion)
+  {
+    this();
+    this.column_or_supercolumn = column_or_supercolumn;
+    this.deletion = deletion;
+  }
+
+  /**
+   * Performs a deep copy on <i>other</i>.
+   */
+  public Mutation(Mutation other) {
+    if (other.isSetColumn_or_supercolumn()) {
+      this.column_or_supercolumn = new ColumnOrSuperColumn(other.column_or_supercolumn);
+    }
+    if (other.isSetDeletion()) {
+      this.deletion = new Deletion(other.deletion);
+    }
+  }
+
+  public Mutation deepCopy() {
+    return new Mutation(this);
+  }
+
+  @Deprecated
+  public Mutation clone() {
+    return new Mutation(this);
+  }
+
+  public ColumnOrSuperColumn getColumn_or_supercolumn() {
+    return this.column_or_supercolumn;
+  }
+
+  public Mutation setColumn_or_supercolumn(ColumnOrSuperColumn column_or_supercolumn) {
+    this.column_or_supercolumn = column_or_supercolumn;
+    return this;
+  }
+
+  public void unsetColumn_or_supercolumn() {
+    this.column_or_supercolumn = null;
+  }
+
+  // Returns true if field column_or_supercolumn is set (has been asigned a value) and false otherwise
+  public boolean isSetColumn_or_supercolumn() {
+    return this.column_or_supercolumn != null;
+  }
+
+  public void setColumn_or_supercolumnIsSet(boolean value) {
+    if (!value) {
+      this.column_or_supercolumn = null;
+    }
+  }
+
+  public Deletion getDeletion() {
+    return this.deletion;
+  }
+
+  public Mutation setDeletion(Deletion deletion) {
+    this.deletion = deletion;
+    return this;
+  }
+
+  public void unsetDeletion() {
+    this.deletion = null;
+  }
+
+  // Returns true if field deletion is set (has been asigned a value) and false otherwise
+  public boolean isSetDeletion() {
+    return this.deletion != null;
+  }
+
+  public void setDeletionIsSet(boolean value) {
+    if (!value) {
+      this.deletion = null;
+    }
+  }
+
+  public void setFieldValue(int fieldID, Object value) {
+    switch (fieldID) {
+    case COLUMN_OR_SUPERCOLUMN:
+      if (value == null) {
+        unsetColumn_or_supercolumn();
+      } else {
+        setColumn_or_supercolumn((ColumnOrSuperColumn)value);
+      }
+      break;
+
+    case DELETION:
+      if (value == null) {
+        unsetDeletion();
+      } else {
+        setDeletion((Deletion)value);
+      }
+      break;
+
+    default:
+      throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+    }
+  }
+
+  public Object getFieldValue(int fieldID) {
+    switch (fieldID) {
+    case COLUMN_OR_SUPERCOLUMN:
+      return getColumn_or_supercolumn();
+
+    case DELETION:
+      return getDeletion();
+
+    default:
+      throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+    }
+  }
+
+  // Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise
+  public boolean isSet(int fieldID) {
+    switch (fieldID) {
+    case COLUMN_OR_SUPERCOLUMN:
+      return isSetColumn_or_supercolumn();
+    case DELETION:
+      return isSetDeletion();
+    default:
+      throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
+    }
+  }
+
+  @Override
+  public boolean equals(Object that) {
+    if (that == null)
+      return false;
+    if (that instanceof Mutation)
+      return this.equals((Mutation)that);
+    return false;
+  }
+
+  public boolean equals(Mutation that) {
+    if (that == null)
+      return false;
+
+    boolean this_present_column_or_supercolumn = true && this.isSetColumn_or_supercolumn();
+    boolean that_present_column_or_supercolumn = true && that.isSetColumn_or_supercolumn();
+    if (this_present_column_or_supercolumn || that_present_column_or_supercolumn) {
+      if (!(this_present_column_or_supercolumn && that_present_column_or_supercolumn))
+        return false;
+      if (!this.column_or_supercolumn.equals(that.column_or_supercolumn))
+        return false;
+    }
+
+    boolean this_present_deletion = true && this.isSetDeletion();
+    boolean that_present_deletion = true && that.isSetDeletion();
+    if (this_present_deletion || that_present_deletion) {
+      if (!(this_present_deletion && that_present_deletion))
+        return false;
+      if (!this.deletion.equals(that.deletion))
+        return false;
+    }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    return 0;
+  }
+
+  public int compareTo(Mutation other) {
+    if (!getClass().equals(other.getClass())) {
+      return getClass().getName().compareTo(other.getClass().getName());
+    }
+
+    int lastComparison = 0;
+    Mutation typedOther = (Mutation)other;
+
+    lastComparison = Boolean.valueOf(isSetColumn_or_supercolumn()).compareTo(isSetColumn_or_supercolumn());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    lastComparison = TBaseHelper.compareTo(column_or_supercolumn, typedOther.column_or_supercolumn);
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    lastComparison = Boolean.valueOf(isSetDeletion()).compareTo(isSetDeletion());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    lastComparison = TBaseHelper.compareTo(deletion, typedOther.deletion);
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    return 0;
+  }
+
+  public void read(TProtocol iprot) throws TException {
+    TField field;
+    iprot.readStructBegin();
+    while (true)
+    {
+      field = iprot.readFieldBegin();
+      if (field.type == TType.STOP) { 
+        break;
+      }
+      switch (field.id)
+      {
+        case COLUMN_OR_SUPERCOLUMN:
+          if (field.type == TType.STRUCT) {
+            this.column_or_supercolumn = new ColumnOrSuperColumn();
+            this.column_or_supercolumn.read(iprot);
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        case DELETION:
+          if (field.type == TType.STRUCT) {
+            this.deletion = new Deletion();
+            this.deletion.read(iprot);
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        default:
+          TProtocolUtil.skip(iprot, field.type);
+          break;
+      }
+      iprot.readFieldEnd();
+    }
+    iprot.readStructEnd();
+
+
+    // check for required fields of primitive type, which can't be checked in the validate method
+    validate();
+  }
+
+  public void write(TProtocol oprot) throws TException {
+    validate();
+
+    oprot.writeStructBegin(STRUCT_DESC);
+    if (this.column_or_supercolumn != null) {
+      if (isSetColumn_or_supercolumn()) {
+        oprot.writeFieldBegin(COLUMN_OR_SUPERCOLUMN_FIELD_DESC);
+        this.column_or_supercolumn.write(oprot);
+        oprot.writeFieldEnd();
+      }
+    }
+    if (this.deletion != null) {
+      if (isSetDeletion()) {
+        oprot.writeFieldBegin(DELETION_FIELD_DESC);
+        this.deletion.write(oprot);
+        oprot.writeFieldEnd();
+      }
+    }
+    oprot.writeFieldStop();
+    oprot.writeStructEnd();
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("Mutation(");
+    boolean first = true;
+
+    if (isSetColumn_or_supercolumn()) {
+      sb.append("column_or_supercolumn:");
+      if (this.column_or_supercolumn == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.column_or_supercolumn);
+      }
+      first = false;
+    }
+    if (isSetDeletion()) {
+      if (!first) sb.append(", ");
+      sb.append("deletion:");
+      if (this.deletion == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.deletion);
+      }
+      first = false;
+    }
+    sb.append(")");
+    return sb.toString();
+  }
+
+  public void validate() throws TException {
+    // check for required fields
+    // check that fields of type enum have valid values
+  }
+
+}
+
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutation.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutation.java
index bec33221..1f372caa 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutation.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutation.java
@@ -163,11 +163,6 @@ public void delete(QueryPath path, long timestamp)
         assert path.columnFamilyName != null;
         String cfName = path.columnFamilyName;
 
-        if (modifications_.containsKey(cfName))
-        {
-            throw new IllegalArgumentException("ColumnFamily " + cfName + " is already being modified");
-        }
-
         int localDeleteTime = (int) (System.currentTimeMillis() / 1000);
 
         ColumnFamily columnFamily = modifications_.get(cfName);
@@ -230,6 +225,27 @@ public Message makeRowMutationMessage(String verbHandlerName) throws IOException
         return new Message(FBUtilities.getLocalAddress(), StageManager.mutationStage_, verbHandlerName, bos.toByteArray());
     }
 
+    public static RowMutation getRowMutationFromMutations(String keyspace, String key, Map<String, List<Mutation>> cfmap)
+    {
+        RowMutation rm = new RowMutation(keyspace, key.trim());
+        for (Map.Entry<String, List<Mutation>> entry : cfmap.entrySet())
+        {
+            String cfName = entry.getKey();
+            for (Mutation mutation : entry.getValue())
+            {
+                if (mutation.deletion != null)
+                {
+                    deleteColumnOrSuperColumnToRowMutation(rm, cfName, mutation.deletion);
+                }
+                else
+                {
+                    addColumnOrSuperColumnToRowMutation(rm, cfName, mutation.column_or_supercolumn);
+                }
+            }
+        }
+        return rm;
+    }
+    
     public static RowMutation getRowMutation(String table, String key, Map<String, List<ColumnOrSuperColumn>> cfmap)
     {
         RowMutation rm = new RowMutation(table, key.trim());
@@ -271,6 +287,36 @@ public String toString()
                ", modifications=[" + StringUtils.join(modifications_.values(), ", ") + "]" +
                ')';
     }
+
+    private static void addColumnOrSuperColumnToRowMutation(RowMutation rm, String cfName, ColumnOrSuperColumn cosc)
+    {
+        if (cosc.column == null)
+        {
+            for (org.apache.cassandra.service.Column column : cosc.super_column.columns)
+            {
+                rm.add(new QueryPath(cfName, cosc.super_column.name, column.name), column.value, column.timestamp);
+            }
+        }
+        else
+        {
+            rm.add(new QueryPath(cfName, null, cosc.column.name), cosc.column.value, cosc.column.timestamp);
+        }
+    }
+
+    private static void deleteColumnOrSuperColumnToRowMutation(RowMutation rm, String cfName, Deletion del)
+    {
+        if (del.predicate != null && del.predicate.column_names != null)
+        {
+            for(byte[] c : del.predicate.column_names)
+            {
+                rm.delete(new QueryPath(cfName, del.super_column, c), del.timestamp);
+            }
+        }
+        else
+        {
+            rm.delete(new QueryPath(cfName, del.super_column, null), del.timestamp);
+        }
+    }
 }
 
 class RowMutationSerializer implements ICompactSerializer<RowMutation>
@@ -323,4 +369,6 @@ public RowMutation deserialize(DataInputStream dis) throws IOException
         Map<String, ColumnFamily> modifications = defreezeTheMaps(dis);
         return new RowMutation(table, key, modifications);
     }
+
+  
 }
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/CassandraServer.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/CassandraServer.java
index ec00ee66..0dddbeba 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/CassandraServer.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/CassandraServer.java
@@ -21,11 +21,9 @@
 import java.io.BufferedInputStream;
 import java.io.FileInputStream;
 import java.io.IOException;
-import java.io.File;
 import java.util.*;
 
 import org.apache.log4j.Logger;
-import org.apache.log4j.PropertyConfigurator;
 
 import org.apache.commons.lang.ArrayUtils;
 
@@ -416,21 +414,45 @@ public void batch_insert(String keyspace, String key, Map<String, List<ColumnOrS
         {
             for (ColumnOrSuperColumn cosc : cfmap.get(cfName))
             {
-                if (cosc.column != null)
-                {
-                    ThriftValidation.validateColumnPath(keyspace, new ColumnPath(cfName, null, cosc.column.name));
+                ThriftValidation.validateColumnOrSuperColumn(keyspace, cfName, cosc);
+            }
+        }
+
+        doInsert(consistency_level, RowMutation.getRowMutation(keyspace, key, cfmap));
                 }
-                if (cosc.super_column != null)
+
+    public void batch_mutate(String keyspace, Map<String,Map<String,List<Mutation>>> mutation_map, int consistency_level)
+    throws InvalidRequestException, UnavailableException, TimedOutException
                 {
-                    for (Column c : cosc.super_column.columns)
+        if (logger.isDebugEnabled())
+            logger.debug("batch_mutate");
+        
+        List<RowMutation> rowMutations = new ArrayList<RowMutation>();
+        for (Map.Entry<String, Map<String, List<Mutation>>> mutationEntry: mutation_map.entrySet())
                     {
-                        ThriftValidation.validateColumnPath(keyspace, new ColumnPath(cfName, cosc.super_column.name, c.name));
+            String key = mutationEntry.getKey();
+
+            ThriftValidation.validateKey(key);
+            Map<String, List<Mutation>> columnFamilyToMutations = mutationEntry.getValue();
+            for (Map.Entry<String, List<Mutation>> columnFamilyMutations : columnFamilyToMutations.entrySet())
+            {
+                String cfName = columnFamilyMutations.getKey();
+
+                for (Mutation mutation : columnFamilyMutations.getValue())
+                {
+                    ThriftValidation.validateMutation(keyspace, cfName, mutation);
                     }
                 }
+            rowMutations.add(RowMutation.getRowMutationFromMutations(keyspace, key, columnFamilyToMutations));
             }
+        if (consistency_level == ConsistencyLevel.ZERO)
+        {
+            StorageProxy.mutate(rowMutations);
+        }
+        else
+        {
+            StorageProxy.mutateBlocking(rowMutations, consistency_level);
         }
-
-        doInsert(consistency_level, RowMutation.getRowMutation(keyspace, key, cfmap));
     }
 
     public void remove(String table, String key, ColumnPath column_path, long timestamp, int consistency_level)
@@ -451,11 +473,11 @@ private void doInsert(int consistency_level, RowMutation rm) throws UnavailableE
     {
         if (consistency_level != ConsistencyLevel.ZERO)
         {
-            StorageProxy.insertBlocking(rm, consistency_level);
+            StorageProxy.mutateBlocking(Arrays.asList(rm), consistency_level);
         }
         else
         {
-            StorageProxy.insert(rm);
+            StorageProxy.mutate(Arrays.asList(rm));
         }
     }
 
@@ -543,10 +565,9 @@ else if (propertyName.equals("version"))
     {
         if (logger.isDebugEnabled())
             logger.debug("range_slice");
-        if (predicate.getSlice_range() != null)
-            ThriftValidation.validateRange(keyspace, column_parent, predicate.getSlice_range());
-        else
-            ThriftValidation.validateColumns(keyspace, column_parent, predicate.getColumn_names());
+
+        validatePredicate(keyspace, column_parent, predicate);
+
         if (!StorageService.getPartitioner().preservesOrder())
         {
             throw new InvalidRequestException("range queries may only be performed against an order-preserving partitioner");
@@ -618,5 +639,13 @@ else if (col instanceof org.apache.cassandra.db.SuperColumn)
         }
     }
 
+    private void validatePredicate(String keyspace, ColumnParent column_parent, SlicePredicate predicate) throws InvalidRequestException
+    {
+        if (predicate.getSlice_range() != null)
+            ThriftValidation.validateRange(keyspace, column_parent, predicate.getSlice_range());
+        else
+            ThriftValidation.validateColumns(keyspace, column_parent, predicate.getColumn_names());
+
+    }
     // main method moved to CassandraDaemon
 }
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/StorageProxy.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/StorageProxy.java
index 3a7c74ec..5f46c3c3 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/StorageProxy.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/StorageProxy.java
@@ -85,19 +85,23 @@ public int compare(String o1, String o2)
     };
 
     /**
-     * Use this method to have this RowMutation applied
+     * Use this method to have these RowMutations applied
      * across all replicas. This method will take care
      * of the possibility of a replica being down and hint
      * the data across to some other replica.
      *
      * This is the ZERO consistency level. We do not wait for replies.
      *
-     * @param rm the mutation to be applied across the replicas
+     * @param mutations the mutations to be applied across the replicas
     */
-    public static void insert(final RowMutation rm)
+    public static void mutate(List<RowMutation> mutations)
     {
         long startTime = System.currentTimeMillis();
         try
+        {
+            for (final RowMutation rm: mutations)
+            {
+                try
         {
             List<InetAddress> naturalEndpoints = StorageService.instance().getNaturalEndpoints(rm.key());
             Map<InetAddress, InetAddress> endpointMap = StorageService.instance().getHintedEndpointMap(rm.key(), naturalEndpoints);
@@ -155,6 +159,8 @@ public void run()
         catch (IOException e)
         {
             throw new RuntimeException("error inserting key " + rm.key(), e);
+        }
+            }
         }
         finally
         {
@@ -162,98 +168,125 @@ public void run()
         }
     }
     
-    public static void insertBlocking(final RowMutation rm, int consistency_level) throws UnavailableException, TimedOutException
+    public static void mutateBlocking(List<RowMutation> mutations, int consistency_level) throws UnavailableException, TimedOutException
     {
         long startTime = System.currentTimeMillis();
+        ArrayList<WriteResponseHandler> responseHandlers = new ArrayList<WriteResponseHandler>();
+
+        RowMutation mostRecentRowMutation = null;
         try
         {
+            for (RowMutation rm: mutations)
+            {
+                mostRecentRowMutation = rm;
             List<InetAddress> naturalEndpoints = StorageService.instance().getNaturalEndpoints(rm.key());
             Map<InetAddress, InetAddress> endpointMap = StorageService.instance().getHintedEndpointMap(rm.key(), naturalEndpoints);
             int blockFor = determineBlockFor(naturalEndpoints.size(), endpointMap.size(), consistency_level);
 
             // avoid starting a write we know can't achieve the required consistency
-            int liveNodes = 0;
-            for (Map.Entry<InetAddress, InetAddress> entry : endpointMap.entrySet())
-            {
-                if (entry.getKey().equals(entry.getValue()))
-                {
-                    liveNodes++;
-                }
-            }
-            if (liveNodes < blockFor)
-            {
-                throw new UnavailableException();
-            }
+                assureSufficientLiveNodes(endpointMap, blockFor);
 
             // send out the writes, as in insert() above, but this time with a callback that tracks responses
             final WriteResponseHandler responseHandler = StorageService.instance().getWriteResponseHandler(blockFor, consistency_level);
+                responseHandlers.add(responseHandler);
             Message unhintedMessage = null;
             for (Map.Entry<InetAddress, InetAddress> entry : endpointMap.entrySet())
             {
-                InetAddress target = entry.getKey();
-                InetAddress hintedTarget = entry.getValue();
+                    InetAddress naturalTarget = entry.getKey();
+                    InetAddress maybeHintedTarget = entry.getValue();
 
-                if (target.equals(hintedTarget))
+                    if (naturalTarget.equals(maybeHintedTarget))
                 {
-                    if (target.equals(FBUtilities.getLocalAddress()))
+                        // not hinted
+                        if (naturalTarget.equals(FBUtilities.getLocalAddress()))
                     {
-                        if (logger.isDebugEnabled())
-                            logger.debug("insert writing local key " + rm.key());
-                        Runnable runnable = new Runnable()
-                        {
-                            public void run()
-                            {
-                                try
-                                {
-                                    rm.apply();
-                                    responseHandler.localResponse();
-                                }
-                                catch (IOException e)
-                                {
-                                    throw new IOError(e);
-                                }
-                            }
-                        };
-                        StageManager.getStage(StageManager.mutationStage_).execute(runnable);
+                            insertLocalMessage(rm, responseHandler);
                     }
                     else
                     {
+                            // belongs on a different server.  send it there.
                         if (unhintedMessage == null)
                         {
                             unhintedMessage = rm.makeRowMutationMessage();
                             MessagingService.instance().addCallback(responseHandler, unhintedMessage.getMessageId());
                         }
                         if (logger.isDebugEnabled())
-                            logger.debug("insert writing key " + rm.key() + " to " + unhintedMessage.getMessageId() + "@" + target);
-                        MessagingService.instance().sendOneWay(unhintedMessage, target);
+                                logger.debug("insert writing key " + rm.key() + " to " + unhintedMessage.getMessageId() + "@" + naturalTarget);
+                            MessagingService.instance().sendOneWay(unhintedMessage, naturalTarget);
                     }
                 }
                 else
                 {
                     // (hints aren't part of the callback since they don't count towards consistency until they are on the final destination node)
                     Message hintedMessage = rm.makeRowMutationMessage();
-                    hintedMessage.addHeader(RowMutation.HINT, target.getAddress());
+                        hintedMessage.addHeader(RowMutation.HINT, naturalTarget.getAddress());
                     if (logger.isDebugEnabled())
-                        logger.debug("insert writing key " + rm.key() + " to " + hintedMessage.getMessageId() + "@" + hintedTarget + " for " + target);
-                    MessagingService.instance().sendOneWay(hintedMessage, hintedTarget);
+                            logger.debug("insert writing key " + rm.key() + " to " + hintedMessage.getMessageId() + "@" + maybeHintedTarget + " for " + naturalTarget);
+                        MessagingService.instance().sendOneWay(hintedMessage, maybeHintedTarget);
+                    }
                 }
             }
-
             // wait for writes.  throws timeoutexception if necessary
+            for( WriteResponseHandler responseHandler : responseHandlers )
+            {
             responseHandler.get();
         }
-        catch (TimeoutException e)
-        {
-            throw new TimedOutException();
         }
         catch (IOException e)
         {
-            throw new RuntimeException("error writing key " + rm.key(), e);
+            if (mostRecentRowMutation == null)
+                throw new RuntimeException("no mutations were seen but found an error during write anyway", e);
+            else
+                throw new RuntimeException("error writing key " + mostRecentRowMutation.key(), e);
+        }
+        catch (TimeoutException e)
+        {
+            throw new TimedOutException();
         }
         finally
         {
             writeStats.add(System.currentTimeMillis() - startTime);
         }
+
+    }
+
+    private static void assureSufficientLiveNodes(Map<InetAddress, InetAddress> endpointMap, int blockFor)
+            throws UnavailableException
+    {
+        int liveNodes = 0;
+        for (Map.Entry<InetAddress, InetAddress> entry : endpointMap.entrySet())
+        {
+            if (entry.getKey().equals(entry.getValue()))
+            {
+                liveNodes++;
+            }
+        }
+        if (liveNodes < blockFor)
+        {
+            throw new UnavailableException();
+        }
+    }
+
+    private static void insertLocalMessage(final RowMutation rm, final WriteResponseHandler responseHandler)
+    {
+        if (logger.isDebugEnabled())
+            logger.debug("insert writing local key " + rm.key());
+        Runnable runnable = new Runnable()
+        {
+            public void run()
+            {
+                try
+                {
+                    rm.apply();
+                    responseHandler.localResponse();
+                }
+                catch (IOException e)
+                {
+                    throw new IOError(e);
+                }
+            }
+        };
+        StageManager.getStage(StageManager.mutationStage_).execute(runnable);
     }
 
     private static int determineBlockFor(int naturalTargets, int hintedTargets, int consistency_level)
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/ThriftValidation.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/ThriftValidation.java
index 234a19f4..e4486f18 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/ThriftValidation.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/service/ThriftValidation.java
@@ -205,4 +205,79 @@ public static void validateRange(String keyspace, ColumnParent column_parent, Sl
             throw new InvalidRequestException("range finish must come after start in the order of traversal");
         }
     }
+
+    public static void validateColumnOrSuperColumn(String keyspace, String cfName, ColumnOrSuperColumn cosc)
+            throws InvalidRequestException
+    {
+        if (cosc.column != null)
+        {
+            ThriftValidation.validateColumnPath(keyspace, new ColumnPath(cfName, null, cosc.column.name));
+        }
+
+        if (cosc.super_column != null)
+        {
+            for (Column c : cosc.super_column.columns)
+            {
+                ThriftValidation.validateColumnPath(keyspace, new ColumnPath(cfName, cosc.super_column.name, c.name));
+            }
+        }
+
+        if (cosc.column == null && cosc.super_column == null) {
+            throw new InvalidRequestException("ColumnOrSuperColumn must have one or both of Column or SuperColumn");
+        }
+    }
+
+    public static void validateMutation(String keyspace, String cfName, Mutation mut)
+            throws InvalidRequestException
+    {
+        ColumnOrSuperColumn cosc = mut.column_or_supercolumn;
+        Deletion del = mut.deletion;
+
+        if (cosc != null && del != null) {
+            throw new InvalidRequestException("Mutation may have either a ColumnOrSuperColumn or a Deletion, but not both");
+        }
+
+        if (cosc != null)
+        {
+            ThriftValidation.validateColumnOrSuperColumn(keyspace, cfName, cosc);
+        }
+        else if (del != null)
+        {
+            ThriftValidation.validateDeletion(keyspace, cfName, del);
+        }
+        else
+        {
+            throw new InvalidRequestException("Mutation must have one ColumnOrSuperColumn or one Deletion");
+        }
+    }
+
+    public static void validateDeletion(String keyspace, String cfName, Deletion del) throws InvalidRequestException
+    {
+        if (del.super_column == null && del.predicate == null)
+        {
+            throw new InvalidRequestException("A Deletion must have a SuperColumn, a SlicePredicate or both.");
+        }
+
+        if (del.predicate != null)
+        {
+            validateSlicePredicate(keyspace, cfName, del.super_column, del.predicate);
+            if (del.predicate.slice_range != null)
+                throw new InvalidRequestException("Deletion does not yet work correctly with SliceRanges.");
+        }
+    }
+
+    public static void validateSlicePredicate(String keyspace, String cfName, byte[] scName, SlicePredicate predicate) throws InvalidRequestException
+    {
+        if (predicate.column_names == null && predicate.slice_range == null) {
+            throw new InvalidRequestException("A SlicePredicate must be given a list of Columns, a SliceRange, or both");
+        }
+
+        if (predicate.slice_range != null) {
+            validateRange(keyspace, new ColumnParent(cfName, scName), predicate.slice_range);
+        }
+
+        if (predicate.column_names != null) {
+            validateColumns(keyspace, cfName, scName, predicate.column_names);
+        }
+    }
 }
