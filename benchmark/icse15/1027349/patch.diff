diff --git a/cassandra/branches/cassandra-0.7/contrib/client_only/ClientOnlyExample.java b/cassandra/branches/cassandra-0.7/contrib/client_only/ClientOnlyExample.java
index c25f3e25..a221ac5b 100644
--- a/cassandra/branches/cassandra-0.7/contrib/client_only/ClientOnlyExample.java
+++ b/cassandra/branches/cassandra-0.7/contrib/client_only/ClientOnlyExample.java
@@ -80,7 +80,7 @@ private static void testReading() throws Exception
         // do some queries.
         Collection<ByteBuffer> cols = new ArrayList<ByteBuffer>()
         {{
-            add(ByteBuffer.wrap("colb".getBytes()));
+            add(ByteBufferUtil.bytes("colb"));
         }};
         for (int i = 0; i < 100; i++)
         {
@@ -97,7 +97,7 @@ private static void testReading() throws Exception
             {
                 for (IColumn col : cf.getSortedColumns())
                 {
-                    System.out.println(ByteBufferUtil.string(col.name(), Charsets.UTF_8) + ", " + ByteBufferUtil.string(col.value(), Charsets.UTF_8));
+                    System.out.println(ByteBufferUtil.string(col.name()) + ", " + ByteBufferUtil.string(col.value()));
                 }
             }
             else
diff --git a/cassandra/branches/cassandra-0.7/contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java b/cassandra/branches/cassandra-0.7/contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
index 5e6d05cb..5a7302ad 100644
--- a/cassandra/branches/cassandra-0.7/contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
+++ b/cassandra/branches/cassandra-0.7/contrib/pig/src/java/org/apache/cassandra/hadoop/pig/CassandraStorage.java
@@ -17,6 +17,7 @@
 package org.apache.cassandra.hadoop.pig;
 
 import java.io.IOException;
+import java.nio.ByteBuffer;
 import java.util.*;
 
 import org.apache.cassandra.db.Column;
@@ -25,6 +26,7 @@
 import org.apache.cassandra.hadoop.*;
 import org.apache.cassandra.thrift.SlicePredicate;
 import org.apache.cassandra.thrift.SliceRange;
+import org.apache.cassandra.utils.FBUtilities;
 
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.Path;
@@ -52,7 +54,7 @@
     public final static String PIG_INITIAL_ADDRESS = "PIG_INITIAL_ADDRESS";
     public final static String PIG_PARTITIONER = "PIG_PARTITIONER";
 
-    private final static byte[] BOUND = new byte[0];
+    private final static ByteBuffer BOUND = FBUtilities.EMPTY_BYTE_BUFFER;
     private final static int LIMIT = 1024;
 
     private Configuration conf;
@@ -75,7 +77,11 @@ public Tuple getNext() throws IOException
             ArrayList<Tuple> columns = new ArrayList<Tuple>();
             tuple.set(0, new DataByteArray(key));
             for (Map.Entry<byte[], IColumn> entry : cf.entrySet())
-                columns.add(columnToTuple(entry.getKey(), entry.getValue()));
+            {                    
+                byte[] name = entry.getKey();
+                columns.add(columnToTuple(name, 0, name.length, entry.getValue()));
+            }
+         
             tuple.set(1, new DefaultDataBag(columns));
             return tuple;
         }
@@ -85,21 +91,26 @@ public Tuple getNext() throws IOException
         }
     }
 
-    private Tuple columnToTuple(byte[] name, IColumn col) throws IOException
+    private Tuple columnToTuple(byte[] name, int nameOffset, int nameLength, IColumn col) throws IOException
     {
         Tuple pair = TupleFactory.getInstance().newTuple(2);
-        pair.set(0, new DataByteArray(name));
+        pair.set(0, new DataByteArray(name, nameOffset, nameLength));
         if (col instanceof Column)
         {
             // standard
-            pair.set(1, new DataByteArray(col.value()));
+            pair.set(1, new DataByteArray(col.value().array(), 
+                                          col.value().position()+col.value().arrayOffset(),
+                                          col.value().remaining()));
             return pair;
         }
 
         // super
         ArrayList<Tuple> subcols = new ArrayList<Tuple>();
         for (IColumn subcol : ((SuperColumn)col).getSubColumns())
-            subcols.add(columnToTuple(subcol.name(), subcol));
+            subcols.add(columnToTuple(subcol.name().array(), 
+                                      subcol.name().position()+subcol.name().arrayOffset(),
+                                      subcol.name().remaining(), subcol));
+        
         pair.set(1, new DefaultDataBag(subcols));
         return pair;
     }
diff --git a/cassandra/branches/cassandra-0.7/contrib/word_count/src/WordCount.java b/cassandra/branches/cassandra-0.7/contrib/word_count/src/WordCount.java
index 32262aff..bcd8696c 100644
--- a/cassandra/branches/cassandra-0.7/contrib/word_count/src/WordCount.java
+++ b/cassandra/branches/cassandra-0.7/contrib/word_count/src/WordCount.java
@@ -81,7 +81,7 @@ public void map(byte[] key, SortedMap<byte[], IColumn> columns, Context context)
             IColumn column = columns.get(columnName.getBytes());
             if (column == null)
                 return;
-            String value = ByteBufferUtil.string(column.value(), Charsets.UTF_8);
+            String value = ByteBufferUtil.string(column.value());
             logger.debug("read " + key + ":" + value + " from " + context.getInputSplit());
 
             StringTokenizer itr = new StringTokenizer(value);
diff --git a/cassandra/branches/cassandra-0.7/contrib/word_count/src/WordCountSetup.java b/cassandra/branches/cassandra-0.7/contrib/word_count/src/WordCountSetup.java
index a83c17ec..9f686991 100644
--- a/cassandra/branches/cassandra-0.7/contrib/word_count/src/WordCountSetup.java
+++ b/cassandra/branches/cassandra-0.7/contrib/word_count/src/WordCountSetup.java
@@ -16,9 +16,11 @@
  * limitations under the License.
  */
 
+import java.nio.ByteBuffer;
 import java.util.*;
 
 import org.apache.cassandra.thrift.*;
+import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.thrift.TException;
 import org.apache.thrift.protocol.TBinaryProtocol;
 import org.apache.thrift.protocol.TProtocol;
@@ -43,29 +45,29 @@ public static void main(String[] args) throws Exception
 
         client.set_keyspace(WordCount.KEYSPACE);
 
-        Map<byte[], Map<String,List<Mutation>>> mutationMap;
+        Map<ByteBuffer, Map<String,List<Mutation>>> mutationMap;
         Column c;
 
         // text0: no rows
 
         // text1: 1 row, 1 word
-        c = new Column("text1".getBytes(), "word1".getBytes(), System.currentTimeMillis());
-        mutationMap = getMutationMap("key0".getBytes(), WordCount.COLUMN_FAMILY, c);
+        c = new Column(ByteBufferUtil.bytes("text1"), ByteBufferUtil.bytes("word1"), System.currentTimeMillis());
+        mutationMap = getMutationMap(ByteBufferUtil.bytes("key0"), WordCount.COLUMN_FAMILY, c);
         client.batch_mutate(mutationMap, ConsistencyLevel.ONE);
         logger.info("added text1");
 
         // text1: 1 row, 2 word
-        c = new Column("text2".getBytes(), "word1 word2".getBytes(), System.currentTimeMillis());
-        mutationMap = getMutationMap("key0".getBytes(), WordCount.COLUMN_FAMILY, c);
+        c = new Column(ByteBufferUtil.bytes("text2"), ByteBufferUtil.bytes("word1 word2"), System.currentTimeMillis());
+        mutationMap = getMutationMap(ByteBufferUtil.bytes("key0"), WordCount.COLUMN_FAMILY, c);
         client.batch_mutate(mutationMap, ConsistencyLevel.ONE);
         logger.info("added text2");
 
         // text3: 1000 rows, 1 word
-        mutationMap = new HashMap<byte[],Map<String,List<Mutation>>>();
+        mutationMap = new HashMap<ByteBuffer,Map<String,List<Mutation>>>();
         for (int i=0; i<1000; i++)
         {
-            c = new Column("text3".getBytes(), "word1".getBytes(), System.currentTimeMillis());
-            addToMutationMap(mutationMap, ("key" + i).getBytes(), WordCount.COLUMN_FAMILY, c);
+            c = new Column(ByteBufferUtil.bytes("text3"), ByteBufferUtil.bytes("word1"), System.currentTimeMillis());
+            addToMutationMap(mutationMap, ByteBufferUtil.bytes("key" + i), WordCount.COLUMN_FAMILY, c);
         }
         client.batch_mutate(mutationMap, ConsistencyLevel.ONE);
         logger.info("added text3");
@@ -73,14 +75,14 @@ public static void main(String[] args) throws Exception
         System.exit(0);
     }
 
-    private static Map<byte[],Map<String,List<Mutation>>> getMutationMap(byte[] key, String cf, Column c)
+    private static Map<ByteBuffer,Map<String,List<Mutation>>> getMutationMap(ByteBuffer key, String cf, Column c)
     {
-        Map<byte[],Map<String,List<Mutation>>> mutationMap = new HashMap<byte[],Map<String,List<Mutation>>>();
+        Map<ByteBuffer,Map<String,List<Mutation>>> mutationMap = new HashMap<ByteBuffer,Map<String,List<Mutation>>>();
         addToMutationMap(mutationMap, key, cf, c);
         return mutationMap;
     }
 
-    private static void addToMutationMap(Map<byte[],Map<String,List<Mutation>>> mutationMap, byte[] key, String cf, Column c)
+    private static void addToMutationMap(Map<ByteBuffer,Map<String,List<Mutation>>> mutationMap, ByteBuffer key, String cf, Column c)
     {
         Map<String,List<Mutation>> cfMutation = new HashMap<String,List<Mutation>>();
         List<Mutation> mList = new ArrayList<Mutation>();
diff --git a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/DefsTable.java b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/DefsTable.java
index ed8950b3..f5a09b13 100644
--- a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/DefsTable.java
+++ b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/DefsTable.java
@@ -40,12 +40,13 @@
 import org.apache.cassandra.io.SerDeUtils;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.UUIDGen;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 public class DefsTable
 {
     // column name for the schema storing serialized keyspace definitions
     // NB: must be an invalid keyspace name
-    public static final ByteBuffer DEFINITION_SCHEMA_COLUMN_NAME = ByteBuffer.wrap("Avro/Schema".getBytes(UTF_8));
+    public static final ByteBuffer DEFINITION_SCHEMA_COLUMN_NAME = ByteBufferUtil.bytes("Avro/Schema");
 
     /** dumps current keyspace definitions to storage */
     public static synchronized void dumpToStorage(UUID version) throws IOException
diff --git a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/HintedHandOffManager.java b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/HintedHandOffManager.java
index f6eab367..5c2cc621 100644
--- a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/HintedHandOffManager.java
+++ b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/HintedHandOffManager.java
@@ -180,7 +180,7 @@ public static ByteBuffer makeCombinedName(String tableName, String columnFamily)
             throw new RuntimeException("Corrupted hint name " + joined.toString());
         String[] parts = new String[2];
         parts[0] = new String(ArrayUtils.subarray(joined.array(), joined.position()+joined.arrayOffset(), index));
-        parts[1] = new String(ArrayUtils.subarray(joined.array(), index+1, joined.limit()));
+        parts[1] = new String(ArrayUtils.subarray(joined.array(), index+1, joined.limit()+joined.arrayOffset()));
         return parts;
 
     }
diff --git a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/SystemTable.java b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/SystemTable.java
index db2862b9..090ce528 100644
--- a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/SystemTable.java
+++ b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/SystemTable.java
@@ -51,15 +51,15 @@
     private static Logger logger = LoggerFactory.getLogger(SystemTable.class);
     public static final String STATUS_CF = "LocationInfo"; // keep the old CF string for backwards-compatibility
     public static final String INDEX_CF = "IndexInfo";
-    private static final ByteBuffer LOCATION_KEY = ByteBuffer.wrap("L".getBytes(UTF_8));
-    private static final ByteBuffer RING_KEY = ByteBuffer.wrap("Ring".getBytes(UTF_8));
-    private static final ByteBuffer BOOTSTRAP_KEY = ByteBuffer.wrap("Bootstrap".getBytes(UTF_8));
-    private static final ByteBuffer COOKIE_KEY = ByteBuffer.wrap("Cookies".getBytes(UTF_8));
-    private static final ByteBuffer BOOTSTRAP = ByteBuffer.wrap("B".getBytes(UTF_8));
-    private static final ByteBuffer TOKEN = ByteBuffer.wrap("Token".getBytes(UTF_8));
-    private static final ByteBuffer GENERATION = ByteBuffer.wrap("Generation".getBytes(UTF_8));
-    private static final ByteBuffer CLUSTERNAME = ByteBuffer.wrap("ClusterName".getBytes(UTF_8));
-    private static final ByteBuffer PARTITIONER = ByteBuffer.wrap("Partioner".getBytes(UTF_8));
+    private static final ByteBuffer LOCATION_KEY = ByteBufferUtil.bytes("L");
+    private static final ByteBuffer RING_KEY = ByteBufferUtil.bytes("Ring");
+    private static final ByteBuffer BOOTSTRAP_KEY = ByteBufferUtil.bytes("Bootstrap");
+    private static final ByteBuffer COOKIE_KEY = ByteBufferUtil.bytes("Cookies");
+    private static final ByteBuffer BOOTSTRAP = ByteBufferUtil.bytes("B");
+    private static final ByteBuffer TOKEN = ByteBufferUtil.bytes("Token");
+    private static final ByteBuffer GENERATION = ByteBufferUtil.bytes("Generation");
+    private static final ByteBuffer CLUSTERNAME = ByteBufferUtil.bytes("ClusterName");
+    private static final ByteBuffer PARTITIONER = ByteBufferUtil.bytes("Partioner");
 
     private static DecoratedKey decorate(ByteBuffer key)
     {
@@ -70,7 +70,7 @@ private static DecoratedKey decorate(ByteBuffer key)
     public static void purgeIncompatibleHints() throws IOException
     {
         // 0.6->0.7
-        final ByteBuffer hintsPurged6to7 = ByteBuffer.wrap("Hints purged as part of upgrading from 0.6.x to 0.7".getBytes());
+        final ByteBuffer hintsPurged6to7 = ByteBufferUtil.bytes("Hints purged as part of upgrading from 0.6.x to 0.7");
         Table table = Table.open(Table.SYSTEM_TABLE);
         QueryFilter dotSeven = QueryFilter.getNamesFilter(decorate(COOKIE_KEY), new QueryPath(STATUS_CF), hintsPurged6to7);
         ColumnFamily cf = table.getColumnFamilyStore(STATUS_CF).getColumnFamily(dotSeven);
@@ -80,7 +80,7 @@ public static void purgeIncompatibleHints() throws IOException
             logger.info("Upgrading to 0.7. Purging hints if there are any. Old hints will be snapshotted.");
             new Truncation(Table.SYSTEM_TABLE, HintedHandOffManager.HINTS_CF).apply();
             RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, COOKIE_KEY);
-            rm.add(new QueryPath(STATUS_CF, null, hintsPurged6to7), ByteBuffer.wrap("oh yes, it they were purged.".getBytes()), System.currentTimeMillis());
+            rm.add(new QueryPath(STATUS_CF, null, hintsPurged6to7), ByteBufferUtil.bytes("oh yes, it they were purged."), System.currentTimeMillis());
             rm.apply();
         }
     }
diff --git a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/migration/Migration.java b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/migration/Migration.java
index abe73999..d9c2491d 100644
--- a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/migration/Migration.java
+++ b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/db/migration/Migration.java
@@ -44,6 +44,7 @@
 import org.apache.cassandra.service.MigrationManager;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.UUIDGen;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 import static com.google.common.base.Charsets.UTF_8;
 
@@ -71,8 +72,8 @@
     public static final String NAME_VALIDATOR_REGEX = "\\w+";
     public static final String MIGRATIONS_CF = "Migrations";
     public static final String SCHEMA_CF = "Schema";
-    public static final ByteBuffer MIGRATIONS_KEY = ByteBuffer.wrap("Migrations Key".getBytes(UTF_8));
-    public static final ByteBuffer LAST_MIGRATION_KEY = ByteBuffer.wrap("Last Migration".getBytes(UTF_8));
+    public static final ByteBuffer MIGRATIONS_KEY = ByteBufferUtil.bytes("Migrations Key");
+    public static final ByteBuffer LAST_MIGRATION_KEY = ByteBufferUtil.bytes("Last Migration");
     
     protected RowMutation rm;
     protected UUID newVersion;
diff --git a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/dht/RandomPartitioner.java b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/dht/RandomPartitioner.java
index 3809ca70..18079470 100644
--- a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/dht/RandomPartitioner.java
+++ b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/dht/RandomPartitioner.java
@@ -49,7 +49,7 @@
     {
         // find the delimiter position
         int splitPoint = -1;
-        for (int i = fromdisk.position()+fromdisk.arrayOffset(); i < fromdisk.limit(); i++)
+        for (int i = fromdisk.position()+fromdisk.arrayOffset(); i < fromdisk.limit()+fromdisk.arrayOffset(); i++)
         {
             if (fromdisk.array()[i] == DELIMITER_BYTE)
             {
@@ -61,7 +61,7 @@
 
         // and decode the token and key
         String token = new String(fromdisk.array(), fromdisk.position()+fromdisk.arrayOffset(), splitPoint, UTF_8);
-        byte[] key = Arrays.copyOfRange(fromdisk.array(), splitPoint + 1, fromdisk.limit());
+        byte[] key = Arrays.copyOfRange(fromdisk.array(), splitPoint + 1, fromdisk.limit()+fromdisk.arrayOffset());
         return new DecoratedKey<BigIntegerToken>(new BigIntegerToken(token), ByteBuffer.wrap(key));
     }
 
diff --git a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/dht/Range.java b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/dht/Range.java
index f138c7bb..d1f467b3 100644
--- a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/dht/Range.java
+++ b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/dht/Range.java
@@ -230,7 +230,7 @@ else if(left.token instanceof ByteBuffer)
         {
             l  = ((ByteBuffer)left.token).array();
             lo = ((ByteBuffer)left.token).position()+((ByteBuffer)left.token).arrayOffset();
-            ll = ((ByteBuffer)left.token).limit();
+            ll = ((ByteBuffer)left.token).limit()+((ByteBuffer)left.token).arrayOffset();
         }else{
             //Handles other token types
             return left.compareTo(right);
@@ -246,7 +246,7 @@ else if(left.token instanceof ByteBuffer)
         {
             r  = ((ByteBuffer)right.token).array();
             ro = ((ByteBuffer)right.token).position()+((ByteBuffer)right.token).arrayOffset();
-            rl = ((ByteBuffer)right.token).limit();
+            rl = ((ByteBuffer)right.token).limit()+((ByteBuffer)right.token).arrayOffset();
         }
        
             
diff --git a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/net/OutboundTcpConnection.java b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/net/OutboundTcpConnection.java
index db7dddde..48f6b4d0 100644
--- a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/net/OutboundTcpConnection.java
+++ b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/net/OutboundTcpConnection.java
@@ -104,7 +104,7 @@ private void writeConnected(ByteBuffer bb)
     {
         try
         {
-            output.write(bb.array(), 0, bb.limit());
+            output.write(bb.array(), bb.position()+bb.arrayOffset(), bb.limit()+bb.arrayOffset());
             if (queue.peek() == null)
             {
                 output.flush();
diff --git a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/utils/ByteBufferUtil.java b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/utils/ByteBufferUtil.java
index b6cf98a5..a96a3300 100644
--- a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/utils/ByteBufferUtil.java
+++ b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/utils/ByteBufferUtil.java
@@ -18,28 +18,63 @@
  */
 package org.apache.cassandra.utils;
 
+import java.io.UnsupportedEncodingException;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
 
 /**
  * Utility methods to make ByteBuffers less painful
+ * The following should illustrate the different ways byte buffers can be used 
+ * 
+ *        public void testArrayOffet()
+ *        {
+ *                
+ *            byte[] b = "test_slice_array".getBytes();
+ *            ByteBuffer bb = ByteBuffer.allocate(1024);
+ *    
+ *            assert bb.position() == 0;
+ *            assert bb.limit()    == 1024;
+ *            assert bb.capacity() == 1024;
+ *    
+ *            bb.put(b);
+ *            
+ *            assert bb.position()  == b.length;
+ *            assert bb.remaining() == bb.limit() - bb.position();
+ *            
+ *            ByteBuffer bb2 = bb.slice();
+ *            
+ *            assert bb2.position()    == 0;
+ *            
+ *            //slice should begin at other buffers current position
+ *            assert bb2.arrayOffset() == bb.position();
+ *            
+ *            //to match the position in the underlying array one needs to 
+ *            //track arrayOffset
+ *            assert bb2.limit()+bb2.arrayOffset() == bb.limit();
+ *            
+ *           
+ *            assert bb2.remaining() == bb.remaining();
+ *                             
+ *        }
+ *
+ * }
  *
  */
 public class ByteBufferUtil {
 
     public static int compareUnsigned(ByteBuffer o1, ByteBuffer o2)
     {
-        return FBUtilities.compareUnsigned(o1.array(), o2.array(), o1.arrayOffset()+o1.position(), o2.arrayOffset()+o2.position(), o1.limit(), o2.limit());
+        return FBUtilities.compareUnsigned(o1.array(), o2.array(), o1.arrayOffset()+o1.position(), o2.arrayOffset()+o2.position(), o1.limit()+o1.arrayOffset(), o2.limit()+o2.arrayOffset());
     }
     
     public static int compare(byte[] o1, ByteBuffer o2)
     {
-        return FBUtilities.compareUnsigned(o1, o2.array(), 0, o2.arrayOffset()+o2.position(), o1.length, o2.limit());
+        return FBUtilities.compareUnsigned(o1, o2.array(), 0, o2.arrayOffset()+o2.position(), o1.length, o2.limit()+o2.arrayOffset());
     }
 
     public static int compare(ByteBuffer o1, byte[] o2)
     {
-        return FBUtilities.compareUnsigned(o1.array(), o2, o1.arrayOffset()+o1.position(), 0, o1.limit(), o2.length);
+        return FBUtilities.compareUnsigned(o1.array(), o2, o1.arrayOffset()+o1.position(), 0, o1.limit()+o1.arrayOffset(), o2.length);
     }
 
     public static String string(ByteBuffer b, Charset charset)
@@ -51,4 +86,16 @@ public static String string(ByteBuffer b)
     {
         return new String(b.array(), b.arrayOffset() + b.position(), b.remaining());
     }
+    
+    public static ByteBuffer bytes(String s) 
+    { 
+        try
+        {
+            return ByteBuffer.wrap(s.getBytes("UTF-8"));
+        }
+        catch (UnsupportedEncodingException e)
+        {
+           throw new RuntimeException(e);
+        } 
+    }
 }
diff --git a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/utils/FBUtilities.java b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/utils/FBUtilities.java
index 00ae49e2..ba8e1710 100644
--- a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/utils/FBUtilities.java
+++ b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/utils/FBUtilities.java
@@ -67,14 +67,6 @@
 
     public static final int MAX_UNSIGNED_SHORT = 0xFFFF;
 
-    /*public static final Comparator<byte[]> byteArrayComparator = new Comparator<byte[]>()
-    {
-        public int compare(byte[] o1, byte[] o2)
-        {
-            return compareByteArrays(o1, o2);
-        }
-    };*/
-
     /**
      * Parses a string representing either a fraction, absolute value or percentage.
      */
@@ -264,12 +256,13 @@ public static ByteBuffer readByteArray(DataInput in) throws IOException
         {
             throw new IOException("Corrupt (negative) value length encountered");
         }
-        byte[] value = new byte[length];
+       
+        ByteBuffer bb = ByteBuffer.allocate(length);
         if (length > 0)
         {
-            in.readFully(value);
+            in.readFully(bb.array(),bb.position(),bb.remaining());
         }
-        return ByteBuffer.wrap(value);
+        return bb;
     }
 
     public static void writeShortByteArray(ByteBuffer name, DataOutput out)
@@ -299,9 +292,10 @@ private static int readShortLength(DataInput in) throws IOException
 
     public static ByteBuffer readShortByteArray(DataInput in) throws IOException
     {
-        byte[] bytes = new byte[readShortLength(in)];
-        in.readFully(bytes);
-        return ByteBuffer.wrap(bytes);
+        int length = readShortLength(in);
+        ByteBuffer bb = ByteBuffer.allocate(length);
+        in.readFully(bb.array(),bb.position(),bb.remaining());
+        return bb;
     }
 
     /** @return null */
@@ -346,7 +340,7 @@ public static String bytesToHex(byte... bytes)
     public static String bytesToHex(ByteBuffer bytes)
     {
         StringBuilder sb = new StringBuilder();
-        for (int i=bytes.position()+bytes.arrayOffset(); i<bytes.limit(); i++)
+        for (int i=bytes.position()+bytes.arrayOffset(); i<bytes.limit()+bytes.arrayOffset(); i++)
         {
             int bint = bytes.array()[i] & 0xff;
             if (bint <= 0xF)
diff --git a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/utils/GuidGenerator.java b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/utils/GuidGenerator.java
index 95275629..a6a35ac2 100644
--- a/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/utils/GuidGenerator.java
+++ b/cassandra/branches/cassandra-0.7/src/java/org/apache/cassandra/utils/GuidGenerator.java
@@ -64,7 +64,7 @@ public static String guid() {
         ByteBuffer array = guidAsBytes();
         
         StringBuilder sb = new StringBuilder();
-        for (int j = array.position()+array.arrayOffset(); j < array.limit(); ++j) {
+        for (int j = array.position()+array.arrayOffset(); j < array.limit()+array.arrayOffset(); ++j) {
             int b = array.array()[j] & 0xFF;
             if (b < 0x10) sb.append('0');
             sb.append(Integer.toHexString(b));
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/client/TestRingCache.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/client/TestRingCache.java
index fbdd88fb..1382c78c 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/client/TestRingCache.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/client/TestRingCache.java
@@ -32,6 +32,8 @@
 import org.apache.thrift.protocol.TBinaryProtocol;
 import org.apache.thrift.transport.TFramedTransport;
 import org.apache.thrift.transport.TSocket;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 /**
  *  Sample code that uses RingCache in the client.
@@ -101,7 +103,7 @@ public static void main(String[] args) throws Throwable
             // now, read the row back directly from the host owning the row locally
             tester.setup(firstEndpoint.getHostAddress(), DatabaseDescriptor.getRpcPort());
             tester.thriftClient.set_keyspace(keyspace);
-            tester.thriftClient.insert(row, parent, new Column(ByteBuffer.wrap("col1".getBytes()), ByteBuffer.wrap("val1".getBytes()), 1), ConsistencyLevel.ONE);
+            tester.thriftClient.insert(row, parent, new Column(ByteBufferUtil.bytes("col1"), ByteBufferUtil.bytes("val1"), 1), ConsistencyLevel.ONE);
             Column column = tester.thriftClient.get(row, col, ConsistencyLevel.ONE).column;
             System.out.println("read row " + new String(row.array()) + " " + new String(column.name.array()) + ":" + new String(column.value.array()) + ":" + column.timestamp);
         }
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/config/ColumnDefinitionTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/config/ColumnDefinitionTest.java
index 3659cf73..d16dbbfd 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/config/ColumnDefinitionTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/config/ColumnDefinitionTest.java
@@ -22,22 +22,21 @@
 
 
 import java.nio.ByteBuffer;
-
 import org.junit.Test;
-
 import org.apache.cassandra.thrift.IndexType;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 public class ColumnDefinitionTest
 {
     @Test
     public void testSerializeDeserialize() throws Exception
     {
-        ColumnDefinition cd0 = new ColumnDefinition(ByteBuffer.wrap("TestColumnDefinitionName0".getBytes("UTF8")),
+        ColumnDefinition cd0 = new ColumnDefinition(ByteBufferUtil.bytes("TestColumnDefinitionName0"),
                                                     "BytesType",
                                                     IndexType.KEYS,
                                                     "random index name 0");
 
-        ColumnDefinition cd1 = new ColumnDefinition(ByteBuffer.wrap("TestColumnDefinition1".getBytes("UTF8")),
+        ColumnDefinition cd1 = new ColumnDefinition(ByteBufferUtil.bytes("TestColumnDefinition1"),
                                                     "LongType",
                                                     null,
                                                     null);
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
index b2c83a67..2d507f5e 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
@@ -49,6 +49,7 @@
 
 import static junit.framework.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 public class ColumnFamilyStoreTest extends CleanupHelper
 {
@@ -68,9 +69,9 @@ public void testGetColumnWithWrongBF() throws IOException, ExecutionException, I
     {
         List<RowMutation> rms = new LinkedList<RowMutation>();
         RowMutation rm;
-        rm = new RowMutation("Keyspace1", ByteBuffer.wrap("key1".getBytes()));
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("Column1".getBytes())), ByteBuffer.wrap("asdf".getBytes()), 0);
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("Column2".getBytes())), ByteBuffer.wrap("asdf".getBytes()), 0);
+        rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("key1"));
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("Column1")), ByteBufferUtil.bytes("asdf"), 0);
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("Column2")), ByteBufferUtil.bytes("asdf"), 0);
         rms.add(rm);
         ColumnFamilyStore store = Util.writeColumnFamily(rms);
 
@@ -78,7 +79,7 @@ public void testGetColumnWithWrongBF() throws IOException, ExecutionException, I
         List<SSTableReader> ssTables = table.getAllSSTables();
         assertEquals(1, ssTables.size());
         ssTables.get(0).forceFilterFailures();
-        ColumnFamily cf = store.getColumnFamily(QueryFilter.getIdentityFilter(Util.dk("key2"), new QueryPath("Standard1", null, ByteBuffer.wrap("Column1".getBytes()))));
+        ColumnFamily cf = store.getColumnFamily(QueryFilter.getIdentityFilter(Util.dk("key2"), new QueryPath("Standard1", null, ByteBufferUtil.bytes("Column1"))));
         assertNull(cf);
     }
 
@@ -89,7 +90,7 @@ public void testEmptyRow() throws Exception
         final ColumnFamilyStore store = table.getColumnFamilyStore("Standard2");
         RowMutation rm;
 
-        rm = new RowMutation("Keyspace1", ByteBuffer.wrap("key1".getBytes()));
+        rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("key1"));
         rm.delete(new QueryPath("Standard2", null, null), System.currentTimeMillis());
         rm.apply();
 
@@ -102,7 +103,7 @@ public void runMayThrow() throws IOException
                 assert cf.isMarkedForDelete();
                 assert cf.getColumnsMap().isEmpty();
 
-                QueryFilter namesFilter = QueryFilter.getNamesFilter(Util.dk("key1"), new QueryPath("Standard2", null, null), ByteBuffer.wrap("a".getBytes()));
+                QueryFilter namesFilter = QueryFilter.getNamesFilter(Util.dk("key1"), new QueryPath("Standard2", null, null), ByteBufferUtil.bytes("a"));
                 cf = store.getColumnFamily(namesFilter);
                 assert cf.isMarkedForDelete();
                 assert cf.getColumnsMap().isEmpty();
@@ -121,9 +122,9 @@ public void testSkipStartKey() throws IOException, ExecutionException, Interrupt
         List<Row> result = cfs.getRangeSlice(FBUtilities.EMPTY_BYTE_BUFFER,
                                              Util.range(p, "key1", "key2"),
                                              10,
-                                             new NamesQueryFilter(ByteBuffer.wrap("asdf".getBytes())));
+                                             new NamesQueryFilter(ByteBufferUtil.bytes("asdf")));
         assertEquals(1, result.size());
-        assert result.get(0).key.key.equals(ByteBuffer.wrap("key2".getBytes()));
+        assert result.get(0).key.key.equals(ByteBufferUtil.bytes("key2"));
     }
 
     @Test
@@ -131,28 +132,28 @@ public void testIndexScan() throws IOException
     {
         RowMutation rm;
 
-        rm = new RowMutation("Keyspace1", ByteBuffer.wrap("k1".getBytes()));
-        rm.add(new QueryPath("Indexed1", null, ByteBuffer.wrap("notbirthdate".getBytes("UTF8"))), FBUtilities.toByteBuffer(1L), 0);
-        rm.add(new QueryPath("Indexed1", null, ByteBuffer.wrap("birthdate".getBytes("UTF8"))), FBUtilities.toByteBuffer(1L), 0);
+        rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("k1"));
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("notbirthdate")), FBUtilities.toByteBuffer(1L), 0);
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("birthdate")), FBUtilities.toByteBuffer(1L), 0);
         rm.apply();
 
-        rm = new RowMutation("Keyspace1", ByteBuffer.wrap("k2".getBytes()));
-        rm.add(new QueryPath("Indexed1", null, ByteBuffer.wrap("notbirthdate".getBytes("UTF8"))), FBUtilities.toByteBuffer(2L), 0);
-        rm.add(new QueryPath("Indexed1", null, ByteBuffer.wrap("birthdate".getBytes("UTF8"))), FBUtilities.toByteBuffer(2L), 0);
+        rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("k2"));
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("notbirthdate")), FBUtilities.toByteBuffer(2L), 0);
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("birthdate")), FBUtilities.toByteBuffer(2L), 0);
         rm.apply();
 
-        rm = new RowMutation("Keyspace1", ByteBuffer.wrap("k3".getBytes()));
-        rm.add(new QueryPath("Indexed1", null, ByteBuffer.wrap("notbirthdate".getBytes("UTF8"))), FBUtilities.toByteBuffer(2L), 0);
-        rm.add(new QueryPath("Indexed1", null, ByteBuffer.wrap("birthdate".getBytes("UTF8"))), FBUtilities.toByteBuffer(1L), 0);
+        rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("k3"));
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("notbirthdate")), FBUtilities.toByteBuffer(2L), 0);
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("birthdate")), FBUtilities.toByteBuffer(1L), 0);
         rm.apply();
 
-        rm = new RowMutation("Keyspace1", ByteBuffer.wrap("k4aaaa".getBytes()));
-        rm.add(new QueryPath("Indexed1", null, ByteBuffer.wrap("notbirthdate".getBytes("UTF8"))), FBUtilities.toByteBuffer(2L), 0);
-        rm.add(new QueryPath("Indexed1", null, ByteBuffer.wrap("birthdate".getBytes("UTF8"))), FBUtilities.toByteBuffer(3L), 0);
+        rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("k4aaaa"));
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("notbirthdate")), FBUtilities.toByteBuffer(2L), 0);
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("birthdate")), FBUtilities.toByteBuffer(3L), 0);
         rm.apply();
 
         // basic single-expression query
-        IndexExpression expr = new IndexExpression(ByteBuffer.wrap("birthdate".getBytes("UTF8")), IndexOperator.EQ, FBUtilities.toByteBuffer(1L));
+        IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexOperator.EQ, FBUtilities.toByteBuffer(1L));
         IndexClause clause = new IndexClause(Arrays.asList(expr),FBUtilities.EMPTY_BYTE_BUFFER, 100);
         IFilter filter = new IdentityQueryFilter();
         IPartitioner p = StorageService.getPartitioner();
@@ -161,24 +162,32 @@ public void testIndexScan() throws IOException
 
         assert rows != null;
         assert rows.size() == 2 : StringUtils.join(rows, ",");
-        assert Arrays.equals("k1".getBytes(), rows.get(0).key.key.array());
-        assert Arrays.equals("k3".getBytes(), rows.get(1).key.key.array());
-        assert FBUtilities.toByteBuffer(1L).equals( rows.get(0).cf.getColumn(ByteBuffer.wrap("birthdate".getBytes("UTF8"))).value());
-        assert FBUtilities.toByteBuffer(1L).equals( rows.get(1).cf.getColumn(ByteBuffer.wrap("birthdate".getBytes("UTF8"))).value());
+        
+        String key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining()); 
+        assert "k1".equals( key );
+    
+        key = new String(rows.get(1).key.key.array(),rows.get(1).key.key.position(),rows.get(1).key.key.remaining()); 
+        assert "k3".equals(key);
+        
+        assert FBUtilities.toByteBuffer(1L).equals( rows.get(0).cf.getColumn(ByteBufferUtil.bytes("birthdate")).value());
+        assert FBUtilities.toByteBuffer(1L).equals( rows.get(1).cf.getColumn(ByteBufferUtil.bytes("birthdate")).value());
 
         // add a second expression
-        IndexExpression expr2 = new IndexExpression(ByteBuffer.wrap("notbirthdate".getBytes("UTF8")), IndexOperator.GTE, FBUtilities.toByteBuffer(2L));
+        IndexExpression expr2 = new IndexExpression(ByteBufferUtil.bytes("notbirthdate"), IndexOperator.GTE, FBUtilities.toByteBuffer(2L));
         clause = new IndexClause(Arrays.asList(expr, expr2), FBUtilities.EMPTY_BYTE_BUFFER, 100);
         rows = Table.open("Keyspace1").getColumnFamilyStore("Indexed1").scan(clause, range, filter);
 
         assert rows.size() == 1 : StringUtils.join(rows, ",");
-        assert Arrays.equals("k3".getBytes(), rows.get(0).key.key.array());
+        key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining()); 
+        assert "k3".equals( key );
 
         // same query again, but with resultset not including the subordinate expression
-        rows = Table.open("Keyspace1").getColumnFamilyStore("Indexed1").scan(clause, range, new NamesQueryFilter(ByteBuffer.wrap("birthdate".getBytes("UTF8"))));
+        rows = Table.open("Keyspace1").getColumnFamilyStore("Indexed1").scan(clause, range, new NamesQueryFilter(ByteBufferUtil.bytes("birthdate")));
 
         assert rows.size() == 1 : StringUtils.join(rows, ",");
-        assert Arrays.equals("k3".getBytes(), rows.get(0).key.key.array());
+        key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining()); 
+        assert "k3".equals( key );
+    
         assert rows.get(0).cf.getColumnCount() == 1 : rows.get(0).cf;
 
         // once more, this time with a slice rowset that needs to be expanded
@@ -186,12 +195,14 @@ public void testIndexScan() throws IOException
         rows = Table.open("Keyspace1").getColumnFamilyStore("Indexed1").scan(clause, range, emptyFilter);
       
         assert rows.size() == 1 : StringUtils.join(rows, ",");
-        assert Arrays.equals("k3".getBytes(), rows.get(0).key.key.array());
+        key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining()); 
+        assert "k3".equals( key );
+    
         assert rows.get(0).cf.getColumnCount() == 0;
 
         // query with index hit but rejected by secondary clause, with a small enough count that just checking count
         // doesn't tell the scan loop that it's done
-        IndexExpression expr3 = new IndexExpression(ByteBuffer.wrap("notbirthdate".getBytes("UTF8")), IndexOperator.EQ, FBUtilities.toByteBuffer(-1L));
+        IndexExpression expr3 = new IndexExpression(ByteBufferUtil.bytes("notbirthdate"), IndexOperator.EQ, FBUtilities.toByteBuffer(-1L));
         clause = new IndexClause(Arrays.asList(expr, expr3), FBUtilities.EMPTY_BYTE_BUFFER, 1);
         rows = Table.open("Keyspace1").getColumnFamilyStore("Indexed1").scan(clause, range, filter);
 
@@ -204,43 +215,45 @@ public void testIndexDeletions() throws IOException
         ColumnFamilyStore cfs = Table.open("Keyspace3").getColumnFamilyStore("Indexed1");
         RowMutation rm;
 
-        rm = new RowMutation("Keyspace3", ByteBuffer.wrap("k1".getBytes()));
-        rm.add(new QueryPath("Indexed1", null, ByteBuffer.wrap("birthdate".getBytes("UTF8"))), FBUtilities.toByteBuffer(1L), 0);
+        rm = new RowMutation("Keyspace3", ByteBufferUtil.bytes("k1"));
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("birthdate")), FBUtilities.toByteBuffer(1L), 0);
         rm.apply();
 
-        IndexExpression expr = new IndexExpression(ByteBuffer.wrap("birthdate".getBytes("UTF8")), IndexOperator.EQ, FBUtilities.toByteBuffer(1L));
+        IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexOperator.EQ, FBUtilities.toByteBuffer(1L));
         IndexClause clause = new IndexClause(Arrays.asList(expr), FBUtilities.EMPTY_BYTE_BUFFER, 100);
         IFilter filter = new IdentityQueryFilter();
         IPartitioner p = StorageService.getPartitioner();
         Range range = new Range(p.getMinimumToken(), p.getMinimumToken());
         List<Row> rows = cfs.scan(clause, range, filter);
         assert rows.size() == 1 : StringUtils.join(rows, ",");
-        assert Arrays.equals("k1".getBytes(), rows.get(0).key.key.array());
+        String key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining()); 
+        assert "k1".equals( key );
 
         // delete the column directly
-        rm = new RowMutation("Keyspace3", ByteBuffer.wrap("k1".getBytes()));
-        rm.delete(new QueryPath("Indexed1", null, ByteBuffer.wrap("birthdate".getBytes("UTF8"))), 1);
+        rm = new RowMutation("Keyspace3", ByteBufferUtil.bytes("k1"));
+        rm.delete(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("birthdate")), 1);
         rm.apply();
         rows = cfs.scan(clause, range, filter);
         assert rows.isEmpty();
 
         // verify that it's not being indexed under the deletion column value either
         IColumn deletion = rm.getColumnFamilies().iterator().next().iterator().next();
-        IndexExpression expr0 = new IndexExpression(ByteBuffer.wrap("birthdate".getBytes("UTF8")), IndexOperator.EQ, deletion.value());
+        IndexExpression expr0 = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexOperator.EQ, deletion.value());
         IndexClause clause0 = new IndexClause(Arrays.asList(expr0), FBUtilities.EMPTY_BYTE_BUFFER, 100);
         rows = cfs.scan(clause0, range, filter);
         assert rows.isEmpty();
 
         // resurrect w/ a newer timestamp
-        rm = new RowMutation("Keyspace3", ByteBuffer.wrap("k1".getBytes()));
-        rm.add(new QueryPath("Indexed1", null, ByteBuffer.wrap("birthdate".getBytes("UTF8"))), FBUtilities.toByteBuffer(1L), 2);
+        rm = new RowMutation("Keyspace3", ByteBufferUtil.bytes("k1"));
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("birthdate")), FBUtilities.toByteBuffer(1L), 2);
         rm.apply();
         rows = cfs.scan(clause, range, filter);
         assert rows.size() == 1 : StringUtils.join(rows, ",");
-        assert Arrays.equals("k1".getBytes(), rows.get(0).key.key.array());
+        key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining()); 
+        assert "k1".equals( key );  
 
         // delete the entire row
-        rm = new RowMutation("Keyspace3", ByteBuffer.wrap("k1".getBytes()));
+        rm = new RowMutation("Keyspace3", ByteBufferUtil.bytes("k1"));
         rm.delete(new QueryPath("Indexed1"), 3);
         rm.apply();
         rows = cfs.scan(clause, range, filter);
@@ -254,14 +267,14 @@ public void testIndexUpdate() throws IOException
 
         // create a row and update the birthdate value, test that the index query fetches the new version
         RowMutation rm;
-        rm = new RowMutation("Keyspace2", ByteBuffer.wrap("k1".getBytes()));
-        rm.add(new QueryPath("Indexed1", null, ByteBuffer.wrap("birthdate".getBytes("UTF8"))), FBUtilities.toByteBuffer(1L), 1);
+        rm = new RowMutation("Keyspace2", ByteBufferUtil.bytes("k1"));
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("birthdate")), FBUtilities.toByteBuffer(1L), 1);
         rm.apply();
-        rm = new RowMutation("Keyspace2", ByteBuffer.wrap("k1".getBytes()));
-        rm.add(new QueryPath("Indexed1", null, ByteBuffer.wrap("birthdate".getBytes("UTF8"))), FBUtilities.toByteBuffer(2L), 2);
+        rm = new RowMutation("Keyspace2", ByteBufferUtil.bytes("k1"));
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("birthdate")), FBUtilities.toByteBuffer(2L), 2);
         rm.apply();
 
-        IndexExpression expr = new IndexExpression(ByteBuffer.wrap("birthdate".getBytes("UTF8")), IndexOperator.EQ, FBUtilities.toByteBuffer(1L));
+        IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexOperator.EQ, FBUtilities.toByteBuffer(1L));
         IndexClause clause = new IndexClause(Arrays.asList(expr), FBUtilities.EMPTY_BYTE_BUFFER, 100);
         IFilter filter = new IdentityQueryFilter();
         IPartitioner p = StorageService.getPartitioner();
@@ -269,18 +282,21 @@ public void testIndexUpdate() throws IOException
         List<Row> rows = table.getColumnFamilyStore("Indexed1").scan(clause, range, filter);
         assert rows.size() == 0;
 
-        expr = new IndexExpression(ByteBuffer.wrap("birthdate".getBytes("UTF8")), IndexOperator.EQ, FBUtilities.toByteBuffer(2L));
+        expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexOperator.EQ, FBUtilities.toByteBuffer(2L));
         clause = new IndexClause(Arrays.asList(expr), FBUtilities.EMPTY_BYTE_BUFFER, 100);
         rows = table.getColumnFamilyStore("Indexed1").scan(clause, range, filter);
-        assert Arrays.equals("k1".getBytes(), rows.get(0).key.key.array());
+        String key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining()); 
+        assert "k1".equals( key );
 
         // update the birthdate value with an OLDER timestamp, and test that the index ignores this
-        rm = new RowMutation("Keyspace2", ByteBuffer.wrap("k1".getBytes()));
-        rm.add(new QueryPath("Indexed1", null, ByteBuffer.wrap("birthdate".getBytes("UTF8"))), FBUtilities.toByteBuffer(3L), 0);
+        rm = new RowMutation("Keyspace2", ByteBufferUtil.bytes("k1"));
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("birthdate")), FBUtilities.toByteBuffer(3L), 0);
         rm.apply();
 
         rows = table.getColumnFamilyStore("Indexed1").scan(clause, range, filter);
-        assert Arrays.equals("k1".getBytes(), rows.get(0).key.key.array());
+        key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining()); 
+        assert "k1".equals( key );
+    
     }
 
     @Test
@@ -290,38 +306,39 @@ public void testIndexCreate() throws IOException, ConfigurationException, Interr
 
         // create a row and update the birthdate value, test that the index query fetches the new version
         RowMutation rm;
-        rm = new RowMutation("Keyspace1", ByteBuffer.wrap("k1".getBytes()));
-        rm.add(new QueryPath("Indexed2", null, ByteBuffer.wrap("birthdate".getBytes("UTF8"))), FBUtilities.toByteBuffer(1L), 1);
+        rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("k1"));
+        rm.add(new QueryPath("Indexed2", null, ByteBufferUtil.bytes("birthdate")), FBUtilities.toByteBuffer(1L), 1);
         rm.apply();
 
         ColumnFamilyStore cfs = table.getColumnFamilyStore("Indexed2");
-        ColumnDefinition old = cfs.metadata.column_metadata.get(ByteBuffer.wrap("birthdate".getBytes("UTF8")));
+        ColumnDefinition old = cfs.metadata.column_metadata.get(ByteBufferUtil.bytes("birthdate"));
         ColumnDefinition cd = new ColumnDefinition(old.name, old.validator.getClass().getName(), IndexType.KEYS, "birthdate_index");
         cfs.addIndex(cd);
-        while (!SystemTable.isIndexBuilt("Keyspace1", cfs.getIndexedColumnFamilyStore(ByteBuffer.wrap("birthdate".getBytes("UTF8"))).columnFamily))
+        while (!SystemTable.isIndexBuilt("Keyspace1", cfs.getIndexedColumnFamilyStore(ByteBufferUtil.bytes("birthdate")).columnFamily))
             TimeUnit.MILLISECONDS.sleep(100);
 
-        IndexExpression expr = new IndexExpression(ByteBuffer.wrap("birthdate".getBytes("UTF8")), IndexOperator.EQ, FBUtilities.toByteBuffer(1L));
+        IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexOperator.EQ, FBUtilities.toByteBuffer(1L));
         IndexClause clause = new IndexClause(Arrays.asList(expr), FBUtilities.EMPTY_BYTE_BUFFER, 100);
         IFilter filter = new IdentityQueryFilter();
         IPartitioner p = StorageService.getPartitioner();
         Range range = new Range(p.getMinimumToken(), p.getMinimumToken());
         List<Row> rows = table.getColumnFamilyStore("Indexed2").scan(clause, range, filter);
         assert rows.size() == 1 : StringUtils.join(rows, ",");
-        assert Arrays.equals("k1".getBytes(), rows.get(0).key.key.array());
+        String key = new String(rows.get(0).key.key.array(),rows.get(0).key.key.position(),rows.get(0).key.key.remaining()); 
+        assert "k1".equals( key );        
     }
 
     private ColumnFamilyStore insertKey1Key2() throws IOException, ExecutionException, InterruptedException
     {
         List<RowMutation> rms = new LinkedList<RowMutation>();
         RowMutation rm;
-        rm = new RowMutation("Keyspace2", ByteBuffer.wrap("key1".getBytes()));
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("Column1".getBytes())), ByteBuffer.wrap("asdf".getBytes()), 0);
+        rm = new RowMutation("Keyspace2", ByteBufferUtil.bytes("key1"));
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("Column1")), ByteBufferUtil.bytes("asdf"), 0);
         rms.add(rm);
         Util.writeColumnFamily(rms);
 
-        rm = new RowMutation("Keyspace2", ByteBuffer.wrap("key2".getBytes()));
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("Column1".getBytes())), ByteBuffer.wrap("asdf".getBytes()), 0);
+        rm = new RowMutation("Keyspace2", ByteBufferUtil.bytes("key2"));
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("Column1")), ByteBufferUtil.bytes("asdf"), 0);
         rms.add(rm);
         return Util.writeColumnFamily(rms);
     }
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
index 429107d4..d519ad19 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
@@ -31,6 +31,8 @@
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.db.filter.QueryPath;
 import static org.apache.cassandra.Util.column;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class ColumnFamilyTest extends SchemaLoader
 {
@@ -78,7 +80,8 @@ public void testManyColumns() throws IOException
         cf = ColumnFamily.serializer().deserialize(new DataInputStream(bufIn));
         for (String cName : map.navigableKeySet())
         {
-            assert new String(cf.getColumn(ByteBuffer.wrap(cName.getBytes())).value().array()).equals(map.get(cName));
+            ByteBuffer val = cf.getColumn(ByteBuffer.wrap(cName.getBytes())).value();
+            assert new String(val.array(),val.position(),val.remaining()).equals(map.get(cName));
         }
         assert cf.getColumnNames().size() == map.size();
     }
@@ -105,7 +108,7 @@ public void testTimestamp()
         cf.addColumn(column("col1", "val2", 2)); // same timestamp, new value
         cf.addColumn(column("col1", "val3", 1)); // older timestamp -- should be ignored
 
-        assert Arrays.equals("val2".getBytes(), cf.getColumn(ByteBuffer.wrap("col1".getBytes())).value().array());
+        assert ByteBufferUtil.bytes("val2").equals(cf.getColumn(ByteBufferUtil.bytes("col1")).value());
     }
 
     @Test
@@ -114,33 +117,33 @@ public void testMergeAndAdd()
         ColumnFamily cf_new = ColumnFamily.create("Keyspace1", "Standard1");
         ColumnFamily cf_old = ColumnFamily.create("Keyspace1", "Standard1");
         ColumnFamily cf_result = ColumnFamily.create("Keyspace1", "Standard1");
-        ByteBuffer val = ByteBuffer.wrap("sample value".getBytes());
-        ByteBuffer val2 = ByteBuffer.wrap("x value ".getBytes());
+        ByteBuffer val = ByteBufferUtil.bytes("sample value");
+        ByteBuffer val2 = ByteBufferUtil.bytes("x value ");
 
         // exercise addColumn(QueryPath, ...)
-        cf_new.addColumn(QueryPath.column(ByteBuffer.wrap("col1".getBytes())), val, 3);
-        cf_new.addColumn(QueryPath.column(ByteBuffer.wrap("col2".getBytes())), val, 4);
+        cf_new.addColumn(QueryPath.column(ByteBufferUtil.bytes("col1")), val, 3);
+        cf_new.addColumn(QueryPath.column(ByteBufferUtil.bytes("col2")), val, 4);
 
-        cf_old.addColumn(QueryPath.column(ByteBuffer.wrap("col2".getBytes())), val2, 1);
-        cf_old.addColumn(QueryPath.column(ByteBuffer.wrap("col3".getBytes())), val2, 2);
+        cf_old.addColumn(QueryPath.column(ByteBufferUtil.bytes("col2")), val2, 1);
+        cf_old.addColumn(QueryPath.column(ByteBufferUtil.bytes("col3")), val2, 2);
 
         cf_result.addAll(cf_new);
         cf_result.addAll(cf_old);
 
         assert 3 == cf_result.getColumnCount() : "Count is " + cf_new.getColumnCount();
         //addcolumns will only add if timestamp >= old timestamp
-        assert val.equals(cf_result.getColumn(ByteBuffer.wrap("col2".getBytes())).value());
+        assert val.equals(cf_result.getColumn(ByteBufferUtil.bytes("col2")).value());
 
         // check that tombstone wins timestamp ties
-        cf_result.addTombstone(ByteBuffer.wrap("col1".getBytes()), 0, 3);
-        assert cf_result.getColumn(ByteBuffer.wrap("col1".getBytes())).isMarkedForDelete();
-        cf_result.addColumn(QueryPath.column(ByteBuffer.wrap("col1".getBytes())), val2, 3);
-        assert cf_result.getColumn(ByteBuffer.wrap("col1".getBytes())).isMarkedForDelete();
+        cf_result.addTombstone(ByteBufferUtil.bytes("col1"), 0, 3);
+        assert cf_result.getColumn(ByteBufferUtil.bytes("col1")).isMarkedForDelete();
+        cf_result.addColumn(QueryPath.column(ByteBufferUtil.bytes("col1")), val2, 3);
+        assert cf_result.getColumn(ByteBufferUtil.bytes("col1")).isMarkedForDelete();
 
         // check that column value wins timestamp ties in absence of tombstone
-        cf_result.addColumn(QueryPath.column(ByteBuffer.wrap("col3".getBytes())), val, 2);
-        assert cf_result.getColumn(ByteBuffer.wrap("col3".getBytes())).value().equals(val2);
-        cf_result.addColumn(QueryPath.column(ByteBuffer.wrap("col3".getBytes())), ByteBuffer.wrap("z".getBytes()), 2);
-        assert cf_result.getColumn(ByteBuffer.wrap("col3".getBytes())).value().equals(ByteBuffer.wrap("z".getBytes()));
+        cf_result.addColumn(QueryPath.column(ByteBufferUtil.bytes("col3")), val, 2);
+        assert cf_result.getColumn(ByteBufferUtil.bytes("col3")).value().equals(val2);
+        cf_result.addColumn(QueryPath.column(ByteBufferUtil.bytes("col3")), ByteBufferUtil.bytes("z"), 2);
+        assert cf_result.getColumn(ByteBufferUtil.bytes("col3")).value().equals(ByteBufferUtil.bytes("z"));
     }
 }
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/CompactionsPurgeTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/CompactionsPurgeTest.java
index f82c5f9f..4dccd06d 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/CompactionsPurgeTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/CompactionsPurgeTest.java
@@ -35,6 +35,8 @@
 
 import static junit.framework.Assert.assertEquals;
 import static org.apache.cassandra.db.TableTest.assertColumns;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class CompactionsPurgeTest extends CleanupHelper
 {
@@ -209,18 +211,18 @@ public void testKeyCache(String cfname, int expectedCacheSize) throws IOExceptio
 
         // inserts
         rm = new RowMutation(TABLE1, key1.key);
-        rm.add(new QueryPath(cfName, null, ByteBuffer.wrap("1".getBytes())), FBUtilities.EMPTY_BYTE_BUFFER, 0);
+        rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes("1")), FBUtilities.EMPTY_BYTE_BUFFER, 0);
         rm.apply();
         rm = new RowMutation(TABLE1, key2.key);
-        rm.add(new QueryPath(cfName, null, ByteBuffer.wrap("2".getBytes())), FBUtilities.EMPTY_BYTE_BUFFER, 0);
+        rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes("2")), FBUtilities.EMPTY_BYTE_BUFFER, 0);
         rm.apply();
 
         // deletes
         rm = new RowMutation(TABLE1, key1.key);
-        rm.delete(new QueryPath(cfName, null, ByteBuffer.wrap("1".getBytes())), 1);
+        rm.delete(new QueryPath(cfName, null, ByteBufferUtil.bytes("1")), 1);
         rm.apply();
         rm = new RowMutation(TABLE1, key2.key);
-        rm.delete(new QueryPath(cfName, null, ByteBuffer.wrap("2".getBytes())), 1);
+        rm.delete(new QueryPath(cfName, null, ByteBufferUtil.bytes("2")), 1);
         rm.apply();
 
         // After a flush, the cache should expand to be X% of indices * INDEX_INTERVAL.
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/DefsTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/DefsTest.java
index 7cddb668..f9a6ff74 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/DefsTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/DefsTest.java
@@ -18,29 +18,50 @@
 
 package org.apache.cassandra.db;
 
+import static org.junit.Assert.assertEquals;
+
 import java.io.File;
 import java.io.IOException;
 import java.nio.ByteBuffer;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.SortedSet;
+import java.util.TreeSet;
+import java.util.UUID;
 import java.util.concurrent.ExecutionException;
 
-import org.apache.cassandra.io.SerDeUtils;
-import org.apache.cassandra.locator.OldNetworkTopologyStrategy;
-import org.apache.cassandra.thrift.CfDef;
-import org.apache.cassandra.thrift.ColumnDef;
-import org.junit.Test;
-
 import org.apache.cassandra.CleanupHelper;
 import org.apache.cassandra.Util;
-import org.apache.cassandra.config.*;
+import org.apache.cassandra.config.CFMetaData;
+import org.apache.cassandra.config.ColumnDefinition;
+import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.config.KSMetaData;
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.db.marshal.UTF8Type;
-import org.apache.cassandra.db.migration.*;
+import org.apache.cassandra.db.migration.AddColumnFamily;
+import org.apache.cassandra.db.migration.AddKeyspace;
+import org.apache.cassandra.db.migration.DropColumnFamily;
+import org.apache.cassandra.db.migration.DropKeyspace;
+import org.apache.cassandra.db.migration.Migration;
+import org.apache.cassandra.db.migration.RenameColumnFamily;
+import org.apache.cassandra.db.migration.RenameKeyspace;
+import org.apache.cassandra.db.migration.UpdateColumnFamily;
+import org.apache.cassandra.db.migration.UpdateKeyspace;
+import org.apache.cassandra.locator.OldNetworkTopologyStrategy;
 import org.apache.cassandra.locator.SimpleStrategy;
+import org.apache.cassandra.thrift.CfDef;
+import org.apache.cassandra.thrift.ColumnDef;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.UUIDGen;
+import org.junit.Test;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class DefsTest extends CleanupHelper
 {   
@@ -172,16 +193,16 @@ public void addNewCF() throws ConfigurationException, IOException, ExecutionExce
         // now read and write to it.
         DecoratedKey dk = Util.dk("key0");
         RowMutation rm = new RowMutation(ks, dk.key);
-        rm.add(new QueryPath(cf, null, ByteBuffer.wrap("col0".getBytes())), ByteBuffer.wrap("value0".getBytes()), 1L);
+        rm.add(new QueryPath(cf, null, ByteBufferUtil.bytes("col0")), ByteBufferUtil.bytes("value0"), 1L);
         rm.apply();
         ColumnFamilyStore store = Table.open(ks).getColumnFamilyStore(cf);
         assert store != null;
         store.forceBlockingFlush();
         
-        ColumnFamily cfam = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath(cf), ByteBuffer.wrap("col0".getBytes())));
-        assert cfam.getColumn(ByteBuffer.wrap("col0".getBytes())) != null;
-        IColumn col = cfam.getColumn(ByteBuffer.wrap("col0".getBytes()));
-        assert ByteBuffer.wrap("value0".getBytes()).equals(col.value());
+        ColumnFamily cfam = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath(cf), ByteBufferUtil.bytes("col0")));
+        assert cfam.getColumn(ByteBufferUtil.bytes("col0")) != null;
+        IColumn col = cfam.getColumn(ByteBufferUtil.bytes("col0"));
+        assert ByteBufferUtil.bytes("value0").equals(col.value());
     }
 
     @Test
@@ -197,7 +218,7 @@ public void dropCf() throws ConfigurationException, IOException, ExecutionExcept
         // write some data, force a flush, then verify that files exist on disk.
         RowMutation rm = new RowMutation(ks.name, dk.key);
         for (int i = 0; i < 100; i++)
-            rm.add(new QueryPath(cfm.cfName, null, ByteBuffer.wrap(("col" + i).getBytes())), ByteBuffer.wrap("anyvalue".getBytes()), 1L);
+            rm.add(new QueryPath(cfm.cfName, null, ByteBuffer.wrap(("col" + i).getBytes())), ByteBufferUtil.bytes("anyvalue"), 1L);
         rm.apply();
         ColumnFamilyStore store = Table.open(cfm.tableName).getColumnFamilyStore(cfm.cfName);
         assert store != null;
@@ -214,7 +235,7 @@ public void dropCf() throws ConfigurationException, IOException, ExecutionExcept
         boolean success = true;
         try
         {
-            rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("col0".getBytes())), ByteBuffer.wrap("value0".getBytes()), 1L);
+            rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("col0")), ByteBufferUtil.bytes("value0"), 1L);
             rm.apply();
         }
         catch (Throwable th)
@@ -243,7 +264,7 @@ public void renameCf() throws ConfigurationException, IOException, ExecutionExce
         // write some data, force a flush, then verify that files exist on disk.
         RowMutation rm = new RowMutation(ks.name, dk.key);
         for (int i = 0; i < 100; i++)
-            rm.add(new QueryPath(oldCfm.cfName, null, ByteBuffer.wrap(("col" + i).getBytes())), ByteBuffer.wrap("anyvalue".getBytes()), 1L);
+            rm.add(new QueryPath(oldCfm.cfName, null, ByteBuffer.wrap(("col" + i).getBytes())), ByteBufferUtil.bytes("anyvalue"), 1L);
         rm.apply();
         ColumnFamilyStore store = Table.open(oldCfm.tableName).getColumnFamilyStore(oldCfm.cfName);
         assert store != null;
@@ -268,13 +289,13 @@ public void renameCf() throws ConfigurationException, IOException, ExecutionExce
         
         // do some writes
         rm = new RowMutation(ks.name, dk.key);
-        rm.add(new QueryPath(cfName, null, ByteBuffer.wrap("col5".getBytes())), ByteBuffer.wrap("updated".getBytes()), 2L);
+        rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes("col5")), ByteBufferUtil.bytes("updated"), 2L);
         rm.apply();
         store.forceBlockingFlush();
         
-        cfam = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath(cfName), ByteBuffer.wrap("col5".getBytes())));
+        cfam = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath(cfName), ByteBufferUtil.bytes("col5")));
         assert cfam.getColumnCount() == 1;
-        assert cfam.getColumn(ByteBuffer.wrap("col5".getBytes())).value().equals( ByteBuffer.wrap("updated".getBytes()));
+        assert cfam.getColumn(ByteBufferUtil.bytes("col5")).value().equals( ByteBufferUtil.bytes("updated"));
     }
     
     @Test
@@ -292,16 +313,16 @@ public void addNewKS() throws ConfigurationException, IOException, ExecutionExce
 
         // test reads and writes.
         RowMutation rm = new RowMutation(newCf.tableName, dk.key);
-        rm.add(new QueryPath(newCf.cfName, null, ByteBuffer.wrap("col0".getBytes())), ByteBuffer.wrap("value0".getBytes()), 1L);
+        rm.add(new QueryPath(newCf.cfName, null, ByteBufferUtil.bytes("col0")), ByteBufferUtil.bytes("value0"), 1L);
         rm.apply();
         ColumnFamilyStore store = Table.open(newCf.tableName).getColumnFamilyStore(newCf.cfName);
         assert store != null;
         store.forceBlockingFlush();
         
-        ColumnFamily cfam = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath(newCf.cfName), ByteBuffer.wrap("col0".getBytes())));
-        assert cfam.getColumn(ByteBuffer.wrap("col0".getBytes())) != null;
-        IColumn col = cfam.getColumn(ByteBuffer.wrap("col0".getBytes()));
-        assert ByteBuffer.wrap("value0".getBytes()).equals(col.value());
+        ColumnFamily cfam = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath(newCf.cfName), ByteBufferUtil.bytes("col0")));
+        assert cfam.getColumn(ByteBufferUtil.bytes("col0")) != null;
+        IColumn col = cfam.getColumn(ByteBufferUtil.bytes("col0"));
+        assert ByteBufferUtil.bytes("value0").equals(col.value());
     }
     
     @Test
@@ -317,7 +338,7 @@ public void dropKS() throws ConfigurationException, IOException, ExecutionExcept
         // write some data, force a flush, then verify that files exist on disk.
         RowMutation rm = new RowMutation(ks.name, dk.key);
         for (int i = 0; i < 100; i++)
-            rm.add(new QueryPath(cfm.cfName, null, ByteBuffer.wrap(("col" + i).getBytes())), ByteBuffer.wrap("anyvalue".getBytes()), 1L);
+            rm.add(new QueryPath(cfm.cfName, null, ByteBuffer.wrap(("col" + i).getBytes())), ByteBufferUtil.bytes("anyvalue"), 1L);
         rm.apply();
         ColumnFamilyStore store = Table.open(cfm.tableName).getColumnFamilyStore(cfm.cfName);
         assert store != null;
@@ -333,7 +354,7 @@ public void dropKS() throws ConfigurationException, IOException, ExecutionExcept
         boolean success = true;
         try
         {
-            rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("col0".getBytes())), ByteBuffer.wrap("value0".getBytes()), 1L);
+            rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("col0")), ByteBufferUtil.bytes("value0"), 1L);
             rm.apply();
         }
         catch (Throwable th)
@@ -367,7 +388,7 @@ public void renameKs() throws ConfigurationException, IOException, ExecutionExce
         // write some data that we hope to read back later.
         RowMutation rm = new RowMutation(oldKs.name, dk.key);
         for (int i = 0; i < 10; i++)
-            rm.add(new QueryPath(cfName, null, ByteBuffer.wrap(("col" + i).getBytes())), ByteBuffer.wrap("value".getBytes()), 1L);
+            rm.add(new QueryPath(cfName, null, ByteBuffer.wrap(("col" + i).getBytes())), ByteBufferUtil.bytes("value"), 1L);
         rm.apply();
         ColumnFamilyStore store = Table.open(oldKs.name).getColumnFamilyStore(cfName);
         assert store != null;
@@ -396,11 +417,11 @@ public void renameKs() throws ConfigurationException, IOException, ExecutionExce
         }
         
         // write on old should fail.
-        rm = new RowMutation(oldKs.name, ByteBuffer.wrap("any key will do".getBytes()));
+        rm = new RowMutation(oldKs.name, ByteBufferUtil.bytes("any key will do"));
         boolean success = true;
         try
         {
-            rm.add(new QueryPath(cfName, null, ByteBuffer.wrap("col0".getBytes())), ByteBuffer.wrap("value0".getBytes()), 1L);
+            rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes("col0")), ByteBufferUtil.bytes("value0"), 1L);
             rm.apply();
         }
         catch (Throwable th)
@@ -411,7 +432,7 @@ public void renameKs() throws ConfigurationException, IOException, ExecutionExce
         
         // write on new should work.
         rm = new RowMutation(newKsName, dk.key);
-        rm.add(new QueryPath(cfName, null, ByteBuffer.wrap("col0".getBytes())), ByteBuffer.wrap("newvalue".getBytes()), 2L);
+        rm.add(new QueryPath(cfName, null, ByteBufferUtil.bytes("col0")), ByteBufferUtil.bytes("newvalue"), 2L);
         rm.apply();
         store = Table.open(newKs.name).getColumnFamilyStore(cfName);
         assert store != null;
@@ -419,14 +440,17 @@ public void renameKs() throws ConfigurationException, IOException, ExecutionExce
         
         // read on new should work.
         SortedSet<ByteBuffer> cols = new TreeSet<ByteBuffer>(BytesType.instance);
-        cols.add(ByteBuffer.wrap("col0".getBytes()));
-        cols.add(ByteBuffer.wrap("col1".getBytes()));
+        cols.add(ByteBufferUtil.bytes("col0"));
+        cols.add(ByteBufferUtil.bytes("col1"));
         ColumnFamily cfam = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath(cfName), cols));
         assert cfam.getColumnCount() == cols.size();
         // tests new write.
-        assert Arrays.equals(cfam.getColumn(ByteBuffer.wrap("col0".getBytes())).value().array(), "newvalue".getBytes());
+        
+        ByteBuffer val = cfam.getColumn(ByteBufferUtil.bytes("col0")).value();
+        assertEquals( new String(val.array(),val.position(),val.remaining()), "newvalue");
         // tests old write.
-        assert Arrays.equals(cfam.getColumn(ByteBuffer.wrap("col1".getBytes())).value().array(), "value".getBytes());
+         val = cfam.getColumn(ByteBufferUtil.bytes("col1")).value();
+        assertEquals( new String(val.array(),val.position(),val.remaining()), "value");
     }
 
     @Test
@@ -453,16 +477,16 @@ public void createEmptyKsAddNewCf() throws ConfigurationException, IOException,
         // now read and write to it.
         DecoratedKey dk = Util.dk("key0");
         RowMutation rm = new RowMutation(newKs.name, dk.key);
-        rm.add(new QueryPath(newCf.cfName, null, ByteBuffer.wrap("col0".getBytes())), ByteBuffer.wrap("value0".getBytes()), 1L);
+        rm.add(new QueryPath(newCf.cfName, null, ByteBufferUtil.bytes("col0")), ByteBufferUtil.bytes("value0"), 1L);
         rm.apply();
         ColumnFamilyStore store = Table.open(newKs.name).getColumnFamilyStore(newCf.cfName);
         assert store != null;
         store.forceBlockingFlush();
 
-        ColumnFamily cfam = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath(newCf.cfName), ByteBuffer.wrap("col0".getBytes())));
-        assert cfam.getColumn(ByteBuffer.wrap("col0".getBytes())) != null;
-        IColumn col = cfam.getColumn(ByteBuffer.wrap("col0".getBytes()));
-        assert ByteBuffer.wrap("value0".getBytes()).equals(col.value());
+        ColumnFamily cfam = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath(newCf.cfName), ByteBufferUtil.bytes("col0")));
+        assert cfam.getColumn(ByteBufferUtil.bytes("col0")) != null;
+        IColumn col = cfam.getColumn(ByteBufferUtil.bytes("col0"));
+        assert ByteBufferUtil.bytes("value0").equals(col.value());
     }
     
     @Test
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/NameSortTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/NameSortTest.java
index 7852fc64..ca126e5e 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/NameSortTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/NameSortTest.java
@@ -1,40 +1,35 @@
 /*
-* Licensed to the Apache Software Foundation (ASF) under one
-* or more contributor license agreements.  See the NOTICE file
-* distributed with this work for additional information
-* regarding copyright ownership.  The ASF licenses this file
-* to you under the Apache License, Version 2.0 (the
-* "License"); you may not use this file except in compliance
-* with the License.  You may obtain a copy of the License at
-*
-*    http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing,
-* software distributed under the License is distributed on an
-* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-* KIND, either express or implied.  See the License for the
-* specific language governing permissions and limitations
-* under the License.
-*/
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
 package org.apache.cassandra.db;
 
+import static junit.framework.Assert.assertEquals;
+import static org.apache.cassandra.Util.addMutation;
+
 import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import java.util.Collection;
-import java.util.Arrays;
 import java.nio.ByteBuffer;
-
-import org.apache.cassandra.Util;
-import org.junit.Test;
+import java.util.Collection;
+import java.util.concurrent.ExecutionException;
 
 import org.apache.cassandra.CleanupHelper;
 import org.apache.cassandra.Util;
-import static org.apache.cassandra.Util.addMutation;
-
 import org.apache.cassandra.db.filter.QueryPath;
-import org.apache.cassandra.utils.ByteBufferUtil;
-
-import static junit.framework.Assert.assertEquals;
+import org.junit.Test;
 
 public class NameSortTest extends CleanupHelper
 {
@@ -59,7 +54,6 @@ public void testNameSort100() throws IOException, ExecutionException, Interrupte
         testNameSort(100);
     }
 
-
     private void testNameSort(int N) throws IOException, ExecutionException, InterruptedException
     {
         Table table = Table.open("Keyspace1");
@@ -109,9 +103,10 @@ private void validateNameSort(Table table, int N) throws IOException
             Collection<IColumn> columns = cf.getSortedColumns();
             for (IColumn column : columns)
             {
-                int j = Integer.valueOf(new String(column.name().array()).split("-")[1]);
+                int j = Integer.valueOf(new String(column.name().array(),column.name().position(),column.name().remaining()).split("-")[1]);
                 byte[] bytes = j % 2 == 0 ? "a".getBytes() : "b".getBytes();
-                assert Arrays.equals(bytes, column.value().array());
+                assertEquals(new String(bytes), new String(column.value().array(), column.value().position(), column
+                        .value().remaining()));
             }
 
             cf = Util.getColumnFamily(table, key, "Super1");
@@ -120,14 +115,15 @@ private void validateNameSort(Table table, int N) throws IOException
             assert superColumns.size() == 8 : cf;
             for (IColumn superColumn : superColumns)
             {
-                int j = Integer.valueOf(new String(superColumn.name().array()).split("-")[1]);
+                int j = Integer.valueOf(new String(superColumn.name().array(),superColumn.name().position(),superColumn.name().remaining()).split("-")[1]);
                 Collection<IColumn> subColumns = superColumn.getSubColumns();
                 assert subColumns.size() == 4;
                 for (IColumn subColumn : subColumns)
                 {
-                    long k = subColumn.name().getLong(subColumn.name().position()+subColumn.name().arrayOffset());                   
+                    long k = subColumn.name().getLong(subColumn.name().position() + subColumn.name().arrayOffset());
                     byte[] bytes = (j + k) % 2 == 0 ? "a".getBytes() : "b".getBytes();
-                    assert Arrays.equals(bytes, subColumn.value().array());
+                    assertEquals(new String(bytes), new String(subColumn.value().array(), subColumn.value().position(),
+                            subColumn.value().remaining()));
                 }
             }
         }
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/OneCompactionTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/OneCompactionTest.java
index 4ac1dbce..e06f5aaf 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/OneCompactionTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/OneCompactionTest.java
@@ -32,6 +32,8 @@
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.CleanupHelper;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class OneCompactionTest extends CleanupHelper
 {
@@ -46,7 +48,7 @@ private void testCompaction(String columnFamilyName, int insertsPerTable) throws
         for (int j = 0; j < insertsPerTable; j++) {
             DecoratedKey key = Util.dk(String.valueOf(j));
             RowMutation rm = new RowMutation("Keyspace1", key.key);
-            rm.add(new QueryPath(columnFamilyName, null, ByteBuffer.wrap("0".getBytes())), FBUtilities.EMPTY_BYTE_BUFFER, j);
+            rm.add(new QueryPath(columnFamilyName, null, ByteBufferUtil.bytes("0")), FBUtilities.EMPTY_BYTE_BUFFER, j);
             rm.apply();
             inserted.add(key);
             store.forceBlockingFlush();
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/ReadMessageTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/ReadMessageTest.java
index bef3e4d4..3e5ad826 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/ReadMessageTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/ReadMessageTest.java
@@ -34,6 +34,8 @@
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.commons.lang.ArrayUtils;
 import org.junit.Test;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class ReadMessageTest extends SchemaLoader
 {
@@ -41,8 +43,8 @@
     public void testMakeReadMessage() throws IOException
     {
         ArrayList<ByteBuffer> colList = new ArrayList<ByteBuffer>();
-        colList.add(ByteBuffer.wrap("col1".getBytes()));
-        colList.add(ByteBuffer.wrap("col2".getBytes()));
+        colList.add(ByteBufferUtil.bytes("col1"));
+        colList.add(ByteBufferUtil.bytes("col2"));
         
         ReadCommand rm, rm2;
         DecoratedKey dk = Util.dk("row1");
@@ -55,7 +57,7 @@ public void testMakeReadMessage() throws IOException
         rm2 = serializeAndDeserializeReadMessage(rm);
         assert rm2.toString().equals(rm.toString());
         
-        rm = new SliceFromReadCommand("Keyspace1", dk.key, new QueryPath("Standard1"), ByteBuffer.wrap("a".getBytes()), ByteBuffer.wrap("z".getBytes()), true, 5);
+        rm = new SliceFromReadCommand("Keyspace1", dk.key, new QueryPath("Standard1"), ByteBufferUtil.bytes("a"), ByteBufferUtil.bytes("z"), true, 5);
         rm2 = serializeAndDeserializeReadMessage(rm);
         assertEquals(rm2.toString(), rm.toString());
 
@@ -63,7 +65,7 @@ public void testMakeReadMessage() throws IOException
         rm2 = serializeAndDeserializeReadMessage(rm);
         assert rm2.toString().equals(rm.toString());
 
-        rm = new SliceFromReadCommand("Keyspace1", dk.key, new QueryPath("Standard1"), ByteBuffer.wrap("a".getBytes()), ByteBuffer.wrap("z".getBytes()), true, 5);
+        rm = new SliceFromReadCommand("Keyspace1", dk.key, new QueryPath("Standard1"), ByteBufferUtil.bytes("a"), ByteBufferUtil.bytes("z"), true, 5);
         rm2 = serializeAndDeserializeReadMessage(rm);
         assertEquals(rm2.toString(), rm.toString());
     }
@@ -88,12 +90,12 @@ public void testGetColumn() throws IOException, ColumnFamilyNotDefinedException
 
         // add data
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("Column1".getBytes())), ByteBuffer.wrap("abcd".getBytes()), 0);
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("Column1")), ByteBufferUtil.bytes("abcd"), 0);
         rm.apply();
 
-        ReadCommand command = new SliceByNamesReadCommand("Keyspace1", dk.key, new QueryPath("Standard1"), Arrays.asList(ByteBuffer.wrap("Column1".getBytes())));
+        ReadCommand command = new SliceByNamesReadCommand("Keyspace1", dk.key, new QueryPath("Standard1"), Arrays.asList(ByteBufferUtil.bytes("Column1")));
         Row row = command.getRow(table);
-        IColumn col = row.cf.getColumn(ByteBuffer.wrap("Column1".getBytes()));
+        IColumn col = row.cf.getColumn(ByteBufferUtil.bytes("Column1"));
         assert Arrays.equals(col.value().array(), "abcd".getBytes());  
     }
 }
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java
index f32c91d3..fed0fbad 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java
@@ -32,6 +32,7 @@
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.junit.Test;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 /**
  * Test for the truncate operation.
@@ -51,7 +52,7 @@ public void testTruncate() throws IOException, ExecutionException, InterruptedEx
 		ColumnFamily cf;
 
 		// trucate clears memtable
-		rm = new RowMutation("Keyspace1", ByteBuffer.wrap("keymulti".getBytes()));
+		rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("keymulti"));
 		cf = ColumnFamily.create("Keyspace1", "Standard1");
 		cf.addColumn(column("col1", "val1", 1L));
 		rm.add(cf);
@@ -68,7 +69,7 @@ public void testTruncate() throws IOException, ExecutionException, InterruptedEx
 		assertNull(getFromTable(table, "Standard1", "keymulti", "col1"));
 
 		// truncate clears sstable
-		rm = new RowMutation("Keyspace1", ByteBuffer.wrap("keymulti".getBytes()));
+		rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("keymulti"));
 		cf = ColumnFamily.create("Keyspace1", "Standard1");
 		cf.addColumn(column("col1", "val1", 1L));
 		rm.add(cf);
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnFamilyTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnFamilyTest.java
index d0647c72..3c27d12e 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnFamilyTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnFamilyTest.java
@@ -30,6 +30,8 @@
 
 import org.apache.cassandra.CleanupHelper;
 import org.apache.cassandra.Util;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class RemoveColumnFamilyTest extends CleanupHelper
 {
@@ -43,7 +45,7 @@ public void testRemoveColumnFamily() throws IOException, ExecutionException, Int
 
         // add data
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("Column1".getBytes())), ByteBuffer.wrap("asdf".getBytes()), 0);
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("Column1")), ByteBufferUtil.bytes("asdf"), 0);
         rm.apply();
 
         // remove
@@ -51,9 +53,9 @@ public void testRemoveColumnFamily() throws IOException, ExecutionException, Int
         rm.delete(new QueryPath("Standard1"), 1);
         rm.apply();
 
-        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Standard1", null, ByteBuffer.wrap("Column1".getBytes()))));
+        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Standard1", null, ByteBufferUtil.bytes("Column1"))));
         assert retrieved.isMarkedForDelete();
-        assertNull(retrieved.getColumn(ByteBuffer.wrap("Column1".getBytes())));
+        assertNull(retrieved.getColumn(ByteBufferUtil.bytes("Column1")));
         assertNull(Util.cloneAndRemoveDeleted(retrieved, Integer.MAX_VALUE));
     }
 }
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush1Test.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush1Test.java
index 6e039dac..fbf6690c 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush1Test.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush1Test.java
@@ -30,6 +30,8 @@
 
 import org.apache.cassandra.CleanupHelper;
 import org.apache.cassandra.Util;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class RemoveColumnFamilyWithFlush1Test extends CleanupHelper
 {
@@ -43,8 +45,8 @@ public void testRemoveColumnFamilyWithFlush1() throws IOException, ExecutionExce
 
         // add data
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("Column1".getBytes())), ByteBuffer.wrap("asdf".getBytes()), 0);
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("Column2".getBytes())), ByteBuffer.wrap("asdf".getBytes()), 0);
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("Column1")), ByteBufferUtil.bytes("asdf"), 0);
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("Column2")), ByteBufferUtil.bytes("asdf"), 0);
         rm.apply();
         store.forceBlockingFlush();
 
@@ -55,7 +57,7 @@ public void testRemoveColumnFamilyWithFlush1() throws IOException, ExecutionExce
 
         ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Standard1")));
         assert retrieved.isMarkedForDelete();
-        assertNull(retrieved.getColumn(ByteBuffer.wrap("Column1".getBytes())));
+        assertNull(retrieved.getColumn(ByteBufferUtil.bytes("Column1")));
         assertNull(Util.cloneAndRemoveDeleted(retrieved, Integer.MAX_VALUE));
     }
 }
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush2Test.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush2Test.java
index e2e93ee1..3bcd2423 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush2Test.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush2Test.java
@@ -30,6 +30,8 @@
 
 import org.apache.cassandra.CleanupHelper;
 import org.apache.cassandra.Util;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class RemoveColumnFamilyWithFlush2Test extends CleanupHelper
 {
@@ -43,7 +45,7 @@ public void testRemoveColumnFamilyWithFlush2() throws IOException, ExecutionExce
 
         // add data
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("Column1".getBytes())), ByteBuffer.wrap("asdf".getBytes()), 0);
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("Column1")), ByteBufferUtil.bytes("asdf"), 0);
         rm.apply();
         // remove
         rm = new RowMutation("Keyspace1", dk.key);
@@ -51,9 +53,9 @@ public void testRemoveColumnFamilyWithFlush2() throws IOException, ExecutionExce
         rm.apply();
         store.forceBlockingFlush();
 
-        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Standard1", null, ByteBuffer.wrap("Column1".getBytes()))));
+        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Standard1", null, ByteBufferUtil.bytes("Column1"))));
         assert retrieved.isMarkedForDelete();
-        assertNull(retrieved.getColumn(ByteBuffer.wrap("Column1".getBytes())));
+        assertNull(retrieved.getColumn(ByteBufferUtil.bytes("Column1")));
         assertNull(Util.cloneAndRemoveDeleted(retrieved, Integer.MAX_VALUE));
     }
 }
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnTest.java
index 34a38fc0..d65a9996 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveColumnTest.java
@@ -31,6 +31,8 @@
 
 import org.apache.cassandra.CleanupHelper;
 import org.apache.cassandra.Util;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class RemoveColumnTest extends CleanupHelper
 {
@@ -44,17 +46,17 @@ public void testRemoveColumn() throws IOException, ExecutionException, Interrupt
 
         // add data
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("Column1".getBytes())), ByteBuffer.wrap("asdf".getBytes()), 0);
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("Column1")), ByteBufferUtil.bytes("asdf"), 0);
         rm.apply();
         store.forceBlockingFlush();
 
         // remove
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.delete(new QueryPath("Standard1", null, ByteBuffer.wrap("Column1".getBytes())), 1);
+        rm.delete(new QueryPath("Standard1", null, ByteBufferUtil.bytes("Column1")), 1);
         rm.apply();
 
-        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Standard1"), ByteBuffer.wrap("Column1".getBytes())));
-        assert retrieved.getColumn(ByteBuffer.wrap("Column1".getBytes())).isMarkedForDelete();
+        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Standard1"), ByteBufferUtil.bytes("Column1")));
+        assert retrieved.getColumn(ByteBufferUtil.bytes("Column1")).isMarkedForDelete();
         assertNull(Util.cloneAndRemoveDeleted(retrieved, Integer.MAX_VALUE));
         assertNull(Util.cloneAndRemoveDeleted(store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Standard1"))), Integer.MAX_VALUE));
     }
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveSubColumnTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveSubColumnTest.java
index db6987b7..c3f43f3a 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveSubColumnTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveSubColumnTest.java
@@ -30,6 +30,8 @@
 import static org.apache.cassandra.Util.getBytes;
 import org.apache.cassandra.Util;
 import org.apache.cassandra.CleanupHelper;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class RemoveSubColumnTest extends CleanupHelper
 {
@@ -49,11 +51,11 @@ public void testRemoveSubColumn() throws IOException, ExecutionException, Interr
 
         // remove
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.delete(new QueryPath("Super1", ByteBuffer.wrap("SC1".getBytes()), getBytes(1)), 1);
+        rm.delete(new QueryPath("Super1", ByteBufferUtil.bytes("SC1"), getBytes(1)), 1);
         rm.apply();
 
-        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Super1", ByteBuffer.wrap("SC1".getBytes()))));
-        assert retrieved.getColumn(ByteBuffer.wrap("SC1".getBytes())).getSubColumn(getBytes(1)).isMarkedForDelete();
+        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Super1", ByteBufferUtil.bytes("SC1"))));
+        assert retrieved.getColumn(ByteBufferUtil.bytes("SC1")).getSubColumn(getBytes(1)).isMarkedForDelete();
         assertNull(Util.cloneAndRemoveDeleted(retrieved, Integer.MAX_VALUE));
     }
 }
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java
index f3f1f30b..ed7dddff 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java
@@ -35,6 +35,8 @@
 
 import org.apache.cassandra.CleanupHelper;
 import static junit.framework.Assert.assertNotNull;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class RemoveSuperColumnTest extends CleanupHelper
 {
@@ -53,7 +55,7 @@ public void testRemoveSuperColumn() throws IOException, ExecutionException, Inte
 
         // remove
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.delete(new QueryPath("Super1", ByteBuffer.wrap("SC1".getBytes())), 1);
+        rm.delete(new QueryPath("Super1", ByteBufferUtil.bytes("SC1")), 1);
         rm.apply();
 
         validateRemoveTwoSources(dk);
@@ -82,7 +84,7 @@ public void testRemoveDeletedSubColumn() throws IOException, ExecutionException,
 
         // remove
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.delete(new QueryPath("Super3", ByteBuffer.wrap("SC1".getBytes()), Util.getBytes(1)), 1);
+        rm.delete(new QueryPath("Super3", ByteBufferUtil.bytes("SC1"), Util.getBytes(1)), 1);
         rm.apply();
 
         validateRemoveSubColumn(dk);
@@ -94,20 +96,20 @@ public void testRemoveDeletedSubColumn() throws IOException, ExecutionException,
     private void validateRemoveSubColumn(DecoratedKey dk) throws IOException
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super3");
-        ColumnFamily cf = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super3", ByteBuffer.wrap("SC1".getBytes())), Util.getBytes(1)));
+        ColumnFamily cf = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super3", ByteBufferUtil.bytes("SC1")), Util.getBytes(1)));
         assertNull(Util.cloneAndRemoveDeleted(cf, Integer.MAX_VALUE));
-        cf = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super3", ByteBuffer.wrap("SC1".getBytes())), Util.getBytes(2)));
+        cf = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super3", ByteBufferUtil.bytes("SC1")), Util.getBytes(2)));
         assertNotNull(Util.cloneAndRemoveDeleted(cf, Integer.MAX_VALUE));
     }
 
     private void validateRemoveTwoSources(DecoratedKey dk) throws IOException
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super1");
-        ColumnFamily cf = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super1"), ByteBuffer.wrap("SC1".getBytes())));
+        ColumnFamily cf = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super1"), ByteBufferUtil.bytes("SC1")));
         assert cf.getSortedColumns().iterator().next().getMarkedForDeleteAt() == 1 : cf;
         assert cf.getSortedColumns().iterator().next().getSubColumns().size() == 0 : cf;
         assertNull(Util.cloneAndRemoveDeleted(cf, Integer.MAX_VALUE));
-        cf = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super1"), ByteBuffer.wrap("SC1".getBytes())));
+        cf = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super1"), ByteBufferUtil.bytes("SC1")));
         assertNull(Util.cloneAndRemoveDeleted(cf, Integer.MAX_VALUE));
         cf = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Super1")));
         assertNull(Util.cloneAndRemoveDeleted(cf, Integer.MAX_VALUE));
@@ -117,7 +119,7 @@ private void validateRemoveTwoSources(DecoratedKey dk) throws IOException
     private void validateRemoveCompacted(DecoratedKey dk) throws IOException
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super1");
-        ColumnFamily resolved = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super1"), ByteBuffer.wrap("SC1".getBytes())));
+        ColumnFamily resolved = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super1"), ByteBufferUtil.bytes("SC1")));
         assert resolved.getSortedColumns().iterator().next().getMarkedForDeleteAt() == 1;
         Collection<IColumn> subColumns = resolved.getSortedColumns().iterator().next().getSubColumns();
         assert subColumns.size() == 0;
@@ -138,7 +140,7 @@ public void testRemoveSuperColumnWithNewData() throws IOException, ExecutionExce
 
         // remove
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.delete(new QueryPath("Super2", ByteBuffer.wrap("SC1".getBytes())), 1);
+        rm.delete(new QueryPath("Super2", ByteBufferUtil.bytes("SC1")), 1);
         rm.apply();
 
         // new data
@@ -159,7 +161,7 @@ public void testRemoveSuperColumnWithNewData() throws IOException, ExecutionExce
     private void validateRemoveWithNewData(DecoratedKey dk) throws IOException
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super2");
-        ColumnFamily cf = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super2", ByteBuffer.wrap("SC1".getBytes())), getBytes(2)));
+        ColumnFamily cf = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super2", ByteBufferUtil.bytes("SC1")), getBytes(2)));
         Collection<IColumn> subColumns = cf.getSortedColumns().iterator().next().getSubColumns();
         assert subColumns.size() == 1;
         assert subColumns.iterator().next().timestamp() == 2;
@@ -179,9 +181,9 @@ public void testRemoveSuperColumnResurrection() throws IOException, ExecutionExc
 
         // remove
         rm = new RowMutation("Keyspace1", key.key);
-        rm.delete(new QueryPath("Super2", ByteBuffer.wrap("SC1".getBytes())), 1);
+        rm.delete(new QueryPath("Super2", ByteBufferUtil.bytes("SC1")), 1);
         rm.apply();
-        assertNull(Util.cloneAndRemoveDeleted(store.getColumnFamily(QueryFilter.getNamesFilter(key, new QueryPath("Super2"), ByteBuffer.wrap("SC1".getBytes()))), Integer.MAX_VALUE));
+        assertNull(Util.cloneAndRemoveDeleted(store.getColumnFamily(QueryFilter.getNamesFilter(key, new QueryPath("Super2"), ByteBufferUtil.bytes("SC1"))), Integer.MAX_VALUE));
 
         // resurrect
         rm = new RowMutation("Keyspace1", key.key);
@@ -189,7 +191,7 @@ public void testRemoveSuperColumnResurrection() throws IOException, ExecutionExc
         rm.apply();
 
         // validate
-        ColumnFamily cf = store.getColumnFamily(QueryFilter.getNamesFilter(key, new QueryPath("Super2"), ByteBuffer.wrap("SC1".getBytes())));
+        ColumnFamily cf = store.getColumnFamily(QueryFilter.getNamesFilter(key, new QueryPath("Super2"), ByteBufferUtil.bytes("SC1")));
         cf = Util.cloneAndRemoveDeleted(cf, Integer.MAX_VALUE);
         Collection<IColumn> subColumns = cf.getSortedColumns().iterator().next().getSubColumns();
         assert subColumns.size() == 1;
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RowIterationTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RowIterationTest.java
index dd805796..b8f75ae4 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RowIterationTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RowIterationTest.java
@@ -36,6 +36,8 @@
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.utils.FBUtilities;
 import static junit.framework.Assert.assertEquals;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class RowIterationTest extends CleanupHelper
 {
@@ -53,7 +55,7 @@ public void testRowIteration() throws IOException, ExecutionException, Interrupt
         for (int i = 0; i < ROWS_PER_SSTABLE; i++) {
             DecoratedKey key = Util.dk(String.valueOf(i));
             RowMutation rm = new RowMutation(TABLE1, key.key);
-            rm.add(new QueryPath("Super3", ByteBuffer.wrap("sc".getBytes()), ByteBuffer.wrap(String.valueOf(i).getBytes())), ByteBuffer.wrap(new byte[ROWS_PER_SSTABLE * 10 - i * 2]), i);
+            rm.add(new QueryPath("Super3", ByteBufferUtil.bytes("sc"), ByteBuffer.wrap(String.valueOf(i).getBytes())), ByteBuffer.wrap(new byte[ROWS_PER_SSTABLE * 10 - i * 2]), i);
             rm.apply();
             inserted.add(key);
         }
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RowTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RowTest.java
index 5a4f9ef9..d2ec2e0e 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RowTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/RowTest.java
@@ -28,6 +28,8 @@
 import static junit.framework.Assert.fail;
 import org.apache.cassandra.db.marshal.AsciiType;
 import static org.apache.cassandra.Util.column;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class RowTest extends SchemaLoader
 {
@@ -48,10 +50,10 @@ public void testDiffColumnFamily()
     @Test
     public void testDiffSuperColumn()
     {
-        SuperColumn sc1 = new SuperColumn(ByteBuffer.wrap("one".getBytes()), AsciiType.instance);
+        SuperColumn sc1 = new SuperColumn(ByteBufferUtil.bytes("one"), AsciiType.instance);
         sc1.addColumn(column("subcolumn", "A", 0));
 
-        SuperColumn sc2 = new SuperColumn(ByteBuffer.wrap("one".getBytes()), AsciiType.instance);
+        SuperColumn sc2 = new SuperColumn(ByteBufferUtil.bytes("one"), AsciiType.instance);
         sc2.markForDeleteAt(0, 0);
 
         SuperColumn scDiff = (SuperColumn)sc1.diff(sc2);
@@ -70,14 +72,14 @@ public void testResolve()
         cf2.addColumn(column("two", "C", 1));
 
         cf1.resolve(cf2);
-        assert Arrays.equals(cf1.getColumn(ByteBuffer.wrap("one".getBytes())).value().array(), "B".getBytes());
-        assert Arrays.equals(cf1.getColumn(ByteBuffer.wrap("two".getBytes())).value().array(), "C".getBytes());
+        assert Arrays.equals(cf1.getColumn(ByteBufferUtil.bytes("one")).value().array(), "B".getBytes());
+        assert Arrays.equals(cf1.getColumn(ByteBufferUtil.bytes("two")).value().array(), "C".getBytes());
     }
 
     @Test
     public void testExpiringColumnExpiration()
     {
-        Column c = new ExpiringColumn(ByteBuffer.wrap("one".getBytes()), ByteBuffer.wrap("A".getBytes()), 0, 1);
+        Column c = new ExpiringColumn(ByteBufferUtil.bytes("one"), ByteBufferUtil.bytes("A"), 0, 1);
         assert !c.isMarkedForDelete();
 
         try
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/SuperColumnTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/SuperColumnTest.java
index d5df8018..cbaf61ba 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/SuperColumnTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/SuperColumnTest.java
@@ -25,13 +25,15 @@
 import static junit.framework.Assert.assertNull;
 import static org.apache.cassandra.Util.getBytes;
 import org.apache.cassandra.db.marshal.LongType;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class SuperColumnTest
 {   
     @Test
     public void testMissingSubcolumn() {
-    	SuperColumn sc = new SuperColumn(ByteBuffer.wrap("sc1".getBytes()), LongType.instance);
-    	sc.addColumn(new Column(getBytes(1), ByteBuffer.wrap("value".getBytes()), 1));
+    	SuperColumn sc = new SuperColumn(ByteBufferUtil.bytes("sc1"), LongType.instance);
+    	sc.addColumn(new Column(getBytes(1), ByteBufferUtil.bytes("value"), 1));
     	assertNotNull(sc.getSubColumn(getBytes(1)));
     	assertNull(sc.getSubColumn(getBytes(2)));
     }
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/TableTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/TableTest.java
index 15c03340..ef852ba7 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/TableTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/TableTest.java
@@ -43,6 +43,8 @@
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.io.util.BufferedRandomAccessFile;
 import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class TableTest extends CleanupHelper
 {
@@ -81,7 +83,7 @@ public void runMayThrow() throws Exception
                 cf = cfStore.getColumnFamily(QueryFilter.getSliceFilter(TEST_KEY, new QueryPath("Standard3"), FBUtilities.EMPTY_BYTE_BUFFER, FBUtilities.EMPTY_BYTE_BUFFER, false, 0));
                 assertColumns(cf);
 
-                cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard3"), ByteBuffer.wrap("col99".getBytes())));
+                cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard3"), ByteBufferUtil.bytes("col99")));
                 assertColumns(cf);
             }
         };
@@ -108,10 +110,10 @@ public void runMayThrow() throws Exception
             {
                 ColumnFamily cf;
 
-                cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard1"), ByteBuffer.wrap("col1".getBytes())));
+                cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard1"), ByteBufferUtil.bytes("col1")));
                 assertColumns(cf, "col1");
 
-                cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard1"), ByteBuffer.wrap("col3".getBytes())));
+                cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(TEST_KEY, new QueryPath("Standard1"), ByteBufferUtil.bytes("col3")));
                 assertColumns(cf, "col3");
             }
         };
@@ -133,16 +135,16 @@ public void testGetRowSliceByRange() throws Throwable
         rm.add(cf);
         rm.apply();
         
-        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("b".getBytes()), ByteBuffer.wrap("c".getBytes()), false, 100);
+        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("b"), ByteBufferUtil.bytes("c"), false, 100);
         assertEquals(2, cf.getColumnCount());
         
-        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("b".getBytes()), ByteBuffer.wrap("b".getBytes()), false, 100);
+        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("b"), ByteBufferUtil.bytes("b"), false, 100);
         assertEquals(1, cf.getColumnCount());
         
-        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("b".getBytes()), ByteBuffer.wrap("c".getBytes()), false, 1);
+        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("b"), ByteBufferUtil.bytes("c"), false, 1);
         assertEquals(1, cf.getColumnCount());
         
-        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("c".getBytes()), ByteBuffer.wrap("b".getBytes()), false, 1);
+        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("c"), ByteBufferUtil.bytes("b"), false, 1);
         assertNull(cf);
     }
 
@@ -150,7 +152,7 @@ public void testGetRowSliceByRange() throws Throwable
     public void testGetSliceNoMatch() throws Throwable
     {
         Table table = Table.open("Keyspace1");
-        RowMutation rm = new RowMutation("Keyspace1", ByteBuffer.wrap("row1000".getBytes()));
+        RowMutation rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("row1000"));
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard2");
         cf.addColumn(column("col1", "val1", 1));
         rm.add(cf);
@@ -194,30 +196,30 @@ public void runMayThrow() throws Exception
                 assert DatabaseDescriptor.getColumnIndexSize() == 4096 : "Unexpected column index size, block boundaries won't be where tests expect them.";
 
                 // test forward, spanning a segment.
-                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col096".getBytes()), ByteBuffer.wrap("col099".getBytes()), false, 4);
+                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col096"), ByteBufferUtil.bytes("col099"), false, 4);
                 assertColumns(cf, "col096", "col097", "col098", "col099");
 
                 // test reversed, spanning a segment.
-                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col099".getBytes()), ByteBuffer.wrap("col096".getBytes()), true, 4);
+                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col099"), ByteBufferUtil.bytes("col096"), true, 4);
                 assertColumns(cf, "col096", "col097", "col098", "col099");
 
                 // test forward, within a segment.
-                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col100".getBytes()), ByteBuffer.wrap("col103".getBytes()), false, 4);
+                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col100"), ByteBufferUtil.bytes("col103"), false, 4);
                 assertColumns(cf, "col100", "col101", "col102", "col103");
 
                 // test reversed, within a segment.
-                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col103".getBytes()), ByteBuffer.wrap("col100".getBytes()), true, 4);
+                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col103"), ByteBufferUtil.bytes("col100"), true, 4);
                 assertColumns(cf, "col100", "col101", "col102", "col103");
 
                 // test forward from beginning, spanning a segment.
                 String[] strCols = new String[100]; // col000-col099
                 for (int i = 0; i < 100; i++)
                     strCols[i] = "col" + fmt.format(i);
-                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), FBUtilities.EMPTY_BYTE_BUFFER, ByteBuffer.wrap("col099".getBytes()), false, 100);
+                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), FBUtilities.EMPTY_BYTE_BUFFER, ByteBufferUtil.bytes("col099"), false, 100);
                 assertColumns(cf, strCols);
 
                 // test reversed, from end, spanning a segment.
-                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), FBUtilities.EMPTY_BYTE_BUFFER, ByteBuffer.wrap("col288".getBytes()), true, 12);
+                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), FBUtilities.EMPTY_BYTE_BUFFER, ByteBufferUtil.bytes("col288"), true, 12);
                 assertColumns(cf, "col288", "col289", "col290", "col291", "col292", "col293", "col294", "col295", "col296", "col297", "col298", "col299");
             }
         };
@@ -291,7 +293,7 @@ public void testGetSliceFromBasic() throws Throwable
         rm.apply();
 
         rm = new RowMutation("Keyspace1", ROW.key);
-        rm.delete(new QueryPath("Standard1", null, ByteBuffer.wrap("col4".getBytes())), 2L);
+        rm.delete(new QueryPath("Standard1", null, ByteBufferUtil.bytes("col4")), 2L);
         rm.apply();
 
         Runnable verify = new WrappedRunnable()
@@ -300,26 +302,26 @@ public void runMayThrow() throws Exception
             {
                 ColumnFamily cf;
 
-                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col5".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, false, 2);
+                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col5"), FBUtilities.EMPTY_BYTE_BUFFER, false, 2);
                 assertColumns(cf, "col5", "col7");
 
-                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col4".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, false, 2);
+                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col4"), FBUtilities.EMPTY_BYTE_BUFFER, false, 2);
                 assertColumns(cf, "col4", "col5", "col7");
                 assertColumns(ColumnFamilyStore.removeDeleted(cf, Integer.MAX_VALUE), "col5", "col7");
 
-                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col5".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, true, 2);
+                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col5"), FBUtilities.EMPTY_BYTE_BUFFER, true, 2);
                 assertColumns(cf, "col3", "col4", "col5");
 
-                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col6".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, true, 2);
+                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col6"), FBUtilities.EMPTY_BYTE_BUFFER, true, 2);
                 assertColumns(cf, "col3", "col4", "col5");
 
                 cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), FBUtilities.EMPTY_BYTE_BUFFER, FBUtilities.EMPTY_BYTE_BUFFER, true, 2);
                 assertColumns(cf, "col7", "col9");
 
-                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col95".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, false, 2);
+                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col95"), FBUtilities.EMPTY_BYTE_BUFFER, false, 2);
                 assertColumns(cf);
 
-                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col0".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, true, 2);
+                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col0"), FBUtilities.EMPTY_BYTE_BUFFER, true, 2);
                 assertColumns(cf);
             }
         };
@@ -361,11 +363,17 @@ public void runMayThrow() throws Exception
             {
                 ColumnFamily cf;
 
-                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBuffer.wrap("col2".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
+                cf = cfStore.getColumnFamily(ROW, new QueryPath("Standard1"), ByteBufferUtil.bytes("col2"), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
                 assertColumns(cf, "col2", "col3", "col4");
-                assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col2".getBytes())).value().array()), "valx");
-                assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col3".getBytes())).value().array()), "valx");
-                assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col4".getBytes())).value().array()), "val4");
+                
+                ByteBuffer col = cf.getColumn(ByteBufferUtil.bytes("col2")).value();
+                assertEquals(new String(col.array(),col.position(),col.remaining()), "valx");
+                
+                col = cf.getColumn(ByteBufferUtil.bytes("col3")).value();
+                assertEquals(new String(col.array(),col.position(),col.remaining()), "valx");
+                
+                col = cf.getColumn(ByteBufferUtil.bytes("col4")).value();
+                assertEquals(new String(col.array(),col.position(),col.remaining()), "val4");                              
             }
         };
 
@@ -409,44 +417,60 @@ private void validateSliceLarge(ColumnFamilyStore cfStore) throws IOException
     {
         DecoratedKey key = Util.dk("row3");
         ColumnFamily cf;
-        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("col1000".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
+        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col1000"), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
         assertColumns(cf, "col1000", "col1001", "col1002");
-        assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1000".getBytes())).value().array()), "v1000");
-        assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1001".getBytes())).value().array()), "v1001");
-        assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1002".getBytes())).value().array()), "v1002");
 
-        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("col1195".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
+        ByteBuffer col; 
+        col = cf.getColumn(ByteBufferUtil.bytes("col1000")).value();
+        assertEquals(new String(col.array(),col.position(),col.remaining()), "v1000");
+        col = cf.getColumn(ByteBufferUtil.bytes("col1001")).value();
+        assertEquals(new String(col.array(),col.position(),col.remaining()), "v1001");
+        col = cf.getColumn(ByteBufferUtil.bytes("col1002")).value();
+        assertEquals(new String(col.array(),col.position(),col.remaining()), "v1002");
+        
+        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col1195"), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
         assertColumns(cf, "col1195", "col1196", "col1197");
-        assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1195".getBytes())).value().array()), "v1195");
-        assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1196".getBytes())).value().array()), "v1196");
-        assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1197".getBytes())).value().array()), "v1197");
 
-        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("col1996".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, true, 1000);
+        col = cf.getColumn(ByteBufferUtil.bytes("col1195")).value();
+        assertEquals(new String(col.array(),col.position(),col.remaining()), "v1195");
+        col = cf.getColumn(ByteBufferUtil.bytes("col1196")).value();
+        assertEquals(new String(col.array(),col.position(),col.remaining()), "v1196");
+        col = cf.getColumn(ByteBufferUtil.bytes("col1197")).value();
+        assertEquals(new String(col.array(),col.position(),col.remaining()), "v1197");
+        
+       
+        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col1996"), FBUtilities.EMPTY_BYTE_BUFFER, true, 1000);
         IColumn[] columns = cf.getSortedColumns().toArray(new IColumn[0]);
         for (int i = 1000; i < 1996; i++)
         {
             String expectedName = "col" + i;
             IColumn column = columns[i - 1000];
-            assert Arrays.equals(column.name().array(), expectedName.getBytes()) : cfStore.getComparator().getString(column.name()) + " is not " + expectedName;
-            assert Arrays.equals(column.value().array(), ("v" + i).getBytes());
+            assertEquals(new String(column.name().array(), column.name().position(),column.name().remaining()), expectedName); 
+            assertEquals(new String(column.value().array(), column.value().position(),column.value().remaining()), ("v" + i));
         }
 
-        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("col1990".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
+        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col1990"), FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
         assertColumns(cf, "col1990", "col1991", "col1992");
-        assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1990".getBytes())).value().array()), "v1990");
-        assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1991".getBytes())).value().array()), "v1991");
-        assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1992".getBytes())).value().array()), "v1992");
+        col = cf.getColumn(ByteBufferUtil.bytes("col1990")).value();
+        assertEquals(new String(col.array(),col.position(),col.remaining()), "v1990");
+        col = cf.getColumn(ByteBufferUtil.bytes("col1991")).value();
+        assertEquals(new String(col.array(),col.position(),col.remaining()), "v1991");
+        col = cf.getColumn(ByteBufferUtil.bytes("col1992")).value();
+        assertEquals(new String(col.array(),col.position(),col.remaining()), "v1992");
 
         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), FBUtilities.EMPTY_BYTE_BUFFER, FBUtilities.EMPTY_BYTE_BUFFER, true, 3);
         assertColumns(cf, "col1997", "col1998", "col1999");
-        assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1999".getBytes())).value().array()), "v1999");
-        assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1998".getBytes())).value().array()), "v1998");
-        assertEquals(new String(cf.getColumn(ByteBuffer.wrap("col1997".getBytes())).value().array()), "v1997");
-
-        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("col9000".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER, true, 3);
+        col = cf.getColumn(ByteBufferUtil.bytes("col1997")).value();
+        assertEquals(new String(col.array(),col.position(),col.remaining()), "v1997");
+        col = cf.getColumn(ByteBufferUtil.bytes("col1998")).value();
+        assertEquals(new String(col.array(),col.position(),col.remaining()), "v1998");
+        col = cf.getColumn(ByteBufferUtil.bytes("col1999")).value();
+        assertEquals(new String(col.array(),col.position(),col.remaining()), "v1999");
+
+        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col9000"), FBUtilities.EMPTY_BYTE_BUFFER, true, 3);
         assertColumns(cf, "col1997", "col1998", "col1999");
 
-        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBuffer.wrap("col9000".getBytes()),FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
+        cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), ByteBufferUtil.bytes("col9000"),FBUtilities.EMPTY_BYTE_BUFFER, false, 3);
         assertColumns(cf);
     }
 
@@ -460,8 +484,8 @@ public void testGetSliceFromSuperBasic() throws Throwable
 
         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Super1");
-        SuperColumn sc = new SuperColumn(ByteBuffer.wrap("sc1".getBytes()), LongType.instance);
-        sc.addColumn(new Column(getBytes(1), ByteBuffer.wrap("val1".getBytes()), 1L));
+        SuperColumn sc = new SuperColumn(ByteBufferUtil.bytes("sc1"), LongType.instance);
+        sc.addColumn(new Column(getBytes(1), ByteBufferUtil.bytes("val1"), 1L));
         cf.addColumn(sc);
         rm.add(cf);
         rm.apply();
@@ -472,7 +496,10 @@ public void runMayThrow() throws Exception
             {
                 ColumnFamily cf = cfStore.getColumnFamily(ROW, new QueryPath("Super1"), FBUtilities.EMPTY_BYTE_BUFFER, FBUtilities.EMPTY_BYTE_BUFFER, false, 10);
                 assertColumns(cf, "sc1");
-                assertEquals(new String(cf.getColumn(ByteBuffer.wrap("sc1".getBytes())).getSubColumn(getBytes(1)).value().array()), "val1");
+                
+                ByteBuffer val = cf.getColumn(ByteBufferUtil.bytes("sc1")).getSubColumn(getBytes(1)).value();
+                
+                assertEquals(new String(val.array(),val.position(),val.remaining()), "val1");
             }
         };
 
@@ -485,7 +512,7 @@ public static void assertColumns(ColumnFamily cf, String... columnNames)
         List<String> L = new ArrayList<String>();
         for (IColumn column : columns)
         {
-            L.add(new String(column.name().array()));
+            L.add(new String(column.name().array(),column.name().position(),column.name().remaining()));
         }
 
         List<String> names = new ArrayList<String>(columnNames.length);
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/TimeSortTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/TimeSortTest.java
index 8bf4cf1d..ca56915f 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/TimeSortTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/TimeSortTest.java
@@ -36,6 +36,8 @@
 import org.apache.cassandra.db.filter.NamesQueryFilter;
 import org.apache.cassandra.db.marshal.LongType;
 import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.utils.ByteBufferUtil;
+
 
 public class TimeSortTest extends CleanupHelper
 {
@@ -48,12 +50,12 @@ public void testMixedSources() throws IOException, ExecutionException, Interrupt
         DecoratedKey key = Util.dk("key0");
 
         rm = new RowMutation("Keyspace1", key.key);
-        rm.add(new QueryPath("StandardLong1", null, getBytes(100)), ByteBuffer.wrap("a".getBytes()), 100);
+        rm.add(new QueryPath("StandardLong1", null, getBytes(100)), ByteBufferUtil.bytes("a"), 100);
         rm.apply();
         cfStore.forceBlockingFlush();
 
         rm = new RowMutation("Keyspace1", key.key);
-        rm.add(new QueryPath("StandardLong1", null, getBytes(0)), ByteBuffer.wrap("b".getBytes()), 0);
+        rm.add(new QueryPath("StandardLong1", null, getBytes(0)), ByteBufferUtil.bytes("b"), 0);
         rm.apply();
 
         ColumnFamily cf = cfStore.getColumnFamily(key, new QueryPath("StandardLong1"), getBytes(10), FBUtilities.EMPTY_BYTE_BUFFER, false, 1000);
@@ -72,7 +74,7 @@ public void testTimeSort() throws IOException, ExecutionException, InterruptedEx
             RowMutation rm = new RowMutation("Keyspace1", ByteBuffer.wrap(Integer.toString(i).getBytes()));
             for (int j = 0; j < 8; ++j)
             {
-                rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2)), ByteBuffer.wrap("a".getBytes()), j * 2);
+                rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2)), ByteBufferUtil.bytes("a"), j * 2);
             }
             rm.apply();
         }
@@ -87,13 +89,13 @@ public void testTimeSort() throws IOException, ExecutionException, InterruptedEx
         RowMutation rm = new RowMutation("Keyspace1", key.key);
         for (int j = 0; j < 4; ++j)
         {
-            rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2 + 1)), ByteBuffer.wrap("b".getBytes()), j * 2 + 1);
+            rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2 + 1)), ByteBufferUtil.bytes("b"), j * 2 + 1);
         }
         rm.apply();
         // and some overwrites
         rm = new RowMutation("Keyspace1", key.key);
-        rm.add(new QueryPath("StandardLong1", null, getBytes(0)), ByteBuffer.wrap("c".getBytes()), 100);
-        rm.add(new QueryPath("StandardLong1", null, getBytes(10)), ByteBuffer.wrap("c".getBytes()), 100);
+        rm.add(new QueryPath("StandardLong1", null, getBytes(0)), ByteBufferUtil.bytes("c"), 100);
+        rm.add(new QueryPath("StandardLong1", null, getBytes(10)), ByteBufferUtil.bytes("c"), 100);
         rm.apply();
 
         // verify
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/marshal/TypeCompareTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/marshal/TypeCompareTest.java
index 924fcfee..893b1365 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/marshal/TypeCompareTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/db/marshal/TypeCompareTest.java
@@ -39,38 +39,38 @@
     public void testAscii()
     {
         AsciiType comparator = new AsciiType();
-        assert comparator.compare(FBUtilities.EMPTY_BYTE_BUFFER, ByteBuffer.wrap("asdf".getBytes())) < 0;
-        assert comparator.compare(ByteBuffer.wrap("asdf".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER) > 0;
+        assert comparator.compare(FBUtilities.EMPTY_BYTE_BUFFER, ByteBufferUtil.bytes("asdf")) < 0;
+        assert comparator.compare(ByteBufferUtil.bytes("asdf"), FBUtilities.EMPTY_BYTE_BUFFER) > 0;
         assert comparator.compare(FBUtilities.EMPTY_BYTE_BUFFER, FBUtilities.EMPTY_BYTE_BUFFER) == 0;
-        assert comparator.compare(ByteBuffer.wrap("z".getBytes()), ByteBuffer.wrap("a".getBytes())) > 0;
-        assert comparator.compare(ByteBuffer.wrap("a".getBytes()), ByteBuffer.wrap("z".getBytes())) < 0;
-        assert comparator.compare(ByteBuffer.wrap("asdf".getBytes()), ByteBuffer.wrap("asdf".getBytes())) == 0;
-        assert comparator.compare(ByteBuffer.wrap("asdz".getBytes()), ByteBuffer.wrap("asdf".getBytes())) > 0;
+        assert comparator.compare(ByteBufferUtil.bytes("z"), ByteBufferUtil.bytes("a")) > 0;
+        assert comparator.compare(ByteBufferUtil.bytes("a"), ByteBufferUtil.bytes("z")) < 0;
+        assert comparator.compare(ByteBufferUtil.bytes("asdf"), ByteBufferUtil.bytes("asdf")) == 0;
+        assert comparator.compare(ByteBufferUtil.bytes("asdz"), ByteBufferUtil.bytes("asdf")) > 0;
     }
 
     @Test
     public void testBytes()
     {
         BytesType comparator = new BytesType();
-        assert comparator.compare(FBUtilities.EMPTY_BYTE_BUFFER, ByteBuffer.wrap("asdf".getBytes())) < 0;
-        assert comparator.compare(ByteBuffer.wrap("asdf".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER) > 0;
+        assert comparator.compare(FBUtilities.EMPTY_BYTE_BUFFER, ByteBufferUtil.bytes("asdf")) < 0;
+        assert comparator.compare(ByteBufferUtil.bytes("asdf"), FBUtilities.EMPTY_BYTE_BUFFER) > 0;
         assert comparator.compare(FBUtilities.EMPTY_BYTE_BUFFER, FBUtilities.EMPTY_BYTE_BUFFER) == 0;
-        assert comparator.compare(ByteBuffer.wrap("z".getBytes()), ByteBuffer.wrap("a".getBytes())) > 0;
-        assert comparator.compare(ByteBuffer.wrap("a".getBytes()), ByteBuffer.wrap("z".getBytes())) < 0;
-        assert comparator.compare(ByteBuffer.wrap("asdf".getBytes()), ByteBuffer.wrap("asdf".getBytes())) == 0;
-        assert comparator.compare(ByteBuffer.wrap("asdz".getBytes()), ByteBuffer.wrap("asdf".getBytes())) > 0;
+        assert comparator.compare(ByteBufferUtil.bytes("z"), ByteBufferUtil.bytes("a")) > 0;
+        assert comparator.compare(ByteBufferUtil.bytes("a"), ByteBufferUtil.bytes("z")) < 0;
+        assert comparator.compare(ByteBufferUtil.bytes("asdf"), ByteBufferUtil.bytes("asdf")) == 0;
+        assert comparator.compare(ByteBufferUtil.bytes("asdz"), ByteBufferUtil.bytes("asdf")) > 0;
     }
 
     @Test
     public void testUTF8()
     {
         UTF8Type comparator = new UTF8Type();
-        assert comparator.compare(FBUtilities.EMPTY_BYTE_BUFFER, ByteBuffer.wrap("asdf".getBytes())) < 0;
-        assert comparator.compare(ByteBuffer.wrap("asdf".getBytes()), FBUtilities.EMPTY_BYTE_BUFFER) > 0;
+        assert comparator.compare(FBUtilities.EMPTY_BYTE_BUFFER, ByteBufferUtil.bytes("asdf")) < 0;
+        assert comparator.compare(ByteBufferUtil.bytes("asdf"), FBUtilities.EMPTY_BYTE_BUFFER) > 0;
         assert comparator.compare(FBUtilities.EMPTY_BYTE_BUFFER, FBUtilities.EMPTY_BYTE_BUFFER) == 0;
-        assert comparator.compare(ByteBuffer.wrap("z".getBytes(Charsets.UTF_8)), ByteBuffer.wrap("a".getBytes(Charsets.UTF_8))) > 0;
-        assert comparator.compare(ByteBuffer.wrap("z".getBytes(Charsets.UTF_8)), ByteBuffer.wrap("z".getBytes(Charsets.UTF_8))) == 0;
-        assert comparator.compare(ByteBuffer.wrap("a".getBytes(Charsets.UTF_8)), ByteBuffer.wrap("z".getBytes(Charsets.UTF_8))) < 0;
+        assert comparator.compare(ByteBufferUtil.bytes("z"), ByteBufferUtil.bytes("a")) > 0;
+        assert comparator.compare(ByteBufferUtil.bytes("z"), ByteBufferUtil.bytes("z")) == 0;
+        assert comparator.compare(ByteBufferUtil.bytes("a"), ByteBufferUtil.bytes("z")) < 0;
     }
 
     @Test
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/io/LazilyCompactedRowTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/io/LazilyCompactedRowTest.java
index 60f51a93..9f1b50f1 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/io/LazilyCompactedRowTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/io/LazilyCompactedRowTest.java
@@ -43,6 +43,7 @@
 import org.apache.cassandra.io.sstable.IndexHelper;
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.io.util.DataOutputBuffer;
+import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.junit.Test;
 
@@ -121,9 +122,9 @@ public void testOneRow() throws IOException, ExecutionException, InterruptedExce
         Table table = Table.open("Keyspace1");
         ColumnFamilyStore cfs = table.getColumnFamilyStore("Standard1");
 
-        ByteBuffer key = ByteBuffer.wrap("k".getBytes());
+        ByteBuffer key = ByteBufferUtil.bytes("k");
         RowMutation rm = new RowMutation("Keyspace1", key);
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("c".getBytes())), FBUtilities.EMPTY_BYTE_BUFFER, 0);
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("c")), FBUtilities.EMPTY_BYTE_BUFFER, 0);
         rm.apply();
         cfs.forceBlockingFlush();
 
@@ -140,8 +141,8 @@ public void testOneRowTwoColumns() throws IOException, ExecutionException, Inter
 
         ByteBuffer key =ByteBuffer.wrap( "k".getBytes() );
         RowMutation rm = new RowMutation("Keyspace1", key);
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("c".getBytes())), FBUtilities.EMPTY_BYTE_BUFFER, 0);
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("d".getBytes())), FBUtilities.EMPTY_BYTE_BUFFER, 0);
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("c")), FBUtilities.EMPTY_BYTE_BUFFER, 0);
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("d")), FBUtilities.EMPTY_BYTE_BUFFER, 0);
         rm.apply();
         cfs.forceBlockingFlush();
 
@@ -156,9 +157,9 @@ public void testTwoRows() throws IOException, ExecutionException, InterruptedExc
         Table table = Table.open("Keyspace1");
         ColumnFamilyStore cfs = table.getColumnFamilyStore("Standard1");
 
-        ByteBuffer key = ByteBuffer.wrap("k".getBytes());
+        ByteBuffer key = ByteBufferUtil.bytes("k");
         RowMutation rm = new RowMutation("Keyspace1", key);
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("c".getBytes())), FBUtilities.EMPTY_BYTE_BUFFER, 0);
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("c")), FBUtilities.EMPTY_BYTE_BUFFER, 0);
         rm.apply();
         cfs.forceBlockingFlush();
 
@@ -176,10 +177,10 @@ public void testTwoRowsTwoColumns() throws IOException, ExecutionException, Inte
         Table table = Table.open("Keyspace1");
         ColumnFamilyStore cfs = table.getColumnFamilyStore("Standard1");
 
-        ByteBuffer key = ByteBuffer.wrap("k".getBytes());
+        ByteBuffer key = ByteBufferUtil.bytes("k");
         RowMutation rm = new RowMutation("Keyspace1", key);
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("c".getBytes())), FBUtilities.EMPTY_BYTE_BUFFER, 0);
-        rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("d".getBytes())), FBUtilities.EMPTY_BYTE_BUFFER, 0);
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("c")), FBUtilities.EMPTY_BYTE_BUFFER, 0);
+        rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("d")), FBUtilities.EMPTY_BYTE_BUFFER, 0);
         rm.apply();
         cfs.forceBlockingFlush();
 
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
index a0187f51..989b7185 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
@@ -38,6 +38,7 @@
 import org.apache.cassandra.io.util.FileDataInput;
 import org.apache.cassandra.io.util.MmappedSegmentedFile;
 import org.apache.cassandra.service.StorageService;
+import org.apache.cassandra.utils.ByteBufferUtil;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.Pair;
 
@@ -64,7 +65,7 @@ public void testGetPositionsForRanges() throws IOException, ExecutionException,
         {
             ByteBuffer key = ByteBuffer.wrap(String.valueOf(j).getBytes());
             RowMutation rm = new RowMutation("Keyspace1", key);
-            rm.add(new QueryPath("Standard2", null, ByteBuffer.wrap("0".getBytes())), FBUtilities.EMPTY_BYTE_BUFFER, j);
+            rm.add(new QueryPath("Standard2", null, ByteBufferUtil.bytes("0")), FBUtilities.EMPTY_BYTE_BUFFER, j);
             rm.apply();
         }
         store.forceBlockingFlush();
@@ -105,7 +106,7 @@ public void testSpannedIndexPositions() throws IOException, ExecutionException,
         {
             ByteBuffer key = ByteBuffer.wrap(String.valueOf(j).getBytes());
             RowMutation rm = new RowMutation("Keyspace1", key);
-            rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("0".getBytes())), FBUtilities.EMPTY_BYTE_BUFFER, j);
+            rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("0")), FBUtilities.EMPTY_BYTE_BUFFER, j);
             rm.apply();
         }
         store.forceBlockingFlush();
@@ -142,7 +143,7 @@ public void testPersistentStatistics() throws IOException, ExecutionException, I
         {
             ByteBuffer key = ByteBuffer.wrap(String.valueOf(j).getBytes());
             RowMutation rm = new RowMutation("Keyspace1", key);
-            rm.add(new QueryPath("Standard1", null, ByteBuffer.wrap("0".getBytes())), FBUtilities.EMPTY_BYTE_BUFFER, j);
+            rm.add(new QueryPath("Standard1", null, ByteBufferUtil.bytes("0")), FBUtilities.EMPTY_BYTE_BUFFER, j);
             rm.apply();
         }
         store.forceBlockingFlush();
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/io/sstable/SSTableWriterTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/io/sstable/SSTableWriterTest.java
index cbdcb17c..d5242c6a 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/io/sstable/SSTableWriterTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/io/sstable/SSTableWriterTest.java
@@ -46,6 +46,7 @@
 import org.apache.cassandra.thrift.IndexOperator;
 import org.apache.cassandra.utils.FBUtilities;
 import org.junit.Test;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 public class SSTableWriterTest extends CleanupHelper {
 
@@ -54,25 +55,25 @@ public void testRecoverAndOpen() throws IOException, ExecutionException, Interru
     {
         RowMutation rm;
 
-        rm = new RowMutation("Keyspace1", ByteBuffer.wrap("k1".getBytes()));
-        rm.add(new QueryPath("Indexed1", null, ByteBuffer.wrap("birthdate".getBytes("UTF8"))), FBUtilities.toByteBuffer(1L), 0);
+        rm = new RowMutation("Keyspace1", ByteBufferUtil.bytes("k1"));
+        rm.add(new QueryPath("Indexed1", null, ByteBufferUtil.bytes("birthdate")), FBUtilities.toByteBuffer(1L), 0);
         rm.apply();
         
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Indexed1");        
-        cf.addColumn(new Column(ByteBuffer.wrap("birthdate".getBytes()), FBUtilities.toByteBuffer(1L), 0));
-        cf.addColumn(new Column(ByteBuffer.wrap("anydate".getBytes()), FBUtilities.toByteBuffer(1L), 0));
+        cf.addColumn(new Column(ByteBufferUtil.bytes("birthdate"), FBUtilities.toByteBuffer(1L), 0));
+        cf.addColumn(new Column(ByteBufferUtil.bytes("anydate"), FBUtilities.toByteBuffer(1L), 0));
         
         Map<ByteBuffer, ByteBuffer> entries = new HashMap<ByteBuffer, ByteBuffer>();
         
         DataOutputBuffer buffer = new DataOutputBuffer();
         ColumnFamily.serializer().serializeWithIndexes(cf, buffer);
-        entries.put(ByteBuffer.wrap("k2".getBytes()), ByteBuffer.wrap(Arrays.copyOf(buffer.getData(), buffer.getLength())));        
+        entries.put(ByteBufferUtil.bytes("k2"), ByteBuffer.wrap(Arrays.copyOf(buffer.getData(), buffer.getLength())));        
         cf.clear();
         
-        cf.addColumn(new Column(ByteBuffer.wrap("anydate".getBytes()), FBUtilities.toByteBuffer(1L), 0));
+        cf.addColumn(new Column(ByteBufferUtil.bytes("anydate"), FBUtilities.toByteBuffer(1L), 0));
         buffer = new DataOutputBuffer();
         ColumnFamily.serializer().serializeWithIndexes(cf, buffer);               
-        entries.put(ByteBuffer.wrap("k3".getBytes()), ByteBuffer.wrap(Arrays.copyOf(buffer.getData(), buffer.getLength())));
+        entries.put(ByteBufferUtil.bytes("k3"), ByteBuffer.wrap(Arrays.copyOf(buffer.getData(), buffer.getLength())));
         
         SSTableReader orig = SSTableUtils.writeRawSSTable("Keyspace1", "Indexed1", entries);        
         // whack the index to trigger the recover
@@ -84,7 +85,7 @@ public void testRecoverAndOpen() throws IOException, ExecutionException, Interru
         cfs.addSSTable(sstr);
         cfs.buildSecondaryIndexes(cfs.getSSTables(), cfs.getIndexedColumns());
         
-        IndexExpression expr = new IndexExpression(ByteBuffer.wrap("birthdate".getBytes("UTF8")), IndexOperator.EQ, FBUtilities.toByteBuffer(1L));
+        IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexOperator.EQ, FBUtilities.toByteBuffer(1L));
         IndexClause clause = new IndexClause(Arrays.asList(expr), FBUtilities.EMPTY_BYTE_BUFFER, 100);
         IFilter filter = new IdentityQueryFilter();
         IPartitioner p = StorageService.getPartitioner();
@@ -92,6 +93,6 @@ public void testRecoverAndOpen() throws IOException, ExecutionException, Interru
         List<Row> rows = cfs.scan(clause, range, filter);
         
         assertEquals("IndexExpression should return two rows on recoverAndOpen", 2, rows.size());
-        assertTrue("First result should be 'k1'",ByteBuffer.wrap("k1".getBytes()).equals(rows.get(0).key.key));
+        assertTrue("First result should be 'k1'",ByteBufferUtil.bytes("k1").equals(rows.get(0).key.key));
     }
 }
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
index 69dd069e..1557e8b6 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
@@ -51,6 +51,7 @@
 import static org.apache.cassandra.service.AntiEntropyService.*;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 public class AntiEntropyServiceTest extends CleanupHelper
 {
@@ -103,8 +104,8 @@ public void testValidatorPrepare() throws Throwable
         // write
         List<RowMutation> rms = new LinkedList<RowMutation>();
         RowMutation rm;
-        rm = new RowMutation(tablename, ByteBuffer.wrap("key1".getBytes()));
-        rm.add(new QueryPath(cfname, null, ByteBuffer.wrap("Column1".getBytes())), ByteBuffer.wrap("asdf".getBytes()), 0);
+        rm = new RowMutation(tablename, ByteBufferUtil.bytes("key1"));
+        rm.add(new QueryPath(cfname, null, ByteBufferUtil.bytes("Column1")), ByteBufferUtil.bytes("asdf"), 0);
         rms.add(rm);
         Util.writeColumnFamily(rms);
 
@@ -138,11 +139,11 @@ public void testValidatorAdd() throws Throwable
         validator.prepare(store);
 
         // add a row with the minimum token
-        validator.add(new PrecompactedRow(new DecoratedKey(min, ByteBuffer.wrap("nonsense!".getBytes(UTF_8))),
+        validator.add(new PrecompactedRow(new DecoratedKey(min, ByteBufferUtil.bytes("nonsense!")),
                                        new DataOutputBuffer()));
 
         // and a row after it
-        validator.add(new PrecompactedRow(new DecoratedKey(mid, ByteBuffer.wrap("inconceivable!".getBytes(UTF_8))),
+        validator.add(new PrecompactedRow(new DecoratedKey(mid, ByteBufferUtil.bytes("inconceivable!")),
                                        new DataOutputBuffer()));
         validator.complete();
 
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/service/EmbeddedCassandraServiceTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/service/EmbeddedCassandraServiceTest.java
index 97e1dc38..41439018 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/service/EmbeddedCassandraServiceTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/service/EmbeddedCassandraServiceTest.java
@@ -40,6 +40,7 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 /**
  * Example how to use an embedded cassandra service.
@@ -89,15 +90,15 @@ public void testEmbeddedCassandraService() throws AuthenticationException, Autho
         Cassandra.Client client = getClient();
         client.set_keyspace("Keyspace1");
 
-        ByteBuffer key_user_id = ByteBuffer.wrap("1".getBytes());
+        ByteBuffer key_user_id = ByteBufferUtil.bytes("1");
         
         long timestamp = System.currentTimeMillis();
         ColumnPath cp = new ColumnPath("Standard1");
         ColumnParent par = new ColumnParent("Standard1");
-        cp.column = ByteBuffer.wrap("name".getBytes(Charsets.UTF_8));
+        cp.column = ByteBufferUtil.bytes("name");
 
         // insert
-        client.insert(key_user_id, par, new Column(ByteBuffer.wrap("name".getBytes(Charsets.UTF_8)),
+        client.insert(key_user_id, par, new Column(ByteBufferUtil.bytes("name"),
                 ByteBuffer.wrap( "Ran".getBytes(Charsets.UTF_8)), timestamp), ConsistencyLevel.ONE);
 
         // read
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
index 60c52105..f352c195 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/streaming/StreamingTransferTest.java
@@ -45,6 +45,7 @@
 
 import org.junit.BeforeClass;
 import org.junit.Test;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 public class StreamingTransferTest extends CleanupHelper
 {
@@ -69,7 +70,7 @@ public void testTransferTable() throws Exception
             RowMutation rm = new RowMutation("Keyspace1", ByteBuffer.wrap(key.getBytes()));
             ColumnFamily cf = ColumnFamily.create(table.name, cfs.columnFamily);
             cf.addColumn(column(key, "v", 0));
-            cf.addColumn(new Column(ByteBuffer.wrap("birthdate".getBytes("UTF8")), FBUtilities.toByteBuffer((long) i), 0));
+            cf.addColumn(new Column(ByteBufferUtil.bytes("birthdate"), FBUtilities.toByteBuffer((long) i), 0));
             rm.add(cf);
             rm.apply();
         }
@@ -81,8 +82,8 @@ public void testTransferTable() throws Exception
         // transfer the first and last key
         IPartitioner p = StorageService.getPartitioner();
         List<Range> ranges = new ArrayList<Range>();
-        ranges.add(new Range(p.getMinimumToken(), p.getToken(ByteBuffer.wrap("key1".getBytes()))));
-        ranges.add(new Range(p.getToken(ByteBuffer.wrap("key2".getBytes())), p.getMinimumToken()));
+        ranges.add(new Range(p.getMinimumToken(), p.getToken(ByteBufferUtil.bytes("key1"))));
+        ranges.add(new Range(p.getToken(ByteBufferUtil.bytes("key2")), p.getMinimumToken()));
         StreamOutSession session = StreamOutSession.create(table.name, LOCAL, null);
         StreamOut.transferSSTables(session, Arrays.asList(sstable), ranges);
         session.await();
@@ -90,24 +91,24 @@ public void testTransferTable() throws Exception
         // confirm that the SSTable was transferred and registered
         List<Row> rows = Util.getRangeSlice(cfs);
         assertEquals(2, rows.size());
-        assert rows.get(0).key.key.equals( ByteBuffer.wrap("key1".getBytes()));
-        assert rows.get(1).key.key.equals( ByteBuffer.wrap("key3".getBytes()));
+        assert rows.get(0).key.key.equals( ByteBufferUtil.bytes("key1"));
+        assert rows.get(1).key.key.equals( ByteBufferUtil.bytes("key3"));
         assertEquals(2, rows.get(0).cf.getColumnsMap().size());
         assertEquals(2, rows.get(1).cf.getColumnsMap().size());
-        assert rows.get(1).cf.getColumn(ByteBuffer.wrap("key3".getBytes())) != null;
+        assert rows.get(1).cf.getColumn(ByteBufferUtil.bytes("key3")) != null;
 
         // and that the index and filter were properly recovered
         assert null != cfs.getColumnFamily(QueryFilter.getIdentityFilter(Util.dk("key1"), new QueryPath(cfs.columnFamily)));
         assert null != cfs.getColumnFamily(QueryFilter.getIdentityFilter(Util.dk("key3"), new QueryPath(cfs.columnFamily)));
 
         // and that the secondary index works
-        IndexExpression expr = new IndexExpression(ByteBuffer.wrap("birthdate".getBytes("UTF8")), IndexOperator.EQ, FBUtilities.toByteBuffer(3L));
+        IndexExpression expr = new IndexExpression(ByteBufferUtil.bytes("birthdate"), IndexOperator.EQ, FBUtilities.toByteBuffer(3L));
         IndexClause clause = new IndexClause(Arrays.asList(expr), FBUtilities.EMPTY_BYTE_BUFFER, 100);
         IFilter filter = new IdentityQueryFilter();
         Range range = new Range(p.getMinimumToken(), p.getMinimumToken());
         rows = cfs.scan(clause, range, filter);
         assertEquals(1, rows.size());
-        assert rows.get(0).key.key.equals( ByteBuffer.wrap("key3".getBytes())) ;
+        assert rows.get(0).key.key.equals( ByteBufferUtil.bytes("key3")) ;
     }
 
     @Test
@@ -131,8 +132,8 @@ public void testTransferTableMultiple() throws Exception
         // transfer the first and last key
         IPartitioner p = StorageService.getPartitioner();
         List<Range> ranges = new ArrayList<Range>();
-        ranges.add(new Range(p.getMinimumToken(), p.getToken(ByteBuffer.wrap("transfer1".getBytes()))));
-        ranges.add(new Range(p.getToken(ByteBuffer.wrap("test2".getBytes())), p.getMinimumToken()));
+        ranges.add(new Range(p.getMinimumToken(), p.getToken(ByteBufferUtil.bytes("transfer1"))));
+        ranges.add(new Range(p.getToken(ByteBufferUtil.bytes("test2")), p.getMinimumToken()));
         StreamOutSession session = StreamOutSession.create(tablename, LOCAL, null);
         StreamOut.transferSSTables(session, Arrays.asList(sstable, sstable2), ranges);
         session.await();
@@ -141,7 +142,7 @@ public void testTransferTableMultiple() throws Exception
         ColumnFamilyStore cfstore = Table.open(tablename).getColumnFamilyStore(cfname);
         List<Row> rows = Util.getRangeSlice(cfstore);
         assertEquals(6, rows.size());
-        assert rows.get(0).key.key.equals( ByteBuffer.wrap("test".getBytes()));
+        assert rows.get(0).key.key.equals( ByteBufferUtil.bytes("test"));
         assert rows.get(3).key.key.equals(ByteBuffer.wrap( "transfer1".getBytes() ));
         assert rows.get(0).cf.getColumnsMap().size() == 1;
         assert rows.get(3).cf.getColumnsMap().size() == 1;
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/tools/SSTableExportTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/tools/SSTableExportTest.java
index 2d42c920..6f79f624 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/tools/SSTableExportTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/tools/SSTableExportTest.java
@@ -47,6 +47,7 @@
 import org.json.simple.JSONValue;
 import org.json.simple.parser.ParseException;
 import org.junit.Test;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 public class SSTableExportTest extends SchemaLoader
 {
@@ -63,12 +64,12 @@ public void testEnumeratekeys() throws IOException
         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
         
         // Add rowA
-        cfamily.addColumn(new QueryPath("Standard1", null, ByteBuffer.wrap("colA".getBytes())), ByteBuffer.wrap("valA".getBytes()), 1);
+        cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colA")), ByteBufferUtil.bytes("valA"), 1);
         writer.append(Util.dk("rowA"), cfamily);
         cfamily.clear();
         
         // Add rowB
-        cfamily.addColumn(new QueryPath("Standard1", null, ByteBuffer.wrap("colB".getBytes())), ByteBuffer.wrap("valB".getBytes()), 1);
+        cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colB")), ByteBufferUtil.bytes("valB"), 1);
         writer.append(Util.dk("rowB"), cfamily);
         cfamily.clear();
      
@@ -95,17 +96,17 @@ public void testExportSimpleCf() throws IOException    {
         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
         
         // Add rowA
-        cfamily.addColumn(new QueryPath("Standard1", null, ByteBuffer.wrap("colA".getBytes())), ByteBuffer.wrap("valA".getBytes()), 1);
+        cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colA")), ByteBufferUtil.bytes("valA"), 1);
         writer.append(Util.dk("rowA"), cfamily);
         cfamily.clear();
         
         // Add rowB
-        cfamily.addColumn(new QueryPath("Standard1", null, ByteBuffer.wrap("colB".getBytes())), ByteBuffer.wrap("valB".getBytes()), 1);
+        cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colB")), ByteBufferUtil.bytes("valB"), 1);
         writer.append(Util.dk("rowB"), cfamily);
         cfamily.clear();
 
         // Add rowExclude
-        cfamily.addColumn(new QueryPath("Standard1", null, ByteBuffer.wrap("colX".getBytes())), ByteBuffer.wrap("valX".getBytes()), 1);
+        cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("colX")), ByteBufferUtil.bytes("valX"), 1);
         writer.append(Util.dk("rowExclude"), cfamily);
         cfamily.clear();
 
@@ -137,17 +138,17 @@ public void testExportSuperCf() throws IOException
         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
         
         // Add rowA
-        cfamily.addColumn(new QueryPath("Super4", ByteBuffer.wrap("superA".getBytes()), ByteBuffer.wrap("colA".getBytes())), ByteBuffer.wrap("valA".getBytes()), 1);
+        cfamily.addColumn(new QueryPath("Super4", ByteBufferUtil.bytes("superA"), ByteBufferUtil.bytes("colA")), ByteBufferUtil.bytes("valA"), 1);
         writer.append(Util.dk("rowA"), cfamily);
         cfamily.clear();
         
         // Add rowB
-        cfamily.addColumn(new QueryPath("Super4", ByteBuffer.wrap("superB".getBytes()), ByteBuffer.wrap("colB".getBytes())), ByteBuffer.wrap("valB".getBytes()), 1);
+        cfamily.addColumn(new QueryPath("Super4", ByteBufferUtil.bytes("superB"), ByteBufferUtil.bytes("colB")), ByteBufferUtil.bytes("valB"), 1);
         writer.append(Util.dk("rowB"), cfamily);
         cfamily.clear();
 
         // Add rowExclude
-        cfamily.addColumn(new QueryPath("Super4", ByteBuffer.wrap("superX".getBytes()), ByteBuffer.wrap("colX".getBytes())), ByteBuffer.wrap("valX".getBytes()), 1);
+        cfamily.addColumn(new QueryPath("Super4", ByteBufferUtil.bytes("superX"), ByteBufferUtil.bytes("colX")), ByteBufferUtil.bytes("valX"), 1);
         writer.append(Util.dk("rowExclude"), cfamily);
         cfamily.clear();
 
@@ -160,7 +161,7 @@ public void testExportSuperCf() throws IOException
         JSONObject json = (JSONObject)JSONValue.parse(new FileReader(tempJson));
         
         JSONObject rowA = (JSONObject)json.get(asHex("rowA"));
-        JSONObject superA = (JSONObject)rowA.get(cfamily.getComparator().getString(ByteBuffer.wrap("superA".getBytes())));
+        JSONObject superA = (JSONObject)rowA.get(cfamily.getComparator().getString(ByteBufferUtil.bytes("superA")));
         JSONArray subColumns = (JSONArray)superA.get("subColumns");
         JSONArray colA = (JSONArray)subColumns.get(0);
         JSONObject rowExclude = (JSONObject)json.get(asHex("rowExclude"));
@@ -177,12 +178,12 @@ public void testRoundTripStandardCf() throws IOException, ParseException
         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2);
         
         // Add rowA
-        cfamily.addColumn(new QueryPath("Standard1", null, ByteBuffer.wrap("name".getBytes())), ByteBuffer.wrap("val".getBytes()), 1);
+        cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("name")), ByteBufferUtil.bytes("val"), 1);
         writer.append(Util.dk("rowA"), cfamily);
         cfamily.clear();
 
         // Add rowExclude
-        cfamily.addColumn(new QueryPath("Standard1", null, ByteBuffer.wrap("name".getBytes())), ByteBuffer.wrap("val".getBytes()), 1);
+        cfamily.addColumn(new QueryPath("Standard1", null, ByteBufferUtil.bytes("name")), ByteBufferUtil.bytes("val"), 1);
         writer.append(Util.dk("rowExclude"), cfamily);
         cfamily.clear();
 
@@ -197,12 +198,12 @@ public void testRoundTripStandardCf() throws IOException, ParseException
         SSTableImport.importJson(tempJson.getPath(), "Keyspace1", "Standard1", tempSS2.getPath());
 
         reader = SSTableReader.open(Descriptor.fromFilename(tempSS2.getPath()));
-        QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), new QueryPath("Standard1", null, null), ByteBuffer.wrap("name".getBytes()));
+        QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), new QueryPath("Standard1", null, null), ByteBufferUtil.bytes("name"));
         ColumnFamily cf = qf.getSSTableColumnIterator(reader).getColumnFamily();
         assertTrue(cf != null);
-        assertTrue(cf.getColumn(ByteBuffer.wrap("name".getBytes())).value().equals(ByteBuffer.wrap(hexToBytes("76616c"))));
+        assertTrue(cf.getColumn(ByteBufferUtil.bytes("name")).value().equals(ByteBuffer.wrap(hexToBytes("76616c"))));
 
-        qf = QueryFilter.getNamesFilter(Util.dk("rowExclude"), new QueryPath("Standard1", null, null), ByteBuffer.wrap("name".getBytes()));
+        qf = QueryFilter.getNamesFilter(Util.dk("rowExclude"), new QueryPath("Standard1", null, null), ByteBufferUtil.bytes("name"));
         cf = qf.getSSTableColumnIterator(reader).getColumnFamily();
         assert cf == null;
     }
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/tools/SSTableImportTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/tools/SSTableImportTest.java
index dd988882..75e48c43 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/tools/SSTableImportTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/tools/SSTableImportTest.java
@@ -38,6 +38,7 @@
 
 import org.json.simple.parser.ParseException;
 import org.junit.Test;
+import org.apache.cassandra.utils.ByteBufferUtil;
 
 public class SSTableImportTest extends SchemaLoader
 {   
@@ -51,9 +52,9 @@ public void testImportSimpleCf() throws IOException, ParseException
 
         // Verify results
         SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));
-        QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), new QueryPath("Standard1", null, null), ByteBuffer.wrap("colAA".getBytes()));
+        QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), new QueryPath("Standard1", null, null), ByteBufferUtil.bytes("colAA"));
         ColumnFamily cf = qf.getSSTableColumnIterator(reader).getColumnFamily();
-        assert cf.getColumn(ByteBuffer.wrap("colAA".getBytes())).value().equals(ByteBuffer.wrap(hexToBytes("76616c4141")));
+        assert cf.getColumn(ByteBufferUtil.bytes("colAA")).value().equals(ByteBuffer.wrap(hexToBytes("76616c4141")));
     }
 
     @Test
@@ -65,9 +66,9 @@ public void testImportSuperCf() throws IOException, ParseException
         
         // Verify results
         SSTableReader reader = SSTableReader.open(Descriptor.fromFilename(tempSS.getPath()));
-        QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), new QueryPath("Super4", null, null), ByteBuffer.wrap("superA".getBytes()));
+        QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), new QueryPath("Super4", null, null), ByteBufferUtil.bytes("superA"));
         ColumnFamily cf = qf.getSSTableColumnIterator(reader).getColumnFamily();
-        IColumn superCol = cf.getColumn(ByteBuffer.wrap("superA".getBytes()));
-        assert superCol.getSubColumn(ByteBuffer.wrap("colAA".getBytes())).value().equals(ByteBuffer.wrap(hexToBytes("76616c75654141")));
+        IColumn superCol = cf.getColumn(ByteBufferUtil.bytes("superA"));
+        assert superCol.getSubColumn(ByteBufferUtil.bytes("colAA")).value().equals(ByteBuffer.wrap(hexToBytes("76616c75654141")));
     }
 }
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/utils/BloomFilterTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/utils/BloomFilterTest.java
index 1a8c6280..c50e1ab2 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/utils/BloomFilterTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/utils/BloomFilterTest.java
@@ -55,9 +55,9 @@ public void testBloomLimits1()
     @Test
     public void testOne()
     {
-        bf.add(ByteBuffer.wrap("a".getBytes()));
-        assert bf.isPresent(ByteBuffer.wrap("a".getBytes()));
-        assert !bf.isPresent(ByteBuffer.wrap("b".getBytes()));
+        bf.add(ByteBufferUtil.bytes("a"));
+        assert bf.isPresent(ByteBufferUtil.bytes("a"));
+        assert !bf.isPresent(ByteBufferUtil.bytes("b"));
     }
 
     @Test
diff --git a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/utils/FilterTest.java b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/utils/FilterTest.java
index a41b4183..69af0e3e 100644
--- a/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/utils/FilterTest.java
+++ b/cassandra/branches/cassandra-0.7/test/unit/org/apache/cassandra/utils/FilterTest.java
@@ -99,15 +99,15 @@ public static void testFalsePositives(Filter f, ResetableIterator<ByteBuffer> ke
 
     public static Filter testSerialize(Filter f) throws IOException
     {
-        f.add(ByteBuffer.wrap("a".getBytes()));
+        f.add(ByteBufferUtil.bytes("a"));
         DataOutputBuffer out = new DataOutputBuffer();
         f.getSerializer().serialize(f, out);
 
         ByteArrayInputStream in = new ByteArrayInputStream(out.getData(), 0, out.getLength());
         Filter f2 = f.getSerializer().deserialize(new DataInputStream(in));
 
-        assert f2.isPresent(ByteBuffer.wrap("a".getBytes()));
-        assert !f2.isPresent(ByteBuffer.wrap("b".getBytes()));
+        assert f2.isPresent(ByteBufferUtil.bytes("a"));
+        assert !f2.isPresent(ByteBufferUtil.bytes("b"));
         return f2;
     }
 
