diff --git a/db/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/services/io/FileUtil.java b/db/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/services/io/FileUtil.java
index 8f67376b..8c869e76 100644
--- a/db/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/services/io/FileUtil.java
+++ b/db/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/services/io/FileUtil.java
@@ -25,7 +25,6 @@
 import org.apache.derby.io.StorageFile;
 
 import java.io.*;
-import java.net.*;
 
 /**
 	A set of public static methods for dealing with File objects.
@@ -488,39 +487,4 @@ public static File newFile(File parent, String name) {
 		else
 			return new File(parent, name);
 	}
-
-	/**
-	 * Open an input stream to read a file or a URL
-	 * @param fileOrURL	The file or URL to open.
-	 * @param bufferSize 0 => no buffering.
-	 * @return	an InputStream
-	 * @exception StandardException	Thrown on failure
-	 */
-	public static InputStream getInputStream(String fileOrURL,int bufferSize)
-		 throws IOException
-	{
-		InputStream is;
-		try {
-			is = new FileInputStream( fileOrURL );
-		}
-
-		catch (FileNotFoundException fnfe){
-			try {
-				is = new URL( fileOrURL ).openStream();
-			} catch (MalformedURLException mfurle) {
-
-				// if it looks like an url throw this exception
-				// otherwise throw the file not found exception
-				// If there is no : or an early colon then it's
-				// probably a file (e.g. /foo/myjar.jar or a:/foo/myjar.jar)
-				if (fileOrURL.indexOf(':') > 2)
-					throw mfurle;
-				throw fnfe;
-			}
-		}
-		if (bufferSize > 0)
-			is = new BufferedInputStream(is,bufferSize);
-
-		return is;
-	}
 }
diff --git a/db/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/store/access/FileResource.java b/db/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/store/access/FileResource.java
index 68eee871..3e47c0f5 100644
--- a/db/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/store/access/FileResource.java
+++ b/db/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/store/access/FileResource.java
@@ -21,7 +21,6 @@
 package org.apache.derby.iapi.store.access;
 
 import org.apache.derby.iapi.error.StandardException;
-import org.apache.derby.iapi.store.access.DatabaseInstant;
 import org.apache.derby.io.StorageFile;
 
 import java.io.FileNotFoundException;
@@ -78,13 +77,10 @@ public long add(String name,InputStream source)
 	  the database.
 
 	  @param name the name of the fileResource to remove.
-	  @param purgeOnCommit true means purge the fileResource 
-	         when the current transaction commits. false means retain
-	         the file resource for use by replication. 
 	  
 	  @exception StandardException some error occured.
 	  */
-	public void remove(String name, long currentGenerationId, boolean purgeOnCommit)
+	public void remove(String name, long currentGenerationId)
 		throws StandardException;
 
 	/**
@@ -95,14 +91,11 @@ public void remove(String name, long currentGenerationId, boolean purgeOnCommit)
 	  @param name the name of the file resource.
 	  @param source an input stream for reading the content of
 	  the file resource.
-	  @param purgeOnCommit true means purge the existing version of
-	         fileResource when the current transaction commits. false 
-	         means retain the existing version for use by replication. 
 	  @return the generationId for the new 'current' version of the
 	          file resource. 
 	  @exception StandardException some error occured.
 	*/
-	public long replace(String name, long currentGenerationId, InputStream source,boolean purgeOnCommit)
+	public long replace(String name, long currentGenerationId, InputStream source)
 		throws StandardException;
 
 	/**
diff --git a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/JarFile.java b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/JarFile.java
index 4b787beb..bb5a1553 100644
--- a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/JarFile.java
+++ b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/JarFile.java
@@ -31,23 +31,22 @@
 import org.apache.derby.iapi.util.IdUtil;
 import org.apache.derby.iapi.services.io.InputStreamUtil;
 
-class JarFile {
+/**
+ * Represents a jar file for class loading,
+ * previously installed by the sqlj.install_jar or replace_jar procedures.
+ * <br>
+ * The source for the Jar is either a File (database from a file system)
+ * or an InputStream (database is in a jar file itself).
+ */
+abstract class JarFile {
 	final String[] name;
 	protected ZipFile zip;
 	boolean isStream;
 
-	JarFile() {
-		name = null;
-	}
-
 	JarFile(String[] name) {
 		this.name = name;
 	}
 
-	JarFile newJarFile(String[] name) {
-		return new JarFile(name);
-	}
-
 	final String getJarName() {
 		return IdUtil.mkQualifiedName(name);
 	}
@@ -111,7 +110,5 @@ ZipEntry getNextEntry(ZipInputStream in) throws IOException {
 		return data;
 	}
 
-	Object[] getSigners(String className, ZipEntry ze) throws IOException {
-		return null;
-	}
+	abstract Object[] getSigners(String className, ZipEntry ze) throws IOException;
 }
diff --git a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/JarFileJava2.java b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/JarFileJava2.java
index 576d81e1..e69de29b 100644
--- a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/JarFileJava2.java
+++ b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/JarFileJava2.java
@@ -1,122 +0,0 @@
-/*
-
-   Derby - Class org.apache.derby.impl.services.reflect.JarFileJava2
-
-   Copyright 2000, 2004 The Apache Software Foundation or its licensors, as applicable.
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-
-package org.apache.derby.impl.services.reflect;
-
-import org.apache.derby.iapi.reference.MessageId;
-import org.apache.derby.iapi.error.StandardException;
-import org.apache.derby.iapi.services.i18n.MessageService;
-
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipInputStream;
-import java.io.IOException;
-import java.io.File;
-import java.io.InputStream;
-
-// below are all Java2 imports.
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.security.GeneralSecurityException;
-
-
-
-/**
-	Sub-class of JarFile for a Java2 environment that uses the
-	java.util.jar.* classes to be signature aware.
-*/
-
-final class JarFileJava2 extends JarFile {
-
-	JarFileJava2() {
-		super();
-	}
-
-	JarFileJava2(String[] name) {
-		super(name);
-	}
-
-	JarFile newJarFile(String[] name) {
-		return new JarFileJava2(name);
-	}
-
-	void initialize(File jarFile) throws IOException {
-
-		java.util.jar.JarFile jf = new java.util.jar.JarFile(jarFile);
-
-		// determine if it is signed.
-		zip = jf;
-	}
-
-	ZipEntry getEntry(String entryName) {
-		return ((java.util.jar.JarFile) zip).getJarEntry(entryName);
-	}
-	ZipInputStream getZipOnStream(InputStream in) throws IOException {
-		return new java.util.jar.JarInputStream(in);
-	}
-	ZipEntry getNextEntry(ZipInputStream in) throws IOException {
-		return ((java.util.jar.JarInputStream) in).getNextJarEntry();
-	}
-
-	byte[] readData(ZipEntry ze, InputStream in, String className) throws IOException {
-		try {
-			return super.readData(ze, in, className);
-		} catch (SecurityException se) {
-			throw handleException(se, className);
-		}
-	}
-
-	Object[] getSigners(String className, ZipEntry ze) throws IOException {
-		Exception e;
-
-		try {
-			Certificate[] list = ((java.util.jar.JarEntry) ze).getCertificates();
-			if ((list == null) || (list.length == 0)) {
-				return null;
-			}
-
-			for (int i = 0; i < list.length; i++) {
-				if (!(list[i] instanceof X509Certificate)) {
-					String msg = MessageService.getTextMessage(MessageId.CM_UNKNOWN_CERTIFICATE, className, getJarName());
-
-					throw new SecurityException(msg);
-				}
-
-				X509Certificate cert = (X509Certificate) list[i];
-
-				cert.checkValidity();
-			}
-
-			return list;
-
-		} catch (GeneralSecurityException gse) {
-			// convert this into an unchecked security
-			// exception. Unchecked as eventually it has
-			// to pass through a method that's only throwing
-			// ClassNotFoundException
-			e = gse;
-		}
-		throw handleException(e, className);
-	}
-
-	private SecurityException handleException(Exception e, String className) {
-		String msg = MessageService.getTextMessage(MessageId.CM_SECURITY_EXCEPTION, className, getJarName(), e.getLocalizedMessage());
-		return new SecurityException(msg);
-	}
-}
diff --git a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/JarLoader.java b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/JarLoader.java
index 2eb068d8..b719e5f9 100644
--- a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/JarLoader.java
+++ b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/JarLoader.java
@@ -20,19 +20,24 @@
 
 package org.apache.derby.impl.services.reflect;
 
-import org.apache.derby.impl.sql.execute.JarUtil;
 import org.apache.derby.iapi.services.stream.HeaderPrintWriter;
 import org.apache.derby.iapi.error.StandardException;
 
+import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.InputStream;
 import java.io.IOException;
 
-import java.util.zip.ZipFile;
-import java.util.zip.ZipInputStream;
-import java.util.zip.ZipEntry;
-
+import java.security.CodeSource;
+import java.security.GeneralSecurityException;
+import java.security.SecureClassLoader;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.jar.JarInputStream;
 
+import org.apache.derby.iapi.services.io.InputStreamUtil;
 import org.apache.derby.iapi.services.io.LimitInputStream;
 import org.apache.derby.iapi.util.IdUtil;
 
@@ -40,24 +45,35 @@
 import org.apache.derby.iapi.services.i18n.MessageService;
 
 
-public class JarLoader extends ClassLoader {
+class JarLoader extends SecureClassLoader {
 
-	private static final JarFile jarFileFactory;
+    /**
+     * Two part name for the jar file.
+     */
+    private final String[] name;
 
-	static {
+    /**
+     * When the jar file can be manipulated as a java.util.JarFile
+     * this holds the reference to the open jar. When the jar can
+     * only be manipulated as an InputStream (because the jar is itself
+     * in a database jar) then this will be null.
+     */
+    private JarFile jar;
 
-		// 
-		jarFileFactory = new JarFileJava2();
-	}
+    /**
+     * True if the jar can only be accessed using a stream, because
+     * the jar is itself in a database jar. When fals the jar is accessed
+     * using the jar field.
+     */
+    private boolean isStream;
 
 	private UpdateLoader updateLoader;
-	private JarFile jf;
 	private HeaderPrintWriter vs;
 
 	JarLoader(UpdateLoader updateLoader, String[] name, HeaderPrintWriter vs) {
 
 		this.updateLoader = updateLoader;
-		this.jf = jarFileFactory.newJarFile(name);
+        this.name = name;
 		this.vs = vs;
 	}
 
@@ -70,12 +86,16 @@ void initialize() {
 		try {
 
 			if (zipData instanceof File) {
-				jf.initialize((File) zipData);
+                jar = new JarFile((File) zipData);
 				return;
 			}
 
+            // Jar is only accessible as an INputStream,
+            // which means we need to re-open the stream for
+            // each access. Thus we close the stream now as we have
+            // no further use for it.
 			if (zipData instanceof InputStream) {
-				jf.isStream = true;
+				isStream = true;
 				try {
 					((InputStream) zipData).close();
 				} catch (IOException ioe) {
@@ -88,7 +108,7 @@ void initialize() {
 		}
 
 		// No such zip.
-		setInvalid(false);	
+		setInvalid();	
 	}
 
 	/**
@@ -125,11 +145,12 @@ public InputStream getResourceAsStream(String name) {
 		return updateLoader.getResourceAsStream(name);
 	}
 
-	/*
-	** Package level api
+    /**
+     * Return the SQL name for the installed jar.
+     * Used for error and informational messages.
 	*/
 	final String getJarName() {
-		return jf.getJarName();
+        return IdUtil.mkQualifiedName(name);
 	}
 
 	Class loadClassData(String className, String jvmClassName, boolean resolve) {
@@ -138,10 +159,10 @@ Class loadClassData(String className, String jvmClassName, boolean resolve) {
 			return null;
 
 		try {
-			if (jf.isZip())
+			if (jar != null)
 				return loadClassDataFromJar(className, jvmClassName, resolve);
 
-			if (jf.isStream) {
+			if (isStream) {
 				// have to use a new stream each time
 				return loadClassData((InputStream) load(),
 						className, jvmClassName, resolve);
@@ -163,10 +184,10 @@ InputStream getStream(String name) {
 		if (updateLoader == null)
 			return null;
 
-		if (jf.isZip())
-			return getRawStream(jf.getZip(), name);
+		if (jar != null)
+			return getRawStream(name);
 
-		if (jf.isStream) {
+		if (isStream) {
 			return getRawStream((InputStream) load(), name);
 		}
 		return null;
@@ -178,58 +199,73 @@ InputStream getStream(String name) {
 	*/
 
 
-	private Class loadClassDataFromJar(String className, String jvmClassName, boolean resolve) 
+    /**
+     * Load the class data when the installed jar is accessible
+     * as a java.util.jarFile.
+     */
+	private Class loadClassDataFromJar(
+            String className, String jvmClassName, boolean resolve) 
 		throws IOException {
 
-		ZipEntry ze = jf.getEntry(jvmClassName);
-		if (ze == null)
+		JarEntry e = jar.getJarEntry(jvmClassName);
+		if (e == null)
 			return null;
 
-		InputStream in = jf.getZip().getInputStream(ze);
+		InputStream in = jar.getInputStream(e);
 
 		try {
-			return loadClassData(ze, in, className, resolve);
+			return loadClassData(e, in, className, resolve);
 		} finally {
 			in.close();
 		}
 	}
 
+    /**
+     * Load the class data when the installed jar is accessible
+     * only as an input stream (the jar is itself in a database jar).
+     */
 	private Class loadClassData(
 		InputStream in, String className, String jvmClassName, boolean resolve) 
 		throws IOException {
 
-		ZipInputStream zipIn = jf.getZipOnStream(in);
+        JarInputStream jarIn = new JarInputStream(in);
 
 		for (;;) {
 
-			ZipEntry ze = jf.getNextEntry(zipIn);
-			if (ze == null) {
-				zipIn.close();
+			JarEntry e = jarIn.getNextJarEntry();
+			if (e == null) {
+				jarIn.close();
 				return null;
 			}
 
-			if (ze.getName().equals(jvmClassName)) {
-				Class c = loadClassData(ze, zipIn, className, resolve);
-				zipIn.close();
+			if (e.getName().equals(jvmClassName)) {
+				Class c = loadClassData(e, jarIn, className, resolve);
+				jarIn.close();
 				return c;
 			}
 		}
 		
 	}
 
-	private Class loadClassData(ZipEntry ze, InputStream in,
+    /**
+     * Load and optionally resolve the class given its
+     * JarEntry and an InputStream to the class fiel format.
+     * This is common code for when the jar is accessed
+     * directly using JarFile or through InputStream.
+     */
+	private Class loadClassData(JarEntry e, InputStream in,
 		String className, boolean resolve) throws IOException {
 
-		byte[] data = jf.readData(ze, in, className);
+		byte[] data = readData(e, in, className);
 
-		Object[] signers = jf.getSigners(className, ze);
+		Certificate[] signers = getSigners(className, e);
 
 		synchronized (updateLoader) {
 			// see if someone else loaded it while we
 			// were getting the bytes ...
 			Class c = updateLoader.checkLoaded(className, resolve);
 			if (c == null) {
-				c = defineClass(className, data, 0, data.length);
+				c = defineClass(className, data, 0, data.length, (CodeSource) null);
 				if (signers != null) {
 					setSigners(c, signers);
 				}
@@ -253,7 +289,7 @@ Class checkLoaded(String className, boolean resolve) {
 
 	private Object load() {
 
-		String[] dbJarName = jf.name;
+		String[] dbJarName = name;
 
 		String schemaName = dbJarName[IdUtil.DBCP_SCHEMA_NAME];
 		String sqlName = dbJarName[IdUtil.DBCP_SQL_JAR_NAME];
@@ -263,17 +299,28 @@ private Object load() {
 			return updateLoader.getJarReader().readJarFile(schemaName, sqlName);
 		} catch (StandardException se) {
 			if (vs != null)
-				vs.println(MessageService.getTextMessage(MessageId.CM_LOAD_JAR_EXCEPTION, jf.getJarName(), se));
+				vs.println(MessageService.getTextMessage(MessageId.CM_LOAD_JAR_EXCEPTION, getJarName(), se));
 			return null;
 		}
 
 	}
 
-	JarFile setInvalid(boolean newJarFile) {
-
-		jf.setInvalid();
+    /**
+     * Set this loader to be invaid so that it will not
+     * resolve any classes or resources.
+     *
+     */
+	void setInvalid() {
 		updateLoader = null;
-		return newJarFile ? jarFileFactory.newJarFile(jf.name) : null;
+        if (jar != null) {
+            try {
+                jar.close();
+            } catch (IOException ioe) {
+            }
+            jar = null;
+
+        }
+        isStream = false;
 	}
 
 	/*
@@ -281,19 +328,19 @@ JarFile setInvalid(boolean newJarFile) {
 	*/
 
 	/**
-		Get a stream directly from a ZipFile.
+		Get a stream for a resource directly from a JarFile.
 		In this case we can safely return the stream directly.
 		It's a new stream set up by the zip code to read just
 		the contents of this entry.
 	*/
-	private InputStream getRawStream(ZipFile zip, String name) {
+	private InputStream getRawStream(String name) {
 
 		try {
-			ZipEntry ze = zip.getEntry(name);
-			if (ze == null)
+			JarEntry e = jar.getJarEntry(name);
+			if (e == null)
 				return null;
 
-			return zip.getInputStream(ze);
+			return jar.getInputStream(e);
 		} catch (IOException ioe) {
 			return null;
 		}
@@ -307,30 +354,113 @@ private InputStream getRawStream(ZipFile zip, String name) {
 	*/
 	private InputStream getRawStream(InputStream in, String name) { 
 
-		ZipInputStream zipIn = null;
+		JarInputStream jarIn = null;
 		try {
-			zipIn = new ZipInputStream(in);
+			jarIn = new JarInputStream(in);
 
-			ZipEntry ze;
-			while ((ze = jf.getNextEntry(zipIn)) != null) {
+		    JarEntry e;
+			while ((e = jarIn.getNextJarEntry()) != null) {
 
-				if (ze.getName().equals(name)) {
-					LimitInputStream lis = new LimitInputStream(zipIn);
-					lis.setLimit((int) ze.getSize());
+				if (e.getName().equals(name)) {
+					LimitInputStream lis = new LimitInputStream(jarIn);
+					lis.setLimit((int) e.getSize());
 					return lis;
 				}
 			}
 
-			zipIn.close();
+			jarIn.close();
 
 		} catch (IOException ioe) {
-			if (zipIn != null) {
+			if (jarIn != null) {
 				try {
-					zipIn.close();
+					jarIn.close();
 				} catch (IOException ioe2) {
 				}
 			}
 		}
 		return null;
 	}
+    
+    /**
+     * Read the raw data for the class file format
+     * into a byte array that can be used for loading the class.
+     * If this is a signed class and it has been compromised then
+     * a SecurityException will be thrown.
+     */
+    byte[] readData(JarEntry ze, InputStream in, String className)
+            throws IOException {
+
+        try {
+            int size = (int) ze.getSize();
+
+            if (size != -1) {
+                byte[] data = new byte[size];
+
+                InputStreamUtil.readFully(in, data, 0, size);
+
+                return data;
+            }
+
+            // unknown size
+            byte[] data = new byte[1024];
+            ByteArrayOutputStream os = new ByteArrayOutputStream(1024);
+            int r;
+            while ((r = in.read(data)) != -1) {
+                os.write(data, 0, r);
+            }
+
+            data = os.toByteArray();
+            return data;
+        } catch (SecurityException se) {
+            throw handleException(se, className);
+        }
+    }
+
+    /**
+     * Validate the security certificates (signers) for the class data.
+     */
+    private Certificate[] getSigners(String className, JarEntry je) throws IOException {
+
+        try {
+            Certificate[] list = je.getCertificates();
+            if ((list == null) || (list.length == 0)) {
+                return null;
+            }
+
+            for (int i = 0; i < list.length; i++) {
+                if (!(list[i] instanceof X509Certificate)) {
+                    String msg = MessageService.getTextMessage(
+                            MessageId.CM_UNKNOWN_CERTIFICATE, className,
+                            getJarName());
+
+                    throw new SecurityException(msg);
+                }
+
+                X509Certificate cert = (X509Certificate) list[i];
+
+                cert.checkValidity();
+            }
+
+            return list;
+
+        } catch (GeneralSecurityException gse) {
+            // convert this into an unchecked security
+            // exception. Unchecked as eventually it has
+            // to pass through a method that's only throwing
+            // ClassNotFoundException
+            throw handleException(gse, className);
+        }
+        
+    }
+
+    /**
+     * Provide a SecurityManager with information about the class name
+     * and the jar file.
+     */
+    private SecurityException handleException(Exception e, String className) {
+        String msg = MessageService.getTextMessage(
+                MessageId.CM_SECURITY_EXCEPTION, className, getJarName(), e
+                        .getLocalizedMessage());
+        return new SecurityException(msg);
+    }
 }
diff --git a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/UpdateLoader.java b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/UpdateLoader.java
index e365314a..16ca2425 100644
--- a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/UpdateLoader.java
+++ b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/services/reflect/UpdateLoader.java
@@ -46,6 +46,22 @@
 
 public class UpdateLoader {
 
+    /**
+     * List of packages that Derby will not support being loaded
+     * from an installed jar file.
+     */
+    private static final String[] RESTRICTED_PACKAGES = {
+        // While loading java. classes is blocked by the standard
+        // class loading mechanism, javax. ones are not. However
+        // allowing database applications to override jvm classes
+        // seems a bad idea.
+        "javax.",
+        
+        // Allowing an application to possible override the engine's
+        // own classes also seems dangerous.
+        "org.apache.derby.",
+    };
+
 	private JarLoader[] jarList;
 	private HeaderPrintWriter vs;
 	private final ClassLoader myLoader;
@@ -122,6 +138,13 @@ public Class loadClass(String className, boolean resolve)
 				if (clazz != null)
 					return clazz;
 
+                // Refuse to load classes from restricted name spaces
+                for (int i = 0; i < RESTRICTED_PACKAGES.length; i++)
+                {
+                    if (className.startsWith(RESTRICTED_PACKAGES[i]))
+                        throw new ClassNotFoundException(className);
+                }
+
 				String jvmClassName = className.replace('.', '/').concat(".class");
 
 				if (!initDone)
@@ -222,23 +245,11 @@ public synchronized void modifyJar(boolean reload) throws StandardException {
 		if (!initDone)
 			return;
 
-		if (reload) {
-			//first close the existing jar file opens
+        // first close the existing jar file opens
 			close();
-			initializeFromClassPath(thisClasspath);
-			return;
-		}
 
-		// first thing to do is to remove all Class entries
-		// and then get a complete set of loaders ...
-		synchronized (this) {
-
-			for (int i = 0; i < jarList.length; i++) {
-
-				JarLoader jl = jarList[i];
-
-				JarFile newJarFile = jl.setInvalid(reload);
-			}
+		if (reload) {
+			initializeFromClassPath(thisClasspath);
 		}
 	}
 
@@ -280,7 +291,7 @@ Class checkLoaded(String className, boolean resolve) {
 	public void close() {
 
 		for (int i = 0; i < jarList.length; i++) {
-			jarList[i].setInvalid(false);
+			jarList[i].setInvalid();
 		}
 
 	}
diff --git a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/AddJarConstantAction.java b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/AddJarConstantAction.java
index 58f4df16..ce800adb 100644
--- a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/AddJarConstantAction.java
+++ b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/AddJarConstantAction.java
@@ -32,8 +32,6 @@
  */
 class AddJarConstantAction extends DDLConstantAction
 {
-
-	private final UUID id;
 	private	final String schemaName;
 	private	final String sqlName;
 	private final String externalPath;
@@ -54,12 +52,11 @@
 	 *	@param	sqlName			    The sqlName for the jar file.
 	 *  @param  fileName            The name of the file that holds the jar.
 	 */
-	AddJarConstantAction(UUID id,
+	AddJarConstantAction(
 								 String schemaName,
 								 String sqlName,
 								 String externalPath)
 	{
-		this.id = id;
 		this.schemaName = schemaName;
 		this.sqlName = sqlName;
 		this.externalPath = externalPath;
@@ -93,7 +90,7 @@ public	String	toString()
 	public void	executeConstantAction( Activation activation )
 						throws StandardException
 	{
-		JarUtil.add(id,schemaName,sqlName,externalPath);
+		JarUtil.add(schemaName,sqlName,externalPath);
 	}
 
 }
diff --git a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/DropJarConstantAction.java b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/DropJarConstantAction.java
index 83ec914e..996a161c 100644
--- a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/DropJarConstantAction.java
+++ b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/DropJarConstantAction.java
@@ -34,8 +34,6 @@
  */
 class DropJarConstantAction extends DDLConstantAction
 {
-
-	private final UUID id;
 	private final String schemaName;
 	private final String sqlName;
 
@@ -48,15 +46,12 @@
 	/**
 	 *	Make the ConstantAction to drop a jar file to database.
 	 *
-	 *	@param	id					The id for the jar file
 	 *	@param	schemaName			The SchemaName for the jar file.
 	 *	@param	sqlName			    The sqlName for the jar file.
 	 */
-	DropJarConstantAction(UUID id,
-								  String schemaName,
+	DropJarConstantAction(String schemaName,
 								  String sqlName)
 	{
-		this.id = id;
 		this.schemaName = schemaName;
 		this.sqlName = sqlName;
 	}
@@ -89,13 +84,6 @@ public	String	toString()
 	public void	executeConstantAction( Activation activation )
 						throws StandardException
 	{
-		JarUtil.drop(null,schemaName,sqlName,
-					 purgeOnCommit());
+		JarUtil.drop(schemaName,sqlName);
 	}
-
-	//
-	// Replication can over-ride this to defer purging dropped jar
-	// files that remain in the stage.
-	protected boolean purgeOnCommit() { return true; }
-
 }
diff --git a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/GenericConstantActionFactory.java b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/GenericConstantActionFactory.java
index f333058c..c5ad2b23 100644
--- a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/GenericConstantActionFactory.java
+++ b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/GenericConstantActionFactory.java
@@ -833,57 +833,51 @@ public	UpdateConstantAction	getUpdateConstantAction(
 	/**
 	 * Make the ConstantAction to Add a jar file to a database.
 	 *
-	 *	@param	id					The id for the jar file -
-	 *                              (null means create one)
 	 *	@param	schemaName			The SchemaName for the jar file.
 	 *	@param	sqlName			    The sqlName for the jar file.
 	 *  @param  fileName            The name of the file that holds the jar.
 	 *  @exception StandardException Ooops
 	 */
-	public	ConstantAction getAddJarConstantAction(UUID id,
+	public	ConstantAction getAddJarConstantAction(
 														 String schemaName,
 														 String sqlName,
 														 String externalPath)
 		 throws StandardException
 	{
 		getAuthorizer().authorize(Authorizer.JAR_WRITE_OP);
-		return new AddJarConstantAction(id,schemaName,sqlName,externalPath);
+		return new AddJarConstantAction(schemaName,sqlName,externalPath);
 	}
 	/**
 	 * Make the ConstantAction to replace a jar file in a database.
 	 *
-	 *	@param	id					The id for the jar file -
-	 *                              (Ignored if null)
 	 *	@param	schemaName			The SchemaName for the jar file.
 	 *	@param	sqlName			    The sqlName for the jar file.
 	 *  @param  fileName            The name of the file that holds the new jar.
 	 *  @exception StandardException Ooops
 	 */
-	public	ConstantAction getReplaceJarConstantAction(UUID id,
+	public	ConstantAction getReplaceJarConstantAction(
 														 String schemaName,
 														 String sqlName,
 														 String externalPath)
 		 throws StandardException
 	{
 		getAuthorizer().authorize(Authorizer.JAR_WRITE_OP);
-		return new ReplaceJarConstantAction(id,schemaName,sqlName,externalPath);
+		return new ReplaceJarConstantAction(schemaName,sqlName,externalPath);
 	}
 	/**
 	 * Make the ConstantAction to drop a jar file from a database.
 	 *
-	 *	@param	id					The id for the jar file -
-	 *                              (Ignored if null)
 	 *	@param	schemaName			The SchemaName for the jar file.
 	 *	@param	sqlName			    The sqlName for the jar file.
 	 *  @exception StandardException Ooops
 	 */
-	public	ConstantAction getDropJarConstantAction(UUID id,
+	public	ConstantAction getDropJarConstantAction(
 														  String schemaName,
 														  String sqlName)
 		 throws StandardException
 	{
 		getAuthorizer().authorize(Authorizer.JAR_WRITE_OP);
-		return new DropJarConstantAction(id,schemaName,sqlName);
+		return new DropJarConstantAction(schemaName,sqlName);
 	}
 
 	static protected Authorizer getAuthorizer()
diff --git a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/JarDDL.java b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/JarDDL.java
index 7e00e3b5..a697482c 100644
--- a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/JarDDL.java
+++ b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/JarDDL.java
@@ -41,7 +41,7 @@
 
 		GenericConstantActionFactory caf = getConstantActionFactory();
 		ConstantAction ca =
-			caf.getAddJarConstantAction(null,schemaName,sqlName,externalPath);
+			caf.getAddJarConstantAction(schemaName,sqlName,externalPath);
 		ca.executeConstantAction(null);
 	}
 
@@ -59,7 +59,7 @@
 
 		GenericConstantActionFactory caf = getConstantActionFactory();
 		ConstantAction ca =
-			caf.getDropJarConstantAction(null,schemaName,sqlName);
+			caf.getDropJarConstantAction(schemaName,sqlName);
 		ca.executeConstantAction(null);
 	}
 
@@ -77,7 +77,7 @@
 
 		GenericConstantActionFactory caf = getConstantActionFactory();
 		ConstantAction ca =
-			caf.getReplaceJarConstantAction(null,schemaName,sqlName,externalPath);
+			caf.getReplaceJarConstantAction(schemaName,sqlName,externalPath);
 		ca.executeConstantAction(null);
 	}
 
diff --git a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/JarUtil.java b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/JarUtil.java
index 1cde3a94..10901096 100644
--- a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/JarUtil.java
+++ b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/JarUtil.java
@@ -38,24 +38,20 @@
 import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.store.access.FileResource;
 import org.apache.derby.catalog.UUID;
-import org.apache.derby.iapi.services.io.FileUtil;
-import org.apache.derby.io.StorageFile;
 
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.sql.CallableStatement;
-import java.sql.Connection;
-import java.sql.SQLException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
 
-public class JarUtil
+
+class JarUtil
 {
-	public static final String ADD_JAR_DDL = "ADD JAR";
-	public static final String DROP_JAR_DDL = "DROP JAR";
-	public static final String REPLACE_JAR_DDL = "REPLACE JAR";
-	public static final String READ_JAR = "READ JAR";
 	//
 	//State passed in by the caller
-	private UUID id; //For add null means create a new id.
 	private String schemaName;
 	private String sqlName;
 
@@ -67,10 +63,9 @@
 	
 	//
 	//State derived from the caller's context
-	public JarUtil(UUID id, String schemaName, String sqlName)
+	private JarUtil(String schemaName, String sqlName)
 		 throws StandardException
 	{
-		this.id = id;
 		this.schemaName = schemaName;
 		this.sqlName = sqlName;
 
@@ -92,15 +87,15 @@ public JarUtil(UUID id, String schemaName, String sqlName)
 
 	  @exception StandardException Opps
 	  */
-	static public long
-	add(UUID id, String schemaName, String sqlName, String externalPath)
+	static long
+	add(String schemaName, String sqlName, String externalPath)
 		 throws StandardException
 	{
-		JarUtil jutil = new JarUtil(id, schemaName, sqlName);
+		JarUtil jutil = new JarUtil(schemaName, sqlName);
 		InputStream is = null;
 		
 		try {
-			is = FileUtil.getInputStream(externalPath, 0);
+			is = openJarURL(externalPath);
 			return jutil.add(is);
 		} catch (java.io.IOException fnfe) {
 			throw StandardException.newException(SQLState.SQLJ_INVALID_JAR, fnfe, externalPath);
@@ -120,7 +115,7 @@ public JarUtil(UUID id, String schemaName, String sqlName)
 	  @param is A stream for reading the content of the file to add.
 	  @exception StandardException Opps
 	  */
-	public long add(InputStream is) throws StandardException
+	private long add(final InputStream is) throws StandardException
 	{
 		//
 		//Like create table we say we are writing before we read the dd
@@ -131,15 +126,16 @@ public long add(InputStream is) throws StandardException
 				StandardException.newException(SQLState.LANG_OBJECT_ALREADY_EXISTS_IN_OBJECT, 
 											   fid.getDescriptorType(), sqlName, fid.getSchemaDescriptor().getDescriptorType(), schemaName);
 
+        SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, null, true);
 		try {
 			notifyLoader(false);
 			dd.invalidateAllSPSPlans();
-			long generationId = fr.add(JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()),is);
+            final String jarExternalName = JarDDL.mkExternalName(schemaName,
+                    sqlName, fr.getSeparatorChar());
 
-			SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, null, true);
+            long generationId = setJar(jarExternalName, is, true, 0L);
 
-			fid = ddg.newFileInfoDescriptor(id, sd,
-							sqlName, generationId);
+            fid = ddg.newFileInfoDescriptor(/*DJD*/null, sd, sqlName, generationId);
 			dd.addDescriptor(fid, sd, DataDictionary.SYSFILES_CATALOG_NUM,
 							 false, lcc.getTransactionExecute());
 			return generationId;
@@ -149,22 +145,27 @@ public long add(InputStream is) throws StandardException
 	}
 
 	/**
-	  Drop a jar file from the current connection's database.
-
-	  @param id The id for the jar file we drop. Ignored if null.
-	  @param schemaName the name for the schema that holds the jar file.
-	  @param sqlName the sql name for the jar file.
-	  @param purgeOnCommit True means purge the old jar file on commit. False
-	    means leave it around for use by replication.
-
-	  @exception StandardException Opps
+     * Drop a jar file from the current connection's database.
+     * 
+     * @param id
+     *            The id for the jar file we drop. Ignored if null.
+     * @param schemaName
+     *            the name for the schema that holds the jar file.
+     * @param sqlName
+     *            the sql name for the jar file.
+     * @param purgeOnCommit
+     *            True means purge the old jar file on commit. False means leave
+     *            it around for use by replication.
+     * 
+     * @exception StandardException
+     *                Opps
 	  */
-	static public void
-	drop(UUID id, String schemaName, String sqlName,boolean purgeOnCommit)
+	static void
+	drop(String schemaName, String sqlName)
 		 throws StandardException
 	{
-		JarUtil jutil = new JarUtil(id, schemaName,sqlName);
-		jutil.drop(purgeOnCommit);
+		JarUtil jutil = new JarUtil(schemaName,sqlName);
+		jutil.drop();
 	}
 
 	/**
@@ -173,12 +174,10 @@ public long add(InputStream is) throws StandardException
 	  <P> The reason for dropping  the jar file in this private instance
 	  method is that it allows us to share set up logic with add and
 	  replace.
-	  @param purgeOnCommit True means purge the old jar file on commit. False
-	    means leave it around for use by replication.
 
 	  @exception StandardException Opps
 	  */
-	public void drop(boolean purgeOnCommit) throws StandardException
+	private void drop() throws StandardException
 	{
 		//
 		//Like create table we say we are writing before we read the dd
@@ -187,15 +186,6 @@ public void drop(boolean purgeOnCommit) throws StandardException
 		if (fid == null)
 			throw StandardException.newException(SQLState.LANG_FILE_DOES_NOT_EXIST, sqlName,schemaName);
 
-		if (SanityManager.DEBUG)
-		{
-			if (id != null && !fid.getUUID().equals(id))
-			{
-				SanityManager.THROWASSERT("Drop id mismatch want="+id+
-						" have "+fid.getUUID());
-			}
-		}
-
 		String dbcp_s = PropertyUtil.getServiceProperty(lcc.getTransactionExecute(),Property.DATABASE_CLASSPATH);
 		if (dbcp_s != null)
 		{
@@ -227,7 +217,7 @@ public void drop(boolean purgeOnCommit) throws StandardException
 			dd.dropFileInfoDescriptor(fid);
 
 			fr.remove(JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()),
-				fid.getGenerationId(), true /*purgeOnCommit*/);
+				fid.getGenerationId());
 		} finally {
 			notifyLoader(true);
 		}
@@ -238,29 +228,26 @@ public void drop(boolean purgeOnCommit) throws StandardException
 	  external file. 
 
 
-	  @param id The id for the jar file we add. Ignored if null.
 	  @param schemaName the name for the schema that holds the jar file.
 	  @param sqlName the sql name for the jar file.
 	  @param externalPath the path for the jar file to add.
-	  @param purgeOnCommit True means purge the old jar file on commit. False
-	    means leave it around for use by replication.
 	  @return The new generationId for the jar file we replace.
 
 	  @exception StandardException Opps
 	  */
-	static public long
-	replace(UUID id,String schemaName, String sqlName,
-			String externalPath,boolean purgeOnCommit)
+	static long
+	replace(String schemaName, String sqlName,
+			String externalPath)
 		 throws StandardException
 	{
-		JarUtil jutil = new JarUtil(id,schemaName,sqlName);
+		JarUtil jutil = new JarUtil(schemaName,sqlName);
 		InputStream is = null;
 		
 
 		try {
-			is = FileUtil.getInputStream(externalPath, 0);
+			is = openJarURL(externalPath);
 
-			return jutil.replace(is,purgeOnCommit);
+			return jutil.replace(is);
 		} catch (java.io.IOException fnfe) {
 			throw StandardException.newException(SQLState.SQLJ_INVALID_JAR, fnfe, externalPath);
 		}
@@ -282,7 +269,7 @@ public void drop(boolean purgeOnCommit) throws StandardException
 	    means leave it around for use by replication.
 	  @exception StandardException Opps
 	  */
-	public long replace(InputStream is,boolean purgeOnCommit) throws StandardException
+	private long replace(InputStream is) throws StandardException
 	{
 		//
 		//Like create table we say we are writing before we read the dd
@@ -294,26 +281,18 @@ public long replace(InputStream is,boolean purgeOnCommit) throws StandardExcepti
 		if (fid == null)
 			throw StandardException.newException(SQLState.LANG_FILE_DOES_NOT_EXIST, sqlName,schemaName);
 
-		if (SanityManager.DEBUG)
-		{
-			if (id != null && !fid.getUUID().equals(id))
-			{
-				SanityManager.THROWASSERT("Replace id mismatch want="+
-					id+" have "+fid.getUUID());
-			}
-		}
-
 		try {
 			// disable loads from this jar
 			notifyLoader(false);
 			dd.invalidateAllSPSPlans();
 			dd.dropFileInfoDescriptor(fid);
+            final String jarExternalName =
+                JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar());
 
 			//
 			//Replace the file.
-			long generationId = 
-				fr.replace(JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()),
-					fid.getGenerationId(), is, purgeOnCommit);
+			long generationId = setJar(jarExternalName, is, false,
+					fid.getGenerationId());
 
 			//
 			//Re-add the descriptor to the data dictionary.
@@ -331,22 +310,6 @@ public long replace(InputStream is,boolean purgeOnCommit) throws StandardExcepti
 		}
 	}
 
-	/**
-	  Get the FileInfoDescriptor for a jar file from the current connection's database or
-	  null if it does not exist.
-
-	  @param schemaName the name for the schema that holds the jar file.
-	  @param sqlName the sql name for the jar file.
-	  @return The FileInfoDescriptor.
-	  @exception StandardException Opps
-	  */
-	public static FileInfoDescriptor getInfo(String schemaName, String sqlName, String statementType)
-		 throws StandardException
-	{
-		JarUtil jUtil = new JarUtil(null,schemaName,sqlName);
-		return jUtil.getInfo();
-	}
-
 	/**
 	  Get the FileInfoDescriptor for the Jar file or null if it does not exist.
 	  @exception StandardException Ooops
@@ -358,36 +321,6 @@ private FileInfoDescriptor getInfo()
 		return dd.getFileInfoDescriptor(sd,sqlName);
 	}
 
-	// get the current version of the jar file as a File or InputStream
-	public static Object getAsObject(String schemaName, String sqlName)
-		 throws StandardException
-	{
-		JarUtil jUtil = new JarUtil(null,schemaName,sqlName);
-
-		FileInfoDescriptor fid = jUtil.getInfo();
-		if (fid == null)
-			throw StandardException.newException(SQLState.LANG_FILE_DOES_NOT_EXIST, sqlName,schemaName);
-
-		long generationId = fid.getGenerationId();
-
-		StorageFile f = jUtil.getAsFile(generationId);
-		if (f != null)
-			return f;
-
-		return jUtil.getAsStream(generationId);
-	}
-
-	private StorageFile getAsFile(long generationId) {
-		return fr.getAsFile(JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()), generationId);
-	}
-
-	public static InputStream getAsStream(String schemaName, String sqlName,
-		long generationId) throws StandardException {
-		JarUtil jUtil = new JarUtil(null,schemaName,sqlName);
-
-		return jUtil.getAsStream(generationId);		
-	}
-
 	private InputStream getAsStream(long generationId) throws StandardException {
 		try {
 			return fr.getAsStream(JarDDL.mkExternalName(schemaName, sqlName, fr.getSeparatorChar()), generationId);
@@ -396,8 +329,76 @@ private InputStream getAsStream(long generationId) throws StandardException {
 		}
 	}
 
+
 	private void notifyLoader(boolean reload) throws StandardException {
 		ClassFactory cf = lcc.getLanguageConnectionFactory().getClassFactory();
 		cf.notifyModifyJar(reload);
 	}
+
+    /**
+     * Open an input stream to read a URL or a file.
+     * URL is attempted first, if the string does not conform
+     * to a URL then an attempt to open it as a regular file
+     * is tried.
+     * <BR>
+     * Attempting the file first can throw a security execption
+     * when a valid URL is passed in.
+     * The security exception is due to not have the correct permissions
+     * to access the bogus file path. To avoid this the order was reversed
+     * to attempt the URL first and only attempt a file open if creating
+     * the URL throws a MalformedURLException.
+     */
+    private static InputStream openJarURL(final String externalPath)
+        throws IOException
+    {
+        try {
+            return (InputStream) AccessController.doPrivileged
+            (new java.security.PrivilegedExceptionAction(){
+                
+                public Object run() throws IOException {    
+                    try {
+                        return new URL(externalPath).openStream();
+                    } catch (MalformedURLException mfurle)
+                    {
+                        return new FileInputStream(externalPath);
+                    }
+                }
+            });
+        } catch (PrivilegedActionException e) {
+            throw (IOException) e.getException();
+        }
+    }
+    
+    /**
+     * Copy the jar from the externally obtained 
+     * input stream into the database
+     * @param jarExternalName Name of jar with database structure.
+     * @param contents Contents of jar file.
+     * @param add true to add, false to replace
+     * @param currentGenerationId generation id of existing version, ignored when adding.
+     */
+    private long setJar(final String jarExternalName,
+            final InputStream contents,
+            final boolean add,
+            final long currentGenerationId)
+            throws StandardException {
+        try {
+            return ((Long) AccessController
+                    .doPrivileged(new java.security.PrivilegedExceptionAction() {
+
+                        public Object run() throws StandardException {
+                            long generationId;
+                            
+                            if (add)
+                                generationId = fr.add(jarExternalName, contents);
+                            else
+                                generationId =  fr.replace(jarExternalName,
+                                        currentGenerationId, contents);
+                            return new Long(generationId);
+                        }
+                    })).longValue();
+        } catch (PrivilegedActionException e) {
+            throw (StandardException) e.getException();
+        }
+    }
 }
diff --git a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/ReplaceJarConstantAction.java b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/ReplaceJarConstantAction.java
index 1074768c..e76879e6 100644
--- a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/ReplaceJarConstantAction.java
+++ b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/ReplaceJarConstantAction.java
@@ -20,21 +20,15 @@
 
 package org.apache.derby.impl.sql.execute;
 
-import org.apache.derby.iapi.services.sanity.SanityManager;
 import org.apache.derby.iapi.error.StandardException;
-import org.apache.derby.iapi.sql.execute.ConstantAction;
-
 import org.apache.derby.iapi.sql.Activation;
-
-import org.apache.derby.catalog.UUID;
+import org.apache.derby.iapi.sql.execute.ConstantAction;
 /**
  *	Constant action to Add an external  Jar file to a database. 
  *
  */
 class ReplaceJarConstantAction extends DDLConstantAction
 {
-
-	private final UUID id;
 	private final String schemaName;
 	private final String sqlName;
 	private final String externalPath;
@@ -47,17 +41,15 @@
 	/**
 	 *	Make the ConstantAction to replace a jar file in a database.
 	 *
-	 *	@param	id					The id for the jar file
 	 *	@param	schemaName			The SchemaName for the jar file.
 	 *	@param	sqlName			    The sqlName for the jar file.
 	 *  @param  fileName            The name of the file that holds the jar.
 	 */
-	ReplaceJarConstantAction(UUID id,
+	ReplaceJarConstantAction(
 									String schemaName,
 									String sqlName,
 									String externalPath)
 	{
-		this.id = id;
 		this.schemaName = schemaName;
 		this.sqlName = sqlName;
 		this.externalPath = externalPath;
@@ -88,15 +80,8 @@ public	String	toString()
 	public void	executeConstantAction( Activation activation )
 						throws StandardException
 	{
-		JarUtil.replace(id,schemaName,
+		JarUtil.replace(schemaName,
 									   sqlName,
-									   externalPath,
-									   purgeOnCommit());
+									   externalPath);
 	}
-
-	//
-	// Replication can over-ride this to defer purging dropped jar
-	// files that remain in the stage.
-	protected boolean purgeOnCommit() { return true; }
-
 }
diff --git a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/RFResource.java b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/RFResource.java
index eee5f67d..7aa02575 100644
--- a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/RFResource.java
+++ b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/RFResource.java
@@ -41,12 +41,16 @@
 import java.io.OutputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 
 public class RFResource implements FileResource {
 
-	protected final BaseDataFileFactory factory;
+	private final BaseDataFileFactory factory;
 
-	public RFResource(BaseDataFileFactory dataFactory) {
+	RFResource(BaseDataFileFactory dataFactory) {
 		this.factory = dataFactory;
 	}
 
@@ -129,7 +133,7 @@ public long add(String name, InputStream source)
 	  @see FileResource#remove
 	  @exception StandardException Oops
 	  */
-	public void remove(String name, long currentGenerationId, boolean purgeOnCommit)
+	public void remove(String name, long currentGenerationId)
 		throws StandardException
 	{
 		if (factory.isReadOnly())
@@ -142,27 +146,24 @@ public void remove(String name, long currentGenerationId, boolean purgeOnCommit)
             factory.getRawStoreFactory().findUserTransaction(
                 cm, AccessFactoryGlobals.USER_TRANS_NAME);
 
-		tran.logAndDo(privRemoveFileOperation(name, currentGenerationId, purgeOnCommit));
+		tran.logAndDo(privRemoveFileOperation(name, currentGenerationId, true));
 
-		if (purgeOnCommit) {
-
-			Serviceable s = privRemoveFile(getAsFile(name, currentGenerationId));
+		Serviceable s = new RemoveFile(getAsFile(name, currentGenerationId));
 
 			tran.addPostCommitWork(s);
 		}
-	}
 
 	/**
 	  @see FileResource#replace
 	  @exception StandardException Oops
 	  */
-	public long replace(String name, long currentGenerationId, InputStream source, boolean purgeOnCommit)
+	public long replace(String name, long currentGenerationId, InputStream source)
 		throws StandardException
 	{
 		if (factory.isReadOnly())
 			throw StandardException.newException(SQLState.FILE_READ_ONLY);
 
-		remove(name, currentGenerationId, purgeOnCommit);
+		remove(name, currentGenerationId);
 
 		long generationId = add(name, source);
 
@@ -181,6 +182,7 @@ public StorageFile getAsFile(String name, long generationId)
 	}
 
 	/**
+<<<<<<< .working
 	  @see FileResource#getAsFile
 	  */
 	public StorageFile getAsFile(String name)
@@ -189,6 +191,8 @@ public StorageFile getAsFile(String name)
 	}
 
 	/**
+=======
+>>>>>>> .merge-right.r551252
 	  @see FileResource#getAsStream
 	  @exception IOException trouble accessing file.
 	  */
@@ -240,7 +244,7 @@ protected RemoveFileOperation privRemoveFileOperation(
 } // end of class RFResource
 
 
-class RemoveFile implements Serviceable
+final class RemoveFile implements Serviceable, PrivilegedExceptionAction
 {
 	private final StorageFile fileToGo;
 
@@ -252,14 +256,10 @@ protected RemoveFileOperation privRemoveFileOperation(
 	public int performWork(ContextManager context)
         throws StandardException
     {
-        // SECURITY PERMISSION - MP1, OP5
-        if (fileToGo.exists())
-        {
-            if (!fileToGo.delete())
-            {
-                throw StandardException.newException(
-                    SQLState.FILE_CANNOT_REMOVE_FILE, fileToGo);
-            }
+        try {
+            AccessController.doPrivileged(this);
+        } catch (PrivilegedActionException e) {
+            throw (StandardException) (e.getException());
         }
         return Serviceable.DONE;
 	}
@@ -275,4 +275,15 @@ public boolean serviceImmediately()
 	{
 		return false;
 	}	
+
+    public Object run() throws StandardException {
+        // SECURITY PERMISSION - MP1, OP5
+        if (fileToGo.exists()) {
+            if (!fileToGo.delete()) {
+                throw StandardException.newException(
+                        SQLState.FILE_CANNOT_REMOVE_FILE, fileToGo);
+            }
+        }
+        return null;
+    }	
 }
