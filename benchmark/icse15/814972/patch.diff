diff --git a/incubator/cassandra/branches/cassandra-0.4/interface/gen-java/org/apache/cassandra/service/Cassandra.java b/incubator/cassandra/branches/cassandra-0.4/interface/gen-java/org/apache/cassandra/service/Cassandra.java
index 93933c31..1046f216 100644
--- a/incubator/cassandra/branches/cassandra-0.4/interface/gen-java/org/apache/cassandra/service/Cassandra.java
+++ b/incubator/cassandra/branches/cassandra-0.4/interface/gen-java/org/apache/cassandra/service/Cassandra.java
@@ -46,17 +46,17 @@
 
   public interface Iface {
 
-    public ColumnOrSuperColumn get(String keyspace, String key, ColumnPath column_path, int consistency_level) throws InvalidRequestException, NotFoundException, TException;
+    public ColumnOrSuperColumn get(String keyspace, String key, ColumnPath column_path, int consistency_level) throws InvalidRequestException, NotFoundException, UnavailableException, TException;
 
-    public List<ColumnOrSuperColumn> get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, NotFoundException, TException;
+    public List<ColumnOrSuperColumn> get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, NotFoundException, UnavailableException, TException;
 
-    public Map<String,ColumnOrSuperColumn> multiget(String keyspace, List<String> keys, ColumnPath column_path, int consistency_level) throws InvalidRequestException, TException;
+    public Map<String,ColumnOrSuperColumn> multiget(String keyspace, List<String> keys, ColumnPath column_path, int consistency_level) throws InvalidRequestException, UnavailableException, TException;
 
-    public Map<String,List<ColumnOrSuperColumn>> multiget_slice(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, TException;
+    public Map<String,List<ColumnOrSuperColumn>> multiget_slice(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, UnavailableException, TException;
 
-    public int get_count(String keyspace, String key, ColumnParent column_parent, int consistency_level) throws InvalidRequestException, TException;
+    public int get_count(String keyspace, String key, ColumnParent column_parent, int consistency_level) throws InvalidRequestException, UnavailableException, TException;
 
-    public List<String> get_key_range(String keyspace, String column_family, String start, String finish, int count, int consistency_level) throws InvalidRequestException, TException;
+    public List<String> get_key_range(String keyspace, String column_family, String start, String finish, int count, int consistency_level) throws InvalidRequestException, UnavailableException, TException;
 
     public void insert(String keyspace, String key, ColumnPath column_path, byte[] value, long timestamp, int consistency_level) throws InvalidRequestException, UnavailableException, TException;
 
@@ -99,7 +99,7 @@ public TProtocol getOutputProtocol()
       return this.oprot_;
     }
 
-    public ColumnOrSuperColumn get(String keyspace, String key, ColumnPath column_path, int consistency_level) throws InvalidRequestException, NotFoundException, TException
+    public ColumnOrSuperColumn get(String keyspace, String key, ColumnPath column_path, int consistency_level) throws InvalidRequestException, NotFoundException, UnavailableException, TException
     {
       send_get(keyspace, key, column_path, consistency_level);
       return recv_get();
@@ -118,7 +118,7 @@ public void send_get(String keyspace, String key, ColumnPath column_path, int co
       oprot_.getTransport().flush();
     }
 
-    public ColumnOrSuperColumn recv_get() throws InvalidRequestException, NotFoundException, TException
+    public ColumnOrSuperColumn recv_get() throws InvalidRequestException, NotFoundException, UnavailableException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
@@ -138,10 +138,13 @@ public ColumnOrSuperColumn recv_get() throws InvalidRequestException, NotFoundEx
       if (result.nfe != null) {
         throw result.nfe;
       }
+      if (result.ue != null) {
+        throw result.ue;
+      }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");
     }
 
-    public List<ColumnOrSuperColumn> get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, NotFoundException, TException
+    public List<ColumnOrSuperColumn> get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, NotFoundException, UnavailableException, TException
     {
       send_get_slice(keyspace, key, column_parent, predicate, consistency_level);
       return recv_get_slice();
@@ -161,7 +164,7 @@ public void send_get_slice(String keyspace, String key, ColumnParent column_pare
       oprot_.getTransport().flush();
     }
 
-    public List<ColumnOrSuperColumn> recv_get_slice() throws InvalidRequestException, NotFoundException, TException
+    public List<ColumnOrSuperColumn> recv_get_slice() throws InvalidRequestException, NotFoundException, UnavailableException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
@@ -181,10 +184,13 @@ public void send_get_slice(String keyspace, String key, ColumnParent column_pare
       if (result.nfe != null) {
         throw result.nfe;
       }
+      if (result.ue != null) {
+        throw result.ue;
+      }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_slice failed: unknown result");
     }
 
-    public Map<String,ColumnOrSuperColumn> multiget(String keyspace, List<String> keys, ColumnPath column_path, int consistency_level) throws InvalidRequestException, TException
+    public Map<String,ColumnOrSuperColumn> multiget(String keyspace, List<String> keys, ColumnPath column_path, int consistency_level) throws InvalidRequestException, UnavailableException, TException
     {
       send_multiget(keyspace, keys, column_path, consistency_level);
       return recv_multiget();
@@ -203,7 +209,7 @@ public void send_multiget(String keyspace, List<String> keys, ColumnPath column_
       oprot_.getTransport().flush();
     }
 
-    public Map<String,ColumnOrSuperColumn> recv_multiget() throws InvalidRequestException, TException
+    public Map<String,ColumnOrSuperColumn> recv_multiget() throws InvalidRequestException, UnavailableException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
@@ -220,10 +226,13 @@ public void send_multiget(String keyspace, List<String> keys, ColumnPath column_
       if (result.ire != null) {
         throw result.ire;
       }
+      if (result.ue != null) {
+        throw result.ue;
+      }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiget failed: unknown result");
     }
 
-    public Map<String,List<ColumnOrSuperColumn>> multiget_slice(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, TException
+    public Map<String,List<ColumnOrSuperColumn>> multiget_slice(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level) throws InvalidRequestException, UnavailableException, TException
     {
       send_multiget_slice(keyspace, keys, column_parent, predicate, consistency_level);
       return recv_multiget_slice();
@@ -243,7 +252,7 @@ public void send_multiget_slice(String keyspace, List<String> keys, ColumnParent
       oprot_.getTransport().flush();
     }
 
-    public Map<String,List<ColumnOrSuperColumn>> recv_multiget_slice() throws InvalidRequestException, TException
+    public Map<String,List<ColumnOrSuperColumn>> recv_multiget_slice() throws InvalidRequestException, UnavailableException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
@@ -260,10 +269,13 @@ public void send_multiget_slice(String keyspace, List<String> keys, ColumnParent
       if (result.ire != null) {
         throw result.ire;
       }
+      if (result.ue != null) {
+        throw result.ue;
+      }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "multiget_slice failed: unknown result");
     }
 
-    public int get_count(String keyspace, String key, ColumnParent column_parent, int consistency_level) throws InvalidRequestException, TException
+    public int get_count(String keyspace, String key, ColumnParent column_parent, int consistency_level) throws InvalidRequestException, UnavailableException, TException
     {
       send_get_count(keyspace, key, column_parent, consistency_level);
       return recv_get_count();
@@ -282,7 +294,7 @@ public void send_get_count(String keyspace, String key, ColumnParent column_pare
       oprot_.getTransport().flush();
     }
 
-    public int recv_get_count() throws InvalidRequestException, TException
+    public int recv_get_count() throws InvalidRequestException, UnavailableException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
@@ -299,10 +311,13 @@ public int recv_get_count() throws InvalidRequestException, TException
       if (result.ire != null) {
         throw result.ire;
       }
+      if (result.ue != null) {
+        throw result.ue;
+      }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_count failed: unknown result");
     }
 
-    public List<String> get_key_range(String keyspace, String column_family, String start, String finish, int count, int consistency_level) throws InvalidRequestException, TException
+    public List<String> get_key_range(String keyspace, String column_family, String start, String finish, int count, int consistency_level) throws InvalidRequestException, UnavailableException, TException
     {
       send_get_key_range(keyspace, column_family, start, finish, count, consistency_level);
       return recv_get_key_range();
@@ -323,7 +338,7 @@ public void send_get_key_range(String keyspace, String column_family, String sta
       oprot_.getTransport().flush();
     }
 
-    public List<String> recv_get_key_range() throws InvalidRequestException, TException
+    public List<String> recv_get_key_range() throws InvalidRequestException, UnavailableException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
@@ -340,6 +355,9 @@ public void send_get_key_range(String keyspace, String column_family, String sta
       if (result.ire != null) {
         throw result.ire;
       }
+      if (result.ue != null) {
+        throw result.ue;
+      }
       throw new TApplicationException(TApplicationException.MISSING_RESULT, "get_key_range failed: unknown result");
     }
 
@@ -623,6 +641,8 @@ public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TExcepti
           result.ire = ire;
         } catch (NotFoundException nfe) {
           result.nfe = nfe;
+        } catch (UnavailableException ue) {
+          result.ue = ue;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get");
@@ -653,6 +673,8 @@ public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TExcepti
           result.ire = ire;
         } catch (NotFoundException nfe) {
           result.nfe = nfe;
+        } catch (UnavailableException ue) {
+          result.ue = ue;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_slice", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_slice");
@@ -681,6 +703,8 @@ public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TExcepti
           result.success = iface_.multiget(args.keyspace, args.keys, args.column_path, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
+        } catch (UnavailableException ue) {
+          result.ue = ue;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing multiget", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing multiget");
@@ -709,6 +733,8 @@ public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TExcepti
           result.success = iface_.multiget_slice(args.keyspace, args.keys, args.column_parent, args.predicate, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
+        } catch (UnavailableException ue) {
+          result.ue = ue;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing multiget_slice", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing multiget_slice");
@@ -738,6 +764,8 @@ public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TExcepti
           result.setSuccessIsSet(true);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
+        } catch (UnavailableException ue) {
+          result.ue = ue;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_count", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_count");
@@ -766,6 +794,8 @@ public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TExcepti
           result.success = iface_.get_key_range(args.keyspace, args.column_family, args.start, args.finish, args.count, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
+        } catch (UnavailableException ue) {
+          result.ue = ue;
         } catch (Throwable th) {
           LOGGER.error("Internal error processing get_key_range", th);
           TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing get_key_range");
@@ -1449,13 +1479,16 @@ public void validate() throws TException {
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);
+    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)3);
 
     public ColumnOrSuperColumn success;
     public InvalidRequestException ire;
     public NotFoundException nfe;
+    public UnavailableException ue;
     public static final int SUCCESS = 0;
     public static final int IRE = 1;
     public static final int NFE = 2;
+    public static final int UE = 3;
 
     // isset id assignments
 
@@ -1466,6 +1499,8 @@ public void validate() throws TException {
           new FieldValueMetaData(TType.STRUCT)));
       put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
+      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
@@ -1478,12 +1513,14 @@ public get_result() {
     public get_result(
       ColumnOrSuperColumn success,
       InvalidRequestException ire,
-      NotFoundException nfe)
+      NotFoundException nfe,
+      UnavailableException ue)
     {
       this();
       this.success = success;
       this.ire = ire;
       this.nfe = nfe;
+      this.ue = ue;
     }
 
     /**
@@ -1499,6 +1536,9 @@ public get_result(get_result other) {
       if (other.isSetNfe()) {
         this.nfe = new NotFoundException(other.nfe);
       }
+      if (other.isSetUe()) {
+        this.ue = new UnavailableException(other.ue);
+      }
     }
 
     public get_result deepCopy() {
@@ -1582,6 +1622,30 @@ public void setNfeIsSet(boolean value) {
       }
     }
 
+    public UnavailableException getUe() {
+      return this.ue;
+    }
+
+    public get_result setUe(UnavailableException ue) {
+      this.ue = ue;
+      return this;
+    }
+
+    public void unsetUe() {
+      this.ue = null;
+    }
+
+    // Returns true if field ue is set (has been asigned a value) and false otherwise
+    public boolean isSetUe() {
+      return this.ue != null;
+    }
+
+    public void setUeIsSet(boolean value) {
+      if (!value) {
+        this.ue = null;
+      }
+    }
+
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
@@ -1608,6 +1672,14 @@ public void setFieldValue(int fieldID, Object value) {
         }
         break;
 
+      case UE:
+        if (value == null) {
+          unsetUe();
+        } else {
+          setUe((UnavailableException)value);
+        }
+        break;
+
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -1624,6 +1696,9 @@ public Object getFieldValue(int fieldID) {
       case NFE:
         return getNfe();
 
+      case UE:
+        return getUe();
+
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -1638,6 +1713,8 @@ public boolean isSet(int fieldID) {
         return isSetIre();
       case NFE:
         return isSetNfe();
+      case UE:
+        return isSetUe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -1683,6 +1760,15 @@ public boolean equals(get_result that) {
           return false;
       }
 
+      boolean this_present_ue = true && this.isSetUe();
+      boolean that_present_ue = true && that.isSetUe();
+      if (this_present_ue || that_present_ue) {
+        if (!(this_present_ue && that_present_ue))
+          return false;
+        if (!this.ue.equals(that.ue))
+          return false;
+      }
+
       return true;
     }
 
@@ -1723,6 +1809,14 @@ public int compareTo(get_result other) {
       if (lastComparison != 0) {
         return lastComparison;
       }
+      lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
       return 0;
     }
 
@@ -1761,6 +1855,14 @@ public void read(TProtocol iprot) throws TException {
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
+          case UE:
+            if (field.type == TType.STRUCT) {
+              this.ue = new UnavailableException();
+              this.ue.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
@@ -1789,6 +1891,10 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(NFE_FIELD_DESC);
         this.nfe.write(oprot);
         oprot.writeFieldEnd();
+      } else if (this.isSetUe()) {
+        oprot.writeFieldBegin(UE_FIELD_DESC);
+        this.ue.write(oprot);
+        oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
@@ -1822,6 +1928,14 @@ public String toString() {
         sb.append(this.nfe);
       }
       first = false;
+      if (!first) sb.append(", ");
+      sb.append("ue:");
+      if (this.ue == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ue);
+      }
+      first = false;
       sb.append(")");
       return sb.toString();
     }
@@ -2435,13 +2549,16 @@ public void validate() throws TException {
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
     private static final TField NFE_FIELD_DESC = new TField("nfe", TType.STRUCT, (short)2);
+    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)3);
 
     public List<ColumnOrSuperColumn> success;
     public InvalidRequestException ire;
     public NotFoundException nfe;
+    public UnavailableException ue;
     public static final int SUCCESS = 0;
     public static final int IRE = 1;
     public static final int NFE = 2;
+    public static final int UE = 3;
 
     // isset id assignments
 
@@ -2453,6 +2570,8 @@ public void validate() throws TException {
           new FieldValueMetaData(TType.STRUCT)));
       put(NFE, new FieldMetaData("nfe", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
+      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
@@ -2465,12 +2584,14 @@ public get_slice_result() {
     public get_slice_result(
       List<ColumnOrSuperColumn> success,
       InvalidRequestException ire,
-      NotFoundException nfe)
+      NotFoundException nfe,
+      UnavailableException ue)
     {
       this();
       this.success = success;
       this.ire = ire;
       this.nfe = nfe;
+      this.ue = ue;
     }
 
     /**
@@ -2490,6 +2611,9 @@ public get_slice_result(get_slice_result other) {
       if (other.isSetNfe()) {
         this.nfe = new NotFoundException(other.nfe);
       }
+      if (other.isSetUe()) {
+        this.ue = new UnavailableException(other.ue);
+      }
     }
 
     public get_slice_result deepCopy() {
@@ -2573,6 +2697,30 @@ public void setNfeIsSet(boolean value) {
       }
     }
 
+    public UnavailableException getUe() {
+      return this.ue;
+    }
+
+    public get_slice_result setUe(UnavailableException ue) {
+      this.ue = ue;
+      return this;
+    }
+
+    public void unsetUe() {
+      this.ue = null;
+    }
+
+    // Returns true if field ue is set (has been asigned a value) and false otherwise
+    public boolean isSetUe() {
+      return this.ue != null;
+    }
+
+    public void setUeIsSet(boolean value) {
+      if (!value) {
+        this.ue = null;
+      }
+    }
+
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
@@ -2599,6 +2747,14 @@ public void setFieldValue(int fieldID, Object value) {
         }
         break;
 
+      case UE:
+        if (value == null) {
+          unsetUe();
+        } else {
+          setUe((UnavailableException)value);
+        }
+        break;
+
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -2615,6 +2771,9 @@ public Object getFieldValue(int fieldID) {
       case NFE:
         return getNfe();
 
+      case UE:
+        return getUe();
+
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -2629,6 +2788,8 @@ public boolean isSet(int fieldID) {
         return isSetIre();
       case NFE:
         return isSetNfe();
+      case UE:
+        return isSetUe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -2674,6 +2835,15 @@ public boolean equals(get_slice_result that) {
           return false;
       }
 
+      boolean this_present_ue = true && this.isSetUe();
+      boolean that_present_ue = true && that.isSetUe();
+      if (this_present_ue || that_present_ue) {
+        if (!(this_present_ue && that_present_ue))
+          return false;
+        if (!this.ue.equals(that.ue))
+          return false;
+      }
+
       return true;
     }
 
@@ -2714,6 +2884,14 @@ public int compareTo(get_slice_result other) {
       if (lastComparison != 0) {
         return lastComparison;
       }
+      lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
       return 0;
     }
 
@@ -2762,6 +2940,14 @@ public void read(TProtocol iprot) throws TException {
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
+          case UE:
+            if (field.type == TType.STRUCT) {
+              this.ue = new UnavailableException();
+              this.ue.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
@@ -2797,6 +2983,10 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(NFE_FIELD_DESC);
         this.nfe.write(oprot);
         oprot.writeFieldEnd();
+      } else if (this.isSetUe()) {
+        oprot.writeFieldBegin(UE_FIELD_DESC);
+        this.ue.write(oprot);
+        oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
@@ -2830,6 +3020,14 @@ public String toString() {
         sb.append(this.nfe);
       }
       first = false;
+      if (!first) sb.append(", ");
+      sb.append("ue:");
+      if (this.ue == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ue);
+      }
+      first = false;
       sb.append(")");
       return sb.toString();
     }
@@ -3376,11 +3574,14 @@ public void validate() throws TException {
     private static final TStruct STRUCT_DESC = new TStruct("multiget_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
+    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
 
     public Map<String,ColumnOrSuperColumn> success;
     public InvalidRequestException ire;
+    public UnavailableException ue;
     public static final int SUCCESS = 0;
     public static final int IRE = 1;
+    public static final int UE = 2;
 
     // isset id assignments
 
@@ -3391,6 +3592,8 @@ public void validate() throws TException {
               new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class))));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
+      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
@@ -3402,11 +3605,13 @@ public multiget_result() {
 
     public multiget_result(
       Map<String,ColumnOrSuperColumn> success,
-      InvalidRequestException ire)
+      InvalidRequestException ire,
+      UnavailableException ue)
     {
       this();
       this.success = success;
       this.ire = ire;
+      this.ue = ue;
     }
 
     /**
@@ -3431,6 +3636,9 @@ public multiget_result(multiget_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
+      if (other.isSetUe()) {
+        this.ue = new UnavailableException(other.ue);
+      }
     }
 
     public multiget_result deepCopy() {
@@ -3490,6 +3698,30 @@ public void setIreIsSet(boolean value) {
       }
     }
 
+    public UnavailableException getUe() {
+      return this.ue;
+    }
+
+    public multiget_result setUe(UnavailableException ue) {
+      this.ue = ue;
+      return this;
+    }
+
+    public void unsetUe() {
+      this.ue = null;
+    }
+
+    // Returns true if field ue is set (has been asigned a value) and false otherwise
+    public boolean isSetUe() {
+      return this.ue != null;
+    }
+
+    public void setUeIsSet(boolean value) {
+      if (!value) {
+        this.ue = null;
+      }
+    }
+
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
@@ -3508,6 +3740,14 @@ public void setFieldValue(int fieldID, Object value) {
         }
         break;
 
+      case UE:
+        if (value == null) {
+          unsetUe();
+        } else {
+          setUe((UnavailableException)value);
+        }
+        break;
+
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -3521,6 +3761,9 @@ public Object getFieldValue(int fieldID) {
       case IRE:
         return getIre();
 
+      case UE:
+        return getUe();
+
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -3533,6 +3776,8 @@ public boolean isSet(int fieldID) {
         return isSetSuccess();
       case IRE:
         return isSetIre();
+      case UE:
+        return isSetUe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -3569,6 +3814,15 @@ public boolean equals(multiget_result that) {
           return false;
       }
 
+      boolean this_present_ue = true && this.isSetUe();
+      boolean that_present_ue = true && that.isSetUe();
+      if (this_present_ue || that_present_ue) {
+        if (!(this_present_ue && that_present_ue))
+          return false;
+        if (!this.ue.equals(that.ue))
+          return false;
+      }
+
       return true;
     }
 
@@ -3616,12 +3870,20 @@ public void read(TProtocol iprot) throws TException {
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
-          default:
-            TProtocolUtil.skip(iprot, field.type);
-            break;
-        }
-        iprot.readFieldEnd();
-      }
+          case UE:
+            if (field.type == TType.STRUCT) {
+              this.ue = new UnavailableException();
+              this.ue.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
+          default:
+            TProtocolUtil.skip(iprot, field.type);
+            break;
+        }
+        iprot.readFieldEnd();
+      }
       iprot.readStructEnd();
 
 
@@ -3648,6 +3910,10 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
+      } else if (this.isSetUe()) {
+        oprot.writeFieldBegin(UE_FIELD_DESC);
+        this.ue.write(oprot);
+        oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
@@ -3673,6 +3939,14 @@ public String toString() {
         sb.append(this.ire);
       }
       first = false;
+      if (!first) sb.append(", ");
+      sb.append("ue:");
+      if (this.ue == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ue);
+      }
+      first = false;
       sb.append(")");
       return sb.toString();
     }
@@ -4307,11 +4581,14 @@ public void validate() throws TException {
     private static final TStruct STRUCT_DESC = new TStruct("multiget_slice_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.MAP, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
+    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
 
     public Map<String,List<ColumnOrSuperColumn>> success;
     public InvalidRequestException ire;
+    public UnavailableException ue;
     public static final int SUCCESS = 0;
     public static final int IRE = 1;
+    public static final int UE = 2;
 
     // isset id assignments
 
@@ -4323,6 +4600,8 @@ public void validate() throws TException {
                   new StructMetaData(TType.STRUCT, ColumnOrSuperColumn.class)))));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
+      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
@@ -4334,11 +4613,13 @@ public multiget_slice_result() {
 
     public multiget_slice_result(
       Map<String,List<ColumnOrSuperColumn>> success,
-      InvalidRequestException ire)
+      InvalidRequestException ire,
+      UnavailableException ue)
     {
       this();
       this.success = success;
       this.ire = ire;
+      this.ue = ue;
     }
 
     /**
@@ -4366,6 +4647,9 @@ public multiget_slice_result(multiget_slice_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
+      if (other.isSetUe()) {
+        this.ue = new UnavailableException(other.ue);
+      }
     }
 
     public multiget_slice_result deepCopy() {
@@ -4425,6 +4709,30 @@ public void setIreIsSet(boolean value) {
       }
     }
 
+    public UnavailableException getUe() {
+      return this.ue;
+    }
+
+    public multiget_slice_result setUe(UnavailableException ue) {
+      this.ue = ue;
+      return this;
+    }
+
+    public void unsetUe() {
+      this.ue = null;
+    }
+
+    // Returns true if field ue is set (has been asigned a value) and false otherwise
+    public boolean isSetUe() {
+      return this.ue != null;
+    }
+
+    public void setUeIsSet(boolean value) {
+      if (!value) {
+        this.ue = null;
+      }
+    }
+
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
@@ -4443,6 +4751,14 @@ public void setFieldValue(int fieldID, Object value) {
         }
         break;
 
+      case UE:
+        if (value == null) {
+          unsetUe();
+        } else {
+          setUe((UnavailableException)value);
+        }
+        break;
+
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -4456,6 +4772,9 @@ public Object getFieldValue(int fieldID) {
       case IRE:
         return getIre();
 
+      case UE:
+        return getUe();
+
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -4468,6 +4787,8 @@ public boolean isSet(int fieldID) {
         return isSetSuccess();
       case IRE:
         return isSetIre();
+      case UE:
+        return isSetUe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -4504,6 +4825,15 @@ public boolean equals(multiget_slice_result that) {
           return false;
       }
 
+      boolean this_present_ue = true && this.isSetUe();
+      boolean that_present_ue = true && that.isSetUe();
+      if (this_present_ue || that_present_ue) {
+        if (!(this_present_ue && that_present_ue))
+          return false;
+        if (!this.ue.equals(that.ue))
+          return false;
+      }
+
       return true;
     }
 
@@ -4561,6 +4891,14 @@ public void read(TProtocol iprot) throws TException {
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
+          case UE:
+            if (field.type == TType.STRUCT) {
+              this.ue = new UnavailableException();
+              this.ue.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
@@ -4600,6 +4938,10 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
+      } else if (this.isSetUe()) {
+        oprot.writeFieldBegin(UE_FIELD_DESC);
+        this.ue.write(oprot);
+        oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
@@ -4625,6 +4967,14 @@ public String toString() {
         sb.append(this.ire);
       }
       first = false;
+      if (!first) sb.append(", ");
+      sb.append("ue:");
+      if (this.ue == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ue);
+      }
+      first = false;
       sb.append(")");
       return sb.toString();
     }
@@ -5149,11 +5499,14 @@ public void validate() throws TException {
     private static final TStruct STRUCT_DESC = new TStruct("get_count_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
+    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
 
     public int success;
     public InvalidRequestException ire;
+    public UnavailableException ue;
     public static final int SUCCESS = 0;
     public static final int IRE = 1;
+    public static final int UE = 2;
 
     // isset id assignments
     private static final int __SUCCESS_ISSET_ID = 0;
@@ -5164,6 +5517,8 @@ public void validate() throws TException {
           new FieldValueMetaData(TType.I32)));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
+      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
@@ -5175,12 +5530,14 @@ public get_count_result() {
 
     public get_count_result(
       int success,
-      InvalidRequestException ire)
+      InvalidRequestException ire,
+      UnavailableException ue)
     {
       this();
       this.success = success;
       setSuccessIsSet(true);
       this.ire = ire;
+      this.ue = ue;
     }
 
     /**
@@ -5193,6 +5550,9 @@ public get_count_result(get_count_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
+      if (other.isSetUe()) {
+        this.ue = new UnavailableException(other.ue);
+      }
     }
 
     public get_count_result deepCopy() {
@@ -5251,6 +5611,30 @@ public void setIreIsSet(boolean value) {
       }
     }
 
+    public UnavailableException getUe() {
+      return this.ue;
+    }
+
+    public get_count_result setUe(UnavailableException ue) {
+      this.ue = ue;
+      return this;
+    }
+
+    public void unsetUe() {
+      this.ue = null;
+    }
+
+    // Returns true if field ue is set (has been asigned a value) and false otherwise
+    public boolean isSetUe() {
+      return this.ue != null;
+    }
+
+    public void setUeIsSet(boolean value) {
+      if (!value) {
+        this.ue = null;
+      }
+    }
+
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
@@ -5269,6 +5653,14 @@ public void setFieldValue(int fieldID, Object value) {
         }
         break;
 
+      case UE:
+        if (value == null) {
+          unsetUe();
+        } else {
+          setUe((UnavailableException)value);
+        }
+        break;
+
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -5282,6 +5674,9 @@ public Object getFieldValue(int fieldID) {
       case IRE:
         return getIre();
 
+      case UE:
+        return getUe();
+
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -5294,6 +5689,8 @@ public boolean isSet(int fieldID) {
         return isSetSuccess();
       case IRE:
         return isSetIre();
+      case UE:
+        return isSetUe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -5330,6 +5727,15 @@ public boolean equals(get_count_result that) {
           return false;
       }
 
+      boolean this_present_ue = true && this.isSetUe();
+      boolean that_present_ue = true && that.isSetUe();
+      if (this_present_ue || that_present_ue) {
+        if (!(this_present_ue && that_present_ue))
+          return false;
+        if (!this.ue.equals(that.ue))
+          return false;
+      }
+
       return true;
     }
 
@@ -5362,6 +5768,14 @@ public int compareTo(get_count_result other) {
       if (lastComparison != 0) {
         return lastComparison;
       }
+      lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
       return 0;
     }
 
@@ -5392,6 +5806,14 @@ public void read(TProtocol iprot) throws TException {
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
+          case UE:
+            if (field.type == TType.STRUCT) {
+              this.ue = new UnavailableException();
+              this.ue.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
@@ -5416,6 +5838,10 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
+      } else if (this.isSetUe()) {
+        oprot.writeFieldBegin(UE_FIELD_DESC);
+        this.ue.write(oprot);
+        oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
@@ -5437,6 +5863,14 @@ public String toString() {
         sb.append(this.ire);
       }
       first = false;
+      if (!first) sb.append(", ");
+      sb.append("ue:");
+      if (this.ue == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ue);
+      }
+      first = false;
       sb.append(")");
       return sb.toString();
     }
@@ -6135,11 +6569,14 @@ public void validate() throws TException {
     private static final TStruct STRUCT_DESC = new TStruct("get_key_range_result");
     private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
     private static final TField IRE_FIELD_DESC = new TField("ire", TType.STRUCT, (short)1);
+    private static final TField UE_FIELD_DESC = new TField("ue", TType.STRUCT, (short)2);
 
     public List<String> success;
     public InvalidRequestException ire;
+    public UnavailableException ue;
     public static final int SUCCESS = 0;
     public static final int IRE = 1;
+    public static final int UE = 2;
 
     // isset id assignments
 
@@ -6149,6 +6586,8 @@ public void validate() throws TException {
               new FieldValueMetaData(TType.STRING))));
       put(IRE, new FieldMetaData("ire", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
+      put(UE, new FieldMetaData("ue", TFieldRequirementType.DEFAULT, 
+          new FieldValueMetaData(TType.STRUCT)));
     }});
 
     static {
@@ -6160,11 +6599,13 @@ public get_key_range_result() {
 
     public get_key_range_result(
       List<String> success,
-      InvalidRequestException ire)
+      InvalidRequestException ire,
+      UnavailableException ue)
     {
       this();
       this.success = success;
       this.ire = ire;
+      this.ue = ue;
     }
 
     /**
@@ -6181,6 +6622,9 @@ public get_key_range_result(get_key_range_result other) {
       if (other.isSetIre()) {
         this.ire = new InvalidRequestException(other.ire);
       }
+      if (other.isSetUe()) {
+        this.ue = new UnavailableException(other.ue);
+      }
     }
 
     public get_key_range_result deepCopy() {
@@ -6240,6 +6684,30 @@ public void setIreIsSet(boolean value) {
       }
     }
 
+    public UnavailableException getUe() {
+      return this.ue;
+    }
+
+    public get_key_range_result setUe(UnavailableException ue) {
+      this.ue = ue;
+      return this;
+    }
+
+    public void unsetUe() {
+      this.ue = null;
+    }
+
+    // Returns true if field ue is set (has been asigned a value) and false otherwise
+    public boolean isSetUe() {
+      return this.ue != null;
+    }
+
+    public void setUeIsSet(boolean value) {
+      if (!value) {
+        this.ue = null;
+      }
+    }
+
     public void setFieldValue(int fieldID, Object value) {
       switch (fieldID) {
       case SUCCESS:
@@ -6258,6 +6726,14 @@ public void setFieldValue(int fieldID, Object value) {
         }
         break;
 
+      case UE:
+        if (value == null) {
+          unsetUe();
+        } else {
+          setUe((UnavailableException)value);
+        }
+        break;
+
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -6271,6 +6747,9 @@ public Object getFieldValue(int fieldID) {
       case IRE:
         return getIre();
 
+      case UE:
+        return getUe();
+
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -6283,6 +6762,8 @@ public boolean isSet(int fieldID) {
         return isSetSuccess();
       case IRE:
         return isSetIre();
+      case UE:
+        return isSetUe();
       default:
         throw new IllegalArgumentException("Field " + fieldID + " doesn't exist!");
       }
@@ -6319,6 +6800,15 @@ public boolean equals(get_key_range_result that) {
           return false;
       }
 
+      boolean this_present_ue = true && this.isSetUe();
+      boolean that_present_ue = true && that.isSetUe();
+      if (this_present_ue || that_present_ue) {
+        if (!(this_present_ue && that_present_ue))
+          return false;
+        if (!this.ue.equals(that.ue))
+          return false;
+      }
+
       return true;
     }
 
@@ -6351,6 +6841,14 @@ public int compareTo(get_key_range_result other) {
       if (lastComparison != 0) {
         return lastComparison;
       }
+      lastComparison = Boolean.valueOf(isSetUe()).compareTo(isSetUe());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      lastComparison = TBaseHelper.compareTo(ue, typedOther.ue);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
       return 0;
     }
 
@@ -6390,6 +6888,14 @@ public void read(TProtocol iprot) throws TException {
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
+          case UE:
+            if (field.type == TType.STRUCT) {
+              this.ue = new UnavailableException();
+              this.ue.read(iprot);
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
           default:
             TProtocolUtil.skip(iprot, field.type);
             break;
@@ -6421,6 +6927,10 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(IRE_FIELD_DESC);
         this.ire.write(oprot);
         oprot.writeFieldEnd();
+      } else if (this.isSetUe()) {
+        oprot.writeFieldBegin(UE_FIELD_DESC);
+        this.ue.write(oprot);
+        oprot.writeFieldEnd();
       }
       oprot.writeFieldStop();
       oprot.writeStructEnd();
@@ -6446,6 +6956,14 @@ public String toString() {
         sb.append(this.ire);
       }
       first = false;
+      if (!first) sb.append(", ");
+      sb.append("ue:");
+      if (this.ue == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.ue);
+      }
+      first = false;
       sb.append(")");
       return sb.toString();
     }
diff --git a/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/cli/CliClient.java b/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/cli/CliClient.java
index 250e991c..bd8f2000 100644
--- a/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/cli/CliClient.java
+++ b/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/cli/CliClient.java
@@ -111,7 +111,7 @@ private void cleanupAndExit()
     }
 
     // Execute GET statement
-    private void executeGet(CommonTree ast) throws TException, NotFoundException, InvalidRequestException
+    private void executeGet(CommonTree ast) throws TException, NotFoundException, InvalidRequestException, UnavailableException
     {
         if (!CliMain.isConnected())
             return;
diff --git a/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/locator/TokenMetadata.java b/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/locator/TokenMetadata.java
index 148b4f92..09dea3b6 100644
--- a/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/locator/TokenMetadata.java
+++ b/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/locator/TokenMetadata.java
@@ -24,6 +24,9 @@
 
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.net.EndPoint;
+import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.gms.FailureDetector;
+import org.apache.cassandra.service.UnavailableException;
 
 public class TokenMetadata
 {
@@ -153,7 +156,7 @@ public EndPoint getFirstEndpoint()
     }
     
 
-    public EndPoint getNextEndpoint(EndPoint endPoint)
+    public EndPoint getNextEndpoint(EndPoint endPoint) throws UnavailableException
     {
         lock_.readLock().lock();
         try
@@ -163,7 +166,16 @@ public EndPoint getNextEndpoint(EndPoint endPoint)
                 return null;
             Collections.sort(tokens);
             int i = tokens.indexOf(endPointToTokenMap_.get(endPoint)); // TODO binary search
-            return tokenToEndPointMap_.get(tokens.get((i + 1) % tokens.size()));
+            int j = 1;
+            EndPoint ep;
+            while (!FailureDetector.instance().isAlive((ep = tokenToEndPointMap_.get(tokens.get((i + j) % tokens.size())))))
+            {
+                if (++j > DatabaseDescriptor.getReplicationFactor())
+                {
+                    throw new UnavailableException();
+                }
+            }
+            return ep;
         }
         finally
         {
diff --git a/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/service/CassandraServer.java b/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/service/CassandraServer.java
index ecee92f7..96ea527d 100644
--- a/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/service/CassandraServer.java
+++ b/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/service/CassandraServer.java
@@ -72,7 +72,8 @@ public void start() throws IOException
 		storageService.start();
 	}
 
-    protected Map<String, ColumnFamily> readColumnFamily(List<ReadCommand> commands, int consistency_level) throws InvalidRequestException
+    protected Map<String, ColumnFamily> readColumnFamily(List<ReadCommand> commands, int consistency_level)
+    throws InvalidRequestException, UnavailableException
     {
         // TODO - Support multiple column families per row, right now row only contains 1 column family
         String cfName = commands.get(0).getColumnFamilyName();
@@ -175,7 +176,8 @@ public void start() throws IOException
         return thriftSuperColumns;
     }
 
-    private Map<String, List<ColumnOrSuperColumn>> getSlice(List<ReadCommand> commands, int consistency_level) throws InvalidRequestException
+    private Map<String, List<ColumnOrSuperColumn>> getSlice(List<ReadCommand> commands, int consistency_level)
+    throws InvalidRequestException, UnavailableException
     {
         Map<String, ColumnFamily> cfamilies = readColumnFamily(commands, consistency_level);
         Map<String, List<ColumnOrSuperColumn>> columnFamiliesMap = new HashMap<String, List<ColumnOrSuperColumn>>();
@@ -211,7 +213,7 @@ public void start() throws IOException
     }
 
     public List<ColumnOrSuperColumn> get_slice(String keyspace, String key, ColumnParent column_parent, SlicePredicate predicate, int consistency_level)
-    throws InvalidRequestException, NotFoundException
+    throws InvalidRequestException, NotFoundException, UnavailableException
     {
         if (logger.isDebugEnabled())
             logger.debug("get_slice");
@@ -219,7 +221,7 @@ public void start() throws IOException
     }
     
     public Map<String, List<ColumnOrSuperColumn>> multiget_slice(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level)
-    throws InvalidRequestException
+    throws InvalidRequestException, UnavailableException
     {
         if (logger.isDebugEnabled())
             logger.debug("multiget_slice");
@@ -227,7 +229,7 @@ public void start() throws IOException
     }
 
     private Map<String, List<ColumnOrSuperColumn>> multigetSliceInternal(String keyspace, List<String> keys, ColumnParent column_parent, SlicePredicate predicate, int consistency_level)
-    throws InvalidRequestException
+    throws InvalidRequestException, UnavailableException
     {
         ThriftValidation.validateColumnParent(keyspace, column_parent);
         List<ReadCommand> commands = new ArrayList<ReadCommand>();
@@ -250,7 +252,7 @@ public void start() throws IOException
     }
 
     public ColumnOrSuperColumn get(String table, String key, ColumnPath column_path, int consistency_level)
-    throws InvalidRequestException, NotFoundException
+    throws InvalidRequestException, NotFoundException, UnavailableException
     {
         if (logger.isDebugEnabled())
             logger.debug("get");
@@ -264,7 +266,7 @@ public ColumnOrSuperColumn get(String table, String key, ColumnPath column_path,
 
     /** no values will be mapped to keys with no data */
     private Map<String, Collection<IColumn>> multigetColumns(List<ReadCommand> commands, int consistency_level)
-    throws InvalidRequestException
+    throws InvalidRequestException, UnavailableException
     {
         Map<String, ColumnFamily> cfamilies = readColumnFamily(commands, consistency_level);
         Map<String, Collection<IColumn>> columnFamiliesMap = new HashMap<String, Collection<IColumn>>();
@@ -299,7 +301,7 @@ public ColumnOrSuperColumn get(String table, String key, ColumnPath column_path,
 
     /** always returns a ColumnOrSuperColumn for each key, even if there is no data for it */
     public Map<String, ColumnOrSuperColumn> multiget(String table, List<String> keys, ColumnPath column_path, int consistency_level)
-    throws InvalidRequestException
+    throws InvalidRequestException, UnavailableException
     {
         if (logger.isDebugEnabled())
             logger.debug("multiget");
@@ -307,7 +309,7 @@ public ColumnOrSuperColumn get(String table, String key, ColumnPath column_path,
     }
 
     private Map<String, ColumnOrSuperColumn> multigetInternal(String table, List<String> keys, ColumnPath column_path, int consistency_level)
-    throws InvalidRequestException
+    throws InvalidRequestException, UnavailableException
     {
         ThriftValidation.validateColumnPath(table, column_path);
 
@@ -356,7 +358,7 @@ public ColumnOrSuperColumn get(String table, String key, ColumnPath column_path,
     }
 
     public int get_count(String table, String key, ColumnParent column_parent, int consistency_level)
-    throws InvalidRequestException
+    throws InvalidRequestException, UnavailableException
     {
         if (logger.isDebugEnabled())
             logger.debug("get_count");
@@ -364,7 +366,7 @@ public int get_count(String table, String key, ColumnParent column_parent, int c
     }
 
     private Map<String, Integer> multigetCountInternal(String table, List<String> keys, ColumnParent column_parent, int consistency_level)
-    throws InvalidRequestException
+    throws InvalidRequestException, UnavailableException
     {
         // validateColumnParent assumes we require simple columns; g_c_c is the only
         // one of the columnParent-taking apis that can also work at the SC level.
@@ -576,7 +578,8 @@ else if (propertyName.equals("version"))
         return columnFamiliesMap;
     }
 
-    public List<String> get_key_range(String tablename, String columnFamily, String startWith, String stopAt, int maxResults, int consistency_level) throws InvalidRequestException, TException
+    public List<String> get_key_range(String tablename, String columnFamily, String startWith, String stopAt, int maxResults, int consistency_level)
+    throws InvalidRequestException, TException, UnavailableException
     {
         if (logger.isDebugEnabled())
             logger.debug("get_key_range");
diff --git a/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/service/StorageProxy.java b/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/service/StorageProxy.java
index 34b10e67..24fc2e3c 100644
--- a/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/service/StorageProxy.java
+++ b/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/service/StorageProxy.java
@@ -233,7 +233,7 @@ public static void insertBlocking(RowMutation rm) throws UnavailableException
      * @return the row associated with command.key
      * @throws Exception
      */
-    private static List<Row> weakReadRemote(List<ReadCommand> commands) throws IOException
+    private static List<Row> weakReadRemote(List<ReadCommand> commands) throws IOException, UnavailableException
     {
         if (logger.isDebugEnabled())
             logger.debug("weakreadlocal reading " + StringUtils.join(commands, ", "));
@@ -245,7 +245,6 @@ public static void insertBlocking(RowMutation rm) throws UnavailableException
         for (ReadCommand command: commands)
         {
             EndPoint endPoint = StorageService.instance().findSuitableEndPoint(command.key);
-            assert endPoint != null;
             Message message = command.makeReadMessage();
 
             if (logger.isDebugEnabled())
@@ -281,7 +280,7 @@ public static void insertBlocking(RowMutation rm) throws UnavailableException
      * a specific set of column names from a given column family.
      */
     public static List<Row> readProtocol(List<ReadCommand> commands, int consistency_level)
-    throws IOException, TimeoutException, InvalidRequestException
+    throws IOException, TimeoutException, InvalidRequestException, UnavailableException
     {
         long startTime = System.currentTimeMillis();
 
@@ -335,7 +334,7 @@ public static void insertBlocking(RowMutation rm) throws UnavailableException
          * 7. else carry out read repair by getting data from all the nodes.
         // 5. return success
      */
-    private static List<Row> strongRead(List<ReadCommand> commands) throws IOException, TimeoutException, InvalidRequestException
+    private static List<Row> strongRead(List<ReadCommand> commands) throws IOException, TimeoutException, InvalidRequestException, UnavailableException
     {
         List<QuorumResponseHandler<Row>> quorumResponseHandlers = new ArrayList<QuorumResponseHandler<Row>>();
         List<EndPoint[]> commandEndPoints = new ArrayList<EndPoint[]>();
@@ -449,52 +448,6 @@ public static void insertBlocking(RowMutation rm) throws UnavailableException
         return messages;
     }
     
-    private static MultiQuorumResponseHandler dispatchMessagesMulti(Map<String, ReadCommand[]> readMessages, Map<String, Message[]> messages) throws IOException
-    {
-        Set<String> keys = messages.keySet();
-        /* This maps the keys to the original data read messages */
-        Map<String, ReadCommand> readMessage = new HashMap<String, ReadCommand>();
-        /* This maps the keys to their respective endpoints/replicas */
-        Map<String, EndPoint[]> endpoints = new HashMap<String, EndPoint[]>();
-        /* Groups the messages that need to be sent to the individual keys */
-        Message[][] msgList = new Message[messages.size()][DatabaseDescriptor.getReplicationFactor()];
-        /* Respects the above grouping and provides the endpoints for the above messages */
-        EndPoint[][] epList = new EndPoint[messages.size()][DatabaseDescriptor.getReplicationFactor()];
-        
-        int i = 0;
-        for ( String key : keys )
-        {
-            /* This is the primary */
-            EndPoint dataPoint = StorageService.instance().findSuitableEndPoint(key);
-            List<EndPoint> replicas = new ArrayList<EndPoint>( StorageService.instance().getLiveReadStorageEndPoints(key) );
-            replicas.remove(dataPoint);
-            /* Get the messages to be sent index 0 is the data messages and index 1 is the digest message */
-            Message[] message = messages.get(key);           
-            msgList[i][0] = message[0];
-            int N = DatabaseDescriptor.getReplicationFactor();
-            for ( int j = 1; j < N; ++j )
-            {
-                msgList[i][j] = message[1];
-            }
-            /* Get the endpoints to which the above messages need to be sent */
-            epList[i][0] = dataPoint;
-            for ( int j = 1; i < N; ++i )
-            {                
-                epList[i][j] = replicas.get(j - 1);
-            } 
-            /* Data ReadMessage associated with this key */
-            readMessage.put( key, readMessages.get(key)[0] );
-            /* EndPoints for this specific key */
-            endpoints.put(key, epList[i]);
-            ++i;
-        }
-                
-        /* Handles the read semantics for this entire set of keys */
-        MultiQuorumResponseHandler quorumResponseHandlers = new MultiQuorumResponseHandler(readMessage, endpoints);
-        MessagingService.getMessagingInstance().sendRR(msgList, epList, quorumResponseHandlers);
-        return quorumResponseHandlers;
-    }
-
     /*
     * This function executes the read protocol locally and should be used only if consistency is not a concern.
     * Read the data from the local disk and return if the row is NOT NULL. If the data is NULL do the read from
@@ -530,7 +483,7 @@ private static MultiQuorumResponseHandler dispatchMessagesMulti(Map<String, Read
         return rows;
     }
 
-    static List<String> getKeyRange(RangeCommand rawCommand) throws IOException
+    static List<String> getKeyRange(RangeCommand rawCommand) throws IOException, UnavailableException
     {
         long startTime = System.currentTimeMillis();
         Comparator<String> comparator = StorageService.getPartitioner().getDecoratedKeyComparator();
diff --git a/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/service/StorageService.java b/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/service/StorageService.java
index 05b70581..45cfff6f 100644
--- a/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/service/StorageService.java
+++ b/incubator/cassandra/branches/cassandra-0.4/src/java/org/apache/cassandra/service/StorageService.java
@@ -986,7 +986,7 @@ public boolean isPrimary(String key)
      * This function finds the most suitable endpoint given a key.
      * It checks for locality and alive test.
      */
-	public EndPoint findSuitableEndPoint(String key) throws IOException
+	public EndPoint findSuitableEndPoint(String key) throws IOException, UnavailableException
 	{
 		EndPoint[] endpoints = getReadStorageEndPoints(key);
 		for(EndPoint endPoint: endpoints)
@@ -1017,7 +1017,8 @@ public EndPoint findSuitableEndPoint(String key) throws IOException
 				return endpoints[j];
 			}
 		}
-		return null;
+
+        throw new UnavailableException(); // no nodes that could contain key are alive
 	}
 
 	Map<Token, EndPoint> getLiveEndPointMap()
