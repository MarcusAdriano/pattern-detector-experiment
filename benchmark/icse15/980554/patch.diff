diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java
index a0d02d11..3144fa24 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java
@@ -50,7 +50,7 @@
 
   public interface Iface {
 
-    public void login(AuthenticationRequest auth_request) throws AuthenticationException, AuthorizationException, TException;
+    public AccessLevel login(AuthenticationRequest auth_request) throws AuthenticationException, AuthorizationException, TException;
 
     public void set_keyspace(String keyspace) throws InvalidRequestException, TException;
 
@@ -390,10 +390,10 @@ public TProtocol getOutputProtocol()
       return this.oprot_;
     }
 
-    public void login(AuthenticationRequest auth_request) throws AuthenticationException, AuthorizationException, TException
+    public AccessLevel login(AuthenticationRequest auth_request) throws AuthenticationException, AuthorizationException, TException
     {
       send_login(auth_request);
-      recv_login();
+      return recv_login();
     }
 
     public void send_login(AuthenticationRequest auth_request) throws TException
@@ -406,7 +406,7 @@ public void send_login(AuthenticationRequest auth_request) throws TException
       oprot_.getTransport().flush();
     }
 
-    public void recv_login() throws AuthenticationException, AuthorizationException, TException
+    public AccessLevel recv_login() throws AuthenticationException, AuthorizationException, TException
     {
       TMessage msg = iprot_.readMessageBegin();
       if (msg.type == TMessageType.EXCEPTION) {
@@ -420,13 +420,16 @@ public void recv_login() throws AuthenticationException, AuthorizationException,
       login_result result = new login_result();
       result.read(iprot_);
       iprot_.readMessageEnd();
+      if (result.isSetSuccess()) {
+        return result.success;
+      }
       if (result.authnx != null) {
         throw result.authnx;
       }
       if (result.authzx != null) {
         throw result.authzx;
       }
-      return;
+      throw new TApplicationException(TApplicationException.MISSING_RESULT, "login failed: unknown result");
     }
 
     public void set_keyspace(String keyspace) throws InvalidRequestException, TException
@@ -1595,13 +1598,13 @@ public void write_args(TProtocol prot) throws TException {
         prot.writeMessageEnd();
       }
 
-      public void getResult() throws AuthenticationException, AuthorizationException, TException {
+      public AccessLevel getResult() throws AuthenticationException, AuthorizationException, TException {
         if (getState() != State.RESPONSE_READ) {
           throw new IllegalStateException("Method call not finished!");
         }
         TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
         TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
-        (new Client(prot)).recv_login();
+        return (new Client(prot)).recv_login();
       }
     }
 
@@ -2618,7 +2621,7 @@ public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TExcepti
         iprot.readMessageEnd();
         login_result result = new login_result();
         try {
-          iface_.login(args.auth_request);
+          result.success = iface_.login(args.auth_request);
         } catch (AuthenticationException authnx) {
           result.authnx = authnx;
         } catch (AuthorizationException authzx) {
@@ -3948,14 +3951,25 @@ public void validate() throws TException {
   public static class login_result implements TBase<login_result, login_result._Fields>, java.io.Serializable, Cloneable   {
     private static final TStruct STRUCT_DESC = new TStruct("login_result");
 
+    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
     private static final TField AUTHNX_FIELD_DESC = new TField("authnx", TType.STRUCT, (short)1);
     private static final TField AUTHZX_FIELD_DESC = new TField("authzx", TType.STRUCT, (short)2);
 
+    /**
+     * 
+     * @see AccessLevel
+     */
+    public AccessLevel success;
     public AuthenticationException authnx;
     public AuthorizationException authzx;
 
     /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
     public enum _Fields implements TFieldIdEnum {
+      /**
+       * 
+       * @see AccessLevel
+       */
+      SUCCESS((short)0, "success"),
       AUTHNX((short)1, "authnx"),
       AUTHZX((short)2, "authzx");
 
@@ -3972,6 +3986,8 @@ public void validate() throws TException {
        */
       public static _Fields findByThriftId(int fieldId) {
         switch(fieldId) {
+          case 0: // SUCCESS
+            return SUCCESS;
           case 1: // AUTHNX
             return AUTHNX;
           case 2: // AUTHZX
@@ -4020,6 +4036,8 @@ public String getFieldName() {
     public static final Map<_Fields, FieldMetaData> metaDataMap;
     static {
       Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
+      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
+          new EnumMetaData(TType.ENUM, AccessLevel.class)));
       tmpMap.put(_Fields.AUTHNX, new FieldMetaData("authnx", TFieldRequirementType.DEFAULT, 
           new FieldValueMetaData(TType.STRUCT)));
       tmpMap.put(_Fields.AUTHZX, new FieldMetaData("authzx", TFieldRequirementType.DEFAULT, 
@@ -4032,10 +4050,12 @@ public login_result() {
     }
 
     public login_result(
+      AccessLevel success,
       AuthenticationException authnx,
       AuthorizationException authzx)
     {
       this();
+      this.success = success;
       this.authnx = authnx;
       this.authzx = authzx;
     }
@@ -4044,6 +4064,9 @@ public login_result(
      * Performs a deep copy on <i>other</i>.
      */
     public login_result(login_result other) {
+      if (other.isSetSuccess()) {
+        this.success = other.success;
+      }
       if (other.isSetAuthnx()) {
         this.authnx = new AuthenticationException(other.authnx);
       }
@@ -4061,6 +4084,38 @@ public login_result clone() {
       return new login_result(this);
     }
 
+    /**
+     * 
+     * @see AccessLevel
+     */
+    public AccessLevel getSuccess() {
+      return this.success;
+    }
+
+    /**
+     * 
+     * @see AccessLevel
+     */
+    public login_result setSuccess(AccessLevel success) {
+      this.success = success;
+      return this;
+    }
+
+    public void unsetSuccess() {
+      this.success = null;
+    }
+
+    /** Returns true if field success is set (has been asigned a value) and false otherwise */
+    public boolean isSetSuccess() {
+      return this.success != null;
+    }
+
+    public void setSuccessIsSet(boolean value) {
+      if (!value) {
+        this.success = null;
+      }
+    }
+
     public AuthenticationException getAuthnx() {
       return this.authnx;
     }
@@ -4111,6 +4166,14 @@ public void setAuthzxIsSet(boolean value) {
 
     public void setFieldValue(_Fields field, Object value) {
       switch (field) {
+      case SUCCESS:
+        if (value == null) {
+          unsetSuccess();
+        } else {
+          setSuccess((AccessLevel)value);
+        }
+        break;
+
       case AUTHNX:
         if (value == null) {
           unsetAuthnx();
@@ -4136,6 +4199,9 @@ public void setFieldValue(int fieldID, Object value) {
 
     public Object getFieldValue(_Fields field) {
       switch (field) {
+      case SUCCESS:
+        return getSuccess();
+
       case AUTHNX:
         return getAuthnx();
 
@@ -4153,6 +4219,8 @@ public Object getFieldValue(int fieldId) {
     /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
     public boolean isSet(_Fields field) {
       switch (field) {
+      case SUCCESS:
+        return isSetSuccess();
       case AUTHNX:
         return isSetAuthnx();
       case AUTHZX:
@@ -4178,6 +4246,15 @@ public boolean equals(login_result that) {
       if (that == null)
         return false;
 
+      boolean this_present_success = true && this.isSetSuccess();
+      boolean that_present_success = true && that.isSetSuccess();
+      if (this_present_success || that_present_success) {
+        if (!(this_present_success && that_present_success))
+          return false;
+        if (!this.success.equals(that.success))
+          return false;
+      }
+
       boolean this_present_authnx = true && this.isSetAuthnx();
       boolean that_present_authnx = true && that.isSetAuthnx();
       if (this_present_authnx || that_present_authnx) {
@@ -4212,6 +4289,15 @@ public int compareTo(login_result other) {
       int lastComparison = 0;
       login_result typedOther = (login_result)other;
 
+      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+      if (isSetSuccess()) {        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
+        if (lastComparison != 0) {
+          return lastComparison;
+        }
+      }
       lastComparison = Boolean.valueOf(isSetAuthnx()).compareTo(typedOther.isSetAuthnx());
       if (lastComparison != 0) {
         return lastComparison;
@@ -4243,6 +4329,13 @@ public void read(TProtocol iprot) throws TException {
           break;
         }
         switch (field.id) {
+          case 0: // SUCCESS
+            if (field.type == TType.I32) {
+              this.success = AccessLevel.findByValue(iprot.readI32());
+            } else { 
+              TProtocolUtil.skip(iprot, field.type);
+            }
+            break;
           case 1: // AUTHNX
             if (field.type == TType.STRUCT) {
               this.authnx = new AuthenticationException();
@@ -4273,7 +4366,11 @@ public void read(TProtocol iprot) throws TException {
     public void write(TProtocol oprot) throws TException {
       oprot.writeStructBegin(STRUCT_DESC);
 
-      if (this.isSetAuthnx()) {
+      if (this.isSetSuccess()) {
+        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
+        oprot.writeI32(this.success.getValue());
+        oprot.writeFieldEnd();
+      } else if (this.isSetAuthnx()) {
         oprot.writeFieldBegin(AUTHNX_FIELD_DESC);
         this.authnx.write(oprot);
         oprot.writeFieldEnd();
@@ -4291,6 +4388,14 @@ public String toString() {
       StringBuilder sb = new StringBuilder("login_result(");
       boolean first = true;
 
+      sb.append("success:");
+      if (this.success == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.success);
+      }
+      first = false;
+      if (!first) sb.append(", ");
       sb.append("authnx:");
       if (this.authnx == null) {
         sb.append("null");
@@ -7049,14 +7154,14 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.LIST) {
               {
-                TList _list47 = iprot.readListBegin();
-                this.success = new ArrayList<ColumnOrSuperColumn>(_list47.size);
-                for (int _i48 = 0; _i48 < _list47.size; ++_i48)
+                TList _list37 = iprot.readListBegin();
+                this.success = new ArrayList<ColumnOrSuperColumn>(_list37.size);
+                for (int _i38 = 0; _i38 < _list37.size; ++_i38)
                 {
-                  ColumnOrSuperColumn _elem49;
-                  _elem49 = new ColumnOrSuperColumn();
-                  _elem49.read(iprot);
-                  this.success.add(_elem49);
+                  ColumnOrSuperColumn _elem39;
+                  _elem39 = new ColumnOrSuperColumn();
+                  _elem39.read(iprot);
+                  this.success.add(_elem39);
                 }
                 iprot.readListEnd();
               }
@@ -7106,9 +7211,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
-          for (ColumnOrSuperColumn _iter50 : this.success)
+          for (ColumnOrSuperColumn _iter40 : this.success)
           {
-            _iter50.write(oprot);
+            _iter40.write(oprot);
           }
           oprot.writeListEnd();
         }
@@ -7651,13 +7756,13 @@ public void read(TProtocol iprot) throws TException {
           case 1: // KEYS
             if (field.type == TType.LIST) {
               {
-                TList _list51 = iprot.readListBegin();
-                this.keys = new ArrayList<byte[]>(_list51.size);
-                for (int _i52 = 0; _i52 < _list51.size; ++_i52)
+                TList _list41 = iprot.readListBegin();
+                this.keys = new ArrayList<byte[]>(_list41.size);
+                for (int _i42 = 0; _i42 < _list41.size; ++_i42)
                 {
-                  byte[] _elem53;
-                  _elem53 = iprot.readBinary();
-                  this.keys.add(_elem53);
+                  byte[] _elem43;
+                  _elem43 = iprot.readBinary();
+                  this.keys.add(_elem43);
                 }
                 iprot.readListEnd();
               }
@@ -7707,9 +7812,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(KEYS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
-          for (byte[] _iter54 : this.keys)
+          for (byte[] _iter44 : this.keys)
           {
-            oprot.writeBinary(_iter54);
+            oprot.writeBinary(_iter44);
           }
           oprot.writeListEnd();
         }
@@ -8257,26 +8362,26 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.MAP) {
               {
-                TMap _map55 = iprot.readMapBegin();
-                this.success = new HashMap<byte[],List<ColumnOrSuperColumn>>(2*_map55.size);
-                for (int _i56 = 0; _i56 < _map55.size; ++_i56)
+                TMap _map45 = iprot.readMapBegin();
+                this.success = new HashMap<byte[],List<ColumnOrSuperColumn>>(2*_map45.size);
+                for (int _i46 = 0; _i46 < _map45.size; ++_i46)
                 {
-                  byte[] _key57;
-                  List<ColumnOrSuperColumn> _val58;
-                  _key57 = iprot.readBinary();
+                  byte[] _key47;
+                  List<ColumnOrSuperColumn> _val48;
+                  _key47 = iprot.readBinary();
                   {
-                    TList _list59 = iprot.readListBegin();
-                    _val58 = new ArrayList<ColumnOrSuperColumn>(_list59.size);
-                    for (int _i60 = 0; _i60 < _list59.size; ++_i60)
+                    TList _list49 = iprot.readListBegin();
+                    _val48 = new ArrayList<ColumnOrSuperColumn>(_list49.size);
+                    for (int _i50 = 0; _i50 < _list49.size; ++_i50)
                     {
-                      ColumnOrSuperColumn _elem61;
-                      _elem61 = new ColumnOrSuperColumn();
-                      _elem61.read(iprot);
-                      _val58.add(_elem61);
+                      ColumnOrSuperColumn _elem51;
+                      _elem51 = new ColumnOrSuperColumn();
+                      _elem51.read(iprot);
+                      _val48.add(_elem51);
                     }
                     iprot.readListEnd();
                   }
-                  this.success.put(_key57, _val58);
+                  this.success.put(_key47, _val48);
                 }
                 iprot.readMapEnd();
               }
@@ -8326,14 +8431,14 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.success.size()));
-          for (Map.Entry<byte[], List<ColumnOrSuperColumn>> _iter62 : this.success.entrySet())
+          for (Map.Entry<byte[], List<ColumnOrSuperColumn>> _iter52 : this.success.entrySet())
           {
-            oprot.writeBinary(_iter62.getKey());
+            oprot.writeBinary(_iter52.getKey());
             {
-              oprot.writeListBegin(new TList(TType.STRUCT, _iter62.getValue().size()));
-              for (ColumnOrSuperColumn _iter63 : _iter62.getValue())
+              oprot.writeListBegin(new TList(TType.STRUCT, _iter52.getValue().size()));
+              for (ColumnOrSuperColumn _iter53 : _iter52.getValue())
               {
-                _iter63.write(oprot);
+                _iter53.write(oprot);
               }
               oprot.writeListEnd();
             }
@@ -10079,13 +10184,13 @@ public void read(TProtocol iprot) throws TException {
           case 2: // KEYS
             if (field.type == TType.LIST) {
               {
-                TList _list64 = iprot.readListBegin();
-                this.keys = new ArrayList<byte[]>(_list64.size);
-                for (int _i65 = 0; _i65 < _list64.size; ++_i65)
+                TList _list54 = iprot.readListBegin();
+                this.keys = new ArrayList<byte[]>(_list54.size);
+                for (int _i55 = 0; _i55 < _list54.size; ++_i55)
                 {
-                  byte[] _elem66;
-                  _elem66 = iprot.readBinary();
-                  this.keys.add(_elem66);
+                  byte[] _elem56;
+                  _elem56 = iprot.readBinary();
+                  this.keys.add(_elem56);
                 }
                 iprot.readListEnd();
               }
@@ -10140,9 +10245,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(KEYS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.keys.size()));
-          for (byte[] _iter67 : this.keys)
+          for (byte[] _iter57 : this.keys)
           {
-            oprot.writeBinary(_iter67);
+            oprot.writeBinary(_iter57);
           }
           oprot.writeListEnd();
         }
@@ -10697,15 +10802,15 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.MAP) {
               {
-                TMap _map68 = iprot.readMapBegin();
-                this.success = new HashMap<byte[],Integer>(2*_map68.size);
-                for (int _i69 = 0; _i69 < _map68.size; ++_i69)
+                TMap _map58 = iprot.readMapBegin();
+                this.success = new HashMap<byte[],Integer>(2*_map58.size);
+                for (int _i59 = 0; _i59 < _map58.size; ++_i59)
                 {
-                  byte[] _key70;
-                  int _val71;
-                  _key70 = iprot.readBinary();
-                  _val71 = iprot.readI32();
-                  this.success.put(_key70, _val71);
+                  byte[] _key60;
+                  int _val61;
+                  _key60 = iprot.readBinary();
+                  _val61 = iprot.readI32();
+                  this.success.put(_key60, _val61);
                 }
                 iprot.readMapEnd();
               }
@@ -10755,10 +10860,10 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.I32, this.success.size()));
-          for (Map.Entry<byte[], Integer> _iter72 : this.success.entrySet())
+          for (Map.Entry<byte[], Integer> _iter62 : this.success.entrySet())
           {
-            oprot.writeBinary(_iter72.getKey());
-            oprot.writeI32(_iter72.getValue());
+            oprot.writeBinary(_iter62.getKey());
+            oprot.writeI32(_iter62.getValue());
           }
           oprot.writeMapEnd();
         }
@@ -11859,14 +11964,14 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.LIST) {
               {
-                TList _list73 = iprot.readListBegin();
-                this.success = new ArrayList<KeySlice>(_list73.size);
-                for (int _i74 = 0; _i74 < _list73.size; ++_i74)
+                TList _list63 = iprot.readListBegin();
+                this.success = new ArrayList<KeySlice>(_list63.size);
+                for (int _i64 = 0; _i64 < _list63.size; ++_i64)
                 {
-                  KeySlice _elem75;
-                  _elem75 = new KeySlice();
-                  _elem75.read(iprot);
-                  this.success.add(_elem75);
+                  KeySlice _elem65;
+                  _elem65 = new KeySlice();
+                  _elem65.read(iprot);
+                  this.success.add(_elem65);
                 }
                 iprot.readListEnd();
               }
@@ -11916,9 +12021,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
-          for (KeySlice _iter76 : this.success)
+          for (KeySlice _iter66 : this.success)
           {
-            _iter76.write(oprot);
+            _iter66.write(oprot);
           }
           oprot.writeListEnd();
         }
@@ -13019,14 +13124,14 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.LIST) {
               {
-                TList _list77 = iprot.readListBegin();
-                this.success = new ArrayList<KeySlice>(_list77.size);
-                for (int _i78 = 0; _i78 < _list77.size; ++_i78)
+                TList _list67 = iprot.readListBegin();
+                this.success = new ArrayList<KeySlice>(_list67.size);
+                for (int _i68 = 0; _i68 < _list67.size; ++_i68)
                 {
-                  KeySlice _elem79;
-                  _elem79 = new KeySlice();
-                  _elem79.read(iprot);
-                  this.success.add(_elem79);
+                  KeySlice _elem69;
+                  _elem69 = new KeySlice();
+                  _elem69.read(iprot);
+                  this.success.add(_elem69);
                 }
                 iprot.readListEnd();
               }
@@ -13076,9 +13181,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
-          for (KeySlice _iter80 : this.success)
+          for (KeySlice _iter70 : this.success)
           {
-            _iter80.write(oprot);
+            _iter70.write(oprot);
           }
           oprot.writeListEnd();
         }
@@ -14179,14 +14284,14 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.LIST) {
               {
-                TList _list81 = iprot.readListBegin();
-                this.success = new ArrayList<KeyCount>(_list81.size);
-                for (int _i82 = 0; _i82 < _list81.size; ++_i82)
+                TList _list71 = iprot.readListBegin();
+                this.success = new ArrayList<KeyCount>(_list71.size);
+                for (int _i72 = 0; _i72 < _list71.size; ++_i72)
                 {
-                  KeyCount _elem83;
-                  _elem83 = new KeyCount();
-                  _elem83.read(iprot);
-                  this.success.add(_elem83);
+                  KeyCount _elem73;
+                  _elem73 = new KeyCount();
+                  _elem73.read(iprot);
+                  this.success.add(_elem73);
                 }
                 iprot.readListEnd();
               }
@@ -14236,9 +14341,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
-          for (KeyCount _iter84 : this.success)
+          for (KeyCount _iter74 : this.success)
           {
-            _iter84.write(oprot);
+            _iter74.write(oprot);
           }
           oprot.writeListEnd();
         }
@@ -16747,38 +16852,38 @@ public void read(TProtocol iprot) throws TException {
           case 1: // MUTATION_MAP
             if (field.type == TType.MAP) {
               {
-                TMap _map85 = iprot.readMapBegin();
-                this.mutation_map = new HashMap<byte[],Map<String,List<Mutation>>>(2*_map85.size);
-                for (int _i86 = 0; _i86 < _map85.size; ++_i86)
+                TMap _map75 = iprot.readMapBegin();
+                this.mutation_map = new HashMap<byte[],Map<String,List<Mutation>>>(2*_map75.size);
+                for (int _i76 = 0; _i76 < _map75.size; ++_i76)
                 {
-                  byte[] _key87;
-                  Map<String,List<Mutation>> _val88;
-                  _key87 = iprot.readBinary();
+                  byte[] _key77;
+                  Map<String,List<Mutation>> _val78;
+                  _key77 = iprot.readBinary();
                   {
-                    TMap _map89 = iprot.readMapBegin();
-                    _val88 = new HashMap<String,List<Mutation>>(2*_map89.size);
-                    for (int _i90 = 0; _i90 < _map89.size; ++_i90)
+                    TMap _map79 = iprot.readMapBegin();
+                    _val78 = new HashMap<String,List<Mutation>>(2*_map79.size);
+                    for (int _i80 = 0; _i80 < _map79.size; ++_i80)
                     {
-                      String _key91;
-                      List<Mutation> _val92;
-                      _key91 = iprot.readString();
+                      String _key81;
+                      List<Mutation> _val82;
+                      _key81 = iprot.readString();
                       {
-                        TList _list93 = iprot.readListBegin();
-                        _val92 = new ArrayList<Mutation>(_list93.size);
-                        for (int _i94 = 0; _i94 < _list93.size; ++_i94)
+                        TList _list83 = iprot.readListBegin();
+                        _val82 = new ArrayList<Mutation>(_list83.size);
+                        for (int _i84 = 0; _i84 < _list83.size; ++_i84)
                         {
-                          Mutation _elem95;
-                          _elem95 = new Mutation();
-                          _elem95.read(iprot);
-                          _val92.add(_elem95);
+                          Mutation _elem85;
+                          _elem85 = new Mutation();
+                          _elem85.read(iprot);
+                          _val82.add(_elem85);
                         }
                         iprot.readListEnd();
                       }
-                      _val88.put(_key91, _val92);
+                      _val78.put(_key81, _val82);
                     }
                     iprot.readMapEnd();
                   }
-                  this.mutation_map.put(_key87, _val88);
+                  this.mutation_map.put(_key77, _val78);
                 }
                 iprot.readMapEnd();
               }
@@ -16812,19 +16917,19 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(MUTATION_MAP_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.mutation_map.size()));
-          for (Map.Entry<byte[], Map<String,List<Mutation>>> _iter96 : this.mutation_map.entrySet())
+          for (Map.Entry<byte[], Map<String,List<Mutation>>> _iter86 : this.mutation_map.entrySet())
           {
-            oprot.writeBinary(_iter96.getKey());
+            oprot.writeBinary(_iter86.getKey());
             {
-              oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, _iter96.getValue().size()));
-              for (Map.Entry<String, List<Mutation>> _iter97 : _iter96.getValue().entrySet())
+              oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, _iter86.getValue().size()));
+              for (Map.Entry<String, List<Mutation>> _iter87 : _iter86.getValue().entrySet())
               {
-                oprot.writeString(_iter97.getKey());
+                oprot.writeString(_iter87.getKey());
                 {
-                  oprot.writeListBegin(new TList(TType.STRUCT, _iter97.getValue().size()));
-                  for (Mutation _iter98 : _iter97.getValue())
+                  oprot.writeListBegin(new TList(TType.STRUCT, _iter87.getValue().size()));
+                  for (Mutation _iter88 : _iter87.getValue())
                   {
-                    _iter98.write(oprot);
+                    _iter88.write(oprot);
                   }
                   oprot.writeListEnd();
                 }
@@ -18518,25 +18623,25 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.MAP) {
               {
-                TMap _map99 = iprot.readMapBegin();
-                this.success = new HashMap<String,List<String>>(2*_map99.size);
-                for (int _i100 = 0; _i100 < _map99.size; ++_i100)
+                TMap _map89 = iprot.readMapBegin();
+                this.success = new HashMap<String,List<String>>(2*_map89.size);
+                for (int _i90 = 0; _i90 < _map89.size; ++_i90)
                 {
-                  String _key101;
-                  List<String> _val102;
-                  _key101 = iprot.readString();
+                  String _key91;
+                  List<String> _val92;
+                  _key91 = iprot.readString();
                   {
-                    TList _list103 = iprot.readListBegin();
-                    _val102 = new ArrayList<String>(_list103.size);
-                    for (int _i104 = 0; _i104 < _list103.size; ++_i104)
+                    TList _list93 = iprot.readListBegin();
+                    _val92 = new ArrayList<String>(_list93.size);
+                    for (int _i94 = 0; _i94 < _list93.size; ++_i94)
                     {
-                      String _elem105;
-                      _elem105 = iprot.readString();
-                      _val102.add(_elem105);
+                      String _elem95;
+                      _elem95 = iprot.readString();
+                      _val92.add(_elem95);
                     }
                     iprot.readListEnd();
                   }
-                  this.success.put(_key101, _val102);
+                  this.success.put(_key91, _val92);
                 }
                 iprot.readMapEnd();
               }
@@ -18570,14 +18675,14 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.success.size()));
-          for (Map.Entry<String, List<String>> _iter106 : this.success.entrySet())
+          for (Map.Entry<String, List<String>> _iter96 : this.success.entrySet())
           {
-            oprot.writeString(_iter106.getKey());
+            oprot.writeString(_iter96.getKey());
             {
-              oprot.writeListBegin(new TList(TType.STRING, _iter106.getValue().size()));
-              for (String _iter107 : _iter106.getValue())
+              oprot.writeListBegin(new TList(TType.STRING, _iter96.getValue().size()));
+              for (String _iter97 : _iter96.getValue())
               {
-                oprot.writeString(_iter107);
+                oprot.writeString(_iter97);
               }
               oprot.writeListEnd();
             }
@@ -19069,13 +19174,13 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.SET) {
               {
-                TSet _set108 = iprot.readSetBegin();
-                this.success = new HashSet<String>(2*_set108.size);
-                for (int _i109 = 0; _i109 < _set108.size; ++_i109)
+                TSet _set98 = iprot.readSetBegin();
+                this.success = new HashSet<String>(2*_set98.size);
+                for (int _i99 = 0; _i99 < _set98.size; ++_i99)
                 {
-                  String _elem110;
-                  _elem110 = iprot.readString();
-                  this.success.add(_elem110);
+                  String _elem100;
+                  _elem100 = iprot.readString();
+                  this.success.add(_elem100);
                 }
                 iprot.readSetEnd();
               }
@@ -19101,9 +19206,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeSetBegin(new TSet(TType.STRING, this.success.size()));
-          for (String _iter111 : this.success)
+          for (String _iter101 : this.success)
           {
-            oprot.writeString(_iter111);
+            oprot.writeString(_iter101);
           }
           oprot.writeSetEnd();
         }
@@ -20691,14 +20796,14 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.LIST) {
               {
-                TList _list112 = iprot.readListBegin();
-                this.success = new ArrayList<TokenRange>(_list112.size);
-                for (int _i113 = 0; _i113 < _list112.size; ++_i113)
+                TList _list102 = iprot.readListBegin();
+                this.success = new ArrayList<TokenRange>(_list102.size);
+                for (int _i103 = 0; _i103 < _list102.size; ++_i103)
                 {
-                  TokenRange _elem114;
-                  _elem114 = new TokenRange();
-                  _elem114.read(iprot);
-                  this.success.add(_elem114);
+                  TokenRange _elem104;
+                  _elem104 = new TokenRange();
+                  _elem104.read(iprot);
+                  this.success.add(_elem104);
                 }
                 iprot.readListEnd();
               }
@@ -20732,9 +20837,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
-          for (TokenRange _iter115 : this.success)
+          for (TokenRange _iter105 : this.success)
           {
-            _iter115.write(oprot);
+            _iter105.write(oprot);
           }
           oprot.writeListEnd();
         }
@@ -21878,27 +21983,27 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.MAP) {
               {
-                TMap _map116 = iprot.readMapBegin();
-                this.success = new HashMap<String,Map<String,String>>(2*_map116.size);
-                for (int _i117 = 0; _i117 < _map116.size; ++_i117)
+                TMap _map106 = iprot.readMapBegin();
+                this.success = new HashMap<String,Map<String,String>>(2*_map106.size);
+                for (int _i107 = 0; _i107 < _map106.size; ++_i107)
                 {
-                  String _key118;
-                  Map<String,String> _val119;
-                  _key118 = iprot.readString();
+                  String _key108;
+                  Map<String,String> _val109;
+                  _key108 = iprot.readString();
                   {
-                    TMap _map120 = iprot.readMapBegin();
-                    _val119 = new HashMap<String,String>(2*_map120.size);
-                    for (int _i121 = 0; _i121 < _map120.size; ++_i121)
+                    TMap _map110 = iprot.readMapBegin();
+                    _val109 = new HashMap<String,String>(2*_map110.size);
+                    for (int _i111 = 0; _i111 < _map110.size; ++_i111)
                     {
-                      String _key122;
-                      String _val123;
-                      _key122 = iprot.readString();
-                      _val123 = iprot.readString();
-                      _val119.put(_key122, _val123);
+                      String _key112;
+                      String _val113;
+                      _key112 = iprot.readString();
+                      _val113 = iprot.readString();
+                      _val109.put(_key112, _val113);
                     }
                     iprot.readMapEnd();
                   }
-                  this.success.put(_key118, _val119);
+                  this.success.put(_key108, _val109);
                 }
                 iprot.readMapEnd();
               }
@@ -21932,15 +22037,15 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, this.success.size()));
-          for (Map.Entry<String, Map<String,String>> _iter124 : this.success.entrySet())
+          for (Map.Entry<String, Map<String,String>> _iter114 : this.success.entrySet())
           {
-            oprot.writeString(_iter124.getKey());
+            oprot.writeString(_iter114.getKey());
             {
-              oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter124.getValue().size()));
-              for (Map.Entry<String, String> _iter125 : _iter124.getValue().entrySet())
+              oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, _iter114.getValue().size()));
+              for (Map.Entry<String, String> _iter115 : _iter114.getValue().entrySet())
               {
-                oprot.writeString(_iter125.getKey());
-                oprot.writeString(_iter125.getValue());
+                oprot.writeString(_iter115.getKey());
+                oprot.writeString(_iter115.getValue());
               }
               oprot.writeMapEnd();
             }
@@ -22886,13 +22991,13 @@ public void read(TProtocol iprot) throws TException {
           case 0: // SUCCESS
             if (field.type == TType.LIST) {
               {
-                TList _list126 = iprot.readListBegin();
-                this.success = new ArrayList<String>(_list126.size);
-                for (int _i127 = 0; _i127 < _list126.size; ++_i127)
+                TList _list116 = iprot.readListBegin();
+                this.success = new ArrayList<String>(_list116.size);
+                for (int _i117 = 0; _i117 < _list116.size; ++_i117)
                 {
-                  String _elem128;
-                  _elem128 = iprot.readString();
-                  this.success.add(_elem128);
+                  String _elem118;
+                  _elem118 = iprot.readString();
+                  this.success.add(_elem118);
                 }
                 iprot.readListEnd();
               }
@@ -22918,9 +23023,9 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
         {
           oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
-          for (String _iter129 : this.success)
+          for (String _iter119 : this.success)
           {
-            oprot.writeString(_iter129);
+            oprot.writeString(_iter119);
           }
           oprot.writeListEnd();
         }
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KsDef.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KsDef.java
index a601b20b..39c6e537 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KsDef.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KsDef.java
@@ -53,24 +53,18 @@
   private static final TField STRATEGY_CLASS_FIELD_DESC = new TField("strategy_class", TType.STRING, (short)2);
   private static final TField REPLICATION_FACTOR_FIELD_DESC = new TField("replication_factor", TType.I32, (short)3);
   private static final TField CF_DEFS_FIELD_DESC = new TField("cf_defs", TType.LIST, (short)5);
-  private static final TField USERS_ACCESS_FIELD_DESC = new TField("users_access", TType.MAP, (short)6);
-  private static final TField GROUPS_ACCESS_FIELD_DESC = new TField("groups_access", TType.MAP, (short)7);
 
   public String name;
   public String strategy_class;
   public int replication_factor;
   public List<CfDef> cf_defs;
-  public Map<String,AccessLevel> users_access;
-  public Map<String,AccessLevel> groups_access;
 
   /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
   public enum _Fields implements TFieldIdEnum {
     NAME((short)1, "name"),
     STRATEGY_CLASS((short)2, "strategy_class"),
     REPLICATION_FACTOR((short)3, "replication_factor"),
-    CF_DEFS((short)5, "cf_defs"),
-    USERS_ACCESS((short)6, "users_access"),
-    GROUPS_ACCESS((short)7, "groups_access");
+    CF_DEFS((short)5, "cf_defs");
 
     private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
@@ -93,10 +87,6 @@ public static _Fields findByThriftId(int fieldId) {
           return REPLICATION_FACTOR;
         case 5: // CF_DEFS
           return CF_DEFS;
-        case 6: // USERS_ACCESS
-          return USERS_ACCESS;
-        case 7: // GROUPS_ACCESS
-          return GROUPS_ACCESS;
         default:
           return null;
       }
@@ -152,14 +142,6 @@ public String getFieldName() {
     tmpMap.put(_Fields.CF_DEFS, new FieldMetaData("cf_defs", TFieldRequirementType.REQUIRED, 
         new ListMetaData(TType.LIST, 
             new StructMetaData(TType.STRUCT, CfDef.class))));
-    tmpMap.put(_Fields.USERS_ACCESS, new FieldMetaData("users_access", TFieldRequirementType.OPTIONAL, 
-        new MapMetaData(TType.MAP, 
-            new FieldValueMetaData(TType.STRING), 
-            new EnumMetaData(TType.ENUM, AccessLevel.class))));
-    tmpMap.put(_Fields.GROUPS_ACCESS, new FieldMetaData("groups_access", TFieldRequirementType.OPTIONAL, 
-        new MapMetaData(TType.MAP, 
-            new FieldValueMetaData(TType.STRING), 
-            new EnumMetaData(TType.ENUM, AccessLevel.class))));
     metaDataMap = Collections.unmodifiableMap(tmpMap);
     FieldMetaData.addStructMetaDataMap(KsDef.class, metaDataMap);
   }
@@ -201,36 +183,6 @@ public KsDef(KsDef other) {
       }
       this.cf_defs = __this__cf_defs;
     }
-    if (other.isSetUsers_access()) {
-      Map<String,AccessLevel> __this__users_access = new HashMap<String,AccessLevel>();
-      for (Map.Entry<String, AccessLevel> other_element : other.users_access.entrySet()) {
-
-        String other_element_key = other_element.getKey();
-        AccessLevel other_element_value = other_element.getValue();
-
-        String __this__users_access_copy_key = other_element_key;
-
-        AccessLevel __this__users_access_copy_value = other_element_value;
-
-        __this__users_access.put(__this__users_access_copy_key, __this__users_access_copy_value);
-      }
-      this.users_access = __this__users_access;
-    }
-    if (other.isSetGroups_access()) {
-      Map<String,AccessLevel> __this__groups_access = new HashMap<String,AccessLevel>();
-      for (Map.Entry<String, AccessLevel> other_element : other.groups_access.entrySet()) {
-
-        String other_element_key = other_element.getKey();
-        AccessLevel other_element_value = other_element.getValue();
-
-        String __this__groups_access_copy_key = other_element_key;
-
-        AccessLevel __this__groups_access_copy_value = other_element_value;
-
-        __this__groups_access.put(__this__groups_access_copy_key, __this__groups_access_copy_value);
-      }
-      this.groups_access = __this__groups_access;
-    }
   }
 
   public KsDef deepCopy() {
@@ -352,76 +304,6 @@ public void setCf_defsIsSet(boolean value) {
     }
   }
 
-  public int getUsers_accessSize() {
-    return (this.users_access == null) ? 0 : this.users_access.size();
-  }
-
-  public void putToUsers_access(String key, AccessLevel val) {
-    if (this.users_access == null) {
-      this.users_access = new HashMap<String,AccessLevel>();
-    }
-    this.users_access.put(key, val);
-  }
-
-  public Map<String,AccessLevel> getUsers_access() {
-    return this.users_access;
-  }
-
-  public KsDef setUsers_access(Map<String,AccessLevel> users_access) {
-    this.users_access = users_access;
-    return this;
-  }
-
-  public void unsetUsers_access() {
-    this.users_access = null;
-  }
-
-  /** Returns true if field users_access is set (has been asigned a value) and false otherwise */
-  public boolean isSetUsers_access() {
-    return this.users_access != null;
-  }
-
-  public void setUsers_accessIsSet(boolean value) {
-    if (!value) {
-      this.users_access = null;
-    }
-  }
-
-  public int getGroups_accessSize() {
-    return (this.groups_access == null) ? 0 : this.groups_access.size();
-  }
-
-  public void putToGroups_access(String key, AccessLevel val) {
-    if (this.groups_access == null) {
-      this.groups_access = new HashMap<String,AccessLevel>();
-    }
-    this.groups_access.put(key, val);
-  }
-
-  public Map<String,AccessLevel> getGroups_access() {
-    return this.groups_access;
-  }
-
-  public KsDef setGroups_access(Map<String,AccessLevel> groups_access) {
-    this.groups_access = groups_access;
-    return this;
-  }
-
-  public void unsetGroups_access() {
-    this.groups_access = null;
-  }
-
-  /** Returns true if field groups_access is set (has been asigned a value) and false otherwise */
-  public boolean isSetGroups_access() {
-    return this.groups_access != null;
-  }
-
-  public void setGroups_accessIsSet(boolean value) {
-    if (!value) {
-      this.groups_access = null;
-    }
-  }
-
   public void setFieldValue(_Fields field, Object value) {
     switch (field) {
     case NAME:
@@ -456,22 +338,6 @@ public void setFieldValue(_Fields field, Object value) {
       }
       break;
 
-    case USERS_ACCESS:
-      if (value == null) {
-        unsetUsers_access();
-      } else {
-        setUsers_access((Map<String,AccessLevel>)value);
-      }
-      break;
-
-    case GROUPS_ACCESS:
-      if (value == null) {
-        unsetGroups_access();
-      } else {
-        setGroups_access((Map<String,AccessLevel>)value);
-      }
-      break;
-
     }
   }
 
@@ -493,12 +359,6 @@ public Object getFieldValue(_Fields field) {
     case CF_DEFS:
       return getCf_defs();
 
-    case USERS_ACCESS:
-      return getUsers_access();
-
-    case GROUPS_ACCESS:
-      return getGroups_access();
-
     }
     throw new IllegalStateException();
   }
@@ -518,10 +378,6 @@ public boolean isSet(_Fields field) {
       return isSetReplication_factor();
     case CF_DEFS:
       return isSetCf_defs();
-    case USERS_ACCESS:
-      return isSetUsers_access();
-    case GROUPS_ACCESS:
-      return isSetGroups_access();
     }
     throw new IllegalStateException();
   }
@@ -579,24 +435,6 @@ public boolean equals(KsDef that) {
         return false;
     }
 
-    boolean this_present_users_access = true && this.isSetUsers_access();
-    boolean that_present_users_access = true && that.isSetUsers_access();
-    if (this_present_users_access || that_present_users_access) {
-      if (!(this_present_users_access && that_present_users_access))
-        return false;
-      if (!this.users_access.equals(that.users_access))
-        return false;
-    }
-
-    boolean this_present_groups_access = true && this.isSetGroups_access();
-    boolean that_present_groups_access = true && that.isSetGroups_access();
-    if (this_present_groups_access || that_present_groups_access) {
-      if (!(this_present_groups_access && that_present_groups_access))
-        return false;
-      if (!this.groups_access.equals(that.groups_access))
-        return false;
-    }
-
     return true;
   }
 
@@ -649,24 +487,6 @@ public int compareTo(KsDef other) {
         return lastComparison;
       }
     }
-    lastComparison = Boolean.valueOf(isSetUsers_access()).compareTo(typedOther.isSetUsers_access());
-    if (lastComparison != 0) {
-      return lastComparison;
-    }
-    if (isSetUsers_access()) {      lastComparison = TBaseHelper.compareTo(this.users_access, typedOther.users_access);
-      if (lastComparison != 0) {
-        return lastComparison;
-      }
-    }
-    lastComparison = Boolean.valueOf(isSetGroups_access()).compareTo(typedOther.isSetGroups_access());
-    if (lastComparison != 0) {
-      return lastComparison;
-    }
-    if (isSetGroups_access()) {      lastComparison = TBaseHelper.compareTo(this.groups_access, typedOther.groups_access);
-      if (lastComparison != 0) {
-        return lastComparison;
-      }
-    }
     return 0;
   }
 
@@ -720,44 +540,6 @@ public void read(TProtocol iprot) throws TException {
             TProtocolUtil.skip(iprot, field.type);
           }
           break;
-        case 6: // USERS_ACCESS
-          if (field.type == TType.MAP) {
-            {
-              TMap _map36 = iprot.readMapBegin();
-              this.users_access = new HashMap<String,AccessLevel>(2*_map36.size);
-              for (int _i37 = 0; _i37 < _map36.size; ++_i37)
-              {
-                String _key38;
-                AccessLevel _val39;
-                _key38 = iprot.readString();
-                _val39 = AccessLevel.findByValue(iprot.readI32());
-                this.users_access.put(_key38, _val39);
-              }
-              iprot.readMapEnd();
-            }
-          } else { 
-            TProtocolUtil.skip(iprot, field.type);
-          }
-          break;
-        case 7: // GROUPS_ACCESS
-          if (field.type == TType.MAP) {
-            {
-              TMap _map40 = iprot.readMapBegin();
-              this.groups_access = new HashMap<String,AccessLevel>(2*_map40.size);
-              for (int _i41 = 0; _i41 < _map40.size; ++_i41)
-              {
-                String _key42;
-                AccessLevel _val43;
-                _key42 = iprot.readString();
-                _val43 = AccessLevel.findByValue(iprot.readI32());
-                this.groups_access.put(_key42, _val43);
-              }
-              iprot.readMapEnd();
-            }
-          } else { 
-            TProtocolUtil.skip(iprot, field.type);
-          }
-          break;
         default:
           TProtocolUtil.skip(iprot, field.type);
       }
@@ -793,44 +575,14 @@ public void write(TProtocol oprot) throws TException {
       oprot.writeFieldBegin(CF_DEFS_FIELD_DESC);
       {
         oprot.writeListBegin(new TList(TType.STRUCT, this.cf_defs.size()));
-        for (CfDef _iter44 : this.cf_defs)
+        for (CfDef _iter36 : this.cf_defs)
         {
-          _iter44.write(oprot);
+          _iter36.write(oprot);
         }
         oprot.writeListEnd();
       }
       oprot.writeFieldEnd();
     }
-    if (this.users_access != null) {
-      if (isSetUsers_access()) {
-        oprot.writeFieldBegin(USERS_ACCESS_FIELD_DESC);
-        {
-          oprot.writeMapBegin(new TMap(TType.STRING, TType.I32, this.users_access.size()));
-          for (Map.Entry<String, AccessLevel> _iter45 : this.users_access.entrySet())
-          {
-            oprot.writeString(_iter45.getKey());
-            oprot.writeI32(_iter45.getValue().getValue());
-          }
-          oprot.writeMapEnd();
-        }
-        oprot.writeFieldEnd();
-      }
-    }
-    if (this.groups_access != null) {
-      if (isSetGroups_access()) {
-        oprot.writeFieldBegin(GROUPS_ACCESS_FIELD_DESC);
-        {
-          oprot.writeMapBegin(new TMap(TType.STRING, TType.I32, this.groups_access.size()));
-          for (Map.Entry<String, AccessLevel> _iter46 : this.groups_access.entrySet())
-          {
-            oprot.writeString(_iter46.getKey());
-            oprot.writeI32(_iter46.getValue().getValue());
-          }
-          oprot.writeMapEnd();
-        }
-        oprot.writeFieldEnd();
-      }
-    }
     oprot.writeFieldStop();
     oprot.writeStructEnd();
   }
@@ -867,26 +619,6 @@ public String toString() {
       sb.append(this.cf_defs);
     }
     first = false;
-    if (isSetUsers_access()) {
-      if (!first) sb.append(", ");
-      sb.append("users_access:");
-      if (this.users_access == null) {
-        sb.append("null");
-      } else {
-        sb.append(this.users_access);
-      }
-      first = false;
-    }
-    if (isSetGroups_access()) {
-      if (!first) sb.append(", ");
-      sb.append("groups_access:");
-      if (this.groups_access == null) {
-        sb.append("null");
-      } else {
-        sb.append(this.groups_access);
-      }
-      first = false;
-    }
     sb.append(")");
     return sb.toString();
   }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/auth/AllowAllAuthenticator.java b/cassandra/trunk/src/java/org/apache/cassandra/auth/AllowAllAuthenticator.java
index d2659718..355604cd 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/auth/AllowAllAuthenticator.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/auth/AllowAllAuthenticator.java
@@ -20,26 +20,20 @@
  * 
  */
 
-import java.util.Map;
 
 import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.thrift.AccessLevel;
 import org.apache.cassandra.thrift.AuthenticationException;
+import org.apache.cassandra.thrift.AuthenticationRequest;
 import org.apache.cassandra.thrift.AuthorizationException;
 
 public class AllowAllAuthenticator implements IAuthenticator
 {
-    private final static AuthenticatedUser USER = new AuthenticatedUser("allow_all", true);
-
-    @Override
-    public AuthenticatedUser defaultUser()
-    {
-        return USER;
-    }
-
     @Override
-    public AuthenticatedUser login(Map<String,String> credentials) throws AuthenticationException, AuthorizationException
+    public AccessLevel login(String keyspace, AuthenticationRequest authRequest) throws AuthenticationException, AuthorizationException
     {
-        return USER;
+        // do nothing, allow anything
+        return AccessLevel.FULL;
     }
     
     @Override    
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/auth/AuthenticatedUser.java b/cassandra/trunk/src/java/org/apache/cassandra/auth/AuthenticatedUser.java
index 7988f00d..e69de29b 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/auth/AuthenticatedUser.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/auth/AuthenticatedUser.java
@@ -1,76 +0,0 @@
-/*
- * 
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- * 
- */
-
-package org.apache.cassandra.auth;
-
-import java.util.Collections;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.cassandra.avro.AccessLevel;
-
-/**
- * An authenticated user and her groups.
- */
-public class AuthenticatedUser
-{
-    public final String username;
-    public final Set<String> groups;
-    public final boolean isSuper;
-
-    public AuthenticatedUser(String username, boolean isSuper)
-    {
-        this.username = username;
-        this.groups = Collections.emptySet();
-        this.isSuper = isSuper;
-    }
-
-    public AuthenticatedUser(String username, Set<String> groups, boolean isSuper)
-    {
-        this.username = username;
-        this.groups = Collections.unmodifiableSet(groups);
-        this.isSuper = isSuper;
-    }
-
-    /**
-     * @return The access level granted to the user by the given access maps.
-     */
-    public AccessLevel levelFor(Map<String,AccessLevel> usersAccess, Map<String,AccessLevel> groupsAccess)
-    {
-        // determine the maximum access level for this user and groups
-        AccessLevel level = usersAccess.get(username);
-        if (level == null)
-            level = AccessLevel.NONE;
-        for (String group : groups)
-        {
-            AccessLevel forGroup = groupsAccess.get(group);
-            if (forGroup != null && forGroup.ordinal() > level.ordinal())
-                level = forGroup;
-        }
-        return level;
-    }
-
-    @Override
-    public String toString()
-    {
-        return String.format("#<User %s groups=%s>", username, groups);
-    }
-}
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/auth/IAuthenticator.java b/cassandra/trunk/src/java/org/apache/cassandra/auth/IAuthenticator.java
index c11568e5..14cee98c 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/auth/IAuthenticator.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/auth/IAuthenticator.java
@@ -20,20 +20,16 @@
  * 
  */
 
-import java.util.Map;
 
 import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.thrift.AccessLevel;
 import org.apache.cassandra.thrift.AuthenticationException;
+import org.apache.cassandra.thrift.AuthenticationRequest;
 import org.apache.cassandra.thrift.AuthorizationException;
 
 public interface IAuthenticator
 {
-    /**
-     * @return The user that a connection is initialized with, or 'null' if a user must call login().
-     */
-    public AuthenticatedUser defaultUser();
-
-    public AuthenticatedUser login(Map<String,String> credentials) throws AuthenticationException, AuthorizationException;
+    public AccessLevel login(String keyspace, AuthenticationRequest auth_request) throws AuthenticationException, AuthorizationException;
 
     public void validateConfiguration() throws ConfigurationException;
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/auth/SimpleAuthenticator.java b/cassandra/trunk/src/java/org/apache/cassandra/auth/SimpleAuthenticator.java
index 4148a33f..1fb9c02c 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/auth/SimpleAuthenticator.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/auth/SimpleAuthenticator.java
@@ -25,17 +25,17 @@
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 import java.util.Properties;
-import java.util.Map;
-import java.util.HashMap;
 
-import org.apache.cassandra.avro.AccessLevel;
 import org.apache.cassandra.config.ConfigurationException;
+import org.apache.cassandra.thrift.AccessLevel;
 import org.apache.cassandra.thrift.AuthenticationException;
+import org.apache.cassandra.thrift.AuthenticationRequest;
 import org.apache.cassandra.thrift.AuthorizationException;
 
 public class SimpleAuthenticator implements IAuthenticator
 {
     public final static String PASSWD_FILENAME_PROPERTY        = "passwd.properties";
+    public final static String ACCESS_FILENAME_PROPERTY        = "access.properties";
     public final static String PMODE_PROPERTY                  = "passwd.mode";
     public static final String USERNAME_KEY                    = "username";
     public static final String PASSWORD_KEY                    = "password";
@@ -46,14 +46,7 @@
     };
 
     @Override
-    public AuthenticatedUser defaultUser()
-    {
-        // users must log in
-        return null;
-    }
-
-    @Override
-    public AuthenticatedUser login(Map<String,String> credentials) throws AuthenticationException, AuthorizationException
+    public AccessLevel login(String keyspace, AuthenticationRequest authRequest) throws AuthenticationException, AuthorizationException
     {
         String pmode_plain = System.getProperty(PMODE_PROPERTY);
         PasswordMode mode = PasswordMode.PLAIN;
@@ -78,10 +71,10 @@ public AuthenticatedUser login(Map<String,String> credentials) throws Authentica
 
         String pfilename = System.getProperty(PASSWD_FILENAME_PROPERTY);
 
-        String username = credentials.get(USERNAME_KEY);
+        String username = authRequest.getCredentials().get(USERNAME_KEY);
         if (null == username) throw new AuthenticationException("Authentication request was missing the required key '" + USERNAME_KEY + "'");
 
-        String password = credentials.get(PASSWORD_KEY);
+        String password = authRequest.getCredentials().get(PASSWORD_KEY);
         if (null == password) throw new AuthenticationException("Authentication request was missing the required key '" + PASSWORD_KEY + "'");
 
         boolean authenticated = false;
@@ -103,13 +96,15 @@ public AuthenticatedUser login(Map<String,String> credentials) throws Authentica
                 case MD5:
                     authenticated = MessageDigest.isEqual(password.getBytes(), MessageDigest.getInstance("MD5").digest(props.getProperty(username).getBytes()));
                     break;
-                default:
-                    throw new RuntimeException("Unknown PasswordMode " + mode);
             }
         }
         catch (NoSuchAlgorithmException e)
         {
-            throw new RuntimeException("You requested MD5 checking but the MD5 digest algorithm is not available: " + e.getMessage());
+            throw new AuthenticationException("You requested MD5 checking but the MD5 digest algorithm is not available: " + e.getMessage());
+        }
+        catch (FileNotFoundException e)
+        {
+            throw new RuntimeException("Authentication table file given by property " + PASSWD_FILENAME_PROPERTY + " could not be found: " + e.getMessage());
         }
         catch (IOException e)
         {
@@ -122,52 +117,61 @@ public AuthenticatedUser login(Map<String,String> credentials) throws Authentica
 
         if (!authenticated) throw new AuthenticationException(authenticationErrorMessage(mode, username));
 
-        // TODO: Should allow/require a user to configure a 'super' username.
-        return new AuthenticatedUser(username, false);
+        // if we're here, the authentication succeeded. Now let's see if the user is authorized for this keyspace.
+
+        String afilename = System.getProperty(ACCESS_FILENAME_PROPERTY);
+        AccessLevel authorized = AccessLevel.NONE;
+        try
+        {
+            FileInputStream in = new FileInputStream(afilename);
+            Properties props = new Properties();
+            props.load(in);
+            in.close();
+
+            // structure:
+            // given keyspace X, users A B and C can be authorized like this (separate their names with spaces):
+            // X = A B C
+            
+            // note we keep the message here and for other authorization problems exactly the same to prevent attackers
+            // from guessing what keyspaces are valid
+            if (null == props.getProperty(keyspace))
+                throw new AuthorizationException(authorizationErrorMessage(keyspace, username));
+
+            for (String allow : props.getProperty(keyspace).split(","))
+            {
+                if (allow.equals(username)) authorized = AccessLevel.FULL;
+            }
+        }
+        catch (FileNotFoundException e)
+        {
+            throw new RuntimeException("Authorization table file given by property " + ACCESS_FILENAME_PROPERTY + " could not be found: " + e.getMessage());
+        }
+        catch (IOException e)
+        {
+            throw new RuntimeException("Authorization table file given by property " + ACCESS_FILENAME_PROPERTY + " could not be opened: " + e.getMessage());
+        }
+
+        if (authorized == AccessLevel.NONE) throw new AuthorizationException(authorizationErrorMessage(keyspace, username));
+        
+        return authorized;
     }
 
     @Override
     public void validateConfiguration() throws ConfigurationException 
     {
+        String aFileName = System.getProperty(SimpleAuthenticator.ACCESS_FILENAME_PROPERTY);
         String pfilename = System.getProperty(SimpleAuthenticator.PASSWD_FILENAME_PROPERTY);
-        if (pfilename == null)
+        if (aFileName == null || pfilename == null)
         {
             throw new ConfigurationException("When using " + this.getClass().getCanonicalName() + " " + 
+                    SimpleAuthenticator.ACCESS_FILENAME_PROPERTY + " and " + 
                     SimpleAuthenticator.PASSWD_FILENAME_PROPERTY + " properties must be defined.");	
         }
     }
 
-    /**
-     * Loads the user access map for each keyspace from the deprecated access.properties file.
-     */
-    @Deprecated
-    public Map<String,Map<String,AccessLevel>> loadAccessFile() throws ConfigurationException 
-    {
-        Map<String,Map<String,AccessLevel>> keyspacesAccess = new HashMap();
-        final String accessFilenameProperty = "access.properties";
-        String afilename = System.getProperty(accessFilenameProperty);
-        Properties props = new Properties();
-        try
-        {
-            FileInputStream in = new FileInputStream(afilename);
-            props.load(in);
-            in.close();
-        }
-        catch (Exception e)
-        {
-            throw new ConfigurationException("Authorization table file given by property " + accessFilenameProperty + " could not be loaded: " + e.getMessage());
-        }
-        for (String keyspace : props.stringPropertyNames())
+    static String authorizationErrorMessage(String keyspace, String username)
         {
-            // structure:
-            // given keyspace X, users A B and C can be authorized like this (separate their names with spaces):
-            // X = A B C
-            Map<String,AccessLevel> usersAccess = new HashMap();
-            for (String user : props.getProperty(keyspace).split(","))
-                usersAccess.put(user, AccessLevel.FULL);
-            keyspacesAccess.put(keyspace, usersAccess);
-        }
-        return keyspacesAccess;
+        return String.format("User %s could not be authorized to use keyspace %s", username, keyspace);
     }
 
     static String authenticationErrorMessage(PasswordMode mode, String username)
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java b/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java
index cd0b82af..a18bccc3 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java
@@ -56,7 +56,6 @@
 import org.apache.cassandra.db.migration.AddKeyspace;
 import org.apache.cassandra.locator.AbstractReplicationStrategy;
 import org.apache.cassandra.scheduler.IRequestScheduler;
-import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.StorageProxy;
 import org.apache.cassandra.service.StorageService;
 
@@ -76,8 +75,22 @@
     private final static String D_CF_COMPTYPE = "BytesType";
     private final static String D_CF_SUBCOMPTYPE = "";
     
-    // thread local state containing session information
-    private final ClientState clientState = new ClientState();
+    private ThreadLocal<AccessLevel> loginDone = new ThreadLocal<AccessLevel>()
+    {
+        @Override
+        protected AccessLevel initialValue()
+        {
+            return AccessLevel.NONE;
+        }
+    };
+    
+    // Session keyspace.
+    private ThreadLocal<String> curKeyspace = new ThreadLocal<String>();
+
+    /*
+     * An associated Id for scheduling the requests
+     */
+    private ThreadLocal<String> requestSchedulerId = new ThreadLocal<String>();
 
     /*
      * RequestScheduler to perform the scheduling of incoming requests
@@ -95,7 +108,7 @@ public ColumnOrSuperColumn get(ByteBuffer key, ColumnPath columnPath, Consistenc
         if (logger.isDebugEnabled())
             logger.debug("get");
 
-        AvroValidation.validateColumnPath(clientState.getKeyspace(), columnPath);
+        AvroValidation.validateColumnPath(curKeyspace.get(), columnPath);
         
         // FIXME: This is repetitive.
         byte[] column, super_column;
@@ -105,7 +118,7 @@ public ColumnOrSuperColumn get(ByteBuffer key, ColumnPath columnPath, Consistenc
         QueryPath path = new QueryPath(columnPath.column_family.toString(), column == null ? null : super_column);
         List<byte[]> nameAsList = Arrays.asList(column == null ? super_column : column);
         AvroValidation.validateKey(key.array());
-        ReadCommand command = new SliceByNamesReadCommand(clientState.getKeyspace(), key.array(), path, nameAsList);
+        ReadCommand command = new SliceByNamesReadCommand(curKeyspace.get(), key.array(), path, nameAsList);
         
         Map<DecoratedKey<?>, ColumnFamily> cfamilies = readColumnFamily(Arrays.asList(command), consistencyLevel);
         ColumnFamily cf = cfamilies.get(StorageService.getPartitioner().decorateKey(command.key));
@@ -276,7 +289,7 @@ private static Clock avronateIClock(IClock clock)
         GenericArray<ByteBuffer> keys = new GenericData.Array<ByteBuffer>(1, bytesArray);
         keys.add(key);
         
-        return multigetSliceInternal(clientState.getKeyspace(), keys, columnParent, predicate, consistencyLevel).iterator().next().columns;
+        return multigetSliceInternal(curKeyspace.get(), keys, columnParent, predicate, consistencyLevel).iterator().next().columns;
     }
     
     private GenericArray<CoscsMapEntry> multigetSliceInternal(String keyspace, GenericArray<ByteBuffer> keys,
@@ -353,7 +366,7 @@ public int get_count(ByteBuffer key, ColumnParent columnParent, SlicePredicate p
         if (logger.isDebugEnabled())
             logger.debug("multiget_slice");
         
-        return multigetSliceInternal(clientState.getKeyspace(), keys, columnParent, predicate, consistencyLevel);
+        return multigetSliceInternal(curKeyspace.get(), keys, columnParent, predicate, consistencyLevel);
     }
 
     @Override
@@ -364,10 +377,10 @@ public Void insert(ByteBuffer key, ColumnParent parent, Column column, Consisten
             logger.debug("insert");
 
         AvroValidation.validateKey(key.array());
-        AvroValidation.validateColumnParent(clientState.getKeyspace(), parent);
-        AvroValidation.validateColumn(clientState.getKeyspace(), parent, column);
+        AvroValidation.validateColumnParent(curKeyspace.get(), parent);
+        AvroValidation.validateColumn(curKeyspace.get(), parent, column);
 
-        RowMutation rm = new RowMutation(clientState.getKeyspace(), key.array());
+        RowMutation rm = new RowMutation(curKeyspace.get(), key.array());
         try
         {
             rm.add(new QueryPath(parent.column_family.toString(),
@@ -394,10 +407,10 @@ public Void remove(ByteBuffer key, ColumnPath columnPath, Clock clock, Consisten
             logger.debug("remove");
         
         AvroValidation.validateKey(key.array());
-        AvroValidation.validateColumnPath(clientState.getKeyspace(), columnPath);
+        AvroValidation.validateColumnPath(curKeyspace.get(), columnPath);
         IClock dbClock = AvroValidation.validateClock(clock);
         
-        RowMutation rm = new RowMutation(clientState.getKeyspace(), key.array());
+        RowMutation rm = new RowMutation(curKeyspace.get(), key.array());
         byte[] superName = columnPath.super_column == null ? null : columnPath.super_column.array();
         rm.delete(new QueryPath(columnPath.column_family.toString(), superName), dbClock);
         
@@ -461,9 +474,9 @@ public Void batch_mutate(GenericArray<MutationsMapEntry> mutationMap, Consistenc
                 String cfName = cfMutations.getKey().toString();
                 
                 for (Mutation mutation : cfMutations.getValue())
-                    AvroValidation.validateMutation(clientState.getKeyspace(), cfName, mutation);
+                    AvroValidation.validateMutation(curKeyspace.get(), cfName, mutation);
             }
-            rowMutations.add(getRowMutationFromMutations(clientState.getKeyspace(), pair.key.array(), cfToMutations));
+            rowMutations.add(getRowMutationFromMutations(curKeyspace.get(), pair.key.array(), cfToMutations));
         }
         
         if (consistencyLevel == ConsistencyLevel.ZERO)
@@ -508,16 +521,6 @@ private static IClock unavronateClock(Clock clock)
         return new org.apache.cassandra.db.TimestampClock(clock.timestamp);
     }
     
-    private static Map<String,AccessLevel> unavronateAccessMap(Map<Utf8,AccessLevel> map)
-    {
-        Map<String,AccessLevel> out = new HashMap<String,AccessLevel>();
-        if (map == null)
-            return out;
-        for (Map.Entry<Utf8, AccessLevel> entry : map.entrySet())
-            out.put(entry.getKey().toString(), entry.getValue());
-        return out;
-    }
-
     // FIXME: This is copypasta from o.a.c.db.RowMutation, (RowMutation.getRowMutation uses Thrift types directly).
     private static RowMutation getRowMutationFromMutations(String keyspace, byte[] key, Map<Utf8, GenericArray<Mutation>> cfMap)
     {
@@ -598,7 +601,16 @@ public Void set_keyspace(Utf8 keyspace) throws InvalidRequestException
             throw newInvalidRequestException("Keyspace does not exist");
         }
         
-        clientState.setKeyspace(keyspaceStr);
+        // If switching, invalidate previous access level; force a new login.
+        if (this.curKeyspace.get() != null && !this.curKeyspace.get().equals(keyspaceStr))
+            loginDone.set(AccessLevel.NONE);
+        
+        this.curKeyspace.set(keyspaceStr);
+
+        if (DatabaseDescriptor.getRequestSchedulerId().equals(Config.RequestSchedulerId.keyspace)) {
+            requestSchedulerId.set(curKeyspace.get());
+        }
+
         return null;
     }
 
@@ -654,8 +666,6 @@ public Void system_add_keyspace(KsDef ksDef) throws AvroRemoteException, Invalid
                     ksDef.name.toString(),
                     (Class<? extends AbstractReplicationStrategy>)Class.forName(ksDef.strategy_class.toString()),
                     (int)ksDef.replication_factor,
-                    unavronateAccessMap(ksDef.users_access),
-                    unavronateAccessMap(ksDef.groups_access),
                     cfDefs.toArray(new CFMetaData[cfDefs.size()]));
             AddKeyspace add = new AddKeyspace(ksmeta);
             add.apply();
@@ -720,7 +730,7 @@ public Utf8 describe_version() throws AvroRemoteException
      */
     private void schedule()
     {
-        requestScheduler.queue(Thread.currentThread(), clientState.getSchedulingId());
+        requestScheduler.queue(Thread.currentThread(), requestSchedulerId.get());
     }
 
     /**
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java b/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
index 30938ce9..f6146bbe 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
@@ -32,9 +32,7 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.auth.AllowAllAuthenticator;
-import org.apache.cassandra.auth.SimpleAuthenticator;
 import org.apache.cassandra.auth.IAuthenticator;
-import org.apache.cassandra.avro.AccessLevel;
 import org.apache.cassandra.config.Config.RequestSchedulerId;
 import org.apache.cassandra.db.ClockType;
 import org.apache.cassandra.db.ColumnFamilyType;
@@ -345,12 +343,7 @@ else if (conf.memtable_flush_writers == null)
                 CommitLog.setSegmentSize(conf.commitlog_rotation_threshold_in_mb * 1024 * 1024);
 
             // Hardcoded system tables
-            KSMetaData systemMeta = new KSMetaData(Table.SYSTEM_TABLE,
-                                                   LocalStrategy.class,
-                                                   1,
-                                                   null,
-                                                   null,
-                                                   new CFMetaData[]{CFMetaData.StatusCf,
+            KSMetaData systemMeta = new KSMetaData(Table.SYSTEM_TABLE, LocalStrategy.class, 1, new CFMetaData[]{CFMetaData.StatusCf,
                                                                     CFMetaData.HintsCf,
                                                                     CFMetaData.MigrationsCf,
                                                                     CFMetaData.SchemaCf,
@@ -511,18 +504,11 @@ public boolean accept(File pathname)
         CFMetaData.fixMaxId();
     }
 
-    /**
-     * Reads keyspaces from yaml: doesn't populate any internal structures.
-     * @Deprecated
-     */
+    /** reads xml. doesn't populate any internal structures. */
     public static Collection<KSMetaData> readTablesFromYaml() throws ConfigurationException
     {
         List<KSMetaData> defs = new ArrayList<KSMetaData>();
         
-        /* If SimpleAuthenticator is in use, load the (deprecated) access.properties file, to apply it to keyspaces. */
-        Map<String,Map<String,AccessLevel>> keyspacesAccess = new HashMap();
-        if (DatabaseDescriptor.getAuthenticator() instanceof SimpleAuthenticator)
-            keyspacesAccess = ((SimpleAuthenticator)DatabaseDescriptor.getAuthenticator()).loadAccessFile();
         
         /* Read the table related stuff from config */
         for (RawKeyspace keyspace : conf.keyspaces)
@@ -631,12 +617,8 @@ else if (cf.compare_subcolumns_with != null)
                                              cf.gc_grace_seconds,
                                              metadata);
             }
-            defs.add(new KSMetaData(keyspace.name,
-                                    strategyClass,
-                                    keyspace.replication_factor,
-                                    keyspacesAccess.get(keyspace.name),
-                                    null,
-                                    cfDefs));
+            defs.add(new KSMetaData(keyspace.name, strategyClass, keyspace.replication_factor, cfDefs));
+            
         }
 
         return defs;
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/KSMetaData.java b/cassandra/trunk/src/java/org/apache/cassandra/config/KSMetaData.java
index 538d42f4..b7bf8193 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/KSMetaData.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/KSMetaData.java
@@ -32,18 +32,14 @@
 import org.apache.avro.util.Utf8;
 import org.apache.commons.lang.ObjectUtils;
 
-import org.apache.cassandra.avro.AccessLevel;
-
 public final class KSMetaData
 {
     public final String name;
     public final Class<? extends AbstractReplicationStrategy> strategyClass;
     public final int replicationFactor;
-    public final Map<String, CFMetaData> cfMetaData;
-    public final Map<String, AccessLevel> usersAccess;
-    public final Map<String, AccessLevel> groupsAccess;
+    private final Map<String, CFMetaData> cfMetaData;
 
-    public KSMetaData(String name, Class<? extends AbstractReplicationStrategy> strategyClass, int replicationFactor, Map<String,AccessLevel> usersAccess, Map<String,AccessLevel> groupsAccess, CFMetaData... cfDefs)
+    public KSMetaData(String name, Class<? extends AbstractReplicationStrategy> strategyClass, int replicationFactor, CFMetaData... cfDefs)
     {
         this.name = name;
         this.strategyClass = strategyClass == null ? RackUnawareStrategy.class : strategyClass;
@@ -52,44 +48,6 @@ public KSMetaData(String name, Class<? extends AbstractReplicationStrategy> stra
         for (CFMetaData cfm : cfDefs)
             cfmap.put(cfm.cfName, cfm);
         this.cfMetaData = Collections.unmodifiableMap(cfmap);
-        this.usersAccess = usersAccess == null ?
-            Collections.<String, AccessLevel>emptyMap() : Collections.unmodifiableMap(usersAccess);
-        this.groupsAccess = groupsAccess == null ?
-            Collections.<String, AccessLevel>emptyMap() : Collections.unmodifiableMap(groupsAccess);
-    }
-
-    /**
-     * Copies this KSMetaData, adding an additional ColumnFamily.
-     */
-    public KSMetaData withColumnFamily(CFMetaData cfm)
-    {
-        List<CFMetaData> newCfs = new ArrayList<CFMetaData>(cfMetaData().values());
-        newCfs.add(cfm);
-        return new KSMetaData(name, strategyClass, replicationFactor, usersAccess, groupsAccess, newCfs.toArray(new CFMetaData[newCfs.size()]));
-    }
-
-    /**
-     * Copies this KSMetaData, removing the ColumnFamily with the given name (which must exist).
-     */
-    public KSMetaData withoutColumnFamily(String cfName)
-    {
-        CFMetaData cfm = cfMetaData().get(cfName);
-        List<CFMetaData> newCfs = new ArrayList<CFMetaData>(cfMetaData().values());
-        newCfs.remove(cfm);
-        assert newCfs.size() == cfMetaData().size() - 1;
-        return new KSMetaData(name, strategyClass, replicationFactor, usersAccess, groupsAccess, newCfs.toArray(new CFMetaData[newCfs.size()]));
-    }
-
-    /**
-     * Copies this KSMetaData, returning a renamed copy.
-     */
-    public KSMetaData withName(String ksName)
-    {
-        // cfs will need to have their tablenames reset, but their ids will not change
-        List<CFMetaData> newCfs = new ArrayList<CFMetaData>(cfMetaData().size());
-        for (CFMetaData oldCf : cfMetaData().values())
-            newCfs.add(CFMetaData.renameTable(oldCf, ksName));
-        return new KSMetaData(ksName, strategyClass, replicationFactor, usersAccess, groupsAccess, newCfs.toArray(new CFMetaData[newCfs.size()]));
     }
 
     public boolean equals(Object obj)
@@ -117,8 +75,6 @@ public boolean equals(Object obj)
         ks.name = new Utf8(name);
         ks.strategy_class = new Utf8(strategyClass.getName());
         ks.replication_factor = replicationFactor;
-        ks.users_access = SerDeUtils.toAvroMap(usersAccess);
-        ks.groups_access = SerDeUtils.toAvroMap(groupsAccess);
         ks.cf_defs = SerDeUtils.createArray(cfMetaData.size(), org.apache.cassandra.avro.CfDef.SCHEMA$);
         for (CFMetaData cfm : cfMetaData.values())
             ks.cf_defs.add(cfm.deflate());
@@ -136,14 +92,12 @@ public static KSMetaData inflate(org.apache.cassandra.avro.KsDef ks) throws Conf
         {
             throw new ConfigurationException("Could not create ReplicationStrategy of type " + ks.strategy_class, ex);
         }
-        Map<String,AccessLevel> usersAccess = SerDeUtils.fromAvroMap(ks.users_access);
-        Map<String,AccessLevel> groupsAccess = SerDeUtils.fromAvroMap(ks.groups_access);
         int cfsz = (int)ks.cf_defs.size();
         CFMetaData[] cfMetaData = new CFMetaData[cfsz];
         Iterator<org.apache.cassandra.avro.CfDef> cfiter = ks.cf_defs.iterator();
         for (int i = 0; i < cfsz; i++)
             cfMetaData[i] = CFMetaData.inflate(cfiter.next());
 
-        return new KSMetaData(ks.name.toString(), repStratClass, ks.replication_factor, usersAccess, groupsAccess, cfMetaData);
+        return new KSMetaData(ks.name.toString(), repStratClass, ks.replication_factor, cfMetaData);
     }
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
index 579f185b..b30692ab 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
@@ -73,16 +73,23 @@ else if (ksm.cfMetaData().containsKey(cfm.cfName))
             throw new ConfigurationException("CF is already defined in that keyspace.");
         
         // clone ksm but include the new cf def.
-        KSMetaData newKsm = ksm.withColumnFamily(cfm);
+        KSMetaData newKsm = makeNewKeyspaceDefinition(ksm);
         
         rm = Migration.makeDefinitionMutation(newKsm, null, newVersion);
     }
     
+    private KSMetaData makeNewKeyspaceDefinition(KSMetaData ksm)
+    {
+        List<CFMetaData> newCfs = new ArrayList<CFMetaData>(ksm.cfMetaData().values());
+        newCfs.add(cfm);
+        return new KSMetaData(ksm.name, ksm.strategyClass, ksm.replicationFactor, newCfs.toArray(new CFMetaData[newCfs.size()]));
+    }
+    
     public void applyModels() throws IOException
     {
         // reinitialize the table.
         KSMetaData ksm = DatabaseDescriptor.getTableDefinition(cfm.tableName);
-        ksm = ksm.withColumnFamily(cfm);
+        ksm = makeNewKeyspaceDefinition(ksm);
         try
         {
             CFMetaData.map(cfm);
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/DropColumnFamily.java b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/DropColumnFamily.java
index b2454ac4..b5794051 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/DropColumnFamily.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/DropColumnFamily.java
@@ -70,10 +70,20 @@ public DropColumnFamily(String tableName, String cfName, boolean blockOnFileDele
         else if (!ksm.cfMetaData().containsKey(cfName))
             throw new ConfigurationException("CF is not defined in that keyspace.");
         
-        KSMetaData newKsm = ksm.withoutColumnFamily(cfName);
+        KSMetaData newKsm = makeNewKeyspaceDefinition(ksm);
         rm = Migration.makeDefinitionMutation(newKsm, null, newVersion);
     }
 
+    private KSMetaData makeNewKeyspaceDefinition(KSMetaData ksm)
+    {
+        // clone ksm but do not include the new def
+        CFMetaData cfm = ksm.cfMetaData().get(cfName);
+        List<CFMetaData> newCfs = new ArrayList<CFMetaData>(ksm.cfMetaData().values());
+        newCfs.remove(cfm);
+        assert newCfs.size() == ksm.cfMetaData().size() - 1;
+        return new KSMetaData(ksm.name, ksm.strategyClass, ksm.replicationFactor, newCfs.toArray(new CFMetaData[newCfs.size()]));
+    }
+
     @Override
     public void beforeApplyModels()
     {
@@ -95,7 +105,7 @@ public void applyModels() throws IOException
         // reinitialize the table.
         KSMetaData existing = DatabaseDescriptor.getTableDefinition(tableName);
         CFMetaData cfm = existing.cfMetaData().get(cfName);
-        KSMetaData ksm = existing.withoutColumnFamily(cfName);
+        KSMetaData ksm = makeNewKeyspaceDefinition(existing);
         CFMetaData.purge(cfm);
         DatabaseDescriptor.setTableDefinition(ksm, newVersion);
         
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/RenameColumnFamily.java b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/RenameColumnFamily.java
index b113f6be..66727f46 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/RenameColumnFamily.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/RenameColumnFamily.java
@@ -38,6 +38,8 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
+
 public class RenameColumnFamily extends Migration
 {
     private static final Serializer serializer = new Serializer();
@@ -84,8 +86,12 @@ public RenameColumnFamily(String tableName, String oldName, String newName) thro
     private KSMetaData makeNewKeyspaceDefinition(KSMetaData ksm)
     {
         CFMetaData oldCfm = ksm.cfMetaData().get(oldName);
-        KSMetaData temp = ksm.withoutColumnFamily(oldName);
-        return temp.withColumnFamily(CFMetaData.rename(oldCfm, newName));
+        List<CFMetaData> newCfs = new ArrayList<CFMetaData>(ksm.cfMetaData().values());
+        newCfs.remove(oldCfm);
+        assert newCfs.size() == ksm.cfMetaData().size() - 1;
+        CFMetaData newCfm = CFMetaData.rename(oldCfm, newName);
+        newCfs.add(newCfm);
+        return new KSMetaData(ksm.name, ksm.strategyClass, ksm.replicationFactor, newCfs.toArray(new CFMetaData[newCfs.size()]));
     }
 
     @Override
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/RenameKeyspace.java b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/RenameKeyspace.java
index db0f8bf6..04b09a44 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/RenameKeyspace.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/RenameKeyspace.java
@@ -69,11 +69,25 @@ public RenameKeyspace(String oldName, String newName) throws ConfigurationExcept
             throw new ConfigurationException("Keyspace already exists.");
         
         // clone the ksm, replacing thename.
-        KSMetaData newKsm = oldKsm.withName(newName); 
+        KSMetaData newKsm = rename(oldKsm, newName, false); 
         
         rm = makeDefinitionMutation(newKsm, oldKsm, newVersion);
     }
     
+    private static KSMetaData rename(KSMetaData ksm, String newName, boolean purgeOldCfs)
+    {
+        // cfs will need to have their tablenames reset. CFMetaData are immutable, so new ones get created with the
+        // same ids.
+        List<CFMetaData> newCfs = new ArrayList<CFMetaData>(ksm.cfMetaData().size());
+        for (CFMetaData oldCf : ksm.cfMetaData().values())
+        {
+            if (purgeOldCfs)
+                CFMetaData.purge(oldCf);
+            newCfs.add(CFMetaData.renameTable(oldCf, newName));
+        }
+        return new KSMetaData(newName, ksm.strategyClass, ksm.replicationFactor, newCfs.toArray(new CFMetaData[newCfs.size()]));
+    }
+
     @Override
     public ICompactSerializer getSerializer()
     {
@@ -88,9 +102,8 @@ public void applyModels() throws IOException
         
         KSMetaData oldKsm = DatabaseDescriptor.getTableDefinition(oldName);
         for (CFMetaData cfm : oldKsm.cfMetaData().values())
-            // remove cf mappings for previous ksname
             CFMetaData.purge(cfm);
-        KSMetaData newKsm = oldKsm.withName(newName);
+        KSMetaData newKsm = rename(oldKsm, newName, true);
         for (CFMetaData cfm : newKsm.cfMetaData().values())
         {
             try
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/io/SerDeUtils.java b/cassandra/trunk/src/java/org/apache/cassandra/io/SerDeUtils.java
index d27195e8..499ec99a 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/io/SerDeUtils.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/io/SerDeUtils.java
@@ -22,8 +22,6 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.util.Map;
-import java.util.HashMap;
 
 import org.apache.avro.Schema;
 import org.apache.avro.io.BinaryDecoder;
@@ -47,22 +45,6 @@
     // unbuffered decoders
     private final static DecoderFactory DIRECT_DECODERS = new DecoderFactory().configureDirectDecoder(true);
 
-    public static <T> Map<Utf8,T> toAvroMap(Map<String,T> map)
-    {
-        Map<Utf8,T> out = new HashMap<Utf8,T>();
-        for (Map.Entry<String,T> entry : map.entrySet())
-            out.put(new Utf8(entry.getKey()), entry.getValue());
-        return out;
-    }
-
-    public static <T> Map<String,T> fromAvroMap(Map<Utf8,T> map)
-    {
-        Map<String,T> out = new HashMap<String,T>();
-        for (Map.Entry<Utf8,T> entry : map.entrySet())
-            out.put(entry.getKey().toString(), entry.getValue());
-        return out;
-    }
-
 	/**
      * Deserializes a single object based on the given Schema.
      * @param schema writer's schema
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/service/ClientState.java b/cassandra/trunk/src/java/org/apache/cassandra/service/ClientState.java
index 35323576..e69de29b 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/service/ClientState.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/service/ClientState.java
@@ -1,146 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.service;
-
-import java.util.Map;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import org.apache.cassandra.auth.AuthenticatedUser;
-import org.apache.cassandra.avro.AccessLevel;
-import org.apache.cassandra.config.Config.RequestSchedulerId;
-import org.apache.cassandra.config.DatabaseDescriptor;
-import org.apache.cassandra.config.KSMetaData;
-import org.apache.cassandra.thrift.AuthenticationException;
-import org.apache.cassandra.thrift.AuthorizationException;
-import org.apache.cassandra.thrift.InvalidRequestException;
-
-/**
- * A container for per-client, thread-local state that Avro/Thrift threads must hold.
- */
-public class ClientState
-{
-    private static Logger logger = LoggerFactory.getLogger(ClientState.class);
-    
-    // true if the keyspace should be used as the scheduling id
-    private final boolean SCHEDULE_ON_KEYSPACE = DatabaseDescriptor.getRequestSchedulerId().equals(RequestSchedulerId.keyspace);
-
-    // Current user for the session
-    private final ThreadLocal<AuthenticatedUser> user = new ThreadLocal<AuthenticatedUser>()
-    {
-        @Override
-        public AuthenticatedUser initialValue()
-        {
-            return DatabaseDescriptor.getAuthenticator().defaultUser();
-        }
-    };
-
-    // Keyspace and keyspace AccessLevels associated with the session
-    private final ThreadLocal<String> keyspace = new ThreadLocal<String>();
-    private final ThreadLocal<AccessLevel> keyspaceAccess = new ThreadLocal<AccessLevel>();
-
-    /**
-     * Called when the keyspace or user have changed.
-     */
-    private void updateKeyspaceAccess()
-    {
-        if (user.get() == null)
-            // user is not logged in
-            keyspaceAccess.set(null);
-        else if (user.get().isSuper)
-            // super user
-            keyspaceAccess.set(AccessLevel.FULL);
-        else if (keyspace.get() != null)
-        {
-            // lookup the access level for the user in the current keyspace
-            KSMetaData ksm = DatabaseDescriptor.getTableDefinition(keyspace.get());
-            keyspaceAccess.set(user.get().levelFor(ksm.usersAccess, ksm.groupsAccess));
-        }
-        else
-            // user is logged in, but no keyspace is set
-            keyspaceAccess.set(null);
-    }
-
-    public String getKeyspace()
-    {
-        return keyspace.get();
-    }
-
-    public void setKeyspace(String ks)
-    {
-        keyspace.set(ks);
-        updateKeyspaceAccess();
-    }
-
-    public String getSchedulingId()
-    {
-        if (SCHEDULE_ON_KEYSPACE)
-            return keyspace.get();
-        return "default";
-    }
-
-    /**
-     * Attempts to login this client with the given credentials map.
-     * TODO: Kill thrift exceptions
-     */
-    public void login(Map<String,String> credentials) throws AuthenticationException, AuthorizationException
-    {
-        AuthenticatedUser user = DatabaseDescriptor.getAuthenticator().login(credentials);
-        if (logger.isDebugEnabled())
-            logger.debug("logged in: {}", user);
-        this.user.set(user);
-        updateKeyspaceAccess();
-    }
-
-    public void logout()
-    {
-        if (logger.isDebugEnabled())
-            logger.debug("logged out: {}", user.get());
-        user.remove();
-        keyspace.remove();
-        keyspaceAccess.remove();
-    }
-
-    /**
-     * Confirms that the client thread has the given AccessLevel in the 'base' context (where Keyspace
-     * management occurs).
-     */
-    public void hasBaseAccess(AccessLevel level) throws InvalidRequestException
-    {
-        if (user.get() == null)
-            throw new InvalidRequestException("You have not logged in");
-        // FIXME: only checking for the super user until 1271 lands
-        if (!user.get().isSuper)
-            throw new InvalidRequestException("Only a 'super' user may modify keyspaces");
-    }
-
-    /**
-     * Confirms that the client thread has the given AccessLevel in the context of the current Keyspace.
-     */
-    public void hasKeyspaceAccess(AccessLevel level) throws InvalidRequestException
-    {
-        if (user.get() == null)
-            throw new InvalidRequestException("You have not logged in");
-        if (keyspaceAccess.get() == null)
-            throw new InvalidRequestException("You have not set a keyspace for this session");
-        if (keyspaceAccess.get().ordinal() < level.ordinal())
-            throw new InvalidRequestException(String.format("Your user (%s) does not have permission to perform %s operations", user, level));
-    }
-}
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraDaemon.java b/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraDaemon.java
index 3ab9769c..3447c7b0 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraDaemon.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraDaemon.java
@@ -189,7 +189,7 @@ public void uncaughtException(Thread t, Throwable e)
             protected void afterExecute(Runnable r, Throwable t)
             {
                 super.afterExecute(r, t);
-                cassandraServer.clientState.logout();
+                cassandraServer.logout();
             }
         };
         serverEngine = new CustomTThreadPoolServer(new TProcessorFactory(processor),
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java b/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
index 54b7b876..d4cbe708 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
@@ -29,10 +29,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-// importing avro.AccessLevel hides thrift.AccessLevel
-import org.apache.cassandra.avro.AccessLevel;
 import org.apache.cassandra.auth.AllowAllAuthenticator;
-import org.apache.cassandra.auth.AuthenticatedUser;
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.config.KSMetaData;
@@ -56,7 +53,6 @@
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.scheduler.IRequestScheduler;
-import org.apache.cassandra.service.ClientState;
 import org.apache.cassandra.service.StorageProxy;
 import org.apache.cassandra.service.StorageService;
 import org.apache.thrift.TException;
@@ -69,8 +65,24 @@
     private final static List<ColumnOrSuperColumn> EMPTY_COLUMNS = Collections.emptyList();
     private final static List<Column> EMPTY_SUBCOLUMNS = Collections.emptyList();
 
-    // thread local state containing session information
-    public final ClientState clientState = new ClientState();
+    // will be set only by login()
+    private ThreadLocal<AccessLevel> loginDone = new ThreadLocal<AccessLevel>() 
+    {
+        @Override
+        protected AccessLevel initialValue()
+        {
+            return AccessLevel.NONE;
+        }
+    };
+    /*
+     * Keyspace associated with session
+     */
+    private ThreadLocal<String> keySpace = new ThreadLocal<String>();
+
+    /*
+     * An associated Id for scheduling the requests
+     */
+    private ThreadLocal<String> requestSchedulerId = new ThreadLocal<String>();
 
     /*
      * RequestScheduler to perform the scheduling of incoming requests
@@ -213,16 +225,6 @@ private static Clock thriftifyIClock(IClock clock)
         return thrift_clock;
     }
 
-    private static Map<String,AccessLevel> unthriftifyAccessMap(Map<String,org.apache.cassandra.thrift.AccessLevel> map)
-    {
-        Map<String,AccessLevel> out = new HashMap<String,AccessLevel>();
-        if (map == null)
-            return out;
-        for (Map.Entry<String,org.apache.cassandra.thrift.AccessLevel> entry : map.entrySet())
-            out.put(entry.getKey(), Enum.valueOf(org.apache.cassandra.avro.AccessLevel.class, entry.getValue().name()));
-        return out;
-    }
-
     private Map<byte[], List<ColumnOrSuperColumn>> getSlice(List<ReadCommand> commands, ConsistencyLevel consistency_level)
     throws InvalidRequestException, UnavailableException, TimedOutException
     {
@@ -264,8 +266,8 @@ private static Clock thriftifyIClock(IClock clock)
         if (logger.isDebugEnabled())
             logger.debug("get_slice");
         
-        clientState.hasKeyspaceAccess(AccessLevel.READONLY);
-        return multigetSliceInternal(clientState.getKeyspace(), Arrays.asList(key), column_parent, predicate, consistency_level).get(key);
+        checkKeyspaceAndLoginAuthorized(AccessLevel.READONLY);
+        return multigetSliceInternal(keySpace.get(), Arrays.asList(key), column_parent, predicate, consistency_level).get(key);
     }
     
     public Map<byte[], List<ColumnOrSuperColumn>> multiget_slice(List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
@@ -274,9 +276,9 @@ private static Clock thriftifyIClock(IClock clock)
         if (logger.isDebugEnabled())
             logger.debug("multiget_slice");
 
-        clientState.hasKeyspaceAccess(AccessLevel.READONLY);
+        checkKeyspaceAndLoginAuthorized(AccessLevel.READONLY);
 
-        return multigetSliceInternal(clientState.getKeyspace(), keys, column_parent, predicate, consistency_level);
+        return multigetSliceInternal(keySpace.get(), keys, column_parent, predicate, consistency_level);
     }
 
     private Map<byte[], List<ColumnOrSuperColumn>> multigetSliceInternal(String keyspace, List<byte[]> keys, ColumnParent column_parent, SlicePredicate predicate, ConsistencyLevel consistency_level)
@@ -313,8 +315,8 @@ public ColumnOrSuperColumn get(byte[] key, ColumnPath column_path, ConsistencyLe
         if (logger.isDebugEnabled())
             logger.debug("get");
 
-        clientState.hasKeyspaceAccess(AccessLevel.READONLY);
-        String keyspace = clientState.getKeyspace();
+        checkKeyspaceAndLoginAuthorized(AccessLevel.READONLY);
+        String keyspace = keySpace.get();
 
         ThriftValidation.validateColumnPath(keyspace, column_path);
 
@@ -341,7 +343,7 @@ public int get_count(byte[] key, ColumnParent column_parent, SlicePredicate pred
         if (logger.isDebugEnabled())
             logger.debug("get_count");
 
-        clientState.hasKeyspaceAccess(AccessLevel.READONLY);
+        checkKeyspaceAndLoginAuthorized(AccessLevel.READONLY);
 
         return get_slice(key, column_parent, predicate, consistency_level).size();
     }
@@ -352,7 +354,7 @@ public int get_count(byte[] key, ColumnParent column_parent, SlicePredicate pred
         if (logger.isDebugEnabled())
             logger.debug("multiget_count");
 
-        clientState.hasKeyspaceAccess(AccessLevel.READONLY);
+        checkKeyspaceAndLoginAuthorized(AccessLevel.READONLY);
 
         Map<byte[], Integer> counts = new HashMap<byte[], Integer>();
         Map<byte[], List<ColumnOrSuperColumn>> columnFamiliesMap = multigetSliceInternal(table, keys, column_parent, predicate, consistency_level);
@@ -369,14 +371,14 @@ public void insert(byte[] key, ColumnParent column_parent, Column column, Consis
         if (logger.isDebugEnabled())
             logger.debug("insert");
 
-        clientState.hasKeyspaceAccess(AccessLevel.READWRITE);
+        checkKeyspaceAndLoginAuthorized(AccessLevel.READWRITE);
 
         ThriftValidation.validateKey(key);
-        ThriftValidation.validateColumnParent(clientState.getKeyspace(), column_parent);
-        ThriftValidation.validateColumn(clientState.getKeyspace(), column_parent, column);
+        ThriftValidation.validateColumnParent(keySpace.get(), column_parent);
+        ThriftValidation.validateColumn(keySpace.get(), column_parent, column);
         IClock cassandra_clock = ThriftValidation.validateClock(column.clock);
 
-        RowMutation rm = new RowMutation(clientState.getKeyspace(), key);
+        RowMutation rm = new RowMutation(keySpace.get(), key);
         try
         {
             rm.add(new QueryPath(column_parent.column_family, column_parent.super_column, column.name), column.value, cassandra_clock, column.ttl);
@@ -412,7 +414,7 @@ public void batch_mutate(Map<byte[],Map<String,List<Mutation>>> mutation_map, Co
             }
         }
         
-        clientState.hasKeyspaceAccess(needed);
+        checkKeyspaceAndLoginAuthorized(needed);
 
         List<RowMutation> rowMutations = new ArrayList<RowMutation>();
         for (Map.Entry<byte[], Map<String, List<Mutation>>> mutationEntry: mutation_map.entrySet())
@@ -427,10 +429,10 @@ public void batch_mutate(Map<byte[],Map<String,List<Mutation>>> mutation_map, Co
 
                 for (Mutation mutation : columnFamilyMutations.getValue())
                 {
-                    ThriftValidation.validateMutation(clientState.getKeyspace(), cfName, mutation);
+                    ThriftValidation.validateMutation(keySpace.get(), cfName, mutation);
                 }
             }
-            rowMutations.add(RowMutation.getRowMutationFromMutations(clientState.getKeyspace(), key, columnFamilyToMutations));
+            rowMutations.add(RowMutation.getRowMutationFromMutations(keySpace.get(), key, columnFamilyToMutations));
         }
 
         doInsert(consistency_level, rowMutations);
@@ -442,14 +444,14 @@ public void remove(byte[] key, ColumnPath column_path, Clock clock, ConsistencyL
         if (logger.isDebugEnabled())
             logger.debug("remove");
 
-        clientState.hasKeyspaceAccess(AccessLevel.FULL);
+        checkKeyspaceAndLoginAuthorized(AccessLevel.FULL);
 
         ThriftValidation.validateKey(key);
-        ThriftValidation.validateColumnPathOrParent(clientState.getKeyspace(), column_path);
+        ThriftValidation.validateColumnPathOrParent(keySpace.get(), column_path);
 
         IClock cassandra_clock = ThriftValidation.validateClock(clock);
 
-        RowMutation rm = new RowMutation(clientState.getKeyspace(), key);
+        RowMutation rm = new RowMutation(keySpace.get(), key);
         rm.delete(new QueryPath(column_path), cassandra_clock);
 
         doInsert(consistency_level, Arrays.asList(rm));
@@ -517,8 +519,8 @@ private void doInsert(ConsistencyLevel consistency_level, List<RowMutation> muta
         if (logger.isDebugEnabled())
             logger.debug("range_slice");
 
-        String keyspace = clientState.getKeyspace();
-        clientState.hasKeyspaceAccess(AccessLevel.READONLY);
+        String keyspace = keySpace.get();
+        checkKeyspaceAndLoginAuthorized(AccessLevel.READONLY);
 
         return getRangeSlicesInternal(keyspace, column_parent, range, predicate, consistency_level);
     }
@@ -587,11 +589,11 @@ private void doInsert(ConsistencyLevel consistency_level, List<RowMutation> muta
         if (logger.isDebugEnabled())
             logger.debug("scan");
 
-        clientState.hasKeyspaceAccess(AccessLevel.READONLY);
+        checkKeyspaceAndLoginAuthorized(AccessLevel.READONLY);
 
         if (row_predicate.keys != null)
         {
-            Map<byte[], List<ColumnOrSuperColumn>> rowMap = multigetSliceInternal(clientState.getKeyspace(), row_predicate.keys, column_parent, column_predicate, consistency_level);
+            Map<byte[], List<ColumnOrSuperColumn>> rowMap = multigetSliceInternal(keySpace.get(), row_predicate.keys, column_parent, column_predicate, consistency_level);
             List<KeySlice> rows = new ArrayList<KeySlice>(rowMap.size());
             for (Map.Entry<byte[], List<ColumnOrSuperColumn>> entry : rowMap.entrySet())
             {
@@ -602,12 +604,12 @@ private void doInsert(ConsistencyLevel consistency_level, List<RowMutation> muta
 
         if (row_predicate.key_range != null)
         {
-            return getRangeSlicesInternal(clientState.getKeyspace(), column_parent, row_predicate.key_range, column_predicate, consistency_level);
+            return getRangeSlicesInternal(keySpace.get(), column_parent, row_predicate.key_range, column_predicate, consistency_level);
         }
 
         if (row_predicate.index_clause != null)
         {
-            return scanIndexInternal(clientState.getKeyspace(), column_parent, row_predicate.index_clause, column_predicate, consistency_level);
+            return scanIndexInternal(keySpace.get(), column_parent, row_predicate.index_clause, column_predicate, consistency_level);
         }
 
         throw new InvalidRequestException("row predicate must specify keys, key_range, or index_clause");
@@ -694,9 +696,47 @@ public String describe_partitioner() throws TException
         return splits;
     }
 
-    public void login(AuthenticationRequest auth_request) throws AuthenticationException, AuthorizationException, TException
+    public AccessLevel login(AuthenticationRequest auth_request) throws AuthenticationException, AuthorizationException, TException
+    {
+        AccessLevel level;
+        
+        if (keySpace.get() == null)
+        {
+            throw new AuthenticationException("You have not set a specific keyspace; please call set_keyspace first");
+        }
+        
+        level = DatabaseDescriptor.getAuthenticator().login(keySpace.get(), auth_request);
+        
+        if (logger.isDebugEnabled())
+            logger.debug("login confirmed; new access level is " + level);
+        
+        loginDone.set(level);
+        return level;
+    }
+
+    public void logout()
     {
-        clientState.login(auth_request.getCredentials());
+        keySpace.remove();
+        loginDone.remove();
+
+        if (logger.isDebugEnabled())
+            logger.debug("logout complete");
+    }
+
+    protected void checkKeyspaceAndLoginAuthorized(AccessLevel level) throws InvalidRequestException
+    {
+        if (keySpace.get() == null)
+        {
+            throw new InvalidRequestException("You have not assigned a keyspace; please use set_keyspace (and login if necessary)");
+        }
+        
+        if (!(DatabaseDescriptor.getAuthenticator() instanceof AllowAllAuthenticator))
+        {
+            if (loginDone.get() == null)
+                throw new InvalidRequestException("You have not logged into keyspace " + keySpace.get());
+            if (loginDone.get().getValue() < level.getValue())
+                throw new InvalidRequestException("Your credentials are not sufficient to perform " + level + " operations");
+        }
     }
 
     /**
@@ -704,7 +744,7 @@ public void login(AuthenticationRequest auth_request) throws AuthenticationExcep
      */
     private void schedule()
     {
-        requestScheduler.queue(Thread.currentThread(), clientState.getSchedulingId());
+        requestScheduler.queue(Thread.currentThread(), requestSchedulerId.get());
     }
 
     /**
@@ -756,8 +796,7 @@ public Object call() throws Exception
 
     public String system_add_column_family(CfDef cf_def) throws InvalidRequestException, TException
     {
-        clientState.hasBaseAccess(AccessLevel.FULL);
-        
+        checkKeyspaceAndLoginAuthorized(AccessLevel.FULL);
         try
         {
             applyMigrationOnStage(new AddColumnFamily(convertToCFMetaData(cf_def)));
@@ -779,11 +818,11 @@ public String system_add_column_family(CfDef cf_def) throws InvalidRequestExcept
 
     public String system_drop_column_family(String column_family) throws InvalidRequestException, TException
     {
-        clientState.hasBaseAccess(AccessLevel.FULL);
+        checkKeyspaceAndLoginAuthorized(AccessLevel.FULL);
         
         try
         {
-            applyMigrationOnStage(new DropColumnFamily(clientState.getKeyspace(), column_family, true));
+            applyMigrationOnStage(new DropColumnFamily(keySpace.get(), column_family, true));
             return DatabaseDescriptor.getDefsVersion().toString();
         }
         catch (ConfigurationException e)
@@ -802,11 +841,11 @@ public String system_drop_column_family(String column_family) throws InvalidRequ
 
     public String system_rename_column_family(String old_name, String new_name) throws InvalidRequestException, TException
     {
-        clientState.hasBaseAccess(AccessLevel.FULL);
+        checkKeyspaceAndLoginAuthorized(AccessLevel.FULL);
         
         try
         {
-            applyMigrationOnStage(new RenameColumnFamily(clientState.getKeyspace(), old_name, new_name));
+            applyMigrationOnStage(new RenameColumnFamily(keySpace.get(), old_name, new_name));
             return DatabaseDescriptor.getDefsVersion().toString();
         }
         catch (ConfigurationException e)
@@ -828,7 +867,6 @@ public String system_add_keyspace(KsDef ks_def) throws InvalidRequestException,
         // IAuthenticator was devised prior to, and without thought for, dynamic keyspace creation. As
         // a result, we must choose between letting anyone/everyone create keyspaces (which they likely
         // won't even be able to use), or be honest and disallow it entirely if configured for auth.
-        // See CASSANDRA-1271 for a proposed solution.
         if (!(DatabaseDescriptor.getAuthenticator() instanceof AllowAllAuthenticator))
             throw new InvalidRequestException("Unable to create new keyspace while authentication is enabled.");
 
@@ -853,8 +891,6 @@ public String system_add_keyspace(KsDef ks_def) throws InvalidRequestException,
                     ks_def.name, 
                     (Class<? extends AbstractReplicationStrategy>)Class.forName(ks_def.strategy_class), 
                     ks_def.replication_factor,
-                    unthriftifyAccessMap(ks_def.users_access),
-                    unthriftifyAccessMap(ks_def.groups_access),
                     cfDefs.toArray(new CFMetaData[cfDefs.size()]));
             applyMigrationOnStage(new AddKeyspace(ksm));
             return DatabaseDescriptor.getDefsVersion().toString();
@@ -881,7 +917,7 @@ public String system_add_keyspace(KsDef ks_def) throws InvalidRequestException,
     
     public String system_drop_keyspace(String keyspace) throws InvalidRequestException, TException
     {
-        clientState.hasBaseAccess(AccessLevel.FULL);
+        checkKeyspaceAndLoginAuthorized(AccessLevel.FULL);
         
         try
         {
@@ -904,13 +940,11 @@ public String system_drop_keyspace(String keyspace) throws InvalidRequestExcepti
 
     public String system_rename_keyspace(String old_name, String new_name) throws InvalidRequestException, TException
     {
-        clientState.hasBaseAccess(AccessLevel.FULL);
+        checkKeyspaceAndLoginAuthorized(AccessLevel.FULL);
         
         try
         {
-            RenameKeyspace rename = new RenameKeyspace(old_name, new_name);
-            rename.apply();
-            rename.announce();
+            applyMigrationOnStage(new RenameKeyspace(old_name, new_name));
             return DatabaseDescriptor.getDefsVersion().toString();
         }
         catch (ConfigurationException e)
@@ -967,12 +1001,12 @@ private CFMetaData convertToCFMetaData(CfDef cf_def) throws InvalidRequestExcept
 
     public void truncate(String cfname) throws InvalidRequestException, UnavailableException, TException
     {
-        logger.debug("truncating {} in {}", cfname, clientState.getKeyspace());
-        clientState.hasKeyspaceAccess(AccessLevel.READWRITE);
+        logger.debug("truncating {} in {}", cfname, keySpace.get());
+        checkKeyspaceAndLoginAuthorized(AccessLevel.FULL);
         try
         {
             schedule();
-            StorageProxy.truncateBlocking(clientState.getKeyspace(), cfname);
+            StorageProxy.truncateBlocking(keySpace.get(), cfname);
         }
         catch (TimeoutException e)
         {
@@ -995,7 +1029,12 @@ public void set_keyspace(String keyspace) throws InvalidRequestException, TExcep
             throw new InvalidRequestException("Keyspace does not exist");
         }
         
-        clientState.setKeyspace(keyspace);
+        // If switching, invalidate previous access level; force a new login.
+        if (keySpace.get() != null && !keySpace.get().equals(keyspace))
+            loginDone.set(AccessLevel.NONE);
+        
+        keySpace.set(keyspace);
+        requestSchedulerId.set(keyspace);
     }
 
     public Map<String, List<String>> check_schema_agreement() throws TException, InvalidRequestException
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/config/DatabaseDescriptorTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/config/DatabaseDescriptorTest.java
index e6255225..2b8f27a0 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/config/DatabaseDescriptorTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/config/DatabaseDescriptorTest.java
@@ -37,7 +37,9 @@
 {
     protected <D extends SpecificRecord> D serDe(D record) throws IOException
     {
-        return SerDeUtils.<D>deserialize(record.getSchema(), SerDeUtils.serialize(record));
+        D actual = SerDeUtils.<D>deserialize(record.getSchema(), SerDeUtils.serialize(record));
+        assert actual.equals(record) : actual + " != " + record;
+        return actual;
     }
 
     @Test
@@ -81,9 +83,9 @@ public void testTransKsMigration() throws IOException, ConfigurationException
         assert DatabaseDescriptor.getNonSystemTables().size() == 0;
         
         // add a few.
-        AddKeyspace ks0 = new AddKeyspace(new KSMetaData("ks0", RackUnawareStrategy.class, 3, null, null));
+        AddKeyspace ks0 = new AddKeyspace(new KSMetaData("ks0", RackUnawareStrategy.class, 3));
         ks0.apply();
-        AddKeyspace ks1 = new AddKeyspace(new KSMetaData("ks1", RackUnawareStrategy.class, 3, null, null));
+        AddKeyspace ks1 = new AddKeyspace(new KSMetaData("ks1", RackUnawareStrategy.class, 3));
         ks1.apply();
         
         assert DatabaseDescriptor.getTableDefinition("ks0") != null;
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
index 56246fa0..b20562f0 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
@@ -262,7 +262,7 @@ public void addNewKS() throws ConfigurationException, IOException, ExecutionExce
     {
         DecoratedKey dk = Util.dk("key0");
         CFMetaData newCf = new CFMetaData("NewKeyspace1", "AddedStandard1", ColumnFamilyType.Standard, ClockType.Timestamp, UTF8Type.instance, null, new TimestampReconciler(), "A new cf for a new ks", 0, false, 1.0, 0, 864000, Collections.<byte[], ColumnDefinition>emptyMap());
-        KSMetaData newKs = new KSMetaData(newCf.tableName, RackUnawareStrategy.class, 5, null, null, newCf);
+        KSMetaData newKs = new KSMetaData(newCf.tableName, RackUnawareStrategy.class, 5, newCf);
         
         new AddKeyspace(newKs).apply();
         
@@ -414,7 +414,7 @@ public void createEmptyKsAddNewCf() throws ConfigurationException, IOException,
     {
         assert DatabaseDescriptor.getTableDefinition("EmptyKeyspace") == null;
         
-        KSMetaData newKs = new KSMetaData("EmptyKeyspace", RackUnawareStrategy.class, 5, null, null);
+        KSMetaData newKs = new KSMetaData("EmptyKeyspace", RackUnawareStrategy.class, 5, new CFMetaData[]{});
 
         new AddKeyspace(newKs).apply();
         assert DatabaseDescriptor.getTableDefinition("EmptyKeyspace") != null;
