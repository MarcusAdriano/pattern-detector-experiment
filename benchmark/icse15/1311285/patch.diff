diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/Property.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/Property.java
index ab813953..7557b70d 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/Property.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/Property.java
@@ -626,15 +626,6 @@ Default value for wait timeouts (60 seconds)
 	String	LANG_SEQGEN_CACHE_SIZE = "derby.language.sequenceGeneratorCacheSize";
 	int		LANG_SEQGEN_CACHE_SIZE_DEFAULT =32;
 
-	/**
-	 * The size of the identity generator cache 
-	 * used by the data dictionary.  Database.  Static.
-	 * <p>
-	 * Externally visible.
-	 */
-	String	LANG_IDGEN_CACHE_SIZE = "derby.language.identityGeneratorCacheSize";
-	int		LANG_IDGEN_CACHE_SIZE_DEFAULT =32;
-
 	/**
 	 * Name of the implementation of SequencePreallocator which is used
      * to tune how many values Derby pre-allocates for identity columns
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/DataDictionary.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/DataDictionary.java
index 0e97b9c9..aa440e00 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/DataDictionary.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/DataDictionary.java
@@ -1768,6 +1768,29 @@ public void dropFileInfoDescriptor(FileInfoDescriptor fid)
 	public RowLocation getRowLocationTemplate( LanguageConnectionContext lcc, TableDescriptor td)
 		throws StandardException;
 
+	/**
+	 * getSetAutoincrementValue fetches the autoincrement value from 
+	 * SYSCOLUMNS given a row location. If doUpdate is true it updates
+	 * the autoincrement column with the new value.
+	 * the value returned by this routine is the new value and *NOT* the
+	 * value in the system catalogs.
+	 * 
+	 * @param rl		RowLocation of the entry in SYSCOLUMNS.
+	 * @param tc		TransactionController to use.
+	 * @param doUpdate  Write the new value to disk if TRUE.
+	 * @param newValue	A NumberDataValue to use to return incremented value. If
+	 * null, then the caller simply wants the current value fromd disk.
+	 * @param wait		If true, then the caller wants to wait for locks. When
+	 * using a nested user xaction we want to timeout right away if the parent
+	 * holds the lock.
+	 */
+	public NumberDataValue 	getSetAutoincrementValue(RowLocation rl,
+											 TransactionController tc,
+											 boolean doUpdate,
+											 NumberDataValue newValue,
+											 boolean wait)
+		throws StandardException;
+
 	/**
 	 * sets a new value in SYSCOLUMNS for a particular
 	 * autoincrement column.
@@ -1787,22 +1810,21 @@ public void setAutoincrementValue(TransactionController tc,
 		throws StandardException;
 	
 	/**
-	 * Get the next number from an identity or sequence generator
-     * which was created with the CREATE TABLE or CREATE SEQUENCE statement. May
-     * raise an exception if the generator was defined as NO CYCLE and
-     * the range of the generator is exhausted. May allocate a range of
-     * numbers and update the current column of the
-     * corresponding row in SYSCOLULMNS or SYSSEQUENCES. This work is done in the
+	 * Get the next number from an ANSI/ISO sequence generator
+     * which was created with the CREATE SEQUENCE statement. May
+     * raise an exception if the sequence was defined as NO CYCLE and
+     * the range of the sequence is exhausted. May allocate a range of
+     * sequence numbers and update the CURRENTVALUE column of the
+     * corresponding row in SYSSEQUENCES. This work is done in the
      * execution transaction of the current session.
 	 * 
-	 * @param catalogNumber Number of the catalog that manages the values (either SYSCOLUMNS_CATALOG_NUM or SYSSEQUENCES_CATALOG_NUM)
-	 * @param uuidString String value of the UUID which identifies the table or the sequence
-	 * @param returnValue This is a data value to be stuffed with the next number in the range.
+	 * @param sequenceUUIDstring String value of the UUID which identifies the sequence
+	 * @param returnValue This is a data value to be stuffed with the next sequence number.
      *
-     * @throws StandardException if the generator does not cycle and its range is exhausted
+     * @throws StandardException if the sequence does not cycle and its range is exhausted
 	 */
     public void getCurrentValueAndAdvance
-        ( int catalogNumber, String uuidString, NumberDataValue returnValue )
+        ( String sequenceUUIDstring, NumberDataValue returnValue )
         throws StandardException;
 
 	/**
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/SequenceDescriptor.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/SequenceDescriptor.java
index 3fc3d8b5..68bb1b5a 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/SequenceDescriptor.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/SequenceDescriptor.java
@@ -32,7 +32,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.sql.depend.Dependent;
 import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
 import org.apache.derby.iapi.types.DataTypeDescriptor;
-import org.apache.derby.iapi.types.TypeId;
 import org.apache.derby.iapi.store.access.TransactionController;
 
 /**
@@ -45,9 +44,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 public class SequenceDescriptor extends TupleDescriptor
         implements Provider, Dependent, PrivilegedSQLObject
 {
-    // indexes into array of computed min/max values
-    public  static  final   int MIN_VALUE = 0;
-    public  static  final   int MAX_VALUE = MIN_VALUE + 1;
 
     private UUID sequenceUUID;
     private String sequenceName;
@@ -94,35 +90,6 @@ public SequenceDescriptor(DataDictionary dataDictionary, SchemaDescriptor sd, UU
     }
 
     /**
-     * Compute the minimum and maximum values for a sequence range.
-     * Returns an array of two Longs. The first Long is the minimum value,
-     * The second is the maximum value.
-     */
-    public  static  Long[]  computeMinMax
-        (
-         DataTypeDescriptor dataType,
-         Object minValue,
-         Object maxValue
-         )
-    {
-        Long[]  retval = new Long[ 2 ];
-
-        if (dataType.getTypeId().equals(TypeId.SMALLINT_ID)) {
-            retval[ MIN_VALUE ] = (minValue != null ? (Long) minValue : new Long(Short.MIN_VALUE));
-            retval[ MAX_VALUE ] = (maxValue != null ? (Long) maxValue : new Long(Short.MAX_VALUE));
-        } else if (dataType.getTypeId().equals(TypeId.INTEGER_ID)) {
-            retval[ MIN_VALUE ]  = (minValue != null ? (Long) minValue : new Long(Integer.MIN_VALUE));
-            retval[ MAX_VALUE ]  = (maxValue != null ? (Long) maxValue : new Long(Integer.MAX_VALUE));
-        } else {
-            // Could only be BIGINT
-            retval[ MIN_VALUE ]  = (minValue != null ? (Long) minValue : new Long(Long.MIN_VALUE));
-            retval[ MAX_VALUE ]  = (maxValue != null ? (Long) maxValue : new Long(Long.MAX_VALUE));
-        }
-
-        return retval;
-    }
-
-   /**
 	 * @see UniqueTupleDescriptor#getUUID
 	 */
 	public UUID	getUUID()
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java
index ddf3c696..9c6ee2b5 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java
@@ -395,13 +395,11 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	CacheManager	nameTdCache;
 	private CacheManager	spsNameCache;
     private CacheManager sequenceGeneratorCache;
-    private CacheManager idGeneratorCache;
 	private Hashtable		spsIdHash;
 	// private Hashtable       spsTextHash;
 	int				tdCacheSize;
 	int				stmtCacheSize;
     private int seqgenCacheSize;
-    private int idgenCacheSize;
 
     /* Cache of permissions data */
     CacheManager permissionsCache;
@@ -647,10 +645,6 @@ public void boot(boolean create, Properties startParams)
 		seqgenCacheSize = PropertyUtil.intPropertyValue(Property.LANG_SEQGEN_CACHE_SIZE, value,
 									   0, Integer.MAX_VALUE, Property.LANG_SEQGEN_CACHE_SIZE_DEFAULT);
 
-		value = startParams.getProperty(Property.LANG_IDGEN_CACHE_SIZE);
-		idgenCacheSize = PropertyUtil.intPropertyValue(Property.LANG_IDGEN_CACHE_SIZE, value,
-									   0, Integer.MAX_VALUE, Property.LANG_IDGEN_CACHE_SIZE_DEFAULT);
-
 		value = startParams.getProperty(Property.LANG_PERMISSIONS_CACHE_SIZE);
 		permissionsCacheSize = PropertyUtil.intPropertyValue(Property.LANG_PERMISSIONS_CACHE_SIZE, value,
 									   0, Integer.MAX_VALUE, Property.LANG_PERMISSIONS_CACHE_SIZE_DEFAULT);
@@ -706,9 +700,6 @@ public void boot(boolean create, Properties startParams)
 		sequenceGeneratorCache = cf.newCacheManager
             ( this, "SequenceGeneratorCache", seqgenCacheSize, seqgenCacheSize );
 
-		idGeneratorCache = cf.newCacheManager
-            ( this, "IdentityGeneratorCache", idgenCacheSize, idgenCacheSize );
-
 		/* Get the object to coordinate cache transitions */
 		cacheCoordinator = new ShExLockable();
 
@@ -1007,7 +998,6 @@ public Cacheable newCacheable(CacheManager cm) {
 		else if ( cm == nameTdCache ) { return new NameTDCacheable( this ); }
         else if ( cm == permissionsCache ) { return new PermissionsCacheable( this ); }
         else if ( cm == sequenceGeneratorCache ) { return new SequenceUpdater.SyssequenceUpdater( this ); }
-        else if ( cm == idGeneratorCache ) { return new SequenceUpdater.SyscolumnsUpdater( this ); }
 		else { return new SPSNameCacheable( this ); }
 	}
 
@@ -8877,25 +8867,90 @@ private void bootStrapSystemIndexes(
 		return rla;
 	}
     
-	private RowLocation computeIdentityRowLocation(TransactionController tc,
- 													TableDescriptor td)
+
+	/**
+	 * @see DataDictionary#getSetAutoincrementValue
+	 */
+	public NumberDataValue getSetAutoincrementValue(
+											RowLocation rl, 
+											TransactionController tc,
+											boolean doUpdate,
+											NumberDataValue newValue,
+											boolean wait)
  				throws StandardException
  	{
- 		int size;
-		if (!(td.tableHasAutoincrement())) { return null; }
  
- 		size = td.getNumberOfColumns();
+		FormatableBitSet columnToUpdate = new 
+  			FormatableBitSet(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMN_COUNT);
+  		int columnNum = SYSCOLUMNSRowFactory.SYSCOLUMNS_AUTOINCREMENTVALUE;
+		TabInfoImpl ti = coreInfo[SYSCOLUMNS_CORE_NUM];
+  		ConglomerateController heapCC = null;
+		SYSCOLUMNSRowFactory	rf = (SYSCOLUMNSRowFactory) ti.getCatalogRowFactory();
+		ExecRow row = rf.makeEmptyRow();
  
- 		for (int i = 0; i < size; i++)
+  		FormatableBitSet  columnToRead = new
+  			FormatableBitSet(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMN_COUNT);
+		
+		// FormatableBitSet is 0 based.
+  		columnToRead.set(columnNum - 1); // current value.
+		columnToRead.set(columnNum);     // start value.
+		columnToRead.set(columnNum + 1); // increment value.
+
+        try
  		{
- 			ColumnDescriptor cd = td.getColumnDescriptor(i + 1);
- 			if (cd.isAutoincrement())
+			/* if wait is true then we need to do a wait while trying to
+			   open/fetch from the conglomerate. note we use wait both to
+			   open as well as fetch from the conglomerate.
+			*/
+            heapCC = 
+                tc.openConglomerate(
+                    ti.getHeapConglomerate(), 
+                    false,
+                    (TransactionController.OPENMODE_FORUPDATE |
+                     ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
+                    TransactionController.MODE_RECORD,
+                    TransactionController.ISOLATION_REPEATABLE_READ);
+
+            boolean baseRowExists = 
+                heapCC.fetch(rl, row.getRowArray(), columnToRead, wait);
+
+            columnToUpdate.set(columnNum - 1); // current value.
+
+            // while the Row interface is 1 based.
+            NumberDataValue currentAI = (NumberDataValue)row.getColumn(columnNum);
+            long currentAIValue = currentAI.getLong();
+            
+            if (doUpdate)
             {
-				return computeRowLocation(tc, td, cd.getColumnName());
+                // we increment and store the new value in SYSCOLUMNS
+                NumberDataValue increment = (NumberDataValue)row.getColumn(columnNum + 2);
+                currentAI = currentAI.plus(currentAI, increment, currentAI);
+                row.setColumn(columnNum, currentAI);
+                heapCC.replace(rl, row.getRowArray(), columnToUpdate);
             }
+                
+            // but we return the "currentAIValue"-- i.e the value before
+            // incrementing it. 
+            if (newValue != null)
+            {
+                // user has passed in an object; set the current value in there and
+                // return it.
+                newValue.setValue(currentAIValue);
+                return newValue;
  		}
         
-		return null;
+            else
+            {
+                // reuse the object read from row.
+                currentAI.setValue(currentAIValue);
+                return currentAI;
+            }
+        }
+        finally
+        {
+            if (heapCC != null)
+                heapCC.close();
+        }
  	}
 
 	private	ConglomerateDescriptor	bootstrapOneIndex
@@ -9063,12 +9118,9 @@ public void clearCaches() throws StandardException
 	{
 		nameTdCache.cleanAll();
 		nameTdCache.ageOut();
-
 		OIDTdCache.cleanAll();
 		OIDTdCache.ageOut();
-
         clearSequenceCaches();
-
 		if (spsNameCache != null)
 		{
 			//System.out.println("CLEARING SPS CACHE");
@@ -9086,9 +9138,6 @@ public void    clearSequenceCaches() throws StandardException
     {
 		sequenceGeneratorCache.cleanAll();
 		sequenceGeneratorCache.ageOut();
-
-		idGeneratorCache.cleanAll();
-		idGeneratorCache.ageOut();
     }
     
 
@@ -10213,8 +10262,7 @@ private static String twoDigits(int val) {
 
 	/**
 	 * sets a new value in SYSCOLUMNS for a particular
-	 * autoincrement column. this throws away the sequence generator for the
-     * value so that it must be created from scratch.
+	 * autoincrement column.
 	 * 
 	 * @param tc		 Transaction Controller to use.
 	 * @param columnName Name of the column.
@@ -10264,24 +10312,10 @@ public void setAutoincrementValue(TransactionController tc,
 					 bArray, 
 					 colsToUpdate,
 					 tc);
-
-        // remove the generator for this identity column so that it will be reinitialized with the new value.
-        flushIdentityFromCache( tableUUID );
-        
 		return;
 	}
 
     /**
-     * Remove an id generator from the cache so that it will have to be recreated.
-     * This method is called after changing the generator on disk.
-     */
-    private void    flushIdentityFromCache( UUID tableID ) throws StandardException
-    {
-        Cacheable   idGenerator = idGeneratorCache.findCached( tableID.toString() );
-        if ( idGenerator != null ) { idGeneratorCache.remove( idGenerator ); }
-    }
-
-	/**
 	 * Computes the RowLocation in SYSCOLUMNS for a particular 
 	 * autoincrement column.
 	 * 
@@ -10308,108 +10342,6 @@ private RowLocation computeRowLocation(TransactionController tc,
 								 SYSCOLUMNSRowFactory.SYSCOLUMNS_INDEX1_ID);
 	}
 
-	/**
-	 * Computes the RowLocation in SYSCOLUMNS for the identity column of a table. Also
-     * constructs a sequence descriptor describing the current state of the identity sequence.
-	 * 
-	 * @param tc			Transaction Controller to use.
-	 * @param tableIDstring UUID of the table as a string
-	 * @param rowLocation OUTPUT param for returing the row location
-	 * @param sequenceDescriptor OUTPUT param for return the sequence descriptor
-     *
-	 * @exception StandardException thrown on failure.
-	 */ 
-	void computeIdentityRowLocation
-        ( TransactionController tc, String tableIDstring, RowLocation[] rowLocation, SequenceDescriptor[] sequenceDescriptor )
-		throws StandardException								  
-	{
-        UUID    tableID = getUUIDFactory().recreateUUID( tableIDstring );
-        TableDescriptor td = getTableDescriptor( tableID );
-
-        // there should only be 1 identity column per table
-        rowLocation[ 0 ] = computeIdentityRowLocation( tc, td );
-
-		TabInfoImpl ti = coreInfo[SYSCOLUMNS_CORE_NUM];
-  		ConglomerateController heapCC = null;
-		SYSCOLUMNSRowFactory	rf = (SYSCOLUMNSRowFactory) ti.getCatalogRowFactory();
-		ExecRow row = rf.makeEmptyRow();
-		FormatableBitSet columnsToFetch = new FormatableBitSet( SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMN_COUNT );
-
-        for ( int i = 0; i < SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMN_COUNT; i++ )
-        {
-            columnsToFetch.set( i );
-        }
-
-        try
-        {
-            heapCC = 
-                tc.openConglomerate(
-                    ti.getHeapConglomerate(), 
-                    false,
-                    0,
-                    TransactionController.MODE_RECORD,
-                    TransactionController.ISOLATION_REPEATABLE_READ);
-
-            heapCC.fetch( rowLocation[ 0 ], row.getRowArray(), columnsToFetch, true );
-
-            ColumnDescriptor    cd = (ColumnDescriptor) rf.buildDescriptor( row, td, this );
-            DataTypeDescriptor  dtd = cd.getType();
-            Long[]  minMax = SequenceDescriptor.computeMinMax( dtd, null, null );
-
-            sequenceDescriptor[ 0 ] = getDataDescriptorGenerator().newSequenceDescriptor
-                (
-                 td.getSchemaDescriptor(),
-                 td.getUUID(),
-                 td.getName(),
-                 dtd,
-                 new Long( cd.getAutoincValue() ),
-                 cd.getAutoincStart(),
-                 minMax[ SequenceDescriptor.MIN_VALUE ].longValue(),
-                 minMax[ SequenceDescriptor.MAX_VALUE ].longValue(),
-                 cd.getAutoincInc(),
-                 false
-                 );
-        }
-        finally
-        {
-            if (heapCC != null) { heapCC.close(); }
-        }
-	}
-
-	/**
-	 * Set the current value of an identity sequence. This method does not perform
-     * any sanity checking but assumes that the caller knows what they are doing. If the
-     * old value on disk is not what we expect it to be, then we are in a race with another
-     * session. They won and we don't update the value on disk. However, if the old value
-     * is null, that is a signal to us that we should update the value on disk anyway.
-	 * 
-	 * @param tc			Transaction Controller to use.
-	 * @param rowLocation Row in SYSCOLUMNS to update.
-     * @param wait True if we should wait for locks
-     * @param oldValue What we expect to find in the AUTOINCREMENTVALUE column.
-     * @param newValue What to stuff into the AUTOINCREMENTVALUE column.
-	 * 
-	 * @return Returns true if the value was successfully updated, false if we lost a race with another session.
-     *
-	 * @exception StandardException thrown on failure.
-	 */
-    boolean updateCurrentIdentityValue
-        ( TransactionController tc, RowLocation rowLocation, boolean wait, Long oldValue, Long newValue )
-        throws StandardException
-    {
-        return updateCurrentSeqValue
-            (
-             tc,
-             rowLocation,
-             wait,
-             oldValue,
-             newValue,
-             coreInfo[SYSCOLUMNS_CORE_NUM],
-             SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMN_COUNT,
-             SYSCOLUMNSRowFactory.SYSCOLUMNS_AUTOINCREMENTVALUE
-             );
-    }
-    
 	/**
 	 * Computes the RowLocation in SYSSEQUENCES for a particular sequence. Also
      * constructs the sequence descriptor.
@@ -10468,55 +10400,11 @@ private RowLocation computeRowLocation(TransactionController tc,
         ( TransactionController tc, RowLocation rowLocation, boolean wait, Long oldValue, Long newValue )
         throws StandardException
     {
-        return updateCurrentSeqValue
-            (
-             tc,
-             rowLocation,
-             wait,
-             oldValue,
-             newValue,
-             getNonCoreTI( SYSSEQUENCES_CATALOG_NUM ),
-             SYSSEQUENCESRowFactory.SYSSEQUENCES_COLUMN_COUNT,
-             SYSSEQUENCESRowFactory.SYSSEQUENCES_CURRENT_VALUE
-             );
-    }
-    
-	/**
-	 * Set the current value of an ANSI/ISO sequence or identity column. This method does not perform
-     * any sanity checking but assumes that the caller knows what they are doing. If the
-     * old value on disk is not what we expect it to be, then we are in a race with another
-     * session. They won and we don't update the value on disk. However, if the old value
-     * is null, that is a signal to us that we should update the value on disk anyway.
-	 * 
-	 * @param tc			Transaction Controller to use.
-	 * @param rowLocation Row in SYSSEQUENCES or SYSCOLUMNS to update.
-     * @param wait True if we should wait for locks
-     * @param oldValue What we expect to find in the currentvalue column.
-     * @param newValue What to stuff into the current value column.
-     * @param ti Table info for the catalog that is being updated.
-     * @param columnsInRow Number of columns in the catalog row.
-     * @param columnNum ID of the current value column
-	 * 
-	 * @return Returns true if the value was successfully updated, false if we lost a race with another session.
-     *
-	 * @exception StandardException thrown on failure.
-	 */
-    private boolean updateCurrentSeqValue
-        (
-         TransactionController tc,
-         RowLocation rowLocation,
-         boolean wait,
-         Long oldValue,
-         Long newValue,
-         TabInfoImpl    ti,
-         int    columnsInRow,
-         int    columnNum
-         )
-        throws StandardException
-    {
-		FormatableBitSet columnToUpdate = new FormatableBitSet( columnsInRow );
+  		int columnNum = SYSSEQUENCESRowFactory.SYSSEQUENCES_CURRENT_VALUE;
+		FormatableBitSet columnToUpdate = new FormatableBitSet( SYSSEQUENCESRowFactory.SYSSEQUENCES_COLUMN_COUNT );
+		TabInfoImpl ti = getNonCoreTI( SYSSEQUENCES_CATALOG_NUM );
   		ConglomerateController heapCC = null;
-		CatalogRowFactory	rf = ti.getCatalogRowFactory();
+		SYSSEQUENCESRowFactory	rf = (SYSSEQUENCESRowFactory) ti.getCatalogRowFactory();
 		ExecRow row = rf.makeEmptyRow();
         
 		// FormatableBitSet is 0 based.
@@ -10572,28 +10460,13 @@ private RowLocation computeRowLocation(TransactionController tc,
 	 * @see org.apache.derby.iapi.sql.dictionary.DataDictionary#getCurrentValueAndAdvance
 	 */
     public void getCurrentValueAndAdvance
-        ( int catalogNumber, String uuidString, NumberDataValue returnValue )
+        ( String sequenceUUIDstring, NumberDataValue returnValue )
         throws StandardException
     {
-        CacheManager    cm = null;
         SequenceUpdater sequenceUpdater = null;
 
         try {
-            switch( catalogNumber )
-            {
-            case SYSSEQUENCES_CATALOG_NUM:
-                cm = sequenceGeneratorCache;
-                break;
-
-            case SYSCOLUMNS_CATALOG_NUM:
-                cm = idGeneratorCache;
-                break;
-
-            default:
-                throw StandardException.newException( SQLState.BTREE_UNIMPLEMENTED_FEATURE );
-            }
-
-            sequenceUpdater = (SequenceUpdater) cm.find( uuidString );
+            sequenceUpdater = (SequenceUpdater) sequenceGeneratorCache.find( sequenceUUIDstring );
 
             sequenceUpdater.getCurrentValueAndAdvance( returnValue );
         }
@@ -10601,7 +10474,7 @@ private RowLocation computeRowLocation(TransactionController tc,
         {
             if ( sequenceUpdater != null )
             {
-                cm.release( sequenceUpdater );
+                sequenceGeneratorCache.release( sequenceUpdater );
             }
         }
     }
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java
index 38dbabe0..c0ccd41c 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java
@@ -555,70 +555,10 @@ private StandardException unimplementedFeature()
 
     ///////////////////////////////////////////////////////////////////////////////////
     //
-    // NESTED CLASSES
+    // INNER CLASSES
     //
     ///////////////////////////////////////////////////////////////////////////////////
 
-    /**
-     * <p>
-     * Specific implementation of SequenceUpdater for the sequences managed by
-     * SYSCOLUMNS.
-     * </p>
-     */
-    public static final class SyscolumnsUpdater extends SequenceUpdater
-    {
-        private RowLocation _sequenceRowLocation;
-
-        public SyscolumnsUpdater() { super(); }
-        public SyscolumnsUpdater( DataDictionaryImpl dd ) { super( dd ); }
-    
-        //
-        // SequenceUpdater BEHAVIOR
-        //
-
-        protected SequenceGenerator createSequenceGenerator( TransactionController readOnlyTC )
-            throws StandardException
-        {
-            RowLocation[] rowLocation = new RowLocation[ 1 ];
-            SequenceDescriptor[] sequenceDescriptor = new SequenceDescriptor[ 1 ];
-            
-            _dd.computeIdentityRowLocation( readOnlyTC, _uuidString, rowLocation, sequenceDescriptor );
-            
-            _sequenceRowLocation = rowLocation[ 0 ];
-            
-            SequenceDescriptor isd = sequenceDescriptor[ 0 ];
-            
-            return new SequenceGenerator
-                (
-                 isd.getCurrentValue(),
-                 isd.canCycle(),
-                 isd.getIncrement(),
-                 isd.getMaximumValue(),
-                 isd.getMinimumValue(),
-                 isd.getStartValue(),
-                 isd.getSchemaDescriptor().getSchemaName(),
-                 isd.getSequenceName(),
-                 makePreallocator( readOnlyTC )
-                 );
-        }
-
-        protected boolean updateCurrentValueOnDisk( TransactionController tc, Long oldValue, Long newValue, boolean wait ) throws StandardException
-        {
-            return _dd.updateCurrentIdentityValue( tc, _sequenceRowLocation, wait, oldValue, newValue );
-        }
-
-        /**
-         * Wrap the "too much contention" exception in a "lock timeout" exception in
-         * order to preserve the old error behavior of identity columns. See DERBY-5426.
-         */
-        protected   StandardException   tooMuchContentionException()
-        {
-            StandardException   tooMuchContention = super.tooMuchContentionException();
-
-            return StandardException.newException( SQLState.LOCK_TIMEOUT, tooMuchContention );
-        }
-    }
-
     /**
      * <p>
      * Specific implementation of SequenceUpdater for the sequences managed by
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CreateSequenceNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CreateSequenceNode.java
index d9147ccb..752a650d 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CreateSequenceNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CreateSequenceNode.java
@@ -26,7 +26,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.sql.compile.CompilerContext;
 import org.apache.derby.iapi.sql.execute.ConstantAction;
 import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
-import org.apache.derby.iapi.sql.dictionary.SequenceDescriptor;
 import org.apache.derby.iapi.types.DataTypeDescriptor;
 import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.types.TypeId;
@@ -84,9 +83,17 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
         _stepValue = (stepValue != null ? (Long) stepValue : new Long(1));
 
-        Long[]  minMax = SequenceDescriptor.computeMinMax( _dataType, minValue, maxValue );
-        _minValue = minMax[ SequenceDescriptor.MIN_VALUE ];
-        _maxValue = minMax[ SequenceDescriptor.MAX_VALUE ];
+        if (_dataType.getTypeId().equals(TypeId.SMALLINT_ID)) {
+            _minValue = (minValue != null ? (Long) minValue : new Long(Short.MIN_VALUE));
+            _maxValue = (maxValue != null ? (Long) maxValue : new Long(Short.MAX_VALUE));
+        } else if (_dataType.getTypeId().equals(TypeId.INTEGER_ID)) {
+            _minValue = (minValue != null ? (Long) minValue : new Long(Integer.MIN_VALUE));
+            _maxValue = (maxValue != null ? (Long) maxValue : new Long(Integer.MAX_VALUE));
+        } else {
+            // Could only be BIGINT
+            _minValue = (minValue != null ? (Long) minValue : new Long(Long.MIN_VALUE));
+            _maxValue = (maxValue != null ? (Long) maxValue : new Long(Long.MAX_VALUE));
+        }
 
         if (initialValue != null) {
             _initialValue = (Long) initialValue;
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NextSequenceNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NextSequenceNode.java
index 95471368..b1deccbb 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NextSequenceNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NextSequenceNode.java
@@ -28,7 +28,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.services.compiler.LocalField;
 import org.apache.derby.iapi.sql.compile.CompilerContext;
 import org.apache.derby.iapi.services.classfile.VMOpcode;
-import org.apache.derby.iapi.sql.dictionary.DataDictionary;
 import org.apache.derby.iapi.sql.dictionary.SequenceDescriptor;
 import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
 
@@ -134,7 +133,6 @@ public ValueNode bindExpression(
         int dataTypeFormatID = sequenceDescriptor.getDataType().getNull().getTypeFormatId();
         
 		mb.pushThis();
-		mb.push( DataDictionary.SYSSEQUENCES_CATALOG_NUM );
 		mb.push( sequenceUUIDstring );
 		mb.push( dataTypeFormatID );
 		mb.callMethod
@@ -143,7 +141,7 @@ public ValueNode bindExpression(
              ClassName.BaseActivation,
              "getCurrentValueAndAdvance",
              ClassName.NumberDataValue,
-             3
+             2
              );
     }
 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/BaseActivation.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/BaseActivation.java
index 7cd38800..a9996c29 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/BaseActivation.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/BaseActivation.java
@@ -670,23 +670,22 @@ public CursorResultSet getTargetResultSet() {
 	}
 
 	/**
-	 * Called by generated code to get the next number in an identity or sequence generator
-     * and advance the generator. Raises an exception if the generator was declared
+	 * Called by generated code to get the next number in an ANSI/ISO sequence
+     * and advance the sequence. Raises an exception if the sequence was declared
      * NO CYCLE and its range is exhausted.
 	 *
-     * @param catalogNumber SYSCOLUMNS_CATALOG_NUM or SYSSEQUENCES_CATALOG_NUM, depending on the kind of generator
-     * @param uuidString The string value of the generator's uuid (table uuid for identity generators and sequence uuid for sequence generators)
+     * @param sequenceUUIDstring The string value of the sequence's UUID
      * @param typeFormatID The format id of the data type to be returned. E.g., StoredFormatIds.SQL_INTEGER_ID.
      *
 	 * @return The next number in the sequence
 	 */
 	protected NumberDataValue getCurrentValueAndAdvance
-        ( int catalogNumber, String uuidString, int typeFormatID )
+        ( String sequenceUUIDstring, int typeFormatID )
 	       throws StandardException
 	{
         NumberDataValue ndv = (NumberDataValue) getDataValueFactory().getNull( typeFormatID, StringDataValue.COLLATION_TYPE_UCS_BASIC );
 
-        lcc.getDataDictionary().getCurrentValueAndAdvance( catalogNumber, uuidString, ndv );
+        lcc.getDataDictionary().getCurrentValueAndAdvance( sequenceUUIDstring, ndv );
 
         return ndv;
 	}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/InsertConstantAction.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/InsertConstantAction.java
index 13834bee..150240cf 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/InsertConstantAction.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/InsertConstantAction.java
@@ -250,6 +250,24 @@ public void writeExternal( ObjectOutput out )
 	 */
 	public long   getAutoincIncrement(int i) { return autoincIncrement[i]; }
 
+	/**
+	 * Does the target table has autoincrement columns.
+	 *
+	 * @return 	True if the table has ai columns
+	 */
+	public boolean hasAutoincrement()
+	{
+		return (autoincRowLocation != null);
+	}
+
+	/**
+	 * gets the row location 
+	 */
+	public RowLocation[] getAutoincRowLocation()
+	{
+		return autoincRowLocation;
+	}
+	
 	/**
 	 * Get the formatID which corresponds to this class.
 	 *
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java
index e6781990..797b1fc2 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java
@@ -350,20 +350,21 @@ private	void	evaluateCheckConstraints()
 		// Is this a bulkInsert or regular insert?
 		String insertMode = constants.getProperty("insertMode");
 
-		if ( hasAutoincrement() )
+                RowLocation[] rla;
+
+		if ((rla = constants.getAutoincRowLocation()) != null)
 		{
-            int cacheLength = resultDescription.getColumnCount();
-			aiCache = new NumberDataValue[ cacheLength ];
-			for (int i = 0; i < cacheLength; i++)
+			aiCache = 
+				new NumberDataValue[rla.length];
+			for (int i = 0; i < resultDescription.getColumnCount(); i++)
 			{
+				if (rla[i] == null)
+					continue;
 				ResultColumnDescriptor rcd = 
 					resultDescription.getColumnDescriptor(i + 1);
-                if ( rcd.getType().getTypeId().isNumericTypeId() )
-                {
                     aiCache[i] = (NumberDataValue)rcd.getType().getNull();
                 }
 			}
-		}
 
 		if (insertMode != null)
 		{
@@ -393,18 +394,6 @@ else if (StringUtil.SQLEqualsIgnoreCase(insertMode,"REPLACE"))
 	}
 
     /**
-     * Return true if the table has an autoincrement column.
-     */
-    private boolean hasAutoincrement()  throws StandardException
-    {
-        // Global temporary tables don't have table descriptors but they
-        // don't have identity columns either
-        TableDescriptor tabdesc = getTableDescriptor();
-        if ( tabdesc == null ) { return false; }
-        else { return tabdesc.tableHasAutoincrement(); }
-    }
-	
-	/**
 		@exception StandardException Standard Derby error policy
 	*/
 	public void open() throws StandardException
@@ -596,28 +585,6 @@ private void verifyAutoGeneratedColumnsIndexes(int[] columnIndexes)
 	}
 
     /**
-     * Get the table descriptor if it hasn't already been looked up.
-     */
-    private TableDescriptor getTableDescriptor()
-        throws StandardException
-    {
-        if ( td == null ) { td = getDataDictionary().getTableDescriptor(constants.targetUUID); }
-
-        return td;
-    }
-    
-    /**
-     * Get the data dictionary if it hasn't already been looked up.
-     */
-    private DataDictionary getDataDictionary()
-        throws StandardException
-    {
-        if ( dd == null ) { dd = lcc.getDataDictionary(); }
-
-        return dd;
-    }
-    
-	/**
 	 * If user didn't provide columns list for auto-generated columns, then only include
 	 * columns with auto-generated values in the resultset. Those columns would be ones
 	 * with default value defined.
@@ -801,9 +768,9 @@ public ResultSet getAutoGeneratedKeysResultset()
 				}
 				else
 				{
-                    dvd = (NumberDataValue) aiCache[ index ].getNewNull();
-                    dd.getCurrentValueAndAdvance
-                        ( DataDictionary.SYSCOLUMNS_CATALOG_NUM, getTableDescriptor().getUUID().toString(), dvd );
+					dvd = dd.getSetAutoincrementValue(
+						    constants.autoincRowLocation[index],
+							tc, false, aiCache[index], true);
 					startValue = dvd.getLong();
 				}
 				lcc.autoincrementCreateCounter(td.getSchemaName(),
@@ -822,12 +789,77 @@ public ResultSet getAutoGeneratedKeysResultset()
 
 		else
 		{
-			NumberDataValue newValue = aiCache[ index ];
+			NumberDataValue newValue;
+			TransactionController nestedTC = null, tcToUse = tc;
 
-            dd.getCurrentValueAndAdvance
-                ( DataDictionary.SYSCOLUMNS_CATALOG_NUM, getTableDescriptor().getUUID().toString(), newValue );
+			try
+			{
+				nestedTC = tc.startNestedUserTransaction(false);
+				tcToUse = nestedTC;
+			}
 
-			if (setIdentity) { identityVal = newValue.getLong(); }
+			catch (StandardException se)
+			{
+				// If I cannot start a Nested User Transaction use the parent
+				// transaction to do all the work.
+				tcToUse = tc;
+			}
+
+			try 
+			{
+				/* If tcToUse == tc, then we are using parent xaction-- this
+				   can happen if for some reason we couldn't start a nested
+				   transaction
+				*/
+				newValue = dd.getSetAutoincrementValue(
+						   constants.autoincRowLocation[index],
+						   tcToUse, true, aiCache[index], (tcToUse == tc));
+			}
+
+			catch (StandardException se)
+			{
+				if (tcToUse == tc)
+				{
+					/* we've using the parent xaction and we've timed out; just
+					   throw an error and exit.
+					*/
+					throw se;
+				}
+
+				if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT))
+				{
+					// if we couldn't do this with a nested xaction, retry with
+					// parent-- we need to wait this time!
+					newValue = dd.getSetAutoincrementValue(
+									constants.autoincRowLocation[index],
+									tc, true, aiCache[index], true);
+				}
+				else if (se.getMessageId().equals(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE))
+				{
+					// if we got an overflow error, throw a more meaningful
+					// error message
+					throw StandardException.newException(
+												 SQLState.LANG_AI_OVERFLOW,
+												 se,
+												 constants.getTableName(),
+												 constants.getColumnName(index));
+				}
+				else throw se;
+			}
+			finally 
+			{
+				// no matter what, commit the nested transaction; if something
+				// bad happened in the child xaction lets not abort the parent
+				// here.
+				if (nestedTC != null)
+				{
+					nestedTC.commit();
+					nestedTC.destroy();
+				}
+			}
+			aiCache[index] = newValue;
+			if (setIdentity)
+				identityVal = newValue.getLong();
 		}
 
 		return aiCache[index];
@@ -860,7 +892,7 @@ else if (sourceResultSet instanceof NormalizeResultSet)
 	private void normalInsertCore(LanguageConnectionContext lcc, boolean firstExecute)
 		throws StandardException
 	{
-		boolean setUserIdentity = hasAutoincrement() && isSingleRowResultSet();
+		boolean setUserIdentity = constants.hasAutoincrement() && isSingleRowResultSet();
 		boolean	firstDeferredRow = true;
 		ExecRow	deferredRowBuffer = null;
                 long user_autoinc=0;
diff --git a/db/derby/code/trunk/java/storeless/org/apache/derby/impl/storeless/EmptyDictionary.java b/db/derby/code/trunk/java/storeless/org/apache/derby/impl/storeless/EmptyDictionary.java
index 54b03b78..f7b7bb31 100644
--- a/db/derby/code/trunk/java/storeless/org/apache/derby/impl/storeless/EmptyDictionary.java
+++ b/db/derby/code/trunk/java/storeless/org/apache/derby/impl/storeless/EmptyDictionary.java
@@ -737,7 +737,7 @@ public void dropFileInfoDescriptor(FileInfoDescriptor fid)
 	}
 
     public void getCurrentValueAndAdvance
-        ( int catalogNumber, String uuidString, NumberDataValue returnValue )
+        ( String sequenceUUIDstring, NumberDataValue returnValue )
         throws StandardException
     {
 		// Auto-generated method stub
@@ -749,6 +749,13 @@ public RowLocation getRowLocationTemplate(LanguageConnectionContext lcc,
 		return null;
 	}
 
+	public NumberDataValue getSetAutoincrementValue(RowLocation rl,
+			TransactionController tc, boolean doUpdate,
+			NumberDataValue newValue, boolean wait) throws StandardException {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
 	public void setAutoincrementValue(TransactionController tc, UUID tableUUID,
 			String columnName, long aiValue, boolean incrementNeeded)
 			throws StandardException {
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AlterTableTest.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AlterTableTest.java
index f0fdab80..e487e229 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AlterTableTest.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AlterTableTest.java
@@ -3257,7 +3257,7 @@ public void testJira3175()
                 "where c.referenceid = t.tableid and t.tablename='D3175'");
         JDBC.assertUnorderedResultSet(rs, new String[][]{
                     {"X", "1", "VARCHAR(12)", null, null, null, null, "D3175", "T", "R"},
-                    {"ID", "2", "INTEGER NOT NULL", "GENERATED_BY_DEFAULT", "22", "1", "1", "D3175", "T", "R"}
+                    {"ID", "2", "INTEGER NOT NULL", "GENERATED_BY_DEFAULT", "3", "1", "1", "D3175", "T", "R"}
                 });
     }
 
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AutoIncrementTest.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AutoIncrementTest.java
index a70b1558..617960b9 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AutoIncrementTest.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AutoIncrementTest.java
@@ -33,13 +33,8 @@
 import org.apache.derbyTesting.junit.BaseJDBCTestCase;
 import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
 import org.apache.derbyTesting.junit.JDBC;
-import org.apache.derbyTesting.junit.SupportFilesSetup;
 
 public class AutoIncrementTest extends BaseJDBCTestCase {
-
-    private static  final   String  SEQUENCE_OVERFLOW = "2200H";
-    private static  final   String  IMPORT_FILE_NAME = "t_4437_2.dat";
-    
 	public AutoIncrementTest(String name)
 	{
 		super (name);
@@ -226,7 +221,7 @@ public void testsimpleincrement() throws Exception
 		String[][]expectedRows=new String[][]{{"0","0"},{"1","2"},{"2","4"},{"33","6"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 		rs = s.executeQuery("select COLUMNNAME, AUTOINCREMENTVALUE, AUTOINCREMENTSTART, AUTOINCREMENTINC from sys.syscolumns where COLUMNNAME = 'AIS'");
-		expectedRows=new String[][]{{"AIS","40","0","2"}};
+		expectedRows=new String[][]{{"AIS","8","0","2"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 
 	}
@@ -383,7 +378,7 @@ public void testSchema() throws Exception
 		expectedRows=new String[][]{{"1","1"},{"2","2"},{"3","3"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 		rs=s.executeQuery("select b.tablename, a.autoincrementvalue, a.autoincrementstart, a.autoincrementinc from sys.syscolumns a, sys.systables b where a.referenceid=b.tableid and a.columnname ='S1' and b.tablename = 'TAB1'");
-		expectedRows=new String[][]{{"TAB1","21","1","1"}};
+		expectedRows=new String[][]{{"TAB1","4","1","1"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 		s.executeUpdate("create table tab2 (lvl int, s1  bigint generated always as identity)");
 		s.executeUpdate("create trigger tab1_after2 after insert on tab3 referencing new as newrow for each row insert into tab2 (lvl) values 1,2,3");
@@ -495,7 +490,7 @@ public void testsyslocks()throws Exception
 		JDBC.assertFullResultSet(rs,expectedRows);
 		s.execute("insert into lockt1 (x) values (3)");
 		rs=s.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt");
-		expectedRows=new String[][]{{"APP     ","UserTran","TABLE   ","1  ","IX","LOCKT1      ","GRANT","ACTIVE"},{"APP     ","UserTran","ROW     ","1  ","X","LOCKT1      ","GRANT","ACTIVE"},{"APP     ","UserTran","TABLE   ","1  ","S","SYSCOLUMNS  ","GRANT","ACTIVE"}};
+		expectedRows=new String[][]{{"APP     ","UserTran","TABLE   ","1  ","IX","LOCKT1      ","GRANT","ACTIVE"},{"APP     ","UserTran","ROW     ","1  ","X","LOCKT1      ","GRANT","ACTIVE"},{"APP     ","UserTran","TABLE   ","1  ","IX","SYSCOLUMNS  ","GRANT","ACTIVE"},{"APP     ","UserTran","TABLE   ","1  ","S","SYSCOLUMNS  ","GRANT","ACTIVE"},{"APP     ","UserTran","ROW     ","2  ","X","SYSCOLUMNS  ","GRANT","ACTIVE"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 		commit();
 		
@@ -601,10 +596,10 @@ public  void testOverflow()throws Exception
 		ResultSet rs;
 		Statement pst=createStatement();
 		Statement s=createStatement();
-		assertStatementError(SEQUENCE_OVERFLOW, pst,"insert into ai_over1 (x) values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15),(16),(17),(18),(19)");
-		assertStatementError(SEQUENCE_OVERFLOW, pst,"insert into ai_over1 (x) values (1)");		
+		assertStatementError("22003", pst,"insert into ai_over1 (x) values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15),(16),(17),(18),(19)");
+		assertStatementError("22003", pst,"insert into ai_over1 (x) values (1)");		
 		s.executeUpdate("insert into ai_over2 (x) values (1),(2),(3),(4),(5),(6),(7),(8)");
-		assertStatementError(SEQUENCE_OVERFLOW, pst,"insert into ai_over2 (x) values (9),(10)");
+		assertStatementError("22003", pst,"insert into ai_over2 (x) values (9),(10)");
 		String[][]expectedRows=new String[][]{{"1","-32760"},{"2","-32761"},{"3","-32762"},{"4","-32763"},{"5","-32764"},{"6","-32765"},{"7","-32766"},{"8","-32767"}};
 		rs=s.executeQuery("select * from ai_over2");
 		JDBC.assertFullResultSet(rs,expectedRows);		
@@ -613,12 +608,12 @@ public  void testOverflow()throws Exception
 		rs=s.executeQuery("select * from ai_over3");
 		expectedRows=new String[][]{{"1","2147483646"},{"2","2147483647"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
-		assertStatementError(SEQUENCE_OVERFLOW, pst,"insert into ai_over3 (x) select x from ai_over3");			
+		assertStatementError("22003", pst,"insert into ai_over3 (x) select x from ai_over3");			
 		//bigint overflow check		
-		s.executeUpdate("insert into ai_over4 (x) values (1),(2),(3)");
-		assertStatementError(SEQUENCE_OVERFLOW, pst,"insert into ai_over4 (x) values (4)");
+		s.executeUpdate("insert into ai_over4 (x) values (1),(2)");
+		assertStatementError("22003", pst,"insert into ai_over4 (x) values (3)");
 		rs=s.executeQuery("select * from ai_over4");
-		expectedRows=new String[][]{{"1","9223372036854775805"},{"2","9223372036854775806"},{"3","9223372036854775807"}};
+		expectedRows=new String[][]{{"1","9223372036854775805"},{"2","9223372036854775806"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 
 	}
@@ -944,7 +939,7 @@ public void testrestart()throws Exception
 		expectedRows=new String[][]{{"2","2"},{"2","9999"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 		rs=s.executeQuery("select COLUMNNAME, AUTOINCREMENTVALUE, AUTOINCREMENTSTART, AUTOINCREMENTINC from sys.syscolumns where COLUMNNAME = 'REC11'");
-		expectedRows=new String[][]{{"REC11","42","2","2"}};
+		expectedRows=new String[][]{{"REC11","4","2","2"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 		assertStatementError("42837",s,"alter table restartt1 alter column c12 RESTART WITH 2");
 		assertStatementError("42X49",s,"alter table restartt1 alter column rec11 RESTART WITH 2.20");
@@ -979,7 +974,7 @@ public void testlock()throws Exception
 		assertStatementError("23505",s,"insert into t1lock(c12) values(3)");
 		rs=s.executeQuery("select COLUMNNAME, AUTOINCREMENTVALUE, AUTOINCREMENTSTART, AUTOINCREMENTINC from sys.syscolumns where COLUMNNAME = 'LOCKC11'");
 		//Utilities.showResultSet(rs);
-		expectedRows=new String[][]{{"LOCKC11","21","1","1"}};
+		expectedRows=new String[][]{{"LOCKC11","2","1","1"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 
 		rs=s.executeQuery("select * from t1lock");
@@ -1087,226 +1082,8 @@ public void testDerby2902()throws Exception
 
 	}
 
-    /**
-     * <p>
-     * Test that alter table interacts well with the sequence-generator-based identity generators.
-     * </p>
-     */
-    public  void    test_4437_01_alterTable()   throws Exception
-    {
-		Statement s = createStatement();
-        String[][] expectedResults;
-        
-		s.execute("create table t_4437_1( a int, b int generated always as identity )");
-		s.execute("insert into t_4437_1( a ) values (100), (101), (102), (103), (104), (105)");
-        expectedResults = new String[][]
-        {
-            { "100",        "1", },
-            { "101",        "2", },
-            { "102",        "3", },
-            { "103",        "4", },
-            { "104",        "5", },
-            { "105",        "6", },
-        };
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_1 order by a" ), expectedResults );
-
-		s.execute("alter table t_4437_1 alter column b restart with 22");
-		s.execute("insert into t_4437_1( a ) values (110), (111), (112), (113), (114), (115)");
-        expectedResults = addResults
-            (
-             expectedResults,
-             new String[][]
-             {
-                 { "110",        "22", },
-                 { "111",        "23", },
-                 { "112",        "24", },
-                 { "113",        "25", },
-                 { "114",        "26", },
-                 { "115",        "27", },
-             }
-             );
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_1 order by a" ), expectedResults );
-
-		s.execute("alter table t_4437_1 alter column b set increment by 3");
-		s.execute("insert into t_4437_1( a ) values (120), (121), (122), (123), (124)");
-        expectedResults = addResults
-            (
-             expectedResults,
-             new String[][]
-             {
-                 { "120",        "30", },
-                 { "121",        "33", },
-                 { "122",        "36", },
-                 { "123",        "39", },
-                 { "124",        "42", },
-             }
-             );
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_1 order by a" ), expectedResults );
-
-		s.execute("alter table t_4437_1 alter column b set increment by 4");
-		s.execute("insert into t_4437_1( a ) values (130), (131), (132), (133), (134), (135)");
-        expectedResults = addResults
-            (
-             expectedResults,
-             new String[][]
-             {
-                 { "130",        "46", },
-                 { "131",        "50", },
-                 { "132",        "54", },
-                 { "133",        "58", },
-                 { "134",        "62", },
-                 { "135",        "66", },
-             }
-             );
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_1 order by a" ), expectedResults );
-
-        s.execute( "drop table t_4437_1" );
-    }
-    private String[][]  addResults( String[][] original, String[][] extras )
-    {
-        int originalLength = original.length;
-        int extrasLength = extras.length;
-        String[][]  result = new String[ originalLength + extrasLength ][];
-
-        int idx = 0;
-        for ( int i = 0; i < originalLength; i++ ) { result[ idx++ ] = original[ i ]; }
-        for ( int i = 0; i < extrasLength; i++ ) { result[ idx++ ] = extras[ i ]; }
-
-        return result;
-    }
-	
-    /**
-     * <p>
-     * Test that bulk import interacts well with the sequence-generator-based identity generators.
-     * </p>
-     */
-    public  void    test_4437_02_bulkImport()   throws Exception
-    {
-		Statement s = createStatement();
-        String[][] expectedResults;
-
-		s.execute( "create table t_4437_2( a int, b int generated always as identity (start with -10, increment by -3) )" );
-		s.execute( "insert into t_4437_2( a ) values (110), (111), (112), (113), (114), (115)" );
-        expectedResults = new String[][]
-        {
-            { "110",        "-10", },
-            { "111",        "-13", },
-            { "112",        "-16", },
-            { "113",        "-19", },
-            { "114",        "-22", },
-            { "115",        "-25", },
-        };
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_2 order by a" ), expectedResults );
-
-        // import running in replace mode resets the sequence counter
-		s.execute( "call syscs_util.syscs_import_data( null, 'T_4437_2', 'A', null, 'extin/" + IMPORT_FILE_NAME + "', null, null, null, 1 )" );
-        expectedResults = new String[][]
-        {
-            { "100",        "-10", },
-            { "101",        "-13", },
-            { "102",        "-16", },
-            { "103",        "-19", },
-            { "104",        "-22", },
-            { "105",        "-25", },
-        };
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_2 order by a" ), expectedResults );
-
-        // truncate does not reset the counter
-		s.execute( "truncate table t_4437_2" );
-		s.execute( "insert into t_4437_2( a ) values (110), (111), (112), (113), (114), (115)" );
-        expectedResults = new String[][]
-        {
-            { "110",        "-28", },
-            { "111",        "-31", },
-            { "112",        "-34", },
-            { "113",        "-37", },
-            { "114",        "-40", },
-            { "115",        "-43", },
-        };
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_2 order by a" ), expectedResults );
-
-        // delete does not reset the counter either
-		s.execute( "delete from t_4437_2" );
-		s.execute( "insert into t_4437_2( a ) values (110), (111), (112), (113), (114), (115)" );
-        expectedResults = new String[][]
-        {
-            { "110",        "-46", },
-            { "111",        "-49", },
-            { "112",        "-52", },
-            { "113",        "-55", },
-            { "114",        "-58", },
-            { "115",        "-61", },
-        };
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_2 order by a" ), expectedResults );
-
-        // import running in insert mode does not reset the sequence counter
-		s.execute( "call syscs_util.syscs_import_data( null, 'T_4437_2', 'A', null, 'extin/" + IMPORT_FILE_NAME + "', null, null, null, 0 )" );
-        expectedResults = new String[][]
-        {
-            { "100",        "-64", },
-            { "101",        "-67", },
-            { "102",        "-70", },
-            { "103",        "-73", },
-            { "104",        "-76", },
-            { "105",        "-79", },
-            { "110",        "-46", },
-            { "111",        "-49", },
-            { "112",        "-52", },
-            { "113",        "-55", },
-            { "114",        "-58", },
-            { "115",        "-61", },
-        };
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_2 order by a" ), expectedResults );
-
-        s.execute( "drop table t_4437_2" );
-    }
-        
-    /**
-     * <p>
-     * Test that deferred inserts work well with the sequence-generator-based identity generators.
-     * </p>
-     */
-    public  void    test_4437_03_deferredInsert()   throws Exception
-    {
-		Statement s = createStatement();
-        String[][] expectedResults;
-
-		s.execute( "create table t_4437_3( a int, b smallint generated always as identity (start with 9990, increment by -10) )" );
-		s.execute( "insert into t_4437_3( a ) values (100), (101), (102), (103), (104), (105)" );
-        expectedResults = new String[][]
-        {
-            { "100",        "9990", },
-            { "101",        "9980", },
-            { "102",        "9970", },
-            { "103",        "9960", },
-            { "104",        "9950", },
-            { "105",        "9940", },
-        };
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_3 order by a" ), expectedResults );
-
-        // deferred inserts should continue the sequence where it left off
-		s.execute( "insert into t_4437_3( a ) select a + 10 from ( select a from t_4437_3 order by a ) s" );
-        expectedResults = addResults
-            (
-             expectedResults,
-             new String[][]
-             {
-                 { "110",        "9930", },
-                 { "111",        "9920", },
-                 { "112",        "9910", },
-                 { "113",        "9900", },
-                 { "114",        "9890", },
-                 { "115",        "9880", },
-             }
-             );
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_3 order by a" ), expectedResults );
-
-        s.execute( "drop table t_4437_3" );
-    }
-
-	public static Test suite()
-    {
-		Test    cleanDatabaseSuite = new CleanDatabaseTestSetup(
+	public static Test suite() {
+		return new CleanDatabaseTestSetup(
 				new TestSuite(AutoIncrementTest.class, "AutoIncrementTest")) {
 			protected void decorateSQL(Statement s)
 			throws SQLException
@@ -1314,16 +1091,5 @@ protected void decorateSQL(Statement s)
 				createSchemaObjects(s);
 			}
 		};
-        
-        //
-        // Copies the data file to a location which can be read.
-        //
-        Test        result = new SupportFilesSetup
-            (
-             cleanDatabaseSuite,
-             new String [] { "functionTests/tests/lang/" + IMPORT_FILE_NAME }
-             );
-
-        return result;
 	}
 }
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_9.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_9.java
index 23139a37..4b023a5a 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_9.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_9.java
@@ -110,74 +110,6 @@ public static Test suite(int phase) {
     //
     ///////////////////////////////////////////////////////////////////////////////////
 
-    /**
-     * Make sure that generator-based identity columns don't break upgrade/downgrade.
-     */
-    public void testIdentity() throws Exception
-    {
-        Statement s = createStatement();
-
-        switch ( getPhase() )
-        {
-        case PH_CREATE: // create with old version
-            s.execute( "create table t_identity1( a int, b int generated always as identity )" );
-            s.execute( "insert into t_identity1( a ) values ( 100 )" );
-            vetIdentityValues( s, "t_identity1", 1 );
-            break;
-            
-        case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
-            s.execute( "insert into t_identity1( a ) values ( 200 )" );
-            vetIdentityValues( s, "t_identity1", 2 );
-
-            s.execute( "create table t_identity2( a int, b int generated always as identity )" );
-            s.execute( "insert into t_identity2( a ) values ( 100 )" );
-            vetIdentityValues( s, "t_identity2", 1 );
-
-            break;
-            
-        case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
-            s.execute( "insert into t_identity1( a ) values ( 300 )" );
-            vetIdentityValues( s, "t_identity1", 3 );
-
-            s.execute( "insert into t_identity2( a ) values ( 200 )" );
-            vetIdentityValues( s, "t_identity2", 2 );
-
-            break;
-
-        case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
-            s.execute( "insert into t_identity1( a ) values ( 400 )" );
-            vetIdentityValues( s, "t_identity1", 4 );
-
-            s.execute( "insert into t_identity2( a ) values ( 300 )" );
-            vetIdentityValues( s, "t_identity2", 3 );
-
-            break;
-        }
-        
-        s.close();
-    }
-    private void    vetIdentityValues( Statement s, String tableName, int expectedRowCount ) throws Exception
-    {
-        int     actualRowCount = 0;
-        int     lastValue = 0;
-
-        ResultSet   rs = s.executeQuery( "select * from " + tableName + " order by a" );
-
-        while( rs.next() )
-        {
-            actualRowCount++;
-            
-            int currentValue = rs.getInt( 2 );
-            if ( actualRowCount > 1 )
-            {
-                assertTrue( currentValue > lastValue );
-            }
-            lastValue = currentValue;
-        }
-
-        assertEquals( expectedRowCount, actualRowCount );
-    }
-
     /**
      * Make sure that the catalogs and procedures for NATIVE authentication
      * only appear after hard-upgrade.
