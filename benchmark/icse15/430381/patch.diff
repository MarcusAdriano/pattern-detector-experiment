diff --git a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java
index ba899dc7..b1d62a7a 100644
--- a/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java
+++ b/db/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java
@@ -178,7 +178,6 @@
 	private	TriggerInfo				triggerInfo;
 	private RISetChecker 			fkChecker;
 	private TriggerEventActivator	triggerActivator;
-
 	/**
 	 * keeps track of autoincrement values that are generated by 
 	 * getSetAutoincrementValues.
@@ -373,6 +372,7 @@ public InsertResultSet(NoPutResultSet source,
 		String insertMode = constants.getProperty("insertMode");
 		
 		RowLocation[] rla;
+
 		if ((rla = constants.getAutoincRowLocation()) != null)
 		{
 			aiCache = 
@@ -855,12 +855,27 @@ private boolean isSourceRowResultSet ()
 		return isRow;
 	}
 
+    // checks if source result set is a RowResultSet type.
+    private boolean isSingleRowResultSet()
+    {
+        boolean isRow = false;
+        
+        if (sourceResultSet instanceof RowResultSet)
+        	isRow = true;
+        else if (sourceResultSet instanceof NormalizeResultSet)
+            isRow = (((NormalizeResultSet) sourceResultSet).source instanceof RowResultSet);
+        
+        return isRow;
+    }
+	
 	// Do the work for a "normal" insert
 	private void normalInsertCore(LanguageConnectionContext lcc, boolean firstExecute)
 		throws StandardException
 	{
+		boolean setUserIdentity = constants.hasAutoincrement() && isSingleRowResultSet();
 		boolean	firstDeferredRow = true;
 		ExecRow	deferredRowBuffer = null;
+                long user_autoinc=0;
 
 		/* Get or re-use the row changer.
 		 * NOTE: We need to set ourself as the top result set
@@ -1000,6 +1015,30 @@ private void normalInsertCore(LanguageConnectionContext lcc, boolean firstExecut
 
             rowCount++;
 
+            if(setUserIdentity )
+            {
+                        dd = lcc.getDataDictionary();
+                        td = dd.getTableDescriptor(constants.targetUUID);
+                       
+                        int maxColumns = td.getMaxColumnID();
+                        int col;
+                        
+                        for(col=1;col<=maxColumns;col++)
+                        {
+                            ColumnDescriptor cd = td.getColumnDescriptor(col);
+                            if(cd.isAutoincrement())
+                            {
+                                break;
+                            }
+                        }
+                        
+                        if(col <= maxColumns)
+                        {
+                            DataValueDescriptor dvd = row.cloneColumn(col);
+                            user_autoinc = dvd.getLong();
+                        }
+             } 
+
 			// No need to do a next on a single row source
 			if (constants.singleRowSource)
 			{
@@ -1128,6 +1167,14 @@ private void normalInsertCore(LanguageConnectionContext lcc, boolean firstExecut
 		}
 		if (setIdentity)
 			lcc.setIdentityValue(identityVal);
+                /*
+                 * find the value of the identity column from the user inserted value
+                 * and do a lcc.setIdentityValue(<user_value>);
+                 */
+                else if(setUserIdentity )
+                {
+                        lcc.setIdentityValue(user_autoinc);
+                } 
     }
 
 	/*
