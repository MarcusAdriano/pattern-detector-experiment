diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/PerfRunData.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/PerfRunData.java
index 5e7565ad..8cfc50b5 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/PerfRunData.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/PerfRunData.java
@@ -19,10 +19,15 @@
  */
 
 import java.io.File;
+import java.util.HashMap;
+import java.util.Iterator;
+
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.benchmark.byTask.feeds.DocMaker;
 import org.apache.lucene.benchmark.byTask.feeds.QueryMaker;
 import org.apache.lucene.benchmark.byTask.stats.Points;
+import org.apache.lucene.benchmark.byTask.tasks.ReadTask;
+import org.apache.lucene.benchmark.byTask.tasks.SearchTask;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.store.Directory;
@@ -54,9 +59,10 @@
   private Directory directory;
   private Analyzer analyzer;
   private DocMaker docMaker;
-  private QueryMaker searchQueryMaker;
-  private QueryMaker searchTravQueryMaker;
-  private QueryMaker searchTravRetQueryMaker;
+  
+  // we use separate (identical) instances for each "read" task type, so each can iterate the quries separately.
+  private HashMap readTaskQueryMaker;
+  private Class qmkrClass;
 
   private IndexReader indexReader;
   private IndexWriter indexWriter;
@@ -73,14 +79,9 @@ public PerfRunData (Config config) throws Exception {
         "org.apache.lucene.benchmark.byTask.feeds.SimpleDocMaker")).newInstance();
     docMaker.setConfig(config);
     // query makers
-    // we use separate (identical) instances for each "read" task type, so each can iterate the quries separately.
-    Class qmkrClass = Class.forName(config.get("query.maker","org.apache.lucene.benchmark.byTask.feeds.SimpleQueryMaker"));
-    searchQueryMaker = (QueryMaker) qmkrClass.newInstance();
-    searchQueryMaker.setConfig(config);
-    searchTravQueryMaker = (QueryMaker) qmkrClass.newInstance();
-    searchTravQueryMaker.setConfig(config);
-    searchTravRetQueryMaker = (QueryMaker) qmkrClass.newInstance();
-    searchTravRetQueryMaker.setConfig(config);
+    readTaskQueryMaker = new HashMap();
+    qmkrClass = Class.forName(config.get("query.maker","org.apache.lucene.benchmark.byTask.feeds.SimpleQueryMaker"));
+
     // index stuff
     reinit(false);
     
@@ -89,7 +90,7 @@ public PerfRunData (Config config) throws Exception {
     
     if (Boolean.valueOf(config.get("log.queries","false")).booleanValue()) {
       System.out.println("------------> queries:");
-      System.out.println(getSearchQueryMaker().printQueries());
+      System.out.println(getQueryMaker(new SearchTask(this)).printQueries());
     }
 
   }
@@ -118,7 +119,7 @@ public void reinit(boolean eraseIndex) throws Exception {
         FileUtils.fullyDelete(indexDir);
       }
       indexDir.mkdirs();
-      directory = FSDirectory.getDirectory(indexDir, eraseIndex);
+      directory = FSDirectory.getDirectory(indexDir);
     } else {
       directory = new RAMDirectory();
     }
@@ -203,24 +204,30 @@ public Config getConfig() {
 
   public void resetInputs() {
     docMaker.resetInputs();
-    searchQueryMaker.resetInputs();
-    searchTravQueryMaker.resetInputs();
-    searchTravRetQueryMaker.resetInputs();
+    Iterator it = readTaskQueryMaker.values().iterator();
+    while (it.hasNext()) {
+      ((QueryMaker) it.next()).resetInputs();
+    }
   }
 
   /**
-   * @return Returns the searchQueryMaker.
+   * @return Returns the queryMaker by read task type (class)
    */
-  public QueryMaker getSearchQueryMaker() {
-    return searchQueryMaker;
-  }
-
-  public QueryMaker getSearchTravQueryMaker() {
-    return searchTravQueryMaker;
-  }
-
-  public QueryMaker getSearchTravRetQueryMaker() {
-    return searchTravRetQueryMaker;
+  public QueryMaker getQueryMaker(ReadTask readTask) {
+    // mapping the query maker by task class allows extending/adding new search/read tasks
+    // without needing to modify this class.
+    Class readTaskClass = readTask.getClass();
+    QueryMaker qm = (QueryMaker) readTaskQueryMaker.get(readTaskClass);
+    if (qm == null) {
+      try {
+        qm = (QueryMaker) qmkrClass.newInstance();
+        qm.setConfig(config);
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+  }
+      readTaskQueryMaker.put(readTaskClass,qm);
+  }
+    return qm;
   }
 
 }
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/AbstractQueryMaker.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/AbstractQueryMaker.java
index e69de29b..2e2626d9 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/AbstractQueryMaker.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/AbstractQueryMaker.java
@@ -0,0 +1,73 @@
+package org.apache.lucene.benchmark.byTask.feeds;
+/**
+ * Copyright 2005 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.search.Query;
+import org.apache.lucene.benchmark.byTask.utils.Config;
+import org.apache.lucene.benchmark.byTask.utils.Format;
+
+/**
+ * Abstract base query maker. 
+ * Each query maker should just implement the {@link #prepareQueries()} method.
+ **/
+public abstract class AbstractQueryMaker implements QueryMaker {
+
+  protected int qnum = 0;
+  protected Query[] queries;
+  protected Config config;
+
+  public void resetInputs() {
+    qnum = 0;
+  }
+
+  protected abstract Query[] prepareQueries() throws Exception;
+
+  public void setConfig(Config config) throws Exception {
+    this.config = config;
+    queries = prepareQueries();
+  }
+
+  public String printQueries() {
+    String newline = System.getProperty("line.separator");
+    StringBuffer sb = new StringBuffer();
+    if (queries != null) {
+      for (int i = 0; i < queries.length; i++) {
+        sb.append(i+". "+ Format.simpleName(queries[i].getClass())+" - "+queries[i].toString());
+        sb.append(newline);
+      }
+    }
+    return sb.toString();
+  }
+
+  public Query makeQuery() throws Exception {
+    return queries[nextQnum()];
+  }
+  
+  // return next qnum
+  protected synchronized int nextQnum() {
+    int res = qnum;
+    qnum = (qnum+1) % queries.length;
+    return res;
+  }
+
+  /*
+  *  (non-Javadoc)
+  * @see org.apache.lucene.benchmark.byTask.feeds.QueryMaker#makeQuery(int)
+  */
+  public Query makeQuery(int size) throws Exception {
+    throw new Exception(this+".makeQuery(int size) is not supported!");
+  }
+}
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/FileBasedQueryMaker.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/FileBasedQueryMaker.java
index e69de29b..4956acca 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/FileBasedQueryMaker.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/FileBasedQueryMaker.java
@@ -0,0 +1,94 @@
+package org.apache.lucene.benchmark.byTask.feeds;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.queryParser.QueryParser;
+import org.apache.lucene.queryParser.ParseException;
+import org.apache.lucene.search.Query;
+
+import java.io.*;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Copyright 2004 The Apache Software Foundation
+ * <p/>
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * <p/>
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * <p/>
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Create queries from a FileReader.  One per line, pass them through the
+ * QueryParser.  Lines beginning with # are treated as comments
+ *
+ * File can be specified as a absolute, relative or resource.
+ * Two properties can be set:
+ * file.query.maker.file=&lt;Full path to file containing queries&gt;
+ * <br/>
+ * file.query.maker.default.field=&lt;Name of default field - Default value is "body"&gt;
+ *
+ * Example:
+ * file.query.maker.file=c:/myqueries.txt
+ * file.query.maker.default.field=body
+ */
+public class FileBasedQueryMaker extends AbstractQueryMaker implements QueryMaker{
+
+
+  protected Query[] prepareQueries() throws Exception {
+
+    Analyzer anlzr = (Analyzer) Class.forName(config.get("analyzer",
+            "org.apache.lucene.analysis.standard.StandardAnalyzer")).newInstance();
+    String defaultField = config.get("file.query.maker.default.field", "body");
+    QueryParser qp = new QueryParser(defaultField, anlzr);
+
+    List qq = new ArrayList();
+    String fileName = config.get("file.query.maker.file", null);
+    if (fileName != null)
+    {
+      File file = new File(fileName);
+      Reader reader = null;
+      if (file != null && file.exists())
+      {
+        reader = new FileReader(file);
+      } else {
+        //see if we can find it as a resource
+        InputStream asStream = FileBasedQueryMaker.class.getClassLoader().getResourceAsStream(fileName);
+        if (asStream != null) {
+          reader = new InputStreamReader(asStream);
+        }
+      }
+      if (reader != null) {
+        BufferedReader buffered = new BufferedReader(reader);
+        String line = null;
+        int lineNum = 0;
+        while ((line = buffered.readLine()) != null)
+        {
+          line = line.trim();
+          if (!line.equals("") && !line.startsWith("#"))
+          {
+            Query query = null;
+            try {
+              query = qp.parse(line);
+            } catch (ParseException e) {
+              System.err.println("Exception: " + e.getMessage() + " occurred while parsing line: " + lineNum + " Text: " + line);
+            }
+            qq.add(query);
+          }
+          lineNum++;
+        }
+      } else {
+        System.err.println("No Reader available for: " + fileName);
+      }
+    }
+    Query [] result = (Query[]) qq.toArray(new Query[qq.size()]) ;
+    return result;
+  }
+}
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersQueryMaker.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersQueryMaker.java
index 3234e017..8b1d18e4 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersQueryMaker.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersQueryMaker.java
@@ -17,10 +17,6 @@
  * limitations under the License.
  */
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryParser.QueryParser;
@@ -30,19 +26,17 @@
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.benchmark.byTask.utils.Config;
-import org.apache.lucene.benchmark.byTask.utils.Format;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
 
 
 /**
  * A QueryMaker that makes queries devised manually (by Grant Ingersoll) for
  * searching in the Reuters collection.
  */
-public class ReutersQueryMaker implements QueryMaker {
-  
-  private int qnum = 0;
-  private Query queries[];
-  private Config config;
+public class ReutersQueryMaker extends AbstractQueryMaker implements QueryMaker {
   
   private static String [] STANDARD_QUERIES = {
     //Start with some short queries
@@ -106,7 +100,7 @@
     return (Query[]) queries.toArray(new Query[0]);
   }
   
-  private void prepareQueries() throws Exception {
+  protected Query[] prepareQueries() throws Exception {
     // analyzer (default is standard analyzer)
     Analyzer anlzr= (Analyzer) Class.forName(config.get("analyzer",
     "org.apache.lucene.analysis.standard.StandardAnalyzer")).newInstance(); 
@@ -114,47 +108,10 @@ private void prepareQueries() throws Exception {
     List queryList = new ArrayList(20);
     queryList.addAll(Arrays.asList(STANDARD_QUERIES));
     queryList.addAll(Arrays.asList(getPrebuiltQueries("body")));
-    queries = createQueries(queryList, anlzr);
+    return createQueries(queryList, anlzr);
   }
   
-  public Query makeQuery() throws Exception {
-    return queries[nextQnum()];
-  }
   
-  public void setConfig(Config config) throws Exception {
-    this.config = config;
-    prepareQueries();
-  }
   
-  public void resetInputs() {
-    qnum = 0;
-  }
-  
-  // return next qnum
-  private synchronized int nextQnum() {
-    int res = qnum;
-    qnum = (qnum+1) % queries.length;
-    return res;
-  }
-  
-  public String printQueries() {
-    String newline = System.getProperty("line.separator");
-    StringBuffer sb = new StringBuffer();
-    if (queries != null) {
-      for (int i = 0; i < queries.length; i++) {
-        sb.append(i+". "+Format.simpleName(queries[i].getClass())+" - "+queries[i].toString());
-        sb.append(newline);
-      }
-    }
-    return sb.toString();
-  }
-  
-  /*
-   *  (non-Javadoc)
-   * @see org.apache.lucene.benchmark.byTask.feeds.QueryMaker#makeQuery(int)
-   */
-  public Query makeQuery(int size) throws Exception {
-    throw new Exception(this+".makeQuery(int size) is not supported!");
-  }
 
 }
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleQueryMaker.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleQueryMaker.java
index 9dd57ed9..7b62c5e9 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleQueryMaker.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleQueryMaker.java
@@ -17,27 +17,22 @@
  * limitations under the License.
  */
 
-import java.util.ArrayList;
-
 import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.benchmark.byTask.utils.Config;
-import org.apache.lucene.benchmark.byTask.utils.Format;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryParser.QueryParser;
+import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.BooleanClause.Occur;
+
+import java.util.ArrayList;
 
 /**
  * A QueryMaker that makes queries for a collection created 
  * using {@link org.apache.lucene.benchmark.byTask.feeds.SimpleDocMaker}.
  */
-public class SimpleQueryMaker implements QueryMaker {
+public class SimpleQueryMaker extends AbstractQueryMaker implements QueryMaker {
 
-  private int qnum = 0;
-  private Query queries[];
-  private Config config;
   
   /**
    * Prepare the queries for this test.
@@ -70,44 +65,4 @@
     return (Query []) qq.toArray(new Query[0]);
   }
 
-  public Query makeQuery() throws Exception {
-    return queries[nextQnum()];
-  }
-
-  public void setConfig(Config config) throws Exception {
-    this.config = config;
-    queries = prepareQueries();
-  }
-
-  public void resetInputs() {
-    qnum = 0;
-  }
-
-  // return next qnum
-  private synchronized int nextQnum() {
-    int res = qnum;
-    qnum = (qnum+1) % queries.length;
-    return res;
-  }
-
-  public String printQueries() {
-    String newline = System.getProperty("line.separator");
-    StringBuffer sb = new StringBuffer();
-    if (queries != null) {
-      for (int i = 0; i < queries.length; i++) {
-        sb.append(i+". "+Format.simpleName(queries[i].getClass())+" - "+queries[i].toString());
-        sb.append(newline);
-      }
-    }
-    return sb.toString();
-  }
-
-  /*
-   *  (non-Javadoc)
-   * @see org.apache.lucene.benchmark.byTask.feeds.QueryMaker#makeQuery(int)
-   */
-  public Query makeQuery(int size) throws Exception {
-    throw new Exception(this+".makeQuery(int size) is not supported!");
-  }
-
 }
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleSloppyPhraseQueryMaker.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleSloppyPhraseQueryMaker.java
index 82dd9fcb..890875d9 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleSloppyPhraseQueryMaker.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SimpleSloppyPhraseQueryMaker.java
@@ -37,7 +37,7 @@
           q.setSlop(slop);
           int wind = wd;
           for (int i=0; i<qlen; i++) {
-            q.add(new Term(SimpleDocMaker.BODY_FIELD,words[wind++]));
+            q.add(new Term(BasicDocMaker.BODY_FIELD,words[wind++]));
             if (remainedSlop>0) {
               remainedSlop--;
               wind++;
@@ -50,7 +50,7 @@
           q.setSlop(slop+2*qlen);
           wind = wd+qlen+remainedSlop-1;
           for (int i=0; i<qlen; i++) {
-            q.add(new Term(SimpleDocMaker.BODY_FIELD,words[wind--]));
+            q.add(new Term(BasicDocMaker.BODY_FIELD,words[wind--]));
             if (remainedSlop>0) {
               remainedSlop--;
               wind--;
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Points.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Points.java
index 26487e8e..31b7428d 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Points.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Points.java
@@ -18,13 +18,10 @@
  */
 
 import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
+import java.util.List;
 
 import org.apache.lucene.benchmark.byTask.tasks.PerfTask;
 import org.apache.lucene.benchmark.byTask.utils.Config;
-import org.apache.lucene.benchmark.byTask.utils.Format;
 
 
 /**
@@ -34,8 +31,6 @@
 
   private Config config;
   
-  private static final String newline = System.getProperty("line.separator");
-  
   // stat points ordered by their start time. 
   // for now we collect points as TaskStats objects.
   // later might optimize to collect only native data.
@@ -43,26 +38,6 @@
 
   private int nextTaskRunNum = 0;
 
-  /**
-   * Get a textual summary of the benchmark results, average from all test runs.
-   */
-  static final String OP =          "Operation  ";
-  static final String ROUND =       " round";
-  static final String RUNCNT =      "   runCnt";
-  static final String RECCNT =      "   recsPerRun";
-  static final String RECSEC =      "        rec/s";
-  static final String ELAPSED =     "  elapsedSec";
-  static final String USEDMEM =     "    avgUsedMem";
-  static final String TOTMEM =      "    avgTotalMem";
-  static final String COLS[] = {
-      RUNCNT,
-      RECCNT,
-      RECSEC,
-      ELAPSED,
-      USEDMEM,
-      TOTMEM
-  };
-
   /**
    * Create a Points statistics object. 
    */
@@ -70,240 +45,13 @@ public Points (Config config) {
     this.config = config;
   }
 
-  private String tableTitle (String longestOp) {
-    StringBuffer sb = new StringBuffer();
-    sb.append(Format.format(OP,longestOp));
-    sb.append(ROUND);
-    sb.append(config.getColsNamesForValsByRound());
-    for (int i = 0; i < COLS.length; i++) {
-      sb.append(COLS[i]);
-    }
-    return sb.toString(); 
-  }
-  
-  /**
-   * Report detailed statistics as a string
-   * @return the report
-   */
-  public Report reportAll() {
-    String longestOp = longestOp(points);
-    boolean first = true;
-    StringBuffer sb = new StringBuffer();
-    sb.append(tableTitle(longestOp));
-    sb.append(newline);
-    int reported = 0;
-    for (Iterator it = points.iterator(); it.hasNext();) {
-      TaskStats stat = (TaskStats) it.next();
-      if (stat.getElapsed()>=0) { // consider only tasks that ended
-        if (!first) {
-          sb.append(newline);
-        }
-        first = false;
-        String line = taskReportLine(longestOp, stat);
-        reported++;
-        if (points.size()>2&& reported%2==0) {
-          line = line.replaceAll("   "," - ");
-        }
-        sb.append(line);
-      }
-    }
-    String reptxt = (reported==0 ? "No Matching Entries Were Found!" : sb.toString());
-    return new Report(reptxt,reported,reported,points.size());
-  }
-
-  /**
-   * Report statistics as a string, aggregate for tasks named the same.
-   * @return the report
-   */
-  public Report reportSumByName() {
-    // aggregate by task name
-    int reported = 0;
-    LinkedHashMap p2 = new LinkedHashMap();
-    for (Iterator it = points.iterator(); it.hasNext();) {
-      TaskStats stat1 = (TaskStats) it.next();
-      if (stat1.getElapsed()>=0) { // consider only tasks that ended
-        reported++;
-        String name = stat1.getTask().getName();
-        TaskStats stat2 = (TaskStats) p2.get(name);
-        if (stat2 == null) {
-          try {
-            stat2 = (TaskStats) stat1.clone();
-          } catch (CloneNotSupportedException e) {
-            throw new RuntimeException(e);
-          }
-          p2.put(name,stat2);
-        } else {
-          stat2.add(stat1);
-        }
-      }
-    }
-    // now generate report from secondary list p2    
-    return genReportFromList(reported, p2);
-  }
-
   /**
-   * Report statistics as a string, aggregate for tasks named the same, and from the same round.
-   * @return the report
+   * Return the current task stats.
+   * the actual task stats are returned, so caller should not modify this task stats. 
+   * @return current {@link TaskStats}.
    */
-  public Report reportSumByNameRound() {
-    // aggregate by task name and round
-    LinkedHashMap p2 = new LinkedHashMap();
-    int reported = 0;
-    for (Iterator it = points.iterator(); it.hasNext();) {
-      TaskStats stat1 = (TaskStats) it.next();
-      if (stat1.getElapsed()>=0) { // consider only tasks that ended
-        reported++;
-        String name = stat1.getTask().getName();
-        String rname = stat1.getRound()+"."+name; // group by round
-        TaskStats stat2 = (TaskStats) p2.get(rname);
-        if (stat2 == null) {
-          try {
-            stat2 = (TaskStats) stat1.clone();
-          } catch (CloneNotSupportedException e) {
-            throw new RuntimeException(e);
-          }
-          p2.put(rname,stat2);
-        } else {
-          stat2.add(stat1);
-        }
-      }
-    }
-    // now generate report from secondary list p2    
-    return genReportFromList(reported, p2);
-  }
-  
-  private String longestOp(Collection c) {
-    String longest = OP;
-    for (Iterator it = c.iterator(); it.hasNext();) {
-      TaskStats stat = (TaskStats) it.next();
-      if (stat.getElapsed()>=0) { // consider only tasks that ended
-        String name = stat.getTask().getName();
-        if (name.length() > longest.length()) {
-          longest = name;
-        }
-      }
-    }
-    return longest;
-  }
-
-  private String taskReportLine(String longestOp, TaskStats stat) {
-    PerfTask task = stat.getTask();
-    StringBuffer sb = new StringBuffer();
-    sb.append(Format.format(task.getName(), longestOp));
-    String round = (stat.getRound()>=0 ? ""+stat.getRound() : "-");
-    sb.append(Format.formatPaddLeft(round, ROUND));
-    sb.append(config.getColsValuesForValsByRound(stat.getRound()));
-    sb.append(Format.format(stat.getNumRuns(), RUNCNT)); 
-    sb.append(Format.format(stat.getCount() / stat.getNumRuns(), RECCNT));
-    long elapsed = (stat.getElapsed()>0 ? stat.getElapsed() : 1); // assume at least 1ms
-    sb.append(Format.format(1,(float) (stat.getCount() * 1000.0 / elapsed), RECSEC));
-    sb.append(Format.format(2, (float) stat.getElapsed() / 1000, ELAPSED));
-    sb.append(Format.format(0, (float) stat.getMaxUsedMem() / stat.getNumRuns(), USEDMEM)); 
-    sb.append(Format.format(0, (float) stat.getMaxTotMem() / stat.getNumRuns(), TOTMEM));
-    return sb.toString();
-  }
-
-  public Report reportSumByPrefix(String prefix) {
-    // aggregate by task name
-    int reported = 0;
-    LinkedHashMap p2 = new LinkedHashMap();
-    for (Iterator it = points.iterator(); it.hasNext();) {
-      TaskStats stat1 = (TaskStats) it.next();
-      if (stat1.getElapsed()>=0 && stat1.getTask().getName().startsWith(prefix)) { // only ended tasks with proper name
-        reported++;
-        String name = stat1.getTask().getName();
-        TaskStats stat2 = (TaskStats) p2.get(name);
-        if (stat2 == null) {
-          try {
-            stat2 = (TaskStats) stat1.clone();
-          } catch (CloneNotSupportedException e) {
-            throw new RuntimeException(e);
-          }
-          p2.put(name,stat2);
-        } else {
-          stat2.add(stat1);
-        }
-      }
-    }
-    // now generate report from secondary list p2    
-    return genReportFromList(reported, p2);
-  }
-  
-  public Report reportSumByPrefixRound(String prefix) {
-    // aggregate by task name and by round
-    int reported = 0;
-    LinkedHashMap p2 = new LinkedHashMap();
-    for (Iterator it = points.iterator(); it.hasNext();) {
-      TaskStats stat1 = (TaskStats) it.next();
-      if (stat1.getElapsed()>=0 && stat1.getTask().getName().startsWith(prefix)) { // only ended tasks with proper name
-        reported++;
-        String name = stat1.getTask().getName();
-        String rname = stat1.getRound()+"."+name; // group by round
-        TaskStats stat2 = (TaskStats) p2.get(rname);
-        if (stat2 == null) {
-          try {
-            stat2 = (TaskStats) stat1.clone();
-          } catch (CloneNotSupportedException e) {
-            throw new RuntimeException(e);
-          }
-          p2.put(rname,stat2);
-        } else {
-          stat2.add(stat1);
-        }
-      }
-    }
-    // now generate report from secondary list p2    
-    return genReportFromList(reported, p2);
-  }
-
-  private Report genReportFromList(int reported, LinkedHashMap p2) {
-    String longetOp = longestOp(p2.values());
-    boolean first = true;
-    StringBuffer sb = new StringBuffer();
-    sb.append(tableTitle(longetOp));
-    sb.append(newline);
-    int lineNum = 0;
-    for (Iterator it = p2.values().iterator(); it.hasNext();) {
-      TaskStats stat = (TaskStats) it.next();
-      if (!first) {
-        sb.append(newline);
-      }
-      first = false;
-      String line = taskReportLine(longetOp,stat);
-      lineNum++;
-      if (p2.size()>2&& lineNum%2==0) {
-        line = line.replaceAll("   "," - ");
-      }
-      sb.append(line);
-    }
-    String reptxt = (reported==0 ? "No Matching Entries Were Found!" : sb.toString());
-    return new Report(reptxt,p2.size(),reported,points.size());
-  }
-
-  public Report reportSelectByPrefix(String prefix) {
-    String longestOp = longestOp(points);
-    boolean first = true;
-    StringBuffer sb = new StringBuffer();
-    sb.append(tableTitle(longestOp));
-    sb.append(newline);
-    int reported = 0;
-    for (Iterator it = points.iterator(); it.hasNext();) {
-      TaskStats stat = (TaskStats) it.next();
-      if (stat.getElapsed()>=0 && stat.getTask().getName().startsWith(prefix)) { // only ended tasks with proper name
-        reported++;
-        if (!first) {
-          sb.append(newline);
-        }
-        first = false;
-        String line = taskReportLine(longestOp,stat);
-        if (points.size()>2&& reported%2==0) {
-          line = line.replaceAll("   "," - ");
-        }
-        sb.append(line);
-      }
-    }
-    String reptxt = (reported==0 ? "No Matching Entries Were Found!" : sb.toString());
-    return new Report(reptxt,reported,reported, points.size());
+  public List taskStats () {
+    return points;
   }
 
   /**
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Report.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Report.java
index 6f07ecdf..05cff532 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Report.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Report.java
@@ -27,7 +27,7 @@
   private int outOf;
   private int reported;
 
-  Report (String text, int size, int reported, int outOf) {
+  public Report (String text, int size, int reported, int outOf) {
     this.text = text;
     this.size = size;
     this.reported = reported;
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/TaskStats.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/TaskStats.java
index 62936624..7138b9a5 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/TaskStats.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/TaskStats.java
@@ -178,14 +178,14 @@ public void add(TaskStats stat2) {
   /* (non-Javadoc)
    * @see java.lang.Object#clone()
    */
-  protected Object clone() throws CloneNotSupportedException {
+  public Object clone() throws CloneNotSupportedException {
     return super.clone();
   }
 
   /**
    * @return the round number.
    */
-  int getRound() {
+  public int getRound() {
     return round;
   }
   
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AddDocTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AddDocTask.java
index 5fc504ab..89817e02 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AddDocTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AddDocTask.java
@@ -23,11 +23,19 @@
 
 
 /**
- * Add a document, optionally with of a cetrain size.
- * Other side effects: none.
+ * Add a document, optionally with of a certain size.
+ * <br>Other side effects: none.
+ * <br>Relevant properties: <code>doc.add.log.step</code>.
+ * <br>Takes optional param: document size. 
  */
 public class AddDocTask extends PerfTask {
 
+  /**
+   * Default value for property <code>doc.add.log.step<code> - indicating how often 
+   * an "added N docs" message should be logged.  
+   */
+  public static final int DEFAULT_ADD_DOC_LOG_STEP = 500;
+
   public AddDocTask(PerfRunData runData) {
     super(runData);
   }
@@ -70,10 +78,10 @@ public int doLogic() throws Exception {
   private void log (int count) {
     if (logStep<0) {
       // avoid sync although race possible here
-      logStep = getRunData().getConfig().get("doc.add.log.step",500);
+      logStep = getRunData().getConfig().get("doc.add.log.step",DEFAULT_ADD_DOC_LOG_STEP);
     }
     if (logStep>0 && (count%logStep)==0) {
-      System.out.println("--> processed "+count+" docs");
+      System.out.println("--> processed (add) "+count+" docs");
     }
   }
 
@@ -85,4 +93,12 @@ public void setParams(String params) {
     super.setParams(params);
     docSize = (int) Float.parseFloat(params); 
   }
+
+  /* (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.tasks.PerfTask#supportsParams()
+   */
+  public boolean supportsParams() {
+    return true;
+  }
+  
 }
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ClearStatsTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ClearStatsTask.java
index de98d1f3..b7d23169 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ClearStatsTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ClearStatsTask.java
@@ -21,7 +21,7 @@
 
 /**
  * Clear statistics data.
- * Other side effects: None.
+ * <br>Other side effects: None.
  */
 public class ClearStatsTask extends PerfTask {
 
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CloseIndexTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CloseIndexTask.java
index cebdb894..ba378bdb 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CloseIndexTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CloseIndexTask.java
@@ -24,7 +24,7 @@
 
 /**
  * Close index writer.
- * Other side effects: index writer object in perfRunData is nullified.
+ * <br>Other side effects: index writer object in perfRunData is nullified.
  */
 public class CloseIndexTask extends PerfTask {
 
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CloseReaderTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CloseReaderTask.java
index d9d7a2ca..7b827c8c 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CloseReaderTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CloseReaderTask.java
@@ -24,8 +24,8 @@
 
 /**
  * Close index reader.
- * Other side effects: index reader in perfRunData is nullified.
- * This would cause read related tasks to reopen their own reader. 
+ * <br>Other side effects: index reader in perfRunData is nullified.
+ * <br>This would cause read related tasks to reopen their own reader. 
  */
 public class CloseReaderTask extends PerfTask {
 
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask.java
index dfb73fb8..4a7b1b72 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask.java
@@ -28,7 +28,8 @@
 
 /**
  * Create an index.
- * Other side effects: index writer object in perfRunData is set.
+ * <br>Other side effects: index writer object in perfRunData is set.
+ * <br>Relevant properties: <code>merge.factor , max.buffered</code>.
  */
 public class CreateIndexTask extends PerfTask {
 
@@ -45,8 +46,8 @@ public int doLogic() throws IOException {
     Config config = getRunData().getConfig();
     
     boolean cmpnd = config.get("compound",true);
-    int mrgf = config.get("merge.factor",10);
-    int mxbf = config.get("max.buffered",10);
+    int mrgf = config.get("merge.factor",OpenIndexTask.DEFAULT_MERGE_PFACTOR);
+    int mxbf = config.get("max.buffered",OpenIndexTask.DEFAULT_MAX_BUFFERED);
 
     iw.setUseCompoundFile(cmpnd);
     iw.setMergeFactor(mrgf);
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/DeleteDocTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/DeleteDocTask.java
index be86260c..0f1a1c03 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/DeleteDocTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/DeleteDocTask.java
@@ -21,10 +21,24 @@
 
 /**
  * Delete a document by docid.
- * Other side effects: none.
+ * <br>Other side effects: none.
+ * <br>Relevant properties: <code>doc.delete.log.step , doc.delete.step</code>.
+ * <br>If no docid param is supplied, deletes doc with <code>id = last-deleted-doc + doc.delete.step</code>. 
+ * <br>Takes optional param: document id. 
  */
 public class DeleteDocTask extends PerfTask {
 
+  /**
+   * Gap between ids of deleted docs, applies when no docid param is provided.
+   */
+  public static final int DEFAULT_DOC_DELETE_STEP = 8;
+  
+  /**
+   * Default value for property <code>doc.delete.log.step<code> - indicating how often 
+   * an "deleted N docs" message should be logged.  
+   */
+  public static final int DEFAULT_DELETE_DOC_LOG_STEP = 500;
+  
   public DeleteDocTask(PerfRunData runData) {
     super(runData);
   }
@@ -50,10 +64,10 @@ public void setup() throws Exception {
     super.setup();
     // one time static initializations
     if (logStep<0) {
-      logStep = getRunData().getConfig().get("doc.delete.log.step",500);
+      logStep = getRunData().getConfig().get("doc.delete.log.step",DEFAULT_DELETE_DOC_LOG_STEP);
     }
     if (deleteStep<0) {
-      deleteStep = getRunData().getConfig().get("doc.delete.step",8);
+      deleteStep = getRunData().getConfig().get("doc.delete.step",DEFAULT_DOC_DELETE_STEP);
     }
     // set the docid to be deleted
     docid = (byStep ? lastDeleted + deleteStep : docid);
@@ -69,7 +83,7 @@ public void tearDown() throws Exception {
 
   private void log (int count) {
     if (logStep>0 && (count%logStep)==0) {
-      System.out.println("--> processed "+count+" docs, last deleted: "+lastDeleted);
+      System.out.println("--> processed (delete) "+count+" docs, last deleted: "+lastDeleted);
     }
   }
   
@@ -83,4 +97,11 @@ public void setParams(String params) {
     byStep = (docid < 0);
   }
 
+  /* (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.tasks.PerfTask#supportsParams()
+   */
+  public boolean supportsParams() {
+    return true;
+  }
+
 }
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/NewRoundTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/NewRoundTask.java
index 9bc486ff..826d3471 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/NewRoundTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/NewRoundTask.java
@@ -22,7 +22,7 @@
 
 /**
  * Increment the counter for properties maintained by Round Number.
- * Other side effects: if there are props by round number, log value change.
+ * <br>Other side effects: if there are props by round number, log value change.
  */
 public class NewRoundTask extends PerfTask {
 
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenIndexTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenIndexTask.java
index aa2b6323..a224e685 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenIndexTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenIndexTask.java
@@ -28,10 +28,14 @@
 
 /**
  * Open an index writer.
- * Other side effects: index writer object in perfRunData is set.
+ * <br>Other side effects: index writer object in perfRunData is set.
+ * <br>Relevant properties: <code>merge.factor , max.buffered</code>.
  */
 public class OpenIndexTask extends PerfTask {
 
+  public static final int DEFAULT_MAX_BUFFERED = 10;
+  public static final int DEFAULT_MERGE_PFACTOR = 10;
+
   public OpenIndexTask(PerfRunData runData) {
     super(runData);
   }
@@ -44,8 +48,8 @@ public int doLogic() throws IOException {
     Config config = getRunData().getConfig();
     
     boolean cmpnd = config.get("compound",true);
-    int mrgf = config.get("merge.factor",10);
-    int mxbf = config.get("max.buffered",10);
+    int mrgf = config.get("merge.factor",DEFAULT_MERGE_PFACTOR);
+    int mxbf = config.get("max.buffered",DEFAULT_MAX_BUFFERED);
 
     // must update params for newly opened writer
     writer.setMaxBufferedDocs(mxbf);
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenReaderTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenReaderTask.java
index 5c5f08f2..fcef25ea 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenReaderTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenReaderTask.java
@@ -25,7 +25,7 @@
 
 /**
  * Open an index reader.
- * Other side effects: index redaer object in perfRunData is set.
+ * <br>Other side effects: index redaer object in perfRunData is set.
  */
 public class OpenReaderTask extends PerfTask {
 
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OptimizeTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OptimizeTask.java
index dab1cbdb..c6a459d2 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OptimizeTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OptimizeTask.java
@@ -22,7 +22,7 @@
 
 /**
  * Optimize the index.
- * Other side effects: none.
+ * <br>Other side effects: none.
  */
 public class OptimizeTask extends PerfTask {
 
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/PerfTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/PerfTask.java
index d9442705..b3687123 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/PerfTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/PerfTask.java
@@ -30,6 +30,8 @@
  * <br>
  * Tasks performing some work that should be measured for the task, can overide setup() and/or tearDown() and 
  * placed that work there. 
+ * <br>
+ * Relevant properties: <code>task.max.depth.log</code>.
  */
 public abstract class PerfTask implements Cloneable {
 
@@ -39,7 +41,7 @@
   private String name;
   private int depth = 0;
   private int maxDepthLogStart = 0;
-  protected String params = null;
+  private String params = null;
   
   protected static final String NEW_LINE = System.getProperty("line.separator");
 
@@ -199,11 +201,22 @@ public void setup () throws Exception {
   public void tearDown () throws Exception {
   }
 
+  /**
+   * Sub classes that supports parameters must overide this method to return true.
+   * @return true iff this task supports command line params.
+   */
+  public boolean supportsParams () {
+    return false;
+  }
+  
   /**
    * Set the params of this task.
-   * Sub classes that supports parameters may overide this method for fetching/processing the params.
+   * @exception UnsupportedOperationException for tasks supporting command line parameters.
    */
   public void setParams(String params) {
+    if (!supportsParams()) {
+      throw new UnsupportedOperationException(getName()+" does not support command line parameters.");
+    }
     this.params = params;
   }
 
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java
index 0cd612b4..2fe69aa8 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java
@@ -76,9 +76,10 @@ public int doLogic() throws Exception {
       Hits hits = searcher.search(q);
       //System.out.println("searched: "+q);
       
-      if (withTraverse()) {
+      if (withTraverse() && hits!=null) {
         Document doc = null;
-        if (hits != null && hits.length() > 0) {
+        int traversalSize = Math.min(hits.length(), traversalSize());
+        if (traversalSize > 0) {
           for (int m = 0; m < hits.length(); m++) {
             int id = hits.id(m);
             res++;
@@ -120,6 +121,18 @@ public int doLogic() throws Exception {
    */
   public abstract boolean withTraverse ();
 
+  /**
+   * Specify the number of hits to traverse.  Tasks should override this if they want to restrict the number
+   * of hits that are traversed when {@link #withTraverse()} is true. Must be greater than 0.
+   *
+   * Read task calculates the traversal as: Math.min(hits.length(), traversalSize())
+   * @return Integer.MAX_VALUE
+   */
+  public int traversalSize()
+  {
+    return Integer.MAX_VALUE;
+  }
+
   /**
    * Return true if, with search & results traversing, docs should be retrieved.
    */
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepAllTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepAllTask.java
index 98e7a425..a6ecd25b 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepAllTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepAllTask.java
@@ -17,12 +17,16 @@
  * limitations under the License.
  */
 
+import java.util.Iterator;
+import java.util.List;
+
 import org.apache.lucene.benchmark.byTask.PerfRunData;
 import org.apache.lucene.benchmark.byTask.stats.Report;
+import org.apache.lucene.benchmark.byTask.stats.TaskStats;
 
 /**
  * Report all statistics with no aggregations.
- * Other side effects: None.
+ * <br>Other side effects: None.
  */
 public class RepAllTask extends ReportTask {
 
@@ -31,7 +35,7 @@ public RepAllTask(PerfRunData runData) {
    }
 
   public int doLogic() throws Exception {
-    Report rp = getRunData().getPoints().reportAll();
+    Report rp = reportAll(getRunData().getPoints().taskStats());
     
     System.out.println();
     System.out.println("------------> Report All ("+rp.getSize()+" out of "+rp.getOutOf()+")");
@@ -40,4 +44,35 @@ public int doLogic() throws Exception {
     return 0;
   }
 
+  /**
+   * Report detailed statistics as a string
+   * @return the report
+   */
+  protected Report reportAll(List taskStats) {
+    String longestOp = longestOp(taskStats.iterator());
+    boolean first = true;
+    StringBuffer sb = new StringBuffer();
+    sb.append(tableTitle(longestOp));
+    sb.append(newline);
+    int reported = 0;
+    Iterator it = taskStats.iterator();
+    while (it.hasNext()) {
+      TaskStats stat = (TaskStats) it.next();
+      if (stat.getElapsed()>=0) { // consider only tasks that ended
+        if (!first) {
+          sb.append(newline);
+        }
+        first = false;
+        String line = taskReportLine(longestOp, stat);
+        reported++;
+        if (taskStats.size()>2 && reported%2==0) {
+          line = line.replaceAll("   "," - ");
+        }
+        sb.append(line);
+      }
+    }
+    String reptxt = (reported==0 ? "No Matching Entries Were Found!" : sb.toString());
+    return new Report(reptxt,reported,reported,taskStats.size());
+  }
+
 }
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSelectByPrefTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSelectByPrefTask.java
index 3b3eb983..9dc5a6d4 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSelectByPrefTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSelectByPrefTask.java
@@ -17,12 +17,16 @@
  * limitations under the License.
  */
 
+import java.util.Iterator;
+import java.util.List;
+
 import org.apache.lucene.benchmark.byTask.PerfRunData;
 import org.apache.lucene.benchmark.byTask.stats.Report;
+import org.apache.lucene.benchmark.byTask.stats.TaskStats;
 
 /**
  * Report by-name-prefix statistics with no aggregations.
- * Other side effects: None.
+ * <br>Other side effects: None.
  */
 public class RepSelectByPrefTask extends RepSumByPrefTask {
 
@@ -31,7 +35,7 @@ public RepSelectByPrefTask(PerfRunData runData) {
   }
 
   public int doLogic() throws Exception {
-    Report rp = getRunData().getPoints().reportSelectByPrefix(prefix);
+    Report rp = reportSelectByPrefix(getRunData().getPoints().taskStats());
     
     System.out.println();
     System.out.println("------------> Report Select By Prefix ("+prefix+") ("+
@@ -41,4 +45,31 @@ public int doLogic() throws Exception {
 
     return 0;
   }
+  
+  protected Report reportSelectByPrefix(List taskStats) {
+    String longestOp = longestOp(taskStats.iterator());
+    boolean first = true;
+    StringBuffer sb = new StringBuffer();
+    sb.append(tableTitle(longestOp));
+    sb.append(newline);
+    int reported = 0;
+    for (Iterator it = taskStats.iterator(); it.hasNext();) {
+      TaskStats stat = (TaskStats) it.next();
+      if (stat.getElapsed()>=0 && stat.getTask().getName().startsWith(prefix)) { // only ended tasks with proper name
+        reported++;
+        if (!first) {
+          sb.append(newline);
+        }
+        first = false;
+        String line = taskReportLine(longestOp,stat);
+        if (taskStats.size()>2 && reported%2==0) {
+          line = line.replaceAll("   "," - ");
+        }
+        sb.append(line);
+      }
+    }
+    String reptxt = (reported==0 ? "No Matching Entries Were Found!" : sb.toString());
+    return new Report(reptxt,reported,reported, taskStats.size());
+  }
+
 }
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameRoundTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameRoundTask.java
index 4a78ccf1..6491c030 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameRoundTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameRoundTask.java
@@ -17,12 +17,17 @@
  * limitations under the License.
  */
 
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+
 import org.apache.lucene.benchmark.byTask.PerfRunData;
 import org.apache.lucene.benchmark.byTask.stats.Report;
+import org.apache.lucene.benchmark.byTask.stats.TaskStats;
 
 /**
  * Report all statistics grouped/aggregated by name and round.
- * Other side effects: None.
+ * <br>Other side effects: None.
  */
 public class RepSumByNameRoundTask extends ReportTask {
 
@@ -31,7 +36,7 @@ public RepSumByNameRoundTask(PerfRunData runData) {
   }
 
   public int doLogic() throws Exception {
-    Report rp = getRunData().getPoints().reportSumByNameRound();
+    Report rp = reportSumByNameRound(getRunData().getPoints().taskStats());
 
     System.out.println();
     System.out.println("------------> Report Sum By (any) Name and Round ("+
@@ -42,4 +47,35 @@ public int doLogic() throws Exception {
     return 0;
   }
 
+  /**
+   * Report statistics as a string, aggregate for tasks named the same, and from the same round.
+   * @return the report
+   */
+  protected Report reportSumByNameRound(List taskStats) {
+    // aggregate by task name and round
+    LinkedHashMap p2 = new LinkedHashMap();
+    int reported = 0;
+    for (Iterator it = taskStats.iterator(); it.hasNext();) {
+      TaskStats stat1 = (TaskStats) it.next();
+      if (stat1.getElapsed()>=0) { // consider only tasks that ended
+        reported++;
+        String name = stat1.getTask().getName();
+        String rname = stat1.getRound()+"."+name; // group by round
+        TaskStats stat2 = (TaskStats) p2.get(rname);
+        if (stat2 == null) {
+          try {
+            stat2 = (TaskStats) stat1.clone();
+          } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+          }
+          p2.put(rname,stat2);
+        } else {
+          stat2.add(stat1);
+        }
+      }
+    }
+    // now generate report from secondary list p2    
+    return genPartialReport(reported, p2, taskStats.size());
+  }
+
 }
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameTask.java
index 4939911e..101ed4cc 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameTask.java
@@ -17,12 +17,17 @@
  * limitations under the License.
  */
 
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+
 import org.apache.lucene.benchmark.byTask.PerfRunData;
 import org.apache.lucene.benchmark.byTask.stats.Report;
+import org.apache.lucene.benchmark.byTask.stats.TaskStats;
 
 /**
  * Report all statistics aggregated by name.
- * Other side effects: None.
+ * <br>Other side effects: None.
  */
 public class RepSumByNameTask extends ReportTask {
 
@@ -31,7 +36,7 @@ public RepSumByNameTask(PerfRunData runData) {
   }
 
   public int doLogic() throws Exception {
-    Report rp = getRunData().getPoints().reportSumByName();
+    Report rp = reportSumByName(getRunData().getPoints().taskStats());
 
     System.out.println();
     System.out.println("------------> Report Sum By (any) Name ("+
@@ -42,4 +47,35 @@ public int doLogic() throws Exception {
     return 0;
   }
 
+  /**
+   * Report statistics as a string, aggregate for tasks named the same.
+   * @return the report
+   */
+  protected Report reportSumByName(List taskStats) {
+    // aggregate by task name
+    int reported = 0;
+    LinkedHashMap p2 = new LinkedHashMap();
+    for (Iterator it = taskStats.iterator(); it.hasNext();) {
+      TaskStats stat1 = (TaskStats) it.next();
+      if (stat1.getElapsed()>=0) { // consider only tasks that ended
+        reported++;
+        String name = stat1.getTask().getName();
+        TaskStats stat2 = (TaskStats) p2.get(name);
+        if (stat2 == null) {
+          try {
+            stat2 = (TaskStats) stat1.clone();
+          } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+          }
+          p2.put(name,stat2);
+        } else {
+          stat2.add(stat1);
+        }
+      }
+    }
+    // now generate report from secondary list p2    
+    return genPartialReport(reported, p2, taskStats.size());
+  }
+
+
 }
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefRoundTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefRoundTask.java
index 535bcf38..72f954e5 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefRoundTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefRoundTask.java
@@ -17,12 +17,17 @@
  * limitations under the License.
  */
 
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+
 import org.apache.lucene.benchmark.byTask.PerfRunData;
 import org.apache.lucene.benchmark.byTask.stats.Report;
+import org.apache.lucene.benchmark.byTask.stats.TaskStats;
 
 /**
  * Report all prefix matching statistics grouped/aggregated by name and round.
- * Other side effects: None.
+ * <br>Other side effects: None.
  */
 public class RepSumByPrefRoundTask extends RepSumByPrefTask {
 
@@ -31,7 +36,7 @@ public RepSumByPrefRoundTask(PerfRunData runData) {
   }
 
   public int doLogic() throws Exception {
-    Report rp = getRunData().getPoints().reportSumByPrefixRound(prefix);
+    Report rp = reportSumByPrefixRound(getRunData().getPoints().taskStats());
     
     System.out.println();
     System.out.println("------------> Report sum by Prefix ("+prefix+") and Round ("+
@@ -42,4 +47,32 @@ public int doLogic() throws Exception {
     return 0;
   }
 
+  protected Report reportSumByPrefixRound(List taskStats) {
+    // aggregate by task name and by round
+    int reported = 0;
+    LinkedHashMap p2 = new LinkedHashMap();
+    for (Iterator it = taskStats.iterator(); it.hasNext();) {
+      TaskStats stat1 = (TaskStats) it.next();
+      if (stat1.getElapsed()>=0 && stat1.getTask().getName().startsWith(prefix)) { // only ended tasks with proper name
+        reported++;
+        String name = stat1.getTask().getName();
+        String rname = stat1.getRound()+"."+name; // group by round
+        TaskStats stat2 = (TaskStats) p2.get(rname);
+        if (stat2 == null) {
+          try {
+            stat2 = (TaskStats) stat1.clone();
+          } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+          }
+          p2.put(rname,stat2);
+        } else {
+          stat2.add(stat1);
+        }
+      }
+    }
+    // now generate report from secondary list p2    
+    return genPartialReport(reported, p2, taskStats.size());
+  }
+
+
 }
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefTask.java
index c0b3f17d..e55f688e 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefTask.java
@@ -19,10 +19,15 @@
 
 import org.apache.lucene.benchmark.byTask.PerfRunData;
 import org.apache.lucene.benchmark.byTask.stats.Report;
+import org.apache.lucene.benchmark.byTask.stats.TaskStats;
+
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
 
 /**
  * Report by-name-prefix statistics aggregated by name.
- * Other side effects: None.
+ * <br>Other side effects: None.
  */
 public class RepSumByPrefTask extends ReportTask {
 
@@ -33,7 +38,7 @@ public RepSumByPrefTask(PerfRunData runData) {
   protected String prefix;
 
   public int doLogic() throws Exception {
-    Report rp = getRunData().getPoints().reportSumByPrefix(prefix);
+    Report rp = reportSumByPrefix(getRunData().getPoints().taskStats());
     
     System.out.println();
     System.out.println("------------> Report Sum By Prefix ("+prefix+") ("+
@@ -44,6 +49,33 @@ public int doLogic() throws Exception {
     return 0;
   }
 
+  protected Report reportSumByPrefix (List taskStats) {
+    // aggregate by task name
+    int reported = 0;
+    LinkedHashMap p2 = new LinkedHashMap();
+    for (Iterator it = taskStats.iterator(); it.hasNext();) {
+      TaskStats stat1 = (TaskStats) it.next();
+      if (stat1.getElapsed()>=0 && stat1.getTask().getName().startsWith(prefix)) { // only ended tasks with proper name
+        reported++;
+        String name = stat1.getTask().getName();
+        TaskStats stat2 = (TaskStats) p2.get(name);
+        if (stat2 == null) {
+          try {
+            stat2 = (TaskStats) stat1.clone();
+          } catch (CloneNotSupportedException e) {
+            throw new RuntimeException(e);
+          }
+          p2.put(name,stat2);
+        } else {
+          stat2.add(stat1);
+        }
+      }
+    }
+    // now generate report from secondary list p2    
+    return genPartialReport(reported, p2, taskStats.size());
+  }
+  
+
   public void setPrefix(String prefix) {
     this.prefix = prefix;
   }
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReportTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReportTask.java
index 1913a6be..9b5a68c3 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReportTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReportTask.java
@@ -1,6 +1,12 @@
 package org.apache.lucene.benchmark.byTask.tasks;
 
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+
 import org.apache.lucene.benchmark.byTask.PerfRunData;
+import org.apache.lucene.benchmark.byTask.stats.Report;
+import org.apache.lucene.benchmark.byTask.stats.TaskStats;
+import org.apache.lucene.benchmark.byTask.utils.Format;
 
 /**
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -41,4 +47,116 @@ protected boolean shouldNeverLogAtStart() {
   protected boolean shouldNotRecordStats() {
     return true;
   }
+
+  /*
+   * From here start the code used to generate the reports. 
+   * Subclasses would use this part to generate reports.
+   */
+  
+  protected static final String newline = System.getProperty("line.separator");
+  
+  /**
+   * Get a textual summary of the benchmark results, average from all test runs.
+   */
+  protected static final String OP =          "Operation  ";
+  protected static final String ROUND =       " round";
+  protected static final String RUNCNT =      "   runCnt";
+  protected static final String RECCNT =      "   recsPerRun";
+  protected static final String RECSEC =      "        rec/s";
+  protected static final String ELAPSED =     "  elapsedSec";
+  protected static final String USEDMEM =     "    avgUsedMem";
+  protected static final String TOTMEM =      "    avgTotalMem";
+  protected static final String COLS[] = {
+      RUNCNT,
+      RECCNT,
+      RECSEC,
+      ELAPSED,
+      USEDMEM,
+      TOTMEM
+  };
+
+  /**
+   * Compute a title line for a report table
+   * @param longestOp size of longest op name in the table
+   * @return the table title line.
+   */
+  protected String tableTitle (String longestOp) {
+    StringBuffer sb = new StringBuffer();
+    sb.append(Format.format(OP,longestOp));
+    sb.append(ROUND);
+    sb.append(getRunData().getConfig().getColsNamesForValsByRound());
+    for (int i = 0; i < COLS.length; i++) {
+      sb.append(COLS[i]);
+    }
+    return sb.toString(); 
+  }
+  
+  /**
+   * find the longest op name out of completed tasks.  
+   * @param taskStats completed tasks to be considered.
+   * @return the longest op name out of completed tasks.
+   */
+  protected String longestOp(Iterator taskStats) {
+    String longest = OP;
+    while (taskStats.hasNext()) {
+      TaskStats stat = (TaskStats) taskStats.next();
+      if (stat.getElapsed()>=0) { // consider only tasks that ended
+        String name = stat.getTask().getName();
+        if (name.length() > longest.length()) {
+          longest = name;
+        }
+      }
+    }
+    return longest;
+  }
+  
+  /**
+   * Compute a report line for the given task stat.
+   * @param longestOp size of longest op name in the table.
+   * @param stat task stat to be printed.
+   * @return the report line.
+   */
+  protected String taskReportLine(String longestOp, TaskStats stat) {
+    PerfTask task = stat.getTask();
+    StringBuffer sb = new StringBuffer();
+    sb.append(Format.format(task.getName(), longestOp));
+    String round = (stat.getRound()>=0 ? ""+stat.getRound() : "-");
+    sb.append(Format.formatPaddLeft(round, ROUND));
+    sb.append(getRunData().getConfig().getColsValuesForValsByRound(stat.getRound()));
+    sb.append(Format.format(stat.getNumRuns(), RUNCNT)); 
+    sb.append(Format.format(stat.getCount() / stat.getNumRuns(), RECCNT));
+    long elapsed = (stat.getElapsed()>0 ? stat.getElapsed() : 1); // assume at least 1ms
+    sb.append(Format.format(1,(float) (stat.getCount() * 1000.0 / elapsed), RECSEC));
+    sb.append(Format.format(2, (float) stat.getElapsed() / 1000, ELAPSED));
+    sb.append(Format.format(0, (float) stat.getMaxUsedMem() / stat.getNumRuns(), USEDMEM)); 
+    sb.append(Format.format(0, (float) stat.getMaxTotMem() / stat.getNumRuns(), TOTMEM));
+    return sb.toString();
+  }
+
+  protected Report genPartialReport(int reported, LinkedHashMap partOfTasks, int totalSize) {
+    String longetOp = longestOp(partOfTasks.values().iterator());
+    boolean first = true;
+    StringBuffer sb = new StringBuffer();
+    sb.append(tableTitle(longetOp));
+    sb.append(newline);
+    int lineNum = 0;
+    for (Iterator it = partOfTasks.values().iterator(); it.hasNext();) {
+      TaskStats stat = (TaskStats) it.next();
+      if (!first) {
+        sb.append(newline);
+      }
+      first = false;
+      String line = taskReportLine(longetOp,stat);
+      lineNum++;
+      if (partOfTasks.size()>2 && lineNum%2==0) {
+        line = line.replaceAll("   "," - ");
+      }
+      sb.append(line);
+    }
+    String reptxt = (reported==0 ? "No Matching Entries Were Found!" : sb.toString());
+    return new Report(reptxt,partOfTasks.size(),reported,totalSize);
+  }
+
+
+
 }
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetSystemEraseTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetSystemEraseTask.java
index d01ef9a5..48111e60 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetSystemEraseTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetSystemEraseTask.java
@@ -23,8 +23,8 @@
 
 /**
  * Reset all index and input data and call gc, erase index and dir, does NOT clear statistics.
- * This contains ResetInputs.
- * Other side effects: writers/readers nulified, deleted, closed.
+ * <br>This contains ResetInputs.
+ * <br>Other side effects: writers/readers nulified, deleted, closed.
  * Index is erased.
  * Directory is erased.
  */
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetSystemSoftTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetSystemSoftTask.java
index 91695ac2..456cce49 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetSystemSoftTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ResetSystemSoftTask.java
@@ -24,7 +24,7 @@
 /**
  * Reset all index and input data and call gc, does NOT erase index/dir, does NOT clear statistics.
  * This contains ResetInputs.
- * Other side effects: writers/readers nulified, closed.
+ * <br>Other side effects: writers/readers nulified, closed.
  * Index is NOT erased.
  * Directory is NOT erased.
  */
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTask.java
index cf5bf2b0..8234e190 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTask.java
@@ -49,7 +49,7 @@ public boolean withWarm() {
   }
 
   public QueryMaker getQueryMaker() {
-    return getRunData().getSearchQueryMaker();
+    return getRunData().getQueryMaker(this);
   }
 
 
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetTask.java
index c5574780..6f4bde59 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetTask.java
@@ -18,15 +18,16 @@
  */
 
 import org.apache.lucene.benchmark.byTask.PerfRunData;
-import org.apache.lucene.benchmark.byTask.feeds.QueryMaker;
 
 /**
  * Search and Travrese and Retrieve docs task.
  * 
  * <p>Note: This task reuses the reader if it is already open. 
  * Otherwise a reader is opened at start and closed at the end.
+ * 
+ * Takes optional param: traversal size (otherwise all results are traversed).
  */
-public class SearchTravRetTask extends ReadTask {
+public class SearchTravRetTask extends SearchTravTask {
 
   public SearchTravRetTask(PerfRunData runData) {
     super(runData);
@@ -36,21 +37,4 @@ public boolean withRetrieve() {
     return true;
   }
 
-  public boolean withSearch() {
-    return true;
-  }
-
-  public boolean withTraverse() {
-    return true;
-  }
-
-  public boolean withWarm() {
-    return false;
-  }
-
-  public QueryMaker getQueryMaker() {
-    return getRunData().getSearchTravQueryMaker();
-  }
-
-
 }
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravTask.java
index e5e55612..06db91ac 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravTask.java
@@ -25,8 +25,12 @@
  * 
  * <p>Note: This task reuses the reader if it is already open. 
  * Otherwise a reader is opened at start and closed at the end.
+ * <p/>
+ * 
+ * Takes optional param: traversal size (otherwise all results are traversed).
  */
 public class SearchTravTask extends ReadTask {
+  protected int traversalSize = Integer.MAX_VALUE;
 
   public SearchTravTask(PerfRunData runData) {
     super(runData);
@@ -48,8 +52,25 @@ public boolean withWarm() {
     return false;
   }
 
+  
+
   public QueryMaker getQueryMaker() {
-    return getRunData().getSearchTravRetQueryMaker();
+    return getRunData().getQueryMaker(this);
+  }
+
+  public int traversalSize() {
+    return traversalSize;
   }
 
+  public void setParams(String params) {
+    super.setParams(params);
+    traversalSize = (int)Float.parseFloat(params);
+  }
+
+  /* (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.tasks.PerfTask#supportsParams()
+   */
+  public boolean supportsParams() {
+    return true;
+  }
 }
diff --git a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SetPropTask.java b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SetPropTask.java
index 0e3ce9f4..6a5ad083 100644
--- a/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SetPropTask.java
+++ b/lucene/java/trunk/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SetPropTask.java
@@ -24,7 +24,8 @@
  * A property may have a single value, or a sequence of values, seprated by ":". 
  * If a sequence of values is specified, each time a new round starts, 
  * the next (cyclic) value is taken.  
- * Other side effects: none.
+ * <br>Other side effects: none.
+ * <br>Takes mandatory param: "name,value" pair. 
  * @see org.apache.lucene.benchmark.byTask.tasks.NewRoundTask
  */
 public class SetPropTask extends PerfTask {
@@ -55,4 +56,11 @@ public void setParams(String params) {
     value = params.substring(k+1).trim();
   }
 
+  /* (non-Javadoc)
+   * @see org.apache.lucene.benchmark.byTask.tasks.PerfTask#supportsParams()
+   */
+  public boolean supportsParams() {
+    return true;
+  }
+
 }
