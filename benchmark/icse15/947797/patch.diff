diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/NetHarnessJavaTest.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/NetHarnessJavaTest.java
index a3e19375..c6d37cdf 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/NetHarnessJavaTest.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/NetHarnessJavaTest.java
@@ -38,18 +38,14 @@ Licensed to the Apache Software Foundation (ASF) under one or more
  * The following tests could not be run this way, reasons for the
  * 
  * dblook_test_net - filters output
- * dataSourcePermissions_net - InvocationTargetException, needs investigation
  * dblook_test_net_territory - filters output 
  * getCurrentProperties - ExceptionInInitializerError, needs investigation
  * maxthreads - forks VM
  * runtimeinfo" - filters output
  * sysinfo" - forks VM
  * sysinfo_withproperties" - forks VM
- * testProperties" - filters output
- * testconnection" - forks VM
  * testij" - filters output
  * timeslice" - forks VM
- * NSinSameJVM" - filters output
  * DerbyNetAutoStart" - forks VM
  */
 public class NetHarnessJavaTest extends HarnessJavaTest {
diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/SecureServerTest.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/SecureServerTest.java
index 8893843f..0e2701ac 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/SecureServerTest.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/SecureServerTest.java
@@ -497,9 +497,9 @@ private static  String  serverBootedOK()
     private boolean serverCameUp()
         throws Exception
     {
-        return NetworkServerTestSetup.pingForServerStart(
+        return NetworkServerTestSetup.pingForServerUp(
             NetworkServerTestSetup.getNetworkServerControl(),
-            nsTestSetup.getServerProcess());
+            nsTestSetup.getServerProcess(), true);
     }
 
 }
diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/ServerPropertiesTest.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/ServerPropertiesTest.java
index e69de29b..babee633 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/ServerPropertiesTest.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/ServerPropertiesTest.java
@@ -0,0 +1,660 @@
+/*
+
+   Derby - Class org.apache.derbyTesting.functionTests.tests.derbynet.ServerPropertiesTest
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+package org.apache.derbyTesting.functionTests.tests.derbynet;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.security.AccessController;
+import java.sql.SQLException;
+import java.util.Enumeration;
+import java.util.Locale;
+import java.util.Properties;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+
+import org.apache.derby.drda.NetworkServerControl;
+import org.apache.derbyTesting.junit.BaseJDBCTestCase;
+import org.apache.derbyTesting.junit.Derby;
+import org.apache.derbyTesting.junit.JDBC;
+import org.apache.derbyTesting.junit.NetworkServerTestSetup;
+import org.apache.derbyTesting.junit.SecurityManagerSetup;
+import org.apache.derbyTesting.junit.SupportFilesSetup;
+import org.apache.derbyTesting.junit.TestConfiguration;
+import org.apache.derbyTesting.junit.Utilities;
+
+/** 
+ * This test tests the derby.properties, system properties and command line
+ * parameters to make sure the pick up settings in the correct order. 
+ * Search order is:
+ *     command line parameters
+ *     System properties
+ *     derby.properties
+ *     default     
+ * The command line should take precedence
+ * 
+ * The test also tests start server by specifying system properties without
+ * values; in this case the server will use default values.
+ */
+
+public class ServerPropertiesTest  extends BaseJDBCTestCase {
+    
+    // helper state for intercepting server error messages;
+    // needed by fixture testToggleTrace
+    private InputStream[]  _inputStreamHolder;
+    
+    //create own policy file
+    private static String POLICY_FILE_NAME = 
+        "functionTests/tests/derbynet/ServerPropertiesTest.policy";
+    private static String TARGET_POLICY_FILE_NAME = "server.policy";
+    private int[] portsSoFar;
+    
+    public ServerPropertiesTest(String name) {
+        super(name);
+        _inputStreamHolder = new InputStream[1];
+    }
+    
+    public static Test suite()
+    {
+        TestSuite suite = new TestSuite("ServerPropertiesTest");
+          
+        if (!Derby.hasServer()) return suite;
+        // don't run with JSR169 for 1. this is network server and
+        // 2. the java executable may be named differently
+        if (JDBC.vmSupportsJSR169()) return suite;
+        
+        // this fixture doesn't use a client/server setup, instead does the 
+        // relevant starting/stopping inside the test
+        // Add security manager policy that allows executing java commands
+        suite.addTest(decorateTest("ttestSetPortPriority", 
+                new String[] {}, new String[] {}, false));
+        
+        // test unfinished properties settings. 
+        // decorateTest adds policy file and sets up properties
+        // the properties settings are incorrect i.e. they have no value
+        String[] badServerProperties = {
+                "derby.drda.logConnections=",
+                "derby.drda.traceAll=",
+                "derby.drda.traceDirectory=",
+                "derby.drda.keepAlive=",
+                "derby.drda.timeSlice=",
+                "derby.drda.host=",
+                "derby.drda.portNumber=",
+                "derby.drda.minThreads=",
+                "derby.drda.maxThreads=",
+                "derby.drda.startNetworkServer=",
+                "derby.drda.debug="
+                };
+        // fixture hits error DRDA_MissingNetworkJar (Cannot find derbynet.jar) so,
+        // only run with jars
+        if (TestConfiguration.loadingFromJars())
+            suite.addTest(decorateTest("ttestDefaultProperties", 
+                badServerProperties, new String[] {}, true));
+        
+        // The other fixtures, testToggleTrace (trace on/off), 
+        // testToggleLogConnections (logconnections on/off) , and
+        // testWrongCommands can all use the default setup with adjusted policy
+        
+        // need english locale so we can compare command output for those tests 
+        if (!Locale.getDefault().getLanguage().equals("en"))
+            return suite;
+        
+        Test test = TestConfiguration
+            .clientServerSuite(ServerPropertiesTest.class);
+        
+        // Install a security manager using the special policy file.
+        test = decorateWithPolicy(test);
+        suite.addTest(test);
+        return suite;
+    }
+    
+    public void tearDown() throws Exception {
+        super.tearDown();
+        POLICY_FILE_NAME = null;
+        TARGET_POLICY_FILE_NAME = null;
+        _inputStreamHolder = null;
+        if (portsSoFar != null)
+        {
+            for (int i = 0 ; i < portsSoFar.length ; i++)
+            {
+                try {
+                    shutdownServer(portsSoFar[i], true);
+                } catch (SQLException e) {
+                    fail("could not shutdown server at port " + portsSoFar[i]);
+                }
+            }
+            portsSoFar=null;
+        }
+    }
+    
+    /**
+     * <p>
+     * Compose the required decorators to bring up the server in the correct
+     * configuration.
+     * </p>
+     */
+    private static Test decorateTest(String testName, 
+            String[] startupProperties, String[] startupArgs,
+            boolean startServer)
+    {
+        ServerPropertiesTest spt = new ServerPropertiesTest(testName);
+        String [] startupProps;
+        if (startupProperties == null)
+            startupProps = new String[] {};
+        else
+            startupProps = startupProperties;
+        if (startupArgs == null)
+            startupArgs = new String[]{};
+        NetworkServerTestSetup networkServerTestSetup;
+        if (startServer)
+        {
+            // start networkServer as a process
+            networkServerTestSetup = new NetworkServerTestSetup(
+                spt, startupProps, startupArgs, true, true, spt._inputStreamHolder);
+        }
+        else
+        {
+            // get networkserver setup but don't start anything
+            networkServerTestSetup = new NetworkServerTestSetup(
+                spt, true, false);
+        }
+        Test test = decorateWithPolicy(networkServerTestSetup);
+        test = TestConfiguration.defaultServerDecorator(test);
+        return test;
+    }   
+    
+    /**
+     * Construct the name of the server policy file.
+     */
+    private String makeServerPolicyName()
+    {
+        try {
+            String  userDir = getSystemProperty( "user.dir" );
+            String  fileName = userDir + File.separator + SupportFilesSetup.EXTINOUT + File.separator + TARGET_POLICY_FILE_NAME;
+            File      file = new File( fileName );
+            String  urlString = file.toURL().toExternalForm();
+
+            return urlString;
+        }
+        catch (Exception e)
+        {
+            System.out.println( "Unexpected exception caught by makeServerPolicyName(): " + e );
+
+            return null;
+        }
+    }
+    
+    // grant ALL FILES execute, and getPolicy permissions,
+    // as well as write for the trace files.
+    private static Test decorateWithPolicy(Test test) {
+        String serverPolicyName = new ServerPropertiesTest("test").makeServerPolicyName();
+        //
+        // Install a security manager using the initial policy file.
+        //
+        test = new SecurityManagerSetup(test,serverPolicyName );
+        // Copy over the policy file we want to use.
+        //
+        test = new SupportFilesSetup(
+            test, null, new String[] {POLICY_FILE_NAME},
+            null, new String[] {TARGET_POLICY_FILE_NAME}
+        );
+        return test;
+    }
+ 
+    private static Properties getTheProperties() {
+        Properties p;
+        try {
+            p = NetworkServerTestSetup.getNetworkServerControl().getCurrentProperties();
+        } catch (Exception e) {
+            p = null; // should be ok to set to null (to satisfy compiler)
+            // as fail will exit without further checks.
+            e.printStackTrace();
+            fail("unexpected exception getting properties from server");
+        }
+        return p;
+    }
+
+    // check for 1 Property/Value pair, passing in expected as a String
+    // "<propertyName>=<expectedPropertyValue>"
+    private static void verifyProperties(String expectedPropAndValue) {
+        Properties p = getTheProperties();
+        assertPropertyValueCorrect(p, expectedPropAndValue);
+        p=null;
+    }
+ 
+    // check for an array of Property/Value pairs, passing each expected pair 
+    // in as a String "<propertyName>=<expectedPropertyValue>"
+    private static void verifyProperties(String[] expectedValues) { 
+        Properties p = getTheProperties();
+        // for debugging:
+        for (int i=0 ; i<expectedValues.length; i++){
+            println("expV: " + expectedValues[i]);
+        }
+        assertEquals(expectedValues.length , p.size());
+        for ( int i = 0 ; i < expectedValues.length ; i++)
+        {
+            assertPropertyValueCorrect(p, expectedValues[i]);
+        }
+        p = null;
+    }
+ 
+    private static void assertPropertyValueCorrect(Properties p, String expectedPropAndValue) {
+        String[] expPropValueString = expectedPropAndValue.split("=");
+        try {
+            // for debugging
+            String actualPropertyValue = p.getProperty(expPropValueString[0]);
+            println("exppropName: " + expPropValueString[0]);
+            println("exppropValue: " + expPropValueString[1]);
+            println("actualpropValue: " + actualPropertyValue);
+            assertEquals(expPropValueString[1],actualPropertyValue);
+        } catch(Exception e) {
+            fail("could not find property " + expPropValueString[0]);
+        }
+    }
+    
+    public int getAlternativePort() throws SQLException {
+
+        Exception failException = null;
+        // start with the default port + 1
+        // there may be a smarter way to get the starting point...
+        int possiblePort = TestConfiguration.getCurrent().getPort();
+        if (!(possiblePort > 0))
+            possiblePort = 1528;
+        else
+            possiblePort = possiblePort + 1;
+        try {
+            boolean portOK = false;
+            while (!portOK) {
+                // check for first one in use
+                NetworkServerControl networkServer =
+                    new NetworkServerControl(InetAddress.getByName("localhost"), possiblePort);
+                // Ping and wait for the network server to reply
+                boolean started = false;
+
+                try {
+                    networkServer.ping();
+                    // If ping throws no exception the server is running
+                    started = true;
+                } catch(Exception e) {         
+                    failException = e;
+                }
+                // Check if we got a reply on ping
+                if (!started) {
+                    // we'll assume we can use this port. 
+                    // If there was some other problem with the pinging, it'll
+                    // become clear when someone attempts to use the port
+                    portOK = true;
+                }
+                else { // this port's in use.
+                    possiblePort = possiblePort + 1;
+                }
+            }
+        } catch (Exception e) {
+            SQLException se = new SQLException("Error pinging network server");
+            se.initCause(failException);
+            throw se;
+        }        
+        return possiblePort;
+    }
+    
+    /**
+     *  Ping for the server to be up - or down.
+     *  @param port port number to be used in the ping
+     *  @param expectServerUp indicator whether the server is expected to be up
+     */
+    private boolean canPingServer(int port, boolean expectServerUp) 
+    throws SQLException {
+        
+        boolean serverUp = false;
+        try {
+            serverUp = NetworkServerTestSetup.pingForServerUp(
+                NetworkServerTestSetup.getNetworkServerControl(port), null,
+                expectServerUp);
+        } catch (Exception e) {
+            fail("unexpected Exception while pinging");
+        }
+        return serverUp;
+    }
+    
+    // obtain & shutdown the network server;
+    // port needs to be passed in to verify it's down;
+    private String shutdownServer(int port, boolean specifyPort) 
+    throws SQLException {
+        try {
+            if (specifyPort)
+            {
+                NetworkServerControl nsctrl = 
+                    NetworkServerTestSetup.getNetworkServerControl(port);
+                nsctrl.shutdown();
+            }
+            else
+            {
+                NetworkServerControl nsctrl = 
+                    NetworkServerTestSetup.getNetworkServerControlDefault();
+                nsctrl.shutdown();
+            }
+        } catch (Exception e) {
+            return "failed to shutdown server with API parameter";
+        }
+        if (canPingServer(port,false)) {
+            return "Can still ping server";
+        }
+        return null;
+    }
+
+
+    // obtain & start the network server without specifying port;
+    // port needs to be passed in to verify it's up.
+    public String startServer(int port, boolean specifyPort) 
+    throws SQLException {
+        try {
+            if (specifyPort)
+            {
+                NetworkServerControl nsctrl = 
+                    NetworkServerTestSetup.getNetworkServerControl(port);
+                // For debugging, to make output come to console uncomment:
+                //nsctrl.start(new PrintWriter(System.out, true));
+                // and comment out:
+                nsctrl.start(null);
+                NetworkServerTestSetup.waitForServerStart(nsctrl);
+            }
+            else
+            {
+                NetworkServerControl nsctrl = 
+                    NetworkServerTestSetup.getNetworkServerControlDefault();
+                // For debugging, to make output come to console uncomment:
+                //nsctrl.start(new PrintWriter(System.out, true));
+                // and comment out:
+                nsctrl.start(null);
+                NetworkServerTestSetup.waitForServerStart(nsctrl);
+            }
+        } catch (Exception e) {
+            return "failed to start server with port " + port;
+        }
+        // check that we have this server up now
+        if (!canPingServer(port, true)) {
+            return "Cannot ping server started with port set to " + port;
+        }
+        return null;
+    }
+    
+   public void checkWhetherNeedToShutdown(int[] ports, String failReason) {
+       
+       portsSoFar = ports;
+       if (!(failReason == null))
+       {
+           fail(failReason);
+       }
+   }
+   
+   /**
+    * Execute command and verify that it completes successfully
+    * @param Cmd array of java arguments for command
+    * @throws InterruptedException
+    * @throws IOException
+    */
+   private void  assertSuccessfulCmd(String expectedString, String[] Cmd) throws InterruptedException, IOException {
+       assertExecJavaCmdAsExpected(new String[] {expectedString}, Cmd, 0);
+   }
+
+    /**
+     *  Test port setting priority
+     */
+    public void ttestSetPortPriority() 
+    throws SQLException, InterruptedException, IOException {
+        // default is 1527. The test harness configuration would
+        // use the API and add the port number. We want to test all
+        // 4 mechanisms for specifying the port.
+        // To ensure getting a unique port number, this test leaves open
+        // each server for a bit.
+        // as we need to test the default as well as with setting various
+        // properties, this test can't rely on the testsetup.
+
+        // So, first, bring default server down if up
+        // Note: if the harness gets modified to accomodate splitting
+        //    over different networkservers, there maybe something more
+        //    appropriate than shutting down the default server.
+        // we really expect the server to be down, let's
+        // not do any waiting around
+        NetworkServerTestSetup.setWaitTime(0);
+        if (canPingServer(1527, false)) {
+            // for now, shutdown
+            shutdownServer(1527, false);
+        }
+        NetworkServerTestSetup.setDefaultWaitTime();
+
+        // start the default, which at this point should be localhost and 1527
+        String actionResult = startServer(1527, false);
+        checkWhetherNeedToShutdown(new int[] {1527}, actionResult);
+        
+        // set derby.drda.portNumber to an alternate number in derby.properties
+        int firstAlternatePort = getAlternativePort();
+        final Properties derbyProperties = new Properties();
+        derbyProperties.put("derby.drda.portNumber", 
+                new Integer(firstAlternatePort).toString());
+
+        final String derbyHome = getSystemProperty("derby.system.home");
+        Boolean b = (Boolean)AccessController.doPrivileged
+        (new java.security.PrivilegedAction(){
+            public Object run(){
+                boolean fail = false;
+                try {
+                    FileOutputStream propFile = 
+                        new FileOutputStream(derbyHome + File.separator + "derby.properties");
+                    derbyProperties.store(propFile,"testing derby.properties");
+                    propFile.close();
+                } catch (IOException ioe) {
+                    fail = true;
+                }
+                return new Boolean(fail);
+            }
+        });
+        if (b.booleanValue())
+        {
+            checkWhetherNeedToShutdown(new int[] {1527}, "failed to write derby.properties");
+        }
+        // have to shutdown engine to force read of derby.properties
+        TestConfiguration.getCurrent().shutdownEngine();
+        actionResult = startServer(firstAlternatePort, false);
+        checkWhetherNeedToShutdown(new int[] {1527, firstAlternatePort}, actionResult);
+
+        final int secondAlternatePort = getAlternativePort();
+        // Now set system properties.
+        setSystemProperty("derby.drda.portNumber", 
+            new Integer(secondAlternatePort).toString());
+        actionResult = startServer(secondAlternatePort, false);
+        checkWhetherNeedToShutdown( new int[] {1527, firstAlternatePort, secondAlternatePort},
+            actionResult);
+        
+        // now try with specifying port
+        // Note that we didn't unset the system property yet, nor did
+        // we get rid of derby.properties...
+        // command line parameter should take hold
+        int thirdAlternatePort = getAlternativePort();
+        actionResult = startServer(thirdAlternatePort, true);
+        checkWhetherNeedToShutdown(new int[] {1527, firstAlternatePort, secondAlternatePort,
+            thirdAlternatePort}, actionResult);
+
+        // now with -p. 
+        int fourthAlternatePort = getAlternativePort();
+        String[] commandArray = {"-Dderby.system.home=" + derbyHome,
+            "org.apache.derby.drda.NetworkServerControl", "-p",
+            String.valueOf(fourthAlternatePort).toString(), 
+            "-noSecurityManager", "start"};
+        execJavaCmd(commandArray);
+        
+        if (!canPingServer(fourthAlternatePort, true)) {
+            actionResult = "Can not ping server specified with -p";
+        }
+        checkWhetherNeedToShutdown(new int[] {1527, firstAlternatePort, secondAlternatePort,
+            thirdAlternatePort, fourthAlternatePort}, actionResult);
+                        
+        // shutdown with -p
+        commandArray = new String[] {"-Dderby.system.home=" + derbyHome,
+                "org.apache.derby.drda.NetworkServerControl", "-p",
+                String.valueOf(fourthAlternatePort).toString(), 
+                "-noSecurityManager", "shutdown"};
+        execJavaCmd(commandArray);
+
+        if (canPingServer(fourthAlternatePort, false)) {
+            actionResult = "Can still ping server specified with -p";
+        }
+        checkWhetherNeedToShutdown(new int[] {1527, firstAlternatePort, secondAlternatePort,
+            thirdAlternatePort, fourthAlternatePort}, actionResult);
+            
+        // shutdown with port specified in constructor
+        actionResult = shutdownServer(thirdAlternatePort, true);
+        checkWhetherNeedToShutdown( new int[] {1527, firstAlternatePort, secondAlternatePort,
+            thirdAlternatePort}, actionResult);
+        
+        // shutdown using System property
+        actionResult = shutdownServer(secondAlternatePort, false);
+        checkWhetherNeedToShutdown ( new int[] {1527, firstAlternatePort, secondAlternatePort},
+            actionResult);
+        // remove system property
+        removeSystemProperty("derby.drda.portNumber");
+
+        // shutdown server with port set in derby.properties
+        actionResult = shutdownServer(firstAlternatePort, false);
+        checkWhetherNeedToShutdown ( new int[] {1527, firstAlternatePort},
+            actionResult);
+        // remove derby.properties
+        Boolean ret = (Boolean) AccessController.doPrivileged
+        (new java.security.PrivilegedAction() {
+            public Object run() {
+                return Boolean.valueOf((new File(
+                    derbyHome+File.separator + "derby.properties")).delete());
+            }
+        }
+        );
+        if (ret.booleanValue() == false) {
+            checkWhetherNeedToShutdown ( new int[] {1527, firstAlternatePort},
+                "unable to remove derby.properties");
+        }
+        // have to shutdown engine to force re-evaluation of derby.properties
+        TestConfiguration.getCurrent().shutdownEngine();
+        
+        // shutdown the default server
+        actionResult = shutdownServer(1527, false);
+        checkWhetherNeedToShutdown ( new int[] {1527}, actionResult);
+    }
+    
+    /**
+     *   Test start server specifying system properties without values
+     */
+    public void ttestDefaultProperties() throws SQLException
+    {
+        //check that default properties are used
+        verifyProperties(new String[] {
+                "derby.drda.maxThreads=0", 
+                "derby.drda.sslMode=off", 
+                "derby.drda.keepAlive=true", 
+                "derby.drda.minThreads=0", 
+                "derby.drda.portNumber=" + 
+                    String.valueOf(TestConfiguration.getCurrent().getPort()),
+                "derby.drda.logConnections=false", 
+                "derby.drda.timeSlice=0", 
+                "derby.drda.startNetworkServer=false",
+                "derby.drda.host=" +
+                    String.valueOf(TestConfiguration.getCurrent().getHostName()), 
+                "derby.drda.traceAll=false"});
+    }
+       
+    /**
+     *   Test trace command on - property traceAll should get set
+     */
+    public void testToggleTrace() 
+    throws SQLException, IOException, InterruptedException
+    {        
+        // we only care about the traceAll property, the rest will be unchanged
+        String expectedTraceOff = "derby.drda.traceAll=false";
+        String expectedTraceOn = "derby.drda.traceAll=true";      
+
+        verifyProperties(expectedTraceOff);     
+
+        String[] traceCmd = new String[] {
+            "org.apache.derby.drda.NetworkServerControl", "trace", "on" };
+        assertSuccessfulCmd("Trace turned on for all sessions.", traceCmd);
+        verifyProperties(expectedTraceOn);     
+
+        traceCmd = new String[] {
+                "org.apache.derby.drda.NetworkServerControl", "trace", "off" };
+        assertSuccessfulCmd("Trace turned off for all sessions", traceCmd);
+        // traceAll should be back to false
+        verifyProperties(expectedTraceOff);     
+    }
+
+    /**
+     *   Test logconnections on
+     */
+    public void testToggleLogConnections() 
+    throws SQLException, IOException, InterruptedException
+    {
+        // only care about the LogConnections property; the rest is unchanged
+        String expectedLogConnectionsOff = "derby.drda.logConnections=false";
+        String expectedLogConnectionsOn = "derby.drda.logConnections=true";       
+ 
+        verifyProperties(expectedLogConnectionsOff);     
+
+        String[] cmd = new String[] {
+            "org.apache.derby.drda.NetworkServerControl", "logconnections", "on" };
+        assertSuccessfulCmd("Log Connections changed to on.", cmd);
+        verifyProperties(expectedLogConnectionsOn);     
+
+        cmd = new String[] {
+                "org.apache.derby.drda.NetworkServerControl", "logconnections", "off" };
+        assertSuccessfulCmd("Log Connections changed to off.", cmd);
+        // traceAll should be back to false
+        verifyProperties(expectedLogConnectionsOff);    
+    }
+
+    
+    /**
+     *   Test other commands. These should all give a helpful error and the
+     *   usage message
+     *   Note: maybe these test cases should be moved to another Test,
+     *   as they don't actually test any properties. 
+     */
+    public void testWrongCommands() 
+    throws SQLException, IOException, InterruptedException
+    {
+        String nsc = "org.apache.derby.drda.NetworkServerControl";
+        // no arguments
+        String[] cmd = new String[] {nsc};
+        // we'll assume that we get the full message if we get 'Usage'
+        // because sometimes, the message gets returned with carriage return,
+        // and sometimes it doesn't, checking for two different parts...
+        assertExecJavaCmdAsExpected(new String[] 
+            {"No arguments given.", "Usage: "}, cmd, 1);
+        //Unknown command
+        cmd = new String[] {nsc, "unknowncmd"};
+        assertExecJavaCmdAsExpected(new String[] 
+            {"Command unknowncmd is unknown.", "Usage: "}, cmd, 0);
+        // wrong number of arguments
+        cmd = new String[] {nsc, "ping", "arg1"};
+        assertExecJavaCmdAsExpected(new String[] 
+            {"Invalid number of arguments for command ping.",
+             "Usage: "}, cmd, 1);
+    }
+}
diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/SysinfoTest.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/SysinfoTest.java
index e69de29b..e1a243ba 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/SysinfoTest.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/SysinfoTest.java
@@ -0,0 +1,346 @@
+/*
+
+   Derby - Class 
+   org.apache.derbyTesting.functionTests.tests.derbynet.SysinfoTest
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+package org.apache.derbyTesting.functionTests.tests.derbynet;
+
+import java.io.File;
+import java.net.URL;
+import java.security.AccessController;
+import java.util.Properties;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+
+import org.apache.derbyTesting.junit.BaseJDBCTestCase;
+import org.apache.derbyTesting.junit.Derby;
+import org.apache.derbyTesting.junit.JDBC;
+import org.apache.derbyTesting.junit.NetworkServerTestSetup;
+import org.apache.derbyTesting.junit.SecurityManagerSetup;
+import org.apache.derbyTesting.junit.SupportFilesSetup;
+import org.apache.derbyTesting.junit.SystemPropertyTestSetup;
+import org.apache.derbyTesting.junit.TestConfiguration;
+
+/**
+	This tests the sysinfo command
+ */
+
+public class SysinfoTest extends BaseJDBCTestCase {
+
+    private static String TARGET_POLICY_FILE_NAME="sysinfo.policy";
+    private String [] OUTPUT;
+
+    /**
+     * Set to true before adding a test to the suite to add some extra properties.
+     */
+    private static boolean useProperties = false;
+
+
+    /**
+     * Default constructor
+     * @param name
+     */
+    public SysinfoTest(String name) {
+        super(name);
+        /**
+         * Output from sysinfo without the extra properties. 
+         */
+        String [] OUTPUT1 = {
+            "--------- Derby Network Server Information --------" , 
+            "derby.drda.maxThreads=0" ,
+            "derby.drda.sslMode=off" , 
+            "derby.drda.keepAlive=true" , 
+            "derby.drda.minThreads=0" , 
+            "derby.drda.portNumber=1527" , 
+            "derby.drda.logConnections=false" ,
+            "derby.drda.timeSlice=0" , 
+            "derby.drda.startNetworkServer=false" , 
+            "derby.drda.traceAll=false" ,
+            "--------- Derby Information --------" , 
+            "------------------------------------------------------" , 
+            "----------------- Locale Information -----------------" , 
+            "------------------------------------------------------"};
+
+        /**
+         * Output by sysinfo with the extra properties.
+         */
+        String [] OUTPUT2 = {
+            "--------- Derby Network Server Information --------" , 
+            "derby.drda.securityMechanism=USER_ONLY_SECURITY" , 
+            "derby.drda.maxThreads=0" ,
+            "derby.drda.sslMode=off" ,
+            "derby.drda.keepAlive=true" , 
+            "derby.drda.minThreads=0" , 
+            "derby.drda.portNumber=1527" , 
+            "derby.drda.logConnections=false" ,
+            "derby.drda.timeSlice=0" ,
+            "derby.drda.startNetworkServer=false" , 
+            "derby.drda.traceAll=false" ,
+            "--------- Derby Information --------" , 
+            "------------------------------------------------------" , 
+            "----------------- Locale Information -----------------" , 
+            "------------------------------------------------------"};
+
+        if (useProperties)
+            OUTPUT = OUTPUT2;
+        else 
+            OUTPUT = OUTPUT1;
+    }
+
+    /**
+     * Creates a suite with two testcases, with and without some extra 
+     * system properties.
+     * 
+     * @return an empty suite if derbynet.jar is not available, and
+     *      if the JVM only supports JSR169, otherwise, return a suite with
+     *      6 tests, 3 with properties set, 3 without.
+     */
+    public static Test suite() {
+        TestSuite suite = new TestSuite("SysinfoTest");
+
+        // we need to be able to run the server
+        if (!Derby.hasServer()) return suite;
+        // don't run with JSR169 for this is a network server test
+        if (JDBC.vmSupportsJSR169()) return suite;
+
+        useProperties = false;
+        // a call to sysinfo will eventually attempt to load resource 
+        // org.apache.derby.info.DBMS.properties.
+        // If we're using classes, we don't have read permission for the dir.
+        // So, figure out the path & pass the property on so the reference
+        // in the policy file can be resolved.
+        // Note: can't use $derbyTesting.codeclasses as on windows it has
+        // the slashes adjusted.
+        if (!TestConfiguration.loadingFromJars()) {
+            Properties propstmp = new Properties();
+            propstmp.put("sysinfotest.classesdir", findClassDir());
+            suite.addTest(new SystemPropertyTestSetup(decorateTest(), propstmp));
+        }
+        else
+            suite.addTest(decorateTest());
+
+        useProperties = true;
+        Properties props = new Properties();
+        if (!TestConfiguration.loadingFromJars())
+            props.put("sysinfotest.classesdir", findClassDir());
+        props.put("derby.infolog.append","true");
+        props.put("derby.locks.waitTimeout","120");
+        props.put("derby.language.logStatementText","true");
+        //#drda property ,test for it in sysinfo output
+        props.put("derby.drda.securityMechanism","USER_ONLY_SECURITY");
+        suite.addTest(new SystemPropertyTestSetup(decorateTest(), props));
+
+        return suite;
+    }
+
+    private String makePolicyName() {
+        try {
+            String  userDir = getSystemProperty( "user.dir" );
+            String  fileName = userDir + File.separator + 
+            SupportFilesSetup.EXTINOUT + File.separator + TARGET_POLICY_FILE_NAME;
+            File      file = new File( fileName );
+            String  urlString = file.toURL().toExternalForm();
+
+            return urlString;
+        }
+        catch (Exception e) {
+            fail("Unexpected exception caught by " +
+                    "makeServerPolicyName(): " + e );
+            return null;
+        }
+    }
+
+    /**
+     * Decorate a test with SecurityManagerSetup, clientServersuite, and
+     * SupportFilesSetup.
+     * 
+     * @return the decorated test
+     */
+    private static Test decorateTest() {
+        String policyName = new SysinfoTest("test").makePolicyName();
+        Test test = TestConfiguration.clientServerSuite(SysinfoTest.class);
+
+        // Install a security manager using the initial policy file.
+        test = TestConfiguration.singleUseDatabaseDecorator(
+                new SecurityManagerSetup(test, policyName));
+
+        // Copy over the policy file we want to use.
+        String POLICY_FILE_NAME=
+            "functionTests/tests/derbynet/SysinfoTest.policy";
+
+        test = new SupportFilesSetup
+        (
+                test,
+                null,
+                new String[] { POLICY_FILE_NAME },
+                null,
+                new String[] { TARGET_POLICY_FILE_NAME}
+        );
+        return test;
+    }
+
+    /**
+     * Test sysinfo
+     * 
+     * @throws Exception
+     */	
+    public void testSysinfo() throws Exception {
+        String[] SysInfoCmd = 
+            new String[] {"org.apache.derby.drda.NetworkServerControl", "sysinfo",
+            "-p", String.valueOf(TestConfiguration.getCurrent().getPort())};
+
+        Process p = execJavaCmd(SysInfoCmd);
+        String s = readProcessOutput(p);
+
+        s = sed(s);
+
+        print("testSysinfo", s);
+        assertMatchingStringExists(s);
+    }
+
+    /**
+     * Test sysinfo by calling NetworkServerControl.getSysinfo()
+     * 
+     * @throws Exception
+     */
+    public void testSysinfoMethod() throws Exception {	
+
+        String s = NetworkServerTestSetup.
+        getNetworkServerControl(TestConfiguration.getCurrent().getPort()).getSysinfo();
+        s = sed(s);
+
+        print("testSysinfoMethod", s);
+        assertMatchingStringExists(s);
+    }		
+
+    /**
+     * Test sysinfo w/ foreign (non-English) locale.
+     * 
+     * @throws Exception
+     */
+    public void testSysinfoLocale() throws Exception {
+
+        String[] SysInfoLocaleCmd = 
+            new String[] {"-Duser.language=de", "-Duser.country=DE", 
+                "org.apache.derby.drda.NetworkServerControl", "sysinfo",
+                "-p", String.valueOf(TestConfiguration.getCurrent().getPort())};
+        Process p = execJavaCmd(SysInfoLocaleCmd);
+        String s = readProcessOutput(p);
+        s = sed(s);
+
+        print("testSysinfoLocale", s);
+        assertMatchingStringExists(s);
+    }
+
+    /**
+     * Removes lines containing a number of preset words from the given string.
+     * Also trims the string to make it easier to compare.
+     * 
+     * @param s the string to remove lines from
+     * @return the string with the lines removed
+     */
+    private String sed(String s) {
+        /**
+         * Lines containing these strings will be deleted from the output before
+         * asserting that output is correct.
+         */
+        String[] sed = {"Version", "version", "Java", "OS", 
+                "[0-9*]\\.[0-9*]\\.[0-9*]","JRE - JDBC","derby.drda.traceDirectory",
+                "Unable to access Protection Domain","listing properties",
+                "Current Locale",           //Remove these because locale info is
+                "Found support for locale:" //not printed when running from jars..
+        };                          
+
+        for (int i = 0; i < sed.length; i++) {
+            // first, replace \r\n with \n, that's needed if we're on
+            // windows
+            s = s.replaceAll("\r\n", "\n");
+            s = s.replaceAll("(?m)^.*" + sed[i] + ".*\n", "");
+        }
+        s = s.trim();
+        return s;
+    }
+
+    /**
+     * Prints strings to System.out to make it easier to update the tests
+     * when the output changes if derby.tests.debug is true.
+     * 
+     * @param name just a label to identify the string
+     * @param s the string to be printed
+     */
+    private void print(String name,String s) {
+        println("\n\n>>>" + name + ">>>");
+        println(s);
+        println("<<<" + name + "<<<\n\n");
+    }
+
+    public void tearDown() throws Exception {
+        super.tearDown();
+        TARGET_POLICY_FILE_NAME = null;
+        OUTPUT = null;
+    }
+
+    private static String findClassDir() {
+        URL url = null;
+        try {
+            final Class cl = Class.forName("org.apache.derbyTesting." +
+                    "functionTests.tests.derbynet.SysinfoTest");
+        url = (URL)
+           AccessController.doPrivileged(new java.security.PrivilegedAction() {
+            public Object run() {
+                return cl.getProtectionDomain().getCodeSource().getLocation();
+            }
+        });
+        } catch (ClassNotFoundException e) {
+            // need catch to silence compiler, but as we're referring to *this*
+            // class, it ok to ignore this.
+        }
+        return url.getPath();
+    }
+    
+    private void assertMatchingStringExists(String actualOutput) {
+        String delimiter = "\n";
+        String [] actualOutputArray = actualOutput.split(delimiter);
+        int lineCount = actualOutputArray.length;
+        assertEquals(OUTPUT.length, lineCount);
+        for (int i=0 ; i<lineCount ; i++)
+        {
+            String fullExpOutput="";
+            for (int j=0 ; j < OUTPUT.length; j++) {
+                fullExpOutput=fullExpOutput + OUTPUT[j] + "\n";
+            }
+            String ns = actualOutputArray[i];
+            assertTrue("Output string: " + ns + 
+                "\ndoesn't match any of the expected strings: \n" + 
+                fullExpOutput,
+                searchMatchingString(ns));
+        }
+    }
+        
+    private boolean searchMatchingString(String substring){
+        for (int i=0; i<OUTPUT.length;i++)
+        {
+            if (!substring.equals(OUTPUT[i]))
+                continue;
+            else return true;
+        }
+        return false;
+    }
+}
diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/_Suite.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/_Suite.java
index d8f63c40..41930aa2 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/_Suite.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/_Suite.java
@@ -54,11 +54,13 @@ public static Test suite() {
         suite.addTest(BadConnectionTest.suite());
         suite.addTest(NetHarnessJavaTest.suite());
         suite.addTest(SecureServerTest.suite());
+        suite.addTest(SysinfoTest.suite());
         suite.addTest(SSLTest.suite());
         suite.addTest(NetIjTest.suite());
         suite.addTest(LOBLocatorReleaseTest.suite());
         suite.addTest(NSinSameJVMTest.suite());
         suite.addTest(GetCurrentPropertiesTest.suite());
+        suite.addTest(ServerPropertiesTest.suite());
 
 
         // Disabled due to "java.sql.SQLSyntaxErrorException: The class
diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/sysinfo.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/sysinfo.java
index 2921b096..e69de29b 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/sysinfo.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/sysinfo.java
@@ -1,107 +0,0 @@
-/*
-
-   Derby - Class org.apache.derbyTesting.functionTests.tests.derbynet.sysinfo
-
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to You under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-package org.apache.derbyTesting.functionTests.tests.derbynet;
-
-import java.sql.*;
-import java.util.Vector;
-import java.util.Properties;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.BufferedOutputStream;
-import java.net.InetAddress;
-
-import org.apache.derbyTesting.functionTests.harness.jvm;
-import org.apache.derbyTesting.functionTests.util.ExecProcUtil;
-import org.apache.derby.drda.NetworkServerControl;
-import org.apache.derby.tools.ij;
-
-/**
-	This tests the sysinfo command
-*/
-
-public class sysinfo
-{
-
-	private static Properties properties = new java.util.Properties();
-	private static jvm jvm;
-	private static Vector vCmd;
-	private static BufferedOutputStream bos;
-	private static String[] SysInfoCmd = new String[] {"org.apache.derby.drda.NetworkServerControl",
-		"sysinfo"};
-	private static String[] SysInfoLocaleCmd = new String[] {"-Duser.language=err",
-		"-Duser.country=DE", "org.apache.derby.drda.NetworkServerControl", "sysinfo"};
-
-    /*
-     * Test calling server's sysinfo 
-     * 
-     */
-	public static void test (String args[])
-        throws Exception
-	{
-		if ((System.getProperty("java.vm.name") != null) && System.getProperty("java.vm.name").equals("J9"))
-			jvm = jvm.getJvm("j9_13");
-		else
-			jvm = jvm.getJvm("currentjvm");		// ensure compatibility
-		vCmd = jvm.getCommandLine();
-		try
-		{
-			Connection conn1 = ij.startJBMS();
-            bos = new BufferedOutputStream(System.out, 1024);
-
-			/************************************************************
-			 *  Test sysinfo
-			 ************************************************************/
-			System.out.println("Testing Sysinfo");
-			ExecProcUtil.execCmdDumpResults(SysInfoCmd,vCmd,bos);	
-			System.out.println("End test");
-			
-			/************************************************************
-			 *  Test sysinfo by calling NetworkServerControl.getSysinfo()
-			 ************************************************************/
-			System.out.println("Testing Sysinfo (method)");
-			NetworkServerControl derbyServer = 
-				new NetworkServerControl( InetAddress.getByName("localhost"),
-										NetworkServerControl.DEFAULT_PORTNUMBER);
-			System.out.println(derbyServer.getSysinfo());
-			System.out.println("End test (method)");
-			
-			/************************************************************
-			 *  Test sysinfo w/ foreign (non-English) locale
-			 ************************************************************/
-			System.out.println("Testing Sysinfo (locale)");
-			ExecProcUtil.execCmdDumpResults(SysInfoLocaleCmd,vCmd,bos);	
-			System.out.println("End test (locale)");
-
-			bos.close();
-		}
-		catch (Exception e)
-		{
-			e.printStackTrace();
-		}
-	}
-    
-    public static void main(String[] args)
-        throws Exception
-    {
-       test(args);
-    }
-
-}
diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/sysinfo_withproperties.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/sysinfo_withproperties.java
index 1da4e140..e69de29b 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/sysinfo_withproperties.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/sysinfo_withproperties.java
@@ -1,42 +0,0 @@
-/*
-
-   Derby - Class org.apache.derbyTesting.functionTests.tests.derbynet.sysinfo_withproperties
-
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to You under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-package org.apache.derbyTesting.functionTests.tests.derbynet;
-
-/**
-	Purpose of this class is to test the sysinfo command when 
-    server is started with some drda properties. The derby properties
-    in the test harness framework are added to 
-    sysinfo_withproperties_derby.properties.
-    
-    Most of the work of calling sysinfo is done in sysinfo.
-    @see sysinfo#test 
-*/
-
-public class sysinfo_withproperties
-{
-	public static void main (String args[]) throws Exception
-	{
-        // test the sysinfo calls.
-        sysinfo.test(args);
-        
-	}
-
-}
diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/testProperties.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/testProperties.java
index 49e2d507..e69de29b 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/testProperties.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/testProperties.java
@@ -1,384 +0,0 @@
-/*
-
-   Derby - Class org.apache.derbyTesting.functionTests.tests.derbynet.testProperties
-
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to You under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-package org.apache.derbyTesting.functionTests.tests.derbynet;
-
-import java.sql.*;
-import java.util.Vector;
-import java.util.Properties;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.BufferedOutputStream;
-import java.net.InetAddress;
-
-import org.apache.derbyTesting.functionTests.harness.jvm;
-import org.apache.derbyTesting.functionTests.harness.ProcessStreamResult;
-
-import org.apache.derby.drda.NetworkServerControl;
-
-/**
-	This test tests the derby.properties, system properties and 
-	command line parameters to make sure the pick up settings in
-	the correct order. Search order is:
-	   command line parameters
-	   System properties
-	   derby.properties
-	   default
-
-	   The command line should take precedence
-
-	It also tests start server by specifying system properties without values.
-	In this case the server will use default values.
-*/
-
-public class testProperties
-{
-
-	private static Properties properties = new java.util.Properties();
-	private static jvm jvm;
-	private static Vector vCmd;
-    private static  BufferedOutputStream bos = null;
-    
-    /**
-     * For each new exec process done as part of this test, set 
-     * timeout for ProcessStreamResult after which the thread that 
-     * handles the streams for the process exits.  Timeout is in minutes. 
-     * Note: timeout handling will only come into effect when 
-     * ProcessStreamResult#Wait() is called
-     */
-    private static String timeoutMinutes = "2";
-
-    //Command to start server specifying system properties without values
-    private static String[] startServerCmd =
-					new String[] {  "-Dderby.drda.logConnections",
-    								"-Dderby.drda.traceAll",
-									"-Dderby.drda.traceDirectory",
-									"-Dderby.drda.keepAlive",
-									"-Dderby.drda.timeSlice",
-									"-Dderby.drda.host",
-									"-Dderby.drda.portNumber",
-									"-Dderby.drda.minThreads",
-									"-Dderby.drda.maxThreads",
-									"-Dderby.drda.startNetworkServer",
-									"-Dderby.drda.debug",
-									"org.apache.derby.drda.NetworkServerControl",
-									"start",
-									"-noSecurityManager",};
-    
-    //No arguments
-    private static String[] cmdWithoutArgs =
-					new String[] {  "org.apache.derby.drda.NetworkServerControl"};
-    
-    //Unknown command
-    private static String[] cmdUnknown =
-					new String[] {  "org.apache.derby.drda.NetworkServerControl",
-    								"unknowncmd"};
-    
-    //wrong no: of arguments
-    private static String[] cmdWithWrongArgNum =
-					new String[] {  "org.apache.derby.drda.NetworkServerControl",
-    								"ping",
-									"arg1"};
-    
-    //trace on
-    private static String[] cmdTraceOn =
-					new String[] {  "org.apache.derby.drda.NetworkServerControl",
-    								"trace",
-									"on",
-									"-p",
-									"1527"};
-    
-    //trace off
-    private static String[] cmdTraceOff =
-		new String[] {  "org.apache.derby.drda.NetworkServerControl",
-						"trace",
-						"off",
-						"-p",
-						"1527"};
-    
-    //logconnections on
-    private static String[] cmdLogconnectionsOn =
-					new String[] {  "org.apache.derby.drda.NetworkServerControl",
-    								"logconnections",
-									"on",
-									"-p",
-									"1527"};	
-    /**
-	 * Execute the given command and optionally wait and dump the results to standard out
-	 *
-	 * @param args	command and arguments
-	 * @param wait  true =wait for either completion or timeout time and dump output, 
-     * false don't wait and ignore the output.
-	 * @exception Exception
-	 */
-
-	private static void execCmdDumpResults (String[] args, boolean wait) throws Exception
-	{
-        // We need the process inputstream and errorstream
-        ProcessStreamResult prout = null;
-        ProcessStreamResult prerr = null;
-            
-        System.out.flush();
-        bos.flush();
-        
-        BufferedOutputStream _bos = bos;
-        if (!wait) {
-            // not interested in the output, don't expect a huge amount.
-            // information will just be written to the byte array in
-            // memory and never used.
-            _bos = new BufferedOutputStream(new ByteArrayOutputStream());
-        }
-		// Start a process to run the command
-		Process pr = execCmd(args);
-        
-        // Note, the timeout handling will only come into effect when we make
-        // the Wait() call on ProcessStreamResult. 
-        prout = new ProcessStreamResult(pr.getInputStream(), _bos, timeoutMinutes);
-        prerr = new ProcessStreamResult(pr.getErrorStream(), _bos, timeoutMinutes);
-        
-        if (!wait)
-            return;
-
-		// wait until all the results have been processed or if we timed out
-		prout.Wait();
-		prerr.Wait();
-        _bos.flush();
-        System.out.flush();
-
-	}
-
-
-	private static Process execCmd (String[] args) throws Exception
-	{
-        StringBuffer sb = new StringBuffer();
-            
-        for (int i = 0; i < args.length; i++)
-        {
-            sb.append(args[i] + " ");                    
-        }
-        System.out.println(sb.toString());
-		int totalSize = vCmd.size() + args.length;
-		String serverCmd[] = new String[totalSize];
-		int i;
-		for (i = 0; i < vCmd.size(); i++)
-		{
-			serverCmd[i] = (String)vCmd.elementAt(i);
-		}
-		int j = 0;
-		for (; i < totalSize; i++)
-		{
-			serverCmd[i] = args[j++];
-		}
- 
-		// Start a process to run the command
-		Process pr = Runtime.getRuntime().exec(serverCmd);
-		return pr;
-	}
-
-
-	/** 
-	 * Issue derbyServer command if port is null, NetworkServerControl <cmd>
-	 * else  NetworkServerControl <cmd> -p <portstring>
-	 */
-	private static void derbyServerCmd(String cmd, String  portString) throws Exception
-	{
-		String [] cmdArr = null;
-		// For start we don't wait or capture results, just 
-		// rely on test Connection to verify the start.
-		boolean wait = (cmd.equals("start")) ? false : true;
-		
-		if (portString == null)
-			cmdArr  = new String[] {"org.apache.derby.drda.NetworkServerControl", cmd};
-		else if (portString.startsWith("-D"))
-			cmdArr = new String[]
-			 {portString,"org.apache.derby.drda.NetworkServerControl", cmd};
-		else
-			cmdArr = new String[] {"org.apache.derby.drda.NetworkServerControl", cmd,"-p", portString};
-		
-        cmdArr = unsecure( cmd, cmdArr );
-        
-        execCmdDumpResults(cmdArr, wait);
-	}	
-
-    /**
-     * Add the "-noSecurityManager" option to the arguments of the start command. This
-     * prevents the server from choking on the fact that authentication isn't
-     * required. This allows the test to go ahead and test what it intends to,
-     * viz., the precedence of various property-setting techniques.
-     * The authentication requirement and the "-noSecurityManager" option were added as
-     * part of the work for DERBY-2196.
-     */
-    private static  String[]    unsecure( String cmd, String[] originalArgs )
-    {
-        if ( !cmd.equals( "start" ) ) { return originalArgs; }
-        else
-        {
-            int             count = originalArgs.length;
-            String[]    cooked = new String[ count + 1 ];
-
-            for ( int i = 0; i < count; i++ ) { cooked[ i ] = originalArgs[ i ]; }
-
-            cooked[ count ] = "-noSecurityManager";
-
-            return cooked;
-        }
-    }
-
-	private static void waitForStart(String portString, int timeToWait) throws Exception
-	{
-		int waitTime = 0;
-		int port = Integer.parseInt(portString);
-		
-		NetworkServerControl derbyServer = new NetworkServerControl( InetAddress.getByName("localhost"),
-												  port);
-		
-		
-
-        while (waitTime < timeToWait) {
-            try {
-                derbyServer.ping();
-                return;
-            } catch (Exception e) {
-				Thread currentThread = Thread.currentThread();
-				synchronized (currentThread) {
-                    try {
-                        currentThread.wait(1000);
-						waitTime += 1000;
-						if (waitTime >= timeToWait) {
-                            System.out.println(
-                                "Giving up on wait, waited: " + waitTime);
-							throw e;
-                        }
-                    } catch (InterruptedException ie) {
-                    }
-				}
-			}
-        }
-	}
-
-	private static void listProperties(String portString) throws Exception{
-		int port = Integer.parseInt(portString);
-		NetworkServerControl derbyServer = new NetworkServerControl( InetAddress.getByName("localhost"),
-													port);
-		Properties p = derbyServer.getCurrentProperties();
-		p.list(System.out);
-	}
-
-	public static void main (String args[]) throws Exception
-	{
-		if ((System.getProperty("java.vm.name") != null) && System.getProperty("java.vm.name").equals("J9"))
-			jvm = jvm.getJvm("j9_13");
-		else
-			jvm = jvm.getJvm("currentjvm");		// ensure compatibility
-		vCmd = jvm.getCommandLine();
-		try
-		{
-        	bos = new BufferedOutputStream(System.out, 1024);
-			
-
-			System.out.println("Start testProperties to test property priority");
-
-			/************************************************************
-			 *  Test port setting priorty
-			 ************************************************************/
-			// derby.drda.portNumber set in derby.properties to 1528
-			System.out.println("Testing derby.properties Port 1528 ");
-			Properties derbyProperties = new Properties();
-			derbyProperties.put("derby.drda.portNumber","1528");
-			FileOutputStream propFile = new FileOutputStream("derby.properties");
-			derbyProperties.store(propFile,"testing derby.properties");
-			propFile.close();
-			//test start no parameters - Pickup 1528 from derby.properties
-			derbyServerCmd("start",null);	
-			waitForStart("1528",60000);
-			System.out.println("Successfully Connected");
-			//shutdown - also picks up from derby.properties
-			derbyServerCmd("shutdown",null);
-			System.out.println("Testing System properties  Port 1529 ");
-			//test start with system property. Overrides derby.properties
-			derbyServerCmd("start","-Dderby.drda.portNumber=1529");
-
-			waitForStart("1529",60000);	
-			System.out.println("Successfully Connected");
-			//shutdown - also picks up from System Properties
-			derbyServerCmd("shutdown","1529");
-			System.out.println("Testing command line option. Port 1530");
-			derbyServerCmd("start","1530");
-			waitForStart("1530",60000);		
-			System.out.println("Successfully Connected");
-			//shutdown - with command line option
-			derbyServerCmd("shutdown","1530");
-
-			/**********************************************************************
-			 *  Test start server specifying system properties without values
-			 *********************************************************************/
-			System.out.println("Testing start server by specifying system properties without values");
-			System.out.println("First shutdown server started on default port by the test harness");
-
-			//Shutdown the server started by test
-			derbyServerCmd("shutdown","1527");
-            execCmdDumpResults(startServerCmd, false);
-			waitForStart("1527",60000);
-			//check that default properties are used
-			listProperties("1527");
-			
-			//Test trace and logconnections commands
-			execCmdDumpResults(cmdTraceOn, true);
-			execCmdDumpResults(cmdLogconnectionsOn, true);
-			listProperties("1527");
-			execCmdDumpResults(cmdTraceOff, true);
-			listProperties("1527");
-			derbyServerCmd("shutdown","1527");
-			
-			//Test error conditions in command-line
-			execCmdDumpResults(cmdWithoutArgs, true);
-			execCmdDumpResults(cmdUnknown, true);
-			execCmdDumpResults(cmdWithWrongArgNum, true);
-			
-			System.out.println("End test");
-			bos.close();
-		}
-		catch (Exception e)
-		{
-			e.printStackTrace();
-			// If something went wrong,
-			// make sure all these servers are shutdown
-			try {derbyServerCmd("shutdown","1527");} catch (Exception se) {}
-			try {derbyServerCmd("shutdown","1528");} catch (Exception se) {}
-			try {derbyServerCmd("shutdown","1529");} catch (Exception se) {}
-			try {derbyServerCmd("shutdown","1530");} catch (Exception se) {}
-		}
-		finally {
-			try {
-				File fileToDelete = new File("derby.properties");
-				fileToDelete.delete();
-			} catch (Exception e)
-			{
-				e.printStackTrace();
-			}
-		}
-	}
-}
-
-
-
-
-
diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/junit/BaseTestCase.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/junit/BaseTestCase.java
index ab7240e6..cd532e2b 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/junit/BaseTestCase.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/junit/BaseTestCase.java
@@ -19,6 +19,7 @@
  */
 package org.apache.derbyTesting.junit;
 
+import junit.framework.Assert;
 import junit.framework.TestCase;
 import junit.framework.AssertionFailedError;
 
@@ -28,12 +29,14 @@
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.io.Reader;
 import java.io.PrintStream;
 import java.net.URL;
 import java.sql.SQLException;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
+import java.security.PrivilegedExceptionAction;
 
 import java.security.PrivilegedActionException;
 
@@ -395,6 +398,114 @@ public Object run() {
         });
 	}
     
+    /**
+	 * Execute command using 'java' executable and verify that it completes
+	 * with expected results
+	 * @param expectedString String to compare the resulting output with. May be
+	 *     null if the output is not expected to be of interest.
+	 * @param cmd array of java arguments for command
+	 * @param expectedExitValue expected return value from the command
+	 * @throws InterruptedException
+	 * @throws IOException
+	 */
+	public void assertExecJavaCmdAsExpected(String[] expectedString,
+	        String[] cmd, int expectedExitValue) throws InterruptedException,
+	        IOException {
+
+	    Process pr = execJavaCmd(cmd);
+	    String output = readProcessOutput(pr);
+	    int exitValue = pr.exitValue();
+
+	    Assert.assertEquals(expectedExitValue, exitValue);
+	    if (expectedString != null) {
+	        for (int i = 0; i < expectedString.length; i++) {
+	            assertFalse(output.indexOf(expectedString[i]) < 0);
+	        }
+	    }
+	}
+
+
+	/**
+	 * Execute a java command and return the process.
+	 * The caller should decide what to do with the process, if anything,
+	 * typical activities would be to do a pr.waitFor, or to
+	 * get a getInputStream or getErrorStream
+	 * Note, that for verifying the output of a Java process, there is
+	 * assertExecJavaCmdAsExpected
+	 * 
+	 * @param cmd array of java arguments for command
+	 * @return the process that was started
+	 * @throws IOException
+	 */
+	public Process execJavaCmd(String[] cmd) throws IOException {
+	    int totalSize = 3 + cmd.length;
+	    String[] tcmd = new String[totalSize];
+	    tcmd[0] = "java";
+	    tcmd[1] = "-classpath";
+	    tcmd[2] = BaseTestCase.getSystemProperty("java.class.path");
+
+	    System.arraycopy(cmd, 0, tcmd, 3, cmd.length);
+
+	    final String[] command = tcmd;
+
+	    Process pr = null;
+	    try {
+	        pr = (Process) AccessController
+	        .doPrivileged(new PrivilegedExceptionAction() {
+	            public Object run() throws IOException {
+	                Process result = null;
+	                result = Runtime.getRuntime().exec(command);
+	                return result;
+	            }
+	        });
+	    } catch (PrivilegedActionException pe) {
+	        Exception e = pe.getException();
+	        if (e instanceof IOException)
+	            throw (IOException) e;
+	        else
+	            throw (SecurityException) e;
+	    }
+	    return pr;
+	}
+   
+   /**
+    * Reads output from a process and returns it as a string.
+    * This will block until the process terminates.
+    * 
+    * @param pr a running process
+    * @return output of the process
+    * @throws InterruptedException
+    */
+   public String readProcessOutput(Process pr) throws InterruptedException {
+		InputStream is = pr.getInputStream();
+		if (is == null) {
+			fail("Unexpectedly receiving no text from the process");
+		}
+
+		String output = "";
+		try {
+		    char[] ca = new char[1024];
+		    // Create an InputStreamReader with default encoding; we're hoping
+		    // this to be en. If not, we may not match the expected string.
+		    InputStreamReader inStream;
+		    inStream = new InputStreamReader(is);
+
+		    // keep reading from the stream until all done
+		    int charsRead;
+		    while ((charsRead = inStream.read(ca, 0, ca.length)) != -1)
+		    {
+		        output = output + new String(ca, 0, charsRead);
+		    }
+		} catch (Exception e) {
+		    fail("Exception accessing inputstream from process", e);
+		}
+
+		// wait until the process exits
+		pr.waitFor();
+		
+		return output;
+	}
+    
     /**
      * Remove the directory and its contents.
      * @param path Path of the directory
diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/junit/NetworkServerTestSetup.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/junit/NetworkServerTestSetup.java
index 52824987..bdfebc42 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/junit/NetworkServerTestSetup.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/junit/NetworkServerTestSetup.java
@@ -63,6 +63,7 @@
     private FileOutputStream serverOutput;
     private final boolean asCommand;
 
+    private final boolean startServerAtSetup;
     private final boolean useSeparateProcess;
     private final boolean serverShouldComeUp;
     private final InputStream[] inputStreamHolder;
@@ -82,8 +83,35 @@ public NetworkServerTestSetup(Test test, boolean asCommand) {
         this.useSeparateProcess = false;
         this.serverShouldComeUp = true;
         this.inputStreamHolder = null;
+        this.startServerAtSetup = true;
 }
 
+     /**
+     * Decorator this test with the NetworkServerTestSetup.
+     * 
+     * Sets up the server using the current configuration, but does not start.
+     * 
+     * @param test the Test for which this setup is used
+     * @param asCommand True to start using NetworkServerControl.main()
+     * within the same virtual machine, false to use NetworkServerControl.start.
+     * @param startServerAtSetup False to start using NetworkServerControl.main()
+     * 
+     * @see NetworkServerControl#main(String[])
+     * @see NetworkServerControl#start(PrintWriter)
+     */
+    public NetworkServerTestSetup(Test test, boolean asCommand, boolean startServerAtSetup) {
+        super(test);
+        this.asCommand = asCommand;
+
+        this.systemProperties = null;
+        this.startupArgs = null;
+        this.useSeparateProcess = false;
+        this.serverShouldComeUp = true;
+        this.inputStreamHolder = null;
+
+        this.startServerAtSetup = startServerAtSetup;
+    }
+    
      /**
      * Decorator for starting up with specific command args.
      */
@@ -106,6 +134,7 @@ public NetworkServerTestSetup(Test test, boolean asCommand) {
         this.useSeparateProcess = true;
         this.serverShouldComeUp = serverShouldComeUp;
         this.inputStreamHolder = inputStreamHolder;
+        this.startServerAtSetup = true;
     }
 
     /**
@@ -116,6 +145,8 @@ protected void setUp() throws Exception {
         
         networkServerController = getNetworkServerControl();
 
+        if (startServerAtSetup)
+        {
         if (useSeparateProcess)
         { serverProcess = startSeparateProcess(); }
         else if (asCommand)
@@ -125,6 +156,7 @@ else if (asCommand)
         
         if ( serverShouldComeUp ) { waitForServerStart(networkServerController); }
     }
+    }
 
     private void startWithAPI() throws Exception
     {
@@ -211,7 +243,13 @@ private Process startSeparateProcess() throws Exception
 
         final   String  command = buffer.toString();
 
-        //System.out.println( "XXX server startup command = " + command );
+        System.out.println( "XXX server startup command = " + command);
+        /* System.out.println( "XXX server startup command = ");
+        for (int i = 0 ; i < command.length ; i++) {
+            System.out.print( command[i] + " " );
+        }
+        System.out.println();
+        */
 
         Process     serverProcess = (Process) AccessController.doPrivileged
             (
@@ -345,6 +383,34 @@ public static NetworkServerControl getNetworkServerControl()
         }
     }
     
+    /**
+     * Return a new NetworkServerControl for the current configuration.
+     * Use the port number specified.
+     * This method is not for general use - in most cases, the port
+     * should not be specified in the test, instead, the test framework
+     * will decide what is the best port number to use.
+     */
+    public static NetworkServerControl getNetworkServerControl(int port)
+        throws Exception
+    {
+        TestConfiguration config = TestConfiguration.getCurrent();
+            return new NetworkServerControl
+            (InetAddress.getByName(config.getHostName()), 
+             port);
+    }
+    
+    /**
+     * Return a new NetworkServerControl for the current configuration.
+     * Use default values, i.e. port number and host are dependent on 
+     * whatever settings are set in the environment (properties)
+     */
+    public static NetworkServerControl getNetworkServerControlDefault()
+        throws Exception
+    {
+        TestConfiguration config = TestConfiguration.getCurrent();
+            return new NetworkServerControl();
+    }
+    
     /**
      * Ping the server until it has started. Asserts a failure
      * if the server has not started within sixty seconds.
@@ -366,6 +432,16 @@ public static void setWaitTime( long newWaitTime )
         waitTime = newWaitTime;
     }
     
+    /**
+     * Set the number of milliseconds to wait before declaring server startup
+     * a failure back to the default value specified in this class.
+     * 
+     */
+    public static void setDefaultWaitTime()
+    {
+        waitTime = WAIT_TIME;
+    }
+    
     /**
      * Ping server for upto sixty seconds. If the server responds
      * in that time then return true, otherwise return false.
@@ -375,16 +451,30 @@ public static void setWaitTime( long newWaitTime )
      * (could be <code>null</code>)
      * @return true if server responds in time, false otherwise
      */
-    public static boolean pingForServerStart(
-        NetworkServerControl networkServerController, Process serverProcess)
+    public static boolean pingForServerUp(
+        NetworkServerControl networkServerController, Process serverProcess,
+        boolean expectServerUp)
         throws InterruptedException
     {
+        // If we expect the server to be or come up, then
+        // it makes sense to sleep (if ping unsuccessful), then ping 
+        // and repeat this for the duration of wait-time, but stop
+        // when the ping is successful.
+        // But if we are pinging to see if the server is - or
+        // has come - down, we should do the opposite, stop if ping 
+        // is unsuccessful, and repeat until wait-time if it is
         final long startTime = System.currentTimeMillis();
         while (true) {
-            Thread.sleep(SLEEP_TIME);
             try {
                 networkServerController.ping();
+                if (expectServerUp)
+                    return true;
+                else
+                {
+                    if (System.currentTimeMillis() - startTime > waitTime) {
                 return true;
+                    }
+                }
             } catch (Throwable e) {
                 if ( !vetPing( e ) )
                 {
@@ -396,9 +486,13 @@ public static boolean pingForServerStart(
 
                     return false;
                 }
-                if (System.currentTimeMillis() - startTime > waitTime) {
+                if (expectServerUp){
+                    if (System.currentTimeMillis() - startTime > waitTime) 
                     return false;
                 }
+                // else, we got what we expected, done.
+                else
+                    return false;
             }
             if (serverProcess != null) {
                 // if the server runs in a separate process, check whether the
@@ -418,6 +512,7 @@ public static boolean pingForServerStart(
                     return false;
                 }
             }
+            Thread.sleep(SLEEP_TIME);
         }
     }
 
@@ -440,6 +535,6 @@ private static  boolean isDRDAerror( Throwable t )
     public static boolean pingForServerStart(NetworkServerControl control)
         throws InterruptedException
     {
-        return pingForServerStart(control, null);
+        return pingForServerUp(control, null, true);
     }
 }
diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/junit/Utilities.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/junit/Utilities.java
index 56dce8e2..0e642416 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/junit/Utilities.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/junit/Utilities.java
@@ -19,11 +19,22 @@
  */
 package org.apache.derbyTesting.junit;
 
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.PrintWriter;
+import java.io.StringReader;
 import java.io.UnsupportedEncodingException;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.sql.ResultSet;
 import java.sql.ResultSetMetaData;
 import java.sql.SQLException;
 
+
 /**
  * General non-JDBC related utilities relocated from TestUtil
  *
@@ -123,6 +134,10 @@ public static void showResultSet(ResultSet rs) throws SQLException {
                 
                 for (int i = 0; i < nocols; i++)
                 {
+                	String val = rs.getString(i+1);
+                	if (val == null)
+                		System.out.print("null");
+                	else
                     System.out.print("\"" + rs.getString(i+1) + "\"");
                     if (i == (nocols -1))
                         System.out.print("}");
@@ -135,8 +150,50 @@ public static void showResultSet(ResultSet rs) throws SQLException {
                 if (next)
                     System.out.println(",");
                 else
-                    System.out.println("};");
+                    System.out.println("};\n");
+            }
+        }
+        
+    /**
+     * Calls the public method <code>getInfo</code> of the sysinfo tool within
+     * this JVM and returns a <code>BufferedReader</code> for reading its 
+     * output. This is useful for obtaining system information that could be 
+     * used to verify, for example, values returned by Derby MBeans.
+     * 
+     * @return a buffering character-input stream containing the output from
+     *         sysinfo
+     * @see org.apache.derby.tools.sysinfo#getInfo(java.io.PrintWriter out)
+     */
+    public static BufferedReader getSysinfoLocally() {
+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(20 * 1024);
+        PrintWriter pw = new PrintWriter(byteStream, true); // autoflush
+        org.apache.derby.tools.sysinfo.getInfo(pw);
+        pw.flush();
+        pw.close();
+        byte[] outBytes = byteStream.toByteArray();
+        BufferedReader sysinfoOutput = new BufferedReader(
+                    new InputStreamReader(
+                            new ByteArrayInputStream(outBytes)));
+        return sysinfoOutput;
             }
+    
+    /**
+     * <p>Calls the public method <code>getSysInfo()</code> of the Network 
+     * Server instance associated with the current test configuration and 
+     * returns the result as a BufferedReader, making it easy to analyse the 
+     * output line by line.</p>
+     * 
+     * <p>This is useful for obtaining system information that could be 
+     * used to verify, for example, values returned by Derby MBeans.</p>
+     * 
+     * @return a buffering character-input stream containing the output from 
+     *         the server's sysinfo.
+     * @see org.apache.derby.drda.NetworkServerControl#getSysinfo()
+     */
+    public static BufferedReader getSysinfoFromServer() throws Exception {
+        
+        return new BufferedReader(new StringReader(
+                NetworkServerTestSetup.getNetworkServerControl().getSysinfo()));
         }       
 
 }
