diff --git a/aries/trunk/util/util/src/main/java/org/apache/aries/util/AriesFrameworkUtil.java b/aries/trunk/util/util/src/main/java/org/apache/aries/util/AriesFrameworkUtil.java
index e934ea14..71818563 100644
--- a/aries/trunk/util/util/src/main/java/org/apache/aries/util/AriesFrameworkUtil.java
+++ b/aries/trunk/util/util/src/main/java/org/apache/aries/util/AriesFrameworkUtil.java
@@ -1,3 +1,123 @@
   + native
   + text/plain
   + Date Revision
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util;
+
+import org.apache.aries.util.internal.DefaultWorker;
+import org.apache.aries.util.internal.EquinoxWorker;
+import org.apache.aries.util.internal.FelixWorker;
+import org.apache.aries.util.internal.FrameworkUtilWorker;
+import org.apache.aries.util.internal.R43Worker;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.FrameworkUtil;
+import org.osgi.framework.ServiceRegistration;
+
+public final class AriesFrameworkUtil
+{
+  private static FrameworkUtilWorker worker;
+  
+  static {
+    try {
+      worker = new R43Worker();
+    } catch (Throwable e) {
+    }
+    Bundle b = FrameworkUtil.getBundle(AriesFrameworkUtil.class);
+    String bundleClassName = b == null? "": b.getClass().getName();
+    if (worker == null && isEquinox(bundleClassName)) {
+      worker = new EquinoxWorker();
+    } else if (worker == null && bundleClassName.startsWith("org.apache.felix")) {
+      worker = new FelixWorker();
+    } 
+    
+    if (worker == null || !!!worker.isValid()) worker = new DefaultWorker();
+  }
+  
+  
+  /**
+   * This method attempts to get the classloader for a bundle. It may return null if
+   * their is no such classloader, or if it cannot obtain the classloader for the bundle.
+   * 
+   * @param b the bundle whose classloader is desired.
+   * @return  the classloader if found, or null if for example the bundle is in INSTALLED or UNINSTALLED state
+   */
+  public static ClassLoader getClassLoader(Bundle b)
+  {
+    if (b != null && b.getState() != Bundle.UNINSTALLED && b.getState() != Bundle.INSTALLED) {
+      return worker.getClassLoader(b);
+    } else {
+      return null;
+    }
+  }
+  
+  /**
+   * Returns true if we are in equinox, and we can access the interfaces we need.
+   * @param bundleClassName the class name of the bundle implementation.
+   * @return true if we are in equinox, false otherwise.
+   */
+  private static boolean isEquinox(String bundleClassName) 
+  {
+    if (bundleClassName.startsWith("org.eclipse.osgi")) {
+      try {
+        Class.forName("org.eclipse.osgi.framework.internal.core.BundleHost");
+        return true;
+      } catch (ClassNotFoundException e) {
+      }
+    }
+    return false;
+  }
+
+  /**
+   * This method attempts to get the classloader for a bundle. It will force the creation
+   * of a classloader, so if no classloader exists. If the bundle is in installed state, but
+   * cannot be resolved the null will be returned.
+   * 
+   * @param b the bundle to get a classloader for
+   * @return  the classloader.
+   */
+  public static ClassLoader getClassLoaderForced(Bundle b)
+  {
+    if (b == null)
+      return null;
+    try {
+      b.loadClass("java.lang.Object");
+    } catch (ClassNotFoundException e) {
+    }
+    return worker.getClassLoader(b);
+  }
+  
+  /**
+   * Safely unregister the supplied ServiceRegistration, for when you don't
+   * care about the potential IllegalStateException and don't want
+   * it to run wild through your code
+   * 
+   * @param reg The {@link ServiceRegistration}, may be null
+   */
+  public static void safeUnregisterService(ServiceRegistration reg) 
+  {
+    if(reg != null) {
+      try {
+        reg.unregister();
+      } catch (IllegalStateException e) {
+        //This can be safely ignored
+      }
+    }
+  }
+}
diff --git a/aries/trunk/util/util/src/main/java/org/apache/aries/util/internal/R43Worker.java b/aries/trunk/util/util/src/main/java/org/apache/aries/util/internal/R43Worker.java
index e69de29b..fb5870bf 100644
--- a/aries/trunk/util/util/src/main/java/org/apache/aries/util/internal/R43Worker.java
+++ b/aries/trunk/util/util/src/main/java/org/apache/aries/util/internal/R43Worker.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+
+package org.apache.aries.util.internal;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.wiring.BundleWiring;
+
+/**
+ * @version $Rev$ $Date$
+ */
+public class R43Worker implements FrameworkUtilWorker {
+
+    static {
+        BundleWiring.class.getClassLoader();
+    }
+
+    public ClassLoader getClassLoader(Bundle b) {
+        return b.adapt(BundleWiring.class).getClassLoader();
+    }
+
+    public boolean isValid() {
+        return true;
+    }
+}
diff --git a/aries/trunk/util/util/src/main/java/org/apache/aries/util/tracker/RecursiveBundleTracker.java b/aries/trunk/util/util/src/main/java/org/apache/aries/util/tracker/RecursiveBundleTracker.java
index e69de29b..76ca6f57 100644
--- a/aries/trunk/util/util/src/main/java/org/apache/aries/util/tracker/RecursiveBundleTracker.java
+++ b/aries/trunk/util/util/src/main/java/org/apache/aries/util/tracker/RecursiveBundleTracker.java
@@ -0,0 +1,101 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.tracker;
+
+import org.apache.aries.util.tracker.hook.BundleHookBundleTracker;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceReference;
+import org.osgi.util.tracker.BundleTracker;
+import org.osgi.util.tracker.BundleTrackerCustomizer;
+
+/**
+ * <p>This class supports the tracking of composite bundles. It allows clients to ignore any
+ * events related to framework bundles, as it will automatically handle these events. In
+ * order to use this class clients must create a subclass and implement the methods of the
+ * <code>BundleTrackerCustomizer</code> interface. In spite of this, instances of this class
+ * MUST NOT be passed as a parameter to any <code>BundleTracker</code>.</p>
+ * <p/>
+ * The model for using this is that classes should instantiate it
+ * and pass it a 'vanilla' bundle tracker.
+ *
+ * @author pradine
+ */
+public final class RecursiveBundleTracker {
+    private static final int COMPOSITE_BUNDLE_MASK =
+            Bundle.INSTALLED | Bundle.RESOLVED | Bundle.STARTING | Bundle.ACTIVE | Bundle.STOPPING;
+
+    private final BundleTracker tracker;
+
+    /**
+     * Constructor
+     *
+     * @param context   - The <code>BundleContext</code> against which the tracking is done.
+     * @param stateMask - The bit mask of the ORing of the bundle states to be tracked. The
+     *                  mask must contain the flags <code>Bundle.INSTALLED | Bundle.STARTING | Bundle.ACTIVE | Bundle.STOPPING</code>
+     *                  as a minimum.
+     * @throws IllegalArgumentException - If the provided bit mask does not contain required
+     *                                  flags
+     */
+    public RecursiveBundleTracker(BundleContext context, int stateMask, BundleTrackerCustomizer customizer) {
+        // We always need INSTALLED events so we can recursively listen to the frameworks
+        if ((stateMask & COMPOSITE_BUNDLE_MASK) != COMPOSITE_BUNDLE_MASK)
+            throw new IllegalArgumentException();
+        BundleTracker tracker = null;
+        try {
+            //R43, equinox composite bundles seem to produce appropriate bundle event hook notifications
+            tracker = new BundleHookBundleTracker(context, stateMask, customizer);
+        } catch (Throwable e) {
+        }
+        if (tracker == null) {
+            if (areMultipleFrameworksAvailable(context)) {
+                //not sure if this ever happens, non R43 composite bundles
+                tracker = new InternalRecursiveBundleTracker(context, stateMask, customizer);
+            } else {
+                //R42
+                tracker = new BundleTracker(context, stateMask, customizer);
+            }
+        }
+        this.tracker = tracker;
+    }
+
+    private static boolean areMultipleFrameworksAvailable(BundleContext context) {
+        ServiceReference sr = context.getServiceReference("org.osgi.service.framework.CompositeBundleFactory");
+        return sr != null;
+    }
+
+    /**
+     * Start tracking bundles that match the bit mask provided at creation time.
+     *
+     * @see BundleTracker#open()
+     */
+    public void open() {
+        tracker.open();
+    }
+
+    /**
+     * Stop the tracking of bundles
+     *
+     * @see BundleTracker#close()
+     */
+    public void close() {
+        tracker.close();
+    }
+
+}
diff --git a/aries/trunk/util/util/src/main/java/org/apache/aries/util/tracker/hook/BundleHookBundleTracker.java b/aries/trunk/util/util/src/main/java/org/apache/aries/util/tracker/hook/BundleHookBundleTracker.java
index ada1bb9a..ce5c71fc 100644
--- a/aries/trunk/util/util/src/main/java/org/apache/aries/util/tracker/hook/BundleHookBundleTracker.java
+++ b/aries/trunk/util/util/src/main/java/org/apache/aries/util/tracker/hook/BundleHookBundleTracker.java
@@ -1,3 +1,695 @@
   + text/plain
   + Date Revision
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+
+package org.apache.aries.util.tracker.hook;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.BundleEvent;
+import org.osgi.framework.ServiceRegistration;
+import org.osgi.framework.SynchronousBundleListener;
+import org.osgi.framework.hooks.bundle.EventHook;
+import org.osgi.util.tracker.BundleTracker;
+import org.osgi.util.tracker.BundleTrackerCustomizer;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * The Tracked and AbstractTracked inner classes are copied from felix framework 4.0.1.
+ *
+ * @version $Rev$ $Date$
+ */
+public class BundleHookBundleTracker<T> extends BundleTracker {
+
+    static {
+        Class c = EventHook.class;
+    }
+
+  private final BundleContext context;
+  private final int mask;
+  private final BundleTrackerCustomizer customizer;
+  private Tracked tracked;
+  private ServiceRegistration sr;
+
+  public BundleHookBundleTracker(BundleContext context, int stateMask, BundleTrackerCustomizer customizer) {
+    super(context, stateMask, customizer);
+    this.context = context;
+    this.mask = stateMask;
+    this.customizer = customizer == null ? this : customizer;
+  }
+
+  @Override
+  public void open() {
+    tracked = new Tracked();
+    EventHook hook = new BundleEventHook(tracked);
+    sr = context.registerService(EventHook.class.getName(), hook, null);
+      super.open();
+  }
+
+  @Override
+  public void close() {
+      super.close();
+    sr.unregister();
+    tracked.close();
+    tracked = null;
+  }
+
+    @Override
+    public Object addingBundle(Bundle bundle, BundleEvent bundleEvent) {
+        if (bundleEvent == null) {
+            tracked.trackInitial(bundle);
+        }
+        return null;
+    }
+
+    @Override
+    public void modifiedBundle(Bundle bundle, BundleEvent bundleEvent, Object o) {
+    }
+
+    @Override
+    public void removedBundle(Bundle bundle, BundleEvent bundleEvent, Object o) {
+    }
+
+    private class BundleEventHook implements EventHook {
+    private Tracked tracked;
+
+    private BundleEventHook(Tracked tracked) {
+      this.tracked = tracked;
+    }
+
+    public void event(BundleEvent bundleEvent, Collection<BundleContext> bundleContexts) {
+      tracked.bundleChanged(bundleEvent);
+    }
+  }
+
+  /**
+   * Inner class which subclasses AbstractTracked. This class is the
+   * {@code SynchronousBundleListener} object for the tracker.
+   *
+   * @ThreadSafe
+   * @since 1.4
+   */
+  private final class Tracked extends AbstractTracked<Bundle, T, BundleEvent>
+      implements
+      SynchronousBundleListener {
+    /**
+     * Tracked constructor.
+     */
+    Tracked() {
+      super();
+    }
+
+    /**
+     * {@code BundleListener} method for the {@code BundleTracker}
+     * class. This method must NOT be synchronized to avoid deadlock
+     * potential.
+     *
+     * @param event {@code BundleEvent} object from the framework.
+     */
+    public void bundleChanged(final BundleEvent event) {
+      /*
+      * Check if we had a delayed call (which could happen when we
+      * close).
+      */
+      if (closed) {
+        return;
+      }
+      final Bundle bundle = event.getBundle();
+      final int state = bundle.getState();
+      if (DEBUG) {
+        System.out
+            .println("BundleTracker.Tracked.bundleChanged[" + state + "]: " + bundle); //$NON-NLS-1$ //$NON-NLS-2$
+      }
+
+      if ((state & mask) != 0) {
+        track(bundle, event);
+        /*
+        * If the customizer throws an unchecked exception, it is safe
+        * to let it propagate
+        */
+      } else {
+        untrack(bundle, event);
+        /*
+        * If the customizer throws an unchecked exception, it is safe
+        * to let it propagate
+        */
+      }
+    }
+
+    /**
+     * Call the specific customizer adding method. This method must not be
+     * called while synchronized on this object.
+     *
+     * @param item    Item to be tracked.
+     * @param related Action related object.
+     * @return Customized object for the tracked item or {@code null}
+     *         if the item is not to be tracked.
+     */
+    T customizerAdding(final Bundle item, final BundleEvent related) {
+      return (T)customizer.addingBundle(item, related);
+    }
+
+    /**
+     * Call the specific customizer modified method. This method must not be
+     * called while synchronized on this object.
+     *
+     * @param item    Tracked item.
+     * @param related Action related object.
+     * @param object  Customized object for the tracked item.
+     */
+    void customizerModified(final Bundle item, final BundleEvent related,
+                            final T object) {
+      customizer.modifiedBundle(item, related, object);
+    }
+
+    /**
+     * Call the specific customizer removed method. This method must not be
+     * called while synchronized on this object.
+     *
+     * @param item    Tracked item.
+     * @param related Action related object.
+     * @param object  Customized object for the tracked item.
+     */
+    void customizerRemoved(final Bundle item, final BundleEvent related,
+                           final T object) {
+      customizer.removedBundle(item, related, object);
+    }
+  }
+
+  /**
+   * Abstract class to track items. If a Tracker is reused (closed then reopened),
+   * then a new AbstractTracked object is used. This class acts a map of tracked
+   * item -> customized object. Subclasses of this class will act as the listener
+   * object for the tracker. This class is used to synchronize access to the
+   * tracked items. This is not a public class. It is only for use by the
+   * implementation of the Tracker class.
+   *
+   * @param <S> The tracked item. It is the key.
+   * @param <T> The value mapped to the tracked item.
+   * @param <R> The reason the tracked item is being tracked or untracked.
+   * @version $Id: 79452e6c28683021f2bcf11d3689ec75c6b5642f $
+   * @ThreadSafe
+   * @since 1.4
+   */
+  private static abstract class AbstractTracked<S, T, R> {
+    /* set this to true to compile in debug messages */
+    static final boolean DEBUG = false;
+
+    /**
+     * Map of tracked items to customized objects.
+     *
+     * @GuardedBy this
+     */
+    private final Map<S, T> tracked;
+
+    /**
+     * Modification count. This field is initialized to zero and incremented by
+     * modified.
+     *
+     * @GuardedBy this
+     */
+    private int trackingCount;
+
+    /**
+     * List of items in the process of being added. This is used to deal with
+     * nesting of events. Since events may be synchronously delivered, events
+     * can be nested. For example, when processing the adding of a service and
+     * the customizer causes the service to be unregistered, notification to the
+     * nested call to untrack that the service was unregistered can be made to
+     * the track method.
+     * <p/>
+     * Since the ArrayList implementation is not synchronized, all access to
+     * this list must be protected by the same synchronized object for
+     * thread-safety.
+     *
+     * @GuardedBy this
+     */
+    private final List<S> adding;
+
+    /**
+     * true if the tracked object is closed.
+     * <p/>
+     * This field is volatile because it is set by one thread and read by
+     * another.
+     */
+    volatile boolean closed;
+
+    /**
+     * Initial list of items for the tracker. This is used to correctly process
+     * the initial items which could be modified before they are tracked. This
+     * is necessary since the initial set of tracked items are not "announced"
+     * by events and therefore the event which makes the item untracked could be
+     * delivered before we track the item.
+     * <p/>
+     * An item must not be in both the initial and adding lists at the same
+     * time. An item must be moved from the initial list to the adding list
+     * "atomically" before we begin tracking it.
+     * <p/>
+     * Since the LinkedList implementation is not synchronized, all access to
+     * this list must be protected by the same synchronized object for
+     * thread-safety.
+     *
+     * @GuardedBy this
+     */
+    private final LinkedList<S> initial;
+
+    /**
+     * AbstractTracked constructor.
+     */
+    AbstractTracked() {
+      tracked = new HashMap<S, T>();
+      trackingCount = 0;
+      adding = new ArrayList<S>(6);
+      initial = new LinkedList<S>();
+      closed = false;
+    }
+
+    /**
+     * Set initial list of items into tracker before events begin to be
+     * received.
+     * <p/>
+     * This method must be called from Tracker's open method while synchronized
+     * on this object in the same synchronized block as the add listener call.
+     *
+     * @param list The initial list of items to be tracked. {@code null}
+     *             entries in the list are ignored.
+     * @GuardedBy this
+     */
+    void setInitial(S[] list) {
+      if (list == null) {
+        return;
+      }
+      for (S item : list) {
+        if (item == null) {
+          continue;
+        }
+        if (DEBUG) {
+          System.out.println("AbstractTracked.setInitial: " + item); //$NON-NLS-1$
+        }
+        initial.add(item);
+      }
+    }
+
+    /**
+     * Track the initial list of items. This is called after events can begin to
+     * be received.
+     * <p/>
+     * This method must be called from Tracker's open method while not
+     * synchronized on this object after the add listener call.
+     */
+    void trackInitial() {
+      while (true) {
+        S item;
+        synchronized (this) {
+          if (closed || (initial.size() == 0)) {
+            /*
+                        * if there are no more initial items
+                        */
+            return; /* we are done */
+          }
+          /*
+                   * move the first item from the initial list to the adding list
+                   * within this synchronized block.
+                   */
+          item = initial.removeFirst();
+          if (tracked.get(item) != null) {
+            /* if we are already tracking this item */
+            if (DEBUG) {
+              System.out
+                  .println("AbstractTracked.trackInitial[already tracked]: " + item); //$NON-NLS-1$
+            }
+            continue; /* skip this item */
+          }
+          if (adding.contains(item)) {
+            /*
+                        * if this item is already in the process of being added.
+                        */
+            if (DEBUG) {
+              System.out
+                  .println("AbstractTracked.trackInitial[already adding]: " + item); //$NON-NLS-1$
+            }
+            continue; /* skip this item */
+          }
+          adding.add(item);
+        }
+        if (DEBUG) {
+          System.out.println("AbstractTracked.trackInitial: " + item); //$NON-NLS-1$
+        }
+        trackAdding(item, null); /*
+									 * Begin tracking it. We call trackAdding
+									 * since we have already put the item in the
+									 * adding list.
+									 */
+      }
+    }
+
+      void trackInitial(S item) {
+        synchronized (this) {
+          if (closed) {
+            /*
+                        * if there are no more initial items
+                        */
+            return; /* we are done */
+          }
+          /*
+                   * move the first item from the initial list to the adding list
+                   * within this synchronized block.
+                   */
+          item = initial.removeFirst();
+          if (tracked.get(item) != null) {
+            /* if we are already tracking this item */
+            if (DEBUG) {
+              System.out
+                  .println("AbstractTracked.trackInitial[already tracked]: " + item); //$NON-NLS-1$
+            }
+            return; /* skip this item */
+          }
+          if (adding.contains(item)) {
+            /*
+                        * if this item is already in the process of being added.
+                        */
+            if (DEBUG) {
+              System.out
+                  .println("AbstractTracked.trackInitial[already adding]: " + item); //$NON-NLS-1$
+            }
+            return; /* skip this item */
+          }
+          adding.add(item);
+        }
+        if (DEBUG) {
+          System.out.println("AbstractTracked.trackInitial: " + item); //$NON-NLS-1$
+        }
+        trackAdding(item, null); /*
+									 * Begin tracking it. We call trackAdding
+									 * since we have already put the item in the
+									 * adding list.
+									 */
+    }
+
+    /**
+     * Called by the owning Tracker object when it is closed.
+     */
+    void close() {
+      closed = true;
+    }
+
+    /**
+     * Begin to track an item.
+     *
+     * @param item    Item to be tracked.
+     * @param related Action related object.
+     */
+    void track(final S item, final R related) {
+      final T object;
+      synchronized (this) {
+        if (closed) {
+          return;
+        }
+        object = tracked.get(item);
+        if (object == null) { /* we are not tracking the item */
+          if (adding.contains(item)) {
+            /* if this item is already in the process of being added. */
+            if (DEBUG) {
+              System.out
+                  .println("AbstractTracked.track[already adding]: " + item); //$NON-NLS-1$
+            }
+            return;
+          }
+          adding.add(item); /* mark this item is being added */
+        } else { /* we are currently tracking this item */
+          if (DEBUG) {
+            System.out
+                .println("AbstractTracked.track[modified]: " + item); //$NON-NLS-1$
+          }
+          modified(); /* increment modification count */
+        }
+      }
+
+      if (object == null) { /* we are not tracking the item */
+        trackAdding(item, related);
+      } else {
+        /* Call customizer outside of synchronized region */
+        customizerModified(item, related, object);
+        /*
+               * If the customizer throws an unchecked exception, it is safe to
+               * let it propagate
+               */
+      }
+    }
+
+    /**
+     * Common logic to add an item to the tracker used by track and
+     * trackInitial. The specified item must have been placed in the adding list
+     * before calling this method.
+     *
+     * @param item    Item to be tracked.
+     * @param related Action related object.
+     */
+    private void trackAdding(final S item, final R related) {
+      if (DEBUG) {
+        System.out.println("AbstractTracked.trackAdding: " + item); //$NON-NLS-1$
+      }
+      T object = null;
+      boolean becameUntracked = false;
+      /* Call customizer outside of synchronized region */
+      try {
+        object = customizerAdding(item, related);
+        /*
+               * If the customizer throws an unchecked exception, it will
+               * propagate after the finally
+               */
+      } finally {
+        synchronized (this) {
+          if (adding.remove(item) && !closed) {
+            /*
+                        * if the item was not untracked during the customizer
+                        * callback
+                        */
+            if (object != null) {
+              tracked.put(item, object);
+              modified(); /* increment modification count */
+              notifyAll(); /* notify any waiters */
+            }
+          } else {
+            becameUntracked = true;
+          }
+        }
+      }
+      /*
+          * The item became untracked during the customizer callback.
+          */
+      if (becameUntracked && (object != null)) {
+        if (DEBUG) {
+          System.out
+              .println("AbstractTracked.trackAdding[removed]: " + item); //$NON-NLS-1$
+        }
+        /* Call customizer outside of synchronized region */
+        customizerRemoved(item, related, object);
+        /*
+               * If the customizer throws an unchecked exception, it is safe to
+               * let it propagate
+               */
+      }
+    }
+
+    /**
+     * Discontinue tracking the item.
+     *
+     * @param item    Item to be untracked.
+     * @param related Action related object.
+     */
+    void untrack(final S item, final R related) {
+      final T object;
+      synchronized (this) {
+        if (initial.remove(item)) { /*
+										 * if this item is already in the list
+										 * of initial references to process
+										 */
+          if (DEBUG) {
+            System.out
+                .println("AbstractTracked.untrack[removed from initial]: " + item); //$NON-NLS-1$
+          }
+          return; /*
+						 * we have removed it from the list and it will not be
+						 * processed
+						 */
+        }
+
+        if (adding.remove(item)) { /*
+										 * if the item is in the process of
+										 * being added
+										 */
+          if (DEBUG) {
+            System.out
+                .println("AbstractTracked.untrack[being added]: " + item); //$NON-NLS-1$
+          }
+          return; /*
+						 * in case the item is untracked while in the process of
+						 * adding
+						 */
+        }
+        object = tracked.remove(item); /*
+											 * must remove from tracker before
+											 * calling customizer callback
+											 */
+        if (object == null) { /* are we actually tracking the item */
+          return;
+        }
+        modified(); /* increment modification count */
+      }
+      if (DEBUG) {
+        System.out.println("AbstractTracked.untrack[removed]: " + item); //$NON-NLS-1$
+      }
+      /* Call customizer outside of synchronized region */
+      customizerRemoved(item, related, object);
+      /*
+          * If the customizer throws an unchecked exception, it is safe to let it
+          * propagate
+          */
+    }
+
+    /**
+     * Returns the number of tracked items.
+     *
+     * @return The number of tracked items.
+     * @GuardedBy this
+     */
+    int size() {
+      return tracked.size();
+    }
+
+    /**
+     * Returns if the tracker is empty.
+     *
+     * @return Whether the tracker is empty.
+     * @GuardedBy this
+     * @since 1.5
+     */
+    boolean isEmpty() {
+      return tracked.isEmpty();
+    }
+
+    /**
+     * Return the customized object for the specified item
+     *
+     * @param item The item to lookup in the map
+     * @return The customized object for the specified item.
+     * @GuardedBy this
+     */
+    T getCustomizedObject(final S item) {
+      return tracked.get(item);
+    }
+
+    /**
+     * Copy the tracked items into an array.
+     *
+     * @param list An array to contain the tracked items.
+     * @return The specified list if it is large enough to hold the tracked
+     *         items or a new array large enough to hold the tracked items.
+     * @GuardedBy this
+     */
+    S[] copyKeys(final S[] list) {
+      return tracked.keySet().toArray(list);
+    }
+
+    /**
+     * Increment the modification count. If this method is overridden, the
+     * overriding method MUST call this method to increment the tracking count.
+     *
+     * @GuardedBy this
+     */
+    void modified() {
+      trackingCount++;
+    }
+
+    /**
+     * Returns the tracking count for this {@code ServiceTracker} object.
+     * <p/>
+     * The tracking count is initialized to 0 when this object is opened. Every
+     * time an item is added, modified or removed from this object the tracking
+     * count is incremented.
+     *
+     * @return The tracking count for this object.
+     * @GuardedBy this
+     */
+    int getTrackingCount() {
+      return trackingCount;
+    }
+
+    /**
+     * Copy the tracked items and associated values into the specified map.
+     *
+     * @param <M> Type of {@code Map} to hold the tracked items and
+     *            associated values.
+     * @param map The map into which to copy the tracked items and associated
+     *            values. This map must not be a user provided map so that user code
+     *            is not executed while synchronized on this.
+     * @return The specified map.
+     * @GuardedBy this
+     * @since 1.5
+     */
+    <M extends Map<? super S, ? super T>> M copyEntries(final M map) {
+      map.putAll(tracked);
+      return map;
+    }
+
+    /**
+     * Call the specific customizer adding method. This method must not be
+     * called while synchronized on this object.
+     *
+     * @param item    Item to be tracked.
+     * @param related Action related object.
+     * @return Customized object for the tracked item or {@code null} if
+     *         the item is not to be tracked.
+     */
+    abstract T customizerAdding(final S item, final R related);
+
+    /**
+     * Call the specific customizer modified method. This method must not be
+     * called while synchronized on this object.
+     *
+     * @param item    Tracked item.
+     * @param related Action related object.
+     * @param object  Customized object for the tracked item.
+     */
+    abstract void customizerModified(final S item, final R related,
+                                     final T object);
+
+    /**
+     * Call the specific customizer removed method. This method must not be
+     * called while synchronized on this object.
+     *
+     * @param item    Tracked item.
+     * @param related Action related object.
+     * @param object  Customized object for the tracked item.
+     */
+    abstract void customizerRemoved(final S item, final R related,
+                                    final T object);
+  }
+
+}
diff --git a/aries/trunk/util/util/src/test/java/org/apache/aries/util/RecursiveBundleTrackerTest.java b/aries/trunk/util/util/src/test/java/org/apache/aries/util/RecursiveBundleTrackerTest.java
index e69de29b..d2de9c3a 100644
--- a/aries/trunk/util/util/src/test/java/org/apache/aries/util/RecursiveBundleTrackerTest.java
+++ b/aries/trunk/util/util/src/test/java/org/apache/aries/util/RecursiveBundleTrackerTest.java
@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util;
+
+import org.apache.aries.unittest.mocks.MethodCall;
+import org.apache.aries.unittest.mocks.Skeleton;
+import org.apache.aries.util.tracker.BundleTrackerFactory;
+import org.apache.aries.util.tracker.InternalRecursiveBundleTracker;
+import org.apache.aries.util.tracker.RecursiveBundleTracker;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.BundleEvent;
+import org.osgi.framework.ServiceReference;
+import org.osgi.framework.Version;
+import org.osgi.service.framework.CompositeBundle;
+import org.osgi.util.tracker.BundleTrackerCustomizer;
+
+import static org.junit.Assert.*;
+
+public class RecursiveBundleTrackerTest {
+    BundleContext context;
+    InternalRecursiveBundleTracker sut;
+    
+    @Before
+    public void setup() {
+        context = Skeleton.newMock(BundleContext.class);
+        Skeleton.getSkeleton(context).setReturnValue(
+                new MethodCall(BundleContext.class, "getServiceReference", "org.osgi.service.framework.CompositeBundleFactory"), 
+                Skeleton.newMock(ServiceReference.class));
+    }
+    
+    @After
+    public void closeTrackes() {
+        BundleTrackerFactory.unregisterAndCloseBundleTracker("test");
+    }
+    
+    @Test
+    public void testCompositeLifeCycle() {
+        makeSUT();
+        CompositeBundle  cb = composite("test.composite", "1.0.0");
+        assertNoTrackers();
+        
+        // full lifecycle
+        
+        sut.addingBundle(cb, new BundleEvent(BundleEvent.INSTALLED, cb));
+        assertTracker(cb);
+
+        sut.modifiedBundle(cb, new BundleEvent(BundleEvent.RESOLVED, cb), cb);
+        sut.modifiedBundle(cb, new BundleEvent(BundleEvent.STARTING, cb), cb);
+        sut.modifiedBundle(cb, new BundleEvent(BundleEvent.STARTED, cb), cb);
+        sut.modifiedBundle(cb, new BundleEvent(BundleEvent.STOPPING, cb), cb);
+        sut.removedBundle(cb, new BundleEvent(BundleEvent.STOPPED, cb), cb);
+        assertNoTrackers();
+        
+        // short lifecycle
+        
+        sut.addingBundle(cb, new BundleEvent(BundleEvent.INSTALLED, cb));
+        assertTracker(cb);
+        
+        sut.modifiedBundle(cb, new BundleEvent(BundleEvent.RESOLVED, cb), cb);        
+        sut.removedBundle(cb, new BundleEvent(BundleEvent.UNRESOLVED, cb), cb);
+        assertNoTrackers();
+        
+        // shortest lifecycle
+        
+        sut.addingBundle(cb, new BundleEvent(BundleEvent.INSTALLED, cb));
+        assertTracker(cb);
+        
+        sut.removedBundle(cb, new BundleEvent(BundleEvent.UNINSTALLED, cb), cb);
+        assertNoTrackers();
+    }
+    
+    
+    @Test(expected=IllegalArgumentException.class)
+    public void testMissingStopping() {
+        new RecursiveBundleTracker(null, Bundle.INSTALLED | Bundle.RESOLVED | Bundle.STARTING | Bundle.ACTIVE, null);
+    }
+    
+    @Test(expected=IllegalArgumentException.class)
+    public void testMissingStarting() {
+        new RecursiveBundleTracker(null, Bundle.INSTALLED | Bundle.RESOLVED | Bundle.ACTIVE | Bundle.STOPPING, null);        
+    }
+
+    @Test(expected=IllegalArgumentException.class)
+    public void testMissingInstalled() {
+        new RecursiveBundleTracker(null, Bundle.RESOLVED | Bundle.STARTING | Bundle.ACTIVE | Bundle.STOPPING, null);        
+    }
+    
+    private void assertNoTrackers() {
+        assertTrue(BundleTrackerFactory.getAllBundleTracker().isEmpty());        
+    }
+    
+    private void assertTracker(CompositeBundle cb) {
+        assertEquals(1, BundleTrackerFactory.getAllBundleTracker().size());
+        assertEquals(1, BundleTrackerFactory.getBundleTrackerList(cb.getSymbolicName()+"_"+cb.getVersion()).size());        
+    }
+    
+    private void makeSUT() {
+        BundleTrackerCustomizer customizer = Skeleton.newMock(BundleTrackerCustomizer.class);
+
+        sut = new InternalRecursiveBundleTracker(context, 
+                Bundle.INSTALLED | Bundle.STARTING | Bundle.ACTIVE | Bundle.STOPPING, customizer);
+        
+        sut.open();
+    }
+    
+    private CompositeBundle composite(String symbolicName, String version) {
+        CompositeBundle cb = Skeleton.newMock(CompositeBundle.class);
+        Skeleton cbSkel = Skeleton.getSkeleton(cb);
+        cbSkel.setReturnValue(new MethodCall(CompositeBundle.class, "getSymbolicName"), symbolicName);
+        cbSkel.setReturnValue(new MethodCall(CompositeBundle.class, "getVersion"), new Version(version));
+        return cb;
+    }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/AriesFrameworkUtil.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/AriesFrameworkUtil.java
index e69de29b..a7527d4b 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/AriesFrameworkUtil.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/AriesFrameworkUtil.java
@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util;
+
+import org.apache.aries.util.internal.DefaultWorker;
+import org.apache.aries.util.internal.EquinoxWorker;
+import org.apache.aries.util.internal.FelixWorker;
+import org.apache.aries.util.internal.FrameworkUtilWorker;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.FrameworkUtil;
+import org.osgi.framework.ServiceRegistration;
+
+public final class AriesFrameworkUtil 
+{
+  private static FrameworkUtilWorker worker;
+  
+  static {
+    Bundle b = FrameworkUtil.getBundle(AriesFrameworkUtil.class);
+    String bundleClassName = b.getClass().getName();
+    if (isEquinox(bundleClassName)) {
+      worker = new EquinoxWorker();
+    } else if (bundleClassName.startsWith("org.apache.felix")) {
+      worker = new FelixWorker();
+    } 
+    
+    if (worker == null || !!!worker.isValid()) worker = new DefaultWorker();
+  }
+  
+  
+  /**
+   * This method attempts to get the classloader for a bundle. It may return null if
+   * their is no such classloader, or if it cannot obtain the classloader for the bundle.
+   * 
+   * @param b the bundle whose classloader is desired.
+   * @return  the classloader if found, or null if for example the bundle is in INSTALLED or UNINSTALLED state
+   */
+  public static ClassLoader getClassLoader(Bundle b)
+  {
+    if (b != null && b.getState() != Bundle.UNINSTALLED && b.getState() != Bundle.INSTALLED) {
+      return worker.getClassLoader(b);
+    } else {
+      return null;
+    }
+  }
+  
+  /**
+   * Returns true if we are in equinox, and we can access the interfaces we need.
+   * @param bundleClassName the class name of the bundle implementation.
+   * @return true if we are in equinox, false otherwise.
+   */
+  private static boolean isEquinox(String bundleClassName) 
+  {
+    if (bundleClassName.startsWith("org.eclipse.osgi")) {
+      try {
+        Class.forName("org.eclipse.osgi.framework.internal.core.BundleHost");
+        return true;
+      } catch (ClassNotFoundException e) {
+      }
+    }
+    return false;
+  }
+
+  /**
+   * This method attempts to get the classloader for a bundle. It will force the creation
+   * of a classloader, so if no classloader exists. If the bundle is in installed state, but
+   * cannot be resolved the null will be returned.
+   * 
+   * @param b the bundle to get a classloader for
+   * @return  the classloader.
+   */
+  public static ClassLoader getClassLoaderForced(Bundle b)
+  {
+    if (b == null)
+      return null;
+    try {
+      b.loadClass("java.lang.Object");
+    } catch (ClassNotFoundException e) {
+    }
+    return worker.getClassLoader(b);
+  }
+  
+  /**
+   * Safely unregister the supplied ServiceRegistration, for when you don't
+   * care about the potential IllegalStateException and don't want
+   * it to run wild through your code
+   * 
+   * @param reg The {@link ServiceRegistration}, may be null
+   */
+  public static void safeUnregisterService(ServiceRegistration reg) 
+  {
+    if(reg != null) {
+      try {
+        reg.unregister();
+      } catch (IllegalStateException e) {
+        //This can be safely ignored
+      }
+    }
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/FragmentBuilder.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/FragmentBuilder.java
index e69de29b..a202fb56 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/FragmentBuilder.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/FragmentBuilder.java
@@ -0,0 +1,270 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.jar.Attributes;
+import java.util.jar.JarEntry;
+import java.util.jar.JarOutputStream;
+import java.util.jar.Manifest;
+
+import org.apache.aries.util.internal.MessageUtil;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.BundleException;
+import org.osgi.framework.Constants;
+
+public class FragmentBuilder {
+    private List<String> importPackages = new ArrayList<String>();
+    private List<String> exportPackages = new ArrayList<String>();
+    private Bundle hostBundle;
+    private String nameExtension;
+    private String bundleNameExtension;
+    private String fragmentName;
+    private Map<String, byte[]> files = new HashMap<String, byte[]>();
+
+    public FragmentBuilder(Bundle host) {
+        this(host, ".fragment", "Fragment");
+    }
+    
+    public FragmentBuilder(Bundle host, String symbolicNameSuffix, String bundleNameSuffix) {
+        hostBundle = host;
+        nameExtension = symbolicNameSuffix;
+        bundleNameExtension = bundleNameSuffix;
+
+        // make sure we have an initial '.'
+        if (!!!nameExtension.startsWith(".")) {
+            nameExtension = "." + nameExtension;
+        }
+    }
+
+    public void setName(String name) {
+        fragmentName = name;
+    }
+
+    public void addImports(String... imports) {
+        importPackages.addAll(Arrays.asList(imports));
+    }
+
+    public void addExports(String... imports) {
+        exportPackages.addAll(Arrays.asList(imports));
+    }
+
+    public void addImportsFromExports(Bundle exportBundle) {
+        String exportString = (String) exportBundle.getHeaders().get(Constants.EXPORT_PACKAGE);
+
+        if (exportString != null) {
+            String exportVersion = exportBundle.getVersion().toString();
+            String bundleConstraint = Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE
+                    + "=\"" + exportBundle.getSymbolicName() + "\"";
+            String bundleVersionConstraint = Constants.BUNDLE_VERSION_ATTRIBUTE
+                    + "=\"[" + exportVersion + "," + exportVersion + "]\"";
+
+            List<String> exports = parseDelimitedString(exportString, ",", true);            
+            for (String export : exports) {
+                importPackages.add(convertExportToImport(export, bundleConstraint, bundleVersionConstraint));
+            }
+        }
+    }
+
+    /**
+     * Filter out directives in the export statement
+     * 
+     * @param exportStatement
+     * @return
+     */
+    private String convertExportToImport(String exportStatement,
+                                         String bundleConstraint, 
+                                         String bundleVersionConstraint) {
+        StringBuffer result = new StringBuffer();
+
+        for (String fragment : exportStatement.split("\\s*;\\s*")) {
+            int pos = fragment.indexOf('=');
+
+            // similar to fragment.contains(":=") but looks for the first '='
+            // and checks whether this is part of ':='
+            // in this way we will not be fooled by attributes like
+            // a="something:=strange"
+            if (!!!(pos > 0 && fragment.charAt(pos - 1) == ':')) {
+                result.append(fragment);
+                result.append(';');
+            }
+        }
+
+        result.append(bundleConstraint);
+        result.append(';');
+        result.append(bundleVersionConstraint);
+
+        return result.toString();
+    }
+
+    public void addFile(String path, byte[] content) {
+        files.put(path, content);
+    }
+
+    public Bundle install(BundleContext ctx) throws IOException, BundleException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        JarOutputStream jos = null;
+
+        try {
+            jos = new JarOutputStream(baos, makeManifest());
+            addFileContent(jos);
+        } finally {
+            if (jos != null)
+                jos.close();
+            baos.close();
+        }
+
+        byte[] inMemoryJar = baos.toByteArray();
+        ByteArrayInputStream bais = new ByteArrayInputStream(inMemoryJar);
+
+        return ctx.installBundle(getFragmentSymbolicName(), bais);
+    }
+
+    private void addFileContent(JarOutputStream jos) throws IOException {
+        for (Map.Entry<String, byte[]> entry : files.entrySet()) {
+            jos.putNextEntry(new JarEntry(entry.getKey()));
+            jos.write(entry.getValue());
+        }
+    }
+
+    public String getFragmentSymbolicName() {
+        return hostBundle.getSymbolicName() + nameExtension;
+    }
+
+    public String getFragmentBundleName() {
+        if (fragmentName != null) {
+            return fragmentName;
+        } else {
+            String bundleName = (String) hostBundle.getHeaders().get(Constants.BUNDLE_NAME);
+            if (bundleName != null && bundleNameExtension != null) {
+                return bundleName.trim() + " " + bundleNameExtension.trim();
+            }
+        }
+        return null;
+    }
+    
+    private Manifest makeManifest() {
+        String commonVersion = hostBundle.getVersion().toString();
+        String fragmentHost = hostBundle.getSymbolicName() + ";"
+                + Constants.BUNDLE_VERSION_ATTRIBUTE + "=\"" + commonVersion
+                + "\"";
+
+        Manifest m = new Manifest();
+        Attributes manifestAttributes = m.getMainAttributes();
+        manifestAttributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), "1.0");
+        manifestAttributes.putValue(Constants.BUNDLE_MANIFESTVERSION, "2");
+        manifestAttributes.putValue(Constants.BUNDLE_SYMBOLICNAME, getFragmentSymbolicName());   
+        
+        String bundleName = getFragmentBundleName();        
+        if (bundleName != null) {
+            manifestAttributes.putValue(Constants.BUNDLE_NAME, bundleName);
+        }
+            
+        manifestAttributes.putValue(Constants.BUNDLE_VERSION, commonVersion);
+        manifestAttributes.putValue(Constants.BUNDLE_VENDOR, "Apache");
+        manifestAttributes.putValue(Constants.FRAGMENT_HOST, fragmentHost);
+
+        addImportsAndExports(manifestAttributes);
+
+        return m;
+    }
+
+    private void addImportsAndExports(Attributes attrs) {
+        if (!!!importPackages.isEmpty()) {
+            attrs.putValue(Constants.IMPORT_PACKAGE, joinStrings(importPackages, ','));
+        }
+
+        if (!!!exportPackages.isEmpty()) {
+            attrs.putValue(Constants.EXPORT_PACKAGE, joinStrings(exportPackages, ','));
+        }
+    }
+
+    private String joinStrings(List<String> strs, char separator) {
+        StringBuilder result = new StringBuilder();
+        boolean first = true;
+        for (String str : strs) {
+            if (first)
+                first = false;
+            else
+                result.append(separator);
+
+            result.append(str);
+        }
+
+        return result.toString();
+    }
+    
+    private static List<String> parseDelimitedString(String value, String delim, boolean includeQuotes) {   
+        if (value == null) {       
+            value = "";
+        }
+
+        List<String> list = new ArrayList<String>();
+
+        int CHAR = 1;
+        int DELIMITER = 2;
+        int STARTQUOTE = 4;
+        int ENDQUOTE = 8;
+
+        StringBuffer sb = new StringBuffer();
+
+        int expecting = (CHAR | DELIMITER | STARTQUOTE);
+
+        for (int i = 0; i < value.length(); i++) {        
+            char c = value.charAt(i);
+
+            boolean isDelimiter = (delim.indexOf(c) >= 0);
+            boolean isQuote = (c == '"');
+
+            if (isDelimiter && ((expecting & DELIMITER) > 0)) {            
+                list.add(sb.toString().trim());
+                sb.delete(0, sb.length());
+                expecting = (CHAR | DELIMITER | STARTQUOTE);
+            } else if (isQuote && ((expecting & STARTQUOTE) > 0)) { 
+                if (includeQuotes) {
+                    sb.append(c);
+                }
+                expecting = CHAR | ENDQUOTE;
+            } else if (isQuote && ((expecting & ENDQUOTE) > 0)) {    
+                if (includeQuotes) {
+                    sb.append(c);
+                }
+                expecting = (CHAR | STARTQUOTE | DELIMITER);
+            } else if ((expecting & CHAR) > 0) {            
+                sb.append(c);
+            } else {
+                throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0012E", value));
+            }
+        }
+
+        if (sb.length() > 0) {        
+            list.add(sb.toString().trim());
+        }
+
+        return list;
+    }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/ManifestHeaderUtils.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/ManifestHeaderUtils.java
index e69de29b..853daa5d 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/ManifestHeaderUtils.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/ManifestHeaderUtils.java
@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.aries.util.internal.MessageUtil;
+
+
+
+public class ManifestHeaderUtils {
+
+     /**
+     * 
+     * Splits a delimiter separated string, tolerating presence of non separator commas
+     * within double quoted segments.
+     * 
+     * Eg.
+     * com.ibm.ws.eba.helloWorldService;version="[1.0.0, 1.0.0]" &
+     * com.ibm.ws.eba.helloWorldService;version="1.0.0"
+     * com.ibm.ws.eba.helloWorld;version="2";bundle-version="[2,30)"
+     * com.acme.foo;weirdAttr="one;two;three";weirdDir:="1;2;3"
+     *  @param value          the value to be split
+     *  @param delimiter      the delimiter string such as ',' etc.
+     *  @return List<String>  the components of the split String in a list
+     */
+    public static List<String> split(String value, String delimiter)
+    {
+      List<String> result = new ArrayList<String>();
+      if (value != null) {
+        String[] packages = value.split(delimiter);
+        
+        for (int i = 0; i < packages.length; ) {
+          String tmp = packages[i++].trim();
+          // if there is a odd number of " in a string, we need to append
+          while (count(tmp, "\"") % 2 != 0) {
+            // check to see if we need to append the next package[i++]          
+              if (i<packages.length)
+                tmp = tmp + delimiter + packages[i++].trim();
+              else 
+                // oops. The double quotes are not paired up. We have reached to the end of the string.
+                throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0008E",tmp));        
+          }
+          
+          result.add(tmp);
+          
+        }
+      }
+      return result;
+    }  
+   
+    /**
+     * count the number of characters in a string
+     * @param parent The string to be searched
+     * @param subString The substring to be found
+     * @return the number of occurrence of the subString
+     */
+     private static int count(String parent, String subString) {
+       
+       int count = 0 ;
+       int i = parent.indexOf(subString);
+       while (i > -1) {
+         if (parent.length() >= i+1)
+           parent = parent.substring(i+1);
+         count ++;
+         i = parent.indexOf(subString);
+       }
+       return count;
+     }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/VersionRange.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/VersionRange.java
index e69de29b..809321e9 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/VersionRange.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/VersionRange.java
@@ -0,0 +1,455 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util;
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.apache.aries.util.internal.MessageUtil;
+import org.osgi.framework.Version;
+
+public final class VersionRange {
+    
+    /** A string representation of the version. */
+    private String version;
+
+    /** The minimum desired version for the bundle */
+    private Version minimumVersion;
+
+    /** The maximum desired version for the bundle */
+    private Version maximumVersion;
+
+    /** True if the match is exclusive of the minimum version */
+    private boolean minimumExclusive;
+
+    /** True if the match is exclusive of the maximum version */
+    private boolean maximumExclusive;
+
+    /** A regexp to select the version */
+    private static final Pattern versionCapture = Pattern.compile("\"?(.*?)\"?$");
+
+    /**
+     * 
+     * @param version
+     *            version for the verioninfo
+     */
+    public VersionRange(String version) {
+        this.version = version;
+        processVersionAttribute(version);
+    }
+
+    /**
+     * This method should be used to create a version range from a single
+     * version string.
+     * @param version
+     *            version for the versioninfo
+     * @param exactVersion
+     *            whether this is an exact version {@code true} or goes to infinity
+     *            {@code false}
+     */
+    public VersionRange(String version, boolean exactVersion) {
+        
+        if (exactVersion) {
+            // Do not store this string as it might be just a version, or a range!
+            processExactVersionAttribute(version);
+        } else {
+            this.version = version;
+            processVersionAttribute(this.version);
+        }
+
+        assertInvariants();
+    }
+
+    /**
+     * Constructor designed for internal use only.
+     * 
+     * @param maximumVersion
+     * @param maximumExclusive
+     * @param minimumVersion
+     * @param minimumExclusive
+     * @throws IllegalArgumentException
+     *             if parameters are not valid.
+     */
+    private VersionRange(Version maximumVersion,
+                         boolean maximumExclusive,
+                         Version minimumVersion,
+                         boolean minimumExclusive) {
+        this.maximumVersion = maximumVersion;
+        this.maximumExclusive = maximumExclusive;
+        this.minimumVersion = minimumVersion;
+        this.minimumExclusive = minimumExclusive;
+
+        assertInvariants();
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.aries.application.impl.VersionRange#toString()
+     */
+    @Override
+    public String toString() {
+        // Some constructors don't take in a string that we can return directly, 
+        // so construct one if needed
+        if (version == null) {
+            if (maximumVersion == null) {
+                version = minimumVersion.toString();
+            } else {
+                version = (minimumExclusive ? "(" : "[") + minimumVersion + "," + maximumVersion
+                          + (maximumExclusive ? ")" : "]");
+            }
+        }
+        return this.version;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = 17;
+        result = 31 * result + minimumVersion.hashCode();
+        result = 31 * result + (minimumExclusive ? 1 : 0);
+        result = 31 * result + (maximumVersion != null ? maximumVersion.hashCode() : 0);
+        result = 31 * result + (maximumExclusive ? 1 : 0);
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+        boolean result = false;
+        if (this == other) {
+            result = true;
+        } else if (other instanceof VersionRange) {
+            VersionRange vr = (VersionRange) other;
+            result = minimumVersion.equals(vr.minimumVersion)
+                     && minimumExclusive == vr.minimumExclusive
+                     && (maximumVersion == null ? vr.maximumVersion == null : maximumVersion
+                             .equals(vr.maximumVersion)) && maximumExclusive == vr.maximumExclusive;
+        }
+
+        return result;
+    }
+
+    /**
+     * this method returns the exact version from the versionInfo obj.
+     * this is used for DeploymentContent only to return a valid exact version
+     * otherwise, null is returned.
+     * @return the exact version
+     */
+    public Version getExactVersion() {
+        Version v = null;
+        if (isExactVersion()) {
+            v = getMinimumVersion();
+        }
+        return v;
+    }
+
+    /**
+     * get the maximum version
+     * @return    the maximum version
+     */
+    public Version getMaximumVersion() {
+        return maximumVersion;
+    }
+
+    /**
+     * get the minimum version
+     * @return    the minimum version
+     */
+    public Version getMinimumVersion() {
+        return minimumVersion;
+    }
+
+    /**
+     * is the maximum version exclusive
+     * @return is the max version in the range.
+     */
+    public boolean isMaximumExclusive() {
+        return maximumExclusive;
+    }
+
+    /**
+     * is the maximum version unbounded
+     * @return true if no upper bound was specified.
+     */
+    public boolean isMaximumUnbounded() {
+        boolean unbounded = maximumVersion == null;
+        return unbounded;
+    }
+
+    /**
+     * is the minimum version exclusive
+     * @return true if the min version is in range.
+     */
+    public boolean isMinimumExclusive() {
+        return minimumExclusive;
+    }
+
+    /**
+     * this is designed for deployed-version as that is the exact version.
+     * 
+     * @param version
+     * @return
+     * @throws IllegalArgumentException
+     */
+    private boolean processExactVersionAttribute(String version) throws IllegalArgumentException {
+        boolean success = processVersionAttribute(version);
+
+        if (maximumVersion == null) {
+            maximumVersion = minimumVersion;
+        }
+
+        if (!minimumVersion.equals(maximumVersion)) {
+            throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0011E", version));
+        }
+
+        if (!!!isExactVersion()) {
+            throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0009E", version));
+        }
+
+        return success;
+    }
+
+    /**
+     * process the version attribute,
+     * 
+     * @param version
+     *            the value to be processed
+     * @return
+     * @throws IllegalArgumentException
+     */
+    private boolean processVersionAttribute(String version) throws IllegalArgumentException {
+        boolean success = false;
+
+        if (version == null) {
+            throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0010E"));
+        }
+
+        Matcher matches = versionCapture.matcher(version);
+
+        if (matches.matches()) {
+            String versions = matches.group(1);
+
+            if ((versions.startsWith("[") || versions.startsWith("("))
+                && (versions.endsWith("]") || versions.endsWith(")"))) {
+                if (versions.startsWith("["))
+                    minimumExclusive = false;
+                else if (versions.startsWith("("))
+                    minimumExclusive = true;
+
+                if (versions.endsWith("]"))
+                    maximumExclusive = false;
+                else if (versions.endsWith(")"))
+                    maximumExclusive = true;
+
+                int index = versions.indexOf(',');
+                String minVersion = versions.substring(1, index);
+                String maxVersion = versions.substring(index + 1, versions.length() - 1);
+
+                try {
+                    minimumVersion = new Version(minVersion.trim());
+                    maximumVersion = new Version(maxVersion.trim());
+                    success = true;
+                } catch (NumberFormatException nfe) {
+                    throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0009E", version), nfe);
+                }
+            } else {
+                try {
+                    if (versions.trim().length() == 0)
+                        minimumVersion = new Version(0, 0, 0);
+                    else
+                        minimumVersion = new Version(versions.trim());
+                    success = true;
+                } catch (NumberFormatException nfe) {
+                    throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0009E", version), nfe);
+                }
+            }
+        } else {
+            throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0009E", version));
+        }
+
+        return success;
+    }
+
+    /**
+     * Assert object invariants. Called by constructors to verify that arguments
+     * were valid.
+     * 
+     * @throws IllegalArgumentException
+     *             if invariants are violated.
+     */
+    private void assertInvariants() {
+        if (minimumVersion == null
+            || !isRangeValid(minimumVersion, minimumExclusive, maximumVersion, maximumExclusive)) {
+            IllegalArgumentException e = new IllegalArgumentException();
+            throw e;
+        }
+    }
+
+    /**
+     * Check if the supplied parameters describe a valid version range.
+     * 
+     * @param min
+     *            the minimum version.
+     * @param minExclusive
+     *            whether the minimum version is exclusive.
+     * @param max
+     *            the maximum version.
+     * @param maxExclusive
+     *            whether the maximum version is exclusive.
+     * @return true is the range is valid; otherwise false.
+     */
+    private boolean isRangeValid(Version min,
+                                 boolean minExclusive,
+                                 Version max,
+                                 boolean maxExclusive) {
+        boolean result;
+
+        // A null maximum version is unbounded so means that minimum is smaller
+        // than
+        // maximum.
+        int minMaxCompare = (max == null ? -1 : min.compareTo(max));
+        if (minMaxCompare > 0) {
+            // Minimum larger than maximum is invalid.
+            result = false;
+        } else if (minMaxCompare == 0 && (minExclusive || maxExclusive)) {
+            // If min and max are the same, and either are exclusive, no valid
+            // range
+            // exists.
+            result = false;
+        } else {
+            // Range is valid.
+            result = true;
+        }
+
+        return result;
+    }
+
+    /**
+     * This method checks that the provided version matches the desired version.
+     * 
+     * @param version
+     *            the version.
+     * @return true if the version matches, false otherwise.
+     */
+    public boolean matches(Version version) {
+        boolean result;
+        if (this.getMaximumVersion() == null) {
+            result = this.getMinimumVersion().compareTo(version) <= 0;
+        } else {
+            int minN = this.isMinimumExclusive() ? 0 : 1;
+            int maxN = this.isMaximumExclusive() ? 0 : 1;
+
+            result = (this.getMinimumVersion().compareTo(version) < minN)
+                     && (version.compareTo(this.getMaximumVersion()) < maxN);
+        }
+        return result;
+    }
+
+    /**
+     * check if the versioninfo is the exact version
+     * @return true if the range will match 1 exact version.
+     */
+    public boolean isExactVersion() {
+        return minimumVersion.equals(maximumVersion) && minimumExclusive == maximumExclusive
+               && !!!minimumExclusive;
+    }
+
+    /**
+     * Create a new version range that is the intersection of {@code this} and the argument.
+     * In other words, the largest version range that lies within both {@code this} and
+     * the parameter.
+     * @param range a version range to be intersected with {@code this}.
+     * @return a new version range, or {@code null} if no intersection is possible.
+     */
+    public VersionRange intersect(VersionRange r) {
+        // Use the highest minimum version.
+        final Version newMinimumVersion;
+        final boolean newMinimumExclusive;
+        int minCompare = minimumVersion.compareTo(r.getMinimumVersion());
+        if (minCompare > 0) {
+            newMinimumVersion = minimumVersion;
+            newMinimumExclusive = minimumExclusive;
+        } else if (minCompare < 0) {
+            newMinimumVersion = r.getMinimumVersion();
+            newMinimumExclusive = r.isMinimumExclusive();
+        } else {
+            newMinimumVersion = minimumVersion;
+            newMinimumExclusive = (minimumExclusive || r.isMinimumExclusive());
+        }
+
+        // Use the lowest maximum version.
+        final Version newMaximumVersion;
+        final boolean newMaximumExclusive;
+        // null maximum version means unbounded, so the highest possible value.
+        if (maximumVersion == null) {
+            newMaximumVersion = r.getMaximumVersion();
+            newMaximumExclusive = r.isMaximumExclusive();
+        } else if (r.getMaximumVersion() == null) {
+            newMaximumVersion = maximumVersion;
+            newMaximumExclusive = maximumExclusive;
+        } else {
+            int maxCompare = maximumVersion.compareTo(r.getMaximumVersion());
+            if (maxCompare < 0) {
+                newMaximumVersion = maximumVersion;
+                newMaximumExclusive = maximumExclusive;
+            } else if (maxCompare > 0) {
+                newMaximumVersion = r.getMaximumVersion();
+                newMaximumExclusive = r.isMaximumExclusive();
+            } else {
+                newMaximumVersion = maximumVersion;
+                newMaximumExclusive = (maximumExclusive || r.isMaximumExclusive());
+            }
+        }
+
+        VersionRange result;
+        if (isRangeValid(newMinimumVersion, newMinimumExclusive, newMaximumVersion,
+                newMaximumExclusive)) {
+            result = new VersionRange(newMaximumVersion, newMaximumExclusive, newMinimumVersion,
+                    newMinimumExclusive);
+        } else {
+            result = null;
+        }
+        return result;
+    }
+
+    /**
+     * Parse a version range..
+     * 
+     * @param s
+     * @return VersionRange object.
+     * @throws IllegalArgumentException
+     *             if the String could not be parsed as a VersionRange
+     */
+    public static VersionRange parseVersionRange(String s) throws IllegalArgumentException {
+        return new VersionRange(s);
+    }
+
+    /**
+     * Parse a version range and indicate if the version is an exact version
+     * 
+     * @param s
+     * @param exactVersion
+     * @return VersionRange object.
+     * @throws IllegalArgumentException
+     *             if the String could not be parsed as a VersionRange
+     */
+    public static VersionRange parseVersionRange(String s, boolean exactVersion)
+            throws IllegalArgumentException {
+        return new VersionRange(s, exactVersion);
+    }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/FileSystem.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/FileSystem.java
index e69de29b..d2f150d6 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/FileSystem.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/FileSystem.java
@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.filesystem;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.zip.ZipFile;
+
+import org.apache.aries.util.filesystem.impl.FileSystemImpl;
+import org.apache.aries.util.filesystem.impl.NestedZipDirectory;
+import org.apache.aries.util.io.IOUtils;
+
+/**
+ * An abstraction of a file system. A file system can be a zip, or a directory.
+ */
+public class FileSystem {
+
+  /**
+   * This method gets the IDirectory that represents the root of a virtual file
+   * system. The provided file can either identify a directory, or a zip file.
+   * 
+   * @param fs the zip file.
+   * @return   the root of the virtual FS.
+   */
+  public static IDirectory getFSRoot(File fs)
+  {
+	  return FileSystemImpl.getFSRoot(fs, null);
+  }
+  
+  /**
+   * This method gets an ICloseableDirectory that represents the root of a virtual file
+   * system. The provided InputStream should represent a zip file.
+   * 
+   * When this {@link ICloseableDirectory} is closed then backing resources will be
+   * cleaned up.
+   * 
+   * @param is An input stream to a zip file.
+   * @return   the root of the virtual FS.
+   */
+  public static ICloseableDirectory getFSRoot(InputStream is)
+  {
+    return FileSystemImpl.getFSRoot(is);
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/FileUtils.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/FileUtils.java
index ada1bb9a..4113f7ca 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/FileUtils.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/FileUtils.java
@@ -1,3 +1,69 @@
   + text/plain
   + Date Revision
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.util.filesystem;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.aries.util.manifest.BundleManifest;
+
+public class FileUtils {
+  /**
+   * Check whether a file is a bundle.
+   * @param file the file path
+   * @return
+   */
+  public static boolean isBundle(File file) {
+    BundleManifest bm = BundleManifest.fromBundle(file);
+    return ((bm != null) && (bm.isValid()));
+  }
+
+  /**
+   * Get a list of urls for the bundles under the parent url
+   * @param sourceDir The parent url
+   * @return
+   * @throws IOException
+   */
+  public static  List<URI> getBundlesRecursive(URI sourceDir) throws IOException {
+    List<URI> filesFound = new ArrayList<URI>();
+    if (sourceDir == null) {
+      return filesFound;
+    } if (sourceDir != null) {
+      File sourceFile = new File(sourceDir);
+      if (sourceFile.isFile()) {
+        if (isBundle(sourceFile)) {
+          filesFound.add(sourceDir);
+        }
+      } else if (sourceFile.isDirectory()) {
+        File[] subFiles = sourceFile.listFiles();
+        if ((subFiles !=null) && (subFiles.length >0)) {
+          for (File file : subFiles) {
+            filesFound.addAll(getBundlesRecursive(file.toURI()));
+          }
+        }
+      }
+    }
+    return filesFound;
+  }
+
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/ICloseableDirectory.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/ICloseableDirectory.java
index ada1bb9a..c4687f07 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/ICloseableDirectory.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/ICloseableDirectory.java
@@ -1,3 +1,37 @@
   + text/plain
   + Date Revision
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.filesystem;
+
+import java.io.Closeable;
+
+/**
+ * Implementation of IDirectory that is more efficient for batch operations as it does not due 
+ * automatic resource management. Instead the user has to explicitly call close to release resources.
+ * Resources are cached for the current IDirectory archive only. Nested archives should be converted to 
+ * {@link ICloseableDirectory} separately.
+ */
+public interface ICloseableDirectory extends IDirectory, Closeable {
+	/**
+	 * Checks whether the closeable directory has been closed
+	 */
+	boolean isClosed();
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/IDirectory.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/IDirectory.java
index ada1bb9a..eeb0cc80 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/IDirectory.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/IDirectory.java
@@ -1,3 +1,71 @@
   + text/plain
   + Date Revision
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.filesystem;
+
+import java.util.List;
+
+/**
+ * A virtual directory in a file system. Widely used to present a common view of regular 
+ * file systems, jar and zip files. 
+ */
+public interface IDirectory extends Iterable<IFile>, IFile
+{
+  /**
+   * @return the list of files in this directory. Files must be in this directory
+   *         and not in sub-directories.
+   */
+  public List<IFile> listFiles();
+  
+  /**
+   * 
+   * @return the list of files in all directories (including sub-directories). This is the complete list.
+   */
+  public List<IFile> listAllFiles();
+  
+  /**
+   * Gets the requested file under this directory. The file may be located any
+   * number of levels within this directory. The name is relative to this
+   * directory. If the file cannot be found it will return null.
+   * 
+   * @param name the name of the file.
+   * @return     the IFile, or null if no such file exists.
+   */
+  public IFile getFile(String name);
+  
+  /**
+   * @return true if this IDirectory is the root of the virtual file system.
+   */
+  public boolean isRoot();
+  
+  /**
+   * Open a more effective implementation with user regulated resource management. The implementation will be 
+   * more efficient for batch operations. Make sure to call close when finished with the returned IDirectory. 
+   * 
+   * IFiles and IDirectories other than the returned closeable directory
+   * will stay valid after calling the close method but will no longer perform as efficiently. InputStreams that are
+   * open at the time of calling close may be invalidated.
+   * 
+   * @return {@link ICloseableDirectory} or null if a batch aware version of this {@link IDirectory} is not supported
+   */
+  public ICloseableDirectory toCloseable();
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/IFile.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/IFile.java
index ada1bb9a..0e4a0297 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/IFile.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/IFile.java
@@ -1,3 +1,92 @@
   + text/plain
   + Date Revision
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.filesystem;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+
+/**
+ * A virtual file on the virtual file system. This may represent a file or a
+ * directory.
+ */
+public interface IFile
+{
+  /**
+   * @return the name of the file relative to the root of the virtual FS. This will return a '/' separated path
+   * indepedent of underlying filesystem
+   */
+  public String getName();
+  /**
+   * @return true iff this IFile is also an IDirectory
+   */
+  public boolean isDirectory();
+  /**
+   * @return true iff this IFile is not an IDirectory
+   */
+  public boolean isFile();
+  /**
+   * @return the last modified date of the file.
+   */
+  public long getLastModified();
+  /**
+   * @return the size of the file.
+   */
+  public long getSize();
+  
+  /**
+   * @return if this is a directory return this as an IDirectory, otherwise return null.
+   */
+  public IDirectory convert();
+  
+  /**
+   * @return if this is a directory or an archive, returns the opened IDirectory
+   */
+  public IDirectory convertNested();
+  
+  /**
+   * @return returns the parent directory of this IFile, or null if this is the root.
+   */
+  public IDirectory getParent();
+  
+  /**
+   * The input stream returned by this method should always be closed after use.
+   * 
+   * @return An InputStream to read the file from.
+   * 
+   * @throws IOException
+   * @throws UnsupportedOperationException If the IFile is also an IDirectory.
+   */
+  public InputStream open() throws IOException, UnsupportedOperationException;
+  
+  /**
+   * @return the root of this file system.
+   */
+  public IDirectory getRoot();
+  /**
+   * @return a URL that can be used to get at this file at a later date.
+   * @throws MalformedURLException 
+   */
+  public URL toURL() throws MalformedURLException ;
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/CloseableDirectory.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/CloseableDirectory.java
index e69de29b..95e1d571 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/CloseableDirectory.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/CloseableDirectory.java
@@ -0,0 +1,142 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.filesystem.impl;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.aries.util.filesystem.ICloseableDirectory;
+import org.apache.aries.util.filesystem.IDirectory;
+import org.apache.aries.util.filesystem.IFile;
+import org.apache.aries.util.internal.MessageUtil;
+
+public class CloseableDirectory implements ICloseableDirectory {
+	protected IDirectory delegate;
+	private final AtomicBoolean closed = new AtomicBoolean(false);
+
+	public CloseableDirectory(IDirectory delegate) {
+		this.delegate = delegate;
+	}
+	
+	public String getName() {
+		checkNotClosed();
+		return delegate.getName();
+	}
+
+	public boolean isDirectory() {
+		checkNotClosed();
+		return delegate.isDirectory();
+	}
+
+	public boolean isFile() {
+		checkNotClosed();
+		return delegate.isFile();
+	}
+
+	public long getLastModified() {
+		checkNotClosed();
+		return delegate.getLastModified();
+	}
+
+	public IFile getFile(String name) {
+		checkNotClosed();
+		return delegate.getFile(name);
+	}
+
+	public long getSize() {
+		checkNotClosed();
+		return delegate.getSize();
+	}
+
+	public IDirectory convert() {
+		checkNotClosed();
+		return delegate.convert();
+	}
+
+	public IDirectory convertNested() {
+		checkNotClosed();
+		return delegate.convertNested();
+	}
+
+	public boolean isRoot() {
+		checkNotClosed();
+		return delegate.isRoot();
+	}
+
+	public IDirectory getParent() {
+		checkNotClosed();
+		return delegate.getParent();
+	}
+
+	public IDirectory getRoot() {
+		checkNotClosed();
+		return delegate.getRoot();
+	}
+
+	public Iterator<IFile> iterator() {
+		checkNotClosed();
+		return delegate.iterator();
+	}
+
+	public List<IFile> listFiles() {
+		checkNotClosed();
+		return delegate.listFiles();
+	}
+
+	public List<IFile> listAllFiles() {
+		checkNotClosed();
+		return delegate.listAllFiles();
+	}
+
+	public ICloseableDirectory toCloseable() {
+		checkNotClosed();
+		return delegate.toCloseable();
+	}
+
+	public InputStream open() throws IOException, UnsupportedOperationException {
+		checkNotClosed();
+		return delegate.open();
+	}
+
+	public URL toURL() throws MalformedURLException {
+		checkNotClosed();
+		return delegate.toURL();
+	}
+
+	public final void close() throws IOException {
+		if (closed.compareAndSet(false, true)) {
+			cleanup();
+		}
+	}
+	
+	protected void cleanup() {}
+	
+	protected void checkNotClosed() {
+		if (isClosed()) throw new IllegalStateException(MessageUtil.getMessage("UTIL0018E"));
+	}
+
+	public boolean isClosed() {
+		return closed.get();
+	}
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/DirectoryImpl.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/DirectoryImpl.java
index e69de29b..2ae1d4cb 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/DirectoryImpl.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/DirectoryImpl.java
@@ -0,0 +1,137 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.filesystem.impl;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.aries.util.filesystem.ICloseableDirectory;
+import org.apache.aries.util.filesystem.IDirectory;
+import org.apache.aries.util.filesystem.IFile;
+
+/**
+ * An IDirectory representing a java.io.File whose isDirectory method returns true.
+ */
+public class DirectoryImpl extends FileImpl implements IDirectory
+{
+  /**
+   * @param dir      the file to represent.
+   * @param rootFile the file that represents the FS root.
+   */
+  public DirectoryImpl(File dir, File rootFile)
+  {
+    super(dir, rootFile);
+  }
+
+  public IFile getFile(String name)
+  {
+    File desiredFile = new File(file, name);
+    IFile result = null;
+    
+    if (desiredFile.exists()) 
+    {
+        if(!desiredFile.isDirectory())
+          result = new FileImpl(desiredFile, rootDirFile);
+        else
+          result = new DirectoryImpl(desiredFile, rootDirFile);
+    }
+    
+    return result;
+  }
+
+  public boolean isRoot()
+  {
+    boolean result = (rootDirFile == file);
+    return result;
+  }
+
+  public List<IFile> listFiles()
+  {
+    List<IFile> files = new ArrayList<IFile>();
+    File[] filesInDir = file.listFiles();
+    if (filesInDir != null) {
+      for (File f : filesInDir) {
+        if (f.isFile()) {
+          files.add(new FileImpl(f, rootDirFile));
+        } else if (f.isDirectory()) {
+          files.add(new DirectoryImpl(f, rootDirFile));
+        }
+      }
+    }
+    return files;
+  }
+  
+  public List<IFile> listAllFiles()
+  {
+    List<IFile> files = new ArrayList<IFile>();
+    File[] filesInDir = file.listFiles();
+    if (filesInDir != null) {
+      for (File f : filesInDir) {
+        if (f.isFile()) {
+          files.add(new FileImpl(f, rootDirFile));
+        } else if (f.isDirectory()) {
+          IDirectory subdir = new DirectoryImpl(f, rootDirFile);
+          files.add(subdir);
+          files.addAll(subdir.listAllFiles());
+        }
+      }
+    }
+    return files;
+  }
+  
+  public Iterator<IFile> iterator()
+  {
+	return listFiles().iterator();
+  }
+
+  public IDirectory getParent()
+  {
+    return isRoot() ? null : super.getParent();
+  }
+
+  public IDirectory convert()
+  {
+    return this;
+  }
+
+  public InputStream open() throws IOException
+  {
+    throw new UnsupportedOperationException();
+  }
+
+  public long getLastModified()
+  {
+    long result = super.getLastModified();
+    for (IFile aFile : this) {
+      long tmpLastModified = aFile.getLastModified();
+      
+      if (tmpLastModified > result) result = tmpLastModified;
+    }
+    return result;
+  }
+
+  public ICloseableDirectory toCloseable() {
+	return new CloseableDirectory(this);
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/FileImpl.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/FileImpl.java
index e69de29b..eb24f9dd 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/FileImpl.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/FileImpl.java
@@ -0,0 +1,147 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.filesystem.impl;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+
+import org.apache.aries.util.filesystem.IDirectory;
+import org.apache.aries.util.filesystem.IFile;
+
+/**
+ * An implementation of IFile that represents a java.io.File.
+ */
+public class FileImpl implements IFile
+{
+  /** The name of the root directory of the file system */
+  protected String rootDir;
+  /** This file in the file system */
+  protected File file;
+  /** The root File in the file system */
+  protected File rootDirFile;
+  /** The name of this file in the vFS */
+  private String name;
+  
+  /**
+   * @param f        this file.
+   * @param rootFile the root of the vFS.
+   */
+  public FileImpl(File f, File rootFile)
+  {
+    file = f;
+    this.rootDirFile = rootFile;
+    rootDir = rootFile.getAbsolutePath();
+    
+    if (f.equals(rootFile)) name = "";
+    else name = file.getAbsolutePath().substring(rootDir.length() + 1).replace('\\', '/');
+  }
+  
+  public IDirectory convert()
+  {
+    return null;
+  }
+
+  public long getLastModified()
+  {
+    long result = file.lastModified();
+    return result;
+  }
+
+  public String getName()
+  {
+    return name;
+  }
+
+  public IDirectory getParent()
+  {
+    IDirectory parent = new DirectoryImpl(file.getParentFile(), rootDirFile);
+    return parent;
+  }
+
+  public long getSize()
+  {
+    long size = file.length();
+    return size;
+  }
+
+  public boolean isDirectory()
+  {
+    boolean result = file.isDirectory();
+    return result;
+  }
+
+  public boolean isFile()
+  {
+    boolean result = file.isFile();
+    return result;
+  }
+
+  public InputStream open() throws IOException
+  {
+    InputStream is = new FileInputStream(file);
+    return is;
+  }
+
+  public IDirectory getRoot()
+  {
+    IDirectory root = new DirectoryImpl(rootDirFile, rootDirFile);
+    return root;
+  }
+
+  public URL toURL() throws MalformedURLException
+  {
+    URL result = file.toURI().toURL();
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj)
+  {
+    if (obj == null) return false;
+    if (obj == this) return true;
+    
+    if (obj.getClass() == getClass()) {
+      return file.equals(((FileImpl)obj).file);
+    }
+    
+    return false;
+  }
+
+  @Override
+  public int hashCode()
+  {
+    return file.hashCode();
+  }
+  
+  @Override
+  public String toString()
+  {
+    return file.getAbsolutePath();
+  }
+
+  public IDirectory convertNested() {
+	  if (isDirectory()) return convert();
+	  else return FileSystemImpl.getFSRoot(file, getParent());
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/FileSystemImpl.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/FileSystemImpl.java
index ada1bb9a..a5e16734 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/FileSystemImpl.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/FileSystemImpl.java
@@ -1,3 +1,133 @@
   + text/plain
   + Date Revision
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.filesystem.impl;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipInputStream;
+
+import org.apache.aries.util.filesystem.ICloseableDirectory;
+import org.apache.aries.util.filesystem.IDirectory;
+import org.apache.aries.util.filesystem.IFile;
+import org.apache.aries.util.io.IOUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class FileSystemImpl {
+
+	private static final Logger _logger = LoggerFactory.getLogger(FileSystemImpl.class.getName());
+
+	/**
+	 * This method gets the IDirectory that represents the root of a virtual file
+	 * system. The provided file can either identify a directory, or a zip file.
+	 * 
+	 * @param fs the zip file.
+	 * @return   the root of the virtual FS.
+	 */
+	public static IDirectory getFSRoot(File fs, IDirectory parent)
+	{
+		IDirectory dir = null;
+
+		if (fs.exists()) {
+			if (fs.isDirectory()) {
+				dir = new DirectoryImpl(fs, fs);
+			} else if (fs.isFile() && isValidZip(fs)) {
+				try {
+					dir = new ZipDirectory(fs, parent);
+				} catch (IOException e) {
+					_logger.error ("IOException in IDirectory.getFSRoot", e);
+				}
+			}
+		}
+		else {
+			// since this method does not throw an exception but just returns null, make sure we do not lose the error
+			_logger.error("File not found in IDirectory.getFSRoot", new FileNotFoundException(fs.getPath()));
+		}
+		return dir;
+	}
+	
+	/**
+	 * Check whether a file is actually a valid zip
+	 * @param zip
+	 * @return
+	 */
+	public static boolean isValidZip(File zip) {
+		try {
+			ZipFile zf = new ZipFile(zip);
+			zf.close();
+			return true;
+		} catch (IOException e) {
+			_logger.debug("Not a valid zip: "+zip);
+			return false;
+		}
+	}
+	
+	/**
+	 * Check whether a file is actually a valid zip
+	 * @param zip
+	 * @return
+	 */
+	public static boolean isValidZip(IFile zip) {
+		ZipInputStream zis = null;
+		try {
+			// just opening the stream ain't enough, we have to check the first entry
+			zis = new ZipInputStream(zip.open());
+			return zis.getNextEntry() != null;
+		} catch (IOException e) {
+			_logger.debug("Not a valid zip: "+zip);
+			return false;
+		} finally {
+			IOUtils.close(zis);
+		}
+	}
+
+  public static ICloseableDirectory getFSRoot(InputStream is) {
+    File tempFile = null;
+    try {
+      tempFile = File.createTempFile("inputStreamExtract", ".zip");
+    } catch (IOException e1) {
+      _logger.error ("IOException in IDirectory.getFSRoot", e1);
+      return null;
+    }
+    FileOutputStream fos = null; 
+    try {
+      fos = new FileOutputStream(tempFile);
+      IOUtils.copy(is, fos);  
+    } catch (IOException e) {
+      return null;
+    } finally {
+      IOUtils.close(fos);
+    }
+    
+    IDirectory dir = getFSRoot(tempFile, null);
+    
+    if(dir == null)
+      return null;
+    else
+      return new InputStreamClosableDirectory(dir, tempFile);
+
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/InputStreamClosableDirectory.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/InputStreamClosableDirectory.java
index ada1bb9a..10de1db1 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/InputStreamClosableDirectory.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/InputStreamClosableDirectory.java
@@ -1,3 +1,41 @@
   + text/plain
   + Date Revision
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.filesystem.impl;
+
+import java.io.File;
+
+import org.apache.aries.util.filesystem.IDirectory;
+
+public class InputStreamClosableDirectory extends CloseableDirectory {
+
+  private final File tempFile;
+  
+  public InputStreamClosableDirectory(IDirectory delegate, File temp) {
+    super(delegate);
+    tempFile = temp;
+  }
+
+  @Override
+  protected void cleanup() {
+      tempFile.delete();
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/NestedCloseableDirectory.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/NestedCloseableDirectory.java
index ada1bb9a..2602d267 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/NestedCloseableDirectory.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/NestedCloseableDirectory.java
@@ -1,3 +1,67 @@
   + text/plain
   + Date Revision
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.filesystem.impl;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.zip.ZipFile;
+
+import org.apache.aries.util.filesystem.IFile;
+import org.apache.aries.util.io.IOUtils;
+
+public class NestedCloseableDirectory extends CloseableDirectory {
+
+	private final File tempFile;
+	private final ZipFile zip;
+	
+	public NestedCloseableDirectory(IFile archive, NestedZipDirectory delegate) throws IOException {
+		super(delegate);
+		
+		tempFile = File.createTempFile("archiveExtract", ".jar");
+
+		FileOutputStream fos = null; 
+		try {
+			fos = new FileOutputStream(tempFile);
+			IOUtils.copy(archive.open(), fos);	
+			this.delegate = new NestedZipDirectory(delegate, this);
+			
+			zip = new ZipFile(tempFile);
+		} catch (IOException e) {
+			IOUtils.close(fos);
+			tempFile.delete();
+			throw e;
+		}
+	}
+	
+	public ZipFile getZipFile() {
+		return zip;
+	}
+
+	@Override
+	protected void cleanup() {
+		try {
+			zip.close();
+		} catch (IOException e) {}
+		tempFile.delete();
+	}
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/NestedZipDirectory.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/NestedZipDirectory.java
index ada1bb9a..593e933c 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/NestedZipDirectory.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/NestedZipDirectory.java
@@ -1,3 +1,220 @@
   + text/plain
   + Date Revision
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.filesystem.impl;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipInputStream;
+
+import org.apache.aries.util.filesystem.ICloseableDirectory;
+import org.apache.aries.util.filesystem.IDirectory;
+import org.apache.aries.util.filesystem.IFile;
+import org.apache.aries.util.io.IOUtils;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class NestedZipDirectory extends NestedZipFile implements IDirectory {
+	
+	private static final Logger logger = LoggerFactory.getLogger(NestedZipDirectory.class.getName());
+	
+	public NestedZipDirectory(IFile archive, ZipEntry entry, NestedZipDirectory parent, NestedCloseableDirectory cache) {
+		super(archive, entry, parent, cache);
+	}
+	
+	public NestedZipDirectory(IFile archive, String pathInZip, NestedZipDirectory parent, NestedCloseableDirectory cache) {
+		super(archive, pathInZip, parent, cache);
+	}
+	
+	public NestedZipDirectory(IFile archive) {
+		super(archive);
+	}
+	
+	public NestedZipDirectory(NestedZipDirectory other, NestedCloseableDirectory cache) {
+		super(other, cache);
+	}
+	
+	public IDirectory convert() {
+		return this;
+	}
+
+	public Iterator<IFile> iterator() {
+		return listFiles().iterator();
+	}
+
+	public List<IFile> listFiles() {
+		return listFiles(false);
+	}
+
+	public List<IFile> listAllFiles() {
+		return listFiles(true);
+	}
+	
+	private List<IFile> listFiles(boolean includeFilesInNestedSubdirs) {
+			Map<String, ZipEntry> entriesByName = new LinkedHashMap<String, ZipEntry>();
+			for (ZipEntry entry : getAllEntries()) {
+				if (ZipDirectory.isInDir(getNameInZip(), entry, includeFilesInNestedSubdirs)) {
+					entriesByName.put(entry.getName(), entry);
+				}
+			}
+
+			List<IFile> files = new ArrayList<IFile>();
+			for (ZipEntry ze : entriesByName.values()) {
+				NestedZipDirectory parent = includeFilesInNestedSubdirs ? buildParent(ze, entriesByName) : this;
+				if (ze.isDirectory()) files.add(new NestedZipDirectory(archive, ze, parent, cache));
+				else files.add(new NestedZipFile(archive, ze, parent, cache));
+			}
+			
+			return files;
+	}
+	
+	private List<? extends ZipEntry> getAllEntries() {
+		if (cache != null && !!!cache.isClosed()) {
+			return Collections.list(cache.getZipFile().entries());
+		} else {
+			ZipInputStream zis = null;
+			try {
+				zis = new ZipInputStream(archive.open());
+				
+				List<ZipEntry> result = new ArrayList<ZipEntry>();
+				ZipEntry entry = zis.getNextEntry();
+				while (entry != null) {
+					result.add(entry);
+					entry = zis.getNextEntry();
+				}
+				
+				return result;				
+			} catch (IOException e) {
+				logger.error("IOException reading nested ZipFile", e);
+				return Collections.emptyList();
+			} finally {
+				IOUtils.close(zis);
+			}
+		}		
+	}
+	
+	private NestedZipDirectory buildParent(ZipEntry entry, Map<String,ZipEntry> entries) {
+		NestedZipDirectory result = this;
+		
+		String path = entry.getName().substring(getNameInZip().length());
+		String[] segments = path.split("/");
+		
+		if (segments != null && segments.length > 1) {
+			StringBuilder entryPath = new StringBuilder(getNameInZip());
+			for (int i=0; i<segments.length-1; i++) {
+				String p = segments[i];
+				entryPath.append(p).append("/");
+				ZipEntry ze = entries.get(entryPath.toString());
+				
+				if (ze != null) {
+					result = new NestedZipDirectory(archive, ze, result, cache);
+				} else {
+					result = new NestedZipDirectory(archive, entryPath.toString(), result, cache);
+				}
+			}
+		}
+		
+		return result;
+	}
+
+	public IFile getFile(String name) {
+		Map<String,ZipEntry> entries = new HashMap<String, ZipEntry>();
+		ZipEntry ze;
+
+		if (cache != null && !!!cache.isClosed()) {
+			ZipFile zip = cache.getZipFile();
+
+			String[] segments = name.split("/");
+			StringBuilder path = new StringBuilder();
+			for (String s : segments) {
+				path.append(s).append('/');
+				ZipEntry p = zip.getEntry(path.toString());
+				if (p != null) entries.put(path.toString(), p);
+			}
+			
+			ze = zip.getEntry(name);
+			
+		} else {
+			ZipInputStream zis = null;
+			
+			try {
+				zis = new ZipInputStream(archive.open());
+				
+				ze = zis.getNextEntry();
+				
+				while (ze != null && !!!ze.getName().equals(name)) {
+					if (name.startsWith(ze.getName())) entries.put(ze.getName(), ze);
+					
+					ze = zis.getNextEntry();
+				}
+			} catch (IOException e) {
+				logger.error("IOException reading nested ZipFile", e);
+				return null;
+			} finally {
+				IOUtils.close(zis);
+			}
+		}
+		
+		if (ze != null) {
+			NestedZipDirectory parent = buildParent(ze, entries);
+			if (ze.isDirectory()) return new NestedZipDirectory(archive, ze, parent, cache);
+			else return new NestedZipFile(archive, ze, parent, cache);
+		} else {
+			return null;
+		}
+	}
+
+	
+	public boolean isDirectory() {
+		return true;
+	}
+
+	public InputStream open() throws IOException, UnsupportedOperationException {
+		throw new UnsupportedOperationException();
+	}
+
+	public boolean isFile() {
+		return false;
+	}
+
+	public boolean isRoot() {
+		return false;
+	}
+
+	public ICloseableDirectory toCloseable() {
+		try {
+			return new NestedCloseableDirectory(archive, this);			
+		} catch (IOException e) {
+			logger.error("Exception while creating extracted version of nested zip file", e);
+			return null;
+		}		
+	}
+
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/NestedZipFile.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/NestedZipFile.java
index e69de29b..fcf9216f 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/NestedZipFile.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/NestedZipFile.java
@@ -0,0 +1,193 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.filesystem.impl;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipInputStream;
+
+import org.apache.aries.util.filesystem.IDirectory;
+import org.apache.aries.util.filesystem.IFile;
+
+public class NestedZipFile implements IFile {
+	private final String name;
+	private final long size;
+	private final long lastModified;
+	private final IDirectory parent;
+	protected final IFile archive;
+	private final String nameInZip;
+	protected final NestedCloseableDirectory cache;
+	
+	/**
+	 * Construct a nested zip file
+	 * @param archive
+	 * @param entry
+	 * @param parent
+	 */
+	public NestedZipFile(IFile archive, ZipEntry entry, NestedZipDirectory parent, NestedCloseableDirectory cache) {
+		this.archive = archive;
+		this.parent = parent;
+		this.nameInZip = entry.getName();
+
+		name = archive.getName() + "/" + (nameInZip.endsWith("/") ? nameInZip.substring(0, nameInZip.length()-1) : nameInZip);
+		size = entry.getSize();
+		lastModified = entry.getTime();
+		this.cache = cache;
+	}
+	
+	public NestedZipFile(IFile archive, String pathInZip, NestedZipDirectory parent, NestedCloseableDirectory cache) {
+		this.archive = archive;
+		this.parent = parent;
+		this.nameInZip = pathInZip;
+
+		name = archive.getName() + "/" + (nameInZip.endsWith("/") ? nameInZip.substring(0, nameInZip.length()-1) : nameInZip);
+		size = -1;
+		lastModified = -1;
+		this.cache = cache;
+	}
+	
+	
+	public NestedZipFile(IFile archive) {
+		this.archive = archive;
+		this.parent = archive.getParent();
+		this.nameInZip = "";
+
+		name = archive.getName();
+		lastModified = archive.getLastModified();
+		size = archive.getSize();
+		cache = null;
+	}
+	
+	public NestedZipFile(NestedZipFile other, NestedCloseableDirectory cache) {
+		name = other.name;
+		size = other.size;
+		lastModified = other.lastModified;
+		parent = other.parent;
+		archive = other.archive;
+		nameInZip = other.nameInZip;
+		
+		this.cache = cache;
+	}
+	
+	public String getNameInZip() {
+		return nameInZip;
+	}
+	
+	public String getName() {
+		return name;
+	}
+
+	public boolean isDirectory() {
+		return false;
+	}
+
+	public boolean isFile() {
+		return true;
+	}
+
+	public long getLastModified() {
+		return lastModified;
+	}
+
+	public long getSize() {
+		return size;
+	}
+
+	public IDirectory convert() {
+		return null;
+	}
+
+	public IDirectory convertNested() {
+		if (isDirectory()) return convert();
+		else if (FileSystemImpl.isValidZip(this)) return new NestedZipDirectory(this);
+		else return null;
+	}
+
+	public IDirectory getParent() {
+		return parent;
+	}
+
+	public InputStream open() throws IOException, UnsupportedOperationException {
+		if (cache != null && !!!cache.isClosed()) {
+			ZipFile zip = cache.getZipFile();
+			ZipEntry ze = zip.getEntry(nameInZip);
+			
+			if (ze != null) return zip.getInputStream(ze);
+			else return null;
+		} else {
+			final ZipInputStream zis = new ZipInputStream(archive.open());
+			
+			ZipEntry entry = zis.getNextEntry();
+			while (entry != null && !!!entry.getName().equals(nameInZip)) {
+				entry = zis.getNextEntry();
+			}
+			
+			if (entry != null) {
+				return zis;
+			} else {
+				zis.close();
+				return null;
+			}
+		}
+	}
+
+	public IDirectory getRoot() {
+		return archive.getRoot();
+	}
+
+	public URL toURL() throws MalformedURLException
+	{
+		if (nameInZip.length() == 0) return archive.toURL();
+		else {
+			String entryURL = "jar:" + archive.toURL() + "!/" + nameInZip;
+			return new URL(entryURL);
+		}
+	}
+
+	@Override
+	public boolean equals(Object obj)
+	{
+		if (obj == null) return false;
+		if (obj == this) return true;
+
+		if (obj.getClass() == getClass()) {
+			return toString().equals(obj.toString());
+		}
+
+		return false;
+	}
+
+	@Override
+	public int hashCode()
+	{
+		return toString().hashCode();
+	}
+
+	@Override
+	public String toString()
+	{
+		if (nameInZip.length() == 0) return archive.toString();
+		return archive.toString() + "/" + nameInZip;
+	}
+
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/ZipCloseableDirectory.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/ZipCloseableDirectory.java
index e69de29b..c408796f 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/ZipCloseableDirectory.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/ZipCloseableDirectory.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.filesystem.impl;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.zip.ZipFile;
+
+import org.apache.aries.util.io.IOUtils;
+
+public class ZipCloseableDirectory extends CloseableDirectory {
+	private final ZipFile zip;
+	
+	public ZipCloseableDirectory(File archive, ZipDirectory parent) throws IOException {
+		super(parent);
+
+		this.zip = new ZipFile(archive);
+		delegate = new ZipDirectory(parent, this);
+	}
+	
+	public ZipFile getZipFile() {
+		return zip;
+	}
+	
+	@Override
+	protected void cleanup() {
+		try {
+			IOUtils.close(zip);
+		} catch (IOException e) {}
+	}
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/ZipDirectory.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/ZipDirectory.java
index e69de29b..bfc1109a 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/ZipDirectory.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/ZipDirectory.java
@@ -0,0 +1,266 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.filesystem.impl;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+
+import org.apache.aries.util.filesystem.ICloseableDirectory;
+import org.apache.aries.util.filesystem.IDirectory;
+import org.apache.aries.util.filesystem.IFile;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * A directory in the zip.
+ */
+public class ZipDirectory extends ZipFileImpl implements IDirectory
+{
+  private static final Logger logger = LoggerFactory.getLogger(ZipDirectory.class.getName());
+
+  /** The root of the zip FS. */
+  private final IDirectory root;
+  private final boolean zipRoot;
+  
+  /**
+   * Constructs a directory in the zip.
+   * 
+   * @param zip1   the zip file.
+   * @param entry1 the entry in the zip representing this dir.
+   * @param parent the parent directory.
+   */
+  public ZipDirectory(File zip1, ZipEntry entry1, ZipDirectory parent, ZipCloseableDirectory cache)
+  {
+    super(zip1, entry1, parent, cache);
+    zipRoot = false;
+    root = parent.getRoot();
+  }
+
+  /**
+   * This constructor creates the root of the zip.
+   * @param file
+   * @param fs
+   * @param parent
+   * @throws MalformedURLException 
+   */
+  public ZipDirectory(File fs, IDirectory parent) throws MalformedURLException
+  {
+    super(fs, parent);
+    root = (parent == null) ? this : parent.getRoot();
+    zipRoot = true;
+  }
+  
+  public ZipDirectory(ZipDirectory other, ZipCloseableDirectory cache) {
+	  super(other, cache);
+	  root = other.root;
+	  zipRoot = other.zipRoot;
+  }
+
+  public IFile getFile(String name)
+  {
+    IFile result = null;
+    
+    String entryName = isZipRoot() ? name : getNameInZip() + "/" + name;
+    
+    ZipEntry entryFile = getEntry(entryName);
+    
+    if (entryFile != null) {
+      if (!!!entryFile.isDirectory()) {
+        result = new ZipFileImpl(zip, entryFile, buildParent(entryFile), cache);
+      } else {
+        result = new ZipDirectory(zip, entryFile, buildParent(entryFile), cache);
+      }
+    }
+    return result;
+  }
+
+  /**
+   * This method builds the parent directory hierarchy for a file.
+   * @param foundEntry
+   * @return the parent of the entry.
+   */
+  private ZipDirectory buildParent(ZipEntry foundEntry)
+  {
+    ZipDirectory result = this;
+    
+    String name = foundEntry.getName();
+    
+    name = name.substring(getNameInZip().length());
+    
+    String[] paths = name.split("/");
+    
+    StringBuilder baseBuilderCrapThingToGetRoundFindBugs = new StringBuilder(getNameInZip());
+    
+    if (!!!isZipRoot()) baseBuilderCrapThingToGetRoundFindBugs.append('/');
+    // Build 'result' as a chain of ZipDirectories. This will only work if java.util.ZipFile recognises every 
+    // directory in the chain as being a ZipEntry in its own right. 
+    outer: if (paths != null && paths.length > 1) {
+      for (int i = 0; i < paths.length - 1; i++) {
+        String path = paths[i];
+        baseBuilderCrapThingToGetRoundFindBugs.append(path);
+        ZipEntry dirEntry = getEntry(baseBuilderCrapThingToGetRoundFindBugs.toString());
+        if (dirEntry == null) { 
+          result = this;
+          break outer;
+        }
+        result = new ZipDirectory(zip, dirEntry, result, cache);
+        baseBuilderCrapThingToGetRoundFindBugs.append('/');
+      }
+    }
+    return result;
+  }
+
+  public boolean isRoot()
+  {
+	  return getParent() == null;
+  }
+
+  public List<IFile> listFiles()
+  {
+	  return listFiles(false);
+  }
+
+  public List<IFile> listAllFiles()
+  {
+	  return listFiles(true);
+  }
+  
+  private List<IFile> listFiles(boolean includeFilesInNestedSubdirs)
+  {
+	  List<IFile> files = new ArrayList<IFile>();
+
+	  ZipFile z = openZipFile();
+	  List<? extends ZipEntry> entries = Collections.list(z.entries());
+
+	  for (ZipEntry possibleEntry : entries) {
+		  if (isInDir(getNameInZip(), possibleEntry, includeFilesInNestedSubdirs)) {
+			  ZipDirectory parent = includeFilesInNestedSubdirs ? buildParent(possibleEntry) : this;
+			  if (possibleEntry.isDirectory()) {
+				  files.add(new ZipDirectory(zip, possibleEntry, parent, cache));
+			  } else {
+				  files.add(new ZipFileImpl(zip, possibleEntry, parent, cache));
+			  }
+		  }
+
+	  }
+	  
+	  closeZipFile(z);
+	  return files;	  
+  }
+  
+  /**
+   * This method works out if the provided entry is inside this directory. It
+   * returns false if it is not, or if it is in a sub-directory.
+   * 
+   * @param possibleEntry
+   * @param whether files in subdirectories are to be included
+   * @return true if it is in this directory.
+   */
+  protected static boolean isInDir(String parentDir, ZipEntry possibleEntry, boolean allowSubDirs)
+  {
+    boolean result;
+    String name = possibleEntry.getName();
+    if (name.endsWith("/")) name = name.substring(0, name.length() - 1);
+    result = (name.startsWith(parentDir) && !!!name.equals(parentDir) && (allowSubDirs || name.substring(parentDir.length() + 1).indexOf('/') == -1));
+    return result;
+  }
+
+  public Iterator<IFile> iterator()
+  {
+    return listFiles().iterator();
+  }
+
+  public IDirectory convert()
+  {
+    return this;
+  }
+
+  public boolean isDirectory()
+  {
+    return true;
+  }
+
+  public boolean isFile()
+  {
+    return false;
+  }
+
+  public InputStream open() 
+  {
+    throw new UnsupportedOperationException();
+  }
+
+  public IDirectory getRoot()
+  {
+    return root;
+  }
+  
+  public boolean isZipRoot() {
+	  return zipRoot;
+  }
+    
+  // Although we only delegate to our super class if we removed this Findbugs
+  // would correctly point out that we add fields in this class, but do not
+  // take them into account for the equals method. In fact this is not a problem
+  // we do not care about the root when doing an equality check, but by including
+  // an equals or hashCode in here we can clearly document that we did this
+  // on purpose. Hence this comment.
+  @Override
+  public boolean equals(Object other)
+  {
+    return super.equals(other);
+  }
+  
+  @Override
+  public int hashCode()
+  {
+    return super.hashCode();
+  }
+  
+  private ZipEntry getEntry(String entryName) {
+    ZipFile z = openZipFile();
+    ZipEntry entryFile = null;
+    
+    if (z != null) {
+      entryFile = z.getEntry(entryName);
+      closeZipFile(z);
+    }
+    return entryFile;
+  }
+
+  public ICloseableDirectory toCloseable() {
+	  try {
+		  return new ZipCloseableDirectory(zip, this);
+	  } catch (IOException e) {
+		  logger.error("IOException opening zip file", this);
+		  return null;
+	  }
+  }
+}
+
+
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/ZipFileImpl.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/ZipFileImpl.java
index e69de29b..3bf844d4 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/ZipFileImpl.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/filesystem/impl/ZipFileImpl.java
@@ -0,0 +1,314 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.filesystem.impl;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipException;
+import java.util.zip.ZipFile;
+
+import org.apache.aries.util.filesystem.IDirectory;
+import org.apache.aries.util.filesystem.IFile;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * An implementation of IFile that represents a file entry in a zip.
+ */
+public class ZipFileImpl implements IFile
+{
+  /** A logger */
+  private static final Logger logger = LoggerFactory.getLogger(ZipFileImpl.class.getName());
+
+  /** The name of the file */
+  private String name;
+  /** The size of the file */
+  private final long size;
+  /** The last time the file was updated */
+  private final long lastModified;
+  /** The zip file this is contained in */
+  protected final File zip;
+  /** The entry in the zip this IFile represents */
+  protected final ZipEntry entry;
+  /** The parent directory */
+  private final IDirectory parent;
+  /** The URL of the zip file we are looking inside of */
+  private final String url;
+  /** The path of the zip archive to the VFS root */
+  private final String zipPathToRoot;
+  /** The closeable directory that caches the open ZipFile */
+  protected final ZipCloseableDirectory cache;
+  
+  /**
+   * This constructor is used to create a file entry within the zip.
+   * 
+   * @param zip1    the zip file the entry is in.
+   * @param entry1  the entry this IFile represents.
+   * @param parent1 the parent directory.
+   */
+  public ZipFileImpl(File zip1, ZipEntry entry1, ZipDirectory parent1, ZipCloseableDirectory cache)
+  {
+    this.zip = zip1;
+    this.entry = entry1;
+    
+    this.zipPathToRoot = parent1.getZipPathToRoot();
+
+    name = zipPathToRoot + entry1.getName();
+    
+    if (entry1.isDirectory()) name = name.substring(0, name.length() - 1);
+    
+    lastModified = entry1.getTime();
+    size = entry1.getSize();
+    
+    url = ((ZipFileImpl)parent1).url;
+    
+    this.parent = parent1;
+    this.cache = cache;
+  }
+  
+  /**
+   * This is called to construct the root directory of the zip.
+   * 
+   * @param zip1 the zip file this represents.
+   * @param fs   the file on the fs.
+   * @param rootName the name of this zipfile relative to the IFile filesystem root
+   * @throws MalformedURLException
+   */
+  protected ZipFileImpl(File zip1, IDirectory parent) throws MalformedURLException
+  {
+    this.zip = zip1;
+    this.entry = null;
+    
+    if (parent == null) {
+        name = "";
+        zipPathToRoot = "";
+        this.parent = null;
+    } else {
+    	this.parent = parent;
+    	name = parent.getName() + "/" + zip1.getName();
+    	zipPathToRoot = name+"/";
+    }
+    
+    lastModified = zip1.lastModified();
+    size = zip1.length();
+    url = zip1.toURI().toURL().toExternalForm();
+    this.cache = null;
+  }
+  
+  public ZipFileImpl(ZipFileImpl other, ZipCloseableDirectory cache) {
+	  name = other.name;
+	  size = other.size;
+	  lastModified = other.lastModified;
+	  zip = other.zip;
+	  entry = other.entry;
+	  parent = other.parent;
+	  url = other.url;
+	  zipPathToRoot = other.zipPathToRoot;
+	  this.cache = cache;
+  }
+
+  /**
+   * Obtain the path of the zip file to the VFS root
+   */
+  public String getZipPathToRoot() {
+	  return zipPathToRoot;
+  }
+  
+  public IDirectory convert()
+  {
+    return null;
+  }
+  
+  public IDirectory convertNested() {
+	  if (isDirectory()) return convert();
+	  else if (FileSystemImpl.isValidZip(this)) return new NestedZipDirectory(this); 
+	  else return null;
+  }	
+
+  public long getLastModified()
+  {
+    return lastModified;
+  }
+
+  public String getName()
+  {
+    return name;
+  }
+  
+  public String getNameInZip() 
+  {
+	  if (entry == null) return "";
+	  else {
+		  String name = entry.getName();
+		  if (isDirectory()) return name.substring(0, name.length()-1);
+		  else return name;
+	  }
+  }
+
+  public IDirectory getParent()
+  {
+    return parent;
+  }
+
+  public long getSize()
+  {
+    return size;
+  }
+
+  public boolean isDirectory()
+  {
+    return false;
+  }
+
+  public boolean isFile()
+  {
+    return true;
+  }
+
+  public InputStream open() throws IOException
+  {
+    InputStream is = new SpecialZipInputStream(entry);
+    return is;
+  }
+  
+  public IDirectory getRoot()
+  {
+    return parent.getRoot();
+  }
+
+  public URL toURL() throws MalformedURLException
+  {
+    URL result;
+    
+    if(name.equals(zipPathToRoot))
+      result = new URL(url);
+    else {
+      
+      String entryURL = "jar:" + url + "!/";
+      if(entry != null)
+        entryURL += entry.getName();
+      else {
+        entryURL += name.substring(zipPathToRoot.length());
+      }
+      result = new URL(entryURL);
+    }
+      
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj)
+  {
+    if (obj == null) return false;
+    if (obj == this) return true;
+    
+    if (obj.getClass() == getClass()) {
+      return toString().equals(obj.toString());
+    }
+    
+    return false;
+  }
+
+  @Override
+  public int hashCode()
+  {
+    return toString().hashCode();
+  }
+
+  @Override
+  public String toString()
+  {
+	  if (name != null && name.length() != 0) return url.substring(5)+ "/" + name;
+	  else return url.substring(5);
+  }
+  
+  ZipFile openZipFile(){
+    ZipFile z = null;
+
+    if (cache != null && !!!cache.isClosed()) {
+    	z = cache.getZipFile();
+    } else {
+	    try {
+	      z = new ZipFile(zip);
+	    } catch (ZipException e) {
+	      logger.error ("ZipException in ZipFileImpl.openZipFile", e);
+	    } catch (IOException e) {
+	      logger.error ("IOException in ZipFileImpl.openZipFile", e);
+	    }
+    }
+    return z;
+  }
+  
+  void closeZipFile(ZipFile z){
+	  if (cache != null && cache.getZipFile() == z) {
+		  // do nothing
+	  } else {
+		  try{
+			  z.close();
+		  }
+		  catch (IOException e) {
+			  logger.error ("IOException in ZipFileImpl.closeZipFile", e);
+		  }
+	  }
+  }
+  
+  /**
+   * A simple class to delegate to the InputStream of the constructor
+   * and to call close on the zipFile when we close the stream.
+   *
+   */
+  private class SpecialZipInputStream extends InputStream{
+
+    private ZipFile zipFile;
+    private InputStream is;
+    
+    public SpecialZipInputStream(ZipEntry anEntry){
+      try{
+      this.zipFile = openZipFile();
+      this.is = zipFile.getInputStream(anEntry);
+      }
+      catch (ZipException e) {
+        logger.error ("ZipException in SpecialZipInputStream()", e);
+      } catch (IOException e) {
+        logger.error ("IOException in SpecialZipInputStream()", e);        
+      }
+    }
+    
+    @Override
+    public int read() throws IOException
+    {
+      return is.read();
+    }
+    
+    @Override
+    public void close() throws IOException{
+        //call close on the input stream, probably does nothing
+        is.close();
+        //call close on the zip file, important for tidying up
+        closeZipFile(zipFile);
+    }
+    
+  }
+
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/BundleToClassLoaderAdapter.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/BundleToClassLoaderAdapter.java
index e69de29b..77d1ce0e 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/BundleToClassLoaderAdapter.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/BundleToClassLoaderAdapter.java
@@ -0,0 +1,140 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.internal;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Enumeration;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleReference;
+
+public class BundleToClassLoaderAdapter extends ClassLoader implements BundleReference
+{
+  private final Bundle b;
+
+  public BundleToClassLoaderAdapter(Bundle bundle)
+  {
+    b = bundle;
+  }
+
+  @Override
+  public URL getResource(final String name)
+  {
+    return AccessController.doPrivileged(new PrivilegedAction<URL>() {
+	public URL run()
+      {
+        return b.getResource(name);
+      }
+    });
+  }
+
+  @Override
+  public InputStream getResourceAsStream(String name)
+  {
+    URL url = getResource(name);
+
+    InputStream result = null;
+
+    if (url != null) {
+      try {
+        result = url.openStream();
+      } catch (IOException e) {
+      }
+    }
+
+    return result;
+  }
+
+  @Override
+  public Enumeration<URL> getResources(final String name) throws IOException
+  {
+    Enumeration<URL> urls;
+    try {
+      urls = AccessController.doPrivileged(new PrivilegedExceptionAction<Enumeration<URL>>() {
+		@SuppressWarnings("unchecked")
+        public Enumeration<URL> run() throws IOException
+        {
+          return b.getResources(name);
+        }
+      });
+    } catch (PrivilegedActionException e) {
+      Exception cause = e.getException();
+
+      if (cause instanceof IOException) throw (IOException)cause;
+      if (cause instanceof RuntimeException) throw (RuntimeException)cause;
+
+      IOException ioe = new IOException(name);
+      ioe.initCause(cause);
+      throw ioe;
+    }
+
+    if (urls == null) {
+      urls = Collections.enumeration(new ArrayList<URL>());
+    }
+
+    return urls;
+  }
+
+  /*
+   * Notes we overwrite loadClass rather than findClass because we don't want to delegate
+   * to the default classloader, only the bundle.
+   * 
+   * Also note that ClassLoader#loadClass(String) by javadoc on ClassLoader delegates
+   * to this method, so we don't need to overwrite it separately.
+   * 
+   * (non-Javadoc)
+   * @see java.lang.ClassLoader#loadClass(java.lang.String, boolean)
+   */  
+  @Override
+  public Class<?> loadClass(final String name, boolean resolve) throws ClassNotFoundException
+  {
+    try {
+      Class<?> result = AccessController.doPrivileged(new PrivilegedExceptionAction<Class<?>>() {
+        public Class<?> run() throws ClassNotFoundException
+        {
+          return b.loadClass(name);
+        }
+      });
+      
+      if (resolve) resolveClass(result);
+      
+      return result;
+    } catch (PrivilegedActionException e) {
+      Exception cause = e.getException();
+
+      if (cause instanceof ClassNotFoundException) throw (ClassNotFoundException)cause;
+      if (cause instanceof RuntimeException) throw (RuntimeException)cause;
+
+      throw new ClassNotFoundException(name, cause);
+    }
+  }
+
+  public Bundle getBundle()
+  {
+    return b;
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/DefaultWorker.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/DefaultWorker.java
index e69de29b..31ce6e0e 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/DefaultWorker.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/DefaultWorker.java
@@ -0,0 +1,175 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.internal;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.util.IdentityHashMap;
+import java.util.Map;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.BundleEvent;
+import org.osgi.framework.BundleListener;
+import org.osgi.framework.Constants;
+import org.osgi.framework.FrameworkEvent;
+import org.osgi.framework.FrameworkListener;
+import org.osgi.framework.FrameworkUtil;
+
+public class DefaultWorker implements FrameworkUtilWorker, BundleListener, FrameworkListener
+{
+  private Map<Bundle, ClassLoader> classLoaders = new IdentityHashMap<Bundle, ClassLoader>();
+  private static final Bundle myFrameworkBundle;
+
+  static
+  {
+    Bundle bundle = FrameworkUtil.getBundle(DefaultWorker.class);
+    BundleContext myContext = bundle == null? null: bundle.getBundleContext();
+    
+    // This may be created during framework shutdown when the bundle context is null.
+    // So we need to cope and not NPE during construction.
+    if (myContext != null) {
+      myFrameworkBundle = myContext.getBundle(0);
+    } else {
+      myFrameworkBundle = null;
+    }
+  }
+  
+  
+  public ClassLoader getClassLoader(final Bundle b) 
+  {
+    ClassLoader cl = get(b);
+    
+    if (cl != null) return cl;
+
+    // so first off try to get the real classloader. We can do this by loading a known class
+    // such as the bundle activator. There is no guarantee this will work, so we have a back door too.
+    String activator = (String) b.getHeaders().get(Constants.BUNDLE_ACTIVATOR);
+    if (activator != null) {
+      try {
+        Class<?> clazz = b.loadClass(activator);
+        // so we have the class, but it could have been imported, so we make sure the two bundles
+        // are the same. A reference check should work here because there will be one.
+        Bundle activatorBundle = FrameworkUtil.getBundle(clazz);
+        if (activatorBundle == b) {
+          cl = clazz.getClassLoader();
+        }
+      } catch (ClassNotFoundException e) {
+      }
+    }
+    
+    if (cl == null) {
+      // ok so we haven't found a class loader yet, so we need to create a wapper class loader
+      cl = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
+        public ClassLoader run() {
+          return new BundleToClassLoaderAdapter(b);
+        }
+      });
+    }
+    
+    if (cl != null) {
+      setupListener(b);
+      cl = put(b, cl);
+    }
+    
+    return cl;
+  }
+
+  private void setupListener(Bundle b) 
+  {
+    // So we need to cope with multiple equinox frameworks, so we can't just listen to our
+    // BundleContext. Instead we add a listener to Bundle 0 of the framework bundle associated
+    // with the bundle passed in.
+    BundleContext ctx = b.getBundleContext().getBundle(0).getBundleContext();
+    ctx.addBundleListener(this);
+    ctx.addFrameworkListener(this);
+  }
+
+  private synchronized ClassLoader put(Bundle b, ClassLoader cl) 
+  {
+    // If the bundle is uninstalled or installed then there is no classloader so we should
+    // just return null. This is a last second sanity check to avoid memory leaks that could
+    // occur if a bundle is uninstalled or unresolved while someone is calling getClassLoader
+    if (b.getState() == Bundle.UNINSTALLED || b.getState() == Bundle.INSTALLED) return null;
+    
+    ClassLoader previous = classLoaders.put(b, cl);
+    // OK, so we could cause a replace to occur here, so we want to check to
+    // see if previous is not null. If it is not null we need to do a replace
+    // and return the previous classloader. This ensures we have one classloader
+    // in use for a bundle.
+    if (previous != null) {
+      cl = previous;
+      classLoaders.put(b, cl);
+    }
+    
+    return cl;
+  }
+
+  private synchronized ClassLoader get(Bundle b) 
+  {
+    return classLoaders.get(b);
+  }
+
+  private synchronized void remove(Bundle bundle) 
+  {
+    classLoaders.remove(bundle);
+  }
+
+  public boolean isValid()
+  {
+    return true;
+  }
+
+  public void bundleChanged(BundleEvent event) 
+  {
+    if (event.getType() == BundleEvent.UNINSTALLED || event.getType() == BundleEvent.UNRESOLVED) {
+      Bundle b = event.getBundle();
+      
+      remove(b);
+      
+      if (b.getBundleId() == 0) {
+        clearBundles(b);
+      }
+    }
+  }
+
+  private void clearBundles(Bundle b) {
+    // we have been told about the system bundle, so we need to clear up any state for this framework.
+    BundleContext ctx = b.getBundleContext();
+    ctx.removeBundleListener(this);
+    Bundle[] bundles = ctx.getBundles();
+    for (Bundle bundle : bundles) {
+      remove(bundle);
+    }
+  }
+
+  public void frameworkEvent(FrameworkEvent event) 
+  {
+    if (event.getType() == FrameworkEvent.STOPPED) {
+      Bundle b = event.getBundle();
+      if (b == myFrameworkBundle) {
+        classLoaders.clear();
+      } else if (b != null) {
+        clearBundles(b);
+      }
+      
+      b.getBundleContext().removeFrameworkListener(this);
+    }
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/EquinoxWorker.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/EquinoxWorker.java
index e69de29b..13597a67 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/EquinoxWorker.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/EquinoxWorker.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.internal;
+
+import java.lang.reflect.InvocationTargetException;
+
+import org.osgi.framework.Bundle;
+
+public class EquinoxWorker extends DefaultWorker implements FrameworkUtilWorker {
+
+  public ClassLoader getClassLoader(Bundle b) 
+  {
+    ClassLoader result = null;
+    try {
+      Object bundleLoaderProxy = invoke(b, "getLoaderProxy");
+      if (bundleLoaderProxy != null) {
+        Object bundleLoader = invoke(bundleLoaderProxy, "getBasicBundleLoader");
+        if (bundleLoader != null) {
+          Object bundleClassLoader = invoke(bundleLoader, "createClassLoader");
+          if (bundleClassLoader instanceof ClassLoader) {
+            result = (ClassLoader)bundleClassLoader;
+          }
+        }
+      }
+    } catch (IllegalArgumentException e) {
+    } catch (SecurityException e) {
+    } catch (IllegalAccessException e) {
+    } catch (InvocationTargetException e) {
+    } catch (NoSuchMethodException e) {
+    }
+    
+    return result;
+  }
+
+  private Object invoke(Object targetObject, String method) throws IllegalAccessException, InvocationTargetException,
+      NoSuchMethodException
+  {
+    return targetObject.getClass().getDeclaredMethod(method).invoke(targetObject);
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/FelixWorker.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/FelixWorker.java
index e69de29b..53a282eb 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/FelixWorker.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/FelixWorker.java
@@ -0,0 +1,71 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.internal;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.FrameworkUtil;
+
+public final class FelixWorker extends DefaultWorker implements FrameworkUtilWorker 
+{
+  private static Method getCurrentModuleMethod;
+  private static Method getClassLoader;
+  private static Class<?> moduleClass;
+
+  static {
+    Bundle b = FrameworkUtil.getBundle(FelixWorker.class);
+    try {
+      getCurrentModuleMethod = b.getClass().getDeclaredMethod("getCurrentModule");
+      moduleClass = b.getClass().getClassLoader().loadClass("org.apache.felix.framework.ModuleImpl");
+      getClassLoader = moduleClass.getDeclaredMethod("getClassLoader");
+      
+      getCurrentModuleMethod.setAccessible(true);
+      getClassLoader.setAccessible(true);
+    } catch (SecurityException e) {
+    } catch (NoSuchMethodException e) {
+    } catch (IllegalArgumentException e) {
+    } catch (ClassNotFoundException e) {
+    }
+  }
+  
+  public ClassLoader getClassLoader(Bundle b) 
+  {
+    if (getCurrentModuleMethod != null) {
+      try {
+        Object result = getCurrentModuleMethod.invoke(b);
+        if (result != null && moduleClass.isInstance(result)) {
+          Object cl = getClassLoader.invoke(result);
+          
+          if (cl instanceof ClassLoader) return (ClassLoader) cl;
+        }
+      } catch (IllegalArgumentException e) {
+      } catch (IllegalAccessException e) {
+      } catch (InvocationTargetException e) {
+      }
+    }
+    return null;
+  }
+
+  public boolean isValid()
+  {
+    return getCurrentModuleMethod != null && moduleClass != null && getClassLoader != null;
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/FrameworkUtilWorker.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/FrameworkUtilWorker.java
index e934ea14..3b935d8d 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/FrameworkUtilWorker.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/FrameworkUtilWorker.java
@@ -1,3 +1,32 @@
   + native
   + text/plain
   + Date Revision
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.internal;
+
+import org.osgi.framework.Bundle;
+
+public interface FrameworkUtilWorker {
+
+  ClassLoader getClassLoader(Bundle b);
+
+  boolean isValid();
+
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/MessageUtil.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/MessageUtil.java
index e69de29b..aca6f978 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/MessageUtil.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/internal/MessageUtil.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.internal;
+
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+
+public class MessageUtil {
+    /** The resource bundle for blueprint messages */
+    private final static ResourceBundle messages = 
+        ResourceBundle.getBundle("org.apache.aries.util.messages.UTILmessages");
+
+    /**
+     * Resolve a message from the bundle, including any necessary formatting.
+     * 
+     * @param key
+     *            the message key.
+     * @param inserts
+     *            any required message inserts.
+     * @return the message translated into the server local.
+     */
+    public static final String getMessage(String key, Object... inserts) {
+        String msg = messages.getString(key);
+
+        if (inserts.length > 0)
+            msg = MessageFormat.format(msg, inserts);
+
+        return msg;
+    }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/io/IOUtils.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/io/IOUtils.java
index e69de29b..a926ea3f 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/io/IOUtils.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/io/IOUtils.java
@@ -0,0 +1,294 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.io;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.jar.JarOutputStream;
+import java.util.jar.Manifest;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipException;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipInputStream;
+import java.util.zip.ZipOutputStream;
+
+import org.apache.aries.util.filesystem.IFile;
+import org.apache.aries.util.internal.MessageUtil;
+
+public class IOUtils
+{
+  /**
+   * Copy an InputStream to an OutputStream and close the InputStream afterwards.
+   */
+  public static void copy(InputStream in, OutputStream out) throws IOException
+  {
+    try {
+      copyAndDoNotCloseInputStream(in, out);
+    }
+    finally {
+      close(in);
+    }
+  }
+  
+  /**
+   * Copy an InputStream to an OutputStream and do not close the InputStream afterwards.
+   */
+  public static void copyAndDoNotCloseInputStream(InputStream in, OutputStream out) throws IOException
+  {
+    int len;
+    byte[] b = new byte[1024];
+    while ((len = in.read(b)) != -1)
+      out.write(b,0,len);
+  }
+  
+  /**
+   * Close some xStream for good :)
+   */
+  public static void close(Closeable c)
+  {
+    try {
+      if (c != null)
+        c.close();
+    }
+    catch (IOException e) {
+      c = null;
+    }
+  }
+  
+  /**
+   * A special version of close() for ZipFiles, which don't implement Closeable.
+   * @param file the file to close. ZipFiles seem prone to file locking problems
+   * on Windows, so to aid diagnostics we throw, not swallow, any exceptions. 
+   */
+  public static void close(ZipFile file) throws IOException
+  {
+    if (file != null) file.close();
+  }
+  
+  public static OutputStream getOutputStream(File outputDir, String relativePath) throws IOException
+  {
+    int lastSeparatorIndex = relativePath.replace(File.separatorChar,'/').lastIndexOf("/");
+    String dirName = null;
+    String fileName = null;
+    
+    File outputDirectory;
+    if (lastSeparatorIndex != -1)
+    {
+      dirName = relativePath.substring(0, lastSeparatorIndex);
+      fileName = relativePath.substring(lastSeparatorIndex + 1);
+
+      outputDirectory = new File(outputDir, dirName);
+      
+      if (!!!outputDirectory.exists() && !!!outputDirectory.mkdirs())
+        throw new IOException(MessageUtil.getMessage("UTIL0015E", relativePath));
+    }
+    else
+    {
+      outputDirectory = outputDir;
+      fileName = relativePath;
+    }
+    
+    File outputFile = new File(outputDirectory, fileName);
+    return new FileOutputStream(outputFile);
+  }
+  
+  /**
+   * Write the given InputStream to a file given by a root directory (outputDir) and a relative directory.
+   * Necessary subdirectories will be created. This method will close the supplied InputStream.
+   */
+  public static void writeOut(File outputDir, String relativePath, InputStream content) throws IOException
+  {
+    OutputStream out = null;
+    try {
+      out = getOutputStream(outputDir, relativePath);
+      IOUtils.copy(content, out);
+    }
+    finally {
+      close(out);
+    }
+  }
+  
+  /**
+   * Write the given InputStream to a file given by a root directory (outputDir) and a relative directory.
+   * Necessary subdirectories will be created. This method will not close the supplied InputStream.
+   */
+  public static void writeOutAndDontCloseInputStream(File outputDir, String relativePath, InputStream content) throws IOException
+  {
+    OutputStream out = null;
+    try {
+      out = getOutputStream(outputDir, relativePath);
+      IOUtils.copyAndDoNotCloseInputStream(content, out);
+    }
+    finally {
+      close(out);
+    }
+  }
+  
+   /** 
+   * Zip up all contents of rootDir (recursively) into targetStream
+   */
+  @SuppressWarnings("unchecked")
+  public static void zipUp (File rootDir, OutputStream targetStream) throws IOException
+  {
+    ZipOutputStream out = null;
+    try { 
+      out = new ZipOutputStream (targetStream);
+      zipUpRecursive(out, "", rootDir, (Set<String>) Collections.EMPTY_SET);
+    } finally { 
+      close(out);
+    }
+  }
+  
+  /**
+   * Zip up all contents of rootDir (recursively) into targetFile
+   */
+  @SuppressWarnings("unchecked")
+  public static void zipUp(File rootDir, File targetFile) throws IOException
+  {
+    ZipOutputStream out = null; 
+    try {
+      out = new ZipOutputStream(new FileOutputStream(targetFile));
+      zipUpRecursive(out, "", rootDir, (Set<String>) Collections.EMPTY_SET);
+    }
+    finally {
+      close(out);
+    }
+  }
+  
+  /**
+   * Jar up all the contents of rootDir (recursively) into targetFile and add the manifest
+   */
+  public static void jarUp(File rootDir, File targetFile, Manifest manifest) throws IOException
+  {
+    JarOutputStream out = null;
+    try {
+      out = new JarOutputStream(new FileOutputStream(targetFile), manifest);
+      zipUpRecursive(out, "", rootDir, new HashSet<String>(Arrays.asList("META-INF/MANIFEST.MF")));
+    }
+    finally {
+      close(out);
+    }
+  }
+  
+  /**
+   * Helper method used by zipUp
+   */
+  private static void zipUpRecursive(ZipOutputStream out, String prefix, 
+      File directory, Set<String> filesToExclude) throws IOException
+  {
+    File[] files = directory.listFiles();
+    if (files != null) 
+    {
+      for (File f : files)
+      {        
+        String fileName; 
+        if (f.isDirectory())
+          fileName = prefix + f.getName() + "/";
+        else
+          fileName = prefix + f.getName();
+        
+        if (filesToExclude.contains(fileName))
+          continue;
+        
+        ZipEntry ze = new ZipEntry(fileName);
+        ze.setSize(f.length());
+        ze.setTime(f.lastModified());
+        out.putNextEntry(ze);
+
+        if (f.isDirectory()) 
+          zipUpRecursive(out, fileName, f, filesToExclude);
+        else 
+        {
+          IOUtils.copy(new FileInputStream(f), out);
+        }
+      }
+    }
+  }
+  
+  /**
+   * Do rm -rf
+   */
+  public static boolean deleteRecursive(File root)
+  {
+    if (!!!root.exists())
+      return false;
+    else if (root.isFile())
+      return root.delete();
+    else {
+      boolean result = true;
+      for (File f : root.listFiles())
+      {
+        result = deleteRecursive(f) && result;
+      }
+      return root.delete() && result;
+    }
+  }
+  
+  /**
+   * Unpack the zip file into the outputDir
+   * @param zip
+   * @param outputDir
+   * @return true if the zip was expanded, false if the zip was found not to be a zip
+   * @throws IOException when there are unexpected issues handling the zip files.
+   */
+  public static boolean unpackZip(IFile zip, File outputDir) throws IOException{
+    boolean success=true;
+    //unpack from fileOnDisk into bundleDir.
+    ZipInputStream zis = null;
+    try{
+      boolean isZip = false;
+      ZipEntry zipEntry = null;
+      try {
+        zis = new ZipInputStream (zip.open());
+        zipEntry = zis.getNextEntry();
+        isZip = zipEntry != null; 
+      } catch (ZipException e) { // It's not a zip - that's ok, we'll return that below. 
+        isZip = false;
+      } catch (UnsupportedOperationException e) {  // This isn't declared, but is thrown in practice
+        isZip = false;                             // It's not a zip - that's ok, we'll return that below. 
+      }
+      if(isZip){
+        do { 
+          if (!zipEntry.isDirectory()) { 
+            writeOutAndDontCloseInputStream(outputDir, zipEntry.getName(), zis);
+          }
+          zis.closeEntry();
+          zipEntry = zis.getNextEntry();
+        } while (zipEntry != null);
+      }else{
+        success=false;
+      }
+    }finally{
+      IOUtils.close(zis);
+    }
+    return success;
+  }
+  
+
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/io/RememberingInputStream.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/io/RememberingInputStream.java
index ada1bb9a..df9ddd3e 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/io/RememberingInputStream.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/io/RememberingInputStream.java
@@ -1,3 +1,179 @@
   + text/plain
   + Date Revision
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.io;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import org.apache.aries.util.internal.MessageUtil;
+
+/**
+ * This class can be used to buffer an arbitrary amount of content from an input stream and be able to reset to 
+ * the start.
+ */
+public class RememberingInputStream extends InputStream {
+
+  /** The size by which to grow our array */
+  private static final int bufferGrowthSize = 0x4000;
+  /** The bytes that have been read so far */
+  private byte[] bytes = new byte[bufferGrowthSize];
+  /** Index of the next empty entry in the array */
+  private int pos = 0;
+  /** The input stream that actually holds the data */
+  private final InputStream stream;
+  /** Index of the last valid byte in the byte array */
+  private int maxRead = -1;
+  /** The point to reset to */
+  private int markPoint = -1;
+  
+  
+  public RememberingInputStream(InputStream in) throws IOException{
+    stream = in;
+    // Pre fill with data that we know we're going to need - it's 
+    // more efficient than the single byte reads are - hopefully
+    // someone reading a lot of data will do reads in bulk
+    
+    maxRead = stream.read(bytes) - 1;
+  }
+
+  @Override
+  public int read() throws IOException {
+    
+    if(pos <= maxRead)
+    {
+      //We can't return the byte directly, because it is signed
+      //We can pretend this is an unsigned byte by using boolean
+      //& to set the low end byte of an int.
+      return bytes[pos++] & 0xFF;
+    } else {
+      int i = stream.read();
+      if(i<0)
+        return i;
+    
+      ensureCapacity(0);
+      bytes[pos++] = (byte) i;
+      return i;
+    }
+  }
+
+  /**
+   * Ensure our internal byte array can hold enough data
+   * @param i one less than the number of bytes that need
+   *          to be held.
+   */
+  private void ensureCapacity(int i) {
+    if((pos + i) >= bytes.length) {
+      byte[] tmp = bytes;
+      int newLength = bytes.length + bufferGrowthSize;
+      while(newLength < pos + i) {
+        newLength += bufferGrowthSize;
+      }
+      bytes = new byte[newLength];
+      System.arraycopy(tmp, 0, bytes, 0, (maxRead >= pos) ? maxRead + 1 : pos);
+    }
+  }
+
+  @Override
+  public int read(byte[] b) throws IOException {
+    return read(b, 0, b.length);
+  }
+
+  @Override
+  public int read(byte[] b, int off, int len) throws IOException {
+    if(pos <= maxRead) {
+      if(pos + len <= maxRead)
+      {
+        System.arraycopy(bytes, pos, b, off, len);
+        pos += len;
+        return len;
+      } else {
+        int lengthLeftOfBuffer = (maxRead - pos) + 1;
+        System.arraycopy(bytes, pos, b, off, lengthLeftOfBuffer);
+        int read = stream.read(b, off + lengthLeftOfBuffer, len - lengthLeftOfBuffer);
+        if(read < 0) {
+          pos += lengthLeftOfBuffer;
+          return lengthLeftOfBuffer;
+        }
+        ensureCapacity(lengthLeftOfBuffer + read - 1);
+        System.arraycopy(b, off + lengthLeftOfBuffer, bytes, maxRead + 1, read);
+        pos +=  (lengthLeftOfBuffer + read);
+        return lengthLeftOfBuffer + read;
+      }
+    } else {
+      int i = stream.read(b, off, len);
+      if(i<0)
+        return i;
+      ensureCapacity(i - 1);
+      System.arraycopy(b, off, bytes, pos, i);
+      pos += i;
+      return i;
+    }
+  }
+
+  @Override
+  public long skip(long n) throws IOException {
+    throw new IOException(MessageUtil.getMessage("UTIL0017E"));
+  }
+
+  @Override
+  public int available() throws IOException {
+    if(pos <= maxRead) 
+      return (maxRead - pos) + 1;
+    else 
+      return stream.available(); 
+  }
+
+  @Override
+  public synchronized void mark(int readlimit) {
+    markPoint = pos;
+  }
+
+  @Override
+  public synchronized void reset() throws IOException {
+    if(maxRead < pos)
+      maxRead = pos - 1;
+    pos = markPoint;
+  }
+
+  @Override
+  public boolean markSupported() {
+    return true;
+  }
+
+  /**
+   * Noop. Does not close the passed in archive, which is kept open for further reading.
+   */
+  @Override
+  public void close() throws IOException {
+    //No op, don't close the parent.
+  }
+  
+  /**
+   * Actually closes the underlying InputStream. Call this method instead of close, which is implemented as a no-op.
+   * Alternatively call close directly on the parent.
+   * @throws IOException
+   */
+  public void closeUnderlying() throws IOException {
+      stream.close();
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/BundleManifest.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/BundleManifest.java
index ada1bb9a..ec4bad68 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/BundleManifest.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/BundleManifest.java
@@ -1,3 +1,201 @@
   + text/plain
   + Date Revision
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.manifest;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.jar.Attributes;
+import java.util.jar.JarInputStream;
+import java.util.jar.Manifest;
+import java.util.zip.ZipEntry;
+
+import org.apache.aries.util.filesystem.IFile;
+import org.apache.aries.util.internal.MessageUtil;
+import org.apache.aries.util.io.IOUtils;
+import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValueMap;
+import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValuePair;
+import org.osgi.framework.Constants;
+import org.osgi.framework.Version;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Entity class to retrieve and represent a bundle manifest (valid or invalid).
+ */
+public class BundleManifest
+{
+  private static final String MANIFEST_PATH = "META-INF/MANIFEST.MF";
+  private static final Logger _logger = LoggerFactory.getLogger(BundleManifest.class.getName());
+
+  /**
+   * Read a manifest from a jar input stream. This will find the manifest even if it is NOT
+   * the first file in the archive.
+   * 
+   * @param is
+   * @return
+   */
+  public static BundleManifest fromBundle(InputStream is) {
+    JarInputStream jarIs = null;
+    try {
+      jarIs = new JarInputStream(is);
+      Manifest m = jarIs.getManifest();
+      if (m != null)
+        return new BundleManifest(m);
+      else {
+        ZipEntry entry;
+        while ((entry = jarIs.getNextEntry()) != null) {
+          if (entry.getName().equals(MANIFEST_PATH))
+            return new BundleManifest(jarIs);
+        }
+        
+        return null;
+      }
+    }
+    catch (IOException e) {
+      _logger.error ("IOException in BundleManifest()", e);
+      return null;
+    }
+    finally {
+      IOUtils.close(jarIs);
+    }
+  }
+  
+  /**
+   * Retrieve a BundleManifest from the given jar file
+   * 
+   * @param f
+   * @return
+   */
+  public static BundleManifest fromBundle(IFile f) {
+    InputStream is = null;
+    try {
+      if (f.isDirectory()) {
+        IFile manFile = f.convert().getFile(MANIFEST_PATH);
+        if (manFile != null)
+          return new BundleManifest(manFile.open());
+        else
+          return null;
+      } else {
+        is = f.open();
+        return fromBundle(is);
+      }
+    } catch (IOException e) {
+      _logger.error ("IOException in BundleManifest.fromBundle(IFile)", e);
+      return null;
+    }
+    finally {
+      IOUtils.close(is);
+    }
+  }
+  
+  /**
+   * Retrieve a bundle manifest from the given jar file, which can be exploded or compressed
+   * 
+   * @param f
+   * @return
+   */
+  public static BundleManifest fromBundle(File f) {
+    if (f.isDirectory()) {
+      File manifestFile = new File(f, MANIFEST_PATH);
+      if (manifestFile.isFile())
+        try {
+          return new BundleManifest(new FileInputStream(manifestFile));
+        }
+        catch (IOException e) {
+          _logger.error ("IOException in BundleManifest.fromBundle(File)", e);
+          return null;
+        }
+      else
+        return null;
+    }
+    else  if (f.isFile()) {
+      try {
+        return fromBundle(new FileInputStream(f));
+      }
+      catch (IOException e) {
+        _logger.error ("IOException in BundleManifest.fromBundle(File)", e);
+        return null;
+      }
+    }
+    else {
+      throw new IllegalArgumentException(MessageUtil.getMessage("UTIL0016E", f.getAbsolutePath()));
+    }
+  }
+  
+  private Manifest manifest;
+  
+  /**
+   * Create a BundleManifest object from the InputStream to the manifest (not to the bundle)
+   * @param manifestIs
+   * @throws IOException
+   */
+  public BundleManifest(InputStream manifestIs) throws IOException {
+    this(ManifestProcessor.parseManifest(manifestIs));
+  }
+  
+  /**
+   * Create a BundleManifest object from a common Manifest object
+   * @param m
+   */
+  public BundleManifest(Manifest m) {
+    manifest = m;
+  }
+  
+  public String getSymbolicName() {
+    String rawSymName = manifest.getMainAttributes().getValue(Constants.BUNDLE_SYMBOLICNAME);
+
+    String result = null;
+    if (rawSymName != null) {
+      NameValuePair info = ManifestHeaderProcessor.parseBundleSymbolicName(rawSymName);
+      result = info.getName();
+    }
+    
+    return result;
+  }
+  
+  public Version getVersion() {
+    String specifiedVersion = manifest.getMainAttributes().getValue(Constants.BUNDLE_VERSION);
+    Version result = (specifiedVersion == null) ? Version.emptyVersion : new Version(specifiedVersion);
+    
+    return result;
+  }
+  
+  public String getManifestVersion() {
+    return manifest.getMainAttributes().getValue(Constants.BUNDLE_MANIFESTVERSION);
+  }
+  
+  public Attributes getRawAttributes() {
+    return manifest.getMainAttributes();
+  }
+  
+  public Manifest getRawManifest() {
+    return manifest;
+  }
+  
+  public boolean isValid() {
+    return getManifestVersion() != null && getSymbolicName() != null;
+  }
+}
+
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/Constants.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/Constants.java
index e69de29b..5fc7e155 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/Constants.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/Constants.java
@@ -0,0 +1,24 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.manifest;
+
+public class Constants {
+	public static final String MANIFEST_VERSION="1.0";
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/ManifestHeaderProcessor.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/ManifestHeaderProcessor.java
index e69de29b..f00b102f 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/ManifestHeaderProcessor.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/ManifestHeaderProcessor.java
@@ -0,0 +1,671 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.manifest;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.apache.aries.util.ManifestHeaderUtils;
+import org.apache.aries.util.VersionRange;
+import org.osgi.framework.Constants;
+
+
+public class ManifestHeaderProcessor
+{
+  public static final String NESTED_FILTER_ATTRIBUTE = "org.apache.aries.application.filter.attribute";
+  private static final Pattern FILTER_ATTR = Pattern.compile("(\\(!)?\\((.*?)([<>]?=)(.*?)\\)\\)?");
+  private static final String LESS_EQ_OP = "<=";
+  private static final String GREATER_EQ_OP = ">=";
+
+  /**
+   * A simple class to associate two types.
+   *
+   * @param <N> The type for the 'Name'
+   * @param <V> The type for the 'Value'
+   */
+  public static class NameValuePair {
+    private String name;
+    private Map<String,String> attributes;
+    
+    public NameValuePair(String name, Map<String,String> value)
+    {
+      this.name = name;
+      this.attributes = value;
+    }
+    public String getName()
+    {
+      return name;
+    }
+    public void setName(String name)
+    {
+      this.name = name;
+    }
+    
+    public Map<String,String> getAttributes()
+    {
+      return attributes;
+    }
+    public void setAttributes(Map<String,String> value)
+    {
+      this.attributes = value;
+    }
+    
+    @Override
+    public String toString(){
+      return "{"+name.toString()+"::"+attributes.toString()+"}";
+    }
+    @Override
+    public int hashCode()
+    {
+      final int prime = 31;
+      int result = 1;
+      result = prime * result + ((name == null) ? 0 : name.hashCode());
+      result = prime * result + ((attributes == null) ? 0 : attributes.hashCode());
+      return result;
+    }
+    @Override
+    public boolean equals(Object obj)
+    {
+      if (this == obj) return true;
+      if (obj == null) return false;
+      if (getClass() != obj.getClass()) return false;
+      final NameValuePair other = (NameValuePair) obj;
+      if (name == null) {
+        if (other.name != null) return false;
+      } else if (!name.equals(other.name)) return false;
+      if (attributes == null) {
+    	  if (other.attributes != null) return false;
+      } else if (!attributes.equals(other.attributes)) return false;
+      return true;
+    }
+  }
+  
+  /**
+   * Intended to provide a standard way to add Name/Value's to 
+   * aggregations of Name/Value's.
+   *
+   * @param <N> Type of 'Name'
+   * @param <V> Type of 'Value'
+   */
+  public static interface NameValueCollection {
+    /**
+     * Add this Name & Value to the collection.
+     * @param n
+     * @param v
+     */
+    public void addToCollection(String n, Map<String,String> v);
+  }
+
+  /**
+   * Map of Name -> Value.
+   * 
+   * @param <N> Type of 'Name'
+   * @param <V> Type of 'Value'
+   */
+  public static class NameValueMap extends HashMap<String, Map<String,String>> implements NameValueCollection, Map<String, Map<String,String>>{
+	private static final long serialVersionUID = -6446338858542599141L;
+	
+	public void addToCollection(String n, Map<String,String> v){
+      this.put(n,v);
+    }
+	
+	@Override
+	public String toString(){
+      StringBuilder sb = new StringBuilder();
+      sb.append("{");
+      boolean first=true;
+      for(Map.Entry<String, Map<String,String>> entry : this.entrySet()){
+        if(!first)sb.append(",");
+        first=false;
+        sb.append(entry.getKey()+"->"+entry.getValue());
+      }
+      sb.append("}");
+      return sb.toString();
+    }
+  }
+  
+  /**
+   * List of Name/Value
+   *
+   * @param <N> Type of 'Name'
+   * @param <V> Type of 'Value'
+   */
+  public static class NameValueList extends ArrayList<NameValuePair> implements NameValueCollection, List<NameValuePair> {    
+	private static final long serialVersionUID = 1808636823825029983L;
+	
+	public void addToCollection(String n, Map<String,String> v){
+      this.add(new NameValuePair(n,v));
+    } 
+	@Override
+    public String toString(){
+      StringBuffer sb = new StringBuffer();
+      sb.append("{");
+      boolean first = true;
+      for(NameValuePair nvp : this){
+        if(!first)sb.append(",");
+        first=false;
+        sb.append(nvp.toString());        
+      }
+      sb.append("}");
+      return sb.toString();
+    }
+  }
+  
+  /**
+   * 
+   * Splits a delimiter separated string, tolerating presence of non separator commas
+   * within double quoted segments.
+   * 
+   * Eg.
+   * com.ibm.ws.eba.helloWorldService;version="[1.0.0, 1.0.0]" &
+   * com.ibm.ws.eba.helloWorldService;version="1.0.0"
+   * com.ibm.ws.eba.helloWorld;version="2";bundle-version="[2,30)"
+   * com.acme.foo;weirdAttr="one;two;three";weirdDir:="1;2;3"
+   *  @param value          the value to be split
+   *  @param delimiter      the delimiter string such as ',' etc.
+   *  @return List<String>  the components of the split String in a list
+   */
+  public static List<String> split(String value, String delimiter)
+  {
+    return ManifestHeaderUtils.split(value, delimiter);
+  }  
+  
+ 
+  /**
+   * Internal method to parse headers with the format<p>
+   *   [Name](;[Name])*(;[attribute-name]=[attribute-value])*<br> 
+   * Eg.<br>
+   *   rumplestiltskin;thing=value;other=something<br>
+   *   littleredridinghood
+   *   bundle1;bundle2;other=things
+   *   bundle1;bundle2
+   *   
+   * @param s data to parse
+   * @return a list of NameValuePair, with the Name being the name component, 
+   *         and the Value being a NameValueMap of key->value mappings.   
+   */
+  private static List<NameValuePair> genericNameWithNameValuePairProcess(String s){    
+    String name;
+    Map<String,String> params = null;
+    List<NameValuePair> nameValues = new ArrayList<NameValuePair>();
+    List<String> pkgs = new ArrayList<String>();
+    int index = s.indexOf(";");
+    if(index==-1){
+      name = s;
+      params = new HashMap<String, String>();
+      pkgs.add(name);
+    }else{       
+      name = s.substring(0,index).trim();
+      String tail = s.substring(index+1).trim();
+      
+      pkgs.add(name); // add the first package
+      StringBuilder parameters = new StringBuilder();
+          
+      
+      // take into consideration of multiple packages separated by ';'
+      // while they share the same attributes or directives
+      List<String> tailParts = split(tail, ";");
+      boolean firstParameter =false;
+      
+      for (String part : tailParts) {
+        // if it is not a parameter and no parameter appears in front of it, it must a package
+        if (!!!(part.contains("=")))  {
+          // Need to make sure no parameter appears before the package, otherwise ignore this string
+          // as this syntax is invalid
+          if (!!!(firstParameter))
+            pkgs.add(part);
+        } else {
+          if (!!!(firstParameter)) 
+            firstParameter = true;
+
+          parameters.append(part + ";");
+        }
+      }          
+      
+      if (parameters.length() != 0) {
+        //remove the final ';' if there is one
+        if (parameters.toString().endsWith(";")) {
+         
+          parameters = parameters.deleteCharAt(parameters.length() -1);
+        }       
+        
+        params = genericNameValueProcess(parameters.toString());
+      }
+      
+    }
+    for (String pkg : pkgs) {
+      nameValues.add(new NameValuePair(pkg,params));
+    }  
+    
+    return nameValues;
+   
+  }
+
+  /**
+   * Internal method to parse headers with the format<p>
+   *   [attribute-name]=[attribute-value](;[attribute-name]=[attribute-value])*<br>
+   * Eg.<br>
+   *   thing=value;other=something<br>
+   * <p>
+   * Note. Directives (name:=value) are represented in the map with name suffixed by ':'
+   *   
+   * @param s data to parse
+   * @return a NameValueMap, with attribute-name -> attribute-value.
+   */
+  private static Map<String,String> genericNameValueProcess(String s){
+    Map<String,String> params = new HashMap<String,String>();  
+    List<String> parameters = split(s, ";");
+    for(String parameter : parameters) {
+      List<String> parts = split(parameter,"=");
+      // do a check, otherwise we might get NPE   
+      if (parts.size() ==2) {
+        String second = parts.get(1).trim();
+        if (second.startsWith("\"") && second.endsWith("\""))
+          second = second.substring(1,second.length()-1);
+        
+        String first = parts.get(0).trim();
+        
+        // make sure for directives we clear out any space as in "directive  :=value"        
+        if (first.endsWith(":")) {
+            first = first.substring(0, first.length()-1).trim()+":";
+        }
+        
+        params.put(first, second);
+      }
+    }
+
+    return params;
+  }
+  
+  /**
+   * Processes an import/export style header.. <p> 
+   *  pkg1;attrib=value;attrib=value,pkg2;attrib=value,pkg3;attrib=value
+   * 
+   * @param out The collection to add each package name + attrib map to.
+   * @param s The data to parse
+   */
+  private static void genericImportExportProcess(NameValueCollection out, String s){
+    List<String> packages = split(s, ",");
+    for(String pkg : packages){   
+      List<NameValuePair> ps = genericNameWithNameValuePairProcess(pkg);
+      for (NameValuePair p : ps) {
+        out.addToCollection(p.getName(), p.getAttributes());
+      }
+    }    
+  }
+  
+  /**
+   * Parse an export style header.<p>
+   *   pkg1;attrib=value;attrib=value,pkg2;attrib=value,pkg3;attrib=value2
+   * <p>
+   * Result is returned as a list, as export does allow duplicate package exports.
+   * 
+   * @param list The data to parse.
+   * @return List of NameValuePairs, where each Name in the list is an exported package, 
+   *         with its associated Value being a NameValueMap of any attributes declared. 
+   */
+  public static List<NameValuePair> parseExportString(String s){
+    NameValueList retval = new NameValueList();
+    genericImportExportProcess(retval, s);
+    return retval;
+  }
+  
+  /**
+   * Parse an export style header in a list.<p>
+   *   pkg1;attrib=value;attrib=value
+   *   pkg2;attrib=value
+   *   pkg3;attrib=value2
+   * <p>
+   * Result is returned as a list, as export does allow duplicate package exports.
+   * 
+   * @param list The data to parse.
+   * @return List of NameValuePairs, where each Name in the list is an exported package, 
+   *         with its associated Value being a NameValueMap of any attributes declared. 
+   */
+  public static List<NameValuePair> parseExportList(List<String> list){
+    NameValueList retval = new NameValueList();
+    for(String pkg : list){   
+      List<NameValuePair> ps = genericNameWithNameValuePairProcess(pkg);
+      for (NameValuePair p : ps) {
+        retval.addToCollection(p.getName(), p.getAttributes());
+      }
+    } 
+    return retval;
+  }
+  
+  /**
+   * Parse an import style header.<p>
+   *   pkg1;attrib=value;attrib=value,pkg2;attrib=value,pkg3;attrib=value
+   * <p>
+   * Result is returned as a set, as import does not allow duplicate package imports.
+   * 
+   * @param s The data to parse.
+   * @return Map of NameValuePairs, where each Key in the Map is an imported package, 
+   *         with its associated Value being a NameValueMap of any attributes declared. 
+   */  
+  public static Map<String, Map<String, String>> parseImportString(String s){
+    NameValueMap retval = new NameValueMap();
+    genericImportExportProcess(retval, s);
+    return retval;    
+  }
+  
+  /**
+   * Parse a bundle symbolic name.<p>
+   *   bundlesymbolicname;attrib=value;attrib=value
+   * <p>
+   * 
+   * @param s The data to parse.
+   * @return NameValuePair with Name being the BundleSymbolicName, 
+   *         and Value being any attribs declared for the name. 
+   */   
+  public static NameValuePair parseBundleSymbolicName(String s){
+    return genericNameWithNameValuePairProcess(s).get(0); // should just return the first one
+  }
+  
+  /**
+   * Parse a version range.. 
+   * 
+   * @param s
+   * @return VersionRange object.
+   * @throws IllegalArgumentException if the String could not be parsed as a VersionRange
+   */
+  public static VersionRange parseVersionRange(String s) throws IllegalArgumentException{
+    return new VersionRange(s);
+  }
+  
+  /**
+   * Parse a version range and indicate if the version is an exact version 
+   * 
+   * @param s
+   * @param exactVersion
+   * @return VersionRange object.
+   * @throws IllegalArgumentException if the String could not be parsed as a VersionRange
+   */
+  public static VersionRange parseVersionRange(String s, boolean exactVersion) throws IllegalArgumentException{
+    return new VersionRange(s, exactVersion);
+  }
+
+  /**
+	 * Generate a filter from a set of attributes. This filter will be suitable
+	 * for presentation to OBR This means that, due to the way OBR works, it
+	 * will include a stanza of the form, (mandatory:<*mandatoryAttribute)
+	 * Filter strings generated by this method will therefore tend to break the
+	 * standard OSGi Filter class. The OBR stanza can be stripped out later if
+	 * required.
+	 * 
+	 * @param attribs
+	 * @return filter string
+	 */
+	public static String generateFilter(Map<String, String> attribs) {
+		StringBuilder filter = new StringBuilder("(&");
+		boolean realAttrib = false;
+		StringBuffer realAttribs = new StringBuffer();
+
+		if (attribs == null) {
+			attribs = new HashMap<String, String>();
+		}
+
+		for (Map.Entry<String, String> attrib : attribs.entrySet()) {
+			String attribName = attrib.getKey();
+
+			if (attribName.endsWith(":")) {
+				// skip all directives. It is used to affect the attribs on the
+				// filter xml.
+			} else if ((Constants.VERSION_ATTRIBUTE.equals(attribName))
+					|| (Constants.BUNDLE_VERSION_ATTRIBUTE.equals(attribName))) {
+				// version and bundle-version attrib requires special
+				// conversion.
+				realAttrib = true;
+
+				VersionRange vr = ManifestHeaderProcessor
+						.parseVersionRange(attrib.getValue());
+
+				filter.append("(" + attribName + ">=" + vr.getMinimumVersion());
+
+				if (vr.getMaximumVersion() != null) {
+					filter.append(")(" + attribName + "<=");
+					filter.append(vr.getMaximumVersion());
+				}
+
+				if (vr.getMaximumVersion() != null && vr.isMinimumExclusive()) {
+					filter.append(")(!(" + attribName + "=");
+					filter.append(vr.getMinimumVersion());
+					filter.append(")");
+				}
+
+				if (vr.getMaximumVersion() != null && vr.isMaximumExclusive()) {
+					filter.append(")(!(" + attribName + "=");
+					filter.append(vr.getMaximumVersion());
+					filter.append(")");
+				}
+				filter.append(")");
+
+			} else if (NESTED_FILTER_ATTRIBUTE.equals(attribName)) {
+				// Filters go in whole, no formatting needed
+				realAttrib = true;
+				filter.append(attrib.getValue());
+
+			} else if (Constants.OBJECTCLASS.equals(attribName)) {
+				realAttrib = true;
+				// objectClass has a "," separated list of interfaces
+				String[] values = attrib.getValue().split(",");
+				for (String s : values)
+					filter.append("(" + Constants.OBJECTCLASS + "=" + s + ")");
+
+			} else {
+				// attribName was not version..
+				realAttrib = true;
+
+				filter.append("(" + attribName + "=" + attrib.getValue() + ")");
+				// store all attributes in order to build up the mandatory
+				// filter and separate them with ", "
+				// skip bundle-symbolic-name in the mandatory directive query
+				if (!!!Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE
+						.equals(attribName)) {
+					realAttribs.append(attribName);
+					realAttribs.append(", ");
+				}
+			}
+		}
+		/*
+		 * The following is how OBR makes mandatory attributes work, we require
+		 * that the set of mandatory attributes on the export is a subset of (or
+		 * equal to) the set of the attributes we supply.
+		 */
+
+		if (realAttribs.length() > 0) {
+			String attribStr = (realAttribs.toString()).trim();
+			// remove the final ,
+			if ((attribStr.length() > 0) && (attribStr.endsWith(","))) {
+				attribStr = attribStr.substring(0, attribStr.length() - 1);
+			}
+			// build the mandatory filter, e.g.(mandatory:&lt;*company, local)
+			filter.append("(" + Constants.MANDATORY_DIRECTIVE + ":" + "<*"
+					+ attribStr + ")");
+		}
+
+		// Prune (& off the front and ) off end
+		String filterString = filter.toString();
+		int openBraces = 0;
+		for (int i = 0; openBraces < 3; i++) {
+			i = filterString.indexOf('(', i);
+			if (i == -1) {
+				break;
+			} else {
+				openBraces++;
+			}
+		}
+		if (openBraces < 3 && filterString.length() > 2) {
+			filter.delete(0, 2);
+		} else {
+			filter.append(")");
+		}
+
+		String result = "";
+		if (realAttrib != false) {
+			result = filter.toString();
+		}
+		return result;
+	}
+
+	/**
+   * Generate a filter from a set of attributes. This filter will be suitable
+   * for presentation to OBR. This means that, due to the way OBR works, it will
+   * include a stanza of the form, (mandatory:<*mandatoryAttribute) Filter
+   * strings generated by this method will therefore tend to break the standard
+   * OSGi Filter class. The OBR stanza can be stripped out later if required.
+   * 
+   * We may wish to consider relocating this method since VersionRange has its
+   * own top level class.
+   * 
+   * @param type
+   * @param name
+   * @param attribs
+   * @return filter string
+   */
+  public static String generateFilter(String type, String name,
+      Map<String, String> attribs) {
+    StringBuffer filter = new StringBuffer();
+    String result;
+    // shortcut for the simple case with no attribs.
+
+    if (attribs == null || attribs.isEmpty())
+      filter.append("(" + type + "=" + name + ")");
+    else {
+      // process all the attribs passed.
+      // find out whether there are attributes on the filter
+
+      filter.append("(&(" + type + "=" + name + ")");
+
+      String filterString = generateFilter(attribs);
+
+      int start = 0;
+      int end = filterString.length();
+      if (filterString.startsWith("(&")) {
+        start = 2;
+        end--;
+      }
+
+      if ("".equals(filterString)) {
+        filter.delete(0, 2);
+      } else {
+        filter.append(filterString, start, end);
+        filter.append(")");
+      }
+    }
+
+    result = filter.toString();
+
+    return result;
+  }
+
+  private static Map<String, String> parseFilterList(String filter) {
+
+    Map<String, String> result = new HashMap<String, String>();
+    Set<String> negatedVersions = new HashSet<String>();
+    Set<String> negatedBundleVersions = new HashSet<String>();
+
+    String lowerVersion = null;
+    String upperVersion = null;
+    String lowerBundleVersion = null;
+    String upperBundleVersion = null;
+
+    Matcher m = FILTER_ATTR.matcher(filter);
+    while (m.find()) {
+      boolean negation = m.group(1) != null;
+      String attr = m.group(2);
+      String op = m.group(3);
+      String value = m.group(4);
+
+      if (Constants.VERSION_ATTRIBUTE.equals(attr)) {
+        if (negation) {
+          negatedVersions.add(value);
+        } else {
+          if (GREATER_EQ_OP.equals(op))
+            lowerVersion = value;
+          else if (LESS_EQ_OP.equals(op))
+            upperVersion = value;
+          else
+            throw new IllegalArgumentException();
+        }
+      } else if (Constants.BUNDLE_VERSION_ATTRIBUTE.equals(attr)) {
+        // bundle-version is like version, but may be specified at the
+        // same time
+        // therefore we have similar code with separate variables
+        if (negation) {
+          negatedBundleVersions.add(value);
+        } else {
+          if (GREATER_EQ_OP.equals(op))
+            lowerBundleVersion = value;
+          else if (LESS_EQ_OP.equals(op))
+            upperBundleVersion = value;
+          else
+            throw new IllegalArgumentException();
+        }
+      } else {
+        result.put(attr, value);
+      }
+    }
+
+    if (lowerVersion != null) {
+      StringBuilder versionAttr = new StringBuilder(lowerVersion);
+      if (upperVersion != null) {
+        versionAttr.append(",").append(upperVersion).insert(0,
+            negatedVersions.contains(lowerVersion) ? '(' : '[').append(
+            negatedVersions.contains(upperVersion) ? ')' : ']');
+      }
+
+      result.put(Constants.VERSION_ATTRIBUTE, versionAttr.toString());
+    }
+    // Do it again for bundle-version
+    if (lowerBundleVersion != null) {
+      StringBuilder versionAttr = new StringBuilder(lowerBundleVersion);
+      if (upperBundleVersion != null) {
+        versionAttr.append(",").append(upperBundleVersion).insert(0,
+            negatedBundleVersions.contains(lowerBundleVersion) ? '(' : '[')
+            .append(
+                negatedBundleVersions.contains(upperBundleVersion) ? ')' : ']');
+      }
+
+      result.put(Constants.BUNDLE_VERSION_ATTRIBUTE, versionAttr.toString());
+    }
+
+    return result;
+  }
+	  
+  public static Map<String,String> parseFilter(String filter) 
+  {
+    Map<String,String> result;
+    if (filter.startsWith("(&")) {
+      result = parseFilterList(filter.substring(2, filter.length()-1));
+    } else {
+      result = parseFilterList(filter);
+    }
+    return result;
+  }
+
+}
+
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/ManifestProcessor.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/ManifestProcessor.java
index ada1bb9a..15fd83c3 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/ManifestProcessor.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/manifest/ManifestProcessor.java
@@ -1,3 +1,225 @@
   + text/plain
   + Date Revision
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.manifest;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.jar.Attributes;
+import java.util.jar.Manifest;
+
+import org.apache.aries.util.filesystem.IDirectory;
+import org.apache.aries.util.filesystem.IFile;
+import org.apache.aries.util.io.IOUtils;
+
+/**
+ * This class contains utilities for parsing manifests. It provides methods to
+ * parse the manifest, read a manifest into a map and to split an manifest
+ * entry that follows the Import-Package syntax.
+ */
+public class ManifestProcessor
+{
+  /**
+   * Reads a manifest's main attributes into a String->String map.
+   * <p>
+   * Will always return a map, empty if the manifest had no attributes.
+   * 
+   * @param mf The manifest to read.
+   * @return Map of manifest main attributes.
+   */
+  public static Map<String, String> readManifestIntoMap(Manifest mf){
+
+    HashMap<String, String> props = new HashMap<String, String>();
+    
+    Attributes mainAttrs = mf.getMainAttributes();
+    if (mainAttrs!=null){
+      Set<Entry<Object, Object>> attributeSet =  mainAttrs.entrySet(); 
+      if (attributeSet != null){
+        // Copy all the manifest headers across. The entry set should be a set of
+        // Name to String mappings, by calling String.valueOf we do the conversion
+        // to a string and we do not NPE.
+        for (Map.Entry<Object, Object> entry : attributeSet) {
+          props.put(String.valueOf(entry.getKey()), String.valueOf(entry.getValue()));
+        }
+      }    
+    }
+         
+    return props;
+  }
+  
+  /**
+   * mapToManifest
+   */
+  public static Manifest mapToManifest (Map<String,String> attributes)
+  {
+    Manifest man = new Manifest();
+    Attributes att = man.getMainAttributes();
+    att.putValue(Attributes.Name.MANIFEST_VERSION.toString(), Constants.MANIFEST_VERSION);
+    for (Map.Entry<String, String> entry : attributes.entrySet()) {
+      att.putValue(entry.getKey(),  entry.getValue());
+    }
+    return man;
+  }
+  
+  /**
+   * This method parses the manifest using a custom manifest parsing routine.
+   * This means that we can avoid the 76 byte line length in a manifest providing
+   * a better developer experience.
+   * 
+   * @param in the input stream to read the manifest from.
+   * @return   the parsed manifest
+   * @throws IOException
+   */
+  public static Manifest parseManifest(InputStream in) throws IOException
+  {
+    Manifest man = new Manifest();
+    
+    try
+    {
+      // I'm assuming that we use UTF-8 here, but the jar spec doesn't say.
+      BufferedReader reader = new BufferedReader(new InputStreamReader(in, "UTF-8"));
+      
+      String line;
+      StringBuilder attribute = null;
+      
+      String namedAttribute = null;
+      
+      do {
+        line = reader.readLine();
+  
+        // if we get a blank line skip to the next one
+        if (line != null && line.trim().length() == 0) continue;
+        if (line != null && line.charAt(0) == ' ' && attribute != null) {
+          // we have a continuation line, so add to the builder, ignoring the
+          // first character
+          attribute.append(line.trim());
+        } else if (attribute == null) {
+          attribute = new StringBuilder(line.trim());
+        } else if (attribute != null) {
+          // We have fully parsed an attribute
+          int index = attribute.indexOf(":");
+          String attributeName = attribute.substring(0, index).trim();
+          // TODO cope with index + 1 being after the end of attribute
+          String attributeValue = attribute.substring(index + 1).trim();
+          
+          if ("Name".equals(attributeName)) {
+            man.getEntries().put(attributeValue, new Attributes());
+            namedAttribute = attributeValue;
+          } else {
+            if (namedAttribute == null) {
+              man.getMainAttributes().put(new Attributes.Name(attributeName), attributeValue);
+            } else {
+              man.getAttributes(namedAttribute).put(new Attributes.Name(attributeName), attributeValue);
+            }
+          }
+          
+          if (line != null) attribute = new StringBuilder(line.trim());
+        }
+      } while (line != null);
+    }
+    finally {
+      IOUtils.close(in);
+    }
+    return man;
+  }
+  
+  /**
+   * Obtain a manifest from an IDirectory. 
+   * 
+   * @param appDir
+   * @param manifestName the name of manifest
+   * @return Manifest, or null if none found.
+   * @throws IOException
+   */
+  public static Manifest obtainManifestFromAppDir(IDirectory appDir, String manifestName) throws IOException{
+    IFile manifestFile = appDir.getFile(manifestName);
+    Manifest man = null;
+    if (manifestFile != null) {
+      man = parseManifest(manifestFile.open());
+    }
+    return man;
+  }
+
+  
+  /**
+   * 
+   * Splits a delimiter separated string, tolerating presence of non separator commas
+   * within double quoted segments.
+   * 
+   * Eg.
+   * com.ibm.ws.eba.helloWorldService;version="[1.0.0, 1.0.0]" &
+   * com.ibm.ws.eba.helloWorldService;version="1.0.0"
+   * com.ibm.ws.eba.helloWorld;version="2";bundle-version="[2,30)"
+   * com.acme.foo;weirdAttr="one;two;three";weirdDir:="1;2;3"
+   *  @param value          the value to be split
+   *  @param delimiter      the delimiter string such as ',' etc.
+   *  @return List<String>  the components of the split String in a list
+   */
+  public static List<String> split(String value, String delimiter)
+  {
+
+    List<String> result = new ArrayList<String>();
+    if (value != null) {
+      String[] packages = value.split(delimiter);
+      
+      for (int i = 0; i < packages.length; ) {
+        String tmp = packages[i++].trim();
+        // if there is a odd number of " in a string, we need to append
+        while (count(tmp, "\"") % 2 == 1) {
+          // check to see if we need to append the next package[i++]
+          tmp = tmp + delimiter + packages[i++].trim();
+        }
+        
+        result.add(tmp);
+      }
+    }
+
+    return result;
+  }  
+  
+  /**
+   * count the number of characters in a string
+   * @param parent The string to be searched
+   * @param subString The substring to be found
+   * @return the number of occurrence of the subString
+   */
+   private static int count(String parent, String subString) {
+     
+     int count = 0 ;
+     int i = parent.indexOf(subString);
+     while (i > -1) {
+       if (parent.length() >= i+1)
+         parent = parent.substring(i+1);
+       count ++;
+       i = parent.indexOf(subString);
+     }
+     return count;
+   }  
+   
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/nls/MessageUtil.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/nls/MessageUtil.java
index e69de29b..1a65479b 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/nls/MessageUtil.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/nls/MessageUtil.java
@@ -0,0 +1,157 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.nls;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.Locale;
+import java.util.MissingResourceException;
+import java.util.ResourceBundle;
+
+import org.apache.aries.util.AriesFrameworkUtil;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.FrameworkUtil;
+
+/**
+ * This is a helper class for loading messages for logging and exception messages. It supports translating the message into the
+ * default Locale. It works out the calling Bundle and uses it to load any resources. If the resource bundle is of type
+ * java.properties then it tries to find the bundle first via the bundle getResources method, then via the getEntry method. If it
+ * is of type java.class then it'll use the bundle to load the class.
+ */
+public final class MessageUtil
+{
+  /** The resource bundle used to translate messages */
+  private final ResourceBundle messages;
+  private static final StackFinder finder;
+
+  /** 
+   * One of the static methods needs to obtain the caller, so we cheat and use a SecurityManager to get the 
+   * classes on the stack.
+   */
+  private static class StackFinder extends SecurityManager
+  {
+    @Override
+    public Class<?>[] getClassContext()
+    {
+      return super.getClassContext();
+    }
+  }
+  
+  static 
+  {
+    finder = AccessController.doPrivileged(new PrivilegedAction<StackFinder>() {
+      public StackFinder run()
+      {
+        return new StackFinder();
+      }
+    });
+  }
+
+  private MessageUtil(ResourceBundle b)
+  {
+    messages = b;
+  }
+
+  /**
+   * This method translates the message and puts the inserts into the message before returning it.
+   * If the message key does not exist then the key itself is returned.
+   * 
+   * @param key     the message key.
+   * @param inserts the inserts into the resolved message.
+   * @return the message in the correct language, or the key if the message does not exist.
+   */
+  public String getMessage(String key, Object ... inserts)
+  {
+    String message;
+
+    try {
+      message = messages.getString(key);
+
+      if (inserts != null && inserts.length > 0) {
+        message = MessageFormat.format(message, inserts);
+      }
+    } catch (MissingResourceException e) {
+      message = key;
+    }
+
+    return message;
+  }
+
+  /**
+   * Loads the MessageUtil using the given context. It resolves the Class to an OSGi bundle.
+   * 
+   * @param context  the bundle this class is in will be used to resolve the base name.
+   * @param baseName the resource bundle base name
+   * @return the message util instance.
+   * @throws MissingResourceException If the resource bundle cannot be located
+   */
+  public static MessageUtil createMessageUtil(Class<?> context, String baseName)
+  {
+    return createMessageUtil(FrameworkUtil.getBundle(context), baseName);
+  }
+
+  /**
+   * This method uses the Bundle associated with the caller of this method.
+   * 
+   * @param baseName the resource bundle base name
+   * @return the message util instance.
+   * @throws MissingResourceException If the resource bundle cannot be located
+   */
+  public static MessageUtil createMessageUtil(String baseName)
+  {
+    Class<?>[] stack = finder.getClassContext();
+
+    for (Class<?> clazz : stack) {
+      if (clazz != MessageUtil.class) {
+        return createMessageUtil(clazz, baseName);
+      }
+    }
+
+    throw new MissingResourceException(org.apache.aries.util.internal.MessageUtil.getMessage("UTIL0014E", baseName), baseName, null);
+  }
+
+  /**
+   * This method loads the resource bundle backing the MessageUtil from the provided Bundle.
+   * 
+   * @param b        the bundle to load the resource bundle from
+   * @param baseName the resource bundle base name
+   * @return the message util instance.
+   * @throws MissingResourceException If the resource bundle cannot be located
+   */
+  public static MessageUtil createMessageUtil(final Bundle b, String baseName)
+  {
+    ResourceBundle rb;
+    
+    if (b == null) {
+      // if the bundle is null we are probably outside of OSGi, so just use non-OSGi resolve rules.
+      rb = ResourceBundle.getBundle(baseName);
+    } else {
+      // if the bundle is OSGi use OSGi resolve rules as best as Java5 allows
+      ClassLoader loader = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
+        public ClassLoader run() {
+            return AriesFrameworkUtil.getClassLoader(b);
+        }          
+      }); 
+      rb = ResourceBundle.getBundle(baseName, Locale.getDefault(), loader);
+    }
+    
+    return new MessageUtil(rb);
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/service/registry/ServicePair.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/service/registry/ServicePair.java
index ada1bb9a..736fc582 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/service/registry/ServicePair.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/service/registry/ServicePair.java
@@ -1,3 +1,81 @@
   + text/plain
   + Date Revision
   + native
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.service.registry;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceReference;
+
+// TODO need to determine if this needs to be thread safe or not
+public class ServicePair<T>
+{
+  private BundleContext ctx;
+  private ServiceReference ref;
+  private T serviceObject;
+  
+  public ServicePair(BundleContext context, ServiceReference serviceRef)
+  {
+    ctx = context;
+    ref = serviceRef;
+  }
+  
+  public ServicePair(BundleContext context, ServiceReference serviceRef, T service)
+  {
+    ctx = context;
+    ref = serviceRef;
+    serviceObject = service;
+  }
+  
+  @SuppressWarnings("unchecked")
+  public T get()
+  {
+    if (serviceObject == null && ref.getBundle() != null) {
+      serviceObject = AccessController.doPrivileged(new PrivilegedAction<T>() {
+          public T run()
+          {
+            return serviceObject = (T) ctx.getService(ref);
+          }
+        });
+    }
+    
+    return serviceObject;
+  }
+  
+  public boolean isValid() {
+    return (ref.getBundle() != null);
+  }
+
+  public void unget()
+  {
+    if (serviceObject != null) {
+      ctx.ungetService(ref);
+      serviceObject = null;
+    }
+  }
+
+  public ServiceReference getReference() 
+  {
+    return ref;
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/tracker/BundleTrackerFactory.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/tracker/BundleTrackerFactory.java
index ada1bb9a..e4837662 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/tracker/BundleTrackerFactory.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/tracker/BundleTrackerFactory.java
@@ -1,3 +1,109 @@
   + text/plain
   + Date Revision
   + native
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.tracker;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+
+import org.osgi.framework.Version;
+import org.osgi.util.tracker.BundleTracker;
+
+/**
+ * This is the factory for BundleTracker
+ */
+public class BundleTrackerFactory {
+    private static ConcurrentHashMap<String, List<BundleTracker>> btMap = new ConcurrentHashMap<String, List<BundleTracker>>();
+
+    /**
+     * get bundle tracker based on bundle name and version
+     * 
+     * @param bundleScope
+     *            composite bundle's - SymbolicName_Version
+     * @return the list of bundle tracker associated with the bundle scope
+     */
+    public static List<BundleTracker> getBundleTrackerList(String bundleScope) {
+        return (List<BundleTracker>) btMap.get(bundleScope);
+    }
+
+    /**
+     * get bundle tracker based on composite bundle's symbolicName and version
+     * 
+     * @param symbolicName
+     *            composite bundle's symbolicName
+     * @param version
+     *            composite bundle's version
+     * @return the list of bundle tracker associated with the bundle scope
+     */
+    public static List<BundleTracker> getBundleTrackerList(String symbolicName,
+            Version version) {
+        return (List<BundleTracker>) btMap.get(symbolicName + "_"
+                + version.toString());
+    }
+
+    /**
+     * get all bundle tracker registered in this factory
+     * 
+     * @return all the trackers registered. The collection contains a List<BundleTracker> for each bundle scope.
+     */
+    public static Collection<List<BundleTracker>> getAllBundleTracker() {
+        return btMap.values();
+    }
+
+    /**
+     * register the bundle tracker
+     * 
+     * @param bundleScope
+     *            composite bundle's SymbolicName_Version
+     * @param bt
+     *            the bundle tracker to be registered
+     */
+    public static void registerBundleTracker(String bundleScope,
+            BundleTracker bt) {
+        List<BundleTracker> list = btMap.get(bundleScope);
+        if (list == null) {
+            list = new ArrayList<BundleTracker>();
+        }
+        list.add(bt);
+        btMap.putIfAbsent(bundleScope, list);
+    }
+
+    /**
+     * unregister and close the bundle tracker(s) associated with composite
+     * bundle's - SymbolicName_Version
+     * 
+     * @param bundleScope
+     *            composite bundle's - SymbolicName_Version
+     */
+    public static void unregisterAndCloseBundleTracker(String bundleScope) {
+        List<BundleTracker> list = btMap.get(bundleScope);
+        if (list == null) {
+            return;
+        } else {
+            for (BundleTracker bt : list) {
+                bt.close();
+            }
+        }
+        btMap.remove(bundleScope);
+    }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/tracker/InternalRecursiveBundleTracker.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/tracker/InternalRecursiveBundleTracker.java
index e69de29b..274758fe 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/tracker/InternalRecursiveBundleTracker.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/tracker/InternalRecursiveBundleTracker.java
@@ -0,0 +1,160 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.tracker;
+
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.BundleEvent;
+import org.osgi.service.framework.CompositeBundle;
+import org.osgi.util.tracker.BundleTracker;
+import org.osgi.util.tracker.BundleTrackerCustomizer;
+
+/**
+ * A BundleTracker which will track bundles in the given context, and also 
+ * bundles in any child contexts. This should be used instead of the
+ * normal non-recursive BundleTracker when registering bundle tracker
+ * customizers.
+ */
+public class InternalRecursiveBundleTracker extends BundleTracker
+{
+  private final int mask;
+
+  private final ConcurrentMap<String,String> alreadyRecursedContexts = new ConcurrentHashMap<String, String>();
+
+  private final BundleTrackerCustomizer customizer;
+
+  public InternalRecursiveBundleTracker(BundleContext context, int stateMask,
+      BundleTrackerCustomizer customizer)
+  {
+    super(context, stateMask, null);
+    mask = stateMask;
+    this.customizer = customizer;
+  }
+
+  /*
+  * (non-Javadoc)
+  * @see org.osgi.util.tracker.BundleTracker#addingBundle(org.osgi.framework.Bundle, org.osgi.framework.BundleEvent)
+  */
+  @Override
+  public Object addingBundle(Bundle b, BundleEvent event)
+  {
+    Object o = null;
+
+    if (b instanceof CompositeBundle) {
+      customizedProcessBundle(this, b, event);
+      o = b;
+    } else {
+      // Delegate to our customizer for normal bundles
+      if (customizer != null) {
+        o = customizer.addingBundle(b, event);
+      }
+    }
+
+    return o;
+  }
+
+  /*
+   * (non-Javadoc)
+   * @see org.osgi.util.tracker.BundleTracker#modifiedBundle(org.osgi.framework.Bundle, org.osgi.framework.BundleEvent, java.lang.Object)
+   */
+  @Override
+  public void modifiedBundle(Bundle b, BundleEvent event, Object object)
+  {
+    if (b instanceof CompositeBundle) {
+      customizedProcessBundle(this, b, event);
+    } else {
+      // Delegate to our customizer for normal bundles
+      if (customizer != null) {
+        customizer.modifiedBundle(b, event, object);
+      }
+    }
+  }
+
+  /*
+   * (non-Javadoc)
+   * @see org.osgi.util.tracker.BundleTracker#removedBundle(org.osgi.framework.Bundle, org.osgi.framework.BundleEvent, java.lang.Object)
+   */
+  @Override
+  public void removedBundle(Bundle b, BundleEvent event, Object object)
+  {
+    if (b instanceof CompositeBundle) {
+      customizedProcessBundle(this, b, event);
+    } else {
+      if (customizer != null) {
+        customizer.removedBundle(b, event, object);
+      }
+    }
+  }
+
+  protected void customizedProcessBundle(BundleTrackerCustomizer btc, Bundle b, BundleEvent event)
+  {
+    if (b instanceof CompositeBundle) {
+      CompositeBundle cb = (CompositeBundle) b;
+      // check if the compositeBundle is already tracked in the
+      // BundleTrackerFactory
+      String bundleScope = cb.getSymbolicName() + "_" + cb.getVersion().toString();
+      List<BundleTracker> btList = BundleTrackerFactory.getBundleTrackerList(bundleScope);
+
+      // bundle is already active and there is no event associated
+      // this can happen when bundle is first time added to the tracker
+      if (event == null) {
+        if (cb.getState() == Bundle.INSTALLED || cb.getState() == Bundle.RESOLVED || cb.getState() == Bundle.STARTING || cb.getState() == Bundle.ACTIVE) {
+          openTracker(btc, cb, bundleScope, mask);
+        }
+      } else {
+        if (event.getType() == BundleEvent.STOPPED || event.getType() == BundleEvent.UNRESOLVED || event.getType() == BundleEvent.UNINSTALLED) {
+          // if CompositeBundle is being stopped, let's remove the bundle
+          // tracker(s) associated with the composite bundle
+          String bundleId = b.getSymbolicName()+"/"+b.getVersion();
+          alreadyRecursedContexts.remove(bundleId);
+          
+          if (btList != null) {
+            // unregister the bundlescope off the factory and close
+            // bundle trackers
+            BundleTrackerFactory.unregisterAndCloseBundleTracker(bundleScope);
+          }
+        } else if (event.getType() == BundleEvent.INSTALLED || event.getType() == BundleEvent.RESOLVED || event.getType() == BundleEvent.STARTING) {
+          openTracker(btc, cb, bundleScope, mask);
+        }
+      }
+    }
+  }
+
+  private synchronized void openTracker(BundleTrackerCustomizer btc, CompositeBundle cb,
+      String bundleScope, int stateMask)
+  {
+    // let's process each of the bundle in the CompositeBundle
+    BundleContext compositeBundleContext = cb.getCompositeFramework().getBundleContext();
+    
+    String bundleId = cb.getSymbolicName()+"/"+cb.getVersion();
+    if (alreadyRecursedContexts.putIfAbsent(bundleId, bundleId) == null) {
+
+      // let's track each of the bundle in the CompositeBundle
+      BundleTracker bt = new InternalRecursiveBundleTracker(compositeBundleContext, stateMask,
+          customizer);
+      bt.open();
+      BundleTrackerFactory.registerBundleTracker(bundleScope, bt);
+    }
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/tracker/SingleServiceTracker.java b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/tracker/SingleServiceTracker.java
index ada1bb9a..d68ae711 100644
--- a/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/tracker/SingleServiceTracker.java
+++ b/aries/trunk/util/util-r42/src/main/java/org/apache/aries/util/tracker/SingleServiceTracker.java
@@ -1,3 +1,180 @@
   + text/plain
   + Date Revision
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util.tracker;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Constants;
+import org.osgi.framework.Filter;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.ServiceEvent;
+import org.osgi.framework.ServiceListener;
+import org.osgi.framework.ServiceReference;
+
+public final class SingleServiceTracker<T> 
+{
+  public static interface SingleServiceListener
+  {
+    public void serviceFound();
+    public void serviceLost();
+    public void serviceReplaced();
+  }
+  
+  private final BundleContext ctx;
+  private final String className;
+  private final AtomicReference<T> service = new AtomicReference<T>();
+  private final AtomicReference<ServiceReference> ref = new AtomicReference<ServiceReference>();
+  private final AtomicBoolean open = new AtomicBoolean(false);
+  private final SingleServiceListener serviceListener;
+  private String filterString;
+  private Filter filter;
+
+  private final ServiceListener listener = new ServiceListener()
+  {
+    public void serviceChanged(ServiceEvent event) 
+    {
+      if (open.get()) {
+        if (event.getType() == ServiceEvent.UNREGISTERING) {
+          ServiceReference deadRef = event.getServiceReference();
+          if (deadRef.equals(ref.get())) {
+            findMatchingReference(deadRef);
+          }
+        } else if (event.getType() == ServiceEvent.REGISTERED && ref.get() == null) {
+          findMatchingReference(null);
+        }
+      }
+    }
+  };
+  
+  public SingleServiceTracker(BundleContext context, Class<T> clazz, SingleServiceListener sl)
+  {
+    ctx = context;
+    this.className = clazz.getName();
+    serviceListener = sl;
+  }
+  
+  public SingleServiceTracker(BundleContext context, Class<T> clazz, String filterString, SingleServiceListener sl) throws InvalidSyntaxException
+  {
+    this(context, clazz, sl);
+    this.filterString = filterString;
+    if (filterString != null) filter = context.createFilter(filterString);
+  }
+  
+  public T getService()
+  {
+    return service.get();
+  }
+  
+  public ServiceReference getServiceReference()
+  {
+    return ref.get();
+  }
+  
+  public void open()
+  {
+    if (open.compareAndSet(false, true)) {
+      try {
+        String filterString = '(' + Constants.OBJECTCLASS + '=' + className + ')';
+        if (filter != null) filterString = "(&" + filterString + filter + ')';
+        ctx.addServiceListener(listener, filterString);
+        findMatchingReference(null);
+      } catch (InvalidSyntaxException e) {
+        // this can never happen. (famous last words :)
+      }
+    }
+  }
+
+  private void findMatchingReference(ServiceReference original) {
+    boolean clear = true;
+    ServiceReference ref = ctx.getServiceReference(className);
+    if (ref != null && (filter == null || filter.match(ref))) {
+      @SuppressWarnings("unchecked")
+      T service = (T) ctx.getService(ref);
+      if (service != null) {
+        clear = false;
+        
+        // We do the unget out of the lock so we don't exit this class while holding a lock.
+        if (!!!update(original, ref, service)) {
+          ctx.ungetService(ref);
+        }
+      }
+    } else if (original == null){
+      clear = false;
+    }
+    
+    if (clear) {
+      update(original, null, null);
+    }
+  }
+  
+  private boolean update(ServiceReference deadRef, ServiceReference newRef, T service)
+  {
+    boolean result = false;
+    int foundLostReplaced = -1;
+
+    // Make sure we don't try to get a lock on null
+    Object lock;
+    
+    // we have to choose our lock.
+    if (newRef != null) lock = newRef;
+    else if (deadRef != null) lock = deadRef;
+    else lock = this;
+    
+    // This lock is here to ensure that no two threads can set the ref and service
+    // at the same time. 
+    synchronized (lock) {
+      if (open.get()) {
+        result = this.ref.compareAndSet(deadRef, newRef);
+        if (result) {
+          this.service.set(service);
+
+          if (deadRef == null && newRef != null) foundLostReplaced = 0;
+          if (deadRef != null && newRef == null) foundLostReplaced = 1;
+          if (deadRef != null && newRef != null) foundLostReplaced = 2;
+        }
+      }
+    }
+
+    if (serviceListener != null) {
+      if (foundLostReplaced == 0) serviceListener.serviceFound();
+      else if (foundLostReplaced == 1) serviceListener.serviceLost();
+      else if (foundLostReplaced == 2) serviceListener.serviceReplaced();
+    }
+
+    return result;
+  }
+
+  public void close()
+  {
+    if (open.compareAndSet(true, false)) {
+      ctx.removeServiceListener(listener);
+      
+      synchronized (this) {
+        ServiceReference deadRef = ref.getAndSet(null);
+        service.set(null);
+        if (deadRef != null) ctx.ungetService(deadRef);
+      }
+    }
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/BundleToClassLoaderAdapterTest.java b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/BundleToClassLoaderAdapterTest.java
index 02a8af2c..53c462b2 100644
--- a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/BundleToClassLoaderAdapterTest.java
+++ b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/BundleToClassLoaderAdapterTest.java
@@ -1,3 +1,75 @@
   + text/xml
   + Date Revision
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util;
+
+import org.apache.aries.unittest.mocks.MethodCall;
+import org.apache.aries.unittest.mocks.Skeleton;
+import org.apache.aries.util.internal.BundleToClassLoaderAdapter;
+import org.junit.Test;
+import org.osgi.framework.Bundle;
+
+import static org.junit.Assert.assertEquals;
+
+public class BundleToClassLoaderAdapterTest {
+    @Test(expected=ClassNotFoundException.class)
+    public void testInheritance() throws Exception {
+        ClassLoader testLoader = new ClassLoader(makeSUT(false)) {
+        };
+        
+        testLoader.loadClass(Bundle.class.getName());
+    }
+    
+    @Test
+    public void testInheritancePositive() throws Exception {
+        ClassLoader testLoader = new ClassLoader(makeSUT(true)) {
+        };
+
+        assertEquals(Bundle.class, testLoader.loadClass(Bundle.class.getName()));
+    }
+    
+    @Test
+    public void testStraightLoadClass() throws Exception {
+        assertEquals(Bundle.class, makeSUT(true).loadClass(Bundle.class.getName()));
+    }
+    
+    @Test(expected=ClassNotFoundException.class)
+    public void testLoadClassFailure() throws Exception {
+        makeSUT(false).loadClass(Bundle.class.getName());        
+    }
+    
+    @Test
+    public void testLoadWithResolve() throws Exception {
+        assertEquals(Bundle.class, makeSUT(true).loadClass(Bundle.class.getName(), true));
+    }
+    
+    private BundleToClassLoaderAdapter makeSUT(boolean includeBundleClass) {
+        Bundle bundle = Skeleton.newMock(Bundle.class);
+        if (includeBundleClass) {
+            Skeleton.getSkeleton(bundle).setReturnValue(new MethodCall(Bundle.class, "loadClass", Bundle.class.getName()), Bundle.class);
+        } else {
+            Skeleton.getSkeleton(bundle).setThrows(new MethodCall(Bundle.class, "loadClass", Bundle.class.getName()), new ClassNotFoundException());
+        }
+        
+        return new BundleToClassLoaderAdapter(bundle);
+    }
+}
diff --git a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/FragmentUtilsTest.java b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/FragmentUtilsTest.java
index ada1bb9a..bffe6f17 100644
--- a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/FragmentUtilsTest.java
+++ b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/FragmentUtilsTest.java
@@ -1,3 +1,148 @@
   + text/plain
   + Date Revision
   + native
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.util.Dictionary;
+import java.util.Hashtable;
+
+import org.apache.aries.mocks.BundleMock;
+import org.apache.aries.unittest.mocks.Skeleton;
+import org.junit.Before;
+import org.junit.Test;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.Constants;
+
+public class FragmentUtilsTest {
+
+    private Bundle hostBundle;
+
+    @Before
+    public void setUp() throws Exception {
+        hostBundle = Skeleton.newMock(new BundleMock("scooby.doo",
+                new Hashtable<String, Object>()), Bundle.class);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testFragmentCreation() throws Exception {
+        Bundle exportBundle = makeBundleWithExports("export.bundle", "1.2.3",
+                "export.package;version=\"1.0.0\";uses:=\"foo.jar,bar.jar\";singleton:=true");
+
+        Dictionary fragmentHeaders = makeFragmentFromExportBundle(exportBundle)
+                .getHeaders();
+
+        assertNotNull("No headers in the fragment", fragmentHeaders);
+
+        assertEquals("Wrong symbolicName", "scooby.doo.test.fragment",
+                    fragmentHeaders.get(Constants.BUNDLE_SYMBOLICNAME));
+        assertEquals("Wrong version", "0.0.0", 
+                    fragmentHeaders.get(Constants.BUNDLE_VERSION));
+        assertEquals("Wrong Bundle manifest version", "2", 
+                    fragmentHeaders.get(Constants.BUNDLE_MANIFESTVERSION));
+        assertEquals("Wrong Fragment host", "scooby.doo;bundle-version=\"0.0.0\"", 
+                    fragmentHeaders.get(Constants.FRAGMENT_HOST));
+        assertEquals("Wrong Bundle Name", "Test Fragment bundle",
+                    fragmentHeaders.get(Constants.BUNDLE_NAME));
+        assertEquals(
+                "Wrong Imports",
+                "export.package;version=\"1.0.0\";bundle-symbolic-name=\"export.bundle\";bundle-version=\"[1.2.3,1.2.3]\"",
+                fragmentHeaders.get(Constants.IMPORT_PACKAGE));
+    }
+
+    private Bundle makeBundleWithExports(String symbolicName, String version,
+            String exports) {
+        Hashtable<String, Object> headers = new Hashtable<String, Object>();
+        headers.put(Constants.BUNDLE_VERSION, version);
+        headers.put(Constants.EXPORT_PACKAGE, exports);
+        Bundle exportBundle = Skeleton.newMock(new BundleMock(symbolicName,
+                headers), Bundle.class);
+        return exportBundle;
+    }
+
+    private Bundle makeFragmentFromExportBundle(Bundle exportBundle)
+            throws Exception {
+        FragmentBuilder builder = new FragmentBuilder(hostBundle, "test.fragment", "fragment");
+        builder.setName("Test Fragment bundle");
+        builder.addImportsFromExports(exportBundle);
+
+        return builder.install(hostBundle.getBundleContext());
+    }
+
+    @Test
+    public void testManifestAttributes() throws Exception {
+        String fakeExportsListNoExtras = "no.such.export,no.such.export2";
+        String fakeExportsListAttrOnly = "no.such.export;version=\"1.1.1\",no.such.export2;version=\"2.2.2\"";
+        String fakeExportsListDirOnly = "no.such.export;uses:=\"some.other.thing\",no.such.export2;include:=\"some.thing\"";
+        String fakeExportsListMixed = "no.such.export;version=\"1.1.1\";uses:=\"some.other.thing\",no.such.export2;include:=\"some.thing\"";
+        String fakeExportsListFunkyAttr = "no.such.export;attribute=\"a:=\",no.such.export2;attributeTwo=\"b:=\";include:=\"some.thing\"";
+
+        String expectedImportsListNoExtras = "no.such.export;bundle-symbolic-name=\"no.such.provider\";bundle-version=\"[1.1.1,1.1.1]\",no.such.export2;bundle-symbolic-name=\"no.such.provider\";bundle-version=\"[1.1.1,1.1.1]\"";
+        String expectedImportsListAttrOnly = "no.such.export;version=\"1.1.1\";bundle-symbolic-name=\"no.such.provider\";bundle-version=\"[1.1.1,1.1.1]\",no.such.export2;version=\"2.2.2\";bundle-symbolic-name=\"no.such.provider\";bundle-version=\"[1.1.1,1.1.1]\"";
+        String expectedImportsListDirOnly = "no.such.export;bundle-symbolic-name=\"no.such.provider\";bundle-version=\"[1.1.1,1.1.1]\",no.such.export2;bundle-symbolic-name=\"no.such.provider\";bundle-version=\"[1.1.1,1.1.1]\"";
+        String expectedImportsListMixed = "no.such.export;version=\"1.1.1\";bundle-symbolic-name=\"no.such.provider\";bundle-version=\"[1.1.1,1.1.1]\",no.such.export2;bundle-symbolic-name=\"no.such.provider\";bundle-version=\"[1.1.1,1.1.1]\"";
+        String expectedImportsListFunkyAttr = "no.such.export;attribute=\"a:=\";bundle-symbolic-name=\"no.such.provider\";bundle-version=\"[1.1.1,1.1.1]\",no.such.export2;attributeTwo=\"b:=\";bundle-symbolic-name=\"no.such.provider\";bundle-version=\"[1.1.1,1.1.1]\"";
+
+        Bundle exportBundle = makeBundleWithExports("no.such.provider",
+                "1.1.1", fakeExportsListNoExtras);
+        Dictionary headers = makeFragmentFromExportBundle(exportBundle)
+                .getHeaders();
+        assertEquals(
+                "Import list did not match expected value, expectedImportsListNoExtras",
+                expectedImportsListNoExtras, headers
+                        .get(Constants.IMPORT_PACKAGE));
+
+        exportBundle = makeBundleWithExports("no.such.provider", "1.1.1",
+                fakeExportsListAttrOnly);
+        headers = makeFragmentFromExportBundle(exportBundle).getHeaders();
+        assertEquals(
+                "Import list did not match expected value, expectedImportsListAttrOnly",
+                expectedImportsListAttrOnly, headers
+                        .get(Constants.IMPORT_PACKAGE));
+
+        exportBundle = makeBundleWithExports("no.such.provider", "1.1.1",
+                fakeExportsListDirOnly);
+        headers = makeFragmentFromExportBundle(exportBundle).getHeaders();
+        assertEquals(
+                "Import list did not match expected value, expectedImportsListDirOnly",
+                expectedImportsListDirOnly, headers
+                        .get(Constants.IMPORT_PACKAGE));
+
+        exportBundle = makeBundleWithExports("no.such.provider", "1.1.1",
+                fakeExportsListMixed);
+        headers = makeFragmentFromExportBundle(exportBundle).getHeaders();
+        assertEquals(
+                "Import list did not match expected value, expectedImportsListMixed",
+                expectedImportsListMixed, headers.get(Constants.IMPORT_PACKAGE));
+
+        exportBundle = makeBundleWithExports("no.such.provider", "1.1.1",
+                fakeExportsListFunkyAttr);
+        headers = makeFragmentFromExportBundle(exportBundle).getHeaders();
+        assertEquals(
+                "Import list did not match expected value, expectedImportsListFunkyAttr",
+                expectedImportsListFunkyAttr, headers
+                        .get(Constants.IMPORT_PACKAGE));
+    }
+
+}
diff --git a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/SingleServiceTrackerTest.java b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/SingleServiceTrackerTest.java
index e69de29b..6924239f 100644
--- a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/SingleServiceTrackerTest.java
+++ b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/SingleServiceTrackerTest.java
@@ -0,0 +1,88 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util;
+
+import org.apache.aries.mocks.BundleContextMock;
+import org.apache.aries.unittest.mocks.MethodCall;
+import org.apache.aries.unittest.mocks.Skeleton;
+import org.apache.aries.util.tracker.SingleServiceTracker;
+import org.apache.aries.util.tracker.SingleServiceTracker.SingleServiceListener;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.osgi.framework.BundleContext;
+
+import static org.junit.Assert.*;
+
+public class SingleServiceTrackerTest {
+  private BundleContext ctx;
+  private SingleServiceTracker<String> sut;
+  private SingleServiceTracker.SingleServiceListener listener;
+  
+  @Before
+  public void setup() {
+    ctx = Skeleton.newMock(new BundleContextMock(), BundleContext.class);
+  }
+  
+  @After
+  public void teardown() {
+    BundleContextMock.clear();
+  }
+  
+  private void createSut() {
+    listener = Skeleton.newMock(SingleServiceListener.class);
+    sut = new SingleServiceTracker<String>(ctx, String.class, listener);
+    sut.open();
+  }
+  
+  @Test
+  public void testAfterTheFactService() 
+  {
+    createSut();
+    Skeleton.getSkeleton(listener).assertSkeletonNotCalled();
+    
+    ctx.registerService("java.lang.String", "uno", null);
+    Skeleton.getSkeleton(listener).assertCalled(new MethodCall(SingleServiceListener.class, "serviceFound"));
+    
+    assertEquals("uno", sut.getService());
+  }
+  
+  @Test
+  public void testDoubleRegistration() {
+    testAfterTheFactService();
+    
+    Skeleton.getSkeleton(listener).clearMethodCalls();
+    ctx.registerService("java.lang.String", "due", null);
+    
+    Skeleton.getSkeleton(listener).assertSkeletonNotCalled();
+    assertEquals("uno", sut.getService());
+  }
+  
+  @Test
+  public void testRegistrationWhileClosed() {
+    createSut();
+    sut.close();
+    
+    ctx.registerService("java.lang.String", "uno", null);
+    Skeleton.getSkeleton(listener).assertSkeletonNotCalled();
+    
+    assertNull(sut.getService());
+  }
+  
+}
diff --git a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/VersionRangeTest.java b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/VersionRangeTest.java
index e69de29b..0184cd1f 100644
--- a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/VersionRangeTest.java
+++ b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/VersionRangeTest.java
@@ -0,0 +1,301 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.util;
+
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import org.junit.Test;
+import org.osgi.framework.Version;
+
+public class VersionRangeTest
+{
+  /**
+   * Test the version range created correctly
+   * @throws Exception
+   */
+  
+  @Test
+  public void testVersionRange() throws Exception {
+    String version1 = "[1.2.3, 4.5.6]";
+    String version2="(1, 2]";
+    String version3="[2,4)";
+    String version4="(1,2)";
+    String version5="2";
+    String version6 = "2.3";
+    String version7="[1.2.3.q, 2.3.4.p)";
+    String version8="1.2.2.5";
+    String version9="a.b.c";
+    String version10=null;
+    String version11="";
+    String version12="\"[1.2.3, 4.5.6]\"";
+    
+    VersionRange vr = new VersionRange(version1);
+    assertEquals("The value is wrong", "1.2.3", vr.getMinimumVersion().toString());
+    assertFalse("The value is wrong", vr.isMinimumExclusive());
+    assertEquals("The value is wrong", "4.5.6", vr.getMaximumVersion().toString());
+    assertFalse("The value is wrong", vr.isMaximumExclusive());
+    
+    vr = new VersionRange(version2);
+    assertEquals("The value is wrong", "1.0.0", vr.getMinimumVersion().toString());
+    assertTrue("The value is wrong", vr.isMinimumExclusive());
+    assertEquals("The value is wrong", "2.0.0", vr.getMaximumVersion().toString());
+    assertFalse("The value is wrong", vr.isMaximumExclusive());
+    
+    vr = new VersionRange(version3);
+    
+    assertEquals("The value is wrong", "2.0.0", vr.getMinimumVersion().toString());
+    assertFalse("The value is wrong", vr.isMinimumExclusive());
+    assertEquals("The value is wrong", "4.0.0", vr.getMaximumVersion().toString());
+    assertTrue("The value is wrong", vr.isMaximumExclusive());
+    
+    vr = new VersionRange(version4);
+    
+    assertEquals("The value is wrong", "1.0.0", vr.getMinimumVersion().toString());
+    assertTrue("The value is wrong", vr.isMinimumExclusive());
+    assertEquals("The value is wrong", "2.0.0", vr.getMaximumVersion().toString());
+    assertTrue("The value is wrong", vr.isMaximumExclusive());
+    
+    vr = new VersionRange(version5);
+    assertEquals("The value is wrong", "2.0.0", vr.getMinimumVersion().toString());
+    assertFalse("The value is wrong", vr.isMinimumExclusive());
+    assertNull("The value is wrong", vr.getMaximumVersion());
+    assertFalse("The value is wrong", vr.isMaximumExclusive());
+    
+    vr = new VersionRange(version6);
+    assertEquals("The value is wrong", "2.3.0", vr.getMinimumVersion().toString());
+    assertFalse("The value is wrong", vr.isMinimumExclusive());
+    assertNull("The value is wrong", vr.getMaximumVersion());
+    assertFalse("The value is wrong", vr.isMaximumExclusive());
+    
+    vr = new VersionRange(version7);
+    assertEquals("The value is wrong", "1.2.3.q", vr.getMinimumVersion().toString());
+    assertFalse("The value is wrong", vr.isMinimumExclusive());
+    assertEquals("The value is wrong", "2.3.4.p", vr.getMaximumVersion().toString());
+    assertTrue("The value is wrong", vr.isMaximumExclusive());
+    
+    vr = new VersionRange(version8);
+    assertEquals("The value is wrong", "1.2.2.5", vr.getMinimumVersion().toString());
+    assertFalse("The value is wrong", vr.isMinimumExclusive());
+    assertNull("The value is wrong", vr.getMaximumVersion());
+    assertFalse("The value is wrong", vr.isMaximumExclusive());
+    boolean exception = false;
+    try {
+    vr = new VersionRange(version9);
+    } catch (Exception e){
+      exception = true;
+    }
+    
+    assertTrue("The value is wrong", exception);
+    boolean exceptionNull = false;
+    try {
+      vr = new VersionRange(version10);
+    } catch (Exception e){
+      exceptionNull = true;
+    }
+    assertTrue("The value is wrong", exceptionNull);
+    // empty version should be defaulted to >=0.0.0
+    vr = new VersionRange(version11);
+    assertEquals("The value is wrong", "0.0.0", vr.getMinimumVersion().toString());
+    assertFalse("The value is wrong", vr.isMinimumExclusive());
+    assertNull("The value is wrong", vr.getMaximumVersion());
+    assertFalse("The value is wrong", vr.isMaximumExclusive());
+
+    vr = new VersionRange(version12);
+    assertEquals("The value is wrong", "1.2.3", vr.getMinimumVersion().toString());
+    assertFalse("The value is wrong", vr.isMinimumExclusive());
+    assertEquals("The value is wrong", "4.5.6", vr.getMaximumVersion().toString());
+    assertFalse("The value is wrong", vr.isMaximumExclusive());  
+  }
+  
+  @Test
+  public void testInvalidVersions() throws Exception
+  {
+    try {
+      new VersionRange("a");
+      assertTrue("Should have thrown an exception", false);
+    } catch (IllegalArgumentException e) {
+    }
+    
+    try {
+      new VersionRange("[1.0.0,1.0.1]", true);
+      assertTrue("Should have thrown an exception", false);
+    } catch (IllegalArgumentException e) {
+    }
+  }
+  
+  @Test
+  public void testExactVersion() throws Exception 
+  {
+    VersionRange vr;
+    try {
+      vr = new VersionRange("[1.0.0, 2.0.0]", true);
+      fail("from 1 to 2 not excludsive is not an exact range");
+    } catch (IllegalArgumentException e) {
+      // expected
+    }
+    
+    vr = new VersionRange("[1.0.0, 1.0.0]", true);
+    assertTrue(vr.isExactVersion());
+    
+    try {
+      vr = new VersionRange("(1.0.0, 1.0.0]", true);
+      fail("from 1 (not including 1) to 1, is not valid");
+    } catch (IllegalArgumentException e) {
+      // expected
+    }
+    
+    try {
+      vr = new VersionRange("[1.0.0, 1.0.0)", true);
+      fail("sfrom 1 to 1 (not including 1), is not valid");
+    } catch (IllegalArgumentException e) {
+      // expected
+    }
+
+    vr = new VersionRange("1.0.0", true);
+    assertTrue(vr.isExactVersion());
+
+    vr = new VersionRange("1.0.0", false);
+    assertFalse(vr.isExactVersion());
+
+    vr = new VersionRange("[1.0.0, 2.0.0]");
+    assertFalse(vr.isExactVersion());
+    
+    vr = new VersionRange("[1.0.0, 1.0.0]");
+    assertTrue(vr.isExactVersion());
+
+    vr = new VersionRange("1.0.0", true);
+    assertEquals(new Version("1.0.0"), vr.getMinimumVersion());
+    assertTrue(vr.isExactVersion());
+    
+    vr = new VersionRange("1.0.0", false);
+    assertEquals(new Version("1.0.0"), vr.getMinimumVersion());
+    assertNull(vr.getMaximumVersion());
+    assertFalse(vr.isExactVersion());
+    
+    // don't throw any silly exceptions
+    vr = new VersionRange("[1.0.0,2.0.0)", false);
+    assertFalse(vr.isExactVersion());
+    
+    vr = new VersionRange("[1.0.0, 2.0.0]");
+    assertFalse(vr.isExactVersion());
+
+    vr = new VersionRange("[1.0.0, 1.0.0]");
+    assertTrue(vr.isExactVersion());
+
+  }
+  
+  @Test
+  public void testMatches()
+  {
+    VersionRange vr = new VersionRange("[1.0.0, 2.0.0]");
+    
+    assertFalse(vr.matches(new Version(0,9,0)));
+    assertFalse(vr.matches(new Version(2,1,0)));
+    assertTrue(vr.matches(new Version(2,0,0)));
+    assertTrue(vr.matches(new Version(1,0,0)));
+    assertTrue(vr.matches(new Version(1,5,0)));
+    
+    vr = new VersionRange("[1.0.0, 2.0.0)");
+    
+    assertFalse(vr.matches(new Version(0,9,0)));
+    assertFalse(vr.matches(new Version(2,1,0)));
+    assertFalse(vr.matches(new Version(2,0,0)));
+    assertTrue(vr.matches(new Version(1,0,0)));
+    assertTrue(vr.matches(new Version(1,5,0)));
+
+    vr = new VersionRange("(1.0.0, 2.0.0)");
+    
+    assertFalse(vr.matches(new Version(0,9,0)));
+    assertFalse(vr.matches(new Version(2,1,0)));
+    assertFalse(vr.matches(new Version(2,0,0)));
+    assertFalse(vr.matches(new Version(1,0,0)));
+    assertTrue(vr.matches(new Version(1,5,0)));
+
+    vr = new VersionRange("[1.0.0, 1.0.0]");
+    assertFalse(vr.matches(new Version(0,9,0)));
+    assertFalse(vr.matches(new Version(2,0,0)));
+    assertTrue(vr.matches(new Version(1,0,0)));
+    assertFalse(vr.matches(new Version(1,5,0)));
+    assertFalse(vr.matches(new Version(1,9,9)));
+  }
+  
+  @Test
+  public void testIntersectVersionRange_Valid1()
+  {
+    VersionRange v1 = new VersionRange("[1.0.0,3.0.0]");
+    VersionRange v2 = new VersionRange("[2.0.0,3.0.0)");
+    VersionRange result = v1.intersect(v2);
+    assertNotNull(result);
+    assertEquals("[2.0.0,3.0.0)", result.toString());
+  }
+  
+  @Test
+  public void testIntersectVersionRange_Valid2()
+  {
+    VersionRange v1 = new VersionRange("[1.0.0,3.0.0)");
+    VersionRange v2 = new VersionRange("(2.0.0,3.0.0]");
+    VersionRange result = v1.intersect(v2);
+    assertNotNull(result);
+    assertEquals("(2.0.0,3.0.0)", result.toString());
+  }
+
+  @Test
+  public void testIntersectVersionRange_Valid3()
+  {
+    VersionRange v1 = new VersionRange("[2.0.0,2.0.0]");
+    VersionRange v2 = new VersionRange("[1.0.0,3.0.0]");
+    VersionRange result = v1.intersect(v2);
+    assertNotNull(result);
+    assertEquals("[2.0.0,2.0.0]", result.toString());
+  }
+  
+  @Test
+  public void testIntersectVersionRange_Invalid1()
+  {
+    VersionRange v1 = new VersionRange("[1.0.0,2.0.0]");
+    VersionRange v2 = new VersionRange("(2.0.0,3.0.0]");
+    VersionRange result = v1.intersect(v2);
+    assertNull(result);
+  }
+
+  @Test
+  public void testIntersectVersionRange_Invalid2()
+  {
+    VersionRange v1 = new VersionRange("[1.0.0,2.0.0)");
+    VersionRange v2 = new VersionRange("[2.0.0,3.0.0]");
+    VersionRange result = v1.intersect(v2);
+    assertNull(result);
+  }
+
+  @Test
+  public void testIntersectVersionRange_Invalid3()
+  {
+    VersionRange v1 = new VersionRange("[1.0.0,1.0.0]");
+    VersionRange v2 = new VersionRange("[2.0.0,2.0.0]");
+    VersionRange result = v1.intersect(v2);
+    assertNull(result);
+  }
+
+}
diff --git a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/filesystem/FileSystemTest.java b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/filesystem/FileSystemTest.java
index e69de29b..ad636d48 100644
--- a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/filesystem/FileSystemTest.java
+++ b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/filesystem/FileSystemTest.java
@@ -0,0 +1,515 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.filesystem;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.reflect.Field;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.jar.Manifest;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipOutputStream;
+
+import org.apache.aries.unittest.junit.Assert;
+import org.apache.aries.util.io.IOUtils;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+
+/**
+ * This class contains tests for the virtual file system.
+ */
+public class FileSystemTest
+{
+  /**
+   * Make sure we correctly understand the content of the application when the
+   * application is an exploded directory. This test just checks that the
+   * root directory returns the expected information.
+   * 
+   * @throws IOException
+   */
+  @Test(expected=UnsupportedOperationException.class)
+  public void basicRootDirTestsWithFiles() throws IOException
+  {
+    File baseDir = new File(getTestResourceDir(), "/app1");
+    File manifest = new File(baseDir, "META-INF/APPLICATION.MF");
+    IDirectory dir = FileSystem.getFSRoot(baseDir);
+    
+    runBasicRootDirTests(dir, baseDir.length(), manifest.lastModified());
+  }
+  
+  /**
+   * Make sure we correctly understand the directory structure for exploded
+   * directories.
+   * 
+   * @throws IOException
+   */
+  @Test
+  public void basicDirTestsWithFiles() throws IOException
+  {
+    File baseDir = new File(getTestResourceDir(), "/app1");
+    IDirectory dir = FileSystem.getFSRoot(baseDir);
+
+    File desiredFile = new File(baseDir, "META-INF/APPLICATION.MF");
+    
+    runBasicDirTest(dir, desiredFile.length(), desiredFile.lastModified());
+    runBasicDirTest(dir.toCloseable(), desiredFile.length(), desiredFile.lastModified());
+  }
+  
+  /**
+   * Make sure we correctly understand the content of the application when the
+   * application is a zip. This test just checks that the
+   * root directory returns the expected information.
+   * 
+   * @throws IOException
+   */
+  @Test(expected=UnsupportedOperationException.class)
+  public void basicRootDirTestsWithZip() throws IOException
+  {
+    File baseDir = new File("fileSystemTest/app2.zip");
+    IDirectory dir = FileSystem.getFSRoot(baseDir);
+    
+    runBasicRootDirTests(dir, baseDir.length(), baseDir.lastModified());
+  }
+  
+  /**
+   * Make sure we correctly understand the content of the application when the
+   * application is a zip. This test just checks that the
+   * root directory returns the expected information.
+   * 
+   * @throws IOException
+   */
+  @Test(expected=UnsupportedOperationException.class)
+  public void basicRootDirTestsWithZipInputStream() throws IOException
+  {
+    File baseDir = new File("fileSystemTest/app2.zip");
+    ICloseableDirectory dir = FileSystem.getFSRoot(new FileInputStream(baseDir));
+    
+    try {
+      runBasicRootDirTests(dir, baseDir.length(), baseDir.lastModified());
+    } finally {
+      dir.close();
+    }
+  }
+  
+  @Test
+  public void testInvalidFSRoot() throws IOException
+  {
+	  File baseDir = new File(getTestResourceDir(), "/app1");
+	  File manifest = new File(baseDir, "META-INF/APPLICATION.MF");
+	  IDirectory dir = FileSystem.getFSRoot(manifest);
+	  
+	  assertNull(dir);
+  }
+  
+  /**
+   * Make sure that operations work on zip files nested in file IDirectories
+   * @throws IOException
+   */
+  @Test
+  public void nestedZipInDirectory() throws IOException
+  {
+	IDirectory dir = FileSystem.getFSRoot(new File("").getAbsoluteFile());  
+	
+	// base convert does not do nested zips
+	IDirectory zip = dir.getFile("fileSystemTest/app2.zip").convert();
+	assertNull(zip);
+	
+	// basic conversion works
+	zip = dir.getFile("fileSystemTest/app2.zip").convertNested();
+	assertNotNull(zip);
+	
+	// we get the parent and our path right
+	assertNotNull(zip.getParent());
+	assertEquals("fileSystemTest", zip.getParent().getName());
+	assertEquals("fileSystemTest/app2.zip", zip.getName());
+	
+	// files inside the nested zip have the correct path as well
+	IFile appMf = zip.getFile("META-INF/APPLICATION.MF");
+	assertNotNull(appMf);
+	assertEquals("fileSystemTest/app2.zip/META-INF/APPLICATION.MF", appMf.getName());
+	checkManifest(appMf.open());
+
+	// root is right
+	assertFalse(zip.isRoot());
+	assertEquals(dir, zip.getRoot());
+	assertEquals(dir, appMf.getRoot());	
+	
+	// check URLs are correct
+	checkManifest(appMf.toURL().openStream());
+	
+	runBasicDirTest(zip, "fileSystemTest/app2.zip/", appMf.getSize(), appMf.getLastModified());
+  }
+  
+  /**
+   * Make sure that the operations work with zip files inside other zip files. Performance is not going to be great though :)
+   */
+  @Test
+  public void nestedZipInZip() throws IOException
+  {
+	  IDirectory outer = FileSystem.getFSRoot(new File("fileSystemTest/outer.zip"));
+	  
+	  IFile innerFile = outer.getFile("app2.zip");
+	  assertNotNull(innerFile);
+
+	  IDirectory inner = innerFile.convertNested();
+	  assertNotNull(inner);
+	  
+	  File desiredFile = new File(new File(getTestResourceDir(), "/app1"), "META-INF/APPLICATION.MF");  
+	  
+	  // no size information when stream reading :(
+	  runBasicDirTest(inner, "app2.zip/", -1, desiredFile.lastModified());
+	  runBasicDirTest(inner.toCloseable(), "app2.zip/", desiredFile.length(), desiredFile.lastModified());
+  }
+  
+  /**
+   * Make sure that the operations work with zip files inside other zip files. Performance is not going to be great though :)
+   */
+  @Test
+  public void nestedZipInZipInputStream() throws Exception
+  {
+    ICloseableDirectory outer = FileSystem.getFSRoot(new FileInputStream("fileSystemTest/outer.zip"));
+    try {
+      IFile innerFile = outer.getFile("app2.zip");
+      assertNotNull(innerFile);
+
+      IDirectory inner = innerFile.convertNested();
+      assertNotNull(inner);
+      
+      File desiredFile = new File(new File(getTestResourceDir(), "/app1"), "META-INF/APPLICATION.MF");  
+      
+      // no size information when stream reading :(
+      runBasicDirTest(inner, "app2.zip/", -1, desiredFile.lastModified());
+      runBasicDirTest(inner.toCloseable(), "app2.zip/", desiredFile.length(), desiredFile.lastModified());
+    } finally {
+      outer.close();
+      
+      Field f = outer.getClass().getDeclaredField("tempFile");
+      
+      f.setAccessible(true);
+      assertFalse(((File)f.get(outer)).exists());
+    }
+  }
+  
+  /**
+   * Make sure we correctly understand the directory structure for zips.
+   * 
+   * @throws IOException
+   */
+  @Test
+  public void basicDirTestsWithZip() throws IOException
+  {
+    File baseDir = new File("fileSystemTest/app2.zip");
+    IDirectory dir = FileSystem.getFSRoot(baseDir);
+
+    assertTrue(dir.toString(), dir.toString().endsWith("app2.zip"));
+    
+    File desiredFile = new File(new File(getTestResourceDir(), "/app1"), "META-INF/APPLICATION.MF");
+    
+    runBasicDirTest(dir, desiredFile.length(), desiredFile.lastModified());
+    runBasicDirTest(dir.toCloseable(), desiredFile.length(), desiredFile.lastModified());
+  }
+  
+  /**
+   * Make sure we correctly understand the directory structure for zips.
+   * 
+   * @throws IOException
+   */
+  @Test
+  public void basicDirTestsWithZipInputStream() throws IOException
+  {
+    File baseDir = new File("fileSystemTest/app2.zip");
+    ICloseableDirectory dir = FileSystem.getFSRoot(new FileInputStream(baseDir));
+
+    try {
+      File desiredFile = new File(new File(getTestResourceDir(), "/app1"), "META-INF/APPLICATION.MF");
+    
+      runBasicDirTest(dir, desiredFile.length(), desiredFile.lastModified());
+      runBasicDirTest(dir.toCloseable(), desiredFile.length(), desiredFile.lastModified());
+    } finally {
+      dir.close();
+    }
+  }
+  
+  @Test
+  public void zipCloseableZipSimplePerformanceTest() throws IOException
+  {
+	  int N = 100000;
+	  File baseDir = new File("fileSystemTest/app2.zip");
+
+	  ZipFile zip = new ZipFile(baseDir);	  
+	  
+	  long start = System.currentTimeMillis();
+	  for (int i=0; i<N; i++) {
+		  ZipEntry ze = zip.getEntry("META-INF/APPLICATION.MF");
+		  InputStream is = zip.getInputStream(ze);
+		  is.close();
+	  }
+	  long duration = System.currentTimeMillis() - start;
+
+	  
+	  // normal zip files 
+	  
+	  ICloseableDirectory dir = FileSystem.getFSRoot(baseDir).toCloseable();
+
+	  start = System.currentTimeMillis();
+	  for (int i=0; i<N; i++) {
+		  IFile appMf = dir.getFile("META-INF/APPLICATION.MF");
+		  InputStream is = appMf.open();
+		  is.close();
+	  }
+	  long duration2 = System.currentTimeMillis() - start;
+	  
+	  dir.close();
+	  // within an order of magnitude
+	  assertTrue("ZipFile: "+duration+", IDirectory: "+duration2 , duration2 < 10*duration );
+	  
+	  
+	  // nested zip files
+	  
+	  IDirectory outer = FileSystem.getFSRoot(new File("fileSystemTest/outer.zip"));
+	  IFile innerFile = outer.getFile("app2.zip");
+	  dir = innerFile.convertNested().toCloseable();
+	  
+	  start = System.currentTimeMillis();
+	  for (int i=0; i<N; i++) {
+		  IFile appMf = dir.getFile("META-INF/APPLICATION.MF");
+		  InputStream is = appMf.open();
+		  is.close();
+	  }
+	  long duration3 = System.currentTimeMillis() - start;
+	  
+	  dir.close();
+	  // within an order of magnitude
+	  assertTrue("ZipFile: "+duration+", IDirectory: "+duration3 , duration3 < 10*duration );
+	  
+  }
+  
+  /**
+   * Zip up the app1 directory to create a zippped version before running any
+   * tests.
+   * 
+   * @throws IOException
+   */
+  @BeforeClass
+  public static void makeZip() throws IOException
+  {
+    File zipFile = new File("fileSystemTest/app2.zip");
+    zipFile.getParentFile().mkdirs();
+    ZipOutputStream out = new ZipOutputStream(new FileOutputStream(zipFile));
+
+    int index = new File(getTestResourceDir(), "/app1").getAbsolutePath().length();    
+    writeEnties(out, new File(getTestResourceDir(), "/app1"), index);
+
+    out.close();
+    
+    zipFile = new File("outer.zip");
+    out = new ZipOutputStream(new FileOutputStream(zipFile));
+    index = new File("fileSystemTest").getAbsolutePath().length();    
+    writeEnties(out, new File("fileSystemTest"), index);
+
+    out.close();
+    
+    if (!!!zipFile.renameTo(new File("fileSystemTest/outer.zip"))) throw new IOException("Rename failed");
+  }
+  
+  private static File getTestResourceDir() {
+	  File root = new File("").getAbsoluteFile();
+	  
+	  if (root.getName().equals("target")) return new File("../src/test/resources");
+	  else return new File("src/test/resources");
+  }
+  
+  /**
+   * Make sure the test zip is deleted afterwards.
+   */
+  @AfterClass
+  public static void destroyZip()
+  {
+	  IOUtils.deleteRecursive(new File("fileSystemTest"));
+  }
+  
+  /**
+   * This method writes the given directory into the provided zip output stream.
+   * It removes the first <code>index</code> bytes from the absolute path name
+   * when building the zip.
+   * 
+   * @param zos   the zip output stream to use
+   * @param f     the directory to write into the zip.
+   * @param index how much of the file name to chop off.
+   * @throws IOException
+   */
+  public static void writeEnties(ZipOutputStream zos, File f, int index) throws IOException {
+    File[] files = f.listFiles();
+    
+    if (files != null) {
+      for (File file : files) {
+        String fileName = file.getAbsolutePath().substring(index + 1);
+        
+     // Bug 1954: replace any '\' characters with '/' - required by ZipEntry
+        fileName = fileName.replace('\\', '/');
+        
+        if (file.isDirectory()) fileName = fileName + "/";
+        
+        ZipEntry ze = new ZipEntry(fileName);
+        ze.setSize(file.length());
+        ze.setTime(file.lastModified());
+        zos.putNextEntry(ze);
+        
+        if (file.isFile()) {
+          InputStream is = new FileInputStream(file);
+          byte[] buffer = new byte[(int)file.length()];
+          int len = is.read(buffer);
+          zos.write(buffer, 0, len);
+          is.close();   // Bug 1594
+        }
+
+        zos.closeEntry();
+        
+        if (file.isDirectory()) {
+          writeEnties(zos, file, index);
+        }
+      }
+    }
+  }
+  
+  /**
+   * This method makes sure that the data is correctly understood from disk. It
+   * is called for both the file and zip versions of the test to ensure we have
+   * consistent results.
+   * 
+   * @param dir   The IDirectory for the root of the vFS.
+   * @param len   The size of the file.
+   * @param time  The time the file was last updated.
+   * @throws IOException
+   */
+  public void runBasicRootDirTests(IDirectory dir, long len, long time) throws IOException
+  {
+    assertEquals("The root file system name is not correct", "", dir.getName());
+    assertEquals("The size of the file is not correct", len, dir.getSize());
+    
+    // This assertion just isn't working on Hudson as of build #79
+    // assertEquals("The last modified time of the file is not correct", time, dir.getLastModified());
+    
+    assertNull("I managed to get a parent of a root", dir.getParent());
+    assertTrue("The root dir does not know it is a dir", dir.isDirectory());
+    assertFalse("The root dir has an identity crisis and thinks it is a file", dir.isFile());
+
+    dir.open();
+  }
+  
+  private void runBasicDirTest(IDirectory dir, long len, long time) throws IOException
+  {
+	  runBasicDirTest(dir, "", len, time);
+  }
+  
+  /**
+   * This method makes sure that the data is correctly understood from disk. It
+   * is called for both the file and zip versions of the test to ensure we have
+   * consistent results.
+   * 
+   * @param dir   The IDirectory for the root of the vFS.
+   * @param len   The size of the file.
+   * @param time  The time the file was last updated.
+   * @throws IOException
+   */
+  private void runBasicDirTest(IDirectory dir, String namePrefix, long len, long time) throws IOException
+  {
+    assertNull("for some reason our fake app has a fake blueprint file.", dir.getFile("OSGI-INF/blueprint/aries.xml"));
+    
+    IFile file = dir.getFile("META-INF/APPLICATION.MF");
+    
+    assertNotNull("we could not find the application manifest", file);
+    
+    assertNull(file.convert());
+    assertNull(file.convertNested());
+    
+    assertEquals(namePrefix+"META-INF/APPLICATION.MF", file.getName().replace('\\', '/'));
+    assertTrue("The last update time is not within 2 seconds of the expected value. Expected: " + time + " Actual: " + file.getLastModified(), Math.abs(time - file.getLastModified()) < 2000);
+
+    assertEquals(len, file.getSize());
+    assertEquals(namePrefix+"META-INF", file.getParent().getName());
+    assertFalse(file.isDirectory());
+    assertTrue(file.isFile());
+    
+    List<IFile> files = dir.listFiles();
+    filterOutSvn(files);
+    assertEquals(1, files.size());
+
+    List<IFile> allFiles = dir.listAllFiles();
+    filterOutSvn(allFiles);    
+    assertEquals(3, allFiles.size());
+    
+    assertEquals(namePrefix+"META-INF", allFiles.get(1).getParent().getName());
+    
+    IFile metaInf = files.get(0);
+    
+    assertTrue(metaInf.isDirectory());
+    assertEquals(namePrefix+"META-INF", metaInf.getName());
+    assertNotNull(metaInf.convert());
+    
+    files = metaInf.convert().listAllFiles();
+    filterOutSvn(files);
+    assertEquals(2, files.size());    
+    
+    for (IFile aFile : dir) {
+      if (!aFile.getName().contains(".svn")) { 
+        assertTrue(aFile.isDirectory());
+        assertEquals(namePrefix+"META-INF", aFile.getName());
+        assertNotNull(aFile.convert());
+      }
+    }
+
+    checkManifest(file.open());
+        
+    IFile applicationMF2 = dir.getFile("META-INF/APPLICATION.MF");
+    
+    Assert.assertEqualsContract(file, applicationMF2, dir);
+    Assert.assertHashCodeEquals(file, applicationMF2, true);
+  }
+  
+  private void filterOutSvn(Collection<IFile> files) {
+	  Iterator<IFile> its = files.iterator();
+	  while (its.hasNext()) {
+		  IFile f = its.next();
+		  if (f.getName().toLowerCase().contains(".svn")) its.remove();
+	  }
+  }
+  
+  private void checkManifest(InputStream is) throws IOException {
+	  Manifest man = new Manifest(is);
+	  //remember to close the input stream after use
+	  is.close();
+	  assertEquals("com.travel.reservation", man.getMainAttributes().getValue("Application-SymbolicName"));	  
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/filesystem/FileUtilsTest.java b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/filesystem/FileUtilsTest.java
index e69de29b..e435f66f 100644
--- a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/filesystem/FileUtilsTest.java
+++ b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/filesystem/FileUtilsTest.java
@@ -0,0 +1,113 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.filesystem;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.StringBufferInputStream;
+import java.net.URI;
+import java.util.List;
+
+import org.apache.aries.unittest.fixture.ArchiveFixture;
+import org.apache.aries.unittest.fixture.ArchiveFixture.ZipFixture;
+import org.apache.aries.util.filesystem.FileUtils;
+import org.apache.aries.util.io.IOUtils;
+import org.junit.Test;
+import org.osgi.framework.Constants;
+
+
+/**
+ * This class contains tests for the virtual file system.
+ */
+public class FileUtilsTest
+{
+
+
+  /**
+   * Make sure we get the bundles files recursively regardless of the file extension.
+   * @throws IOException
+   */
+
+  @SuppressWarnings("deprecation")
+  @Test
+  public void testGetBundlesRecursive() throws IOException {
+    File tmpDir = new File("../src/test/resources/tmpJars");
+    tmpDir.mkdirs();
+    for (int n =0; n< 2; n++) {
+      ZipFixture bundle = ArchiveFixture.newJar().manifest()
+      .attribute(Constants.BUNDLE_SYMBOLICNAME, "aa" + n)
+      .attribute(Constants.BUNDLE_MANIFESTVERSION, "2")
+      .attribute(Constants.IMPORT_PACKAGE, "a.b.c, p.q.r, x.y.z, javax.naming")
+      .attribute(Constants.BUNDLE_VERSION, "1.0.0").end();
+      FileOutputStream fout = new FileOutputStream(new File (tmpDir.getAbsoluteFile(), "aa" + n + ((n == 0)? ".jar": ".war")));
+      bundle.writeOut(fout);
+      fout.close();
+    }
+    File subDir = new File(tmpDir, "subDir");
+    subDir.mkdirs();
+    for (int n =0; n< 2; n++) {
+      ZipFixture bundle = ArchiveFixture.newJar().manifest()
+      .attribute(Constants.BUNDLE_SYMBOLICNAME, "aa" + n)
+      .attribute(Constants.BUNDLE_MANIFESTVERSION, "2")
+      .attribute(Constants.IMPORT_PACKAGE, "a.b.c, p.q.r, x.y.z, javax.naming")
+      .attribute(Constants.BUNDLE_VERSION, "1.0.0").end();
+
+
+
+      FileOutputStream fout = new FileOutputStream(new File (subDir.getAbsoluteFile(), "aa" + n + ((n == 0)? ".jar": ".war")));
+      bundle.writeOut(fout);
+      fout.close();
+    }
+
+    for (int n =0; n< 2; n++) {
+      ZipFixture bundle = ArchiveFixture.newJar().manifest()
+      .attribute(Constants.BUNDLE_MANIFESTVERSION, "2")
+      .attribute(Constants.IMPORT_PACKAGE, "a.b.c, p.q.r, x.y.z, javax.naming")
+      .attribute(Constants.BUNDLE_VERSION, "1.0.0").end();
+
+
+      FileOutputStream fout = new FileOutputStream(new File (tmpDir, "bb" + n + ".jar"));
+      bundle.writeOut(fout);
+      fout.close();
+    }
+
+    IOUtils.writeOut(tmpDir, "simple.jar", new StringBufferInputStream("abc"));
+    IOUtils.writeOut(tmpDir, "simple.war", new StringBufferInputStream("sss"));
+    IOUtils.writeOut(tmpDir, "simple.txt", new StringBufferInputStream("abc"));
+    IOUtils.writeOut(tmpDir, "some/relative/directory/complex.jar", new StringBufferInputStream("def"));
+    IOUtils.writeOut(tmpDir, "some/relative/directory/aa/complex2.war", new StringBufferInputStream("ghi"));
+    IOUtils.writeOut(tmpDir, "simple", new StringBufferInputStream("abc"));
+
+    List<URI> jarFiles = FileUtils.getBundlesRecursive(tmpDir.toURI());
+    assertEquals("There should be 4 entries.", 4, jarFiles.size());
+    assertTrue("The entry should contain this aa0.jar", jarFiles.contains(new File(tmpDir, "aa0.jar").toURI()));
+    assertTrue("The entry should contain this aa1.war", jarFiles.contains(new File(tmpDir, "aa1.war").toURI()));
+    assertTrue("The entry should contain this aa0.jar", jarFiles.contains(new File(subDir, "aa0.jar").toURI()));
+    assertTrue("The entry should contain this aa1.war", jarFiles.contains(new File(subDir, "aa1.war").toURI()));
+
+    IOUtils.deleteRecursive(tmpDir);
+  }
+
+
+}
diff --git a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/filesystem/IOUtilsTest.java b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/filesystem/IOUtilsTest.java
index e69de29b..0a8afbbe 100644
--- a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/filesystem/IOUtilsTest.java
+++ b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/filesystem/IOUtilsTest.java
@@ -0,0 +1,233 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.filesystem;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.StringBufferInputStream;
+import java.util.zip.ZipFile;
+
+import org.apache.aries.util.filesystem.FileSystem;
+import org.apache.aries.util.filesystem.IDirectory;
+import org.apache.aries.util.filesystem.IFile;
+import org.apache.aries.util.io.IOUtils;
+import org.junit.AfterClass;
+import org.junit.Test;
+
+public class IOUtilsTest
+{
+  @AfterClass
+  public static void cleanUp()
+  {
+    new File("ioUtilsTest/test.zip").delete();
+    IOUtils.deleteRecursive(new File("ioUtilsTest"));
+  }
+  
+  @Test
+  public void testZipUpAndUnzipAndDeleteRecursive() throws IOException
+  {
+    new File ("ioUtilsTest").mkdir();
+    IOUtils.zipUp(new File("../src/test/resources/zip"), new File("ioUtilsTest/test.zip"));
+    
+    ZipFile zip = new ZipFile("ioUtilsTest/test.zip");
+    assertNotNull(zip.getEntry("file.txt"));
+    assertNotNull(zip.getEntry("subdir/someFile.txt"));
+    zip.close();
+    
+    IDirectory dir = FileSystem.getFSRoot(new File("ioUtilsTest"));
+    IFile izip = dir.getFile("test.zip");
+    File output = new File("ioUtilsTest/zipout");
+    output.mkdirs();
+    IOUtils.unpackZip(izip, output);
+    File a = new File(output,"file.txt");
+    File b = new File(output,"subdir");
+    File c = new File(b,"someFile.txt");
+    assertTrue(output.exists());
+    assertTrue(a.exists() && a.isFile());
+    assertTrue(b.exists() && b.isDirectory());
+    assertTrue(c.exists() && c.isFile());
+    
+    IOUtils.deleteRecursive(output);
+    assertFalse(output.exists());
+  }
+  
+  @Test
+  public void testWriteOut() throws IOException
+  {
+    File tmpDir = new File("ioUtilsTest/tmp");
+    tmpDir.mkdir();
+    
+    IOUtils.writeOut(tmpDir, "simple.txt", new StringBufferInputStream("abc"));
+    IOUtils.writeOut(tmpDir, "some/relative/directory/complex.txt", new StringBufferInputStream("def"));
+    IOUtils.writeOut(tmpDir, "some/relative/directory/complex2.txt", new StringBufferInputStream("ghi"));
+    
+    File simple = new File("ioUtilsTest/tmp/simple.txt");
+    assertTrue(simple.exists());
+
+    File complex = new File("ioUtilsTest/tmp/some/relative/directory/complex.txt");
+    assertTrue(complex.exists());
+
+    File complex2 = new File("ioUtilsTest/tmp/some/relative/directory/complex2.txt");
+    assertTrue(complex2.exists());
+    
+    BufferedReader r = new BufferedReader(new FileReader(simple));
+    assertEquals("abc", r.readLine());
+    assertNull(r.readLine());
+    r.close();
+    
+    r = new BufferedReader(new FileReader(complex));
+    assertEquals("def", r.readLine());
+    assertNull(r.readLine());
+    r.close();
+
+    r = new BufferedReader(new FileReader(complex2));
+    assertEquals("ghi", r.readLine());
+    assertNull(r.readLine());
+    r.close();
+  }
+  
+  @Test 
+  public void testWriteOutAndDoNotCloseInputStream() throws IOException{
+    InputStream is = new InputStream(){
+      int idx=0;
+      int data[]=new int[]{1,2,3,4,5,-1};
+      @Override
+      public int read() throws IOException
+      {
+        if(idx<data.length)
+          return data[idx++];
+        else
+          return -1;
+      }
+      @Override
+      public void close() throws IOException
+      {
+        fail("Close was invoked");
+      }
+    };
+    File f = new File("ioUtilsTest/outtest1");
+    f.mkdirs();
+    IOUtils.writeOutAndDontCloseInputStream(f, "/fred", is);
+    File fred = new File(f,"/fred");
+    assertTrue(fred.exists());
+    File outtest = fred.getParentFile();
+    fred.delete();
+    outtest.delete();
+    
+  }
+  
+  @Test 
+  public void testCopy() throws IOException{
+    InputStream is = new InputStream(){
+      boolean closed=false;
+      int idx=0;
+      int data[]=new int[]{1,2,3,4,5,-1};
+      @Override
+      public int read() throws IOException
+      {
+        if(idx<data.length)
+          return data[idx++];
+        else
+          return -1;
+      }
+      @Override
+      public void close() throws IOException
+      {
+        closed=true;
+      }
+      @Override
+      public int available() throws IOException
+      {
+        if(!closed)
+          return super.available();
+        else
+          return 123456789;
+      }
+      
+    };
+    
+    OutputStream os = new OutputStream(){
+      int idx=0;
+      int data[]=new int[]{1,2,3,4,5,-1};
+      @Override
+      public void write(int b) throws IOException
+      {
+        if(b!=data[idx++]){
+          fail("Data written to outputstream was not as expected");
+        }
+      }
+    };
+    
+    IOUtils.copy(is,os);
+    if(is.available()!=123456789){
+      fail("close was not invoked");
+    }
+    
+    
+  }
+  
+  @Test
+  public void testCopyAndDoNotClose() throws IOException{
+    
+    InputStream is = new InputStream(){
+      int idx=0;
+      int data[]=new int[]{1,2,3,4,5,-1};
+      @Override
+      public int read() throws IOException
+      {
+        if(idx<data.length)
+          return data[idx++];
+        else
+          return -1;
+      }
+      @Override
+      public void close() throws IOException
+      {
+        fail("Close invoked");
+      }
+    };
+    
+    OutputStream os = new OutputStream(){
+      int idx=0;
+      int data[]=new int[]{1,2,3,4,5,-1};
+      @Override
+      public void write(int b) throws IOException
+      {
+        if(b!=data[idx++]){
+          fail("Data written to outputstream was not as expected");
+        }
+      }
+    };
+    
+    IOUtils.copyAndDoNotCloseInputStream(is,os);
+    
+  }
+}
diff --git a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/manifest/BundleManifestTest.java b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/manifest/BundleManifestTest.java
index e69de29b..cd6ac26e 100644
--- a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/manifest/BundleManifestTest.java
+++ b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/manifest/BundleManifestTest.java
@@ -0,0 +1,94 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.manifest;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.util.jar.JarInputStream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+import org.apache.aries.util.io.IOUtils;
+import org.apache.aries.util.manifest.BundleManifest;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class BundleManifestTest
+{
+  private static File _testfile;
+  
+  @BeforeClass
+  public static void setup() throws Exception
+  {
+    _testfile = new File ("./bundleManifestTest/nonExploded.jar");
+    _testfile.getParentFile().mkdirs();
+    
+    ZipOutputStream out = new ZipOutputStream(new FileOutputStream(_testfile));
+    ZipEntry ze = new ZipEntry("META-INF/");
+    out.putNextEntry(ze);
+    
+    File f = new File("../src/test/resources/bundles/exploded.jar/META-INF/beforeManifest.file");
+    ze = new ZipEntry("META-INF/beforeManifest.file");
+    ze.setSize(f.length());
+    out.putNextEntry(ze);
+    IOUtils.copy(new FileInputStream(f), out);
+    
+    f = new File("../src/test/resources/bundles/exploded.jar/META-INF/MANIFEST.MF");
+    ze = new ZipEntry("META-INF/MANIFEST.MF");
+    ze.setSize(f.length());
+    out.putNextEntry(ze);
+    IOUtils.copy(new FileInputStream(f), out);    
+    
+    out.close();
+  }
+  
+  @AfterClass
+  public static void cleanup()
+  {
+	  IOUtils.deleteRecursive(new File("bundleManifestTest/"));
+  }
+  
+  @Test
+  public void testExploded()
+  {
+    BundleManifest sut = BundleManifest.fromBundle(new File("../src/test/resources/bundles/exploded.jar"));
+    assertEquals("com.ibm.test", sut.getSymbolicName());
+    assertEquals("1.0.0", sut.getVersion().toString());
+  }
+  
+  @Test
+  public void testZip() throws Exception
+  {
+    // make sure that the manifest is not the first file in the jar archive
+    JarInputStream jarIs = new JarInputStream(new FileInputStream(_testfile));
+    assertNull(jarIs.getManifest());
+    jarIs.close();
+    
+    BundleManifest sut = BundleManifest.fromBundle(_testfile);
+    assertEquals("com.ibm.test", sut.getSymbolicName());
+    assertEquals("1.0.0", sut.getVersion().toString());
+  }
+}
+
diff --git a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/manifest/ManifestHeaderProcessorTest.java b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/manifest/ManifestHeaderProcessorTest.java
index e69de29b..09fc0fbb 100644
--- a/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/manifest/ManifestHeaderProcessorTest.java
+++ b/aries/trunk/util/util-r42/src/test/java/org/apache/aries/util/manifest/ManifestHeaderProcessorTest.java
@@ -0,0 +1,549 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.util.manifest;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.aries.util.VersionRange;
+import org.apache.aries.util.manifest.ManifestHeaderProcessor;
+import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValueMap;
+import org.apache.aries.util.manifest.ManifestHeaderProcessor.NameValuePair;
+import org.junit.Test;
+
+public class ManifestHeaderProcessorTest
+{
+  @Test
+  public void testNameValuePair() throws Exception {
+	HashMap<String, String> attrs = new HashMap<String, String>();
+	attrs.put("some", "value");
+    NameValuePair nvp = new NameValuePair("key", attrs);
+    
+    assertEquals("The name value pair is not set properly.", nvp.getName(), "key");
+    assertEquals("The value is not set properly.", nvp.getAttributes().get("some"), "value");
+    
+	attrs = new HashMap<String, String>();
+	attrs.put("some", "value");
+    NameValuePair anotherNvp = new NameValuePair("key", attrs);
+    assertEquals("The two objects of NameValuePair is not equal.", nvp, anotherNvp);
+
+    nvp.setName("newKey");
+    attrs = new HashMap<String, String>();
+	attrs.put("some", "newValue");
+    nvp.setAttributes(attrs);
+    assertEquals("The name value pair is not set properly.", nvp.getName(), "newKey");
+    assertEquals("The value is not set properly.", nvp.getAttributes().get("some"), "newValue");
+    
+    Map<String,String> nvm1 = new HashMap<String,String>();
+    nvm1.put("a","b");
+    nvm1.put("c","d");
+    
+    Map<String,String> nvm2 = new HashMap<String,String>();
+    nvm2.put("c","d");
+    nvm2.put("a","b");
+    assertEquals("The maps are not equal.", nvm1, nvm2);
+    nvm2.put("e","f");
+    assertNotSame("The maps are the same.", nvm1, nvm2);
+    
+    NameValuePair nvp1 = new NameValuePair("one",nvm1);
+    NameValuePair nvp2 = new NameValuePair("one",nvm2);
+    
+    assertNotSame("The pairs are identical ",nvp1,nvp2);
+    nvm1.put("e","f");
+    assertEquals("The pairs are not equal.", nvp1,nvp2);
+    
+    List<NameValuePair> bundleInfoList1 = new ArrayList<NameValuePair>();
+    bundleInfoList1.add(nvp1);
+
+    List<NameValuePair> bundleInfoList2 = new ArrayList<NameValuePair>();
+    bundleInfoList2.add(nvp1);
+    
+    bundleInfoList1.removeAll(bundleInfoList2);
+    assertEquals("The List should be empty", bundleInfoList1.isEmpty(), true);
+   
+   
+    assertNotSame("The two objects of NameValuePair is not equal.", nvp, anotherNvp);
+  }
+
+  
+  /**
+   * Test the Bundle manifest header entry of
+   * Bundle-SymbolicName: com.acme.foo;singleton:=true
+   */
+  @Test
+  public void testParseBundleSymbolicName() 
+  {
+    String bundleSymbolicNameEntry = "com.acme.foo;singleton:=true;fragment-attachment:=always";
+    NameValuePair nvp = ManifestHeaderProcessor.parseBundleSymbolicName(bundleSymbolicNameEntry);
+    assertEquals("The symbolic name is wrong.", nvp.getName(), "com.acme.foo");
+    assertEquals("The value is wrong.", "true", nvp.getAttributes().get("singleton:") );
+    assertEquals("The directive is wrong.", "always", nvp.getAttributes().get("fragment-attachment:") );
+  
+    String bundleSymbolicNameEntry2 = "com.acme.foo";
+    NameValuePair nvp2 = ManifestHeaderProcessor.parseBundleSymbolicName(bundleSymbolicNameEntry2);
+    assertEquals("The symbolic name is wrong.", nvp2.getName(), "com.acme.foo");
+  }
+  
+ 
+
+  /**
+   * Test the import package and import service
+   * Import-Package: com.acme.foo;come.acm,e.bar;version="[1.23,1.24.5]";resolution:=mandatory
+   */
+  @Test
+  public void testParseImportString()
+  {
+    String importPackage = "com.acme.foo,come.acm.e.bar;version=\"[1.23,1.24.5]\";resolution:=mandatory;company=\"ACME\",a.b.c;version=1.2.3;company=com";
+  
+    Map<String, Map<String, String>> importPackageReturn = ManifestHeaderProcessor.parseImportString(importPackage);
+  
+    assertTrue("The package is not set.", importPackageReturn.containsKey("com.acme.foo"));
+    assertTrue("The package is not set.", importPackageReturn.containsKey("come.acm.e.bar"));
+    assertTrue("The package is not set.", importPackageReturn.containsKey("come.acm.e.bar"));
+    assertTrue("The package is not set.", importPackageReturn.containsKey("a.b.c"));
+    assertTrue("The package should not contain any attributes.", importPackageReturn.get("com.acme.foo").isEmpty());
+    assertEquals("The directive is not set correctly.", "[1.23,1.24.5]", importPackageReturn.get("come.acm.e.bar").get("version"));
+    assertEquals("The directive is not set correctly.", "mandatory", importPackageReturn.get("come.acm.e.bar").get("resolution:"));
+    assertEquals("The directive is not set correctly.", "ACME", importPackageReturn.get("come.acm.e.bar").get("company"));
+    assertEquals("The directive is not set correctly.", "1.2.3", importPackageReturn.get("a.b.c").get("version"));
+    assertEquals("The directive is not set correctly.", "com", importPackageReturn.get("a.b.c").get("company"));
+    
+    importPackage="com.acme.foo";
+    
+    assertTrue("The package is not set.", importPackageReturn.containsKey("com.acme.foo"));
+    assertTrue("The package should not contain any attributes.", importPackageReturn.get("com.acme.foo").isEmpty());
+    
+    importPackage="com.acme.foo;com.acme.bar;version=2";
+    Map<String, Map<String, String>> importPackageReturn2 = ManifestHeaderProcessor.parseImportString(importPackage);
+    assertTrue("The package is not set.", importPackageReturn2.containsKey("com.acme.foo"));
+    assertTrue("The package is not set.", importPackageReturn2.containsKey("com.acme.bar"));
+    assertEquals("The directive is not set correctly.", "2", importPackageReturn2.get("com.acme.foo").get("version"));
+    assertEquals("The directive is not set correctly.", "2", importPackageReturn2.get("com.acme.bar").get("version"));
+  }
+  
+  @Test
+  public void testParseExportString()
+  {
+    String exportPackage = "com.acme.foo,com.acme.bar;version=1,com.acme.bar;version=2;uses:=\"a.b.c,d.e.f\";security=false;mandatory:=security";
+  
+    List<NameValuePair> exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
+    
+    int i =0;
+    assertEquals("The number of the packages is wrong.", 3, exportPackageReturn.size());
+    for (NameValuePair nvp : exportPackageReturn) {
+      if (nvp.getName().equals("com.acme.foo")) {
+        i++;
+        
+        assertTrue("The directive or attribute should not be set.", nvp.getAttributes().isEmpty() );
+      } else if ((nvp.getName().equals("com.acme.bar")) && ("2".equals(nvp.getAttributes().get("version")))) {
+      
+        
+        i++;
+        assertEquals("The directive is wrong.", "a.b.c,d.e.f", nvp.getAttributes().get("uses:"));
+        assertEquals("The directive is wrong.", "false", nvp.getAttributes().get("security"));
+        assertEquals("The directive is wrong.", "security", nvp.getAttributes().get("mandatory:"));
+      } else if ((nvp.getName().equals("com.acme.bar")) && ("1".equals(nvp.getAttributes().get("version")))) {
+        i++;
+        
+        assertNull("The directive is wrong.", nvp.getAttributes().get("uses:"));
+        assertNull("The directive is wrong.", nvp.getAttributes().get("security"));
+        assertNull("The directive is wrong.", nvp.getAttributes().get("mandatory:"));
+      }
+    }
+    // make sure all three packages stored
+    assertEquals("The names of the packages are wrong.", 3, i);
+    
+    exportPackage = "com.acme.foo";
+    
+    exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
+    
+    int k =0;
+    assertEquals("The number of the packages is wrong.", 1, exportPackageReturn.size());
+    for (NameValuePair nvp : exportPackageReturn) {
+      if (nvp.getName().equals("com.acme.foo")) {
+        k++;
+        
+        assertTrue("The directive or attribute should not be set.", nvp.getAttributes().isEmpty() );
+      } 
+    }
+    assertEquals("The names of the packages are wrong.", 1, k);
+    
+    // test multiple packages separated by ;
+    
+    exportPackage = "com.acme.foo;com.acme.bar;version=\"2\";resolution:=optional";
+    
+    exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
+    
+    k =0;
+    assertEquals("The number of the packages is wrong.", 2, exportPackageReturn.size());
+    for (NameValuePair nvp : exportPackageReturn) {
+      if (nvp.getName().equals("com.acme.foo")) {
+        k++;
+        
+        assertEquals("The attribute is wrong.", "2", nvp.getAttributes().get("version") );
+        assertEquals("The attribute is wrong.", "optional", nvp.getAttributes().get("resolution:"));
+      } else if (nvp.getName().equals("com.acme.bar")) {
+        k++;
+        
+        assertEquals("The attribute is wrong.", "2", nvp.getAttributes().get("version") );
+        assertEquals("The attribute is wrong.", "optional", nvp.getAttributes().get("resolution:"));
+      }
+    }
+    assertEquals("The names of the packages are wrong.", 2, k);
+    
+    exportPackageReturn = ManifestHeaderProcessor.parseExportString("some.export.with.space.in;directive := spacey");
+    assertEquals(exportPackageReturn.toString(), "spacey", exportPackageReturn.get(0).getAttributes().get("directive:"));
+  }
+    
+    @Test
+    public void testExportMandatoryAttributes() {
+      String exportPackage = "com.acme.foo,com.acme.bar;version=2;company=dodo;security=false;mandatory:=\"security,company\"";
+      
+      List<NameValuePair> exportPackageReturn = ManifestHeaderProcessor.parseExportString(exportPackage);
+      
+      int i =0;
+      assertEquals("The number of the packages is wrong.", 2, exportPackageReturn.size());
+      for (NameValuePair nvp : exportPackageReturn) {
+        if (nvp.getName().equals("com.acme.foo")) {
+          i++;
+          
+          assertTrue("The directive or attribute should not be set.", nvp.getAttributes().isEmpty() );
+        } else if ((nvp.getName().equals("com.acme.bar")) && ("2".equals(nvp.getAttributes().get("version")))) {
+        
+          
+          i++;
+          assertEquals("The directive is wrong.", "dodo", nvp.getAttributes().get("company"));
+          assertEquals("The directive is wrong.", "false", nvp.getAttributes().get("security"));
+          assertEquals("The directive is wrong.", "security,company", nvp.getAttributes().get("mandatory:"));
+        } 
+      }
+      // make sure all three packages stored
+      assertEquals("The names of the packages are wrong.", 2, i);
+      
+    }
+    
+    private String createExpectedFilter(Map<String, String> values, String ... parts)
+    {
+      StringBuilder builder = new StringBuilder(parts[0]);
+      
+      for (Map.Entry<String, String> entry : values.entrySet()) {
+        if ("version".equals(entry.getKey())) builder.append(parts[2]);
+        else if ("company".equals(entry.getKey())) builder.append(parts[1]);
+      }
+      
+      builder.append(parts[3]);
+      
+      return builder.toString();
+    }
+    
+    /**
+     * Test the filter generated correctly
+     * @throws Exception
+     */
+    @Test
+    public void testGenerateFilter() throws Exception {
+      Map<String, String> valueMap = new HashMap<String, String>();
+      valueMap.put("version", "[1.2, 2.3]");
+      valueMap.put("resulution:", "mandatory");
+      valueMap.put("company", "com");
+      String filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
+      String expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)(version<=2.3.0)", "(mandatory:<*company))");
+      assertEquals("The filter is wrong.", expected, filter );
+      
+      
+      valueMap.clear();
+      
+      valueMap.put("version", "(1.2, 2.3]");
+      valueMap.put("resulution:", "mandatory");
+      valueMap.put("company", "com");
+      filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
+      expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)(version<=2.3.0)(!(version=1.2.0))", "(mandatory:<*company))");
+      assertEquals("The filter is wrong.", expected, filter );
+      
+      valueMap.clear();
+      
+      valueMap.put("version", "(1.2, 2.3)");
+      valueMap.put("resulution:", "mandatory");
+      valueMap.put("company", "com");
+      filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
+      expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)(version<=2.3.0)(!(version=1.2.0))(!(version=2.3.0))", "(mandatory:<*company))");
+      assertEquals("The filter is wrong.", expected, filter );
+      
+      valueMap.clear();
+      
+      valueMap.put("version", "1.2");
+      valueMap.put("resulution:", "mandatory");
+      valueMap.put("company", "com");
+      filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
+      expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "(version>=1.2.0)", "(mandatory:<*company))");
+      assertEquals("The filter is wrong.", expected, filter );
+      
+      valueMap.clear();
+      
+      valueMap.put("resulution:", "mandatory");
+      valueMap.put("company", "com");
+      filter = ManifestHeaderProcessor.generateFilter("symbolic-name", "com.ibm.foo", valueMap);
+      expected = createExpectedFilter(valueMap, "(&(symbolic-name=com.ibm.foo)", "(company=com)", "", "(mandatory:<*company))");
+      assertEquals("The filter is wrong.", expected, filter );
+    }
+    
+    /**
+     * Test the version range created correctly
+     * @throws Exception
+     */
+    
+    @Test
+    public void testVersionRange() throws Exception {
+      String version1 = "[1.2.3, 4.5.6]";
+      String version2="(1, 2]";
+      String version3="[2,4)";
+      String version4="(1,2)";
+      String version5="2";
+      String version6 = "2.3";
+      String version7="[1.2.3.q, 2.3.4.p)";
+      String version8="1.2.2.5";
+      String version9="a.b.c";
+      String version10=null;
+      String version11="";
+      String version12="\"[1.2.3, 4.5.6]\"";
+      
+      VersionRange vr = ManifestHeaderProcessor.parseVersionRange(version1);
+      assertEquals("The value is wrong", "1.2.3", vr.getMinimumVersion().toString());
+      assertFalse("The value is wrong", vr.isMinimumExclusive());
+      assertEquals("The value is wrong", "4.5.6", vr.getMaximumVersion().toString());
+      assertFalse("The value is wrong", vr.isMaximumExclusive());
+      
+      vr = ManifestHeaderProcessor.parseVersionRange(version2);
+      assertEquals("The value is wrong", "1.0.0", vr.getMinimumVersion().toString());
+      assertTrue("The value is wrong", vr.isMinimumExclusive());
+      assertEquals("The value is wrong", "2.0.0", vr.getMaximumVersion().toString());
+      assertFalse("The value is wrong", vr.isMaximumExclusive());
+      
+      vr = ManifestHeaderProcessor.parseVersionRange(version3);
+      
+      assertEquals("The value is wrong", "2.0.0", vr.getMinimumVersion().toString());
+      assertFalse("The value is wrong", vr.isMinimumExclusive());
+      assertEquals("The value is wrong", "4.0.0", vr.getMaximumVersion().toString());
+      assertTrue("The value is wrong", vr.isMaximumExclusive());
+      
+      vr = ManifestHeaderProcessor.parseVersionRange(version4);
+      
+      assertEquals("The value is wrong", "1.0.0", vr.getMinimumVersion().toString());
+      assertTrue("The value is wrong", vr.isMinimumExclusive());
+      assertEquals("The value is wrong", "2.0.0", vr.getMaximumVersion().toString());
+      assertTrue("The value is wrong", vr.isMaximumExclusive());
+      
+      vr = ManifestHeaderProcessor.parseVersionRange(version5);
+      assertEquals("The value is wrong", "2.0.0", vr.getMinimumVersion().toString());
+      assertFalse("The value is wrong", vr.isMinimumExclusive());
+      assertNull("The value is wrong", vr.getMaximumVersion());
+      assertFalse("The value is wrong", vr.isMaximumExclusive());
+      
+      vr = ManifestHeaderProcessor.parseVersionRange(version6);
+      assertEquals("The value is wrong", "2.3.0", vr.getMinimumVersion().toString());
+      assertFalse("The value is wrong", vr.isMinimumExclusive());
+      assertNull("The value is wrong", vr.getMaximumVersion());
+      assertFalse("The value is wrong", vr.isMaximumExclusive());
+      
+      vr = ManifestHeaderProcessor.parseVersionRange(version7);
+      assertEquals("The value is wrong", "1.2.3.q", vr.getMinimumVersion().toString());
+      assertFalse("The value is wrong", vr.isMinimumExclusive());
+      assertEquals("The value is wrong", "2.3.4.p", vr.getMaximumVersion().toString());
+      assertTrue("The value is wrong", vr.isMaximumExclusive());
+      
+      vr = ManifestHeaderProcessor.parseVersionRange(version8);
+      assertEquals("The value is wrong", "1.2.2.5", vr.getMinimumVersion().toString());
+      assertFalse("The value is wrong", vr.isMinimumExclusive());
+      assertNull("The value is wrong", vr.getMaximumVersion());
+      assertFalse("The value is wrong", vr.isMaximumExclusive());
+      boolean exception = false;
+      try {
+      vr = ManifestHeaderProcessor.parseVersionRange(version9);
+      } catch (Exception e){
+        exception = true;
+      }
+      
+      assertTrue("The value is wrong", exception);
+      boolean exceptionNull = false;
+      try {
+        vr = ManifestHeaderProcessor.parseVersionRange(version10);
+        } catch (Exception e){
+          exceptionNull = true;
+        }
+        assertTrue("The value is wrong", exceptionNull);
+        // empty version should be defaulted to >=0.0.0
+        vr = ManifestHeaderProcessor.parseVersionRange(version11);
+        assertEquals("The value is wrong", "0.0.0", vr.getMinimumVersion().toString());
+        assertFalse("The value is wrong", vr.isMinimumExclusive());
+        assertNull("The value is wrong", vr.getMaximumVersion());
+        assertFalse("The value is wrong", vr.isMaximumExclusive());
+          
+          
+          vr = ManifestHeaderProcessor.parseVersionRange(version12);
+          assertEquals("The value is wrong", "1.2.3", vr.getMinimumVersion().toString());
+          assertFalse("The value is wrong", vr.isMinimumExclusive());
+          assertEquals("The value is wrong", "4.5.6", vr.getMaximumVersion().toString());
+          assertFalse("The value is wrong", vr.isMaximumExclusive());  
+    }
+    
+    @Test
+    public void testInvalidVersions() throws Exception
+    {
+      try {
+        ManifestHeaderProcessor.parseVersionRange("a");
+        assertTrue("Should have thrown an exception", false);
+      } catch (IllegalArgumentException e) {
+        // assertEquals(MessageUtil.getMessage("APPUTILS0009E", "a"), e.getMessage());
+      }
+      
+      try {
+        ManifestHeaderProcessor.parseVersionRange("[1.0.0,1.0.1]", true);
+        assertTrue("Should have thrown an exception", false);
+      } catch (IllegalArgumentException e) {
+        // assertEquals(MessageUtil.getMessage("APPUTILS0011E", "[1.0.0,1.0.1]"), e.getMessage());
+      }
+
+    }
+
+    @Test
+    public void testSplit() throws Exception {
+      String export = "com.ibm.ws.eba.obr.fep.bundle122;version=\"3\";company=mood;local=yes;security=yes;mandatory:=\"mood,security\"";
+      List<String> result = ManifestHeaderProcessor.split(export, ",");
+      assertEquals("The result is wrong.", export, result.get(0));
+      assertEquals("The result is wrong.", 1, result.size());
+      
+      String aString = "com.acme.foo;weirdAttr=\"one;two;three\";weirdDir:=\"1;2;3\"";
+      result = ManifestHeaderProcessor.split(aString, ";");
+      assertEquals("The result is wrong.", "com.acme.foo", result.get(0));
+      assertEquals("The result is wrong.", "weirdAttr=\"one;two;three\"", result.get(1));
+      assertEquals("The result is wrong.", "weirdDir:=\"1;2;3\"", result.get(2));
+      
+      assertEquals("The result is wrong.", 3, result.size());
+      
+      
+      
+      
+      String pkg1 = "com.ibm.ws.eba.example.helloIsolation;version=\"1.0.0\" ";
+      String pkg2 = "com.ibm.ws.eba.helloWorldService;version=\"[1.0.0,1.0.0]\"";
+      String pkg3 = " com.ibm.ws.eba.helloWorldService;version=\"1.0.0\"";
+      String pkg4 = "com.ibm.ws.eba.helloWorldService;version=\"[1.0.0,1.0.0]\";sharing:=shared" ;
+      String pkg5 = "com.ibm.ws.eba.helloWorldService;sharing:=shared;version=\"[1.0.0,1.0.0]\"";
+      String appContent1 = pkg1 + ", " + pkg2 + ", " + pkg3;
+      String appContent2 = pkg2 + ", " + pkg1 + ", " + pkg3;
+      String appContent3 = pkg1 + ", " + pkg3 + ", " + pkg2;
+      String appContent4 = pkg1 + ", " + pkg3 + ", " + pkg4;
+      String appContent5 = pkg1 + ", " + pkg3 + ", " + pkg5;
+      
+      List<String> splitList = ManifestHeaderProcessor.split(appContent1, ",");
+      assertEquals(pkg1.trim(), splitList.get(0));
+      assertEquals(pkg2.trim(), splitList.get(1));
+      assertEquals(pkg3.trim(), splitList.get(2));
+      
+      splitList = ManifestHeaderProcessor.split(appContent2, ",");
+      assertEquals(pkg2.trim(), splitList.get(0));
+      assertEquals(pkg1.trim(), splitList.get(1));
+      assertEquals(pkg3.trim(), splitList.get(2));
+      
+      splitList = ManifestHeaderProcessor.split(appContent3, ",");
+      assertEquals(pkg1.trim(), splitList.get(0));
+      assertEquals(pkg3.trim(), splitList.get(1));
+      assertEquals(pkg2.trim(), splitList.get(2));
+      
+      splitList = ManifestHeaderProcessor.split(appContent4, ",");
+      assertEquals(pkg1.trim(), splitList.get(0));
+      assertEquals(pkg3.trim(), splitList.get(1));
+      assertEquals(pkg4.trim(), splitList.get(2));
+      
+      splitList = ManifestHeaderProcessor.split(appContent5, ",");
+      assertEquals(pkg1.trim(), splitList.get(0));
+      assertEquals(pkg3.trim(), splitList.get(1));
+      assertEquals(pkg5.trim(), splitList.get(2));   
+    }
+    
+    @Test
+    public void testParseFilter()
+    {
+      Map<String,String> attrs = ManifestHeaderProcessor.parseFilter("(package=com.ibm.test)");
+      assertEquals("com.ibm.test", attrs.get("package"));
+      
+      attrs = ManifestHeaderProcessor.parseFilter("(&(package=com.ibm.test)(attr=value))");
+      assertEquals("com.ibm.test", attrs.get("package"));
+      assertEquals("value", attrs.get("attr"));
+      assertEquals(2, attrs.size());
+      
+      attrs = ManifestHeaderProcessor.parseFilter("(&(version>=1.0.0))");
+      assertEquals("1.0.0", attrs.get("version"));
+      
+      attrs = ManifestHeaderProcessor.parseFilter("(&(version>=1.0.0)(version<=2.0.0))");
+      assertEquals("[1.0.0,2.0.0]", attrs.get("version"));
+
+      attrs = ManifestHeaderProcessor.parseFilter("(&(version>=1.0.0)(version<=2.0.0)(!(version=1.0.0)))");
+      assertEquals("(1.0.0,2.0.0]", attrs.get("version"));
+
+      attrs = ManifestHeaderProcessor.parseFilter("(&(!(version=2.0.0))(!(version=1.0.0))(version>=1.0.0)(version<=2.0.0))");
+      assertEquals("(1.0.0,2.0.0)", attrs.get("version"));
+    }
+    
+    @Test
+    public void testExactVersion() throws Exception 
+    {
+      VersionRange vr;
+      try {
+        vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 2.0.0]", true);
+        fail("should not get here 1");
+      } catch (IllegalArgumentException e) {
+        // expected
+      }
+      
+      vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 1.0.0]", true);
+      assertTrue(vr.isExactVersion());
+      
+      try {
+        vr = ManifestHeaderProcessor.parseVersionRange("(1.0.0, 1.0.0]", true);
+        fail("should not get here 2");
+      } catch (IllegalArgumentException e) {
+        // expected
+      }
+      
+      try {
+        vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 1.0.0)", true);
+        fail("should not get here 3");
+      } catch (IllegalArgumentException e) {
+        // expected
+      }
+      
+      vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 2.0.0]");
+      assertFalse(vr.isExactVersion());
+      
+      vr = ManifestHeaderProcessor.parseVersionRange("[1.0.0, 1.0.0]");
+      assertTrue(vr.isExactVersion());
+      
+      
+    }
+}
