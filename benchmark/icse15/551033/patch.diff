diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CastNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CastNode.java
index 570eaa6d..5a879dc4 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CastNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CastNode.java
@@ -31,7 +31,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.sql.compile.C_NodeTypes;
 
 import org.apache.derby.iapi.types.DataTypeUtilities;
-import org.apache.derby.iapi.types.StringDataValue;
 import org.apache.derby.iapi.types.TypeId;
 import org.apache.derby.iapi.reference.Limits;
 
@@ -76,6 +75,17 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	TypeId	destCTI = null;
 	TypeId	sourceCTI = null;
 	boolean forDataTypeFunction = false;
+	/** This variable gets set by the parser to indiciate that this CAST node 
+	 * has been generated by the parser. This means that we should use the 
+	 * collation info of the current compilation schmea for this node's 
+	 * collation setting. If this variable does not get set to true, then it 
+	 * means that this CAST node has been an internally generated node and we 
+	 * should not touch the collation info set for this CAST node because it 
+	 * has been already set correctly by the class that generated this CAST 
+	 * node. Collation info is part of the DataTypeDescriptor that's defined
+	 * on the ValueNode (the super class of this CastNode class)
+	 */ 
+	boolean externallyGeneratedCastNode = false;
 
 	/*
 	** Static array of valid casts.  Dimentions
@@ -363,7 +373,7 @@ public void bindCastNodeOnly()
 
 		//If the result type of cast is string data type, then that data type 
 		//should get it's collation type from the current schema. 
-		if (destCTI.isStringTypeId()) {
+		if (externallyGeneratedCastNode && destCTI.isStringTypeId()) {
 			//set the collation type to be same as the current schema's 
 			//collation type. Collation derivation is already initialized
 			//to correct value by default which is "IMPLICIT"
@@ -1004,6 +1014,21 @@ public Visitable accept(Visitor v)
 		return returnNode;
 	}
 
+	/** This method gets called by the parser to indiciate that this CAST node 
+	 * has been generated by the parser. This means that we should use the 
+	 * collation info of the current compilation schmea for this node's 
+	 * collation setting. If this method does not get called, then it means
+	 * that this CAST node has been an internally generated node and we should
+	 * not touch the collation of this CAST node because it has been already 
+	 * set correctly by the class that generated this CAST node. 
+	 * 
+	 * @param b true to use function conversion rules
+	 */
+	public void setForExternallyGeneratedCASTnode()
+	{
+		externallyGeneratedCastNode = true;
+	}
+
 	/** set this to be a dataTypeScalarFunction
 	 * 
 	 * @param b true to use function conversion rules
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest.java
index 60df3d6d..f08b0075 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/CollationTest.java
@@ -545,6 +545,21 @@ private void commonTestingForTerritoryBasedDB(Statement s) throws SQLException{
     		" ((CASE WHEN 1=1 THEN TABLENAME ELSE 'c' END) AS CHAR(12)) = " +
 			" 'SYSCOLUMNS'",
     		new String[][] {{"SYSCOLUMNS"} });   
+    //Another test for CASE WHEN THEN ELSE DERBY-2776
+    //The data type for THEN is not same as the data type for ELSE.
+    //THEN is of type CHAR and ELSE is of type VARCHAR. VARCHAR has higher
+    //precedence hence the type associated with the return type of CASE will
+    //be VARCHAR. Also, since the collation type of THEN and ELSE match,
+    //which is TERRITORY BASED, the return type of CASE will have the collation
+    //of TERRITORY BASED. This collation is same as the rhs of the = operation
+    //and hence following sql will pass. 
+    checkLangBasedQuery(s, "SELECT count(*) FROM CUSTOMER WHERE CASE WHEN " +
+    		" 1=1 THEN NAMECHAR ELSE NAME END = NAMECHAR",
+    		new String[][] {{"7"} });   
+    //The query below will work for the same reason. 
+    checkLangBasedQuery(s, "SELECT count(*) FROM SYS.SYSTABLES WHERE CASE " +
+    		" WHEN 1=1 THEN TABLENAME ELSE TABLEID END = TABLENAME",
+    		new String[][] {{"21"} });   
 
     //Do some testing using CONCATENATION
     //following will fail because result string of concatenation has 
@@ -894,15 +909,16 @@ private void commonTestingForTerritoryBasedDB(Statement s) throws SQLException{
 
 private void setUpTable(Statement s) throws SQLException {
 
-    s.execute("CREATE TABLE CUSTOMER(ID INT, NAME VARCHAR(40))");
+    s.execute("CREATE TABLE CUSTOMER(ID INT, NAME VARCHAR(40), NAMECHAR CHAR(40))");
     
     Connection conn = s.getConnection();
 
-    PreparedStatement ps = conn.prepareStatement("INSERT INTO CUSTOMER VALUES(?,?)");
+    PreparedStatement ps = conn.prepareStatement("INSERT INTO CUSTOMER VALUES(?,?,?)");
     for (int i = 0; i < NAMES.length; i++)
     {
             ps.setInt(1, i);
             ps.setString(2, NAMES[i]);
+            ps.setString(3, NAMES[i]);
             ps.executeUpdate();
     }
 
