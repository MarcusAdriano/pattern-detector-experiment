diff --git a/mahout/trunk/core/src/main/java/org/apache/mahout/classifier/bayes/mapreduce/bayes/BayesThetaNormalizerReducer.java b/mahout/trunk/core/src/main/java/org/apache/mahout/classifier/bayes/mapreduce/bayes/BayesThetaNormalizerReducer.java
index 963150fc..e80cfedf 100644
--- a/mahout/trunk/core/src/main/java/org/apache/mahout/classifier/bayes/mapreduce/bayes/BayesThetaNormalizerReducer.java
+++ b/mahout/trunk/core/src/main/java/org/apache/mahout/classifier/bayes/mapreduce/bayes/BayesThetaNormalizerReducer.java
@@ -56,7 +56,6 @@ public void reduce(StringTuple key,
     // Key is label,word, value is the number of times we've seen this label
     // word per local node. Output is the same
     
-    // String token = key.toString();
     
     double weightSumPerLabel = 0.0;
     
diff --git a/mahout/trunk/core/src/main/java/org/apache/mahout/classifier/bayes/mapreduce/common/BayesFeatureMapper.java b/mahout/trunk/core/src/main/java/org/apache/mahout/classifier/bayes/mapreduce/common/BayesFeatureMapper.java
index b2500526..0bef5edb 100644
--- a/mahout/trunk/core/src/main/java/org/apache/mahout/classifier/bayes/mapreduce/common/BayesFeatureMapper.java
+++ b/mahout/trunk/core/src/main/java/org/apache/mahout/classifier/bayes/mapreduce/common/BayesFeatureMapper.java
@@ -73,7 +73,6 @@ public void map(Text key,
                   Text value,
                   final OutputCollector<StringTuple,DoubleWritable> output,
                   Reporter reporter) throws IOException {
-    // String line = value.toString();
     final String label = key.toString();
     String[] tokens = SPACE_PATTERN.split(value.toString());
     OpenObjectIntHashMap<String> wordList = new OpenObjectIntHashMap<String>(tokens.length * gramSize);
diff --git a/mahout/trunk/core/src/main/java/org/apache/mahout/classifier/bayes/mapreduce/common/BayesWeightSummerReducer.java b/mahout/trunk/core/src/main/java/org/apache/mahout/classifier/bayes/mapreduce/common/BayesWeightSummerReducer.java
index 25ca8772..cbf7cc56 100644
--- a/mahout/trunk/core/src/main/java/org/apache/mahout/classifier/bayes/mapreduce/common/BayesWeightSummerReducer.java
+++ b/mahout/trunk/core/src/main/java/org/apache/mahout/classifier/bayes/mapreduce/common/BayesWeightSummerReducer.java
@@ -59,7 +59,6 @@ public void reduce(StringTuple key,
       sum += values.next().get();
     }
     reporter.setStatus("Bayes Weight Summer Reducer: " + key + " => " + sum);
-    // char firstChar = key.toString().charAt(0);
     if (useHbase) {
       if (key.stringAt(0).equals(BayesConstants.FEATURE_SUM)) { // sum of weight
         // for all
diff --git a/mahout/trunk/core/src/main/java/org/apache/mahout/df/tools/FrequenciesJob.java b/mahout/trunk/core/src/main/java/org/apache/mahout/df/tools/FrequenciesJob.java
index 68efd3c5..01f9453a 100644
--- a/mahout/trunk/core/src/main/java/org/apache/mahout/df/tools/FrequenciesJob.java
+++ b/mahout/trunk/core/src/main/java/org/apache/mahout/df/tools/FrequenciesJob.java
@@ -190,7 +190,6 @@ protected void setup(Context context) throws IOException, InterruptedException {
      */
     protected void setup(Dataset dataset) {
       converter = new DataConverter(dataset);
-      //log.info("labels: {}", Arrays.toString(dataset.labels()));
     }
     
     @Override
diff --git a/mahout/trunk/examples/src/test/java/org/apache/mahout/classifier/sgd/TrainLogisticTest.java b/mahout/trunk/examples/src/test/java/org/apache/mahout/classifier/sgd/TrainLogisticTest.java
index 78454385..9945ac61 100644
--- a/mahout/trunk/examples/src/test/java/org/apache/mahout/classifier/sgd/TrainLogisticTest.java
+++ b/mahout/trunk/examples/src/test/java/org/apache/mahout/classifier/sgd/TrainLogisticTest.java
@@ -21,7 +21,6 @@
 import com.google.common.base.Charsets;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 import com.google.common.io.Resources;
 import org.apache.mahout.classifier.AbstractVectorClassifier;
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/Algebra.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/Algebra.java
index ebeee9c4..e69de29b 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/Algebra.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/Algebra.java
@@ -1,245 +0,0 @@
-/*
-Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
-Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
-is hereby granted without fee, provided that the above copyright notice appear in all copies and 
-that both that copyright notice and this permission notice appear in supporting documentation. 
-CERN makes no representations about the suitability of this software for any purpose. 
-It is provided "as is" without expressed or implied warranty.
-*/
-package org.apache.mahout.math.matrix.linalg;
-
-import org.apache.mahout.math.GenericPermuting;
-import org.apache.mahout.math.Swapper;
-import org.apache.mahout.math.matrix.DoubleMatrix1D;
-import org.apache.mahout.math.matrix.DoubleMatrix2D;
-
-/** @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported. */
-@Deprecated
-public final class Algebra {
-
-  /**
-   * A default Algebra object; has {@link Property#DEFAULT} attached for tolerance. Allows ommiting to construct an
-   * Algebra object time and again.
-   *
-   * Note that this Algebra object is immutable. Any attempt to assign a new Property object to it (via method
-   * <tt>setProperty</tt>), or to alter the tolerance of its property object (via <tt>property().setTolerance(...)</tt>)
-   * will throw an exception.
-   */
-  public static final Algebra DEFAULT;
-
-  /**
-   * A default Algebra object; has {@link Property#ZERO} attached for tolerance. Allows ommiting to construct an Algebra
-   * object time and again.
-   *
-   * Note that this Algebra object is immutable. Any attempt to assign a new Property object to it (via method
-   * <tt>setProperty</tt>), or to alter the tolerance of its property object (via <tt>property().setTolerance(...)</tt>)
-   * will throw an exception.
-   */
-  private static final Algebra ZERO;
-
-  /** The property object attached to this instance. */
-  private Property property;
-
-  static {
-    // don't use new Algebra(Property.DEFAULT.tolerance()), because then property object would be mutable.
-    DEFAULT = new Algebra();
-    DEFAULT.property = Property.DEFAULT; // immutable property object
-
-    ZERO = new Algebra();
-    ZERO.property = Property.ZERO; // immutable property object
-  }
-
-  /** Constructs a new instance with an equality tolerance given by <tt>Property.DEFAULT.tolerance()</tt>. */
-  public Algebra() {
-    this(Property.DEFAULT.tolerance());
-  }
-
-  /**
-   * Constructs a new instance with the given equality tolerance.
-   *
-   * @param tolerance the tolerance to be used for equality operations.
-   */
-  public Algebra(double tolerance) {
-    setProperty(new Property(tolerance));
-  }
-
-  /**
-   * Returns the determinant of matrix <tt>A</tt>.
-   *
-   * @return the determinant.
-   */
-  public static double det(DoubleMatrix2D A) {
-    return lu(A).det();
-  }
-
-  /** Returns sqrt(a^2 + b^2) without under/overflow. */
-  static double hypot(double a, double b) {
-    double r;
-    if (Math.abs(a) > Math.abs(b)) {
-      r = b / a;
-      r = Math.abs(a) * Math.sqrt(1 + r * r);
-    } else if (b != 0) {
-      r = a / b;
-      r = Math.abs(b) * Math.sqrt(1 + r * r);
-    } else {
-      r = 0.0;
-    }
-    return r;
-  }
-
-  /** Constructs and returns the LU-decomposition of the given matrix. */
-  private static LUDecomposition lu(DoubleMatrix2D matrix) {
-    return new LUDecomposition(matrix);
-  }
-
-  /**
-   * Modifies the given vector <tt>A</tt> such that it is permuted as specified; Useful for pivoting. Cell <tt>A[i]</tt>
-   * will go into cell <tt>A[indexes[i]]</tt>. <p> <b>Example:</b>
-   * <pre>
-   * Reordering
-   * [A,B,C,D,E] with indexes [0,4,2,3,1] yields
-   * [A,E,C,D,B]
-   * In other words A[0]<--A[0], A[1]<--A[4], A[2]<--A[2], A[3]<--A[3], A[4]<--A[1].
-   *
-   * Reordering
-   * [A,B,C,D,E] with indexes [0,4,1,2,3] yields
-   * [A,E,B,C,D]
-   * In other words A[0]<--A[0], A[1]<--A[4], A[2]<--A[1], A[3]<--A[2], A[4]<--A[3].
-   * </pre>
-   *
-   * @param A       the vector to permute.
-   * @param indexes the permutation indexes, must satisfy <tt>indexes.length==A.size() && indexes[i] >= 0 && indexes[i]
-   *                < A.size()</tt>;
-   * @param work    the working storage, must satisfy <tt>work.length >= A.size()</tt>; set <tt>work==null</tt> if you
-   *                don't care about performance.
-   * @throws IndexOutOfBoundsException if <tt>indexes.length != A.size()</tt>.
-   */
-  public static void permute(DoubleMatrix1D A, int[] indexes, double[] work) {
-    // check validity
-    int size = A.size();
-    if (indexes.length != size) {
-      throw new IndexOutOfBoundsException("invalid permutation");
-    }
-
-    /*
-    int i=size;
-    int a;
-    while (--i >= 0 && (a=indexes[i])==i) if (a < 0 || a >= size)
-    throw new IndexOutOfBoundsException("invalid permutation");
-    if (i<0) return; // nothing to permute
-    */
-
-    if (work == null || size > work.length) {
-      work = A.toArray();
-    } else {
-      A.toArray(work);
-    }
-    for (int i = size; --i >= 0;) {
-      A.setQuick(i, work[indexes[i]]);
-    }
-  }
-
-  /**
-   * Modifies the given matrix <tt>A</tt> such that it's rows are permuted as specified; Useful for pivoting. Row
-   * <tt>A[i]</tt> will go into row <tt>A[indexes[i]]</tt>. <p> <b>Example:</b>
-   * <pre>
-   * Reordering
-   * [A,B,C,D,E] with indexes [0,4,2,3,1] yields
-   * [A,E,C,D,B]
-   * In other words A[0]<--A[0], A[1]<--A[4], A[2]<--A[2], A[3]<--A[3], A[4]<--A[1].
-   *
-   * Reordering
-   * [A,B,C,D,E] with indexes [0,4,1,2,3] yields
-   * [A,E,B,C,D]
-   * In other words A[0]<--A[0], A[1]<--A[4], A[2]<--A[1], A[3]<--A[2], A[4]<--A[3].
-   * </pre>
-   *
-   * @param A       the matrix to permute.
-   * @param indexes the permutation indexes, must satisfy <tt>indexes.length==A.rows() && indexes[i] >= 0 && indexes[i]
-   *                < A.rows()</tt>;
-   * @param work    the working storage, must satisfy <tt>work.length >= A.rows()</tt>; set <tt>work==null</tt> if you
-   *                don't care about performance.
-   * @throws IndexOutOfBoundsException if <tt>indexes.length != A.rows()</tt>.
-   */
-  public static void permuteRows(final DoubleMatrix2D A, int[] indexes, int[] work) {
-    // check validity
-    int size = A.rows();
-    if (indexes.length != size) {
-      throw new IndexOutOfBoundsException("invalid permutation");
-    }
-
-    /*
-    int i=size;
-    int a;
-    while (--i >= 0 && (a=indexes[i])==i) if (a < 0 || a >= size)
-      throw new IndexOutOfBoundsException("invalid permutation");
-    if (i<0) return; // nothing to permute
-    */
-
-    int columns = A.columns();
-    if (columns < size / 10) { // quicker
-      double[] doubleWork = new double[size];
-      for (int j = A.columns(); --j >= 0;) {
-        permute(A.viewColumn(j), indexes, doubleWork);
-      }
-      return;
-    }
-
-    Swapper swapper = new Swapper() {
-      public void swap(int a, int b) {
-        A.viewRow(a).swap(A.viewRow(b));
-      }
-    };
-
-    GenericPermuting.permute(indexes, swapper, work, null);
-  }
-
-  /**
-   * Returns the property object attached to this Algebra, defining tolerance.
-   *
-   * @return the Property object.
-   * @see #setProperty(Property)
-   */
-  public Property property() {
-    return property;
-  }
-
-  /**
-   * Attaches the given property object to this Algebra, defining tolerance.
-   *
-   * @param property the Property object to be attached.
-   * @throws UnsupportedOperationException if <tt>this==DEFAULT && property!=this.property()</tt> - The DEFAULT Algebra
-   *                                       object is immutable.
-   * @throws UnsupportedOperationException if <tt>this==ZERO && property!=this.property()</tt> - The ZERO Algebra object
-   *                                       is immutable.
-   * @see #property
-   */
-  public void setProperty(Property property) {
-    if (this == DEFAULT && property != this.property) {
-      throw new IllegalArgumentException("Attempted to modify immutable object.");
-    }
-    if (this == ZERO && property != this.property) {
-      throw new IllegalArgumentException("Attempted to modify immutable object.");
-    }
-    this.property = property;
-  }
-
-  /**
-   * Modifies the matrix to be a lower trapezoidal matrix.
-   *
-   * @return <tt>A</tt> (for convenience only).
-   */
-  static DoubleMatrix2D trapezoidalLower(DoubleMatrix2D A) {
-    int rows = A.rows();
-    int columns = A.columns();
-    for (int r = rows; --r >= 0;) {
-      for (int c = columns; --c >= 0;) {
-        if (r < c) {
-          A.setQuick(r, c, 0);
-        }
-      }
-    }
-    return A;
-  }
-
-}
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/EigenvalueDecomposition.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/EigenvalueDecomposition.java
index 5ac063e1..b155501c 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/EigenvalueDecomposition.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/EigenvalueDecomposition.java
@@ -15,6 +15,7 @@
 
 import java.io.Serializable;
 
+import static org.apache.mahout.math.Algebra.hypot;
 import static org.apache.mahout.math.matrix.linalg.Property.*;
 
 /** @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported. */
@@ -774,7 +775,7 @@ private void tql2() {
 
           double g = d[l];
           double p = (d[l + 1] - g) / (2.0 * e[l]);
-          double r = Algebra.hypot(p, 1.0);
+          double r = hypot(p, 1.0);
           if (p < 0) {
             r = -r;
           }
@@ -802,7 +803,7 @@ private void tql2() {
             s2 = s;
             g = c * e[i];
             h = c * p;
-            r = Algebra.hypot(p, e[i]);
+            r = hypot(p, e[i]);
             e[i + 1] = s * r;
             s = e[i] / r;
             c = p / r;
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/LUDecomposition.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/LUDecomposition.java
index 89d16ada..e69de29b 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/LUDecomposition.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/LUDecomposition.java
@@ -1,74 +0,0 @@
-/*
-Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
-Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
-is hereby granted without fee, provided that the above copyright notice appear in all copies and 
-that both that copyright notice and this permission notice appear in supporting documentation. 
-CERN makes no representations about the suitability of this software for any purpose. 
-It is provided "as is" without expressed or implied warranty.
-*/
-package org.apache.mahout.math.matrix.linalg;
-
-import java.io.Serializable;
-
-import org.apache.mahout.math.matrix.DoubleMatrix2D;
-
-/**
- * For an <tt>m x n</tt> matrix <tt>A</tt> with <tt>m >= n</tt>, the LU decomposition is an <tt>m x n</tt> unit lower
- * triangular matrix <tt>L</tt>, an <tt>n x n</tt> upper triangular matrix <tt>U</tt>, and a permutation vector
- * <tt>piv</tt> of length <tt>m</tt> so that <tt>A(piv,:) = L*U</tt>; If <tt>m < n</tt>, then <tt>L</tt> is <tt>m x
- * m</tt> and <tt>U</tt> is <tt>m x n</tt>. <P> The LU decomposition with pivoting always exists, even if the matrix is
- * singular, so the constructor will never fail.  The primary use of the LU decomposition is in the solution of square
- * systems of simultaneous linear equations.  This will fail if <tt>isNonsingular()</tt> returns false.
- */
-public final class LUDecomposition implements Serializable {
-
-  private final LUDecompositionQuick quick;
-
-  /**
-   * Constructs and returns a new LU Decomposition object; The decomposed matrices can be retrieved via instance methods
-   * of the returned decomposition object.
-   *
-   * @param a Rectangular matrix
-   */
-  public LUDecomposition(DoubleMatrix2D a) {
-    quick = new LUDecompositionQuick(0); // zero tolerance for compatibility with Jama
-    quick.decompose(a.copy());
-  }
-
-  /**
-   * Returns the determinant, <tt>det(A)</tt>.
-   *
-   * @throws IllegalArgumentException Matrix must be square
-   */
-  public double det() {
-    return quick.det();
-  }
-
-  /**
-   * Solves <tt>A*X = B</tt>.
-   *
-   * @param b A matrix with as many rows as <tt>A</tt> and any number of columns.
-   * @return <tt>X</tt> so that <tt>L*U*X = B(piv,:)</tt>.
-   * @throws IllegalArgumentException if </tt>B.rows() != A.rows()</tt>.
-   * @throws IllegalArgumentException if A is singular, that is, if <tt>!this.isNonsingular()</tt>.
-   * @throws IllegalArgumentException if <tt>A.rows() < A.columns()</tt>.
-   */
-
-  public DoubleMatrix2D solve(DoubleMatrix2D b) {
-    DoubleMatrix2D x = b.copy();
-    quick.solve(x);
-    return x;
-  }
-
-  /**
-   * Returns a String with (propertyName, propertyValue) pairs. Useful for debugging or to quickly get the rough
-   * picture. For example,
-   * <pre>
-   * rank          : 3
-   * trace         : 0
-   * </pre>
-   */
-  public String toString() {
-    return quick.toString();
-  }
-}
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/LUDecompositionQuick.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/LUDecompositionQuick.java
index 056883b0..e69de29b 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/LUDecompositionQuick.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/LUDecompositionQuick.java
@@ -1,679 +0,0 @@
-/*
-Copyright 1999 CERN - European Organization for Nuclear Research.
-Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
-is hereby granted without fee, provided that the above copyright notice appear in all copies and 
-that both that copyright notice and this permission notice appear in supporting documentation. 
-CERN makes no representations about the suitability of this software for any purpose. 
-It is provided "as is" without expressed or implied warranty.
-*/
-package org.apache.mahout.math.matrix.linalg;
-
-import org.apache.mahout.math.function.Mult;
-import org.apache.mahout.math.function.PlusMult;
-import org.apache.mahout.math.list.IntArrayList;
-import org.apache.mahout.math.matrix.DoubleMatrix1D;
-import org.apache.mahout.math.matrix.DoubleMatrix2D;
-import org.apache.mahout.math.matrix.impl.DenseDoubleMatrix1D;
-import org.apache.mahout.math.matrix.impl.DenseDoubleMatrix2D;
-
-import java.io.Serializable;
-
-/** @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported. */
-@Deprecated
-public final class LUDecompositionQuick implements Serializable {
-
-  /** Array for internal storage of decomposition. */
-  private DoubleMatrix2D lu;
-
-  /** pivot sign. */
-  private int pivsign;
-
-  /** Internal storage of pivot vector. */
-  private int[] piv;
-
-  private boolean isNonSingular;
-
-  private final Algebra algebra;
-
-  private transient double[] workDouble;
-  private transient int[] work1;
-
-  /** Constructs and returns a new LU Decomposition object which uses the given tolerance for singularity detection; */
-  public LUDecompositionQuick(double tolerance) {
-    this.algebra = new Algebra(tolerance);
-  }
-
-  /**
-   * Decomposes matrix <tt>A</tt> into <tt>L</tt> and <tt>U</tt> (in-place). Upon return <tt>A</tt> is overridden with
-   * the result <tt>LU</tt>, such that <tt>L*U = A</tt>. Uses a "left-looking", dot-product, Crout/Doolittle algorithm.
-   *
-   * @param A any matrix.
-   */
-  public void decompose(DoubleMatrix2D A) {
-    // setup
-    lu = A;
-    int m = A.rows();
-    int n = A.columns();
-
-    // setup pivot vector
-    if (this.piv == null || this.piv.length != m) {
-      this.piv = new int[m];
-    }
-    for (int i = m; --i >= 0;) {
-      piv[i] = i;
-    }
-    pivsign = 1;
-
-    if (m * n == 0) {
-      setLU(lu);
-      return; // nothing to do
-    }
-
-    //precompute and cache some views to avoid regenerating them time and again
-    DoubleMatrix1D[] luRows = new DoubleMatrix1D[m];
-    for (int i = 0; i < m; i++) {
-      luRows[i] = lu.viewRow(i);
-    }
-
-    IntArrayList nonZeroIndexes =
-        new IntArrayList(); // sparsity
-    DoubleMatrix1D luColj = lu.viewColumn(0).like();  // blocked column j
-    Mult multFunction = Mult.mult(0);
-
-    // Outer loop.
-    int cutOff = 10;
-    for (int j = 0; j < n; j++) {
-      // blocking (make copy of j-th column to localize references)
-      luColj.assign(lu.viewColumn(j));
-
-      // sparsity detection
-      int maxCardinality = m / cutOff; // == heuristic depending on speedup
-      luColj.getNonZeros(nonZeroIndexes, null, maxCardinality);
-      int cardinality = nonZeroIndexes.size();
-      boolean sparse = cardinality < maxCardinality;
-
-      // Apply previous transformations.
-      for (int i = 0; i < m; i++) {
-        int kmax = Math.min(i, j);
-        double s;
-        if (sparse) {
-          s = luRows[i].zDotProduct(luColj, 0, kmax, nonZeroIndexes);
-        } else {
-          s = luRows[i].zDotProduct(luColj, 0, kmax);
-        }
-        double before = luColj.getQuick(i);
-        double after = before - s;
-        luColj.setQuick(i, after); // LUcolj is a copy
-        lu.setQuick(i, j, after);   // this is the original
-        if (sparse) {
-          if (before == 0 && after != 0) { // nasty bug fixed!
-            int pos = nonZeroIndexes.binarySearch(i);
-            pos = -pos - 1;
-            nonZeroIndexes.beforeInsert(pos, i);
-          }
-          if (before != 0 && after == 0) {
-            nonZeroIndexes.remove(nonZeroIndexes.binarySearch(i));
-          }
-        }
-      }
-
-      // Find pivot and exchange if necessary.
-      int p = j;
-      if (p < m) {
-        double max = Math.abs(luColj.getQuick(p));
-        for (int i = j + 1; i < m; i++) {
-          double v = Math.abs(luColj.getQuick(i));
-          if (v > max) {
-            p = i;
-            max = v;
-          }
-        }
-      }
-      if (p != j) {
-        luRows[p].swap(luRows[j]);
-        int k = piv[p];
-        piv[p] = piv[j];
-        piv[j] = k;
-        pivsign = -pivsign;
-      }
-
-      // Compute multipliers.
-      double jj;
-      if (j < m && (jj = lu.getQuick(j, j)) != 0.0) {
-        multFunction.setMultiplicator(1 / jj);
-        lu.viewColumn(j).viewPart(j + 1, m - (j + 1)).assign(multFunction);
-      }
-
-    }
-    setLU(lu);
-  }
-
-  /**
-   * Decomposes the banded and square matrix <tt>A</tt> into <tt>L</tt> and <tt>U</tt> (in-place). Upon return
-   * <tt>A</tt> is overridden with the result <tt>LU</tt>, such that <tt>L*U = A</tt>. Currently supports diagonal and
-   * tridiagonal matrices, all other cases fall through to {@link #decompose(DoubleMatrix2D)}.
-   *
-   * @param semiBandwidth == 1 --> A is diagonal, == 2 --> A is tridiagonal.
-   * @param A             any matrix.
-   */
-  public void decompose(DoubleMatrix2D A, int semiBandwidth) {
-    if (!Property.isSquare(A) || semiBandwidth < 0 || semiBandwidth > 2) {
-      decompose(A);
-      return;
-    }
-    // setup
-    lu = A;
-    int m = A.rows();
-    int n = A.columns();
-
-    // setup pivot vector
-    if (this.piv == null || this.piv.length != m) {
-      this.piv = new int[m];
-    }
-    for (int i = m; --i >= 0;) {
-      piv[i] = i;
-    }
-    pivsign = 1;
-
-    if (m * n == 0) {
-      setLU(A);
-      return; // nothing to do
-    }
-
-    //if (semiBandwidth == 1) { // A is diagonal; nothing to do
-    if (semiBandwidth == 2) { // A is tridiagonal
-      // currently no pivoting !
-      if (n > 1) {
-        A.setQuick(1, 0, A.getQuick(1, 0) / A.getQuick(0, 0));
-      }
-
-      for (int i = 1; i < n; i++) {
-        double ei = A.getQuick(i, i) - A.getQuick(i, i - 1) * A.getQuick(i - 1, i);
-        A.setQuick(i, i, ei);
-        if (i < n - 1) {
-          A.setQuick(i + 1, i, A.getQuick(i + 1, i) / ei);
-        }
-      }
-    }
-    setLU(A);
-  }
-
-  /**
-   * Returns the determinant, <tt>det(A)</tt>.
-   *
-   * @throws IllegalArgumentException if <tt>A.rows() != A.columns()</tt> (Matrix must be square).
-   */
-  public double det() {
-    int m = m();
-    int n = n();
-    if (m != n) {
-      throw new IllegalArgumentException("Matrix must be square.");
-    }
-
-    if (!isNonSingular) {
-      return 0;
-    } // avoid rounding errors
-
-    double det = (double) pivsign;
-    for (int j = 0; j < n; j++) {
-      det *= lu.getQuick(j, j);
-    }
-    return det;
-  }
-
-  /**
-   * Returns pivot permutation vector as a one-dimensional double array
-   *
-   * @return (double) piv
-   */
-  protected double[] getDoublePivot() {
-    int m = m();
-    double[] vals = new double[m];
-    for (int i = 0; i < m; i++) {
-      vals[i] = (double) piv[i];
-    }
-    return vals;
-  }
-
-  /**
-   * Returns the lower triangular factor, <tt>L</tt>.
-   *
-   * @return <tt>L</tt>
-   */
-  public DoubleMatrix2D getL() {
-    return lowerTriangular(lu.copy());
-  }
-
-  /**
-   * Returns a copy of the combined lower and upper triangular factor, <tt>LU</tt>.
-   *
-   * @return <tt>LU</tt>
-   */
-  public DoubleMatrix2D getLU() {
-    return lu.copy();
-  }
-
-  /**
-   * Returns the pivot permutation vector (not a copy of it).
-   *
-   * @return piv
-   */
-  public int[] getPivot() {
-    return piv;
-  }
-
-  /**
-   * Returns the upper triangular factor, <tt>U</tt>.
-   *
-   * @return <tt>U</tt>
-   */
-  public DoubleMatrix2D getU() {
-    return upperTriangular(lu.copy());
-  }
-
-  /**
-   * Returns whether the matrix is nonsingular (has an inverse).
-   *
-   * @return true if <tt>U</tt>, and hence <tt>A</tt>, is nonsingular; false otherwise.
-   */
-  public boolean isNonsingular() {
-    return isNonSingular;
-  }
-
-  /**
-   * Returns whether the matrix is nonsingular.
-   *
-   * @return true if <tt>matrix</tt> is nonsingular; false otherwise.
-   */
-  protected boolean isNonsingular(DoubleMatrix2D matrix) {
-    int m = matrix.rows();
-    int n = matrix.columns();
-    double epsilon = algebra.property().tolerance(); // consider numerical instability
-    for (int j = Math.min(n, m); --j >= 0;) {
-      //if (matrix.getQuick(j,j) == 0) return false;
-      if (Math.abs(matrix.getQuick(j, j)) <= epsilon) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  /**
-   * Modifies the matrix to be a lower triangular matrix. <p> <b>Examples:</b> <table border="0"> <tr nowrap> <td
-   * valign="top">3 x 5 matrix:<br> 9, 9, 9, 9, 9<br> 9, 9, 9, 9, 9<br> 9, 9, 9, 9, 9 </td> <td
-   * align="center">triang.Upper<br> ==></td> <td valign="top">3 x 5 matrix:<br> 9, 9, 9, 9, 9<br> 0, 9, 9, 9, 9<br> 0,
-   * 0, 9, 9, 9</td> </tr> <tr nowrap> <td valign="top">5 x 3 matrix:<br> 9, 9, 9<br> 9, 9, 9<br> 9, 9, 9<br> 9, 9,
-   * 9<br> 9, 9, 9 </td> <td align="center">triang.Upper<br> ==></td> <td valign="top">5 x 3 matrix:<br> 9, 9, 9<br> 0,
-   * 9, 9<br> 0, 0, 9<br> 0, 0, 0<br> 0, 0, 0</td> </tr> <tr nowrap> <td valign="top">3 x 5 matrix:<br> 9, 9, 9, 9,
-   * 9<br> 9, 9, 9, 9, 9<br> 9, 9, 9, 9, 9 </td> <td align="center">triang.Lower<br> ==></td> <td valign="top">3 x 5
-   * matrix:<br> 1, 0, 0, 0, 0<br> 9, 1, 0, 0, 0<br> 9, 9, 1, 0, 0</td> </tr> <tr nowrap> <td valign="top">5 x 3
-   * matrix:<br> 9, 9, 9<br> 9, 9, 9<br> 9, 9, 9<br> 9, 9, 9<br> 9, 9, 9 </td> <td align="center">triang.Lower<br>
-   * ==></td> <td valign="top">5 x 3 matrix:<br> 1, 0, 0<br> 9, 1, 0<br> 9, 9, 1<br> 9, 9, 9<br> 9, 9, 9</td> </tr>
-   * </table>
-   *
-   * @return <tt>A</tt> (for convenience only).
-   */
-  protected static DoubleMatrix2D lowerTriangular(DoubleMatrix2D A) {
-    int rows = A.rows();
-    int columns = A.columns();
-    int min = Math.min(rows, columns);
-    for (int r = min; --r >= 0;) {
-      for (int c = min; --c >= 0;) {
-        if (r < c) {
-          A.setQuick(r, c, 0);
-        } else if (r == c) {
-          A.setQuick(r, c, 1);
-        }
-      }
-    }
-    if (columns > rows) {
-      A.viewPart(0, min, rows, columns - min).assign(0);
-    }
-
-    return A;
-  }
-
-  protected int m() {
-    return lu.rows();
-  }
-
-  protected int n() {
-    return lu.columns();
-  }
-
-  /**
-   * Sets the combined lower and upper triangular factor, <tt>LU</tt>. The parameter is not checked; make sure it is
-   * indeed a proper LU decomposition.
-   */
-  public void setLU(DoubleMatrix2D LU) {
-    this.lu = LU;
-    this.isNonSingular = isNonsingular(LU);
-  }
-
-  /**
-   * Solves the system of equations <tt>A*X = B</tt> (in-place). Upon return <tt>B</tt> is overridden with the result
-   * <tt>X</tt>, such that <tt>L*U*X = B(piv)</tt>.
-   *
-   * @param B A vector with <tt>B.size() == A.rows()</tt>.
-   * @throws IllegalArgumentException if </tt>B.size() != A.rows()</tt>.
-   * @throws IllegalArgumentException if A is singular, that is, if <tt>!isNonsingular()</tt>.
-   * @throws IllegalArgumentException if <tt>A.rows() < A.columns()</tt>.
-   */
-  public void solve(DoubleMatrix1D B) {
-    Property.checkRectangular(lu);
-    int m = m();
-    int n = n();
-    if (B.size() != m) {
-      throw new IllegalArgumentException("Matrix dimensions must agree.");
-    }
-    if (!this.isNonSingular) {
-      throw new IllegalArgumentException("Matrix is singular.");
-    }
-
-
-    // right hand side with pivoting
-    // Matrix Xmat = B.getMatrix(piv,0,nx-1);
-    if (this.workDouble == null || this.workDouble.length < m) {
-      this.workDouble = new double[m];
-    }
-    Algebra.permute(B, this.piv, this.workDouble);
-
-    if (m * n == 0) {
-      return;
-    } // nothing to do
-
-    // Solve L*Y = B(piv,:)
-    for (int k = 0; k < n; k++) {
-      double f = B.getQuick(k);
-      if (f != 0) {
-        for (int i = k + 1; i < n; i++) {
-          // B[i] -= B[k]*LU[i][k];
-          double v = lu.getQuick(i, k);
-          if (v != 0) {
-            B.setQuick(i, B.getQuick(i) - f * v);
-          }
-        }
-      }
-    }
-
-    // Solve U*B = Y;
-    for (int k = n - 1; k >= 0; k--) {
-      // B[k] /= LU[k,k]
-      B.setQuick(k, B.getQuick(k) / lu.getQuick(k, k));
-      double f = B.getQuick(k);
-      if (f != 0) {
-        for (int i = 0; i < k; i++) {
-          // B[i] -= B[k]*LU[i][k];
-          double v = lu.getQuick(i, k);
-          if (v != 0) {
-            B.setQuick(i, B.getQuick(i) - f * v);
-          }
-        }
-      }
-    }
-  }
-
-  /**
-   * Solves the system of equations <tt>A*X = B</tt> (in-place). Upon return <tt>B</tt> is overridden with the result
-   * <tt>X</tt>, such that <tt>L*U*X = B(piv,:)</tt>.
-   *
-   * @param B A matrix with as many rows as <tt>A</tt> and any number of columns.
-   * @throws IllegalArgumentException if </tt>B.rows() != A.rows()</tt>.
-   * @throws IllegalArgumentException if A is singular, that is, if <tt>!isNonsingular()</tt>.
-   * @throws IllegalArgumentException if <tt>A.rows() < A.columns()</tt>.
-   */
-  public void solve(DoubleMatrix2D B) {
-    Property.checkRectangular(lu);
-    int m = m();
-    int n = n();
-    if (B.rows() != m) {
-      throw new IllegalArgumentException("Matrix row dimensions must agree.");
-    }
-    if (!this.isNonSingular) {
-      throw new IllegalArgumentException("Matrix is singular.");
-    }
-
-
-    // right hand side with pivoting
-    // Matrix Xmat = B.getMatrix(piv,0,nx-1);
-    if (this.work1 == null || this.work1.length < m) {
-      this.work1 = new int[m];
-    }
-    //if (this.work2 == null || this.work2.length < m) this.work2 = new int[m];
-    Algebra.permuteRows(B, this.piv, this.work1);
-
-    if (m * n == 0) {
-      return;
-    } // nothing to do
-    int nx = B.columns();
-
-    //precompute and cache some views to avoid regenerating them time and again
-    DoubleMatrix1D[] brows = new DoubleMatrix1D[n];
-    for (int k = 0; k < n; k++) {
-      brows[k] = B.viewRow(k);
-    }
-
-    // transformations
-    Mult div = Mult.div(0);
-    PlusMult minusMult = PlusMult.minusMult(0);
-
-    IntArrayList nonZeroIndexes =
-        new IntArrayList(); // sparsity
-    DoubleMatrix1D bRowk = new DenseDoubleMatrix1D(nx); // blocked row k
-
-    // Solve L*Y = B(piv,:)
-    int cutOff = 10;
-    for (int k = 0; k < n; k++) {
-      // blocking (make copy of k-th row to localize references)
-      bRowk.assign(brows[k]);
-
-      // sparsity detection
-      int maxCardinality = nx / cutOff; // == heuristic depending on speedup
-      bRowk.getNonZeros(nonZeroIndexes, null, maxCardinality);
-      int cardinality = nonZeroIndexes.size();
-      boolean sparse = cardinality < maxCardinality;
-
-      for (int i = k + 1; i < n; i++) {
-        //for (int j = 0; j < nx; j++) B[i][j] -= B[k][j]*LU[i][k];
-        //for (int j = 0; j < nx; j++) B.set(i,j, B.get(i,j) - B.get(k,j)*LU.get(i,k));
-
-        minusMult.setMultiplicator(-lu.getQuick(i, k));
-        if (minusMult.getMultiplicator() != 0) {
-          if (sparse) {
-            brows[i].assign(bRowk, minusMult, nonZeroIndexes);
-          } else {
-            brows[i].assign(bRowk, minusMult);
-          }
-        }
-      }
-    }
-
-    // Solve U*B = Y;
-    for (int k = n - 1; k >= 0; k--) {
-      // for (int j = 0; j < nx; j++) B[k][j] /= LU[k][k];
-      // for (int j = 0; j < nx; j++) B.set(k,j, B.get(k,j) / LU.get(k,k));
-      div.setMultiplicator(1 / lu.getQuick(k, k));
-      brows[k].assign(div);
-
-      // blocking
-      //if (bRowk == null) {
-      //  bRowk = org.apache.mahout.math.matrix.DoubleFactory1D.dense.make(B.columns());
-      //}
-      bRowk.assign(brows[k]);
-
-      // sparsity detection
-      int maxCardinality = nx / cutOff; // == heuristic depending on speedup
-      bRowk.getNonZeros(nonZeroIndexes, null, maxCardinality);
-      int cardinality = nonZeroIndexes.size();
-      boolean sparse = cardinality < maxCardinality;
-
-      //Browk.getNonZeros(nonZeroIndexes,null);
-      //boolean sparse = nonZeroIndexes.size() < nx/10;
-
-      for (int i = 0; i < k; i++) {
-        // for (int j = 0; j < nx; j++) B[i][j] -= B[k][j]*LU[i][k];
-        // for (int j = 0; j < nx; j++) B.set(i,j, B.get(i,j) - B.get(k,j)*LU.get(i,k));
-
-        minusMult.setMultiplicator(-lu.getQuick(i, k));
-        if (minusMult.getMultiplicator() != 0) {
-          if (sparse) {
-            brows[i].assign(bRowk, minusMult, nonZeroIndexes);
-          } else {
-            brows[i].assign(bRowk, minusMult);
-          }
-        }
-      }
-    }
-  }
-
-  /**
-   * Solves <tt>A*X = B</tt>.
-   *
-   * @param B A matrix with as many rows as <tt>A</tt> and any number of columns.
-   * @return <tt>X</tt> so that <tt>L*U*X = B(piv,:)</tt>.
-   * @throws IllegalArgumentException if </tt>B.rows() != A.rows()</tt>.
-   * @throws IllegalArgumentException if A is singular, that is, if <tt>!this.isNonsingular()</tt>.
-   * @throws IllegalArgumentException if <tt>A.rows() < A.columns()</tt>.
-   */
-  /*
-  private void solveOld(DoubleMatrix2D B) {
-    Property.checkRectangular(LU);
-    int m = m();
-    int n = n();
-    if (B.rows() != m) {
-      throw new IllegalArgumentException("Matrix row dimensions must agree.");
-    }
-    if (!this.isNonsingular()) {
-      throw new IllegalArgumentException("Matrix is singular.");
-    }
-
-    // Copy right hand side with pivoting
-    int nx = B.columns();
-
-    if (this.work1 == null || this.work1.length < m) {
-      this.work1 = new int[m];
-    }
-    //if (this.work2 == null || this.work2.length < m) this.work2 = new int[m];
-    Algebra.permuteRows(B, this.piv, this.work1);
-
-    // Solve L*Y = B(piv,:) --> Y (Y is modified B)
-    for (int k = 0; k < n; k++) {
-      for (int i = k + 1; i < n; i++) {
-        double mult = LU.getQuick(i, k);
-        if (mult != 0) {
-          for (int j = 0; j < nx; j++) {
-            //B[i][j] -= B[k][j]*LU[i,k];
-            B.setQuick(i, j, B.getQuick(i, j) - B.getQuick(k, j) * mult);
-          }
-        }
-      }
-    }
-    // Solve U*X = Y; --> X (X is modified B)
-    for (int k = n - 1; k >= 0; k--) {
-      double mult = 1 / LU.getQuick(k, k);
-      if (mult != 1) {
-        for (int j = 0; j < nx; j++) {
-          //B[k][j] /= LU[k][k];
-          B.setQuick(k, j, B.getQuick(k, j) * mult);
-        }
-      }
-      for (int i = 0; i < k; i++) {
-        mult = LU.getQuick(i, k);
-        if (mult != 0) {
-          for (int j = 0; j < nx; j++) {
-            //B[i][j] -= B[k][j]*LU[i][k];
-            B.setQuick(i, j, B.getQuick(i, j) - B.getQuick(k, j) * mult);
-          }
-        }
-      }
-    }
-  }
-   */
-
-  /**
-   * Returns a String with (propertyName, propertyValue) pairs. Useful for debugging or to quickly get the rough
-   * picture. For example,
-   * <pre>
-   * rank          : 3
-   * trace         : 0
-   * </pre>
-   */
-  public String toString() {
-    StringBuilder buf = new StringBuilder();
-
-    buf.append("-----------------------------------------------------------------------------\n");
-    buf.append("LUDecompositionQuick(A) --> isNonSingular(A), det(A), pivot, L, U, inverse(A)\n");
-    buf.append("-----------------------------------------------------------------------------\n");
-
-    buf.append("isNonSingular = ");
-    String unknown = "Illegal operation or error: ";
-    try {
-      buf.append(String.valueOf(this.isNonSingular));
-    } catch (IllegalArgumentException exc) {
-      buf.append(unknown).append(exc.getMessage());
-    }
-
-    buf.append("\ndet = ");
-    try {
-      buf.append(String.valueOf(this.det()));
-    } catch (IllegalArgumentException exc) {
-      buf.append(unknown).append(exc.getMessage());
-    }
-
-    buf.append("\npivot = ");
-    try {
-      buf.append(String.valueOf(new IntArrayList(this.piv)));
-    } catch (IllegalArgumentException exc) {
-      buf.append(unknown).append(exc.getMessage());
-    }
-
-    buf.append("\n\nL = ");
-    try {
-      buf.append(String.valueOf(this.getL()));
-    } catch (IllegalArgumentException exc) {
-      buf.append(unknown).append(exc.getMessage());
-    }
-
-    buf.append("\n\nU = ");
-    try {
-      buf.append(String.valueOf(this.getU()));
-    } catch (IllegalArgumentException exc) {
-      buf.append(unknown).append(exc.getMessage());
-    }
-
-    buf.append("\n\ninverse(A) = ");
-    DoubleMatrix2D identity = DenseDoubleMatrix2D.identity(lu.rows());
-    try {
-      this.solve(identity);
-      buf.append(String.valueOf(identity));
-    } catch (IllegalArgumentException exc) {
-      buf.append(unknown).append(exc.getMessage());
-    }
-
-    return buf.toString();
-  }
-
-  /**
-   * Modifies the matrix to be an upper triangular matrix.
-   *
-   * @return <tt>A</tt> (for convenience only).
-   */
-  protected static DoubleMatrix2D upperTriangular(DoubleMatrix2D A) {
-    int rows = A.rows();
-    int columns = A.columns();
-    int min = Math.min(rows, columns);
-    for (int r = min; --r >= 0;) {
-      for (int c = min; --c >= 0;) {
-        if (r > c) {
-          A.setQuick(r, c, 0);
-        }
-      }
-    }
-    if (columns < rows) {
-      A.viewPart(min, 0, rows - min, columns).assign(0);
-    }
-
-    return A;
-  }
-
-}
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/Property.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/Property.java
index 5ba62406..42f459c9 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/Property.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/Property.java
@@ -366,11 +366,6 @@ public static boolean isPositive(DoubleMatrix2D a) {
     return true;
   }
 
-  /** A matrix <tt>A</tt> is <i>singular</i> if it has no inverse, that is, iff <tt>det(A)==0</tt>. */
-  public boolean isSingular(DoubleMatrix2D a) {
-    return Math.abs(Algebra.det(a)) < tolerance();
-  }
-
   /**
    * A square matrix <tt>A</tt> is <i>skew-symmetric</i> if <tt>A = -transpose(A)</tt>, that is <tt>A[i,j] ==
    * -A[j,i]</tt>.
@@ -651,242 +646,6 @@ public double tolerance() {
     return tolerance;
   }
 
-  /**
-   * Returns summary information about the given matrix <tt>A</tt>. That is a String with (propertyName, propertyValue)
-   * pairs. Useful for debugging or to quickly get the rough picture of a matrix. For example,
-   * <pre>
-   * density                      : 0.9
-   * isDiagonal                   : false
-   * isDiagonallyDominantByRow    : false
-   * isDiagonallyDominantByColumn : false
-   * isIdentity                   : false
-   * isLowerBidiagonal            : false
-   * isLowerTriangular            : false
-   * isNonNegative                : true
-   * isOrthogonal                 : Illegal operation or error: Matrix must be square.
-   * isPositive                   : true
-   * isSingular                   : Illegal operation or error: Matrix must be square.
-   * isSkewSymmetric              : Illegal operation or error: Matrix must be square.
-   * isSquare                     : false
-   * isStrictlyLowerTriangular    : false
-   * isStrictlyTriangular         : false
-   * isStrictlyUpperTriangular    : false
-   * isSymmetric                  : Illegal operation or error: Matrix must be square.
-   * isTriangular                 : false
-   * isTridiagonal                : false
-   * isUnitTriangular             : false
-   * isUpperBidiagonal            : false
-   * isUpperTriangular            : false
-   * isZero                       : false
-   * lowerBandwidth               : Illegal operation or error: Matrix must be square.
-   * semiBandwidth                : Illegal operation or error: Matrix must be square.
-   * upperBandwidth               : Illegal operation or error: Matrix must be square.
-   * </pre>
-   */
-  public String toString(DoubleMatrix2D a) {
-    Map<String, String> messages = new TreeMap<String, String>();
-
-    // determine properties
-    String name = "density";
-    String unknown = "Illegal operation or error: ";
-    try {
-      messages.put(name, String.valueOf(density(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    // determine properties
-    name = "isDiagonal";
-    try {
-      messages.put(name, String.valueOf(isDiagonal(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    // determine properties
-    name = "isDiagonallyDominantByRow";
-    try {
-      messages.put(name, String.valueOf(isDiagonallyDominantByRow(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    // determine properties
-    name = "isDiagonallyDominantByColumn";
-    try {
-      messages.put(name, String.valueOf(isDiagonallyDominantByColumn(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isIdentity";
-    try {
-      messages.put(name, String.valueOf(isIdentity(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isLowerBidiagonal";
-    try {
-      messages.put(name, String.valueOf(isLowerBidiagonal(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isLowerTriangular";
-    try {
-      messages.put(name, String.valueOf(isLowerTriangular(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isNonNegative";
-    try {
-      messages.put(name, String.valueOf(isNonNegative(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isOrthogonal";
-    try {
-      messages.put(name, String.valueOf(isOrthogonal(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isPositive";
-    try {
-      messages.put(name, String.valueOf(isPositive(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isSingular";
-    try {
-      messages.put(name, String.valueOf(isSingular(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isSkewSymmetric";
-    try {
-      messages.put(name, String.valueOf(isSkewSymmetric(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isSquare";
-    try {
-      messages.put(name, String.valueOf(isSquare(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isStrictlyLowerTriangular";
-    try {
-      messages.put(name, String.valueOf(isStrictlyLowerTriangular(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isStrictlyTriangular";
-    try {
-      messages.put(name, String.valueOf(isStrictlyTriangular(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isStrictlyUpperTriangular";
-    try {
-      messages.put(name, String.valueOf(isStrictlyUpperTriangular(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isSymmetric";
-    try {
-      messages.put(name, String.valueOf(isSymmetric(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isTriangular";
-    try {
-      messages.put(name, String.valueOf(isTriangular(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isTridiagonal";
-    try {
-      messages.put(name, String.valueOf(isTridiagonal(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isUnitTriangular";
-    try {
-      messages.put(name, String.valueOf(isUnitTriangular(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isUpperBidiagonal";
-    try {
-      messages.put(name, String.valueOf(isUpperBidiagonal(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isUpperTriangular";
-    try {
-      messages.put(name, String.valueOf(isUpperTriangular(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "isZero";
-    try {
-      messages.put(name, String.valueOf(isZero(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "lowerBandwidth";
-    try {
-      messages.put(name, String.valueOf(lowerBandwidth(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "semiBandwidth";
-    try {
-      messages.put(name, String.valueOf(semiBandwidth(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    name = "upperBandwidth";
-    try {
-      messages.put(name, String.valueOf(upperBandwidth(a)));
-    } catch (IllegalArgumentException exc) {
-      messages.put(name, unknown + exc.getMessage());
-    }
-
-    // determine padding for nice formatting
-    int maxLength = 0;
-    for (String key : messages.keySet()) {
-      maxLength = Math.max(key.length(), maxLength);
-    }
-    String format = String.format(Locale.ENGLISH, "\\%%ds: \\%s\n", maxLength);
-
-    Formatter r = new Formatter();
-    for (Map.Entry<String, String> entry : messages.entrySet()) {
-      r.format(format, maxLength, entry.getKey(), entry.getValue());
-    }
-    return r.toString();
-  }
-
   /**
    * The <i>upper bandwidth</i> of a square matrix <tt>A</tt> is the maximum <tt>j-i</tt> for which <tt>A[i,j]</tt> is
    * nonzero and <tt>j &gt; i</tt>. A <i>banded</i> matrix has a "band" about the diagonal. Diagonal, tridiagonal and
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/QRDecomposition.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/QRDecomposition.java
index 621c11e0..e69de29b 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/QRDecomposition.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/linalg/QRDecomposition.java
@@ -1,291 +0,0 @@
-/*
-Copyright ï¿½ 1999 CERN - European Organization for Nuclear Research.
-Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose 
-is hereby granted without fee, provided that the above copyright notice appear in all copies and 
-that both that copyright notice and this permission notice appear in supporting documentation. 
-CERN makes no representations about the suitability of this software for any purpose. 
-It is provided "as is" without expressed or implied warranty.
-*/
-package org.apache.mahout.math.matrix.linalg;
-
-import java.io.Serializable;
-
-import org.apache.mahout.math.function.Functions;
-import org.apache.mahout.math.matrix.DoubleMatrix1D;
-import org.apache.mahout.math.matrix.DoubleMatrix2D;
-import org.apache.mahout.math.matrix.impl.DenseDoubleMatrix2D;
-
-/**
- For an <tt>m x n</tt> matrix <tt>A</tt> with <tt>m >= n</tt>, the QR decomposition is an <tt>m x n</tt>
- orthogonal matrix <tt>Q</tt> and an <tt>n x n</tt> upper triangular matrix <tt>R</tt> so that
- <tt>A = Q*R</tt>.
- <P>
- The QR decompostion always exists, even if the matrix does not have
- full rank, so the constructor will never fail.  The primary use of the
- QR decomposition is in the least squares solution of nonsquare systems
- of simultaneous linear equations.  This will fail if <tt>isFullRank()</tt>
- returns <tt>false</tt>.
- */
-
-/** @deprecated until unit tests are in place.  Until this time, this class/interface is unsupported. */
-@Deprecated
-public class QRDecomposition implements Serializable {
-
-  /** Array for internal storage of decomposition. */
-  private final DoubleMatrix2D QR;
-  //private double[][] QR;
-
-  /** Row and column dimensions. */
-  private final int m;
-  private final int n;
-
-  /** Array for internal storage of diagonal of R. */
-  private final DoubleMatrix1D Rdiag;
-
-  /**
-   * Constructs and returns a new QR decomposition object;  computed by Householder reflections; The decomposed matrices
-   * can be retrieved via instance methods of the returned decomposition object.
-   *
-   * @param A A rectangular matrix.
-   * @throws IllegalArgumentException if <tt>A.rows() < A.columns()</tt>.
-   */
-
-  public QRDecomposition(DoubleMatrix2D A) {
-    Property.checkRectangular(A);
-
-    // Initialize.
-    QR = A.copy();
-    m = A.rows();
-    n = A.columns();
-    Rdiag = A.like1D(n);
-    //Rdiag = new double[n];
-    //org.apache.mahout.math.function.DoubleDoubleFunction hypot = Algebra.hypotFunction();
-
-    // precompute and cache some views to avoid regenerating them time and again
-    DoubleMatrix1D[] QRcolumns = new DoubleMatrix1D[n];
-    DoubleMatrix1D[] QRcolumnsPart = new DoubleMatrix1D[n];
-    for (int k = 0; k < n; k++) {
-      QRcolumns[k] = QR.viewColumn(k);
-      QRcolumnsPart[k] = QR.viewColumn(k).viewPart(k, m - k);
-    }
-
-    // Main loop.
-    for (int k = 0; k < n; k++) {
-      //DoubleMatrix1D QRcolk = QR.viewColumn(k).viewPart(k,m-k);
-      // Compute 2-norm of k-th column without under/overflow.
-      double nrm = 0;
-      //if (k<m) nrm = QRcolumnsPart[k].aggregate(hypot,F.identity);
-
-      for (int i = k; i < m; i++) { // fixes bug reported by hong.44@osu.edu
-        nrm = Algebra.hypot(nrm, QR.getQuick(i, k));
-      }
-
-
-      if (nrm != 0.0) {
-        // Form k-th Householder vector.
-        if (QR.getQuick(k, k) < 0) {
-          nrm = -nrm;
-        }
-        QRcolumnsPart[k].assign(Functions.div(nrm));
-        /*
-        for (int i = k; i < m; i++) {
-           QR[i][k] /= nrm;
-        }
-        */
-
-        QR.setQuick(k, k, QR.getQuick(k, k) + 1);
-
-        // Apply transformation to remaining columns.
-        for (int j = k + 1; j < n; j++) {
-          DoubleMatrix1D QRcolj = QR.viewColumn(j).viewPart(k, m - k);
-          double s = QRcolumnsPart[k].zDotProduct(QRcolj);
-          /*
-          // fixes bug reported by John Chambers
-          DoubleMatrix1D QRcolj = QR.viewColumn(j).viewPart(k,m-k);
-          double s = QRcolumnsPart[k].zDotProduct(QRcolumns[j]);
-          double s = 0.0;
-          for (int i = k; i < m; i++) {
-            s += QR[i][k]*QR[i][j];
-          }
-          */
-          s = -s / QR.getQuick(k, k);
-          //QRcolumnsPart[j].assign(QRcolumns[k], F.plusMult(s));
-
-          for (int i = k; i < m; i++) {
-            QR.setQuick(i, j, QR.getQuick(i, j) + s * QR.getQuick(i, k));
-          }
-
-        }
-      }
-      Rdiag.setQuick(k, -nrm);
-    }
-  }
-
-  /**
-   * Returns the Householder vectors <tt>H</tt>.
-   *
-   * @return A lower trapezoidal matrix whose columns define the householder reflections.
-   */
-  public DoubleMatrix2D getH() {
-    return Algebra.trapezoidalLower(QR.copy());
-  }
-
-  /**
-   * Generates and returns the (economy-sized) orthogonal factor <tt>Q</tt>.
-   *
-   * @return <tt>Q</tt>
-   */
-  public DoubleMatrix2D getQ() {
-    DoubleMatrix2D Q = QR.like();
-    //double[][] Q = X.getArray();
-    for (int k = n - 1; k >= 0; k--) {
-      DoubleMatrix1D QRcolk = QR.viewColumn(k).viewPart(k, m - k);
-      Q.setQuick(k, k, 1);
-      for (int j = k; j < n; j++) {
-        if (QR.getQuick(k, k) != 0) {
-          DoubleMatrix1D Qcolj = Q.viewColumn(j).viewPart(k, m - k);
-          double s = QRcolk.zDotProduct(Qcolj);
-          s = -s / QR.getQuick(k, k);
-          Qcolj.assign(QRcolk, Functions.plusMult(s));
-        }
-      }
-    }
-    return Q;
-  }
-
-  /**
-   * Returns the upper triangular factor, <tt>R</tt>.
-   *
-   * @return <tt>R</tt>
-   */
-  public DoubleMatrix2D getR() {
-    DoubleMatrix2D R = QR.like(n, n);
-    for (int i = 0; i < n; i++) {
-      for (int j = 0; j < n; j++) {
-        if (i < j) {
-          R.setQuick(i, j, QR.getQuick(i, j));
-        } else if (i == j) {
-          R.setQuick(i, j, Rdiag.getQuick(i));
-        } else {
-          R.setQuick(i, j, 0);
-        }
-      }
-    }
-    return R;
-  }
-
-  /**
-   * Returns whether the matrix <tt>A</tt> has full rank.
-   *
-   * @return true if <tt>R</tt>, and hence <tt>A</tt>, has full rank.
-   */
-  public boolean hasFullRank() {
-    for (int j = 0; j < n; j++) {
-      if (Rdiag.getQuick(j) == 0) {
-        return false;
-      }
-    }
-    return true;
-  }
-
-  /**
-   * Least squares solution of <tt>A*X = B</tt>; <tt>returns X</tt>.
-   *
-   * @param B A matrix with as many rows as <tt>A</tt> and any number of columns.
-   * @return <tt>X</tt> that minimizes the two norm of <tt>Q*R*X - B</tt>.
-   * @throws IllegalArgumentException if <tt>B.rows() != A.rows()</tt>.
-   * @throws IllegalArgumentException if <tt>!this.hasFullRank()</tt> (<tt>A</tt> is rank deficient).
-   */
-  public DoubleMatrix2D solve(DoubleMatrix2D B) {
-    if (B.rows() != m) {
-      throw new IllegalArgumentException("Matrix row dimensions must agree.");
-    }
-    if (!this.hasFullRank()) {
-      throw new IllegalArgumentException("Matrix is rank deficient.");
-    }
-
-    // Copy right hand side
-    int nx = B.columns();
-    DoubleMatrix2D X = B.copy();
-
-    // Compute Y = transpose(Q)*B
-    for (int k = 0; k < n; k++) {
-      for (int j = 0; j < nx; j++) {
-        double s = 0.0;
-        for (int i = k; i < m; i++) {
-          s += QR.getQuick(i, k) * X.getQuick(i, j);
-        }
-        s = -s / QR.getQuick(k, k);
-        for (int i = k; i < m; i++) {
-          X.setQuick(i, j, X.getQuick(i, j) + s * QR.getQuick(i, k));
-        }
-      }
-    }
-    // Solve R*X = Y;
-    for (int k = n - 1; k >= 0; k--) {
-      for (int j = 0; j < nx; j++) {
-        X.setQuick(k, j, X.getQuick(k, j) / Rdiag.getQuick(k));
-      }
-      for (int i = 0; i < k; i++) {
-        for (int j = 0; j < nx; j++) {
-          X.setQuick(i, j, X.getQuick(i, j) - X.getQuick(k, j) * QR.getQuick(i, k));
-        }
-      }
-    }
-    return X.viewPart(0, 0, n, nx);
-  }
-
-  /**
-   * Returns a String with (propertyName, propertyValue) pairs. Useful for debugging or to quickly get the rough
-   * picture. For example,
-   * <pre>
-   * rank          : 3
-   * trace         : 0
-   * </pre>
-   */
-  public String toString() {
-    StringBuilder buf = new StringBuilder();
-
-    buf.append("-----------------------------------------------------------------\n");
-    buf.append("QRDecomposition(A) --> hasFullRank(A), H, Q, R, pseudo inverse(A)\n");
-    buf.append("-----------------------------------------------------------------\n");
-
-    buf.append("hasFullRank = ");
-    String unknown = "Illegal operation or error: ";
-    try {
-      buf.append(String.valueOf(this.hasFullRank()));
-    } catch (IllegalArgumentException exc) {
-      buf.append(unknown).append(exc.getMessage());
-    }
-
-    buf.append("\n\nH = ");
-    try {
-      buf.append(String.valueOf(this.getH()));
-    } catch (IllegalArgumentException exc) {
-      buf.append(unknown).append(exc.getMessage());
-    }
-
-    buf.append("\n\nQ = ");
-    try {
-      buf.append(String.valueOf(this.getQ()));
-    } catch (IllegalArgumentException exc) {
-      buf.append(unknown).append(exc.getMessage());
-    }
-
-    buf.append("\n\nR = ");
-    try {
-      buf.append(String.valueOf(this.getR()));
-    } catch (IllegalArgumentException exc) {
-      buf.append(unknown).append(exc.getMessage());
-    }
-
-    buf.append("\n\npseudo inverse(A) = ");
-    try {
-      buf.append(String.valueOf(this.solve(DenseDoubleMatrix2D.identity(QR.rows()))));
-    } catch (IllegalArgumentException exc) {
-      buf.append(unknown).append(exc.getMessage());
-    }
-
-    return buf.toString();
-  }
-}
