diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/Item.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/Item.java
index b56de2e8..28b95f99 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/Item.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/Item.java
@@ -1,3 +1,201 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Copyright (c) OSGi Alliance (2009). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.jmx;
+
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+import javax.management.openmbean.ArrayType;
+import javax.management.openmbean.CompositeType;
+import javax.management.openmbean.OpenDataException;
+import javax.management.openmbean.OpenType;
+import javax.management.openmbean.TabularType;
+
+/**
+ * The item class enables the definition of open types in the appropriate
+ * interfaces.
+ * 
+ * This class contains a number of methods that make it possible to create open
+ * types for {@link CompositeType}, {@link TabularType}, and {@link ArrayType}.
+ * The normal creation throws a checked exception, making it impossible to use
+ * them in a static initializer. They constructors are also not very suitable
+ * for static construction.
+ * 
+ * 
+ * An Item instance describes an item in a Composite Type. It groups the triplet
+ * of name, description, and Open Type. These Item instances allows the
+ * definitions of an item to stay together.
+ * 
+ * @version $Rev$
+ * @Immutable
+ */
+public class Item {
+
+	/**
+	 * The name of this item.
+	 */
+	private final String name;
+
+	/**
+	 * The description of this item.
+	 */
+	private final String description;
+
+	/**
+	 * The type of this item.
+	 */
+	private final OpenType type;
+
+	/**
+	 * Create a triple of name, description, and type. This triplet is used in
+	 * the creation of a Composite Type.
+	 * 
+	 * @param name
+	 *            The name of the item.
+	 * @param description
+	 *            The description of the item.
+	 * @param type
+	 *            The Open Type of this item.
+	 * @param restrictions
+	 *            Ignored, contains list of restrictions
+	 */
+	public Item(String name, String description, OpenType type,
+			String... restrictions) {
+		this.name = name;
+		this.description = description;
+		this.type = type;
+	}
+
+	/**
+	 * 
+	 */
+
+	/**
+	 * Create a Tabular Type.
+	 * 
+	 * @param name
+	 *            The name of the Tabular Type.
+	 * @param description
+	 *            The description of the Tabular Type.
+	 * @param rowType
+	 *            The Open Type for a row
+	 * @param index
+	 *            The names of the items that form the index .
+	 * @return A new Tabular Type composed from the parameters.
+	 * @throws RuntimeException
+	 *             when the Tabular Type throws an OpenDataException
+	 */
+	static public TabularType tabularType(String name, String description,
+			CompositeType rowType, String... index) {
+		try {
+			return new TabularType(name, description, rowType, index);
+		} catch (OpenDataException e) {
+			throw new RuntimeException(e);
+		}
+	}
+
+	/**
+	 * Create a Composite Type
+	 * 
+	 * @param name
+	 *            The name of the Tabular Type.
+	 * @param description
+	 *            The description of the Tabular Type.
+	 * @param items
+	 *            The items that describe the composite type.
+	 * @return a new Composite Type
+	 * @throws RuntimeException
+	 *             when the Tabular Type throws an OpenDataException
+	 */
+	static public CompositeType compositeType(String name, String description,
+			Item... items) {
+		return extend(null, name, description, items);
+	}
+
+	/**
+	 * Return a new Array Type.
+	 * 
+	 * @param dim
+	 *            The dimension
+	 * @param elementType
+	 *            The element type
+	 * @return A new Array Type
+	 */
+	public static ArrayType arrayType(int dim, OpenType elementType) {
+		try {
+			return new ArrayType(dim, elementType);
+		} catch (OpenDataException e) {
+			throw new RuntimeException(e);
+		}
+	}
+
+	/**
+	 * Extend a Composite Type by adding new items. Items can override items in
+	 * the parent type.
+	 * 
+	 * @param parent
+	 *            The parent type, can be <code>null</code>
+	 * @param name
+	 *            The name of the type
+	 * @param description
+	 *            The description of the type
+	 * @param items
+	 *            The items that should be added/override to the parent type
+	 * @return A new Composite Type that extends the parent type
+	 * @throws RuntimeException
+	 *             when an OpenDataException is thrown
+	 */
+	public static CompositeType extend(CompositeType parent, String name,
+			String description, Item... items) {
+		Set<Item> all = new LinkedHashSet<Item>();
+
+		if (parent != null) {
+			for (Object nm : parent.keySet()) {
+				String key = (String) nm;
+				all.add(new Item(key, parent.getDescription(key),
+						parent.getType(key)));
+			}
+		}
+
+		Collections.addAll(all, items);
+
+		int size = all.size();
+		String names[] = new String[size];
+		String descriptions[] = new String[size];
+		OpenType types[] = new OpenType[size];
+
+		int m = 0;
+		for (Item item : all) {
+			names[m] = item.name;
+			descriptions[m] = item.description;
+			types[m] = item.type;
+			m++;
+		}
+
+		try {
+			return new CompositeType(name, description, names, descriptions,
+					types);
+		} catch (OpenDataException e) {
+			throw new RuntimeException(e);
+		}
+	}
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/JmxConstants.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/JmxConstants.java
index e69de29b..7299e452 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/JmxConstants.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/JmxConstants.java
@@ -0,0 +1,317 @@
+/*
+ * Copyright (c) OSGi Alliance (2009). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.jmx;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+import javax.management.openmbean.ArrayType;
+import javax.management.openmbean.CompositeType;
+import javax.management.openmbean.SimpleType;
+import javax.management.openmbean.TabularType;
+
+/**
+ * Constants for OSGi JMX Specification.
+ * 
+ * Additionally, this class contains a number of utility types that are used in
+ * different places in the specification. These are {@link #LONG_ARRAY_TYPE},
+ * {@link #STRING_ARRAY_TYPE}, and {@link #PROPERTIES_TYPE}.
+ * 
+ * @version $Rev$
+ * @Immutable
+ */
+public class JmxConstants {
+
+	/*
+	 * Empty constructor to make sure this is not used as an object.
+	 */
+	private JmxConstants() {
+		// empty
+	}
+
+	/**
+	 * The MBean Open type for an array of strings
+	 */
+	public static final ArrayType		STRING_ARRAY_TYPE	= Item
+																	.arrayType(
+																			1,
+																			SimpleType.STRING);
+	/**
+	 * The MBean Open type for an array of longs
+	 */
+	public static final ArrayType		LONG_ARRAY_TYPE		= Item
+																	.arrayType(
+																			1,
+																			SimpleType.LONG);
+
+	/**
+	 * For an encoded array we need to start with ARRAY_OF. This must be
+	 * followed by one of the names in {@link #SCALAR}.
+	 * 
+	 */
+	public final static String			ARRAY_OF			= "Array of ";
+
+	/**
+	 * For an encoded vector we need to start with ARRAY_OF. This must be
+	 * followed by one of the names in {@link #SCALAR}.
+	 */
+	public final static String			VECTOR_OF			= "Vector of ";
+
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * {@link java.lang.String}
+	 */
+	public static final String			STRING				= "String";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * {@link java.lang.Integer}
+	 */
+	public static final String			INTEGER				= "Integer";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * {@link java.lang.Long}
+	 */
+	public static final String			LONG				= "Long";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * {@link java.lang.Float}
+	 */
+	public static final String			FLOAT				= "Float";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * {@link java.lang.Double}
+	 */
+	public static final String			DOUBLE				= "Double";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * {@link java.lang.Byte}
+	 */
+	public static final String			BYTE				= "Byte";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * {@link java.lang.Short}
+	 */
+	public static final String			SHORT				= "Short";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * {@link java.lang.Character}
+	 */
+	public static final String			CHARACTER			= "Character";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * {@link java.lang.Boolean}
+	 */
+	public static final String			BOOLEAN				= "Boolean";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * {@link java.math.BigDecimal}
+	 */
+	public static final String			BIGDECIMAL			= "BigDecimal";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * {@link java.math.BigInteger}
+	 */
+	public static final String			BIGINTEGER			= "BigInteger";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * the <code>double</code> primitive type.
+	 */
+	public static final String			P_DOUBLE			= "double";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * the <code>float</code> primitive type.
+	 */
+	public static final String			P_FLOAT				= "float";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * the <code>long</code> primitive type.
+	 */
+	public static final String			P_LONG				= "long";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * the <code>int</code> primitive type.
+	 */
+	public static final String			P_INT				= "int";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * the <code>short</code> primitive type.
+	 */
+	public static final String			P_SHORT				= "short";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * the <code>byte</code> primitive type.
+	 */
+	public static final String			P_BYTE				= "byte";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * the <code>char</code> primitive type.
+	 */
+	public static final String			P_CHAR				= "char";
+	/**
+	 * Value for {@link #PROPERTY_TYPE} <code>Type</code> value in the case of
+	 * the <code>boolean</code> primitive type.
+	 */
+	public static final String			P_BOOLEAN			= "boolean";
+
+	/**
+	 * A set of all scalars that can be used in the {@link #TYPE} property of a
+	 * {@link #PROPERTIES_TYPE}. This contains the following names:
+	 * <ul>
+	 * <li>{@link #BIGDECIMAL}</li>
+	 * <li>{@link #BIGINTEGER}</li>
+	 * <li>{@link #BOOLEAN}</li>
+	 * <li>{@link #BYTE}</li>
+	 * <li>{@link #CHARACTER}</li>
+	 * <li>{@link #DOUBLE}</li>
+	 * <li>{@link #FLOAT}</li>
+	 * <li>{@link #INTEGER}</li>
+	 * <li>{@link #LONG}</li>
+	 * <li>{@link #SHORT}</li>
+	 * <li>{@link #STRING}</li>
+	 * <li>{@link #P_BYTE}</li>
+	 * <li>{@link #P_CHAR}</li>
+	 * <li>{@link #P_DOUBLE}</li>
+	 * <li>{@link #P_FLOAT}</li>
+	 * <li>{@link #P_INT}</li>
+	 * <li>{@link #P_LONG}</li>
+	 * <li>{@link #P_SHORT}</li>
+	 */
+	public final static List<String>	SCALAR				= Collections
+																	.unmodifiableList(Arrays
+																			.asList(
+																					STRING,
+																					INTEGER,
+																					LONG,
+																					FLOAT,
+																					DOUBLE,
+																					BYTE,
+																					SHORT,
+																					CHARACTER,
+																					BOOLEAN,
+																					BIGDECIMAL,
+																					BIGINTEGER,
+																					P_BYTE,
+																					P_CHAR,
+																					P_SHORT,
+																					P_INT,
+																					P_LONG,
+																					P_DOUBLE,
+																					P_FLOAT));
+	/**
+	 * The key KEY.
+	 */
+	public static final String			KEY					= "Key";
+	/**
+	 * The key of a property. The key is {@link #KEY} and the type is
+	 * {@link SimpleType#STRING}.
+	 */
+	public static final Item			KEY_ITEM			= new Item(
+																	KEY,
+																	"The key of the property",
+																	SimpleType.STRING);
+
+	/**
+	 * The key VALUE.
+	 */
+	public static final String			VALUE				= "Value";
+
+	/**
+	 * The value of a property. The key is {@link #VALUE} and the type is
+	 * {@link SimpleType#STRING}. A value will be encoded by the string given in
+	 * {@link #TYPE}. The syntax for this type is given in {@link #TYPE_ITEM}.
+	 */
+	public static final Item			VALUE_ITEM			= new Item(
+																	VALUE,
+																	"The value of the property",
+																	SimpleType.STRING);
+
+	/**
+	 * The key PROPERTY_TYPE.
+	 * 
+	 * ### can we call this value PropertyType and service type ServiceType?
+	 */
+	public static final String			TYPE				= "Type";
+
+	/**
+	 * The type of the property. The key is {@link #TYPE} and the type is
+	 * {@link SimpleType#STRING}. This string must follow the following syntax:
+	 * 
+	 * TYPE ::= ( 'Array of ' | 'Vector of ' )? {@link #SCALAR}
+	 * 
+	 * ### why can't we just use the class name?
+	 * 
+	 * ### why do we have to distinguish between primitives and wrappers?
+	 */
+	public static final Item			TYPE_ITEM			= new Item(
+																	TYPE,
+																	"The type of the property",
+																	SimpleType.STRING,
+																	STRING,
+																	INTEGER,
+																	LONG,
+																	FLOAT,
+																	DOUBLE,
+																	BYTE,
+																	SHORT,
+																	CHARACTER,
+																	BOOLEAN,
+																	BIGDECIMAL,
+																	BIGINTEGER,
+																	P_DOUBLE,
+																	P_FLOAT,
+																	P_LONG,
+																	P_INT,
+																	P_SHORT,
+																	P_CHAR,
+																	P_BYTE,
+																	P_BOOLEAN);
+
+	/**
+	 * A Composite Type describing a a single property. A property consists of
+	 * the following items {@link #KEY_ITEM}, {@link #VALUE_ITEM}, and
+	 * {@link #TYPE_ITEM}.
+	 */
+	public static final CompositeType	PROPERTY_TYPE		= Item
+																	.compositeType(
+																			"PROPERTY",
+																			"This type encapsulates a key/value pair",
+																			KEY_ITEM,
+																			VALUE_ITEM,
+																			TYPE_ITEM);
+
+	/**
+	 * Describes a map with properties. The row type is {@link #PROPERTY_TYPE}.
+	 * The index is defined to the {@link #KEY} of the property.
+	 */
+	public static final TabularType		PROPERTIES_TYPE		= Item
+																	.tabularType(
+																			"PROPERTIES",
+																			"A table of PROPERTY",
+																			PROPERTY_TYPE,
+																			KEY);
+
+	/**
+	 * The domain name of the core OSGi MBeans
+	 */
+	public static final String			OSGI_CORE			= "osgi.core";
+
+	/**
+	 * The domain name of the selected OSGi compendium MBeans
+	 */
+	public static final String			OSGI_COMPENDIUM		= "osgi.compendium";
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/BundleRevisionsStateMBean.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/BundleRevisionsStateMBean.java
index 3f24d583..40db492f 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/BundleRevisionsStateMBean.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/BundleRevisionsStateMBean.java
@@ -1 +1,306 @@
   + native
+/*
+ * Copyright (c) OSGi Alliance (2010, 2011). All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.osgi.jmx.framework;
+
+import java.io.IOException;
+
+import javax.management.openmbean.ArrayType;
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeType;
+import javax.management.openmbean.SimpleType;
+import javax.management.openmbean.TabularType;
+
+import org.osgi.jmx.Item;
+import org.osgi.jmx.JmxConstants;
+
+/**
+ * This MBean represents the bundle wiring state.
+ *
+ * Note that not all information from the BundleWiring Java API is provided.
+ *
+ * Particularly, the limitations are:
+ *  - Cannot retrieve references to resources (e.g. class) of a particular bundle wiring.
+ */
+public interface BundleRevisionsStateMBean {
+    /*
+     * The Object Name for a Bundle Revisions MBean.
+     */
+    String OBJECTNAME = JmxConstants.OSGI_CORE
+        + ":type=wiringState,version=1.0";
+
+    /*
+     * Namespaces
+     *
+     */
+    String BUNDLE_NAMESPACE = "osgi.wiring.bundle";
+    String HOST_NAMESPACE = "osgi.wiring.host";
+    String PACKAGE_NAMESPACE = "osgi.wiring.package";
+
+    /*
+     * Items, CompositeData, TabularData, ArrayTypes
+     *
+     */
+    String KEY = "Key";
+    Item KEY_ITEM = new Item(KEY, "The directive key", SimpleType.STRING);
+
+    String VALUE = "Value";
+    Item VALUE_ITEM = new Item(VALUE, "The directive value",
+            SimpleType.STRING);
+
+    CompositeType DIRECTIVE_TYPE = Item.compositeType("DIRECTIVE",
+            "Describes a directive of a capability or requirement",
+            KEY_ITEM, VALUE_ITEM);
+    TabularType DIRECTIVES_TYPE = Item.tabularType("DIRECTIVES",
+            "Describes the directives of a capability or requirement",
+            DIRECTIVE_TYPE, KEY
+            );
+
+    String DIRECTIVES = "Directives";
+    Item DIRECTIVES_ITEM = new Item(DIRECTIVES,
+            "The directives of a capability or requirement",
+            DIRECTIVES_TYPE);
+
+    // REVIEW should we reuse from JmxConstants here or create our own?
+    TabularType ATTRIBUTES_TYPE = Item.tabularType("ATTRIBUTES",
+            "Describes attributes of a capability or requirement",
+            JmxConstants.PROPERTY_TYPE, JmxConstants.KEY
+            );
+    String ATTRIBUTES = "Attributes";
+    Item ATTRIBUTES_ITEM = new Item(ATTRIBUTES,
+            "The attributes of a capability or requirement",
+            ATTRIBUTES_TYPE);
+
+    String NAMESPACE = "Namespace";
+    Item NAMESPACE_ITEM = new Item(NAMESPACE,
+            "The namespace of a capability or requirement",
+            SimpleType.STRING);
+
+    CompositeType BUNDLE_REQUIREMENT_TYPE =
+        Item.compositeType("BUNDLE_REQUIREMENT",
+                "Describes the live wired requirements of a bundle",
+                ATTRIBUTES_ITEM, DIRECTIVES_ITEM, NAMESPACE_ITEM);
+
+    CompositeType BUNDLE_CAPABILITY_TYPE =
+        Item.compositeType("BUNDLE_CAPABILITY",
+                "Describes the live wired capabilities of a bundle",
+                ATTRIBUTES_ITEM, DIRECTIVES_ITEM, NAMESPACE_ITEM);
+
+    String PROVIDER_BUNDLE_ID = "ProviderBundleId";
+    Item PROVIDER_BUNDLE_ID_ITEM = new Item(PROVIDER_BUNDLE_ID,
+            "The identifier of the bundle that is the provider of the capability",
+            SimpleType.LONG);
+
+    String REQUIRER_BUNDLE_ID = "RequirerBundleId";
+    Item REQUIRER_BUNDLE_ID_ITEM = new Item(REQUIRER_BUNDLE_ID,
+            "The identifier of the bundle that is the requirer of the requirement",
+            SimpleType.LONG);
+
+    String BUNDLE_REQUIREMENT = "BundleRequirement";
+    Item BUNDLE_REQUIREMENT_ITEM = new Item(BUNDLE_REQUIREMENT,
+            "The wired requirements of a bundle",
+            BUNDLE_REQUIREMENT_TYPE);
+
+    String BUNDLE_CAPABILITY = "BundleCapability";
+    Item BUNDLE_CAPABILITY_ITEM = new Item(BUNDLE_CAPABILITY,
+            "The wired capabilities of a bundle",
+            BUNDLE_CAPABILITY_TYPE);
+
+    String PROVIDER_BUNDLE_REVISION_ID = "ProviderBundleRevisionId";
+    Item PROVIDER_BUNDLE_REVISION_ID_ITEM = new Item(PROVIDER_BUNDLE_REVISION_ID,
+            "A local id for the bundle revision that is the provider of the capability",
+            SimpleType.STRING);
+
+    String REQUIRER_BUNDLE_REVISION_ID = "RequirerBundleRevisionId";
+    Item REQUIRER_BUNDLE_REVISION_ID_ITEM =  new Item(REQUIRER_BUNDLE_REVISION_ID,
+            "A local id for the bundle revision that is the requirer of the requirement",
+            SimpleType.STRING);
+
+    /**
+     * Describes the live association between a provider of
+     *  a capability and a requirer of the corresponding requirement.
+     */
+    CompositeType BUNDLE_WIRE_TYPE =
+        Item.compositeType("BUNDLE_WIRE",
+                "Describes the live association between a provider and a requirer",
+                BUNDLE_REQUIREMENT_ITEM,
+                BUNDLE_CAPABILITY_ITEM,
+                PROVIDER_BUNDLE_ID_ITEM,
+                PROVIDER_BUNDLE_REVISION_ID_ITEM,
+                REQUIRER_BUNDLE_ID_ITEM,
+                REQUIRER_BUNDLE_REVISION_ID_ITEM
+                );
+    ArrayType BUNDLE_WIRES_TYPE_ARRAY =
+        Item.arrayType(1, BUNDLE_WIRE_TYPE);
+
+    String BUNDLE_REVISION_ID = "BundleRevisionId";
+    Item BUNDLE_REVISION_ID_ITEM = new Item(BUNDLE_REVISION_ID,
+            "The local identifier of the bundle revision",
+            SimpleType.STRING);
+
+    String BUNDLE_WIRES_TYPE = "BundleWiresType";
+    Item BUNDLE_WIRES_TYPE_ARRAY_ITEM = new Item(BUNDLE_WIRES_TYPE,
+            "The bundle wires of a bundle revision",
+            BUNDLE_WIRES_TYPE_ARRAY);
+
+    String BUNDLE_ID = "BundleId";
+    Item BUNDLE_ID_ITEM = new Item(BUNDLE_ID,
+            "The bundle identifier of the bundle revision",
+            SimpleType.LONG);
+
+    ArrayType REQUIREMENT_TYPE_ARRAY =
+        Item.arrayType(1, BUNDLE_REQUIREMENT_TYPE);
+    ArrayType CAPABILITY_TYPE_ARRAY =
+        Item.arrayType(1, BUNDLE_CAPABILITY_TYPE);
+
+    String REQUIREMENTS = "Requirements";
+    Item REQUIREMENTS_ITEM = new Item(REQUIREMENTS,
+            "The bundle requirements of a bundle revision wiring",
+            REQUIREMENT_TYPE_ARRAY);
+
+    String CAPABILITIES = "Capabilities";
+    Item CAPABILITIES_ITEM = new Item(CAPABILITIES,
+            "The bundle capabilities of a bundle revision wiring",
+            CAPABILITY_TYPE_ARRAY);
+
+    CompositeType BUNDLE_WIRING_TYPE =
+        Item.compositeType("BUNDLE_WIRING",
+                "Describes the runtime association between a provider and a requirer",
+                BUNDLE_ID_ITEM,               /* Long */
+                BUNDLE_REVISION_ID_ITEM,      /* Long (local scope) */
+                REQUIREMENTS_ITEM,            /* REQUIREMENT_TYPE [] */
+                CAPABILITIES_ITEM,            /* CAPABILITIES_TYPE [] */
+                BUNDLE_WIRES_TYPE_ARRAY_ITEM  /* BUNLDE_WIRE_TYPE [] */
+                );
+    ArrayType BUNDLE_WIRING_TYPE_ARRAY =
+        Item.arrayType(1, BUNDLE_WIRING_TYPE);
+
+    ArrayType REVISIONS_REQUIREMENT_TYPE_ARRAY =
+        Item.arrayType(2, BUNDLE_REQUIREMENT_TYPE);
+
+    ArrayType REVISIONS_CAPABILITY_TYPE_ARRAY =
+        Item.arrayType(2, BUNDLE_CAPABILITY_TYPE);
+
+
+    /**
+     * Returns the requirements for the current bundle revision.
+     * The ArrayType is typed by the {@link #REQUIREMENT_TYPE_ARRAY}.
+     *
+     * @param bundleId
+     * @param namespace
+     * @return the declared requirements for the current revision of <code>bundleId</code>
+     * and <code>namespace</code>
+     *
+     */
+    ArrayType getCurrentRevisionDeclaredRequirements(long bundleId,
+            String namespace) throws IOException;
+
+    /**
+     * Returns the capabilities for the current bundle revision.
+     * The ArrayType is typed by the {@link #CAPABILITY_TYPE_ARRAY}
+     *
+     * @param bundleId
+     * @param namespace
+     * @return the declared capabilities for the current revision of <code>bundleId</code>
+     * and <code>namespace</code>
+     */
+    ArrayType getCurrentRevisionDeclaredCapabilities(long bundleId,
+            String namespace) throws IOException;
+
+    /**
+     * Returns the bundle wiring for the current bundle revision.
+     * The ArrayType is typed by the {@link #BUNDLE_WIRING_TYPE}
+     *
+     * @param bundleId
+     * @param namespace
+     * @return the wires for the current revision of <code>bundleId</code>
+     * and <code>namespace</code>
+     */
+    CompositeData getCurrentWiring(long bundleId, String namespace) throws IOException;
+    CompositeData getCurrentWiringClosure(long rootBundleId) throws IOException;
+
+    /**
+     * Returns the requirements for all revisions of the bundle.
+     * The ArrayType is typed by the {@link #REVISIONS_REQUIREMENT_TYPE_ARRAY}.
+     * The requirements are in no particular order, and may change in
+     *  subsequent calls to this operation.
+     *
+     * @param bundleId
+     * @param namespace
+     * @param inUse
+     * @return the declared requirements for all revisions of <code>bundleId</code>
+     *
+     */
+    ArrayType getRevisionsDeclaredRequirements(long bundleId,
+            String namespace, boolean inUse) throws IOException;
+
+    /**
+     * Returns the capabilities for all revisions of the bundle.
+     * The ArrayType is typed by the {@link #REVISIONS_CAPABILITY_TYPE_ARRAY}
+     * The capabilities are in no particular order, and may change in
+     *  subsequent calls to this operation.
+     *
+     * @param bundleId
+     * @param namespace
+     * @param inUse
+     * @return the declared capabilities for all revisions of <code>bundleId</code>
+     */
+    ArrayType getRevisionsDeclaredCapabilities(long bundleId,
+            String namespace, boolean inUse) throws IOException;
+
+    /**
+     * Returns the bundle wirings for all revisions of the bundle.
+     * The ArrayType is typed by the {@link #BUNDLE_WIRING_TYPE_ARRAY}
+     * The bundle wirings are in no particular order, and may
+     *  change in subsequent calls to this operations.
+     *
+     * @param bundleId
+     * @param namespace
+     * @return the wires for all revisions of <code>bundleId</code>
+     */
+    ArrayType getRevisionsWiring(long bundleId, String namespace) throws IOException;
+
+    /**
+     * Returns a closure of all bundle wirings linked by their
+     *  bundle wires, starting at <code>rootBundleId</code>.
+     * The ArrayType is typed by the {@link #BUNDLE_WIRING_TYPE_ARRAY}
+     * The bundle wirings are in no particular order, and may
+     *  change in subsequent calls to this operation. Furthermore,
+     * the bundle wiring IDs are local and cannot be reused across invocations.
+     *
+     * @param rootBundleId
+     * @param namespace
+     * @return a closure of bundle wirings linked together by wires.
+     */
+    ArrayType getWiringClosure(long rootBundleId, String namespace) throws IOException;
+
+    /**
+     * Returns true if capability provided by <code>provider</code> matches
+     *  with the requirement being required by <code>requirer</code>.
+     * The <code>provider</code>'s CompositeType is typed by the
+     *  {@link #BUNDLE_CAPABILITY_TYPE}
+     * The <code>requirer</code>'s CompositeType is typed by the
+     *  {@link #BUNDLE_REQUIREMENT_TYPE}
+     *
+     * REVIEW This method would have worked better should the requirements and
+     *  capabilities have an ID
+     *
+     * @param requirer bundle id of the bundle requirer
+     * @param provider bundle id of the bundle provider
+     * @return true if capability matches with requirement.
+     */
+    boolean matches(CompositeType provider, CompositeType requirer) throws IOException;
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/BundleStateMBean.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/BundleStateMBean.java
index e69de29b..93f6d050 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/BundleStateMBean.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/BundleStateMBean.java
@@ -0,0 +1,698 @@
+/*
+ * Copyright (c) OSGi Alliance (2009, 2010). All Rights Reserved.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.jmx.framework;
+
+import java.io.IOException;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeType;
+import javax.management.openmbean.SimpleType;
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularType;
+
+import org.osgi.jmx.Item;
+import org.osgi.jmx.JmxConstants;
+
+/**
+ * This MBean represents the Bundle state of the framework. This MBean also
+ * emits events that clients can use to get notified of the changes in the
+ * bundle state of the framework.
+ *
+ * @version $Revision$
+ * @ThreadSafe
+ */
+public interface BundleStateMBean {
+	/**
+	 * The Object Name for a Bundle State MBean.
+	 */
+	String OBJECTNAME = JmxConstants.OSGI_CORE
+			+ ":type=bundleState,version=1.7";
+
+	/**
+	 * The key KEY, used in {@link #KEY_ITEM}.
+	 */
+	String KEY = "Key";
+
+	/**
+	 * The item describing the key of a bundle header entry. The key is
+	 * {@link #KEY} and the type is {@link SimpleType#STRING}.
+	 */
+	Item KEY_ITEM = new Item(KEY, "The bundle header key", SimpleType.STRING);
+	/**
+	 * The key VALUE, used in {@link #VALUE_ITEM}.
+	 */
+	String VALUE = "Value";
+	/**
+	 * The item describing the value of a bundle header entry. The key is
+	 * {@link #VALUE} and the type is {@link SimpleType#STRING}.
+	 */
+	Item VALUE_ITEM = new Item(VALUE, "The bundle header value",
+			SimpleType.STRING);
+
+	/**
+	 * The Composite Type describing an entry in bundle headers. It consists of
+	 * {@link #KEY_ITEM} and {@link #VALUE_ITEM}.
+	 */
+	CompositeType HEADER_TYPE = Item.compositeType("HEADER",
+			"This type encapsulates OSGi bundle header key/value pairs",
+			KEY_ITEM, VALUE_ITEM);
+
+	/**
+	 * The Tabular Type describing the type of the Tabular Data value that is
+	 * returned from {@link #getHeaders(long)} method. The primary item is
+	 * {@link #KEY_ITEM}.
+	 */
+	TabularType HEADERS_TYPE = Item.tabularType("HEADERS",
+																"The table of bundle headers",
+																HEADER_TYPE,
+																KEY);
+
+	/**
+	 * The key LOCATION, used in {@link #LOCATION_ITEM}.
+	 */
+	String LOCATION = "Location";
+	/**
+	 * The item containing the bundle location in {@link #BUNDLE_TYPE}. The key
+	 * is {@link #LOCATION} and the the type is {@link SimpleType#STRING}.
+	 */
+	Item LOCATION_ITEM = new Item(LOCATION, "The location of the bundle",
+			SimpleType.STRING);
+
+	/**
+	 * The key IDENTIFIER, used in {@link #IDENTIFIER_ITEM}.
+	 */
+	String IDENTIFIER = "Identifier";
+
+	/**
+	 * The item containing the bundle identifier in {@link #BUNDLE_TYPE}. The
+	 * key is {@link #IDENTIFIER} and the the type is {@link SimpleType#LONG}.
+	 */
+	Item IDENTIFIER_ITEM = new Item(IDENTIFIER, "The id of the bundle",
+			SimpleType.LONG);
+	/**
+	 * The key SYMBOLIC_NAME, used in {@link #SYMBOLIC_NAME_ITEM}.
+	 */
+	String SYMBOLIC_NAME = "SymbolicName";
+
+	/**
+	 * The item containing the symbolic name in {@link #BUNDLE_TYPE}. The key is
+	 * {@link #SYMBOLIC_NAME} and the the type is {@link SimpleType#STRING}.
+	 */
+	Item SYMBOLIC_NAME_ITEM = new Item(SYMBOLIC_NAME,
+			"The symbolic name of the bundle", SimpleType.STRING);
+	/**
+	 * The key VERSION, used in {@link #VERSION_ITEM}.
+	 */
+	String VERSION = "Version";
+
+	/**
+	 * The item containing the symbolic name in {@link #BUNDLE_TYPE}. The key is
+	 * {@link #SYMBOLIC_NAME} and the the type is {@link SimpleType#STRING}.
+	 */
+	Item VERSION_ITEM = new Item(VERSION, "The version of the bundle",
+			SimpleType.STRING);
+	/**
+	 * The key START_LEVEL, used in {@link #START_LEVEL_ITEM}.
+	 */
+	String START_LEVEL = "StartLevel";
+
+	/**
+	 * The item containing the start level in {@link #BUNDLE_TYPE}. The key is
+	 * {@link #START_LEVEL} and the the type is {@link SimpleType#INTEGER}.
+	 */
+	Item START_LEVEL_ITEM = new Item(START_LEVEL,
+			"The start level of the bundle", SimpleType.INTEGER);
+	/**
+	 * The key STATE, used in {@link #STATE_ITEM}.
+	 */
+	String STATE = "State";
+
+	/**
+	 * Constant INSTALLED for the {@link #STATE}
+	 */
+	String INSTALLED = "INSTALLED";
+	/**
+	 * Constant RESOLVED for the {@link #STATE}
+	 */
+	String RESOLVED = "RESOLVED";
+	/**
+	 * Constant STARTING for the {@link #STATE}
+	 */
+	String STARTING = "STARTING";
+	/**
+	 * Constant ACTIVE for the {@link #STATE}
+	 */
+	String ACTIVE = "ACTIVE";
+	/**
+	 * Constant STOPPING for the {@link #STATE}
+	 */
+	String STOPPING = "STOPPING";
+	/**
+	 * Constant UNINSTALLED for the {@link #STATE}
+	 */
+	String UNINSTALLED = "UNINSTALLED";
+	/**
+	 * Constant UNKNOWN for the {@link #STATE}
+	 */
+	String UNKNOWN = "UNKNOWN";
+	/**
+	 * The item containing the bundle state in {@link #BUNDLE_TYPE}. The key is
+	 * {@link #STATE} and the the type is {@link SimpleType#STRING}. The
+	 * returned values must be one of the following strings:
+	 * <ul>
+	 * <li>{@link #INSTALLED}</li>
+	 * <li>{@link #RESOLVED}</li>
+	 * <li>{@link #STARTING}</li>
+	 * <li>{@link #ACTIVE}</li>
+	 * <li>{@link #STOPPING}</li>
+	 * <li>{@link #UNINSTALLED}</li>
+	 * <li>{@link #UNKNOWN}</li>
+	 * </ul>
+	 */
+	Item STATE_ITEM = new Item(STATE, "The state of the bundle",
+			SimpleType.STRING, INSTALLED, RESOLVED, STARTING, ACTIVE, STOPPING,
+			UNINSTALLED, UNKNOWN);
+	/**
+	 * The key LAST_MODIFIED, used in {@link #LAST_MODIFIED_ITEM}.
+	 */
+	String LAST_MODIFIED = "LastModified";
+
+	/**
+	 * The item containing the last modified time in the {@link #BUNDLE_TYPE}.
+	 * The key is {@link #LAST_MODIFIED} and the the type is
+	 * {@link SimpleType#LONG}.
+	 */
+	Item LAST_MODIFIED_ITEM = new Item(LAST_MODIFIED,
+			"The last modification time of the bundle", SimpleType.LONG);
+	/**
+	 * The key PERSISTENTLY_STARTED, used in {@link #PERSISTENTLY_STARTED_ITEM}.
+	 */
+	String			PERSISTENTLY_STARTED		= "PersistentlyStarted";
+
+	/**
+	 * The item containing the indication of persistently started in
+	 * {@link #BUNDLE_TYPE}. The key is {@link #PERSISTENTLY_STARTED} and the
+	 * the type is {@link SimpleType#BOOLEAN}.
+	 */
+	Item PERSISTENTLY_STARTED_ITEM = new Item(PERSISTENTLY_STARTED,
+			"Whether the bundle is persistently started", SimpleType.BOOLEAN);
+	/**
+	 * The key REMOVAL_PENDING, used in {@link #REMOVAL_PENDING_ITEM}.
+	 */
+	String REMOVAL_PENDING = "RemovalPending";
+
+	/**
+	 * The item containing the indication of removal pending in
+	 * {@link #BUNDLE_TYPE}. The key is {@link #REMOVAL_PENDING} and the type is
+	 * {@link SimpleType#BOOLEAN}.
+	 */
+	Item REMOVAL_PENDING_ITEM = new Item(REMOVAL_PENDING,
+			"Whether the bundle is pending removal", SimpleType.BOOLEAN);
+	/**
+	 * The key REQUIRED, used in {@link #REQUIRED_ITEM}.
+	 */
+	String REQUIRED = "Required";
+
+	/**
+	 * The item containing the required status in {@link #BUNDLE_TYPE}. The key
+	 * is {@link #REQUIRED} and the the type is {@link SimpleType#BOOLEAN}.
+	 */
+	Item REQUIRED_ITEM = new Item(REQUIRED, "Whether the bundle is required",
+			SimpleType.BOOLEAN);
+	/**
+	 * The key FRAGMENT, used in {@link #FRAGMENT_ITEM}.
+	 */
+	String FRAGMENT = "Fragment";
+
+	/**
+	 * The item containing the fragment status in {@link #BUNDLE_TYPE}. The key
+	 * is {@link #FRAGMENT} and the the type is {@link SimpleType#BOOLEAN}.
+	 */
+	Item FRAGMENT_ITEM = new Item(FRAGMENT, "Whether the bundle is a fragment",
+			SimpleType.BOOLEAN);
+	/**
+	 * The key REGISTERED_SERVICES, used in {@link #REGISTERED_SERVICES_ITEM}.
+	 */
+	String REGISTERED_SERVICES = "RegisteredServices";
+
+	/**
+	 * The item containing the registered services of the bundle in
+	 * {@link #BUNDLE_TYPE}. The key is {@link #REGISTERED_SERVICES} and the the
+	 * type is {@link JmxConstants#LONG_ARRAY_TYPE}.
+	 */
+	Item REGISTERED_SERVICES_ITEM = new Item(REGISTERED_SERVICES,
+			"The registered services of the bundle",
+			JmxConstants.LONG_ARRAY_TYPE);
+	/**
+	 * The key SERVICES_IN_USE, used in {@link #SERVICES_IN_USE_ITEM}.
+	 */
+	String SERVICES_IN_USE = "ServicesInUse";
+
+	/**
+	 * The item containing the services in use by this bundle in
+	 * {@link #BUNDLE_TYPE}. The key is {@link #SERVICES_IN_USE} and the the
+	 * type is {@link JmxConstants#LONG_ARRAY_TYPE}.
+	 */
+	Item SERVICES_IN_USE_ITEM = new Item(SERVICES_IN_USE,
+			"The services in use by the bundle", JmxConstants.LONG_ARRAY_TYPE);
+	/**
+	 * The key HEADERS, used in {@link #HEADERS_ITEM}.
+	 */
+	String HEADERS = "Headers";
+
+	/**
+	 * The item containing the bundle headers in {@link #BUNDLE_TYPE}. The key
+	 * is {@link #HEADERS} and the the type is {@link #HEADERS_TYPE}.
+	 */
+	Item HEADERS_ITEM = new Item(HEADERS, "The headers of the bundle",
+			HEADERS_TYPE);
+
+	/**
+	 * The key EXPORTED_PACKAGES, used in {@link #EXPORTED_PACKAGES_ITEM}.
+	 */
+	String EXPORTED_PACKAGES = "ExportedPackages";
+
+	/**
+	 * The item containing the exported package names in {@link #BUNDLE_TYPE}
+	 * .The key is {@link #EXPORTED_PACKAGES} and the the type is
+	 * {@link JmxConstants#STRING_ARRAY_TYPE}.
+	 */
+	Item EXPORTED_PACKAGES_ITEM = new Item(EXPORTED_PACKAGES,
+			"The exported packages of the bundle",
+			JmxConstants.STRING_ARRAY_TYPE);
+	/**
+	 * The key IMPORTED_PACKAGES, used in {@link #EXPORTED_PACKAGES_ITEM}.
+	 */
+	String IMPORTED_PACKAGES = "ImportedPackages";
+
+	/**
+	 * The item containing the imported package names in {@link #BUNDLE_TYPE}
+	 * .The key is {@link #IMPORTED_PACKAGES} and the the type is
+	 * {@link JmxConstants#STRING_ARRAY_TYPE}.
+	 */
+	Item IMPORTED_PACKAGES_ITEM = new Item(IMPORTED_PACKAGES,
+			"The imported packages of the bundle",
+			JmxConstants.STRING_ARRAY_TYPE);
+	/**
+	 * The key FRAGMENTS, used in {@link #FRAGMENTS_ITEM}.
+	 */
+	String FRAGMENTS = "Fragments";
+
+	/**
+	 * The item containing the list of fragments the bundle is host to in
+	 * {@link #BUNDLE_TYPE}. The key is {@link #FRAGMENTS} and the type is
+	 * {@link JmxConstants#LONG_ARRAY_TYPE}.
+	 */
+	Item FRAGMENTS_ITEM = new Item(FRAGMENTS,
+			"The fragments of which the bundle is host",
+			JmxConstants.LONG_ARRAY_TYPE);
+	/**
+	 * The key HOSTS, used in {@link #HOSTS_ITEM}.
+	 */
+	String HOSTS = "Hosts";
+
+	/**
+	 * The item containing the bundle identifiers representing the hosts in
+	 * {@link #BUNDLE_TYPE}. The key is {@link #HOSTS} and the type is
+	 * {@link JmxConstants#LONG_ARRAY_TYPE}
+	 */
+	Item HOSTS_ITEM = new Item(HOSTS,
+			"The fragments of which the bundle is host",
+			JmxConstants.LONG_ARRAY_TYPE);
+	/**
+	 * The key REQUIRED_BUNDLES, used in {@link #REQUIRED_BUNDLES_ITEM}.
+	 */
+	String REQUIRED_BUNDLES = "RequiredBundles";
+
+	/**
+	 * The item containing the required bundles in {@link #BUNDLE_TYPE}. The key
+	 * is {@link #REQUIRED_BUNDLES} and the type is
+	 * {@link JmxConstants#LONG_ARRAY_TYPE}
+	 */
+	Item REQUIRED_BUNDLES_ITEM = new Item(REQUIRED_BUNDLES,
+			"The required bundles the bundle", JmxConstants.LONG_ARRAY_TYPE);
+	/**
+	 * The key REQUIRING_BUNDLES, used in {@link #REQUIRING_BUNDLES_ITEM}.
+	 */
+	String REQUIRING_BUNDLES = "RequiringBundles";
+
+	/**
+	 * The item containing the bundles requiring this bundle in
+	 * {@link #BUNDLE_TYPE}. The key is {@link #REQUIRING_BUNDLES} and the type
+	 * is {@link JmxConstants#LONG_ARRAY_TYPE}
+	 */
+	Item REQUIRING_BUNDLES_ITEM = new Item(REQUIRING_BUNDLES,
+			"The bundles requiring the bundle", JmxConstants.LONG_ARRAY_TYPE);
+
+	/**
+	 * The key EVENT, used in {@link #EVENT_ITEM}.
+	 */
+	String EVENT = "BundleEvent";
+
+	/**
+	 * The item containing the event type.  The key is {@link #EVENT} and the type is {@link SimpleType#INTEGER}
+	 */
+	Item EVENT_ITEM = new Item(
+			EVENT,
+			"The type of the event: {INSTALLED=1, STARTED=2, STOPPED=4, UPDATED=8, UNINSTALLED=16}",
+			SimpleType.INTEGER);
+
+	/**
+	 * The Composite Type that represents a bundle event.  This composite consists of:
+	 * <ul>
+	 * <li>{@link #IDENTIFIER}</li>
+	 * <li>{@link #LOCATION}</li>
+	 * <li>{@link #SYMBOLIC_NAME}</li>
+	 * <li>{@link #EVENT}</li>
+	 * </ul>
+	 */
+	CompositeType BUNDLE_EVENT_TYPE = Item.compositeType("BUNDLE_EVENT",
+			"This type encapsulates OSGi bundle events", IDENTIFIER_ITEM,
+			LOCATION_ITEM, SYMBOLIC_NAME_ITEM, EVENT_ITEM);
+
+	/**
+	 * The Composite Type that represents a bundle. This composite consist of:
+	 * <ul>
+	 * <li>{@link #EXPORTED_PACKAGES}</li>
+	 * <li>{@link #FRAGMENT}</li>
+	 * <li>{@link #FRAGMENTS}</li>
+	 * <li>{@link #HEADERS}</li>
+	 * <li>{@link #HOSTS}</li>
+	 * <li>{@link #IDENTIFIER}</li>
+	 * <li>{@link #IMPORTED_PACKAGES}</li>
+	 * <li>{@link #LAST_MODIFIED}</li>
+	 * <li>{@link #LOCATION}</li>
+	 * <li>{@link #PERSISTENTLY_STARTED}</li>
+	 * <li>{@link #REGISTERED_SERVICES}</li>
+	 * <li>{@link #REMOVAL_PENDING}</li>
+	 * <li>{@link #REQUIRED}</li>
+	 * <li>{@link #REQUIRED_BUNDLES}</li>
+	 * <li>{@link #REQUIRING_BUNDLES}</li>
+	 * <li>{@link #START_LEVEL}</li>
+	 * <li>{@link #STATE}</li>
+	 * <li>{@link #SERVICES_IN_USE}</li>
+	 * <li>{@link #SYMBOLIC_NAME}</li>
+	 * <li>{@link #VERSION}</li>
+	 * </ul>
+	 * It is used by {@link #BUNDLES_TYPE}.
+	 */
+	CompositeType BUNDLE_TYPE = Item.compositeType("BUNDLE",
+			"This type encapsulates OSGi bundles", EXPORTED_PACKAGES_ITEM,
+			FRAGMENT_ITEM, FRAGMENTS_ITEM, HEADERS_ITEM, HOSTS_ITEM,
+			IDENTIFIER_ITEM, IMPORTED_PACKAGES_ITEM, LAST_MODIFIED_ITEM,
+			LOCATION_ITEM, PERSISTENTLY_STARTED_ITEM, REGISTERED_SERVICES_ITEM,
+			REMOVAL_PENDING_ITEM, REQUIRED_ITEM, REQUIRED_BUNDLES_ITEM,
+			REQUIRING_BUNDLES_ITEM, START_LEVEL_ITEM, STATE_ITEM,
+			SERVICES_IN_USE_ITEM, SYMBOLIC_NAME_ITEM, VERSION_ITEM);
+
+	/**
+	 * The Tabular Type for a list of bundles. The row type is
+	 * {@link #BUNDLE_TYPE} and the index is {@link #IDENTIFIER}.
+	 */
+	TabularType BUNDLES_TYPE = Item.tabularType("BUNDLES", "A list of bundles",
+																BUNDLE_TYPE,
+																IDENTIFIER);
+
+    CompositeData getBundle(long id) throws IOException;
+
+	/**
+	 * Answer the list of identifiers of the bundles this bundle depends upon
+	 *
+	 * @param bundleIdentifier
+	 *            the bundle identifier
+	 * @return the list of bundle identifiers
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	long[] getRequiredBundles(long bundleIdentifier) throws IOException;
+
+	/**
+	 * Answer the bundle state of the system in tabular form.
+	 *
+	 * Each row of the returned table represents a single bundle. The Tabular
+	 * Data consists of Composite Data that is type by {@link #BUNDLES_TYPE}.
+	 *
+	 * @return the tabular representation of the bundle state
+	 * @throws IOException
+	 */
+	TabularData listBundles() throws IOException;
+
+	TabularData listBundles(String ... items) throws IOException;
+
+	/**
+	 * Answer the list of exported packages for this bundle.
+	 *
+	 * @param bundleId
+	 * @return the array of package names, combined with their version in the
+	 *         format &lt;packageName;version&gt;
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	String[] getExportedPackages(long bundleId) throws IOException;
+
+	/**
+	 * Answer the list of the bundle ids of the fragments associated with this
+	 * bundle
+	 *
+	 * @param bundleId
+	 * @return the array of bundle identifiers
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	long[] getFragments(long bundleId) throws IOException;
+
+	/**
+	 * Answer the headers for the bundle uniquely identified by the bundle id.
+	 * The Tabular Data is typed by the {@link #HEADERS_TYPE}.
+	 *
+	 * @param bundleId
+	 *            the unique identifier of the bundle
+	 * @return the table of associated header key and values
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	TabularData getHeaders(long bundleId) throws IOException;
+    String getHeader(long bundleId, String key) throws IOException;
+
+	/**
+	 * Answer the list of bundle ids of the bundles which host a fragment
+	 *
+	 * @param fragment
+	 *            the bundle id of the fragment
+	 * @return the array of bundle identifiers
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	long[] getHosts(long fragment) throws IOException;
+
+	/**
+	 * Answer the array of the packages imported by this bundle
+	 *
+	 * @param bundleId
+	 *            the bundle identifier
+	 * @return the array of package names, combined with their version in the
+	 *         format &lt;packageName;version&gt;
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	String[] getImportedPackages(long bundleId) throws IOException;
+
+	/**
+	 * Answer the last modified time of a bundle
+	 *
+	 * @param bundleId
+	 *            the unique identifier of a bundle
+	 * @return the last modified time
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	long getLastModified(long bundleId) throws IOException;
+
+	/**
+	 * Answer the list of service identifiers representing the services this
+	 * bundle exports
+	 *
+	 * @param bundleId
+	 *            the bundle identifier
+	 * @return the list of service identifiers
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	long[] getRegisteredServices(long bundleId) throws IOException;
+
+	/**
+	 * Answer the list of identifiers of the bundles which require this bundle
+	 *
+	 * @param bundleIdentifier
+	 *            the bundle identifier
+	 * @return the list of bundle identifiers
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	long[] getRequiringBundles(long bundleIdentifier) throws IOException;
+
+	/**
+	 * Answer the list of service identifiers which refer to the the services
+	 * this bundle is using
+	 *
+	 * @param bundleIdentifier
+	 *            the bundle identifier
+	 * @return the list of service identifiers
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	long[] getServicesInUse(long bundleIdentifier) throws IOException;
+
+	/**
+	 * Answer the start level of the bundle
+	 *
+	 * @param bundleId
+	 *            the identifier of the bundle
+	 * @return the start level
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	int getStartLevel(long bundleId) throws IOException;
+
+	/**
+	 * Answer the symbolic name of the state of the bundle
+	 *
+	 * @param bundleId
+	 *            the identifier of the bundle
+	 * @return the string name of the bundle state
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	String getState(long bundleId) throws IOException;
+
+	/**
+	 * Answer the symbolic name of the bundle
+	 *
+	 * @param bundleId
+	 *            the identifier of the bundle
+	 * @return the symbolic name
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	String getSymbolicName(long bundleId) throws IOException;
+
+	/**
+	 * Answer if the bundle is persistently started when its start level is
+	 * reached
+	 *
+	 * @param bundleId
+	 *            the identifier of the bundle
+	 * @return true if the bundle is persistently started
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	boolean isPersistentlyStarted(long bundleId) throws IOException;
+
+	/**
+	 * Answer whether the bundle is a fragment or not
+	 *
+	 * @param bundleId
+	 *            the identifier of the bundle
+	 * @return true if the bundle is a fragment
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	boolean isFragment(long bundleId) throws IOException;
+
+	/**
+	 * Answer true if the bundle is pending removal
+	 *
+	 * @param bundleId
+	 *            the identifier of the bundle
+	 * @return true if the bundle is pending removal
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	boolean isRemovalPending(long bundleId) throws IOException;
+
+	/**
+	 * Answer true if the bundle is required by another bundle
+	 *
+	 * @param bundleId
+	 *            the identifier of the bundle
+	 * @return true if the bundle is required by another bundle
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	boolean isRequired(long bundleId) throws IOException;
+
+	/**
+	 * Answer the location of the bundle.
+	 *
+	 * @param bundleId
+	 *            the identifier of the bundle
+	 * @return The location string of this bundle
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	String getLocation(long bundleId) throws IOException;
+
+	/**
+	 * Answer the location of the bundle.
+	 *
+	 * @param bundleId
+	 *            the identifier of the bundle
+	 * @return The location string of this bundle
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the bundle indicated does not exist
+	 */
+	String getVersion(long bundleId) throws IOException;
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/FrameworkMBean.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/FrameworkMBean.java
index 1f8bddab..a72eb18a 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/FrameworkMBean.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/FrameworkMBean.java
@@ -1,3 +1,491 @@
   + native
   + text/plain
   + Revision Date
+/*
+ * Copyright (c) OSGi Alliance (2009, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.jmx.framework;
+
+import java.io.IOException;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeType;
+import javax.management.openmbean.SimpleType;
+
+import org.osgi.jmx.Item;
+import org.osgi.jmx.JmxConstants;
+
+/**
+ * The FrameworkMbean provides mechanisms to exert control over the framework.
+ * For many operations, it provides a batch mechanism to avoid excessive message
+ * passing when interacting remotely.
+ * 
+ * @version $Revision$
+ * @ThreadSafe
+ */
+public interface FrameworkMBean {
+	/**
+	 * The fully qualified object name of this mbean.
+	 */
+	String			OBJECTNAME						= JmxConstants.OSGI_CORE
+															+ ":type=framework,version=1.5";
+
+	/**
+	 * The SUCCESS, used in {@link #SUCCESS_ITEM}.
+	 */
+	String			SUCCESS							= "Success";
+
+	/**
+	 * The item that indicates if this operation was successful. The key is
+	 * {@link #SUCCESS} and the type is {@link SimpleType#BOOLEAN}. It is used
+	 * in {@link #BATCH_ACTION_RESULT_TYPE} and
+	 * {@link #BATCH_INSTALL_RESULT_TYPE}.
+	 */
+	Item			SUCCESS_ITEM					= new Item(
+															SUCCESS,
+															"Whether the operation was successful",
+															SimpleType.BOOLEAN);
+
+	/**
+	 * The key ERROR, used in {@link #ERROR_ITEM}.
+	 */
+	String			ERROR							= "Error";
+
+	/**
+	 * The item containing the error message of the batch operation. The key is
+	 * {@link #ERROR} and the type is {@link SimpleType#STRING}. It is used in
+	 * {@link #BATCH_ACTION_RESULT_TYPE} and {@link #BATCH_INSTALL_RESULT_TYPE}.
+	 */
+	Item			ERROR_ITEM						= new Item(
+															ERROR,
+															"The error message if unsuccessful",
+															SimpleType.STRING);
+
+	/**
+	 * The key COMPLETED, used in {@link #COMPLETED_ITEM}.
+	 */
+	String			COMPLETED						= "Completed";
+
+	/**
+	 * The item containing the list of bundles completing the batch operation.
+	 * The key is {@link #COMPLETED} and the type is
+	 * {@link JmxConstants#LONG_ARRAY_TYPE}. It is used in
+	 * {@link #BATCH_ACTION_RESULT_TYPE} and {@link #BATCH_INSTALL_RESULT_TYPE}.
+	 */
+	Item			COMPLETED_ITEM					= new Item(
+															COMPLETED,
+															"The bundle ids of the successfully completed installs",
+															JmxConstants.LONG_ARRAY_TYPE);
+
+	/**
+	 * The key for BUNDLE_IN_ERROR. This key is used with two different items:
+	 * {@link #BUNDLE_IN_ERROR_ID_ITEM} and
+	 * {@link #BUNDLE_IN_ERROR_LOCATION_ITEM} that each have a different type
+	 * for this key. It is used in {@link #BATCH_ACTION_RESULT_TYPE} and
+	 * {@link #BATCH_INSTALL_RESULT_TYPE}.
+	 */
+	String			BUNDLE_IN_ERROR					= "BundleInError";
+
+	/**
+	 * The item containing the bundle which caused the error during the batch
+	 * operation. This item describes the bundle in error as an id. The key is
+	 * {@link #BUNDLE_IN_ERROR} and the type is {@link SimpleType#LONG}. It is
+	 * used in {@link #BATCH_ACTION_RESULT_TYPE}.
+	 * 
+	 * @see #BUNDLE_IN_ERROR_LOCATION_ITEM BUNDLE_IN_ERROR_LOCATION_ITEM for the
+	 *      item that has a location for the bundle in error.
+	 */
+	Item			BUNDLE_IN_ERROR_ID_ITEM			= new Item(
+															BUNDLE_IN_ERROR,
+															"The id of the bundle causing the error",
+															SimpleType.LONG);
+
+	/**
+	 * The key REMAINING, used in {@link #REMAINING_ID_ITEM} and
+	 * {@link #REMAINING_LOCATION_ITEM}.
+	 */
+	String			REMAINING						= "Remaining";
+
+	/**
+	 * The item containing the list of remaining bundles unprocessed by the
+	 * failing batch operation. The key is {@link #REMAINING} and the type is
+	 * {@link JmxConstants#LONG_ARRAY_TYPE}. It is used in
+	 * {@link #BATCH_ACTION_RESULT_TYPE} and {@link #BATCH_INSTALL_RESULT_TYPE}.
+	 */
+	Item			REMAINING_ID_ITEM				= new Item(
+															REMAINING,
+															"The ids of the remaining bundles",
+															JmxConstants.LONG_ARRAY_TYPE);
+
+	/**
+	 * The Composite Type for a batch action result.
+	 * {@link #refreshBundle(long)} and {@link #refreshBundles(long[])}.
+	 * Notice that a batch action result returns uses an id for the
+	 * {@link #BUNDLE_IN_ERROR} while the {@link #BATCH_INSTALL_RESULT_TYPE}
+	 * uses a location.
+	 * 
+	 * This Composite Type consists of the following items:
+	 * <ul>
+	 * <li>{@link #BUNDLE_IN_ERROR_ID_ITEM}</li>
+	 * <li>{@link #COMPLETED_ITEM}</li>
+	 * <li>{@link #ERROR_ITEM}</li>
+	 * <li>{@link #REMAINING_ID_ITEM}</li>
+	 * <li>{@link #SUCCESS_ITEM}</li>
+	 * </ul>
+	 */
+	CompositeType	BATCH_ACTION_RESULT_TYPE		= Item
+															.compositeType(
+																	"BUNDLE_ACTION_RESULT",
+																	"This type encapsulates a bundle batch install action result",
+																	BUNDLE_IN_ERROR_ID_ITEM,
+																	COMPLETED_ITEM,
+																	ERROR_ITEM,
+																	REMAINING_ID_ITEM,
+																	SUCCESS_ITEM //
+															);
+
+	/**
+	 * The item containing the bundle which caused the error during the batch
+	 * operation. This item describes the bundle in error as a location. The key
+	 * is {@link #BUNDLE_IN_ERROR} and the type is {@link SimpleType#STRING}. It
+	 * is used in {@link #BATCH_INSTALL_RESULT_TYPE}.
+	 * 
+	 * @see #BUNDLE_IN_ERROR_ID_ITEM BUNDLE_IN_ERROR_ID_ITEM for the item that
+	 *      has the id for the bundle in error.
+	 */
+	Item			BUNDLE_IN_ERROR_LOCATION_ITEM	= new Item(
+															BUNDLE_IN_ERROR,
+															"The location of the bundle causing the error",
+															SimpleType.STRING);
+
+	/**
+	 * The item containing the list of remaining bundles unprocessed by the
+	 * failing batch operation. The key is {@link #REMAINING} and the type is
+	 * {@link JmxConstants#STRING_ARRAY_TYPE}. It is used in
+	 * {@link #BATCH_ACTION_RESULT_TYPE} and {@link #BATCH_INSTALL_RESULT_TYPE}.
+	 */
+	Item			REMAINING_LOCATION_ITEM			= new Item(
+															REMAINING,
+															"The locations of the remaining bundles",
+															JmxConstants.STRING_ARRAY_TYPE);
+
+	/**
+	 * The Composite Type which represents the result of a batch install
+	 * operation. It is used in {@link #installBundles(String[])} and
+	 * {@link #installBundlesFromURL(String[], String[])}.
+	 * 
+	 * This Composite Type consists of the following items:
+	 * <ul>
+	 * <li>{@link #BUNDLE_IN_ERROR_LOCATION_ITEM}</li>
+	 * <li>{@link #COMPLETED_ITEM}</li>
+	 * <li>{@link #ERROR_ITEM}</li>
+	 * <li>{@link #REMAINING_LOCATION_ITEM P }</li>
+	 * <li>{@link #SUCCESS_ITEM}</li>
+	 * </ul>
+	 */
+	CompositeType	BATCH_INSTALL_RESULT_TYPE		= Item
+															.compositeType(
+																	"BATCH_INSTALL_RESULT",
+																	"This type encapsulates a bundle batch install action result",
+																	BUNDLE_IN_ERROR_LOCATION_ITEM,
+																	COMPLETED_ITEM,
+																	ERROR_ITEM,
+																	REMAINING_LOCATION_ITEM,
+																	SUCCESS_ITEM //
+															);
+
+	/**
+	 * Retrieve the framework start level
+	 * 
+	 * @return the framework start level
+	 * @throws IOException if the operation failed
+	 */
+	int getFrameworkStartLevel() throws IOException;
+
+	/**
+	 * Answer the initial start level assigned to a bundle when it is first
+	 * started
+	 * 
+	 * @return the start level
+	 * @throws IOException if the operation failed
+	 */
+	int getInitialBundleStartLevel() throws IOException;
+
+	/**
+	 * Install the bundle indicated by the bundleLocations
+	 * 
+	 * @param location the location of the bundle to install
+	 * @return the bundle id the installed bundle
+	 * @throws IOException if the operation does not succeed
+	 */
+	long installBundle(String location) throws IOException;
+
+	/**
+	 * Install the bundle indicated by the bundleLocations
+	 * 
+	 * @param location the location to assign to the bundle
+	 * @param url the URL which will supply the bytes for the bundle
+	 * @return the bundle id the installed bundle
+	 * @throws IOException if the operation does not succeed
+	 */
+	long installBundleFromURL(String location, String url) throws IOException;
+
+	/**
+	 * Batch install the bundles indicated by the list of bundleLocationUrls
+	 * 
+	 * @see #BATCH_INSTALL_RESULT_TYPE BATCH_INSTALL_RESULT_TYPE for the precise
+	 *      specification of the CompositeData type representing the returned
+	 *      result.
+	 * 
+	 * @param locations the array of locations of the bundles to install
+	 * @return the resulting state from executing the operation
+	 * @throws IOException if the operation does not succeed
+	 */
+	CompositeData installBundles(String[] locations) throws IOException;
+
+	/**
+	 * Batch install the bundles indicated by the list of bundleLocationUrls
+	 * 
+	 * @see #BATCH_INSTALL_RESULT_TYPE BATCH_INSTALL_RESULT_TYPE
+	 *      BatchBundleResult for the precise specification of the CompositeData
+	 *      type representing the returned result.
+	 * 
+	 * @param locations the array of locations to assign to the installed
+	 *        bundles
+	 * @param urls the array of urls which supply the bundle bytes
+	 * @return the resulting state from executing the operation
+	 * @throws IOException if the operation does not succeed
+	 */
+	CompositeData installBundlesFromURL(String[] locations, String[] urls)
+			throws IOException;
+
+	/**
+	 * Force the update, replacement or removal of the packages identified by
+	 * the specified bundle.
+	 * 
+	 * @param bundleIdentifier the bundle identifier
+	 * @throws IOException if the operation failed
+	 */
+	void refreshBundle(long bundleIdentifier) throws IOException;
+
+	/**
+	 * Force the update, replacement or removal of the packages identified by
+	 * the list of bundles.
+	 * 
+	 * @param bundleIdentifiers The identifiers of the bundles to refresh, or
+	 *        <code>null</code> for all bundles with packages pending removal.
+	 * @throws IOException if the operation failed
+	 */
+	void refreshBundles(long[] bundleIdentifiers) throws IOException;
+
+	/**
+	 * Resolve the bundle indicated by the unique symbolic name and version
+	 * 
+	 * @param bundleIdentifier the bundle identifier
+	 * @return <code>true</code> if the bundle was resolved, false otherwise
+	 * @throws IOException if the operation does not succeed
+	 * @throws IllegalArgumentException if the bundle indicated does not exist
+	 */
+	boolean resolveBundle(long bundleIdentifier) throws IOException;
+
+	/**
+	 * Batch resolve the bundles indicated by the list of bundle identifiers
+	 * 
+	 * @param bundleIdentifiers The identifiers of the bundles to resolve, or
+	 *        <code>null</code> to resolve all unresolved bundles.
+	 * @return <code>true</code> if the bundles were resolved, false otherwise
+	 * @throws IOException if the operation does not succeed
+	 */
+	boolean resolveBundles(long[] bundleIdentifiers) throws IOException;
+
+	/**
+	 * Restart the framework by updating the system bundle
+	 * 
+	 * @throws IOException if the operation failed
+	 */
+	void restartFramework() throws IOException;
+
+	/**
+	 * Set the start level for the bundle identifier
+	 * 
+	 * @param bundleIdentifier the bundle identifier
+	 * @param newlevel the new start level for the bundle
+	 * @throws IOException if the operation failed
+	 */
+	void setBundleStartLevel(long bundleIdentifier, int newlevel)
+			throws IOException;
+
+	/**
+	 * Set the start levels for the list of bundles.
+	 * 
+	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
+	 *      specification of the CompositeData type representing the returned
+	 *      result.
+	 * 
+	 * @param bundleIdentifiers the array of bundle identifiers
+	 * @param newlevels the array of new start level for the bundles
+	 * @return the resulting state from executing the operation
+	 * @throws IOException if the operation failed
+	 */
+	CompositeData setBundleStartLevels(long[] bundleIdentifiers, int[] newlevels)
+			throws IOException;
+
+	/**
+	 * Set the start level for the framework
+	 * 
+	 * @param newlevel the new start level
+	 * @throws IOException if the operation failed
+	 */
+	void setFrameworkStartLevel(int newlevel) throws IOException;
+
+	/**
+	 * Set the initial start level assigned to a bundle when it is first started
+	 * 
+	 * @param newlevel the new start level
+	 * @throws IOException if the operation failed
+	 */
+	void setInitialBundleStartLevel(int newlevel) throws IOException;
+
+	/**
+	 * Shutdown the framework by stopping the system bundle
+	 * 
+	 * @throws IOException if the operation failed
+	 */
+	void shutdownFramework() throws IOException;
+
+	/**
+	 * Start the bundle indicated by the bundle identifier
+	 * 
+	 * @param bundleIdentifier the bundle identifier
+	 * @throws IOException if the operation does not succeed
+	 * @throws IllegalArgumentException if the bundle indicated does not exist
+	 */
+	void startBundle(long bundleIdentifier) throws IOException;
+
+	/**
+	 * Batch start the bundles indicated by the list of bundle identifier
+	 * 
+	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
+	 *      specification of the CompositeData type representing the returned
+	 *      result.
+	 * 
+	 * @param bundleIdentifiers the array of bundle identifiers
+	 * @return the resulting state from executing the operation
+	 * @throws IOException if the operation does not succeed
+	 */
+	CompositeData startBundles(long[] bundleIdentifiers) throws IOException;
+
+	/**
+	 * Stop the bundle indicated by the bundle identifier
+	 * 
+	 * @param bundleIdentifier the bundle identifier
+	 * @throws IOException if the operation does not succeed
+	 * @throws IllegalArgumentException if the bundle indicated does not exist
+	 */
+	void stopBundle(long bundleIdentifier) throws IOException;
+
+	/**
+	 * Batch stop the bundles indicated by the list of bundle identifier
+	 * 
+	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
+	 *      specification of the CompositeData type representing the returned
+	 *      result.
+	 * 
+	 * @param bundleIdentifiers the array of bundle identifiers
+	 * @return the resulting state from executing the operation
+	 * @throws IOException if the operation does not succeed
+	 */
+	CompositeData stopBundles(long[] bundleIdentifiers) throws IOException;
+
+	/**
+	 * Uninstall the bundle indicated by the bundle identifier
+	 * 
+	 * @param bundleIdentifier the bundle identifier
+	 * @throws IOException if the operation does not succeed
+	 * @throws IllegalArgumentException if the bundle indicated does not exist
+	 */
+	void uninstallBundle(long bundleIdentifier) throws IOException;
+
+	/**
+	 * Batch uninstall the bundles indicated by the list of bundle identifiers
+	 * 
+	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
+	 *      specification of the CompositeData type representing the returned
+	 *      result.
+	 * 
+	 * @param bundleIdentifiers the array of bundle identifiers
+	 * @return the resulting state from executing the operation
+	 * @throws IOException if the operation does not succeed
+	 */
+	CompositeData uninstallBundles(long[] bundleIdentifiers) throws IOException;
+
+	/**
+	 * Update the bundle indicated by the bundle identifier
+	 * 
+	 * @param bundleIdentifier the bundle identifier
+	 * @throws IOException if the operation does not succeed
+	 * @throws IllegalArgumentException if the bundle indicated does not exist
+	 */
+	void updateBundle(long bundleIdentifier) throws IOException;
+
+	/**
+	 * Update the bundle identified by the bundle identifier
+	 * 
+	 * @param bundleIdentifier the bundle identifier
+	 * @param url the URL to use to update the bundle
+	 * @throws IOException if the operation does not succeed
+	 * @throws IllegalArgumentException if the bundle indicated does not exist
+	 */
+	void updateBundleFromURL(long bundleIdentifier, String url) throws IOException;
+
+	/**
+	 * Batch update the bundles indicated by the list of bundle identifier.
+	 * 
+	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
+	 *      specification of the CompositeData type representing the returned
+	 *      result.
+	 * 
+	 * @param bundleIdentifiers the array of bundle identifiers
+	 * @return the resulting state from executing the operation
+	 * @throws IOException if the operation does not succeed
+	 */
+	CompositeData updateBundles(long[] bundleIdentifiers) throws IOException;
+
+	/**
+	 * Update the bundle uniquely identified by the bundle symbolic name and
+	 * version using the contents of the supplied urls.
+	 * 
+	 * @see #BATCH_ACTION_RESULT_TYPE BATCH_ACTION_RESULT_TYPE for the precise
+	 *      specification of the CompositeData type representing the returned
+	 *      result.
+	 * 
+	 * @param bundleIdentifiers the array of bundle identifiers
+	 * @param urls the array of URLs to use to update the bundles
+	 * @return the resulting state from executing the operation
+	 * @throws IOException if the operation does not succeed
+	 * @throws IllegalArgumentException if the bundle indicated does not exist
+	 */
+	CompositeData updateBundlesFromURL(long[] bundleIdentifiers, String[] urls)
+			throws IOException;
+
+	/**
+	 * Update the framework by updating the system bundle.
+	 * 
+	 * @throws IOException if the operation failed
+	 */
+	void updateFramework() throws IOException;
+
+ }
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/PackageStateMBean.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/PackageStateMBean.java
index 17c97dcc..78c948a5 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/PackageStateMBean.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/PackageStateMBean.java
@@ -1 +1,198 @@
   + text/plain
+/*
+ * Copyright (c) OSGi Alliance (2009, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.jmx.framework;
+
+import java.io.IOException;
+
+import javax.management.openmbean.CompositeType;
+import javax.management.openmbean.SimpleType;
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularType;
+
+import org.osgi.jmx.Item;
+import org.osgi.jmx.JmxConstants;
+
+/**
+ * This MBean provides information about the package state of the framework.
+ * 
+ * @version $Revision$
+ * @ThreadSafe
+ */
+public interface PackageStateMBean {
+	/**
+	 * The fully qualified object name of this MBean.
+	 */
+	String			OBJECTNAME				= JmxConstants.OSGI_CORE
+													+ ":type=packageState,version=1.5";
+
+	/**
+	 * The key EXPORTING_BUNDLE, used in {@link #EXPORTING_BUNDLES_ITEM}.
+	 */
+	String			EXPORTING_BUNDLES		= "ExportingBundles";
+
+	/**
+	 * The item containing the bundle identifier in {@link #PACKAGE_TYPE}. The
+	 * key is {@link #EXPORTING_BUNDLES} and the type is
+	 * {@link JmxConstants#LONG_ARRAY_TYPE}.
+	 */
+	Item			EXPORTING_BUNDLES_ITEM	= new Item(
+													EXPORTING_BUNDLES,
+													"The bundles the package belongs to",
+													JmxConstants.LONG_ARRAY_TYPE);
+
+	/**
+	 * The key IMPORTING_BUNDLES, used in {@link #IMPORTING_BUNDLES_ITEM}.
+	 */
+	String			IMPORTING_BUNDLES		= "ImportingBundles";
+
+	/**
+	 * The item containing the bundle identifier in {@link #PACKAGE_TYPE}. The
+	 * key is {@link #IMPORTING_BUNDLES} and the type is {@link JmxConstants#LONG_ARRAY_TYPE}.
+	 */
+	Item			IMPORTING_BUNDLES_ITEM	= new Item(
+													IMPORTING_BUNDLES,
+													"The importing bundles of the package",
+													JmxConstants.LONG_ARRAY_TYPE);
+
+
+	/**
+	 * The key NAME, used in {@link #NAME_ITEM}.
+	 */
+	String			NAME					= "Name";
+
+	/**
+	 * The item containing the name of the package in {@link #PACKAGE_TYPE}.
+	 * The key is {@link #NAME} and the type is {@link SimpleType#LONG}.
+	 */
+	Item			NAME_ITEM				= new Item(NAME,
+													"The package name",
+													SimpleType.STRING);
+
+	/**
+	 * The name of the item containing the pending removal status of the package
+	 * in the CompositeData. Used
+	 */
+	String			REMOVAL_PENDING			= "RemovalPending";
+	/**
+	 * The item representing the removal pending status of a package. The key is
+	 * {@link #REMOVAL_PENDING} and the type is {@link SimpleType#BOOLEAN}.
+	 */
+	Item			REMOVAL_PENDING_ITEM	= new Item(
+													REMOVAL_PENDING,
+													"Whether the package is pending removal",
+													SimpleType.BOOLEAN);
+
+	/**
+	 * The name of the item containing the package version in the CompositeData.
+	 * Used in {@link #VERSION_ITEM}.
+	 */
+	String			VERSION					= "Version";
+
+	/**
+	 * The item containing the version of the package in {@link #PACKAGE_TYPE}.
+	 * The key is {@link #VERSION} and the type is {@link SimpleType#STRING}.
+	 */
+	Item			VERSION_ITEM			= new Item(
+													VERSION,
+													"The identifier of the bundle the service belongs to",
+													SimpleType.STRING);
+
+	/**
+	 * The Composite Type for a CompositeData representing a package. This type
+	 * consists of:
+	 * <ul>
+	 * <li>{@link #EXPORTING_BUNDLES_ITEM}</li>
+	 * <li>{@link #IMPORTING_BUNDLES_ITEM}</li>
+	 * <li>{@link #NAME_ITEM}</li>
+	 * <li>{@link #REMOVAL_PENDING_ITEM}</li>
+	 * <li>{@link #VERSION_ITEM}</li>
+	 * </ul>
+	 * The key is defined as {@link #NAME} and {@link #EXPORTING_BUNDLES}
+	 */
+	CompositeType	PACKAGE_TYPE			= Item
+													.compositeType(
+															"PACKAGE",
+															"This type encapsulates an OSGi package",
+															EXPORTING_BUNDLES_ITEM,
+															IMPORTING_BUNDLES_ITEM,
+															NAME_ITEM,
+															REMOVAL_PENDING_ITEM,
+															VERSION_ITEM);
+
+	/**
+	 * The Tabular Type used in {@link #listPackages()}. They key is
+	 * {@link #NAME}, {@link #VERSION}, and {@link #EXPORTING_BUNDLES}.
+	 */
+	TabularType		PACKAGES_TYPE			= Item.tabularType("PACKAGES",
+													"A table of packages",
+													PACKAGE_TYPE, NAME,
+													VERSION, EXPORTING_BUNDLES);
+
+	/**
+	 * Answer the identifier of the bundle exporting the package
+	 * 
+	 * @param packageName - the package name
+	 * @param version - the version of the package
+	 * @return the bundle identifiers exporting such a package
+	 * @throws IOException if the operation fails
+	 * @throws IllegalArgumentException if the package indicated does not exist
+	 */
+	long[] getExportingBundles(String packageName, String version)
+			throws IOException;
+
+	/**
+	 * Answer the list of identifiers of the bundles importing the package
+	 * 
+	 * @param packageName The package name
+	 * @param version The version of the package
+	 * @param exportingBundle The exporting bundle for the given package
+	 * @return the list of bundle identifiers
+	 * @throws IOException if the operation fails
+	 * @throws IllegalArgumentException if the package indicated does not exist
+	 * 
+	 */
+	long[] getImportingBundles(String packageName, String version,
+			long exportingBundle) throws IOException;
+
+	/**
+	 * Answer the package state of the system in tabular form
+	 * 
+	 * The Tabular Data is typed by {@link #PACKAGES_TYPE}, which has
+	 * {@link #PACKAGE_TYPE} as its Composite Type.
+	 * 
+	 * @return the tabular representation of the package state
+	 * @throws IOException When fails
+	 */
+	TabularData listPackages() throws IOException;
+
+	/**
+	 * Answer if this package is exported by a bundle which has been updated or
+	 * uninstalled
+	 * 
+	 * @param packageName The package name
+	 * @param version The version of the package
+	 * @param exportingBundle The bundle exporting the package
+	 * @return true if this package is being exported by a bundle that has been
+	 *         updated or uninstalled.
+	 * @throws IOException if the operation fails
+	 * @throws IllegalArgumentException if the package indicated does not exist
+	 */
+	boolean isRemovalPending(String packageName, String version, long exportingBundle)
+			throws IOException;
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/ServiceStateMBean.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/ServiceStateMBean.java
index b56de2e8..58b1d14b 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/ServiceStateMBean.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/framework/ServiceStateMBean.java
@@ -1,3 +1,245 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Copyright (c) OSGi Alliance (2009, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.jmx.framework;
+
+import java.io.IOException;
+
+import javax.management.openmbean.CompositeType;
+import javax.management.openmbean.SimpleType;
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularType;
+
+import org.osgi.jmx.Item;
+import org.osgi.jmx.JmxConstants;
+
+/**
+ * This MBean represents the Service state of the framework. This MBean also
+ * emits events that clients can use to get notified of the changes in the
+ * service state of the framework.
+ * 
+ * @version $Revision$
+ * @ThreadSafe
+ */
+public interface ServiceStateMBean {
+	/**
+	 * The fully qualified object name of this mbean.
+	 */
+	String OBJECTNAME = JmxConstants.OSGI_CORE
+			+ ":type=serviceState,version=1.5";
+	/**
+	 * The key BUNDLE_IDENTIFIER, used in {@link #BUNDLE_IDENTIFIER_ITEM}.
+	 */
+	String BUNDLE_IDENTIFIER = "BundleIdentifier";
+	/**
+	 * The item containing the bundle identifier in {@link #SERVICE_TYPE}. The
+	 * key is {@link #BUNDLE_IDENTIFIER} and the type is {@link SimpleType#LONG}
+	 * .
+	 */
+	Item BUNDLE_IDENTIFIER_ITEM = new Item(BUNDLE_IDENTIFIER,
+			"The identifier of the bundle the service belongs to",
+			SimpleType.LONG);
+
+	/**
+	 * The key OBJECT_CLASS, used {@link #OBJECT_CLASS_ITEM}.
+	 */
+	String OBJECT_CLASS = "objectClass";
+
+	/**
+	 * The item containing the interfaces of the service in
+	 * {@link #SERVICE_TYPE}. The key is {@link #OBJECT_CLASS} and the type is
+	 * {@link JmxConstants#STRING_ARRAY_TYPE}.
+	 */
+	Item OBJECT_CLASS_ITEM = new Item(
+			OBJECT_CLASS,
+			"An string array containing the interfaces under which the service has been registered",
+			JmxConstants.STRING_ARRAY_TYPE);
+
+	/**
+	 * The key IDENTIFIER, used {@link #IDENTIFIER_ITEM}.
+	 */
+	String IDENTIFIER = "Identifier";
+
+	/**
+	 * The item containing the service identifier in {@link #SERVICE_TYPE}. The
+	 * key is {@link #IDENTIFIER} and the type is {@link SimpleType#LONG}.
+	 */
+	Item IDENTIFIER_ITEM = new Item(IDENTIFIER,
+			"The identifier of the service", SimpleType.LONG);
+
+	/**
+	 * The key USING_BUNDLES, used in {@link #USING_BUNDLES_ITEM}.
+	 */
+	String USING_BUNDLES = "UsingBundles";
+
+	/**
+	 * The item containing the bundles using the service in
+	 * {@link #SERVICE_TYPE}. The key is {@link #USING_BUNDLES} and the type is
+	 * {@link JmxConstants#LONG_ARRAY_TYPE}.
+	 */
+	Item USING_BUNDLES_ITEM = new Item(USING_BUNDLES,
+			"The bundles using the service", JmxConstants.LONG_ARRAY_TYPE);
+
+	/**
+	 * The Composite Type for a CompositeData representing a service. This type
+	 * consists of:
+	 * <ul>
+	 * <li>{@link #BUNDLE_IDENTIFIER}</li>
+	 * <li>{@link #IDENTIFIER}</li>
+	 * <li>{@link #OBJECT_CLASS}</li>
+	 * <li>{@link #USING_BUNDLES}</li>
+	 * </ul>
+	 */
+	CompositeType SERVICE_TYPE = Item.compositeType("SERVICE",
+			"This type encapsulates an OSGi service", BUNDLE_IDENTIFIER_ITEM,
+			IDENTIFIER_ITEM, OBJECT_CLASS_ITEM,
+			USING_BUNDLES_ITEM);
+
+	/**
+	 * The Tabular Type for a Service table. The rows consists of
+	 * {@link #SERVICE_TYPE} Composite Data and the index is {@link #IDENTIFIER}
+	 * .
+	 */
+	TabularType SERVICES_TYPE = Item.tabularType("SERVICES",
+			"The table of all services", SERVICE_TYPE, IDENTIFIER);
+
+	/**
+	 * The key BUNDLE_LOCATION, used in {@link #SERVICE_EVENT_TYPE}.
+	 */
+	String BUNDLE_LOCATION = "BundleLocation";
+	/**
+	 * The item containing the bundle location in {@link #EVENT_ITEM}. The key
+	 * is {@link #BUNDLE_LOCATION} and the the type is {@link SimpleType#STRING}
+	 * .
+	 */
+	Item BUNDLE_LOCATION_ITEM = new Item(BUNDLE_LOCATION,
+			"The location of the bundle", SimpleType.STRING);
+	/**
+	 * The key BUNDLE_SYMBOLIC_NAME, used in {@link #SERVICE_EVENT_TYPE}.
+	 */
+	String BUNDLE_SYMBOLIC_NAME = "BundleSymbolicName";
+
+	/**
+	 * The item containing the symbolic name in {@link #EVENT}. The key is
+	 * {@link #BUNDLE_SYMBOLIC_NAME} and the the type is
+	 * {@link SimpleType#STRING}.
+	 */
+	Item BUNDLE_SYMBOLIC_NAME_ITEM = new Item(BUNDLE_SYMBOLIC_NAME,
+			"The symbolic name of the bundle", SimpleType.STRING);
+
+	/**
+	 * The key EVENT, used in {@link #EVENT_ITEM}.
+	 */
+	String EVENT = "ServiceEvent";
+
+	/**
+	 * The item containing the event type. The key is {@link #EVENT} and the
+	 * type is {@link SimpleType#INTEGER}
+	 */
+	Item EVENT_ITEM = new Item(
+			EVENT,
+			"The eventType of the event: {REGISTERED=1, MODIFIED=2 UNREGISTERING=3}",
+			SimpleType.INTEGER);
+
+	/**
+	 * The Composite Type that represents a service event. This composite
+	 * consists of:
+	 * <ul>
+	 * <li>{@link #IDENTIFIER}</li>
+	 * <li>{@link #OBJECT_CLASS}</li>
+	 * <li>{@link #BUNDLE_LOCATION}</li>
+	 * <li>{@link #BUNDLE_SYMBOLIC_NAME}</li>
+	 * <li>{@link #EVENT}</li>
+	 * </ul>
+	 */
+	CompositeType SERVICE_EVENT_TYPE = Item.compositeType("SERVICE_EVENT",
+			"This type encapsulates OSGi service events", IDENTIFIER_ITEM,
+			OBJECT_CLASS_ITEM, BUNDLE_IDENTIFIER_ITEM, BUNDLE_LOCATION_ITEM,
+			BUNDLE_SYMBOLIC_NAME_ITEM, EVENT_ITEM);
+
+	/**
+	 * Answer the list of interfaces that this service implements
+	 * 
+	 * @param serviceId
+	 *            the identifier of the service
+	 * @return the list of interfaces
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the service indicated does not exist
+	 */
+	public String[] getObjectClass(long serviceId) throws IOException;
+
+	/**
+	 * Answer the bundle identifier of the bundle which registered the service
+	 * 
+	 * @param serviceId
+	 *            the identifier of the service
+	 * @return the identifier for the bundle
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the service indicated does not exist
+	 */
+	long getBundleIdentifier(long serviceId) throws IOException;
+
+	/**
+	 * Answer the map of properties associated with this service
+	 * 
+	 * @see JmxConstants#PROPERTIES_TYPE for the details of the TabularType
+	 * 
+	 * @param serviceId
+	 *            the identifier of the service
+	 * @return the table of properties. These include the standard mandatory
+	 *         service.id and objectClass properties as defined in the
+	 *         <code>org.osgi.framework.Constants</code> interface
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the service indicated does not exist
+	 */
+	TabularData getProperties(long serviceId) throws IOException;
+
+	/**
+	 * Answer the service state of the system in tabular form.
+	 * 
+	 * @see #SERVICES_TYPE for the details of the TabularType
+	 * 
+	 * @return the tabular representation of the service state
+	 * @throws IOException
+	 *             If the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the service indicated does not exist
+	 */
+	TabularData listServices() throws IOException;
+
+	/**
+	 * Answer the list of identifiers of the bundles that use the service
+	 * 
+	 * @param serviceId
+	 *            the identifier of the service
+	 * @return the list of bundle identifiers
+	 * @throws IOException
+	 *             if the operation fails
+	 * @throws IllegalArgumentException
+	 *             if the service indicated does not exist
+	 */
+	long[] getUsingBundles(long serviceId) throws IOException;
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/cm/ConfigurationAdminMBean.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/cm/ConfigurationAdminMBean.java
index 3f24d583..65e1cbcc 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/cm/ConfigurationAdminMBean.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/cm/ConfigurationAdminMBean.java
@@ -1 +1,189 @@
   + native
+/*
+ * Copyright (c) OSGi Alliance (2009, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.jmx.service.cm;
+
+import java.io.IOException;
+
+import javax.management.openmbean.TabularData;
+
+import org.osgi.jmx.JmxConstants;
+
+/**
+ * This MBean provides the management interface to the OSGi Configuration
+ * Administration Service.
+ * 
+ * @version $Revision$
+ * @ThreadSafe
+ */
+public interface ConfigurationAdminMBean {
+	/**
+	 * The object name for this mbean.
+	 */
+	String OBJECTNAME = JmxConstants.OSGI_COMPENDIUM+":service=cm,version=1.3";
+
+	/**
+	 * Create a new configuration instance for the supplied persistent id of the
+	 * factory, answering the PID of the created configuration
+	 * 
+	 * @param factoryPid the persistent id of the factory
+	 * @return the PID of the created configuration
+	 * @throws IOException if the operation failed
+	 */
+	String createFactoryConfiguration(String factoryPid) throws IOException;
+
+	/**
+	 * Create a factory configuration for the supplied persistent id of the
+	 * factory and the bundle location bound to bind the created configuration
+	 * to, answering the PID of the created configuration
+	 * 
+	 * @param factoryPid the persistent id of the factory
+	 * @param location the bundle location
+	 * @return the pid of the created configuation
+	 * @throws IOException if the operation failed
+	 */
+	String createFactoryConfigurationForLocation(String factoryPid, String location)
+			throws IOException;
+
+	/**
+	 * Delete the configuration
+	 * 
+	 * @param pid the persistent identifier of the configuration
+	 * @throws IOException if the operation fails
+	 */
+	void delete(String pid) throws IOException;
+
+	/**
+	 * Delete the configuration
+	 * 
+	 * @param pid the persistent identifier of the configuration
+	 * @param location the bundle location
+	 * @throws IOException if the operation fails
+	 */
+	void deleteForLocation(String pid, String location) throws IOException;
+
+	/**
+	 * Delete the configurations matching the filter specification.
+	 * 
+	 * @param filter the string representation of the
+	 *        <code>org.osgi.framework.Filter</code>
+	 * @throws IOException if the operation failed
+	 * @throws IllegalArgumentException if the filter is invalid
+	 */
+	void deleteConfigurations(String filter) throws IOException;
+
+	/**
+	 * Answer the bundle location the configuration is bound to
+	 * 
+	 * @param pid the persistent identifier of the configuration
+	 * @return the bundle location
+	 * @throws IOException if the operation fails
+	 */
+	String getBundleLocation(String pid) throws IOException;
+
+	/**
+	 * Answer the factory PID if the configuration is a factory configuration,
+	 * null otherwise.
+	 * 
+	 * @param pid the persistent identifier of the configuration
+	 * @return the factory PID
+	 * @throws IOException if the operation fails
+	 */
+	String getFactoryPid(String pid) throws IOException;
+
+	/**
+	 * Answer the factory PID if the configuration is a factory configuration,
+	 * null otherwise.
+	 * 
+	 * @param pid the persistent identifier of the configuration
+	 * @param location the bundle location
+	 * @return the factory PID
+	 * @throws IOException if the operation fails
+	 */
+	String getFactoryPidForLocation(String pid, String location) throws IOException;
+
+	/**
+	 * Answer the contents of the configuration <p/>
+	 * 
+	 * @see JmxConstants#PROPERTIES_TYPE for the details of the TabularType
+	 * 
+	 * @param pid the persistent identifier of the configuration
+	 * @return the table of contents
+	 * @throws IOException if the operation fails
+	 */
+
+	TabularData getProperties(String pid) throws IOException;
+
+	/**
+	 * Answer the contents of the configuration <p/>
+	 * 
+	 * @see JmxConstants#PROPERTIES_TYPE for the details of the TabularType
+	 * 
+	 * @param pid the persistent identifier of the configuration
+	 * @param location the bundle location
+	 * @return the table of contents
+	 * @throws IOException if the operation fails
+	 */
+	TabularData getPropertiesForLocation(String pid, String location) throws IOException;
+
+	/**
+	 * Answer the list of PID/Location pairs of the configurations managed by
+	 * this service
+	 * 
+	 * @param filter the string representation of the
+	 *        <code>org.osgi.framework.Filter</code>
+	 * @return the list of configuration PID/Location pairs
+	 * @throws IOException if the operation failed
+	 * @throws IllegalArgumentException if the filter is invalid
+	 */
+	String[][] getConfigurations(String filter) throws IOException;
+
+	/**
+	 * Set the bundle location the configuration is bound to
+	 * 
+	 * @param pid the persistent identifier of the configuration
+	 * @param location the bundle location
+	 * @throws IOException if the operation fails
+	 */
+	void setBundleLocation(String pid, String location) throws IOException;
+
+	/**
+	 * Update the configuration with the supplied properties For each property
+	 * entry, the following row is supplied <p/>
+	 * 
+	 * @see JmxConstants#PROPERTIES_TYPE for the details of the TabularType
+	 * 
+	 * @param pid the persistent identifier of the configuration
+	 * @param properties the table of properties
+	 * @throws IOException if the operation fails
+	 */
+	void update(String pid, TabularData properties) throws IOException;
+
+	/**
+	 * Update the configuration with the supplied properties For each property
+	 * entry, the following row is supplied <p/>
+	 * 
+	 * @see JmxConstants#PROPERTIES_TYPE for the details of the TabularType
+	 * 
+	 * @param pid the persistent identifier of the configuration
+	 * @param location the bundle location
+	 * @param properties the table of properties
+	 * @throws IOException if the operation fails
+	 */
+	void updateForLocation(String pid, String location, TabularData properties)
+			throws IOException;
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/permissionadmin/PermissionAdminMBean.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/permissionadmin/PermissionAdminMBean.java
index 3f24d583..e2baea3e 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/permissionadmin/PermissionAdminMBean.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/permissionadmin/PermissionAdminMBean.java
@@ -1 +1,82 @@
   + native
+/*
+ * Copyright (c) OSGi Alliance (2009). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.jmx.service.permissionadmin;
+
+import java.io.IOException;
+
+import org.osgi.jmx.JmxConstants;
+
+/**
+ * This MBean represents the OSGi Permission Manager Service
+ * 
+ * @version $Rev$
+ */
+public interface PermissionAdminMBean {
+	/**
+	 * Permission Admin MBean object name.
+	 */
+	String	OBJECTNAME	= JmxConstants.OSGI_CORE
+								+ ":service=permissionadmin,version=1.2";
+
+	/**
+	 * Answer the bundle locations that have permissions assigned to them
+	 * 
+	 * @return the bundle locations
+	 * @throws IOException if the operation fails
+	 */
+	String[] listLocations() throws IOException;
+
+	/**
+	 * Answer the list of encoded permissions of the bundle specified by the
+	 * bundle location
+	 * 
+	 * @param location location identifying the bundle
+	 * @return the array of String encoded permissions
+	 * @throws IOException if the operation fails
+	 */
+	String[] getPermissions(String location) throws IOException;
+
+	/**
+	 * Set the default permissions assigned to bundle locations that have no
+	 * assigned permissions
+	 * 
+	 * @param encodedPermissions the string encoded permissions
+	 * @throws IOException if the operation fails
+	 */
+	void setDefaultPermissions(String[] encodedPermissions) throws IOException;
+
+	/**
+	 * Answer the list of encoded permissions representing the default
+	 * permissions assigned to bundle locations that have no assigned
+	 * permissions
+	 * 
+	 * @return the array of String encoded permissions
+	 * @throws IOException if the operation fails
+	 */
+	String[] listDefaultPermissions() throws IOException;
+
+	/**
+	 * Set the permissions on the bundle specified by the bundle location
+	 * 
+	 * @param location the location of the bundle
+	 * @param encodedPermissions the string encoded permissions to set
+	 * @throws IOException if the operation fails
+	 */
+	void setPermissions(String location, String[] encodedPermissions)
+			throws IOException;
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/provisioning/ProvisioningServiceMBean.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/provisioning/ProvisioningServiceMBean.java
index e69de29b..c8b97a1f 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/provisioning/ProvisioningServiceMBean.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/provisioning/ProvisioningServiceMBean.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) OSGi Alliance (2009, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.jmx.service.provisioning;
+
+import java.io.IOException;
+
+import javax.management.openmbean.TabularData;
+
+import org.osgi.jmx.JmxConstants;
+
+/**
+ * This MBean represents the management interface to the OSGi Initial
+ * Provisioning Service
+ * 
+ * @version $Revision$
+ * @ThreadSafe
+ */
+public interface ProvisioningServiceMBean {
+	/**
+	 * Provisioning MBean object name.
+	 */
+	String	OBJECTNAME	= JmxConstants.OSGI_COMPENDIUM
+								+ ":service=provisioning,version=1.2";
+
+	/**
+	 * Processes the <code>ZipInputStream</code> contents of the provided
+	 * zipURL and extracts information to add to the Provisioning Information
+	 * dictionary, as well as, install/update and start bundles. This method
+	 * causes the <code>PROVISIONING_UPDATE_COUNT</code> to be incremented.
+	 * 
+	 * @param zipURL the String form of the URL that will be resolved into a
+	 *        <code>ZipInputStream</code> which will be used to add key/value
+	 *        pairs to the Provisioning Information dictionary and install and
+	 *        start bundles. If a <code>ZipEntry</code> does not have an
+	 *        <code>Extra</code> field that corresponds to one of the four
+	 *        defined MIME types (<code>MIME_STRING</code>,
+	 *        <code>MIME_BYTE_ARRAY</code>,<code>MIME_BUNDLE</code>, and
+	 *        <code>MIME_BUNDLE_URL</code>) in will be silently ignored.
+	 * @throws IOException if an error occurs while processing the
+	 *         ZipInputStream of the URL. No additions will be made to the
+	 *         Provisioning Information dictionary and no bundles must be
+	 *         started or installed.
+	 */
+	public void addInformationFromZip(String zipURL) throws IOException;
+
+	/**
+	 * Adds the key/value pairs contained in <code>info</code> to the
+	 * Provisioning Information dictionary. This method causes the
+	 * <code>PROVISIONING_UPDATE_COUNT</code> to be incremented.
+	 * 
+	 * @see JmxConstants#PROPERTIES_TYPE for details of the Tabular Data
+	 * 
+	 * @param info the set of Provisioning Information key/value pairs to add to
+	 *        the Provisioning Information dictionary. Any keys are values that
+	 *        are of an invalid type will be silently ignored.
+	 * @throws IOException if the operation fails
+	 */
+	public void addInformation(TabularData info) throws IOException;
+
+	/**
+	 * Returns a table representing the Provisioning Information Dictionary.
+	 * 
+	 * @see JmxConstants#PROPERTIES_TYPE for details of the Tabular Data
+	 * 
+	 * @throws IOException if the operation fails
+	 * @return The table representing the manager dictionary.
+	 */
+	public TabularData listInformation() throws IOException;
+
+	/**
+	 * Replaces the Provisioning Information dictionary with the entries of the
+	 * supplied table. This method causes the
+	 * <code>PROVISIONING_UPDATE_COUNT</code> to be incremented.
+	 * 
+	 * @see JmxConstants#PROPERTIES_TYPE for details of the Tabular Data
+	 * 
+	 * @param info the new set of Provisioning Information key/value pairs. Any
+	 *        keys are values that are of an invalid type will be silently
+	 *        ignored.
+	 * @throws IOException if the operation fails
+	 */
+	public void setInformation(TabularData info) throws IOException;
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/useradmin/UserAdminMBean.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/useradmin/UserAdminMBean.java
index e69de29b..79244c50 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/useradmin/UserAdminMBean.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-api/src/main/java/org/osgi/jmx/service/useradmin/UserAdminMBean.java
@@ -0,0 +1,527 @@
+/*
+ * Copyright (c) OSGi Alliance (2009, 2010). All Rights Reserved.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.osgi.jmx.service.useradmin;
+
+import java.io.IOException;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeType;
+import javax.management.openmbean.SimpleType;
+import javax.management.openmbean.TabularData;
+
+import org.osgi.jmx.Item;
+import org.osgi.jmx.JmxConstants;
+
+/**
+ * This MBean provides the management interface to the OSGi User Manager Service
+ * 
+ * @version $Revision$
+ * @ThreadSafe
+ */
+public interface UserAdminMBean {
+	/**
+	 * User Admin MBean object name.
+	 */
+	String			OBJECTNAME				= JmxConstants.OSGI_COMPENDIUM
+													+ ":service=useradmin,version=1.1";
+
+	/**
+	 * The key NAME, used in {@link #NAME_ITEM}.
+	 */
+	String			NAME					= "Name";
+
+	/**
+	 * The item for the user name for an authorization object. The key is
+	 * {@link #NAME} and the type is {@link SimpleType#STRING}.
+	 */
+	Item			NAME_ITEM				= new Item(
+													NAME,
+													"The user name for this authorization object",
+													SimpleType.STRING);
+
+	/**
+	 * The key ROLES, used in {@link #ROLES_ITEM}.
+	 */
+	String			ROLES					= "Roles";
+
+	/**
+	 * The item containing the roles for this authorization object. The key is
+	 * {@link #ROLES}. and the type is {@link JmxConstants#STRING_ARRAY_TYPE}.
+	 */
+	Item			ROLES_ITEM				= new Item(
+													ROLES,
+													"The names of the roles encapsulated by this auth object",
+													JmxConstants.STRING_ARRAY_TYPE);
+
+	/**
+	 * The Composite Type for an Authorization object. It consists of the
+	 * {@link #NAME_ITEM} and {@link #TYPE_ITEM} items.
+	 */
+	CompositeType	AUTORIZATION_TYPE		= Item
+													.compositeType(
+															"AUTHORIZATION",
+															"An authorization object defines which roles has a user got",
+															NAME_ITEM,
+															ROLES_ITEM);
+	/**
+	 * The Role TYPE key, used in {@link #TYPE_ITEM}.
+	 */
+	String			TYPE					= "Type";
+
+	/**
+	 * The item containing the type of the roles encapsulated by this
+	 * authorization object. The key is {@link #TYPE} and the type is
+	 * {@link SimpleType#INTEGER}.
+	 */
+	Item			TYPE_ITEM				= new Item(
+													TYPE,
+													"An integer representing type of the role: {0=Role,1=user,2=group}",
+													SimpleType.INTEGER);
+
+	/**
+	 * The PROPERTIES key, used in {@link #PROPERTIES_ITEM}.
+	 */
+	String			PROPERTIES				= "Properties";
+
+	/**
+	 * The item containing the properties of a Role. The key is
+	 * {@link #PROPERTIES} and the type is {@link JmxConstants#PROPERTIES_TYPE}.
+	 */
+	Item			PROPERTIES_ITEM			= new Item(
+													PROPERTIES,
+													"A properties as defined by org.osgi.service.useradmin.Role",
+													JmxConstants.PROPERTIES_TYPE);
+	/**
+	 * The Composite Type for a Role. It contains the following items:
+	 * <ul>
+	 * <li>{@link #NAME}</li>
+	 * <li>{@link #TYPE}</li>
+	 * <li>{@link #PROPERTIES}</li>
+	 * </ul>
+	 * 
+	 */
+	CompositeType	ROLE_TYPE				= Item
+													.compositeType(
+															"ROLE",
+															"Mapping of org.osgi.service.useradmin.Role for remote management purposes. User and Group extend Role",
+															NAME_ITEM,
+															TYPE_ITEM);
+
+	/**
+	 * The CREDENTIALS key, used in {@link #CREDENTIALS_ITEM}.
+	 */
+	String			CREDENTIALS				= "Credentials";
+
+	/**
+	 * The item containing the credentials of a user. The key is
+	 * {@link #CREDENTIALS} and the type is {@link JmxConstants#PROPERTIES_TYPE} .
+	 */
+	Item			CREDENTIALS_ITEM		= new Item(
+													CREDENTIALS,
+													"The credentials for this user",
+													JmxConstants.PROPERTIES_TYPE);
+
+	/**
+	 * A Composite Type for a User. A User contains its Role description and
+	 * adds the credentials. It extends {@link #ROLE_TYPE} and adds
+	 * {@link #CREDENTIALS_ITEM}.
+	 * 
+	 * This type extends the {@link #ROLE_TYPE}. It adds:
+	 * <ul>
+	 * <li>{@link #CREDENTIALS}</li>
+	 * </ul>
+	 */
+	CompositeType	USER_TYPE				= Item
+													.extend(
+															ROLE_TYPE,
+															"USER",
+															"Mapping of org.osgi.service.useradmin.User for remote management purposes. User extends Role");
+
+	/**
+	 * The MEMBERS key, used in {@link #MEMBERS_ITEM}.
+	 */
+	String			MEMBERS					= "Members";
+
+	/**
+	 * The item containing the members of a group. The key is {@link #MEMBERS}
+	 * and the type is {@link JmxConstants#STRING_ARRAY_TYPE}. It is used in
+	 * {@link #GROUP_TYPE}.
+	 */
+	Item			MEMBERS_ITEM			= new Item(
+													MEMBERS,
+													"The members of this group",
+													JmxConstants.STRING_ARRAY_TYPE);
+
+	/**
+	 * The REQUIRED_MEMBERS key, used in {@link #REQUIRED_MEMBERS_ITEM}.
+	 */
+	String			REQUIRED_MEMBERS		= "RequiredMembers";
+
+	/**
+	 * The item containing the required members of a group. The key is
+	 * {@link #REQUIRED_MEMBERS} and the type is
+	 * {@link JmxConstants#STRING_ARRAY_TYPE}. It is used in
+	 * {@link #GROUP_TYPE} .
+	 */
+	Item			REQUIRED_MEMBERS_ITEM	= new Item(
+													REQUIRED_MEMBERS,
+													"The required members of this group",
+													JmxConstants.STRING_ARRAY_TYPE);
+
+	/**
+	 * The Composite Type for a Group. It extends {@link #USER_TYPE} and adds
+	 * {@link #MEMBERS_ITEM}, and {@link #REQUIRED_MEMBERS_ITEM}.
+	 * 
+	 * This type extends the {@link #USER_TYPE}. It adds:
+	 * <ul>
+	 * <li>{@link #MEMBERS}</li>
+	 * <li>{@link #REQUIRED_MEMBERS}</li>
+	 * </ul>
+	 */
+	CompositeType	GROUP_TYPE				= Item
+													.extend(
+															USER_TYPE,
+															"GROUP",
+															"Mapping of org.osgi.service.useradmin.Group for remote management purposes. Group extends User which in turn extends Role",
+															MEMBERS_ITEM,
+															REQUIRED_MEMBERS_ITEM);
+
+	/**
+	 * Add credentials to a user, associated with the supplied key
+	 * 
+	 * @param key The key of the credential to add
+	 * @param value The value of the credential to add
+	 * @param username The name of the user that gets the credential.
+	 * @throws IOException if the operation fails
+	 * @throws IllegalArgumentException if the user name is not a User
+	 */
+	void addCredential(String key, byte[] value, String username)
+			throws IOException;
+
+	/**
+	 * Add credentials to a user, associated with the supplied key
+	 * 
+	 * @param key The key of the credential to add
+	 * @param value The value of the credential to add
+	 * @param username The name of the user that gets the credential.
+	 * @throws IOException if the operation fails
+	 * @throws IllegalArgumentException if the username is not a User
+	 */
+	void addCredentialString(String key, String value, String username)
+			throws IOException;
+
+	/**
+	 * Add a member to the group.
+	 * 
+	 * @param groupname The group name that receives the <code>rolename</code>
+	 *        as member.
+	 * @param rolename The <code>rolename</code> (User or Group) that must be
+	 *        added.
+	 * @return <code>true</code> if the role was added to the group
+	 * @throws IOException if the operation fails
+	 * 
+	 */
+	boolean addMember(String groupname, String rolename) throws IOException;
+
+	/**
+	 * Add or update a property on a role
+	 * 
+	 * @param key The key of the property to add
+	 * @param value The value of the property to add (<code>String</code>)
+	 * @param rolename The role name
+	 * @throws IOException if the operation fails
+	 */
+	void addPropertyString(String key, String value, String rolename)
+			throws IOException;
+
+	/**
+	 * Add or update a property on a role.
+	 * 
+	 * @param key The added property key
+	 * @param value The added byte[] property value
+	 * @param rolename The role name that receives the property
+	 * @throws IOException if the operation fails
+	 */
+	void addProperty(String key, byte[] value, String rolename)
+			throws IOException;
+
+	/**
+	 * Add a required member to the group
+	 * 
+	 * @param groupname The group name that is addded
+	 * @param rolename The role that
+	 * @return true if the role was added to the group
+	 * @throws IOException if the operation fails
+	 */
+	boolean addRequiredMember(String groupname, String rolename)
+			throws IOException;
+
+	/**
+	 * Create a User
+	 * 
+	 * @param name Name of the user to create
+	 * @throws IOException if the operation fails
+	 */
+	void createUser(String name) throws IOException;
+
+	/**
+	 * Create a Group
+	 * 
+	 * @param name Name of the group to create
+	 * @throws IOException if the operation fails
+	 */
+	void createGroup(String name) throws IOException;
+
+	/**
+	 * Create a Role
+	 * 
+	 * @param name of the role to create
+	 * @throws IOException if the operation fails
+	 */
+	void createRole(String name) throws IOException;
+
+	/**
+	 * Answer the authorization for the user name.
+	 * 
+	 * The Composite Data is typed by {@link #AUTORIZATION_TYPE}.
+	 * 
+	 * @param user The user name
+	 * @return the Authorization typed by {@link #AUTORIZATION_TYPE}.
+	 * @throws IOException if the operation fails
+	 * @throws IllegalArgumentException if the user name is not a User
+	 */
+	CompositeData getAuthorization(String user) throws IOException;
+
+	/**
+	 * Answer the credentials associated with a user.
+	 * 
+	 * The returned Tabular Data is typed by
+	 * {@link JmxConstants#PROPERTIES_TYPE}.
+	 * 
+	 * @param username The user name
+	 * @return the credentials associated with the user, see
+	 *         {@link JmxConstants#PROPERTIES_TYPE}
+	 * @throws IOException if the operation fails
+	 * @throws IllegalArgumentException if the user name is not a User
+	 */
+	TabularData getCredentials(String username) throws IOException;
+
+	/**
+	 * Answer the Group associated with the group name.
+	 * 
+	 * The returned Composite Data is typed by {@link #GROUP_TYPE}
+	 * 
+	 * @param groupname The group name
+	 * @return the Group, see {@link #GROUP_TYPE}
+	 * @throws IOException if the operation fails
+	 * @throws IllegalArgumentException if the group name is not a Group
+	 */
+	CompositeData getGroup(String groupname) throws IOException;
+
+	/**
+	 * Answer the list of group names
+	 * 
+	 * @return The list of group names
+	 * @throws IOException if the operation fails
+	 */
+	String[] listGroups() throws IOException;
+
+	/**
+	 * Answer the list of group names
+	 * 
+	 * @param filter The filter to apply
+	 * @return The list of group names
+	 * @throws IOException if the operation fails
+	 */
+	String[] getGroups(String filter) throws IOException;
+
+	/**
+	 * Answer the list of implied roles for a user
+	 * 
+	 * @param username The name of the user that has the implied roles
+	 * @return The list of role names
+	 * @throws IOException if the operation fails
+	 * @throws IllegalArgumentException if the username is not a User
+	 */
+	String[] getImpliedRoles(String username) throws IOException;
+
+	/**
+	 * Answer the the user names which are members of the group
+	 * 
+	 * @param groupname The name of the group to get the members from
+	 * @return The list of user names
+	 * @throws IOException if the operation fails
+	 * @throws IllegalArgumentException if the <code>groupname</code> is not a
+	 *         group
+	 */
+	String[] getMembers(String groupname) throws IOException;
+
+	/**
+	 * Answer the properties associated with a role.
+	 * 
+	 * The returned Tabular Data is typed by
+	 * {@link JmxConstants#PROPERTIES_TYPE}.
+	 * 
+	 * @param rolename The name of the role to get properties from
+	 * @return the properties associated with the role, see
+	 *         {@link JmxConstants#PROPERTIES_TYPE}
+	 * @throws IOException if the operation fails
+	 */
+	TabularData getProperties(String rolename) throws IOException;
+
+	/**
+	 * Answer the list of user names which are required members of this group
+	 * 
+	 * @param groupname The name of the group to get the required members from
+	 * @return The list of user names
+	 * @throws IOException if the operation fails
+	 * @throws IllegalArgumentException if the group name is not a group
+	 */
+	String[] getRequiredMembers(String groupname) throws IOException;
+
+	/**
+	 * Answer the role associated with a name.
+	 * 
+	 * The returned Composite Data is typed by {@link #ROLE_TYPE}.
+	 * 
+	 * @param name The name of the role to get the data from
+	 * @return the Role, see {@link #ROLE_TYPE}
+	 * @throws IOException if the operation fails
+	 */
+	CompositeData getRole(String name) throws IOException;
+
+	/**
+	 * Answer the list of role names in the User Admin database
+	 * 
+	 * @return The list of role names
+	 * @throws IOException if the operation fails
+	 */
+	String[] listRoles() throws IOException;
+
+	/**
+	 * Answer the list of role names which match the supplied filter
+	 * 
+	 * @param filter The string representation of the
+	 *        <code>org.osgi.framework.Filter</code> that is used to filter
+	 *        the roles by applying to the properties, if <code>null</code>
+	 *        all roles are returned.
+	 * 
+	 * @return The list the role names
+	 * @throws IOException if the operation fails
+	 */
+	String[] getRoles(String filter) throws IOException;
+
+	/**
+	 * Answer the User associated with the user name.
+	 * 
+	 * The returned Composite Data is typed by {@link #USER_TYPE}.
+	 * 
+	 * @param username The name of the requested user
+	 * @return The User, see {@link #USER_TYPE}
+	 * @throws IOException if the operation fails
+	 * @throws IllegalArgumentException if the <code>username</code> is not a
+	 *         User
+	 */
+	CompositeData getUser(String username) throws IOException;
+
+	/**
+	 * Answer the user name with the given property key-value pair from the User
+	 * Admin service database.
+	 * 
+	 * @param key The key to compare
+	 * @param value The value to compare
+	 * @return The User
+	 * @throws IOException if the operation fails
+	 */
+	String getUserWithProperty(String key, String value) throws IOException;
+
+	/**
+	 * Answer the list of user names in the User Admin database
+	 * 
+	 * @return The list of user names
+	 * @throws IOException if the operation fails
+	 */
+	String[] listUsers() throws IOException;
+
+	/**
+	 * Answer the list of user names in the User Admin database
+	 * 
+	 * @param filter The filter to apply
+	 * @return The list of user names
+	 * @throws IOException if the operation fails
+	 */
+	String[] getUsers(String filter) throws IOException;
+
+	/**
+	 * Remove the credential associated with the given user
+	 * 
+	 * @param key The key of the credential to remove
+	 * @param username The name of the user for which the credential must be
+	 *        removed
+	 * @throws IOException if the operation fails
+	 * @throws IllegalArgumentException if the username is not a User
+	 */
+	void removeCredential(String key, String username) throws IOException;
+
+	/**
+	 * Remove a role from the group
+	 * 
+	 * @param groupname The group name
+	 * @param rolename
+	 * @return true if the role was removed from the group
+	 * @throws IOException if the operation fails
+	 * @throws IllegalArgumentException if the groupname is not a Group
+	 */
+	boolean removeMember(String groupname, String rolename) throws IOException;
+
+	/**
+	 * Remove a property from a role
+	 * 
+	 * @param key
+	 * @param rolename
+	 * @throws IOException if the operation fails
+	 */
+	void removeProperty(String key, String rolename) throws IOException;
+
+	/**
+	 * Remove the Role associated with the name
+	 * 
+	 * @param name
+	 * @return true if the remove succeeded
+	 * @throws IOException if the operation fails
+	 */
+	boolean removeRole(String name) throws IOException;
+
+	/**
+	 * Remove the Group associated with the name
+	 * 
+	 * @param name
+	 * @return true if the remove succeeded
+	 * @throws IOException if the operation fails
+	 */
+	boolean removeGroup(String name) throws IOException;
+
+	/**
+	 * Remove the User associated with the name
+	 * 
+	 * @param name
+	 * @return true if the remove succeeded
+	 * @throws IOException if the operation fails
+	 */
+	boolean removeUser(String name) throws IOException;
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/BlueprintMetadataMBean.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/BlueprintMetadataMBean.java
index e69de29b..bd35116d 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/BlueprintMetadataMBean.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/BlueprintMetadataMBean.java
@@ -0,0 +1,1120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.jmx.blueprint;
+
+import java.io.IOException;
+
+import javax.management.openmbean.ArrayType;
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeType;
+import javax.management.openmbean.SimpleType;
+
+
+public interface BlueprintMetadataMBean {
+
+    /**
+     * The object name for this MBean.
+     */
+    String OBJECTNAME = JmxConstants.ARIES_BLUEPRINT+":service=blueprintMetadata,version=1.0";
+    
+    
+    ///////////////////////////////////////////////////////////////
+    // Define <value>'s CompositeType
+    ///////////////////////////////////////////////////////////////
+    
+    /**
+     * The key STRING_VALUE, used in {@link #STRING_VALUE_ITEM}.
+     */
+    String          STRING_VALUE            = "StringValue";
+    
+    /**
+     * The item containing the un-converted string representation of the value.
+     * The key is {@link #STRING_VALUE}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            STRING_VALUE_ITEM       = new Item(
+                                                    STRING_VALUE, 
+                                                    "The un-converted string representation of a value", 
+                                                    SimpleType.STRING);
+    
+    /**
+     * The key TYPE, used in {@link #TYPE_ITEM}.
+     */
+    String          TYPE                    = "Type";
+    
+    /**
+     * The item containing the name of the type to which the value should be converted.
+     * The key is {@link #TYPE}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            TYPE_ITEM               = new Item(
+                                                    TYPE, 
+                                                    "The type of a value", 
+                                                    SimpleType.STRING);
+    
+    /**
+     * The name of CompositeType for ValueMetadata objects, used in {@link #VALUE_METADATA_TYPE}.
+     */
+    String          VALUE_METADATA          = "ValueMetadata";
+    
+    
+    /**
+     * The CompositeType encapsulates ValueMetadata objects. It contains the following items:
+     * <ul>
+     * <li>{@link #STRING_VALUE}</li>
+     * <li>{@link #TYPE}</li>
+     * </ul>
+     */
+    CompositeType   VALUE_METADATA_TYPE     = Item.compositeType(
+                                                    VALUE_METADATA, 
+                                                    "This type encapsulates ValueMetadata objects", 
+                                                    STRING_VALUE_ITEM, 
+                                                    TYPE_ITEM);                  
+    
+    ///////////////////////////////////////////////////////////////
+    // Define <null>'s CompositeType
+    ///////////////////////////////////////////////////////////////  
+    
+    /**
+     * The key PLACEHOLDER, used in {@link #PLACEHOLDER_ITEM}.
+     */ 
+    String          PLACEHOLDER             = "Placeholder";
+    
+    /**
+     * The item is a placeholder in the null metadata type.
+     * The key is {@link #PLACEHOLDER}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            PLACEHOLDER_ITEM        = new Item(
+                                                    PLACEHOLDER, 
+                                                    "This is a placeholder", 
+                                                    SimpleType.VOID);
+    
+    /**
+     * The name of CompositeType for NullMetadata objects, used in {@link #NULL_METADATA_TYPE}.
+     */
+    String          NULL_METADATA          = "NullMetadata";
+    
+    /**
+     * The CompositeType for NullMetadata objects. A composite type requires at least one item, so we add a placeholder item.
+     */
+    CompositeType   NULL_METADATA_TYPE      = Item.compositeType(
+                                                    NULL_METADATA, 
+                                                    "This type encapsulates NullMetadata objects", 
+                                                    PLACEHOLDER_ITEM);
+    
+    ///////////////////////////////////////////////////////////////
+    // Define <ref>'s CompositeType
+    ///////////////////////////////////////////////////////////////      
+    
+    /**
+     * The key COMPONENT_ID, used in {@link #COMPONENT_ID_ITEM}.
+     */
+    String          COMPONENT_ID            = "ComponentId";
+    
+    /**
+     * The item containing the component id to which the "ref" associates.
+     * The key is {@link #COMPONENT_ID}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            COMPONENT_ID_ITEM       = new Item(
+                                                    COMPONENT_ID,
+                                                    "The component id",
+                                                    SimpleType.STRING);
+    /**
+     * The name of CompositeType for RefMetadata objects, used in {@link #REF_METADATA_TYPE}.
+     */
+    String          REF_METADATA          = "RefMetadata";
+    
+    /**
+     * The CompositeType for a RefMetadata object. It contains the following items:
+     * <ul>
+     * <li>{@link #COMPONENT_ID}</li>
+     * </ul>
+     */
+    CompositeType   REF_METADATA_TYPE       = Item.compositeType(
+                                                    REF_METADATA, 
+                                                    "This type encapsulates RefMetadata objects", 
+                                                    COMPONENT_ID_ITEM);
+
+    ///////////////////////////////////////////////////////////////
+    // Define <idref>'s CompositeType
+    // COMPONENT_ID_ITEM defined in <ref>'s definition
+    ///////////////////////////////////////////////////////////////  
+    /**
+     * The name of CompositeType for IdRefMetadata objects, used in {@link #ID_REF_METADATA_TYPE}.
+     */
+    String          ID_REF_METADATA          = "IdRefMetadata";
+    
+    /**
+     * The CompositeType for an IdRefMetadata object. It contains the following items:
+     * <ul>
+     * <li>{@link #COMPONENT_ID}</li>
+     * </ul>
+     */
+    CompositeType   ID_REF_METADATA_TYPE    = Item.compositeType(
+                                                    ID_REF_METADATA, 
+                                                    "This type encapsulates IdRefMetadata objects", 
+                                                    COMPONENT_ID_ITEM);
+    
+    ///////////////////////////////////////////////////////////////
+    // Define <entry>'s CompositeType, 
+    // used by MapMetadata, PropsMetadata, and Service properties
+    ///////////////////////////////////////////////////////////////    
+    
+    /**
+     * The key KEY, used in {@link #KEY_ITEM}.
+     */    
+    String          KEY                     = "Key";
+    
+    /**
+     * The item containing the key of an entry.
+     * The key is {@link #KEY}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            KEY_ITEM                = new Item(
+                                                    KEY,
+                                                    "The key of an entry",
+                                                    JmxConstants.BYTE_ARRAY_TYPE);
+    
+    /**
+    * The key VALUE, used in {@link #VALUE_ITEM}.
+    */
+    String          VALUE                   = "Value";
+       
+    /**
+    * The item containing a value and this will be used by 
+    * BeanArgument, BeanProperty, MapEntry and CollectionMetadata.
+    * The key is {@link #VALUE}, and the type is {@link JmxConstants#PRIMITIVE_BYTE_ARRAY_TYPE}.
+    */
+    Item            VALUE_ITEM              = new Item(
+                                                   VALUE, 
+                                                   "A value", 
+                                                   JmxConstants.BYTE_ARRAY_TYPE);  
+
+    /**
+     * The name of CompositeType for MapEntry objects, used in {@link #MAP_ENTRY_TYPE}.
+     */
+    String          MAP_ENTRY          = "MapEntry";
+    
+    /**
+     * The CompositeType for a MapEntry object. It contains the following items:
+     * <ul>
+     * <li>{@link #KEY}</li>
+     * <li>{@link #VALUE}</li>
+     * </ul>
+     */
+    CompositeType   MAP_ENTRY_TYPE          = Item.compositeType(
+                                                   MAP_ENTRY, 
+                                                   "This type encapsulates MapEntry objects",
+                                                   KEY_ITEM,
+                                                   VALUE_ITEM);
+    
+    ///////////////////////////////////////////////////////////////
+    // Define <map>'s CompositeType
+    ///////////////////////////////////////////////////////////////
+    
+    /**
+     * The key ENTRIES, used in {@link #ENTRIES_ITEM}.
+     */
+    String          ENTRIES                 = "Entries";
+    
+    /**
+     * The item containing an array of entries
+     * The key is {@link #ENTRIES}, and the type is {@link ArrayType}.
+     */
+    Item            ENTRIES_ITEM            = new Item(
+                                                    ENTRIES,
+                                                    "An array of entries",
+                                                    Item.arrayType(1, MAP_ENTRY_TYPE));
+    
+    /**
+     * The key KEY_TYPE, used in {@link #KEY_TYPE_ITEM}.
+     */
+    String          KEY_TYPE                = "KeyType";
+    
+    /**
+     * The item containing the key type of the entries.
+     * The key is {@link #KEY_TYPE}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            KEY_TYPE_ITEM           = new Item(
+                                                    KEY_TYPE,
+                                                    "The key type of the entries",
+                                                    SimpleType.STRING);
+    
+    /**
+     * The key VALUE_TYPE, used in {@link #VALUE_TYPE_ITEM}.
+     */
+    String          VALUE_TYPE              = "ValueType";
+    
+    /**
+     * The item containing the value type that the value should be
+     * The key is {@link #VALUE_TYPE}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            VALUE_TYPE_ITEM         = new Item(
+                                                    VALUE_TYPE, 
+                                                    "The value type", 
+                                                    SimpleType.STRING);
+    
+    /**
+     * The name of CompositeType for MapMetadata objects, used in {@link #MAP_METADATA_TYPE}.
+     */
+    String          MAP_METADATA          = "MapMetadata";
+    
+    /**
+     * The CompositeType for a MapMetadata object. It contains the following items:
+     * <ul>
+     * <li>{@link #ENTRIES}</li>
+     * <li>{@link #KEY_TYPE}</li>
+     * <li>{@link #VALUE_TYPE}</li>
+     * </ul>
+     */
+    CompositeType   MAP_METADATA_TYPE       = Item.compositeType(
+                                                    MAP_METADATA, 
+                                                    "This type encapsulates MapMetadata objects",
+                                                    ENTRIES_ITEM,
+                                                    KEY_TYPE_ITEM,
+                                                    VALUE_TYPE_ITEM);
+    
+    ///////////////////////////////////////////////////////////////
+    // Define <props>'s CompositeType
+    // ENTRIES_ITEM defined in <map>'s definition
+    ///////////////////////////////////////////////////////////////
+
+    /**
+     * The name of CompositeType for PropsMetadata objects, used in {@link #PROPS_METADATA_TYPE}.
+     */
+    String          PROPS_METADATA          = "PropsMetadata";    
+    
+    /**
+     * The CompositeType for a PropsMetadata object. It contains the following items:
+     * <ul>
+     * <li>{@link #ENTRIES}</li>
+     * </ul>
+     */
+    CompositeType   PROPS_METADATA_TYPE     = Item.compositeType(
+                                                    PROPS_METADATA, 
+                                                    "This type encapsulates PropsMetadata objects",
+                                                    ENTRIES_ITEM);
+    
+    ///////////////////////////////////////////////////////////////
+    // Define <collection>'s CompositeType
+    // VALUE_TYPE_ITEM defined in <map>'s definition
+    ///////////////////////////////////////////////////////////////   
+    
+    /**
+     * The key COLLECTION_CLASS, used in {@link #KEY_TYPE_ITEM}.
+     */
+    String          COLLECTION_CLASS        = "CollectionClass";    
+    
+    /**
+     * The item containing the type of this collection
+     * The key is {@link #COLLECTION_CLASS}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            COLLECTION_CLASS_ITEM   = new Item(
+                                                    COLLECTION_CLASS,
+                                                    "The type of this collection",
+                                                    SimpleType.STRING);
+    
+    /**
+     * The key VALUES, used in {@link #VALUES_ITEM}.
+     */
+    String          VALUES                  = "Values";
+    
+    /**
+     * The item containing all the values
+     * The key is {@link #VALUES}, and the type is {@link ArrayType}.
+     */
+    Item            VALUES_ITEM             = new Item(
+                                                    VALUES,
+                                                    "All the values",
+                                                    Item.arrayType(2, SimpleType.BYTE));
+    
+
+    /**
+     * The name of CompositeType for CollectionMetadata objects, used in {@link #COLLECTION_METADATA_TYPE}.
+     */
+    String          COLLECTION_METADATA          = "CollectionMetadata";    
+    
+    /**
+     * The CompositeType for a CollectionMetadata object. It contains the following items:
+     * <ul>
+     * <li>{@link #COLLECTION_CLASS}</li>
+     * <li>{@link #VALUES}</li>
+     * <li>{@link #VALUE_TYPE}</li>
+     * </ul>
+     */
+    CompositeType   COLLECTION_METADATA_TYPE= Item.compositeType(
+                                                    COLLECTION_METADATA, 
+                                                    "This type encapsulates CollectionMetadata objects",
+                                                    COLLECTION_CLASS_ITEM,
+                                                    VALUES_ITEM,
+                                                    VALUE_TYPE_ITEM);
+   
+    ///////////////////////////////////////////////////////////////
+    // Define <argument>'s CompositeType
+    // VALUE_TYPE_ITEM defined in <map>'s definition
+    ///////////////////////////////////////////////////////////////
+    
+    /**
+     * The key INDEX, used in {@link #INDEX_ITEM}.
+     */
+    String          INDEX                   = "Index";
+    
+    /**
+     * The item containing the zero-based index into the parameter list of
+     * the factory method or constructor to be invoked for this argument.
+     * The key is {@link #INDEX}, and the type is {@link SimpleType#INTEGER}.
+     */
+    Item            INDEX_ITEM              = new Item(
+                                                    INDEX, 
+                                                    "The zero-based index", 
+                                                    SimpleType.INTEGER);
+
+    /**
+     * The name of CompositeType for BeanArgument objects, used in {@link #BEAN_ARGUMENT_TYPE}.
+     */
+    String          BEAN_ARGUMENT               = "BeanArgument";    
+
+    
+    /**
+     * The CompositeType for a Argument object. It contains the following items:
+     * <ul>
+     * <li>{@link #INDEX}</li>
+     * <li>{@link #VALUE_TYPE}</li>
+     * <li>{@link #VALUE}</li>
+     * </ul>
+     */
+    CompositeType   BEAN_ARGUMENT_TYPE          = Item.compositeType(
+                                                    BEAN_ARGUMENT,
+                                                    "This type encapsulates BeanArgument objects",
+                                                    INDEX_ITEM,
+                                                    VALUE_TYPE_ITEM,
+                                                    VALUE_ITEM);
+       
+    ///////////////////////////////////////////////////////////////
+    // Define <property>'s CompositeType
+    ///////////////////////////////////////////////////////////////
+    
+    /**
+     * The key NAME, used in {@link #NAME_ITEM}.
+     */
+    String          NAME                    = "Name";
+    
+    /**
+     * The item containing the name of the property to be injected.
+     * The key is {@link #NAME}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            NAME_ITEM               = new Item(
+                                                    NAME,
+                                                    "The name of the property",
+                                                    SimpleType.STRING);
+    
+    /**
+     * The name of CompositeType for BeanProperty objects, used in {@link #BEAN_PROPERTY_TYPE}.
+     */
+    String          BEAN_PROPERTY               = "BeanProperty";    
+    
+    /**
+     * The CompositeType for property type. It contains the following items:
+     * <ul>
+     * <li>{@link #NAME}</li>
+     * <li>{@link #VALUE}</li>
+     * </ul>
+     */
+    CompositeType   BEAN_PROPERTY_TYPE           = Item.compositeType(
+                                                    BEAN_PROPERTY, 
+                                                    "This type encapsulates BeanProperty objects",
+                                                    NAME_ITEM,
+                                                    VALUE_ITEM);
+        
+    ///////////////////////////////////////////////////////////////
+    // Define Component's CompositeType
+    // <bean>, <service> & Service Reference's CompositeType will 
+    // extend this.
+    ///////////////////////////////////////////////////////////////
+    
+    /**
+     * The key ID, used in {@link #ID_ITEM}.
+     */
+    String          ID                    = "Id";
+
+    /**
+     * The item containing the component id of a component. 
+     * The key is {@link #ID}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            ID_ITEM       = new Item(
+                                                    ID,
+                                                    "The id of the component",
+                                                    SimpleType.STRING);
+    /**
+     * The key ACTIVATION, used in {@link #ACTIVATION_ITEM}.
+     */
+    String          ACTIVATION              = "Activation";
+    
+    /**
+     * The item containing the activation strategy for a component. 
+     * The key is {@link #ACTIVATION}, and the type is {@link SimpleType#INTEGER}.
+     */
+    Item            ACTIVATION_ITEM         = new Item(
+                                                    ACTIVATION,
+                                                    "The activation strategy for a component",
+                                                    SimpleType.INTEGER);
+    
+    /**
+     * The key DEPENDS_ON, used in {@link #DEPENDS_ON_ITEM}.
+     */
+    String          DEPENDS_ON              = "DependsOn";
+    
+    /**
+     * The item containing the ids of any components listed in a <code>depends-on</code> attribute for the component. 
+     * The key is {@link #DEPENDS_ON}, and the type is {@link JmxConstants#STRING_ARRAY_TYPE}.
+     */
+    Item            DEPENDS_ON_ITEM         = new Item(
+                                                    DEPENDS_ON,
+                                                    "The ids of any components listed in a depends-on attribute",
+                                                    JmxConstants.STRING_ARRAY_TYPE);
+    
+    /**
+     * The name of CompositeType for ComponentMetadata objects, used in {@link #COMPONENT_METADATA_TYPE}.
+     */
+    String          COMPONENT_METADATA               = "ComponentMetadata";    
+    
+    /**
+     * The CompositeType for a ComponentMetadata object, it contains 
+     * the following items:
+     * <ul>
+     * <li>{@link #ID}</li>
+     * <li>{@link #ACTIVATION}</li>
+     * <li>{@link #DEPENDS_ON}</li>
+     * </ul>
+     */
+    CompositeType   COMPONENT_METADATA_TYPE     = Item.compositeType(
+                                                    COMPONENT_METADATA,
+                                                    "This type encapsulates ComponentMetadata objects",
+                                                    ID_ITEM,
+                                                    ACTIVATION_ITEM,
+                                                    DEPENDS_ON_ITEM);
+                            
+    ///////////////////////////////////////////////////////////////
+    // Define <bean>'s CompositeType
+    ///////////////////////////////////////////////////////////////
+    
+    /**
+     * The key CLASS_NAME, used in {@link #CLASS_NAME_ITEM}.
+     */
+    String          CLASS_NAME              = "ClassName";
+    
+    /**
+     * The item containing the name of the class specified for the bean. 
+     * The key is {@link #CLASS_NAME}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            CLASS_NAME_ITEM         = new Item(
+                                                    CLASS_NAME,
+                                                    "The name of the class specified for the bean",
+                                                    SimpleType.STRING
+                                                    );
+    
+    /**
+     * The key INIT_METHOD, used in {@link #INIT_METHOD_ITEM}.
+     */
+    String          INIT_METHOD             = "InitMethod";
+    
+    /**
+     * The item containing the name of the init method specified for the bean.
+     * The key is {@link #INIT_METHOD}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            INIT_METHOD_ITEM        = new Item(
+                                                    INIT_METHOD, 
+                                                    "The name of the init method specified for the bean", 
+                                                    SimpleType.STRING);
+    
+    /**
+     * The key DESTROY_METHOD, used in {@link #DESTROY_METHOD_ITEM}.
+     */
+    String          DESTROY_METHOD          = "DestroyMethod";
+    
+    /**
+     * The item containing the name of the destroy method specified for the bean.
+     * The key is {@link #DESTROY_METHOD}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            DESTROY_METHOD_ITEM     = new Item(
+                                                    DESTROY_METHOD, 
+                                                    "The name of the destroy method specified for the bean", 
+                                                    SimpleType.STRING);
+
+    /**
+     * The key FACTORY_METHOD, used in {@link #FACTORY_METHOD_ITEM}.
+     */
+    String          FACTORY_METHOD          = "FactoryMethod";
+    
+    /**
+     * The item containing the name of the factory method specified for the bean.
+     * The key is {@link #FACTORY_METHOD}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            FACTORY_METHOD_ITEM     = new Item(
+                                                    FACTORY_METHOD, 
+                                                    "The name of the factory method specified for the bean", 
+                                                    SimpleType.STRING);
+    
+    /**
+     * The key FACTORY_COMPONENT, used in {@link #FACTORY_COMPONENT_ITEM}.
+     */
+    String          FACTORY_COMPONENT       = "FactoryComponent";
+    
+    /**
+     * The item containing the id of the factory component on which to invoke the factory method for the bean.
+     * The key is {@link #FACTORY_COMPONENT}, and the type is {@link JmxConstants#PRIMITIVE_BYTE_ARRAY_TYPE}.
+     */
+    Item            FACTORY_COMPONENT_ITEM  = new Item(
+                                                    FACTORY_COMPONENT, 
+                                                    "The factory component on which to invoke the factory method for the bean", 
+                                                    JmxConstants.BYTE_ARRAY_TYPE);
+    
+    /**
+     * The key SCOPE, used in {@link #SCOPE_ITEM}.
+     */
+    String          SCOPE                   = "Scope";
+    
+    /**
+     * The item containing the scope for the bean.
+     * The key is {@link #SCOPE}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            SCOPE_ITEM              = new Item(
+                                                    SCOPE, 
+                                                    "The scope for the bean", 
+                                                    SimpleType.STRING);
+
+    /**
+     * The key ARGUMENT, used in {@link #ARGUMENTS_ITEM}.
+     */
+    String          ARGUMENTS                   = "Arguments";
+        
+    /**
+     * The item containing the bean argument for the bean's compositeType.
+     * The key is {@link #ARGUMENTS}, and the type is {@link ARGUMENT_TYPE}.
+     */
+    Item           ARGUMENTS_ITEM     = new Item(
+                                                    ARGUMENTS, 
+                                                    "The bean argument", 
+                                                    Item.arrayType(1, BEAN_ARGUMENT_TYPE));
+    
+    /**
+     * The key PROPERTY, used in {@link #PROPERTIES_ITEM}.
+     */
+    String          PROPERTIES         = "Properties";
+        
+    /**
+     * The item containing the bean property for the bean's compositeType.
+     * The key is {@link #PROPERTIES}, and the type is {@link PROPERTY_TYPE}.
+     */
+    Item            PROPERTIES_ITEM    = new Item(
+                                                    PROPERTIES, 
+                                                    "The bean property", 
+                                                    Item.arrayType(1, BEAN_PROPERTY_TYPE));
+    
+    /**
+     * The name of CompositeType for BeanMetadata objects, used in {@link #BEAN_METADATA_TYPE}.
+     */
+    String          BEAN_METADATA               = "BeanMetadata";    
+    
+    /**
+     * The CompositeType for a BeanMetadata object, it extends {@link #COMPONENT_METADATA_TYPE} 
+     * and adds the following items:
+     * <ul>
+     * <li>{@link #CLASS_NAME}</li>
+     * <li>{@link #INIT_METHOD}</li>
+     * <li>{@link #DESTROY_METHOD}</li>
+     * <li>{@link #FACTORY_METHOD}</li>
+     * <li>{@link #FACTORY_COMPONENT}</li>
+     * <li>{@link #SCOPE}</li>
+     * <li>{@link #ARGUMENTS}</li>
+     * <li>{@link #PROPERTIES}</li>
+     * </ul>
+     */
+    CompositeType   BEAN_METADATA_TYPE      = Item.extend(
+                                                    COMPONENT_METADATA_TYPE, 
+                                                    BEAN_METADATA, 
+                                                    "This type encapsulates BeanMetadata objects",
+                                                    CLASS_NAME_ITEM,
+                                                    INIT_METHOD_ITEM,
+                                                    DESTROY_METHOD_ITEM, 
+                                                    FACTORY_METHOD_ITEM,
+                                                    FACTORY_COMPONENT_ITEM,
+                                                    SCOPE_ITEM,
+                                                    ARGUMENTS_ITEM,
+                                                    PROPERTIES_ITEM);
+
+    ///////////////////////////////////////////////////////////////
+    // Define <registration-listener>'s CompositeType
+    ///////////////////////////////////////////////////////////////
+    
+    /**
+     * The key LISTENER_COMPONENT, used in {@link #LISTENER_COMPONENT_ITEM}.
+     */
+    String          LISTENER_COMPONENT      = "ListenerComponent";
+    
+    /**
+     * The item containing the listener component.
+     * The key is {@link #LISTENER_COMPONENT}, and the type is {@link JmxConstants#PRIMITIVE_BYTE_ARRAY_TYPE}.
+     */
+    Item            LISTENER_COMPONENT_ITEM = new Item(
+                                                    LISTENER_COMPONENT, 
+                                                    "The listener component", 
+                                                    JmxConstants.BYTE_ARRAY_TYPE);
+    
+    /**
+     * The key REGISTRATION_METHOD, used in {@link #REGISTRATION_METHOD_ITEM}.
+     */
+    String          REGISTRATION_METHOD     = "RegistrationMethod";
+    
+    /**
+     * The item containing the name of the registration method.
+     * The key is {@link #REGISTRATION_METHOD}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            REGISTRATION_METHOD_ITEM    = new Item(
+                                                    REGISTRATION_METHOD, 
+                                                    "The name of the registration method", 
+                                                    SimpleType.STRING);
+    
+    /**
+     * The key UNREGISTRATION_METHOD, used in {@link #UNREGISTRATION_METHOD_ITEM}.
+     */
+    String          UNREGISTRATION_METHOD       = "UnregistrationMethod";
+    
+    /**
+     * The item containing the name of the unregistration method.
+     * The key is {@link #UNREGISTRATION_METHOD}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            UNREGISTRATION_METHOD_ITEM  = new Item(
+                                                    UNREGISTRATION_METHOD, 
+                                                    "The name of the unregistration method", 
+                                                    SimpleType.STRING);
+    
+    /**
+     * The name of CompositeType for RegistrationListener objects, used in {@link #REGISTRATION_LISTENER_TYPE}.
+     */
+    String          REGISTRATION_LISTENER               = "RegistrationListener";    
+    
+    /**
+     * The CompositeType for a registration listener, and it contains the following items:
+     * <ul>
+     * <li>{@link #LISTENER_COMPONENT}</li>
+     * <li>{@link #REGISTRATION_METHOD}</li>
+     * <li>{@link #UNREGISTRATION_METHOD}</li>
+     * </ul>
+     */
+    CompositeType   REGISTRATION_LISTENER_TYPE  = Item.compositeType(
+                                                    REGISTRATION_LISTENER, 
+                                                    "This type encapsulates RegistrationListener objects",
+                                                    LISTENER_COMPONENT_ITEM,
+                                                    REGISTRATION_METHOD_ITEM,
+                                                    UNREGISTRATION_METHOD_ITEM);
+    
+    
+    ///////////////////////////////////////////////////////////////
+    // Define <service>'s CompositeType
+    ///////////////////////////////////////////////////////////////
+    
+    /**
+     * The key INTERFACES, used in {@link #INTERFACES_ITEM}.
+     */
+    String          INTERFACES              = "Interfaces";
+    
+    /**
+     * The item containing the type names of the interfaces that the service should be advertised as supporting.
+     * The key is {@link #INTERFACES}, and the type is {@link JmxConstants#STRING_ARRAY_TYPE}.
+     */
+    Item            INTERFACES_ITEM         = new Item(
+                                                    INTERFACES, 
+                                                    "The type names of the interfaces", 
+                                                    JmxConstants.STRING_ARRAY_TYPE);
+    /**
+     * The key AUTO_EXPORT, used in {@link #AUTO_EXPORT_ITEM}.
+     */
+    String          AUTO_EXPORT             = "AutoExport";
+    
+    /**
+     * The item containing the auto-export mode for the service.
+     * The key is {@link #AUTO_EXPORT}, and the type is {@link SimpleType#INTEGER}.
+     */
+    //TODO describe integer
+    Item            AUTO_EXPORT_ITEM        = new Item(
+                                                    AUTO_EXPORT, 
+                                                    "The auto-export mode for the service", 
+                                                    SimpleType.INTEGER);
+
+    /**
+     * The key RANKING, used in {@link #RANKING_ITEM}.
+     */
+    String          RANKING                 = "Ranking";
+    
+    /**
+     * The item containing the ranking value to use when advertising the service.
+     * The key is {@link #RANKING}, and the type is {@link SimpleType#INTEGER}.
+     */
+    Item            RANKING_ITEM            = new Item(
+                                                    RANKING, 
+                                                    "The ranking value when advertising the service", 
+                                                    SimpleType.INTEGER);
+
+    /**
+     * The key SERVICE_COMPONENT, used in {@link #SERVICE_COMPONENT_ITEM}.
+     */
+    String          SERVICE_COMPONENT       = "ServiceComponent";
+    
+    /**
+     * The item containing the id of the component to be exported as a service.
+     * The key is {@link #SERVICE_COMPONENT}, and the type is {@link JmxConstants#PRIMITIVE_BYTE_ARRAY_TYPE}.
+     */
+    Item            SERVICE_COMPONENT_ITEM  = new Item(
+                                                    SERVICE_COMPONENT, 
+                                                    "The component to be exported as a service", 
+                                                    JmxConstants.BYTE_ARRAY_TYPE);
+    
+    /**
+     * The key SERVICE_PROPERTIES, used in {@link #SERVICE_PROPERTIES_ITEM}.
+     */
+    String          SERVICE_PROPERTIES      = "ServiceProperties";
+    
+    /**
+     * The item containing the user declared properties to be advertised with the service.
+     * The key is {@link #SERVICE_COMPONENT}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            SERVICE_PROPERTIES_ITEM = new Item(
+                                                    SERVICE_PROPERTIES,
+                                                    "The user declared properties to be advertised with the service",
+                                                    Item.arrayType(1, MAP_ENTRY_TYPE));
+    
+    /**
+     * The key REGISTRATION_LISTENERS, used in {@link #SERVICE_LISTENERS_ITEM}.
+     */
+    String          REGISTRATION_LISTENERS  = "RegistrationListeners";
+    
+    /**
+     * The item containing all the registration listeners.
+     * The key is {@link #REGISTRATION_LISTENERS}, and the type is {@link ArrayType}.
+     */
+    Item            REGISTRATION_LISTENERS_ITEM = new Item(
+                                                    REGISTRATION_LISTENERS,
+                                                    "All the registration listeners",
+                                                    Item.arrayType(1, REGISTRATION_LISTENER_TYPE));
+    
+    /**
+     * The name of CompositeType for ServiceMetadata objects, used in {@link #SERVICE_METADATA_TYPE}.
+     */
+    String          SERVICE_METADATA               = "ServiceMetadata";    
+    
+    /**
+     * The CompositeType for a ServiceMetadata object, it extends {@link #COMPONENT_METADATA_TYPE}
+     * and adds the following items:
+     * <ul>
+     * <li>{@link #INTERFACES}</li>
+     * <li>{@link #AUTO_EXPORT}</li>
+     * <li>{@link #RANKING}</li>
+     * <li>{@link #SERVICE_COMPONENT}</li>
+     * <li>{@link #SERVICE_PROPERTIES}</li>
+     * <li>{@link #REGISTRATION_LISTENERS}</li>
+     * </ul>
+     */
+    CompositeType   SERVICE_METADATA_TYPE   = Item.extend(
+                                                    COMPONENT_METADATA_TYPE, 
+                                                    SERVICE_METADATA, 
+                                                    "This type encapsulates ServiceMetadata objects",
+                                                    INTERFACES_ITEM,
+                                                    AUTO_EXPORT_ITEM,
+                                                    RANKING_ITEM,
+                                                    SERVICE_COMPONENT_ITEM,
+                                                    SERVICE_PROPERTIES_ITEM,
+                                                    REGISTRATION_LISTENERS_ITEM);
+
+    ///////////////////////////////////////////////////////////////
+    // Define <reference-listener>'s CompositeType
+    // LISTENER_COMPONENT_ITEM defined in the <registration-listener>
+    ///////////////////////////////////////////////////////////////
+    
+    /**
+     * The key BIND_METHOD, used in {@link #BIND_METHOD_ITEM}.
+     */
+    String          BIND_METHOD                 = "BindMethod";
+    
+    /**
+     * The item containing the name of the bind method.
+     * The key is {@link #BIND_METHOD}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            BIND_METHOD_ITEM            = new Item(
+                                                    BIND_METHOD, 
+                                                    "The name of the bind method", 
+                                                    SimpleType.STRING);
+    
+    /**
+     * The key UNBIND_METHOD, used in {@link #UNBIND_METHOD_ITEM}.
+     */
+    String          UNBIND_METHOD               = "UnbindMethod";
+    
+    /**
+     * The item containing the name of the unbind method.
+     * The key is {@link #UNBIND_METHOD}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            UNBIND_METHOD_ITEM          = new Item(
+                                                    UNBIND_METHOD, 
+                                                    "The name of the unbind method", 
+                                                    SimpleType.STRING);
+    
+    /**
+     * The name of CompositeType for ReferenceListener objects, used in {@link #REFERENCE_LISTENER_TYPE}.
+     */
+    String          REFERENCE_LISTENER               = "ReferenceListener"; 
+    
+    /**
+     * The CompositeType for a reference listener, and it contains the following items:
+     * <ul>
+     * <li>{@link #LISTENER_COMPONENT}</li>
+     * <li>{@link #BIND_METHOD}</li>
+     * <li>{@link #UNBIND_METHOD}</li>
+     * </ul>
+     */
+    CompositeType   REFERENCE_LISTENER_TYPE  = Item.compositeType(
+                                                    REFERENCE_LISTENER, 
+                                                    "This type encapsulates ReferenceListener objects",
+                                                    LISTENER_COMPONENT_ITEM,
+                                                    BIND_METHOD_ITEM,
+                                                    UNBIND_METHOD_ITEM);
+    
+    
+    ///////////////////////////////////////////////////////////////
+    // Define Service Reference's CompositeType, 
+    // <reference> & <reference-list> will extend this
+    ///////////////////////////////////////////////////////////////
+    
+    /**
+     * The key AVAILABILITY, used in {@link #AVAILABILITY_ITEM}.
+     */
+    String          AVAILABILITY            = "Availability";
+    
+    /**
+     * The item specify whether or not a matching service is required at all times.
+     * The key is {@link #AVAILABILITY}, and the type is {@link SimpleType#INTEGER}.
+     * 
+     */
+    //TODO add description for each int
+    Item            AVAILABILITY_ITEM       = new Item(
+                                                    AVAILABILITY, 
+                                                    "To specify whether or not a matching service is required at all times", 
+                                                    SimpleType.INTEGER);
+    
+    /**
+     * The key INTERFACE, used in {@link #INTERFACE_ITEM}.
+     */
+    String          INTERFACE               = "Interface";
+    
+    /**
+     * The item containing the name of the interface type that a matching service must support.
+     * The key is {@link #INTERFACE}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            INTERFACE_ITEM          = new Item(
+                                                    INTERFACE, 
+                                                    "the name of the interface type", 
+                                                    SimpleType.STRING);
+    
+    /**
+     * The key COMPONENT_NAME, used in {@link #COMPONENT_NAME_ITEM}.
+     */
+    String          COMPONENT_NAME          = "ComponentName";
+    
+    /**
+     * The item containing the value of the <code>component-name</code> attribute of the service reference.
+     * The key is {@link #INTERFACE}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            COMPONENT_NAME_ITEM     = new Item(
+                                                    COMPONENT_NAME, 
+                                                    "The value of the component-name attribute of the service reference", 
+                                                    SimpleType.STRING);
+    /**
+     * The key FILTER, used in {@link #FILTER_ITEM}.
+     */
+    String          FILTER                  = "Filter";
+    
+    /**
+     * The item containing the filter expression that a matching service must match.
+     * The key is {@link #FILTER}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            FILTER_ITEM             = new Item(
+                                                    FILTER, 
+                                                    "The filter expression that a matching service must match", 
+                                                    SimpleType.STRING);
+    
+    /**
+     * The key REFERENCE_LISTENERS, used in {@link #SERVICE_LISTENERS_ITEM}.
+     */
+    String          REFERENCE_LISTENERS     = "RegistrationListeners";
+    
+    /**
+     * The item containing all the reference listeners.
+     * The key is {@link #REFERENCE_LISTENERS}, and the type is {@link ArrayType}.
+     */
+    Item            REFERENCE_LISTENERS_ITEM= new Item(
+                                                    REFERENCE_LISTENERS,
+                                                    "All the reference listeners",
+                                                    Item.arrayType(1, REFERENCE_LISTENER_TYPE));
+    
+    /**
+     * The name of CompositeType for ServiceReferenceMetadata objects, used in {@link #SERVICE_REFERENCE_METADATA_TYPE}.
+     */
+    String          SERVICE_REFERENCE_METADATA               = "ServiceReferenceMetadata"; 
+    
+    /**
+     * The CompositeType for a ServiceReferenceMetadata object, it extends 
+     * {@link #COMPONENT_METADATA_TYPE} and adds the following items:
+     * <ul>
+     * <li>{@link #AVAILABILITY}</li>
+     * <li>{@link #INTERFACE}</li>
+     * <li>{@link #COMPONENT_NAME}</li>
+     * <li>{@link #FILTER}</li>
+     * <li>{@link #REFERENCE_LISTENERS}</li>
+     * </ul>
+     */
+    CompositeType   SERVICE_REFERENCE_METADATA_TYPE  = Item.extend(
+                                                    COMPONENT_METADATA_TYPE, 
+                                                    SERVICE_REFERENCE_METADATA, 
+                                                    "This type encapsulates ServiceReferenceMetadata objects",
+                                                    AVAILABILITY_ITEM,
+                                                    INTERFACE_ITEM,
+                                                    COMPONENT_NAME_ITEM,
+                                                    FILTER_ITEM,
+                                                    REFERENCE_LISTENERS_ITEM);
+    
+    ///////////////////////////////////////////////////////////////
+    // Define <reference>'s CompositeType
+    ///////////////////////////////////////////////////////////////
+    
+    /**
+     * The key TIME_OUT, used in {@link #TIMEOUT_ITEM}.
+     */
+    String          TIMEOUT                = "TimeOut";
+    
+    /**
+     * The item containing the timeout for service invocations when a backing service is is unavailable.
+     * The key is {@link #TIMEOUT}, and the type is {@link SimpleType#LONG}.
+     */
+    Item            TIMEOUT_ITEM           = new Item(
+                                                    TIMEOUT, 
+                                                    "The timeout for service invocations when a backing service is is unavailable", 
+                                                    SimpleType.LONG);
+    
+    /**
+     * The name of CompositeType for ReferenceMetadata objects, used in {@link #REFERENCE_METADATA_TYPE}.
+     */
+    String          REFERENCE_METADATA        = "ReferenceMetadata"; 
+    
+    /**
+     * The CompositeType for a ReferenceMetadata object, it extends 
+     * {@link #SERVICE_REFERENCE_METADATA_TYPE} and adds the following items:
+     * <ul>
+     * <li>{@link #TIMEOUT}</li>
+     * </ul>
+     */
+    CompositeType   REFERENCE_METADATA_TYPE = Item.extend(
+                                                    SERVICE_REFERENCE_METADATA_TYPE, 
+                                                    REFERENCE_METADATA, 
+                                                    "This type encapsulates ReferenceMetadata objects",
+                                                    TIMEOUT_ITEM);
+    
+    ///////////////////////////////////////////////////////////////
+    // Define <reference-list>'s CompositeType
+    ///////////////////////////////////////////////////////////////
+    
+    /**
+     * The key MEMBER_TYPE, used in {@link #MEMBER_TYPE_ITEM}.
+     */
+    String          MEMBER_TYPE             = "MemberType";
+    
+    /**
+     * The item specify whether the List will contain service object proxies or ServiceReference objects.
+     * The key is {@link #MEMBER_TYPE}, and the type is {@link SimpleType#INTEGER}.
+     */
+    Item            MEMBER_TYPE_ITEM        = new Item(
+                                                    MEMBER_TYPE, 
+                                                    "To specify whether the List will contain service object proxies or ServiceReference objects", 
+                                                    SimpleType.INTEGER);
+    
+    /**
+     * The name of CompositeType for ReferenceListMetadata objects, used in {@link #REFERENCE_LIST_METADATA_TYPE}.
+     */
+    String          REFERENCE_LIST_METADATA        = "ReferenceListMetadata"; 
+    
+    /**
+     * The CompositeType for a ReferenceListMetadata object, it extends 
+     * {@link #SERVICE_REFERENCE_METADATA_TYPE} and adds the following items:
+     * <ul>
+     * <li>{@link #MEMBER_TYPE}</li>
+     * </ul>
+     */
+    CompositeType   REFERENCE_LIST_METADATA_TYPE = Item.extend(
+                                                    SERVICE_REFERENCE_METADATA_TYPE, 
+                                                    REFERENCE_LIST_METADATA, 
+                                                    "This type encapsulates ReferenceListMetadata objects",
+                                                    MEMBER_TYPE_ITEM);
+
+
+    /**
+     * Returns the list of component id.
+     * 
+     * @param containerServiceId The blueprint container service id
+     * @return the array of component id
+     */
+    public String[] getComponentIds(long containerServiceId);
+    
+    /**
+     * Returns all component ids of the specified component type
+     * 
+     * @param containerServiceId The blueprint container service id
+     * @param type The string used to specify the type of component
+     * @return the array of component id
+     */
+    //TODO add description for type
+    public String[] getComponentIdsByType(long containerServiceId, String type);
+    
+    /**
+     * Returns the ComponentMetadata according to the its component id.
+     * The returned Composite Data's type is actually one of {@link #BEAN_METADATA_TYPE}, 
+     * {@link #SERVICE_METADATA_TYPE}, {@link #REFERENCE_METADATA_TYPE}, REFERENCE_LIST_METADATA_TYPE.
+     * 
+     * @param containerServiceId The blueprint container service id
+     * @param componentId The component id
+     * @return the ComponentMetadata
+     */
+    public CompositeData getComponentMetadata(long containerServiceId, String componentId);
+        
+    /**
+     * Returns all the blueprint containers' service IDs, which successfully
+     * created from blueprint bundles.
+     * 
+     * @return the list of all the service IDs of the blueprint containers created by current extender 
+     * @throws IOException if the operation fails
+     */
+    public long[] getBlueprintContainerServiceIds() throws IOException;
+    
+    /**
+     * Returns the blueprint container's service id if the bundle specified 
+     * by the bundle id is a blueprint bundle.
+     * 
+     * @param bundleId The bundle id of a blueprint bundle
+     * @return the blueprint container's service id, or null if the blueprint bundle initialed failed.
+     * @throws IOException if the operation fails
+     * @throws IllegalArgumentException if the bundle is not a blueprint bundle
+     */
+    public long getBlueprintContainerServiceId(long bundleId) throws IOException;
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/BlueprintStateMBean.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/BlueprintStateMBean.java
index b56de2e8..39565d1e 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/BlueprintStateMBean.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/BlueprintStateMBean.java
@@ -1,3 +1,213 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.jmx.blueprint;
+
+import java.io.IOException;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeType;
+import javax.management.openmbean.SimpleType;
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularType;
+
+/**
+ * This MBean provides the management interface to the OSGi Blueprint Service.
+ *
+ * This MBean also emits events that clients can use to get notified of the
+ * changes in the blueprint containers state in the framework.
+ * 
+ * @version $Revision$
+ */
+public interface BlueprintStateMBean {
+    /**
+     * The object name for this MBean.
+     */
+    String OBJECTNAME = JmxConstants.ARIES_BLUEPRINT+":service=blueprintState,version=1.0";
+    
+    ///////////////////////////////////////////////////////////////
+    // Define Event's CompositeType
+    ///////////////////////////////////////////////////////////////
+    
+    /**
+     * The key BUNDLE_ID, used in {@link #BUNDLE_ID_ITEM}.
+     */
+    String          BUNDLE_ID                  = "BundleId";
+    
+    /**
+     * The item containing the Blueprint bundle id associated with this event.
+     * The key is {@link #BUNDLE_ID}, and the type is {@link SimpleType#LONG}.
+     */
+    Item            BUNDLE_ID_ITEM             = new Item(
+                                                    BUNDLE_ID,
+                                                    "the Blueprint bundle id associated with this event.",
+                                                    SimpleType.LONG);
+    
+    /**
+     * The key EXTENDER_BUNDLE_ID, used in {@link #EXTENDER_BUNDLE_ID_ITEM}.
+     */
+    String          EXTENDER_BUNDLE_ID   = "ExtenderBundleId";
+    
+    /**
+     * The item containing the Blueprint extender bundle id that is generating this event.
+     * The key is {@link #EXTENDER_BUNDLE_ID}, and the type is {@link SimpleType#LONG}.
+     */
+    Item            EXTENDER_BUNDLE_ID_ITEM    = new Item(
+                                                    EXTENDER_BUNDLE_ID,
+                                                    "the Blueprint extender bundle id that is generating this event.",
+                                                    SimpleType.LONG);
+
+    /**
+     * The key REPLAY, used in {@link #REPLAY_ITEM}.
+     */ 
+    String          REPLAY               = "Replay";
+    
+    /**
+     * The item containing the flag that represents whether this event is a replay event.
+     * The key is {@link #REPLAY}, and the type is {@link SimpleType#BOOLEAN}.
+     */
+    Item            REPLAY_ITEM          = new Item(
+                                                    REPLAY,
+                                                    "the flag that represents whether this event is a replay event.",
+                                                    SimpleType.BOOLEAN);
+    
+    
+    /**
+     * The key EVENT_TYPE, used in {@link #EVENT_TYPE_ITEM}.
+     */
+    String          EVENT_TYPE                    = "EventType";
+ 
+    /**
+     * The item containing the type of this event.
+     * The key is {@link #EVENT_TYPE}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            EVENT_TYPE_ITEM              = new Item(
+                                                    EVENT_TYPE,
+                                                    "The type of the event: {CREATING=1, CREATED=2, DESTROYING=3, DESTROYED=4, FAILURE=5, GRACE_PERIOD=6, WAITING=7}",
+                                                    SimpleType.INTEGER);
+    
+    /**
+     * The key TIMESTAMP, used in {@link #TIMESTAMP_ITEM}.
+     */    
+    String          TIMESTAMP               = "Timestamp";
+    
+    /**
+     * The item containing the time at which this event was created.
+     * The key is {@link #TIMESTAMP}, and the type is {@link SimpleType#LONG}.
+     */
+    Item            TIMESTAMP_ITEM          = new Item(
+                                                    TIMESTAMP,
+                                                    "the time at which this event was created.",
+                                                    SimpleType.LONG);
+
+
+    /**
+     * The key DEPENDENCIES, used in {@link #DEPENDENCIES_ITEM}.
+     */
+    String          DEPENDENCIES            = "Dependencies";
+    
+    /**
+     * The item containing the filters identifying the missing dependencies that caused the WAITING, GRACE_PERIOD or FAILURE event.
+     * The key is {@link #DEPENDENCIES}, and the type is {@link JmxConstants#STRING_ARRAY_TYPE}.
+     */
+    Item            DEPENDENCIES_ITEM       = new Item(
+                                                    DEPENDENCIES,
+                                                    "the filters identifying the missing dependencies that caused the WAITING, GRACE_PERIOD or FAILURE event.",
+                                                    JmxConstants.STRING_ARRAY_TYPE);
+        
+    /**
+     * The key EXCEPTION_MESSAGE, used in {@link #ERROR_MESSAGE_ITEM}.
+     */    
+    String          EXCEPTION_MESSAGE       = "ExceptionMessage";
+    
+    /**
+     * The item containing the exception message that cause this FAILURE event.
+     * The key is {@link #EXCEPTION_MESSAGE}, and the type is {@link SimpleType#STRING}.
+     */
+    Item            EXCEPTION_MESSAGE_ITEM  = new Item(
+                                                    EXCEPTION_MESSAGE,
+                                                    "the exception message that cause this FAILURE event.",
+                                                    SimpleType.STRING);
+    
+    /**
+     * The CompositeType for a blueprint event. It contains the following items:
+     * <ul>
+     * <li>{@link #BUNDLE_ID}</li>
+     * <li>{@link #EXTENDER_BUNDLE_ID}</li>
+     * <li>{@link #EVENT_TYPE}</li>
+     * <li>{@link #REPLAY}</li>
+     * <li>{@link #TIMESTAMP}</li>
+     * <li>{@link #DEPENDENCIES}</li>
+     * <li>{@link #EXCEPTION_MESSAGE}</li>
+     * </ul>
+     */
+    CompositeType   OSGI_BLUEPRINT_EVENT_TYPE   = Item.compositeType(
+                                                    "OSGI_BLUEPRINT_EVENT", 
+                                                    "Blueprint event", 
+                                                    BUNDLE_ID_ITEM,
+                                                    EXTENDER_BUNDLE_ID_ITEM,
+                                                    EVENT_TYPE_ITEM,
+                                                    REPLAY_ITEM,
+                                                    TIMESTAMP_ITEM,
+                                                    DEPENDENCIES_ITEM,
+                                                    EXCEPTION_MESSAGE_ITEM);
+    
+    
+    /**
+     * The Tabular Type for A list of blueprint events. The row type is
+     * {@link #OSGI_BLUEPRINT_EVENT_TYPE}.
+     */
+    TabularType     OSGI_BLUEPRINT_EVENTS_TYPE  = Item.tabularType(
+                                                    "BUNDLES", 
+                                                    "A list of blueprint events",
+                                                    OSGI_BLUEPRINT_EVENT_TYPE, 
+                                                    new String[] { BUNDLE_ID });
+    
+    /**
+     * Returns the BlueprintEvent associated with this blueprint container.
+     * The returned Composite Data is typed by {@link #OSGI_BLUEPRINT_EVENT_TYPE}.
+     * 
+     * @param bundleId The bundle id of a blueprint bundle
+     * @return the last event associated with the blueprint bundle, see {@link #OSGI_BLUEPRINT_EVENT_TYPE} 
+     * @throws IOException if the operation fails
+     * @throws IllegalArgumentException if the bundle is not a blueprint bundle
+     */
+    public CompositeData getLastEvent(long bundleId) throws IOException;
+    
+    /**
+     * Returns all the last events associated with the blueprint bundles.
+     * 
+     * @return the tabular representation of all the last events associated with the blueprint bundles see {@link #OSGI_BLUEPRINT_EVENTS_TYPE}
+     * @throws IOException if the operation fails
+     */ 
+    public TabularData getLastEvents() throws IOException;
+    
+    /**
+     * Returns all the blueprint bundles' IDs, which are either 
+     * successfully created or not by current extender.
+     * 
+     * @return the list of all the blueprint bundles's IDs (either successfully created or not by current extender)
+     * @throws IOException if the operation fails
+     */
+    public long[] getBlueprintBundleIds() throws IOException;
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/Item.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/Item.java
index b56de2e8..4ac1c74a 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/Item.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/Item.java
@@ -1,3 +1,206 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.jmx.blueprint;
+
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+import javax.management.openmbean.ArrayType;
+import javax.management.openmbean.CompositeType;
+import javax.management.openmbean.OpenDataException;
+import javax.management.openmbean.OpenType;
+import javax.management.openmbean.SimpleType;
+import javax.management.openmbean.TabularType;
+
+/**
+ * The item class enables the definition of open types in the appropriate interfaces.
+ * 
+ * This class contains a number of methods that make it possible to create open types for {@link CompositeType},
+ * {@link TabularType}, and {@link ArrayType}. The normal creation throws a checked exception, making it impossible to
+ * use them in a static initializer. They constructors are also not very suitable for static construction.
+ * 
+ * 
+ * An Item instance describes an item in a Composite Type. It groups the triplet of name, description, and Open Type.
+ * These Item instances allows the definitions of an item to stay together.
+ * 
+ * @Immutable
+ */
+public class Item {
+
+    /**
+     * The name of this item.
+     */
+    private final String name;
+
+    /**
+     * The description of this item.
+     */
+    private final String description;
+
+    /**
+     * The type of this item.
+     */
+    private final OpenType/*<?>*/ type;
+
+    /**
+     * Create a triple of name, description, and type. This triplet is used in the creation of a Composite Type.
+     * 
+     * @param name
+     *            The name of the item.
+     * @param description
+     *            The description of the item.
+     * @param type
+     *            The Open Type of this item.
+     * @param restrictions
+     *            Ignored, contains list of restrictions
+     */
+    public Item(String name, String description, OpenType/*<?>*/ type, String... restrictions) {
+        this.name = name;
+        this.description = description;
+        this.type = type;
+    }
+
+    /**
+     * Create a Tabular Type.
+     * 
+     * @param name
+     *            The name of the Tabular Type.
+     * @param description
+     *            The description of the Tabular Type.
+     * @param rowType
+     *            The Open Type for a row
+     * @param index
+     *            The names of the items that form the index .
+     * @return A new Tabular Type composed from the parameters.
+     * @throws RuntimeException
+     *             when the Tabular Type throws an OpenDataException
+     */
+    static public TabularType tabularType(String name, String description, CompositeType rowType, String... index) {
+        try {
+            return new TabularType(name, description, rowType, index);
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Create a Composite Type
+     * 
+     * @param name
+     *            The name of the Tabular Type.
+     * @param description
+     *            The description of the Tabular Type.
+     * @param items
+     *            The items that describe the composite type.
+     * @return a new Composite Type
+     * @throws RuntimeException
+     *             when the Tabular Type throws an OpenDataException
+     */
+    static public CompositeType compositeType(String name, String description, Item... items) {
+        return extend(null, name, description, items);
+    }
+
+    /**
+     * Extend a Composite Type by adding new items. Items can override items in the parent type.
+     * 
+     * @param parent
+     *            The parent type, can be <code>null</code>
+     * @param name
+     *            The name of the type
+     * @param description
+     *            The description of the type
+     * @param items
+     *            The items that should be added/override to the parent type
+     * @return A new Composite Type that extends the parent type
+     * @throws RuntimeException
+     *             when an OpenDataException is thrown
+     */
+    public static CompositeType extend(CompositeType parent, String name, String description, Item... items) {
+        Set<Item> all = new LinkedHashSet<Item>();
+
+        if (parent != null) {
+            for (Object nm : parent.keySet()) {
+                String key = (String) nm;
+                all.add(new Item((String) nm, parent.getDescription(key), parent.getType(key)));
+            }
+        }
+
+        all.addAll(Arrays.asList(items));
+
+        String names[] = new String[all.size()];
+        String descriptions[] = new String[all.size()];
+        OpenType types[] = new OpenType[all.size()];
+
+        int n = 0;
+        for (Item item : all) {
+            names[n] = item.name;
+            descriptions[n] = item.description;
+            types[n] = item.type;
+            n++;
+        }
+
+        try {
+            return new CompositeType(name, description, names, descriptions, types);
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Return a new Array Type.
+     * 
+     * @param dim
+     *            The dimension
+     * @param elementType
+     *            The element type
+     * @return A new Array Type
+     */
+    public static ArrayType/*<?>*/ arrayType(int dim, OpenType/*<?>*/ elementType) {
+        try {
+            return new ArrayType(dim, elementType);
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+    
+    
+    /**
+     * Return a new primaArray Type.
+     * 
+     * @param elementType
+     *            The element type
+     * @return A new Array Type
+     */
+    /*
+     * For the compatibility  with java 5, we have to cancel this method temporarily.
+     * 
+     * public static ArrayType<?> primitiveArrayType(SimpleType<?> elementType) {
+        try {
+            return new ArrayType(elementType, true);
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+    */
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/JmxConstants.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/JmxConstants.java
index e69de29b..2d9a13ea 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/JmxConstants.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-api/src/main/java/org/apache/aries/jmx/blueprint/JmxConstants.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.jmx.blueprint;
+
+import javax.management.openmbean.ArrayType;
+import javax.management.openmbean.SimpleType;
+
+/**
+ * Constants.
+ * 
+ * Additionally, this class contains a number of utility types that are used in
+ * different places in the specification. These are {@link #LONG_ARRAY_TYPE},
+ * {@link #STRING_ARRAY_TYPE}, and {@link #PRIMITIVE_BYTE_ARRAY_TYPE}.
+ * 
+ * @Immutable
+ */
+public class JmxConstants {
+
+    /*
+     * Empty constructor to make sure this is not used as an object.
+     */
+    private JmxConstants() {
+        // empty
+    }
+
+
+    public static final ArrayType/*<Byte>*/    BYTE_ARRAY_TYPE   = Item
+                                                                    .arrayType(
+                                                                            1,
+                                                                            SimpleType.BYTE);
+    
+    /**
+     * The MBean Open type for an array of strings
+     */
+    public static final ArrayType/*<String>*/    STRING_ARRAY_TYPE   = Item
+                                                                    .arrayType(
+                                                                            1,
+                                                                            SimpleType.STRING);
+
+
+    /**
+     * The domain name of the Blueprint MBeans
+     */
+    public static final String          ARIES_BLUEPRINT  = "org.apache.aries.blueprint";
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPBeanArgument.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPBeanArgument.java
index b56de2e8..ade4f7c5 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPBeanArgument.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPBeanArgument.java
@@ -1,3 +1,79 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.HashMap;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.BeanArgument;
+
+public class BPBeanArgument implements TransferObject {
+    private int index;
+
+    private BPMetadata value;
+
+    private String valueType;
+
+    public BPBeanArgument(CompositeData argument) {
+        index = (Integer) argument.get(BlueprintMetadataMBean.INDEX);
+        Byte[] buf = (Byte[]) argument.get(BlueprintMetadataMBean.VALUE);
+        value = Util.boxedBinary2BPMetadata(buf);
+        valueType = (String) argument.get(BlueprintMetadataMBean.VALUE_TYPE);
+    }
+
+    public BPBeanArgument(BeanArgument argument) {
+        index = argument.getIndex();
+
+        value = Util.metadata2BPMetadata(argument.getValue());
+
+        valueType = argument.getValueType();
+    }
+
+    public CompositeData asCompositeData() {
+        HashMap<String, Object> items = new HashMap<String, Object>();
+        items.put(BlueprintMetadataMBean.INDEX, index);
+        items.put(BlueprintMetadataMBean.VALUE, Util.bpMetadata2BoxedBinary(value));
+        items.put(BlueprintMetadataMBean.VALUE_TYPE, valueType);
+
+        try {
+            return new CompositeDataSupport(BlueprintMetadataMBean.BEAN_ARGUMENT_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public int getIndex() {
+        return index;
+    }
+
+    public BPMetadata getValue() {
+        return value;
+    }
+
+    public String getValueType() {
+        return valueType;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPBeanMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPBeanMetadata.java
index b56de2e8..a83bb23e 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPBeanMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPBeanMetadata.java
@@ -1,3 +1,167 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.BeanArgument;
+import org.osgi.service.blueprint.reflect.BeanMetadata;
+import org.osgi.service.blueprint.reflect.BeanProperty;
+
+public class BPBeanMetadata extends BPComponentMetadata implements BPTarget {
+
+    private String className;
+
+    private String destroyMethod;
+
+    private String factoryMethod;
+
+    private String initMethod;
+
+    private String scope;
+
+    private BPBeanArgument[] arguments;
+
+    private BPBeanProperty[] properties;
+
+    private BPTarget factoryComponent;
+
+    public BPBeanMetadata(CompositeData bean) {
+        super(bean);
+        className = (String) bean.get(BlueprintMetadataMBean.CLASS_NAME);
+        destroyMethod = (String) bean.get(BlueprintMetadataMBean.DESTROY_METHOD);
+        factoryMethod = (String) bean.get(BlueprintMetadataMBean.FACTORY_METHOD);
+        initMethod = (String) bean.get(BlueprintMetadataMBean.INIT_METHOD);
+        scope = (String) bean.get(BlueprintMetadataMBean.SCOPE);
+
+        Byte[] buf = (Byte[]) bean.get(BlueprintMetadataMBean.FACTORY_COMPONENT);
+        factoryComponent = (BPTarget) Util.boxedBinary2BPMetadata(buf);
+
+        CompositeData[] cd_args = (CompositeData[]) bean.get(BlueprintMetadataMBean.ARGUMENTS);
+        arguments = new BPBeanArgument[cd_args.length];
+        for (int i = 0; i < arguments.length; i++) {
+            arguments[i] = new BPBeanArgument(cd_args[i]);
+        }
+
+        CompositeData[] cd_props = (CompositeData[]) bean.get(BlueprintMetadataMBean.PROPERTIES);
+        properties = new BPBeanProperty[cd_props.length];
+        for (int i = 0; i < properties.length; i++) {
+            properties[i] = new BPBeanProperty(cd_props[i]);
+        }
+
+    }
+
+    public BPBeanMetadata(BeanMetadata bean) {
+        super(bean);
+        className = bean.getClassName();
+        destroyMethod = bean.getDestroyMethod();
+        factoryMethod = bean.getFactoryMethod();
+        initMethod = bean.getInitMethod();
+        scope = bean.getScope();
+
+        factoryComponent = (BPTarget) Util.metadata2BPMetadata(bean.getFactoryComponent());
+
+        arguments = new BPBeanArgument[bean.getArguments().size()];
+        int i = 0;
+        for (Object arg : bean.getArguments()) {
+            arguments[i++] = new BPBeanArgument((BeanArgument) arg);
+        }
+
+        properties = new BPBeanProperty[bean.getProperties().size()];
+        i = 0;
+        for (Object prop : bean.getProperties()) {
+            properties[i++] = new BPBeanProperty((BeanProperty) prop);
+        }
+    }
+
+    protected Map<String, Object> getItemsMap() {
+        Map<String, Object> items = super.getItemsMap();
+
+        // add its fields to the map
+        items.put(BlueprintMetadataMBean.CLASS_NAME, className);
+        items.put(BlueprintMetadataMBean.DESTROY_METHOD, destroyMethod);
+        items.put(BlueprintMetadataMBean.FACTORY_METHOD, factoryMethod);
+        items.put(BlueprintMetadataMBean.INIT_METHOD, initMethod);
+        items.put(BlueprintMetadataMBean.SCOPE, scope);
+
+        items.put(BlueprintMetadataMBean.FACTORY_COMPONENT, Util.bpMetadata2BoxedBinary(factoryComponent));
+
+        CompositeData[] cd_args = new CompositeData[arguments.length];
+        for (int i = 0; i < arguments.length; i++) {
+            cd_args[i] = arguments[i].asCompositeData();
+        }
+        items.put(BlueprintMetadataMBean.ARGUMENTS, cd_args);
+
+        CompositeData[] cd_props = new CompositeData[properties.length];
+        for (int i = 0; i < properties.length; i++) {
+            cd_props[i] = properties[i].asCompositeData();
+        }
+        items.put(BlueprintMetadataMBean.PROPERTIES, cd_props);
+
+        return items;
+    }
+
+    public CompositeData asCompositeData() {
+        try {
+            return new CompositeDataSupport(BlueprintMetadataMBean.BEAN_METADATA_TYPE, getItemsMap());
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public BPBeanArgument[] getArguments() {
+        return arguments;
+    }
+
+    public String getClassName() {
+        return className;
+    }
+
+    public String getDestroyMethod() {
+        return destroyMethod;
+    }
+
+    public BPTarget getFactoryComponent() {
+        return factoryComponent;
+    }
+
+    public String getFactoryMethod() {
+        return factoryMethod;
+    }
+
+    public String getInitMethod() {
+        return initMethod;
+    }
+
+    public BPBeanProperty[] getProperties() {
+        return properties;
+    }
+
+    public String getScope() {
+        return scope;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPBeanProperty.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPBeanProperty.java
index b56de2e8..e18c00d7 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPBeanProperty.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPBeanProperty.java
@@ -1,3 +1,69 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.HashMap;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.BeanProperty;
+
+public class BPBeanProperty implements TransferObject {
+    private String name;
+    private BPMetadata value;
+
+    public BPBeanProperty(CompositeData property) {
+        name = (String) property.get(BlueprintMetadataMBean.NAME);
+
+        Byte[] buf = (Byte[]) property.get(BlueprintMetadataMBean.VALUE);
+        value = Util.boxedBinary2BPMetadata(buf);
+    }
+
+    public BPBeanProperty(BeanProperty property) {
+        name = property.getName();
+
+        value = Util.metadata2BPMetadata(property.getValue());
+    }
+
+    public CompositeData asCompositeData() {
+        HashMap<String, Object> items = new HashMap<String, Object>();
+        items.put(BlueprintMetadataMBean.NAME, name);
+        items.put(BlueprintMetadataMBean.VALUE, Util.bpMetadata2BoxedBinary(value));
+
+        try {
+            return new CompositeDataSupport(BlueprintMetadataMBean.BEAN_PROPERTY_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public BPMetadata getValue() {
+        return value;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPCollectionMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPCollectionMetadata.java
index 1f8bddab..73b3a364 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPCollectionMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPCollectionMetadata.java
@@ -1,3 +1,92 @@
   + native
   + text/plain
   + Revision Date
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.HashMap;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.CollectionMetadata;
+import org.osgi.service.blueprint.reflect.Metadata;
+
+public class BPCollectionMetadata implements BPNonNullMetadata {
+    private String collectionClass;
+
+    private String valueType;
+
+    private BPMetadata[] values;
+
+    public BPCollectionMetadata(CompositeData collection) {
+        collectionClass = (String) collection.get(BlueprintMetadataMBean.COLLECTION_CLASS);
+        valueType = (String) collection.get(BlueprintMetadataMBean.VALUE_TYPE);
+
+        Byte[][] arrays = (Byte[][]) collection.get(BlueprintMetadataMBean.VALUES);
+        values = new BPMetadata[arrays.length];
+        for (int i = 0; i < values.length; i++) {
+            values[i] = Util.boxedBinary2BPMetadata((Byte[]) arrays[i]);
+        }
+    }
+
+    public BPCollectionMetadata(CollectionMetadata collection) {
+        collectionClass = collection.getCollectionClass().getCanonicalName();
+        valueType = collection.getValueType();
+
+        values = new BPMetadata[collection.getValues().size()];
+        int i = 0;
+        for (Object value : collection.getValues()) {
+            values[i++] = Util.metadata2BPMetadata((Metadata) value);
+        }
+    }
+
+    public CompositeData asCompositeData() {
+        HashMap<String, Object> items = new HashMap<String, Object>();
+        items.put(BlueprintMetadataMBean.COLLECTION_CLASS, collectionClass);
+        items.put(BlueprintMetadataMBean.VALUE_TYPE, valueType);
+
+        Byte[][] arrays = new Byte[values.length][];
+        for (int i = 0; i < arrays.length; i++) {
+            arrays[i] = Util.bpMetadata2BoxedBinary(values[i]);
+        }
+        items.put(BlueprintMetadataMBean.VALUES, arrays);
+
+        try {
+            return new CompositeDataSupport(BlueprintMetadataMBean.COLLECTION_METADATA_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public String getCollectionClass() {
+        return collectionClass;
+    }
+
+    public String getValueType() {
+        return valueType;
+    }
+
+    public BPMetadata[] getValues() {
+        return values;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPComponentMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPComponentMetadata.java
index b56de2e8..fb1d1f88 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPComponentMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPComponentMetadata.java
@@ -1,3 +1,72 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.ComponentMetadata;
+
+public abstract class BPComponentMetadata implements BPNonNullMetadata {
+    private int activation;
+
+    private String[] dependsOn;
+
+    private String id;
+
+    @SuppressWarnings("boxing")
+    protected BPComponentMetadata(CompositeData component) {
+        activation = (Integer) component.get(BlueprintMetadataMBean.ACTIVATION);
+        dependsOn = (String[]) component.get(BlueprintMetadataMBean.DEPENDS_ON);
+        id = (String) component.get(BlueprintMetadataMBean.ID);
+    }
+
+    protected BPComponentMetadata(ComponentMetadata component) {
+        activation = component.getActivation();
+        dependsOn =  (String[])component.getDependsOn().toArray(new String[0]);
+        id = (String) component.getId();
+    }
+
+    protected Map<String, Object> getItemsMap() {
+        HashMap<String, Object> items = new HashMap<String, Object>();
+        items.put(BlueprintMetadataMBean.ACTIVATION, activation);
+        items.put(BlueprintMetadataMBean.DEPENDS_ON, dependsOn);
+        items.put(BlueprintMetadataMBean.ID, id);
+
+        return items;
+    }
+
+    public int getActivation() {
+        return activation;
+    }
+
+    public String[] getDependsOn() {
+        return dependsOn;
+    }
+
+    public String getId() {
+        return id;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPIdRefMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPIdRefMetadata.java
index b56de2e8..ac66a48e 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPIdRefMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPIdRefMetadata.java
@@ -1,3 +1,58 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.HashMap;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.IdRefMetadata;
+
+public class BPIdRefMetadata implements BPNonNullMetadata {
+    private String componentId;
+
+    public BPIdRefMetadata(CompositeData idRef) {
+        componentId = (String) idRef.get(BlueprintMetadataMBean.COMPONENT_ID);
+    }
+
+    public BPIdRefMetadata(IdRefMetadata idRef) {
+        componentId = idRef.getComponentId();
+    }
+
+    public CompositeData asCompositeData() {
+        HashMap<String, Object> items = new HashMap<String, Object>();
+        items.put(BlueprintMetadataMBean.COMPONENT_ID, componentId);
+
+        try {
+            return new CompositeDataSupport(BlueprintMetadataMBean.ID_REF_METADATA_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public String getComponentId() {
+        return componentId;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPMapEntry.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPMapEntry.java
index b56de2e8..3a7a7336 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPMapEntry.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPMapEntry.java
@@ -1,3 +1,70 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.HashMap;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.MapEntry;
+
+public class BPMapEntry implements TransferObject {
+    private BPNonNullMetadata key;
+
+    private BPMetadata value;
+
+    public BPMapEntry(CompositeData entry) {
+        Byte[] buf = (Byte[]) entry.get(BlueprintMetadataMBean.KEY);
+        key = (BPNonNullMetadata) Util.boxedBinary2BPMetadata(buf);
+
+        buf = (Byte[]) entry.get(BlueprintMetadataMBean.VALUE);
+        value = Util.boxedBinary2BPMetadata(buf);
+    }
+
+    public BPMapEntry(MapEntry entry) {
+        key = (BPNonNullMetadata) Util.metadata2BPMetadata(entry.getKey());
+        value = Util.metadata2BPMetadata(entry.getValue());
+    }
+
+    public CompositeData asCompositeData() {
+        HashMap<String, Object> items = new HashMap<String, Object>();
+        items.put(BlueprintMetadataMBean.KEY, Util.bpMetadata2BoxedBinary(key));
+        items.put(BlueprintMetadataMBean.VALUE, Util.bpMetadata2BoxedBinary(value));
+
+        try {
+            return new CompositeDataSupport(BlueprintMetadataMBean.MAP_ENTRY_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public BPNonNullMetadata getKey() {
+        return key;
+    }
+
+    public BPMetadata getValue() {
+        return value;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPMapMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPMapMetadata.java
index 6dc540c5..d240c2d0 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPMapMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPMapMetadata.java
@@ -1,3 +1,92 @@
   + Revision Date
   + native
   + text/plain
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.HashMap;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.MapEntry;
+import org.osgi.service.blueprint.reflect.MapMetadata;
+
+public class BPMapMetadata implements BPNonNullMetadata {
+    private String keyType;
+
+    private String valueType;
+
+    private BPMapEntry[] entries;
+
+    public BPMapMetadata(CompositeData map) {
+        keyType = (String) map.get(BlueprintMetadataMBean.KEY_TYPE);
+        valueType = (String) map.get(BlueprintMetadataMBean.VALUE_TYPE);
+
+        CompositeData[] cd_entries = (CompositeData[]) map.get(BlueprintMetadataMBean.ENTRIES);
+        entries = new BPMapEntry[cd_entries.length];
+        for (int i = 0; i < entries.length; i++) {
+            entries[i] = new BPMapEntry(cd_entries[i]);
+        }
+    }
+
+    public BPMapMetadata(MapMetadata map) {
+        keyType = map.getKeyType();
+        valueType = map.getValueType();
+
+        entries = new BPMapEntry[map.getEntries().size()];
+        int i = 0;
+        for (Object arg : map.getEntries()) {
+            entries[i++] = new BPMapEntry((MapEntry) arg);
+        }
+    }
+
+    public CompositeData asCompositeData() {
+        HashMap<String, Object> items = new HashMap<String, Object>();
+        items.put(BlueprintMetadataMBean.KEY_TYPE, keyType);
+        items.put(BlueprintMetadataMBean.VALUE_TYPE, valueType);
+
+        CompositeData[] cd_entries = new CompositeData[entries.length];
+        for (int i = 0; i < entries.length; i++) {
+            cd_entries[i] = entries[i].asCompositeData();
+        }
+        items.put(BlueprintMetadataMBean.ENTRIES, cd_entries);
+
+        try {
+            return new CompositeDataSupport(BlueprintMetadataMBean.MAP_METADATA_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public BPMapEntry[] getEntries() {
+        return entries;
+    }
+
+    public String getKeyType() {
+        return keyType;
+    }
+
+    public String getValueType() {
+        return valueType;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPMetadata.java
index b56de2e8..ee180496 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPMetadata.java
@@ -1,3 +1,26 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+public interface BPMetadata extends TransferObject{
+    // marker interface
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPNonNullMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPNonNullMetadata.java
index b56de2e8..5786a4c0 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPNonNullMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPNonNullMetadata.java
@@ -1,3 +1,26 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+public interface BPNonNullMetadata extends BPMetadata {
+    // marker interface
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPNullMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPNullMetadata.java
index b56de2e8..ad9d03e9 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPNullMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPNullMetadata.java
@@ -1,3 +1,50 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.NullMetadata;
+
+public class BPNullMetadata implements BPMetadata {
+    public BPNullMetadata(CompositeData Null) {
+        //do nothing ?
+    }
+
+    public BPNullMetadata(NullMetadata Null) {
+        //do nothing ?
+    }
+
+    public CompositeData asCompositeData() {
+        try {
+			return new CompositeDataSupport(
+					BlueprintMetadataMBean.NULL_METADATA_TYPE,
+					new String[]{BlueprintMetadataMBean.PLACEHOLDER},
+					new Object[]{null});
+		} catch (OpenDataException e) {
+			throw new RuntimeException(e);
+		}
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPPropsMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPPropsMetadata.java
index b56de2e8..2c5b694e 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPPropsMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPPropsMetadata.java
@@ -1,3 +1,71 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.HashMap;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.MapEntry;
+import org.osgi.service.blueprint.reflect.PropsMetadata;
+
+public class BPPropsMetadata implements BPNonNullMetadata {
+    BPMapEntry[] entries;
+
+    public BPPropsMetadata(CompositeData props) {
+        CompositeData[] cd_entries = (CompositeData[]) props.get(BlueprintMetadataMBean.ENTRIES);
+        entries = new BPMapEntry[cd_entries.length];
+        for (int i = 0; i < entries.length; i++) {
+            entries[i] = new BPMapEntry(cd_entries[i]);
+        }
+    }
+
+    public BPPropsMetadata(PropsMetadata props) {
+        entries = new BPMapEntry[props.getEntries().size()];
+        int i = 0;
+        for (Object arg : props.getEntries()) {
+            entries[i++] = new BPMapEntry((MapEntry) arg);
+        }
+    }
+
+    public CompositeData asCompositeData() {
+        CompositeData[] cd_entries = new CompositeData[entries.length];
+        for (int i = 0; i < entries.length; i++) {
+            cd_entries[i] = entries[i].asCompositeData();
+        }
+        HashMap<String, Object> items = new HashMap<String, Object>();
+        items.put(BlueprintMetadataMBean.ENTRIES, cd_entries);
+
+        try {
+            return new CompositeDataSupport(BlueprintMetadataMBean.PROPS_METADATA_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public BPMapEntry[] getEntries() {
+        return entries;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPRefMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPRefMetadata.java
index b56de2e8..3ca66fc8 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPRefMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPRefMetadata.java
@@ -1,3 +1,58 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.HashMap;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.RefMetadata;
+
+public class BPRefMetadata implements BPNonNullMetadata, BPTarget {
+    private String componentId;
+
+    public BPRefMetadata(CompositeData ref) {
+        componentId = (String) ref.get(BlueprintMetadataMBean.COMPONENT_ID);
+    }
+
+    public BPRefMetadata(RefMetadata ref) {
+        componentId = ref.getComponentId();
+    }
+
+    public CompositeData asCompositeData() {
+        HashMap<String, Object> items = new HashMap<String, Object>();
+        items.put(BlueprintMetadataMBean.COMPONENT_ID, componentId);
+
+        try {
+            return new CompositeDataSupport(BlueprintMetadataMBean.REF_METADATA_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public String getComponentId() {
+        return componentId;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPReferenceListMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPReferenceListMetadata.java
index b56de2e8..8a267b65 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPReferenceListMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPReferenceListMetadata.java
@@ -1,3 +1,64 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
+
+public class BPReferenceListMetadata extends BPServiceReferenceMetadata {
+    private int memberType;
+
+    public BPReferenceListMetadata(CompositeData ref_list) {
+        super(ref_list);
+        memberType = (Integer) ref_list.get(BlueprintMetadataMBean.MEMBER_TYPE);
+    }
+
+    public BPReferenceListMetadata(ReferenceListMetadata ref_list) {
+        super(ref_list);
+        memberType = ref_list.getMemberType();
+    }
+
+    protected Map<String, Object> getItemsMap() {
+        Map<String, Object> items = super.getItemsMap();
+        items.put(BlueprintMetadataMBean.MEMBER_TYPE, memberType);
+
+        return items;
+    }
+
+    public CompositeData asCompositeData() {
+        try {
+            return new CompositeDataSupport(BlueprintMetadataMBean.REFERENCE_LIST_METADATA_TYPE, getItemsMap());
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public int getMemberType() {
+        return memberType;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPReferenceListener.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPReferenceListener.java
index 1f8bddab..8ce80a0a 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPReferenceListener.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPReferenceListener.java
@@ -1,3 +1,80 @@
   + native
   + text/plain
   + Revision Date
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.HashMap;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.ReferenceListener;
+
+public class BPReferenceListener implements TransferObject {
+    private String bindMethod;
+
+    private String unbindMethod;
+
+    private BPTarget listenerComponent;
+
+    public BPReferenceListener(CompositeData listener) {
+        bindMethod = (String) listener.get(BlueprintMetadataMBean.BIND_METHOD);
+        unbindMethod = (String) listener.get(BlueprintMetadataMBean.UNBIND_METHOD);
+
+        Byte[] buf = (Byte[]) listener.get(BlueprintMetadataMBean.LISTENER_COMPONENT);
+        listenerComponent = (BPTarget) Util.boxedBinary2BPMetadata(buf);
+    }
+
+    public BPReferenceListener(ReferenceListener listener) {
+        bindMethod = listener.getBindMethod();
+        unbindMethod = listener.getUnbindMethod();
+
+        listenerComponent = (BPTarget) Util.metadata2BPMetadata(listener.getListenerComponent());
+    }
+
+    public CompositeData asCompositeData() {
+        HashMap<String, Object> items = new HashMap<String, Object>();
+        items.put(BlueprintMetadataMBean.BIND_METHOD, bindMethod);
+        items.put(BlueprintMetadataMBean.UNBIND_METHOD, unbindMethod);
+
+        items.put(BlueprintMetadataMBean.LISTENER_COMPONENT, Util.bpMetadata2BoxedBinary(listenerComponent));
+
+        try {
+            return new CompositeDataSupport(BlueprintMetadataMBean.REFERENCE_LISTENER_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public String getBindMethod() {
+        return bindMethod;
+    }
+
+    public BPTarget getListenerComponent() {
+        return listenerComponent;
+    }
+
+    public String getUnbindMethod() {
+        return unbindMethod;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPReferenceMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPReferenceMetadata.java
index b56de2e8..7ecd75b8 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPReferenceMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPReferenceMetadata.java
@@ -1,3 +1,65 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.ReferenceMetadata;
+
+public class BPReferenceMetadata extends BPServiceReferenceMetadata implements BPTarget {
+
+    private long timeout;
+
+    public BPReferenceMetadata(CompositeData reference) {
+        super(reference);
+        timeout = (Long) reference.get(BlueprintMetadataMBean.TIMEOUT);
+    }
+
+    public BPReferenceMetadata(ReferenceMetadata reference) {
+        super(reference);
+        timeout = reference.getTimeout();
+    }
+
+    protected Map<String, Object> getItemsMap() {
+        Map<String, Object> items = super.getItemsMap();
+        items.put(BlueprintMetadataMBean.TIMEOUT, timeout);
+
+        return items;
+    }
+
+    public CompositeData asCompositeData() {
+        try {
+            return new CompositeDataSupport(BlueprintMetadataMBean.REFERENCE_METADATA_TYPE, getItemsMap());
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public long getTimeout() {
+        return timeout;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPRegistrationListener.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPRegistrationListener.java
index 1f8bddab..dd58c584 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPRegistrationListener.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPRegistrationListener.java
@@ -1,3 +1,80 @@
   + native
   + text/plain
   + Revision Date
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.HashMap;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.RegistrationListener;
+
+public class BPRegistrationListener implements TransferObject {
+    private BPTarget listenerComponent;
+
+    private String registrationMethod;
+
+    private String unregistrationMethod;
+
+    public BPRegistrationListener(CompositeData listener) {
+        registrationMethod = (String) listener.get(BlueprintMetadataMBean.REGISTRATION_METHOD);
+        unregistrationMethod = (String) listener.get(BlueprintMetadataMBean.UNREGISTRATION_METHOD);
+
+        Byte[] buf = (Byte[]) listener.get(BlueprintMetadataMBean.LISTENER_COMPONENT);
+        listenerComponent = (BPTarget) Util.boxedBinary2BPMetadata(buf);
+    }
+
+    public BPRegistrationListener(RegistrationListener listener) {
+        registrationMethod = listener.getRegistrationMethod();
+        unregistrationMethod = listener.getUnregistrationMethod();
+
+        listenerComponent = (BPTarget) Util.metadata2BPMetadata(listener.getListenerComponent());
+    }
+
+    public CompositeData asCompositeData() {
+        HashMap<String, Object> items = new HashMap<String, Object>();
+        items.put(BlueprintMetadataMBean.REGISTRATION_METHOD, registrationMethod);
+        items.put(BlueprintMetadataMBean.UNREGISTRATION_METHOD, unregistrationMethod);
+
+        items.put(BlueprintMetadataMBean.LISTENER_COMPONENT, Util.bpMetadata2BoxedBinary(listenerComponent));
+
+        try {
+            return new CompositeDataSupport(BlueprintMetadataMBean.REGISTRATION_LISTENER_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public BPTarget getListenerComponent() {
+        return listenerComponent;
+    }
+
+    public String getRegistrationMethod() {
+        return registrationMethod;
+    }
+
+    public String getUnregistrationMethod() {
+        return unregistrationMethod;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPServiceMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPServiceMetadata.java
index b56de2e8..f0055daf 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPServiceMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPServiceMetadata.java
@@ -1,3 +1,146 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.MapEntry;
+import org.osgi.service.blueprint.reflect.RegistrationListener;
+import org.osgi.service.blueprint.reflect.ServiceMetadata;
+
+public class BPServiceMetadata extends BPComponentMetadata {
+
+    private int autoExport;
+
+    private String[] interfaces;
+
+    private int ranking;
+
+    private BPRegistrationListener[] listeners;
+
+    private BPMapEntry[] properties;
+
+    private BPTarget serviceComponent;
+
+    public BPServiceMetadata(CompositeData service) {
+        super(service);
+        autoExport = (Integer) service.get(BlueprintMetadataMBean.AUTO_EXPORT);
+        interfaces = (String[]) service.get(BlueprintMetadataMBean.INTERFACES);
+        ranking = (Integer) service.get(BlueprintMetadataMBean.RANKING);
+
+        CompositeData[] cd_listeners = (CompositeData[]) service.get(BlueprintMetadataMBean.REGISTRATION_LISTENERS);
+        listeners = new BPRegistrationListener[cd_listeners.length];
+        for (int i = 0; i < listeners.length; i++) {
+            listeners[i] = new BPRegistrationListener(cd_listeners[i]);
+        }
+
+        CompositeData[] cd_props = (CompositeData[]) service.get(BlueprintMetadataMBean.SERVICE_PROPERTIES);
+        properties = new BPMapEntry[cd_props.length];
+        for (int i = 0; i < properties.length; i++) {
+            properties[i] = new BPMapEntry(cd_props[i]);
+        }
+
+        Byte[] buf = (Byte[]) service.get(BlueprintMetadataMBean.SERVICE_COMPONENT);
+        serviceComponent = (BPTarget) Util.boxedBinary2BPMetadata(buf);
+    }
+
+    public BPServiceMetadata(ServiceMetadata service) {
+        super(service);
+        autoExport = service.getAutoExport();
+        interfaces = (String[])service.getInterfaces().toArray(new String[0]);
+        ranking = service.getRanking();
+
+        listeners = new BPRegistrationListener[service.getRegistrationListeners().size()];
+        int i = 0;
+        for (Object listener : service.getRegistrationListeners()) {
+            listeners[i++] = new BPRegistrationListener((RegistrationListener) listener);
+        }
+
+        properties = new BPMapEntry[service.getServiceProperties().size()];
+        i = 0;
+        for (Object prop : service.getServiceProperties()) {
+            properties[i++] = new BPMapEntry((MapEntry) prop);
+        }
+
+        serviceComponent = (BPTarget) Util.metadata2BPMetadata(service.getServiceComponent());
+    }
+
+    protected Map<String, Object> getItemsMap() {
+        Map<String, Object> items = super.getItemsMap();
+        items.put(BlueprintMetadataMBean.AUTO_EXPORT, autoExport);
+        items.put(BlueprintMetadataMBean.INTERFACES, interfaces);
+        items.put(BlueprintMetadataMBean.RANKING, ranking);
+
+        CompositeData[] cd_listeners = new CompositeData[listeners.length];
+        for (int i = 0; i < listeners.length; i++) {
+            cd_listeners[i] = listeners[i].asCompositeData();
+        }
+        items.put(BlueprintMetadataMBean.REGISTRATION_LISTENERS, cd_listeners);
+
+        CompositeData[] cd_props = new CompositeData[properties.length];
+        for (int i = 0; i < properties.length; i++) {
+            cd_props[i] = properties[i].asCompositeData();
+        }
+        items.put(BlueprintMetadataMBean.SERVICE_PROPERTIES, cd_props);
+
+        items.put(BlueprintMetadataMBean.SERVICE_COMPONENT, Util.bpMetadata2BoxedBinary(serviceComponent));
+
+        return items;
+    }
+
+    public CompositeData asCompositeData() {
+        try {
+            return new CompositeDataSupport(BlueprintMetadataMBean.SERVICE_METADATA_TYPE, getItemsMap());
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public int getAutoExport() {
+        return autoExport;
+    }
+
+    public String[] getInterfaces() {
+        return interfaces;
+    }
+
+    public int getRanking() {
+        return ranking;
+    }
+
+    public BPRegistrationListener[] getRegistrationListeners() {
+        return listeners;
+    }
+
+    public BPTarget getServiceComponent() {
+        return serviceComponent;
+    }
+
+    public BPMapEntry[] getServiceProperties() {
+        return properties;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPServiceReferenceMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPServiceReferenceMetadata.java
index b56de2e8..4b0dc481 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPServiceReferenceMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPServiceReferenceMetadata.java
@@ -1,3 +1,109 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.ReferenceListener;
+import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
+
+public abstract class BPServiceReferenceMetadata extends BPComponentMetadata {
+
+    private int availability;
+
+    private String componentName;
+
+    private String filter;
+
+    private String $interface;
+
+    private BPReferenceListener[] listeners;
+
+    protected BPServiceReferenceMetadata(CompositeData reference) {
+        super(reference);
+        availability = (Integer) reference.get(BlueprintMetadataMBean.AVAILABILITY);
+        componentName = (String) reference.get(BlueprintMetadataMBean.COMPONENT_NAME);
+        filter = (String) reference.get(BlueprintMetadataMBean.FILTER);
+        $interface = (String) reference.get(BlueprintMetadataMBean.INTERFACE);
+
+        CompositeData[] cd_listeners = (CompositeData[]) reference.get(BlueprintMetadataMBean.REFERENCE_LISTENERS);
+        listeners = new BPReferenceListener[cd_listeners.length];
+        for (int i = 0; i < listeners.length; i++) {
+            listeners[i] = new BPReferenceListener(cd_listeners[i]);
+        }
+    }
+
+    protected BPServiceReferenceMetadata(ServiceReferenceMetadata reference) {
+        super(reference);
+        availability = reference.getAvailability();
+        componentName = reference.getComponentName();
+        filter = reference.getFilter();
+        $interface = reference.getInterface();
+
+        listeners = new BPReferenceListener[reference.getReferenceListeners().size()];
+        int i = 0;
+        for (Object listener : reference.getReferenceListeners()) {
+            listeners[i++] = new BPReferenceListener((ReferenceListener) listener);
+        }
+    }
+
+    protected Map<String, Object> getItemsMap() {
+        Map<String, Object> items = super.getItemsMap();
+
+        // itself
+        items.put(BlueprintMetadataMBean.AVAILABILITY, availability);
+        items.put(BlueprintMetadataMBean.COMPONENT_NAME, componentName);
+        items.put(BlueprintMetadataMBean.FILTER, filter);
+        items.put(BlueprintMetadataMBean.INTERFACE, $interface);
+
+        CompositeData[] cd_listeners = new CompositeData[listeners.length];
+        for (int i = 0; i < listeners.length; i++) {
+            cd_listeners[i] = listeners[i].asCompositeData();
+        }
+        items.put(BlueprintMetadataMBean.REFERENCE_LISTENERS, cd_listeners);
+
+        return items;
+    }
+
+    public int getAvailability() {
+        return availability;
+    }
+
+    public String getComponentName() {
+        return componentName;
+    }
+
+    public String getFilter() {
+        return filter;
+    }
+
+    public String getInterface() {
+        return $interface;
+    }
+
+    public BPReferenceListener[] getReferenceListeners() {
+        return listeners;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPTarget.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPTarget.java
index e69de29b..ac7ef312 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPTarget.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPTarget.java
@@ -0,0 +1,23 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+public interface BPTarget extends BPNonNullMetadata{
+	// marker interface
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPValueMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPValueMetadata.java
index b56de2e8..d5c3e4ad 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPValueMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/BPValueMetadata.java
@@ -1,3 +1,67 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.HashMap;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.ValueMetadata;
+
+public class BPValueMetadata implements BPNonNullMetadata {
+    private String stringValue;
+
+    private String type;
+
+    public BPValueMetadata(CompositeData value) {
+        stringValue = (String) value.get(BlueprintMetadataMBean.STRING_VALUE);
+        type = (String) value.get(BlueprintMetadataMBean.TYPE);
+    }
+
+    public BPValueMetadata(ValueMetadata value) {
+        stringValue = value.getStringValue();
+        type = value.getType();
+    }
+
+    public CompositeData asCompositeData() {
+        HashMap<String, Object> items = new HashMap<String, Object>();
+        items.put(BlueprintMetadataMBean.STRING_VALUE, stringValue);
+        items.put(BlueprintMetadataMBean.TYPE, type);
+
+        try {
+            return new CompositeDataSupport(BlueprintMetadataMBean.VALUE_METADATA_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public String getStringValue() {
+        return stringValue;
+    }
+
+    public String getType() {
+        return type;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/OSGiBlueprintEvent.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/OSGiBlueprintEvent.java
index b56de2e8..c4d06919 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/OSGiBlueprintEvent.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/OSGiBlueprintEvent.java
@@ -1,3 +1,198 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.apache.aries.jmx.blueprint.BlueprintStateMBean;
+import org.osgi.service.blueprint.container.BlueprintEvent;
+
+/**
+ * <p>
+ * This class represents the CODEC for the composite data representing a OSGi
+ * <link>BlueprintEvent</link>
+ * <p>
+ * It serves as both the documentation of the type structure and as the
+ * codification of the mechanism to convert to/from the CompositeData.
+ * <p>
+ * The structure of the composite data is:
+ * <table border="1">
+ * <tr>
+ * <td>bundleId</td>
+ * <td>long</td>
+ * </tr>
+ * <tr>
+ * <td>extenderBundleId</td>
+ * <td>long</td>
+ * </tr>
+ * <tr>
+ * <td>eventType</td>
+ * <td>int</td>
+ * </tr>
+ * <tr>
+ * <td>replay</td>
+ * <td>boolean</td>
+ * </tr>
+ * <tr>
+ * <td>timestamp</td>
+ * <td>long</td>
+ * </tr>
+ * <tr>
+ * <td>dependencies</td>
+ * <td>String[]</td>
+ * </tr>
+ * <tr>
+ * <td>exceptionMessage</td>
+ * <td>String</td>
+ * </tr>
+ * </table>
+ */
+
+public class OSGiBlueprintEvent implements TransferObject{
+
+    private long bundleId;
+
+    private long extenderBundleId;
+
+    private int eventType;
+
+    private boolean replay;
+
+    private long timestamp;
+
+    private String[] dependencies;
+
+    private String exceptionMessage;
+
+
+    /**
+     * Construct an OSGiBlueprintEvent from the supplied <link>BlueprintEvent</link>
+     *
+     * @param event
+     *            - the event to represent
+     */
+    public OSGiBlueprintEvent(BlueprintEvent event) {
+        this(event.getBundle().getBundleId(),
+                event.getExtenderBundle().getBundleId(),
+                event.getType(),
+                event.isReplay(),
+                event.getTimestamp(),
+                event.getDependencies(),
+                (event.getCause() == null) ? null : event.getCause().getMessage());
+    }
+
+    /**
+     * Construct an OSGiBlueprintEvent from the CompositeData representing the
+     * event
+     *
+     * @param data
+     *            - the CompositeData representing the event.
+     */
+    @SuppressWarnings("boxing")
+    public OSGiBlueprintEvent(CompositeData data) {
+        this((Long) data.get(BlueprintStateMBean.BUNDLE_ID),
+                (Long) data.get(BlueprintStateMBean.EXTENDER_BUNDLE_ID),
+                (Integer) data.get(BlueprintStateMBean.EVENT_TYPE),
+                (Boolean) data.get(BlueprintStateMBean.REPLAY),
+                (Long) data.get(BlueprintStateMBean.TIMESTAMP),
+                (String[]) data.get(BlueprintStateMBean.DEPENDENCIES),
+                (String) data.get(BlueprintStateMBean.EXCEPTION_MESSAGE));
+    }
+
+    /**
+     * Construct the OSGiBlueprintEvent
+     *
+     * @param bundleId
+     * @param extenderBundleId
+     * @param eventType
+     * @param replay
+     * @param timestamp
+     * @param dependencies
+     * @param exceptionMessage
+     */
+    public OSGiBlueprintEvent(long bundleId, long extenderBundleId, int eventType, boolean replay, long timestamp, String[] dependencies, String exceptionMessage){
+        this.bundleId = bundleId;
+        this.extenderBundleId = extenderBundleId;
+        this.eventType = eventType;
+        this.replay = replay;
+        this.timestamp = timestamp;
+        this.dependencies = dependencies;
+        this.exceptionMessage = exceptionMessage;
+    }
+
+    /**
+     * Answer the receiver encoded as CompositeData
+     *
+     * @return the CompositeData encoding of the receiver.
+     */
+    @SuppressWarnings("boxing")
+    public CompositeData asCompositeData() {
+        Map<String, Object> items = new HashMap<String, Object>();
+        items.put(BlueprintStateMBean.BUNDLE_ID, bundleId);
+        items.put(BlueprintStateMBean.EXTENDER_BUNDLE_ID, extenderBundleId);
+        items.put(BlueprintStateMBean.EVENT_TYPE, eventType);
+        items.put(BlueprintStateMBean.REPLAY, replay);
+        items.put(BlueprintStateMBean.TIMESTAMP, timestamp);
+        items.put(BlueprintStateMBean.DEPENDENCIES, dependencies);
+        items.put(BlueprintStateMBean.EXCEPTION_MESSAGE, exceptionMessage);
+        try {
+            return new CompositeDataSupport(BlueprintStateMBean.OSGI_BLUEPRINT_EVENT_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new IllegalStateException("Cannot form blueprint event open data", e);
+        }
+    }
+
+    public long getBundleId() {
+        return bundleId;
+    }
+
+    public long getExtenderBundleId() {
+        return extenderBundleId;
+    }
+
+    public int getEventType() {
+        return eventType;
+    }
+
+    public boolean isReplay() {
+        return replay;
+    }
+
+    public long getTimestamp() {
+        return timestamp;
+    }
+
+    public String[] getDependencies() {
+        return dependencies;
+    }
+
+    public String getExceptionMessage() {
+        return exceptionMessage;
+    }
+
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/TransferObject.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/TransferObject.java
index b56de2e8..3b777bb6 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/TransferObject.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/TransferObject.java
@@ -1,3 +1,28 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import javax.management.openmbean.CompositeData;
+
+public interface TransferObject {
+	CompositeData asCompositeData();
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/Util.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/Util.java
index 1f8bddab..a89b80f2 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/Util.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/codec/Util.java
@@ -1,3 +1,189 @@
   + native
   + text/plain
   + Revision Date
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.codec;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+
+import javax.management.openmbean.CompositeData;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.osgi.service.blueprint.reflect.BeanMetadata;
+import org.osgi.service.blueprint.reflect.CollectionMetadata;
+import org.osgi.service.blueprint.reflect.IdRefMetadata;
+import org.osgi.service.blueprint.reflect.MapMetadata;
+import org.osgi.service.blueprint.reflect.Metadata;
+import org.osgi.service.blueprint.reflect.NullMetadata;
+import org.osgi.service.blueprint.reflect.PropsMetadata;
+import org.osgi.service.blueprint.reflect.RefMetadata;
+import org.osgi.service.blueprint.reflect.ReferenceListMetadata;
+import org.osgi.service.blueprint.reflect.ReferenceMetadata;
+import org.osgi.service.blueprint.reflect.ServiceMetadata;
+import org.osgi.service.blueprint.reflect.ValueMetadata;
+
+public class Util {
+
+    public static BPMetadata metadata2BPMetadata(Metadata metadata) {
+        if(null == metadata)
+            return null;
+        // target first
+        if (metadata instanceof BeanMetadata)
+            return new BPBeanMetadata((BeanMetadata) metadata);
+
+        if (metadata instanceof ReferenceMetadata)
+            return new BPReferenceMetadata((ReferenceMetadata) metadata);
+
+        if (metadata instanceof RefMetadata)
+            return new BPRefMetadata((RefMetadata) metadata);
+
+        // others
+        if (metadata instanceof CollectionMetadata)
+            return new BPCollectionMetadata((CollectionMetadata) metadata);
+
+        if (metadata instanceof ServiceMetadata)
+            return new BPServiceMetadata((ServiceMetadata) metadata);
+
+        if (metadata instanceof ReferenceListMetadata)
+            return new BPReferenceListMetadata((ReferenceListMetadata) metadata);
+
+        if (metadata instanceof IdRefMetadata)
+            return new BPIdRefMetadata((IdRefMetadata) metadata);
+
+        if (metadata instanceof MapMetadata)
+            return new BPMapMetadata((MapMetadata) metadata);
+
+        if (metadata instanceof PropsMetadata)
+            return new BPPropsMetadata((PropsMetadata) metadata);
+
+        if (metadata instanceof ValueMetadata)
+            return new BPValueMetadata((ValueMetadata) metadata);
+
+        // null last
+        if (metadata instanceof NullMetadata)
+            return new BPNullMetadata((NullMetadata) metadata);
+
+        throw new RuntimeException("Unknown metadata type");
+    }
+
+    public static BPMetadata binary2BPMetadata(byte[] buf) {
+        if(null == buf)
+            return null;
+
+        ByteArrayInputStream inBytes = new ByteArrayInputStream(buf);
+        ObjectInputStream inObject;
+        CompositeData metadata;
+        try {
+            inObject = new ObjectInputStream(inBytes);
+            metadata = (CompositeData) inObject.readObject();
+            inObject.close();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        } catch (ClassNotFoundException e) {
+            e.printStackTrace();
+            return null;
+        }
+
+        String typename = metadata.getCompositeType().getTypeName();
+
+        // target first
+        if (typename.equals(BlueprintMetadataMBean.BEAN_METADATA))
+            return new BPBeanMetadata(metadata);
+
+        if (typename.equals(BlueprintMetadataMBean.REFERENCE_METADATA))
+            return new BPReferenceMetadata(metadata);
+
+        if (typename.equals(BlueprintMetadataMBean.REF_METADATA))
+            return new BPRefMetadata(metadata);
+
+        // others
+        if (typename.equals(BlueprintMetadataMBean.COLLECTION_METADATA))
+            return new BPCollectionMetadata(metadata);
+
+        if (typename.equals(BlueprintMetadataMBean.SERVICE_METADATA))
+            return new BPServiceMetadata(metadata);
+
+        if (typename.equals(BlueprintMetadataMBean.REFERENCE_LIST_METADATA))
+            return new BPReferenceListMetadata(metadata);
+
+        if (typename.equals(BlueprintMetadataMBean.ID_REF_METADATA))
+            return new BPIdRefMetadata(metadata);
+
+        if (typename.equals(BlueprintMetadataMBean.MAP_METADATA))
+            return new BPMapMetadata(metadata);
+
+        if (typename.equals(BlueprintMetadataMBean.PROPS_METADATA))
+            return new BPPropsMetadata(metadata);
+
+        if (typename.equals(BlueprintMetadataMBean.VALUE_METADATA))
+            return new BPValueMetadata(metadata);
+
+        // null last
+        if (metadata instanceof NullMetadata)
+            return new BPNullMetadata(metadata);
+
+        throw new RuntimeException("Unknown metadata type");
+    }
+
+    public static byte[] bpMetadata2Binary(BPMetadata metadata) {
+        if(null == metadata)
+            return null;
+
+        ByteArrayOutputStream outBytes = new ByteArrayOutputStream();
+        ObjectOutputStream outObject;
+        try {
+            outObject = new ObjectOutputStream(outBytes);
+            outObject.writeObject(metadata.asCompositeData());
+            outObject.close();
+        } catch (IOException e) {// there is no io op
+            throw new RuntimeException(e);
+        }
+
+        return outBytes.toByteArray();
+    }
+    public static Byte[] bpMetadata2BoxedBinary(BPMetadata metadata)
+    {
+        if(null == metadata)
+            return null;
+
+        byte [] src = bpMetadata2Binary(metadata);
+        Byte [] res = new Byte[src.length];
+        for(int i=0;i<src.length;i++)
+        {
+            res[i] = src[i];
+        }
+        return res;
+    }
+    public static BPMetadata boxedBinary2BPMetadata(Byte[] buf) {
+        if(null == buf)
+            return null;
+
+        byte [] unbox = new byte[buf.length];
+        for(int i=0;i<buf.length;i++)
+        {
+            unbox[i] = buf[i];
+        }
+        return binary2BPMetadata(unbox);
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/Activator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/Activator.java
index b56de2e8..8a73018c 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/Activator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/Activator.java
@@ -1,3 +1,213 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.impl;
+
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import javax.management.InstanceAlreadyExistsException;
+import javax.management.InstanceNotFoundException;
+import javax.management.MBeanRegistrationException;
+import javax.management.MBeanServer;
+import javax.management.NotCompliantMBeanException;
+import javax.management.ObjectName;
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.apache.aries.jmx.blueprint.BlueprintStateMBean;
+import org.osgi.framework.BundleActivator;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceReference;
+import org.osgi.util.tracker.ServiceTracker;
+import org.osgi.util.tracker.ServiceTrackerCustomizer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class Activator implements BundleActivator {
+
+    private static final Logger LOGGER = LoggerFactory.getLogger("org.apache.aries.jmx.blueprint");
+
+    protected BundleContext bundleContext;
+
+    protected StandardMBean blueprintState;
+    protected ObjectName blueprintStateName;
+
+    protected StandardMBean blueprintMetadata;
+    protected ObjectName blueprintMetadataName;
+
+    protected List<MBeanServer> mbeanServers = new CopyOnWriteArrayList<MBeanServer>();
+    protected ServiceTracker mbeanServiceTracker;
+
+    protected AtomicBoolean servicesRegistered = new AtomicBoolean(false);
+
+    public void start(BundleContext context) throws Exception {
+        this.bundleContext = context;
+        this.blueprintStateName = new ObjectName(BlueprintStateMBean.OBJECTNAME);
+        this.blueprintMetadataName = new ObjectName(BlueprintMetadataMBean.OBJECTNAME);
+
+        // create MBeanServerServiceTracker
+        // if there has been already a MBeanServer Service in place, this MBeanServerServiceTracker won't miss it
+        mbeanServiceTracker = new ServiceTracker(bundleContext, MBeanServer.class.getCanonicalName(),
+                new MBeanServerServiceTracker());
+        LOGGER.debug("Awaiting MBeanServer service registration");
+        mbeanServiceTracker.open();
+    }
+
+    public void stop(BundleContext context) throws Exception {
+        for (MBeanServer mbeanServer : mbeanServers) {
+            this.deregisterMBeans(mbeanServer);
+        }
+        mbeanServiceTracker.close();
+        mbeanServers.clear();
+    }
+
+    class MBeanServerServiceTracker implements ServiceTrackerCustomizer {
+
+        public Object addingService(ServiceReference servicereference) {
+            try {
+                LOGGER.debug("Adding MBeanServer: {}", servicereference);
+                final MBeanServer mbeanServer = (MBeanServer) bundleContext.getService(servicereference);
+                Activator.this.mbeanServers.add(mbeanServer);
+                Activator.this.processRegister(mbeanServer);
+                return mbeanServer;
+            } catch (RuntimeException e) {
+                LOGGER.error("uncaught exception in addingService", e);
+                throw e;
+            }
+        }
+
+        public void removedService(ServiceReference servicereference, Object obj) {
+            try {
+                LOGGER.debug("Removing MBeanServer: {}", servicereference);
+                final MBeanServer mbeanServer = (MBeanServer) bundleContext.getService(servicereference);
+                Activator.this.mbeanServers.remove(mbeanServer);
+                Activator.this.processDeregister(mbeanServer);
+            } catch (Throwable e) {
+                LOGGER.debug("uncaught exception in removedService", e);
+            }
+        }
+
+        public void modifiedService(ServiceReference servicereference, Object obj) {
+            // no op
+        }
+
+    }
+
+    private void processRegister(final MBeanServer mbeanServer) {
+        Runnable registration = new Runnable() {
+            public void run() {
+                Activator.this.registerMBeans(mbeanServer);
+            }
+        };
+        Thread registrationThread = new Thread(registration, "Blueprint MBeans Registration");
+        registrationThread.setDaemon(true);
+        registrationThread.start();
+
+    }
+
+    private void processDeregister(final MBeanServer mbeanServer) {
+        Runnable deregister = new Runnable() {
+            public void run() {
+                Activator.this.deregisterMBeans(mbeanServer);
+            }
+        };
+
+        Thread deregisterThread = new Thread(deregister, "Blueprint MBeans Deregistration");
+        deregisterThread.setDaemon(true);
+        deregisterThread.start();
+    }
+
+    protected synchronized void registerMBeans(MBeanServer mbeanServer) {
+        // create BlueprintStateMBean
+        /* the StardardMBean does not implement the MBeanRegistration in jdk1.5 */
+        try {
+            blueprintState = new RegistrableStandardEmitterMBean(new BlueprintState(bundleContext), BlueprintStateMBean.class);
+        } catch (NotCompliantMBeanException e) {
+            LOGGER.error("Unable to create StandardMBean for BlueprintState", e);
+            return;
+        }
+
+        // register BlueprintStateMBean to MBean server
+        LOGGER.debug("Registering bundle state monitor with MBeanServer: {} with name: {}",
+                        mbeanServer, blueprintStateName);
+        try {
+            mbeanServer.registerMBean(blueprintState, blueprintStateName);
+        } catch (InstanceAlreadyExistsException e) {
+            LOGGER.debug("Cannot register BlueprintStateMBean");
+        } catch (MBeanRegistrationException e) {
+            LOGGER.error("Cannot register BlueprintStateMBean", e);
+        } catch (NotCompliantMBeanException e) {
+            LOGGER.error("Cannot register BlueprintStateMBean", e);
+        }
+
+        // create BlueprintMetadataMBean
+        try {
+            blueprintMetadata = new StandardMBean(new BlueprintMetadata(bundleContext), BlueprintMetadataMBean.class);
+        } catch (NotCompliantMBeanException e) {
+            LOGGER.error("Unable to create StandardMBean for BlueprintMetadata", e);
+            return;
+        }
+        // register BlueprintMetadataMBean to MBean server
+        LOGGER.debug("Registering bundle metadata monitor with MBeanServer: {} with name: {}",
+                    mbeanServer, blueprintMetadataName);
+        try {
+            mbeanServer.registerMBean(blueprintMetadata, blueprintMetadataName);
+        } catch (InstanceAlreadyExistsException e) {
+            LOGGER.debug("Cannot register BlueprintMetadataMBean");
+        } catch (MBeanRegistrationException e) {
+            LOGGER.error("Cannot register BlueprintMetadataMBean", e);
+        } catch (NotCompliantMBeanException e) {
+            LOGGER.error("Cannot register BlueprintMetadataMBean", e);
+        }
+
+        servicesRegistered.set(true);
+    }
+
+    protected synchronized void deregisterMBeans(MBeanServer mbeanServer) {
+        if (!servicesRegistered.get()) {
+            return;
+        }
+        // unregister BlueprintStateMBean from MBean server
+        try {
+            mbeanServer.unregisterMBean(blueprintStateName);
+        } catch (InstanceNotFoundException e) {
+            LOGGER.debug("BlueprintStateMBean not found on deregistration");
+        } catch (MBeanRegistrationException e) {
+            LOGGER.error("BlueprintStateMBean deregistration problem");
+        }
+        blueprintState = null;
+
+        // unregister BlueprintMetadataMBean from MBean server
+        try {
+            mbeanServer.unregisterMBean(blueprintMetadataName);
+        } catch (InstanceNotFoundException e) {
+            LOGGER.debug("BlueprintMetadataMBean not found on deregistration");
+        } catch (MBeanRegistrationException e) {
+            LOGGER.error("BlueprintMetadataMBean deregistration problem");
+        }
+        blueprintMetadata = null;
+
+        servicesRegistered.set(false);
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/BlueprintMetadata.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/BlueprintMetadata.java
index e69de29b..8b2bfc8c 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/BlueprintMetadata.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/BlueprintMetadata.java
@@ -0,0 +1,147 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.impl;
+
+import java.io.IOException;
+import java.util.Collection;
+
+import javax.management.openmbean.CompositeData;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.apache.aries.jmx.blueprint.codec.BPMetadata;
+import org.apache.aries.jmx.blueprint.codec.Util;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Constants;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.ServiceReference;
+import org.osgi.service.blueprint.container.BlueprintContainer;
+import org.osgi.service.blueprint.reflect.BeanMetadata;
+import org.osgi.service.blueprint.reflect.ComponentMetadata;
+import org.osgi.service.blueprint.reflect.ServiceMetadata;
+import org.osgi.service.blueprint.reflect.ServiceReferenceMetadata;
+
+public class BlueprintMetadata implements BlueprintMetadataMBean {
+
+    BundleContext bundleContext;
+
+    public BlueprintMetadata(BundleContext bundleContext) {
+        this.bundleContext = bundleContext;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.aries.jmx.blueprint.BlueprintMetadataMBean#getBlueprintContainerServiceId(long)
+     */
+    public long getBlueprintContainerServiceId(long bundleId) throws IOException {
+        Bundle bpBundle = bundleContext.getBundle(bundleId);
+        if (null == bpBundle)
+            throw new IllegalArgumentException("Invalid bundle id " + bundleId);
+
+        String filter = "(&(osgi.blueprint.container.symbolicname=" // no similar one in interfaces
+                + bpBundle.getSymbolicName() + ")(osgi.blueprint.container.version=" + bpBundle.getVersion() + "))";
+        ServiceReference[] serviceReferences = null;
+        try {
+            serviceReferences = bundleContext.getServiceReferences(BlueprintContainer.class.getName(), filter);
+        } catch (InvalidSyntaxException e) {
+            throw new RuntimeException(e);
+        }
+        if (serviceReferences == null || serviceReferences.length < 1)
+            return -1;
+        else
+            return (Long) serviceReferences[0].getProperty(Constants.SERVICE_ID);
+    }
+
+    public long[] getBlueprintContainerServiceIds() throws IOException {
+        ServiceReference[] serviceReferences = null;
+        try {
+            serviceReferences = bundleContext.getServiceReferences(BlueprintContainer.class.getName(), null);
+        } catch (InvalidSyntaxException e) {
+            throw new RuntimeException(e);
+        }
+        if (serviceReferences == null || serviceReferences.length < 1)
+            return null;
+        
+        long[] serviceIds = new long[serviceReferences.length];
+        for (int i = 0; i < serviceReferences.length; i++) {
+            serviceIds[i] = (Long) serviceReferences[i].getProperty(Constants.SERVICE_ID);
+        }
+        return serviceIds;
+    }
+
+    public String[] getComponentIds(long containerServiceId) {
+        BlueprintContainer container = getBlueprintContainer(containerServiceId);
+        return (String[]) container.getComponentIds().toArray(new String[0]);
+    }
+
+    /*
+     * 
+     * type could be Bean, Service, serviceReference (non-Javadoc)
+     * 
+     * @see org.apache.aries.jmx.blueprint.BlueprintMetadataMBean#getComponentIdsByType(long, java.lang.String)
+     */
+    public String[] getComponentIdsByType(long containerServiceId, String type) {
+        BlueprintContainer container = getBlueprintContainer(containerServiceId);
+        Collection<? extends ComponentMetadata> components;
+        if (type.equals(BlueprintMetadataMBean.SERVICE_METADATA)) {
+            components = container.getMetadata(ServiceMetadata.class);
+        } else if (type.equals(BlueprintMetadataMBean.BEAN_METADATA)) {
+            components = container.getMetadata(BeanMetadata.class);
+        } else if (type.equals(BlueprintMetadataMBean.SERVICE_REFERENCE_METADATA)) {
+            components = container.getMetadata(ServiceReferenceMetadata.class);
+        } else {
+            throw new IllegalArgumentException("Unrecognized component type: " + type);
+        }
+        String ids[] = new String[components.size()];
+        int i = 0;
+        for (ComponentMetadata component : components) {
+            // from compendium 121.4.8, in-line managers can not be retrieved by getMetadata, which will return null.
+            // Because in-line managers are actually the object values.
+            // Here we ignore it.
+            if(null == component)
+                continue;
+            ids[i++] = component.getId();
+        }
+        return ids;
+    }
+
+    public CompositeData getComponentMetadata(long containerServiceId, String componentId) {
+        BlueprintContainer container = getBlueprintContainer(containerServiceId);
+        ComponentMetadata componentMetadata = container.getComponentMetadata(componentId);
+        BPMetadata metadata = Util.metadata2BPMetadata(componentMetadata);
+        return metadata.asCompositeData();
+    }
+
+    private BlueprintContainer getBlueprintContainer(long containerServiceId) {
+        String filter = "(" + Constants.SERVICE_ID + "=" + containerServiceId + ")";
+        ServiceReference[] serviceReferences = null;
+        try {
+            serviceReferences = bundleContext.getServiceReferences(BlueprintContainer.class.getName(), filter);
+        } catch (InvalidSyntaxException e) {
+            throw new RuntimeException(e);
+        }
+
+        if (serviceReferences == null || serviceReferences.length <1) {
+            throw new IllegalArgumentException("Invalid BlueprintContainer service id: " + containerServiceId);
+        }
+        return (BlueprintContainer) bundleContext.getService(serviceReferences[0]);
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/BlueprintState.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/BlueprintState.java
index b56de2e8..a5567e9f 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/BlueprintState.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/BlueprintState.java
@@ -1,3 +1,180 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.impl;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.management.MBeanNotificationInfo;
+import javax.management.MBeanRegistration;
+import javax.management.MBeanServer;
+import javax.management.Notification;
+import javax.management.NotificationBroadcasterSupport;
+import javax.management.ObjectName;
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularDataSupport;
+
+import org.apache.aries.jmx.blueprint.BlueprintStateMBean;
+import org.apache.aries.jmx.blueprint.codec.OSGiBlueprintEvent;
+import org.apache.aries.util.AriesFrameworkUtil;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceRegistration;
+import org.osgi.service.blueprint.container.BlueprintEvent;
+import org.osgi.service.blueprint.container.BlueprintListener;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class BlueprintState extends NotificationBroadcasterSupport implements BlueprintStateMBean, MBeanRegistration {
+
+    // notification type description
+    public static String BLUEPRINT_EVENT = "org.osgi.blueprint.event";
+
+    private static final Logger LOGGER = LoggerFactory.getLogger(BlueprintState.class);
+
+    private BundleContext context;
+
+    private ServiceRegistration listenerReg;
+
+    private Map<Long, CompositeData> dataMap = new HashMap<Long, CompositeData>();
+
+    private ExecutorService eventDispatcher;
+
+    private AtomicInteger notificationSequenceNumber = new AtomicInteger(1);
+
+    private AtomicInteger registrations = new AtomicInteger(0);
+
+    public BlueprintState(BundleContext context) {
+        this.context = context;
+    }
+
+    public synchronized long[] getBlueprintBundleIds() throws IOException {
+        Long[] bundleIdKeys = dataMap.keySet().toArray(new Long[dataMap.size()]);
+        long[] bundleIds = new long[bundleIdKeys.length];
+        for (int i = 0; i < bundleIdKeys.length; i++) {
+            bundleIds[i] = bundleIdKeys[i];
+        }
+        return bundleIds;
+    }
+
+    public synchronized CompositeData getLastEvent(long bundleId) throws IOException {
+        return dataMap.get(bundleId);
+    }
+
+    public synchronized TabularData getLastEvents() throws IOException {
+        TabularDataSupport table = new TabularDataSupport(BlueprintStateMBean.OSGI_BLUEPRINT_EVENTS_TYPE);
+        table.putAll(dataMap);
+        return table;
+    }
+
+    public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception {
+        // no op
+        return name;
+    }
+
+    public void postRegister(Boolean registrationDone) {
+        // reg listener
+        if (registrationDone && registrations.incrementAndGet() == 1) {
+            BlueprintListener listener = new BlueprintStateListener();
+            eventDispatcher = Executors.newSingleThreadExecutor(new JMXThreadFactory("JMX OSGi Blueprint State Event Dispatcher"));
+            listenerReg = context.registerService(BlueprintListener.class.getName(), listener, null);
+        }
+    }
+
+    public void preDeregister() throws Exception {
+        // no op
+    }
+
+    public void postDeregister() {
+        if (registrations.decrementAndGet() < 1) {
+            AriesFrameworkUtil.safeUnregisterService(listenerReg); 
+          
+            if (eventDispatcher != null) {
+                eventDispatcher.shutdown(); 
+            }
+        }
+    }
+
+    protected synchronized void onEvent(BlueprintEvent event) {
+        CompositeData data = new OSGiBlueprintEvent(event).asCompositeData();
+        dataMap.put(event.getBundle().getBundleId(), data);
+
+        if (!event.isReplay()) {
+            final Notification notification = new Notification(EVENT_TYPE, OBJECTNAME,
+                    notificationSequenceNumber.getAndIncrement());
+            try {
+                notification.setUserData(data);
+                eventDispatcher.submit(new Runnable() {
+                    public void run() {
+                        sendNotification(notification);
+                    }
+                });
+            } catch (RejectedExecutionException re) {
+                LOGGER.warn("Task rejected for JMX Notification dispatch of event ["
+                        + event + "] - Dispatcher may have been shutdown");
+            } catch (Exception e) {
+                LOGGER.warn("Exception occured on JMX Notification dispatch for event [" + event + "]", e);
+            }
+        }
+    }
+
+    /**
+     * @see javax.management.NotificationBroadcasterSupport#getNotificationInfo()
+     */
+    @Override
+    public MBeanNotificationInfo[] getNotificationInfo() {
+        String[] types = new String[] { BLUEPRINT_EVENT };
+        String name = Notification.class.getName();
+        String description = "A BlueprintEvent issued from the Blueprint Extender describing a blueprint bundle lifecycle change";
+        MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description);
+        return new MBeanNotificationInfo[] { info };
+    }
+
+    private class BlueprintStateListener implements BlueprintListener {
+        public void blueprintEvent(BlueprintEvent event) {
+            onEvent(event);
+        }
+
+    }
+
+    public static class JMXThreadFactory implements ThreadFactory {
+        private final ThreadFactory factory = Executors.defaultThreadFactory();
+        private final String name;
+
+        public JMXThreadFactory(String name) {
+            this.name = name;
+        }
+
+        public Thread newThread(Runnable r) {
+            final Thread t = factory.newThread(r);
+            t.setName(name);
+            t.setDaemon(true);
+            return t;
+        }
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/RegistrableStandardEmitterMBean.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/RegistrableStandardEmitterMBean.java
index b56de2e8..cd00f616 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/RegistrableStandardEmitterMBean.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/main/java/org/apache/aries/jmx/blueprint/impl/RegistrableStandardEmitterMBean.java
@@ -1,3 +1,146 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.blueprint.impl;
+
+import javax.management.*;
+
+/**
+ * The <code>StandardMBean</code> does not appear to delegate correctly to the underlying MBean implementation. Due to
+ * issues surrounding the <code>MBeanRegistration</code> callback methods and <code>NotificationEmmitter</code> methods,
+ * this subclass was introduced to force the delegation
+ * 
+ * @version $Rev$ $Date$
+ */
+public class RegistrableStandardEmitterMBean extends StandardMBean implements MBeanRegistration, NotificationEmitter {
+
+    public <T> RegistrableStandardEmitterMBean(T impl, Class<T> intf) throws NotCompliantMBeanException {
+        super(impl, intf);
+    }
+
+    /**
+     * @see javax.management.StandardMBean#getMBeanInfo()
+     */
+    public MBeanInfo getMBeanInfo() {
+        MBeanInfo mbeanInfo = super.getMBeanInfo();
+        if (mbeanInfo != null) {
+            MBeanNotificationInfo[] notificationInfo;
+            Object impl = getImplementation();
+            if (impl instanceof NotificationEmitter) {
+                notificationInfo = ((NotificationEmitter) (impl)).getNotificationInfo();
+            } else {
+                notificationInfo = new MBeanNotificationInfo[0];
+            }
+            mbeanInfo = new MBeanInfo(mbeanInfo.getClassName(), mbeanInfo.getDescription(), mbeanInfo.getAttributes(),
+                    mbeanInfo.getConstructors(), mbeanInfo.getOperations(), notificationInfo);
+        }
+        return mbeanInfo;
+    }
+
+    /**
+     * @see javax.management.MBeanRegistration#postDeregister()
+     */
+    public void postDeregister() {
+        Object impl = getImplementation();
+        if (impl instanceof MBeanRegistration) {
+            ((MBeanRegistration) impl).postDeregister();
+        }
+    }
+
+    /**
+     * @see javax.management.MBeanRegistration#postRegister(Boolean)
+     */
+    public void postRegister(Boolean registrationDone) {
+        Object impl = getImplementation();
+        if (impl instanceof MBeanRegistration) {
+            ((MBeanRegistration) impl).postRegister(registrationDone);
+        }
+    }
+
+    /**
+     * @see javax.management.MBeanRegistration#preDeregister()
+     */
+    public void preDeregister() throws Exception {
+        Object impl = getImplementation();
+        if (impl instanceof MBeanRegistration) {
+            ((MBeanRegistration) impl).preDeregister();
+        }
+    }
+
+    /**
+     * @see javax.management.MBeanRegistration#preRegister(javax.management.MBeanServer, javax.management.ObjectName)
+     */
+    public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception {
+        ObjectName result = name;
+        Object impl = getImplementation();
+        if (impl instanceof MBeanRegistration) {
+            result = ((MBeanRegistration) impl).preRegister(server, name);
+        }
+        return result;
+    }
+
+    /**
+     * @see javax.management.NotificationEmitter#removeNotificationListener(javax.management.NotificationListener,
+     *      javax.management.NotificationFilter, Object)
+     */
+    public void removeNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback)
+            throws ListenerNotFoundException {
+        Object impl = getImplementation();
+        if (impl instanceof NotificationEmitter) {
+            ((NotificationEmitter) (impl)).removeNotificationListener(listener, filter, handback);
+        }
+    }
+
+    /**
+     * @see javax.management.NotificationBroadcaster#addNotificationListener(javax.management.NotificationListener,
+     *      javax.management.NotificationFilter, Object)
+     */
+    public void addNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback)
+            throws IllegalArgumentException {
+        Object impl = getImplementation();
+        if (impl instanceof NotificationEmitter) {
+            ((NotificationEmitter) (impl)).addNotificationListener(listener, filter, handback);
+        }
+    }
+
+    /**
+     * @see javax.management.NotificationBroadcaster#getNotificationInfo()
+     */
+    public MBeanNotificationInfo[] getNotificationInfo() {
+        MBeanNotificationInfo[] result;
+        Object impl = getImplementation();
+        if (impl instanceof NotificationEmitter) {
+            result = ((NotificationEmitter) (impl)).getNotificationInfo();
+        } else {
+            result = new MBeanNotificationInfo[0];
+        }
+        return result;
+    }
+
+    /**
+     * @see javax.management.NotificationBroadcaster#removeNotificationListener(javax.management.NotificationListener)
+     */
+    public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException {
+        Object impl = getImplementation();
+        if (impl instanceof NotificationEmitter) {
+            ((NotificationEmitter) (impl)).removeNotificationListener(listener);
+        }
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/test/java/org/apache/aries/jmx/blueprint/impl/BlueprintMetadataTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/test/java/org/apache/aries/jmx/blueprint/impl/BlueprintMetadataTest.java
index b56de2e8..0164c38e 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/test/java/org/apache/aries/jmx/blueprint/impl/BlueprintMetadataTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/test/java/org/apache/aries/jmx/blueprint/impl/BlueprintMetadataTest.java
@@ -1,3 +1,352 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.impl;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.jmock.Expectations;
+import org.jmock.Mockery;
+import org.jmock.integration.junit4.JMock;
+import org.jmock.integration.junit4.JUnit4Mockery;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Constants;
+import org.osgi.framework.ServiceReference;
+import org.osgi.framework.Version;
+import org.osgi.service.blueprint.container.BlueprintContainer;
+import org.osgi.service.blueprint.reflect.BeanMetadata;
+import org.osgi.service.blueprint.reflect.ServiceMetadata;
+
+@RunWith(JMock.class)
+public class BlueprintMetadataTest {
+
+    private BlueprintMetadata metadata;
+    private Mockery mockery = new JUnit4Mockery();
+    
+    private BundleContext mockContext;
+    private Bundle  mockBundle;
+    private ServiceReference[] mockServiceReferences = new ServiceReference[1];
+    //private ServiceReference mockServiceReference;
+    private BlueprintContainer mockContainer;
+    private ServiceMetadata mockServiceMetadata;
+    private BeanMetadata mockBeanMetadata;
+    
+    @Before
+    public void setUp() throws Exception {
+        mockContext = mockery.mock(BundleContext.class);
+        mockBundle = mockery.mock(Bundle.class);
+        mockServiceReferences[0] = mockery.mock(ServiceReference.class);
+        mockContainer = mockery.mock(BlueprintContainer.class);
+        mockServiceMetadata = mockery.mock(ServiceMetadata.class);
+        mockBeanMetadata = mockery.mock(BeanMetadata.class);
+        
+        metadata = new BlueprintMetadata(mockContext);
+    }
+
+    @After
+    public void tearDown() throws Exception {
+
+    }
+
+    @Test
+    public void validGetBlueprintContainerServiceId() throws Exception {
+        final long bundleId = 12;
+        final long serviceId = 7117;
+        
+        mockery.checking(new Expectations() {
+            {
+                allowing(mockContext).getBundle(bundleId);
+                will(returnValue(mockBundle));
+                oneOf(mockContext).getServiceReferences(with(any(String.class)), with(any(String.class)));
+                will(returnValue(mockServiceReferences));
+            }
+        });
+        // is there any need?
+        mockery.checking(new Expectations() {
+            {
+                allowing(mockBundle).getSymbolicName();
+                will(returnValue("org.apache.geronimo.blueprint.testXXX"));
+                allowing(mockBundle).getVersion();
+                will(returnValue(Version.emptyVersion));
+            }
+        });
+        mockery.checking(new Expectations() {
+            {
+                allowing(mockServiceReferences[0]).getProperty(Constants.SERVICE_ID);
+                will(returnValue(serviceId));
+            }
+        });
+
+        assertEquals(serviceId, metadata.getBlueprintContainerServiceId(bundleId));
+    }
+
+    @Test
+    public void invalidParaInGetBlueprintContainerServiceId() throws Exception
+    {
+        mockery.checking(new Expectations() {
+            {
+                allowing(mockContext).getBundle(with(any(Long.class)));
+                will(returnValue(null));
+            }
+        });
+        try{
+            metadata.getBlueprintContainerServiceId(-10);
+        } catch(Exception ex)
+        {
+            assertTrue(ex instanceof IllegalArgumentException);
+        }
+    }
+    
+    @Test
+    public void cannotFindAssociatedContainerServiceId() throws Exception
+    {
+        final long bundleId = 12;
+        
+        mockery.checking(new Expectations() {
+            {
+                allowing(mockContext).getBundle(bundleId);
+                will(returnValue(mockBundle));
+                oneOf(mockContext).getServiceReferences(with(any(String.class)), with(any(String.class)));
+                //return null if no services are registered which satisfy the search
+                will(returnValue(null));
+            }
+        });
+        // is there any need?
+        mockery.checking(new Expectations() {
+            {
+                allowing(mockBundle).getSymbolicName();
+                will(returnValue("org.apache.geronimo.blueprint.testXXX"));
+                allowing(mockBundle).getVersion();
+                will(returnValue(Version.emptyVersion));
+            }
+        });
+        assertEquals(-1, metadata.getBlueprintContainerServiceId(bundleId));
+    }
+    
+    @Test
+    public void normalBlueprintContainerServiceIds() throws Exception {
+        final long serviceId = 7117;
+        final long [] serviceIds = new long[]{serviceId};
+        
+        mockery.checking(new Expectations() {
+            {
+                oneOf(mockContext).getServiceReferences(with(any(String.class)), with(any(String.class)));
+                will(returnValue(mockServiceReferences));
+            }
+        });
+        mockery.checking(new Expectations() {
+            {
+                allowing(mockServiceReferences[0]).getProperty(Constants.SERVICE_ID);
+                will(returnValue(serviceId));
+            }
+        });
+        
+        assertArrayEquals(serviceIds, metadata.getBlueprintContainerServiceIds());
+    }
+
+    @Test 
+    public void noBlueprintContainerServiceIds() throws Exception
+    {//It is impossible according to osgi spec, here just test the robustness of code
+        mockery.checking(new Expectations() {
+            {
+                oneOf(mockContext).getServiceReferences(with(any(String.class)), with(any(String.class)));
+                //return null if no services are registered which satisfy the search
+                will(returnValue(null));
+            }
+        });
+        assertNull(metadata.getBlueprintContainerServiceIds());
+    }
+    
+    @Test
+    public void nomalGetComponentIds() throws Exception {
+        final long serviceId = 7117;
+        final Set cidset = getAsSet(new String[]{".component-1", ".component-2", ".component-5"});
+        
+        mockery.checking(new Expectations(){
+            {
+                oneOf(mockContext).getServiceReferences(with(any(String.class)), with(any(String.class)));
+                will(returnValue(mockServiceReferences));
+                oneOf(mockContext).getService(mockServiceReferences[0]);
+                will(returnValue(mockContainer));
+            }
+        });
+        mockery.checking(new Expectations(){
+            {
+                oneOf(mockContainer).getComponentIds();
+                will(returnValue(cidset));
+            }
+        });
+        
+        assertEquals(cidset, getAsSet(metadata.getComponentIds(serviceId)));
+    }
+
+    @Test
+    public void normalGetComponentIdsByType() throws Exception {
+        final long serviceId = 7117;
+        final String [] cidarray = new String[]{".component-1"};
+        final Collection cMetadatas = new ArrayList();
+        cMetadatas.add(mockServiceMetadata);
+        
+        mockery.checking(new Expectations(){
+            {
+                oneOf(mockContext).getServiceReferences(with(any(String.class)), with(any(String.class)));
+                will(returnValue(mockServiceReferences));
+                oneOf(mockContext).getService(mockServiceReferences[0]);
+                will(returnValue(mockContainer));
+            }
+        });
+        mockery.checking(new Expectations(){
+            {
+                oneOf(mockContainer).getMetadata(ServiceMetadata.class);
+                will(returnValue(cMetadatas));
+            }
+        });
+        mockery.checking(new Expectations(){
+            {
+                oneOf(mockServiceMetadata).getId();
+                will(returnValue(cidarray[0]));
+            }
+        });
+        
+        assertArrayEquals(cidarray, 
+                metadata.getComponentIdsByType(serviceId, BlueprintMetadataMBean.SERVICE_METADATA));
+    }
+
+    public void invalidParaInGetComponentIdsByType() throws Exception {
+        final long serviceId = 7117;
+                
+        mockery.checking(new Expectations(){
+            {
+                allowing(mockContext).getServiceReferences(with(any(String.class)), with(any(String.class)));
+                will(returnValue(mockServiceReferences));
+                allowing(mockContext).getService(mockServiceReferences[0]);
+                will(returnValue(mockContainer));
+            }
+        });
+        
+        try {
+            metadata.getComponentIdsByType(serviceId, null);
+        }catch(Exception ex)
+        {
+            assertTrue(ex instanceof IllegalArgumentException);
+        }
+        try {
+            metadata.getComponentIdsByType(serviceId, BlueprintMetadataMBean.COMPONENT_METADATA);
+        }catch(Exception ex)
+        {
+            assertTrue(ex instanceof IllegalArgumentException);
+        }
+    }
+    @Test
+    public void testGetComponentMetadata() throws Exception {
+        final long serviceId = 7117;
+        final String componentId = ".component-1";
+        final String [] cidarray = new String[]{componentId};
+        final List emptyList = new ArrayList();
+        
+        mockery.checking(new Expectations(){
+            {
+                oneOf(mockContext).getServiceReferences(with(any(String.class)), with(any(String.class)));
+                will(returnValue(mockServiceReferences));
+                oneOf(mockContext).getService(mockServiceReferences[0]);
+                will(returnValue(mockContainer));
+            }
+        });
+        mockery.checking(new Expectations(){
+            {
+                oneOf(mockContainer).getComponentMetadata(componentId);
+                will(returnValue(mockBeanMetadata));
+            }
+        });
+        mockery.checking(new Expectations(){
+            {
+                allowing(mockBeanMetadata).getDependsOn();
+                will(returnValue(emptyList));
+
+                allowing(mockBeanMetadata).getArguments();
+                will(returnValue(emptyList));
+                allowing(mockBeanMetadata).getFactoryComponent();
+                will(returnValue(null));
+                allowing(mockBeanMetadata).getProperties();
+                will(returnValue(emptyList));
+                ignoring(mockBeanMetadata);
+            }
+        });
+        metadata.getComponentMetadata(serviceId, componentId);
+        mockery.assertIsSatisfied();
+    }
+    
+    @Test
+    public void fail2GetBlueprintContainer() throws Exception
+    {
+        final long serviceId = 7117;
+        mockery.checking(new Expectations(){
+            {
+                exactly(3).of(mockContext).getServiceReferences(with(any(String.class)), with(any(String.class)));
+                will(returnValue(null));
+            }
+        });
+        
+        try{
+            metadata.getComponentIds(serviceId);
+        }catch(Exception ex)
+        {
+            assertTrue(ex instanceof IllegalArgumentException);
+        }
+        
+        try{
+            metadata.getComponentIdsByType(serviceId, BlueprintMetadataMBean.SERVICE_METADATA);
+        }catch(Exception ex)
+        {
+            assertTrue(ex instanceof IllegalArgumentException);
+        }
+        
+        try{
+            metadata.getComponentMetadata(serviceId, "xxxx");
+        }catch(Exception ex)
+        {
+            assertTrue(ex instanceof IllegalArgumentException);
+        }
+    }
+
+    private Set getAsSet(String[] data) {
+        Set dataSet = new HashSet();
+        dataSet.addAll(Arrays.asList(data));
+        return dataSet;
+    }
+        
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/test/java/org/apache/aries/jmx/blueprint/impl/BlueprintStateTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/test/java/org/apache/aries/jmx/blueprint/impl/BlueprintStateTest.java
index b56de2e8..3d3e97b5 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/test/java/org/apache/aries/jmx/blueprint/impl/BlueprintStateTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-blueprint-core/src/test/java/org/apache/aries/jmx/blueprint/impl/BlueprintStateTest.java
@@ -1,3 +1,61 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.blueprint.impl;
+
+import org.apache.aries.jmx.blueprint.BlueprintStateMBean;
+import org.jmock.Mockery;
+import org.jmock.integration.junit4.JMock;
+import org.jmock.integration.junit4.JUnit4Mockery;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.osgi.framework.BundleContext;
+
+//@RunWith(JMock.class)
+public class BlueprintStateTest {
+//    private Mockery mockery = new JUnit4Mockery();
+//    private BlueprintState state; 
+//    
+//    private BundleContext mockContext; 
+//    
+//    @Before
+//    public void setUp() throws Exception {
+//        mockContext = mockery.mock(BundleContext.class);
+//        
+//        state = new BlueprintState(mockContext);
+//    }
+    @Test
+    public void testGetBlueprintBundleIds(){
+        
+    }
+    
+    @Test
+    public void testGetLastEvent(){
+        
+    }
+    
+    @Test
+    public void testGetLastEvents(){
+        
+    }
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/AbstractCompendiumHandler.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/AbstractCompendiumHandler.java
index b56de2e8..1bb18bcf 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/AbstractCompendiumHandler.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/AbstractCompendiumHandler.java
@@ -1,3 +1,149 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx;
+
+import java.util.concurrent.ExecutorService;
+
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.agent.JMXAgentContext;
+import org.osgi.framework.Constants;
+import org.osgi.framework.Filter;
+import org.osgi.framework.ServiceReference;
+import org.osgi.service.log.LogService;
+import org.osgi.util.tracker.ServiceTracker;
+
+/**
+ * <p>
+ * Abstract implementation of {@link MBeanHandler} that provides a template with basic tracking of an optional
+ * compendium service. MBeanHandler implementations that manage a {@link StandardMBean} that is backed by a single OSGi
+ * compendium service should extend this class and implement the {@linkplain #constructInjectMBean(Object)} and
+ * {@linkplain #getName()} methods
+ * </p>
+ * 
+ * @see MBeanHandler
+ * 
+ * @version $Rev$ $Date$
+ */
+public abstract class AbstractCompendiumHandler extends ServiceTracker implements MBeanHandler {
+
+    protected final JMXAgentContext agentContext;
+    protected StandardMBean mbean;
+    protected Long trackedId;
+    
+    /**
+     * 
+     * @param agentContext
+     * @param filter
+     */
+    protected AbstractCompendiumHandler(JMXAgentContext agentContext, Filter filter) {
+        super(agentContext.getBundleContext(), filter, null);
+        this.agentContext = agentContext;
+    }
+
+    /**
+     * 
+     * @param agentContext
+     * @param clazz
+     */
+    protected AbstractCompendiumHandler(JMXAgentContext agentContext, String clazz) {
+        super(agentContext.getBundleContext(), clazz, null);
+        this.agentContext = agentContext;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.osgi.util.tracker.ServiceTracker#addingService(org.osgi.framework.ServiceReference)
+     */
+    public Object addingService(ServiceReference reference) {
+        Logger logger = agentContext.getLogger();
+        Object trackedService = null;
+        Long serviceId = (Long) reference.getProperty(Constants.SERVICE_ID);
+        //API stipulates versions for compendium services with static ObjectName
+        //This shouldn't happen but added as a consistency check
+        if (getTrackingCount() > 0) {
+            String serviceDescription = (String) ((reference.getProperty(Constants.SERVICE_DESCRIPTION) != null) ? 
+                    reference.getProperty(Constants.SERVICE_DESCRIPTION) : reference.getProperty(Constants.OBJECTCLASS));
+            logger.log(LogService.LOG_WARNING, "Detected secondary ServiceReference for [" + serviceDescription
+                    + "] with " + Constants.SERVICE_ID + " [" + serviceId + "] Only 1 instance will be JMX managed");
+        } else {
+            logger.log(LogService.LOG_INFO, "Registering MBean with ObjectName [" + getName() + "] for service with "
+                    + Constants.SERVICE_ID + " [" + serviceId + "]");
+            trackedService = context.getService(reference);
+            mbean = constructInjectMBean(trackedService);
+            ExecutorService executor = agentContext.getRegistrationExecutor();
+            executor.submit(new Runnable() {
+                public void run() {
+                    agentContext.registerMBean(AbstractCompendiumHandler.this);
+                }
+            });
+            trackedId = serviceId;
+        }
+        return trackedService;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.osgi.util.tracker.ServiceTracker#removedService(org.osgi.framework.ServiceReference, java.lang.Object)
+     */
+    public void removedService(ServiceReference reference, Object service) {
+        Logger logger = agentContext.getLogger();
+        Long serviceID = (Long) reference.getProperty(Constants.SERVICE_ID);
+        if (trackedId != null && !trackedId.equals(serviceID)) {
+            String serviceDescription = (String) ((reference.getProperty(Constants.SERVICE_DESCRIPTION) != null) ? 
+                    reference.getProperty(Constants.SERVICE_DESCRIPTION) : reference.getProperty(Constants.OBJECTCLASS));
+            logger.log(LogService.LOG_WARNING, "ServiceReference for [" + serviceDescription + "] with "
+                    + Constants.SERVICE_ID + " [" + serviceID + "] is not currently JMX managed");
+        } else {
+            logger.log(LogService.LOG_INFO, "Unregistering MBean with ObjectName [" + getName() + "] for service with "
+                    + Constants.SERVICE_ID + " [" + serviceID + "]"); 
+            ExecutorService executor = agentContext.getRegistrationExecutor();
+            executor.submit(new Runnable() {
+                public void run() {
+                    agentContext.unregisterMBean(getName());
+                }
+            });
+            trackedId = null;
+            context.ungetService(reference);
+        }
+    }
+
+    /**
+     * Gets the <code>StandardMBean</code> managed by this handler when the backing service is available or null
+     * 
+     * @see org.apache.aries.jmx.MBeanHandler#getMbean()
+     */
+    public StandardMBean getMbean() {
+        return mbean;
+    }
+
+    /**
+     * Implement this method to construct an appropriate {@link StandardMBean} instance which is backed by the supplied
+     * service tracked by this handler
+     * 
+     * @param targetService
+     *            the compendium service tracked by this handler
+     * @return The <code>StandardMBean</code> instance whose registration lifecycle will be managed by this handler
+     */
+    protected abstract StandardMBean constructInjectMBean(Object targetService);
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/Activator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/Activator.java
index 3f24d583..15b1ac4d 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/Activator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/Activator.java
@@ -1 +1,72 @@
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx;
+
+import org.apache.aries.jmx.agent.JMXAgent;
+import org.apache.aries.jmx.agent.JMXAgentImpl;
+import org.apache.aries.jmx.agent.JMXAgentContext;
+import org.osgi.framework.BundleActivator;
+import org.osgi.framework.BundleContext;
+import org.osgi.service.log.LogService;
+
+/**
+ * <p>Activator for JMX OSGi bundle.</p>
+ * 
+ * @version $Rev$ $Date$
+ */
+public class Activator implements BundleActivator {
+
+    private JMXAgent agent;
+    private Logger logger;
+
+    /**
+     * <p>Called when JMX OSGi bundle starts.
+     * This method creates and starts JMX agent.</p>
+     * 
+     * @see org.osgi.framework.BundleActivator#start(BundleContext)
+     */
+    public void start(BundleContext context) throws Exception {
+        logger = new Logger(context);
+        //starting logger
+        logger.open();
+        logger.log(LogService.LOG_DEBUG, "Starting JMX OSGi bundle");
+        agent = new JMXAgentImpl(logger);
+        JMXAgentContext agentContext = new JMXAgentContext(context, agent, logger);
+        agent.setAgentContext(agentContext);
+        agent.start();
+    }
+
+    /**
+     * <p>Called when JMX OSGi bundle stops.
+     * This method stops agent and logger @see {@link Logger}.</p>
+     * 
+     * @see org.osgi.framework.BundleActivator#stop(BundleContext)
+     */
+    public void stop(BundleContext bc) throws Exception {
+        if (logger != null) {
+            logger.log(LogService.LOG_DEBUG, "Stopping JMX OSGi bundle");
+        }
+        if (agent != null) {
+            agent.stop();
+        }
+        if (logger != null) {
+            logger.close();
+        }
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/JMXThreadFactory.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/JMXThreadFactory.java
index b56de2e8..a636c738 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/JMXThreadFactory.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/JMXThreadFactory.java
@@ -1,3 +1,39 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx;
+
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
+
+public class JMXThreadFactory implements ThreadFactory {
+    private final ThreadFactory factory = Executors.defaultThreadFactory();
+    private final String name;
+    
+    public JMXThreadFactory(String name) {
+        this.name = name;
+    }
+
+    public Thread newThread(Runnable r) {
+        final Thread t = factory.newThread(r);
+        t.setName(name);
+        t.setDaemon(true);
+        return t;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/Logger.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/Logger.java
index b56de2e8..8e9ec428 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/Logger.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/Logger.java
@@ -1,3 +1,91 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx;
+
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceReference;
+import org.osgi.service.log.LogService;
+import org.osgi.util.tracker.ServiceTracker;
+
+/**
+ * <p>This <tt>Logger</tt> class represents ServiceTracker for LogService. 
+ * It provides methods for logging messages. If LogService is not available it logs to stdout.</p>
+ * 
+ * @see org.osgi.service.log.LogService
+ * @see org.osgi.util.tracker.ServiceTracker
+ * @version $Rev$ $Date$
+ */
+public class Logger extends ServiceTracker implements LogService {
+    
+    private String bundleLocation;
+
+    /**
+     * Constructs new Logger(ServiceTracker for LogService).
+     * 
+     * @param context bundle context.
+     */
+    public Logger(BundleContext context) {
+        super(context, LogService.class.getName(), null);
+        this.bundleLocation = context.getBundle().getLocation();
+    }
+
+    /**
+     * @see org.osgi.service.log.LogService#log(int, java.lang.String)
+     */
+    public void log(int level, String message) {
+        LogService logService = (LogService) getService();
+        if (logService != null) {
+            logService.log(level, message);
+        }
+
+    }
+
+    /**
+     * @see org.osgi.service.log.LogService#log(int, java.lang.String, java.lang.Throwable)
+     */
+    public void log(int level, String message, Throwable exception) {
+        LogService logService = (LogService) getService();
+        if (logService != null) {
+            logService.log(level, message, exception);
+        }
+    }
+
+    /**
+     * @see org.osgi.service.log.LogService#log(org.osgi.framework.ServiceReference, int, java.lang.String)
+     */
+    public void log(ServiceReference ref, int level, String message) {
+        LogService logService = (LogService) getService();
+        if (logService != null) {
+            logService.log(ref, level, message);
+        }
+    }
+
+    /**
+     * @see org.osgi.service.log.LogService#log(org.osgi.framework.ServiceReference, int, java.lang.String,
+     *      java.lang.Throwable)
+     */
+    public void log(ServiceReference ref, int level, String message, Throwable exception) {
+        LogService logService = (LogService) getService();
+        if (logService != null) {
+            logService.log(ref, level, message, exception);
+        }
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/MBeanHandler.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/MBeanHandler.java
index 56d8ebfd..693823d9 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/MBeanHandler.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/MBeanHandler.java
@@ -1,2 +1,53 @@
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx;
+
+import javax.management.StandardMBean;
+
+/**
+ * <p>Represents JMX OSGi MBeans handler.
+ * Storing information about holden MBean.</p>
+ * 
+ * @version $Rev$ $Date$
+ */
+public interface MBeanHandler {
+
+    /**
+     * Gets MBean holden by handler.
+     * @return MBean @see {@link StandardMBean}.
+     */
+    StandardMBean getMbean();
+
+    /**
+     * Starts handler.
+     */
+    void open();
+
+    /**
+     * Stops handler.
+     */
+    void close();
+
+    /**
+     * Gets name of the MBean.
+     * @return MBean name.
+     */
+    String getName();
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/MBeanServiceTracker.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/MBeanServiceTracker.java
index b56de2e8..4b4d1238 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/MBeanServiceTracker.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/MBeanServiceTracker.java
@@ -1,3 +1,93 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx;
+
+import java.util.concurrent.ExecutorService;
+
+import javax.management.MBeanServer;
+
+import org.apache.aries.jmx.agent.JMXAgentContext;
+import org.osgi.framework.ServiceReference;
+import org.osgi.service.log.LogService;
+import org.osgi.util.tracker.ServiceTracker;
+
+/**
+ * <p>This class <tt>MBeanServiceTracker</tt> represents {@link ServiceTracker} for {@link MBeanServer}'s
+ * registered as services.
+ * Tracking all registered MBeanServers in ServiceRegistry.</p>
+ * @see ServiceTracker
+ * @version $Rev$ $Date$
+ */
+public class MBeanServiceTracker extends ServiceTracker {
+
+    private JMXAgentContext agentContext;
+
+    /**
+     * Constructs new MBeanServiceTracker.
+     * @param agentContext agent context.
+     */
+    public MBeanServiceTracker(JMXAgentContext agentContext) {
+        super(agentContext.getBundleContext(), MBeanServer.class.getName(), null);
+        this.agentContext = agentContext;
+    }
+
+    /**
+     * <p>Register MBeans using {@link JMXAgentContext#registerMBeans(MBeanServer)} 
+     * when MBeanServer service is discovered</p> 
+     * @see ServiceTracker#addingService(ServiceReference)
+     */
+    public Object addingService(final ServiceReference reference) {
+        final MBeanServer mbeanServer = (MBeanServer) context.getService(reference);
+        Logger logger = agentContext.getLogger();
+        logger.log(LogService.LOG_DEBUG, "Discovered MBean server " + mbeanServer);
+        ExecutorService executor = agentContext.getRegistrationExecutor();
+        executor.submit(new Runnable() {
+
+            public void run() {
+                agentContext.registerMBeans(mbeanServer);
+
+            }
+        });
+
+        return super.addingService(reference);
+    }
+
+    /**
+     * <p>Unregister MBeans using {@link JMXAgentContext#unregisterMBeans(MBeanServer)} 
+     * when MBeanServer service is removed (unregistered from ServiceRegistry) or
+     * tracker is closed</p> 
+     * @see ServiceTracker#removedService(ServiceReference, Object)
+     */
+    public void removedService(final ServiceReference reference, Object service) {
+        final MBeanServer mbeanServer = (MBeanServer) context.getService(reference);
+        Logger logger = agentContext.getLogger();
+        logger.log(LogService.LOG_DEBUG, "MBean server " + mbeanServer+ " is unregistered from SeviceRegistry");
+        ExecutorService executor = agentContext.getRegistrationExecutor();
+        executor.submit(new Runnable() {
+
+            public void run() {
+                agentContext.unregisterMBeans(mbeanServer);
+            }
+        });
+        super.removedService(reference, service);
+    }
+
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/agent/JMXAgent.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/agent/JMXAgent.java
index e69de29b..8e4465e0 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/agent/JMXAgent.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/agent/JMXAgent.java
@@ -0,0 +1,88 @@
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.agent;
+
+import java.util.concurrent.ExecutorService;
+
+import javax.management.MBeanServer;
+
+import org.apache.aries.jmx.MBeanHandler;
+
+/**
+ * <p>This <tt>JMXAgent</tt> class represent agent for MBeanServers registered in ServiceRegistry.
+ * It's responsible for registration and unregistration MBeans with available MBeanServers.
+ * </p>
+ * 
+ * @version $Rev$ $Date$
+ */
+public interface JMXAgent {
+
+    /**
+     * This method starts JMX agent.
+     * Creates and starting all MBean Handlers and MBeanServiceTracker. 
+     */
+    void start();
+
+    /**
+     * Registers MBeans with provided MBeanServer.
+     * @param server MBeanServer with which MBeans are going to be registered 
+     */
+    void registerMBeans(final MBeanServer server);
+
+    /**
+     * Unregisters MBeans with provided MBeanServer.
+     * @param server MBeanServer with which MBeans are going to be unregistered.
+     */
+    void unregisterMBeans(final MBeanServer server);
+
+    /**
+     * Registers MBean with all available MBeanServers.
+     * @param mBeanHandler handler which contains MBean info.
+     */
+    void registerMBean(final MBeanHandler mBeanHandler);
+
+    /**
+     * Unregisters MBean with all available MBeanServers.
+     * @param name of MBean to be unregistered.
+     */
+    void unregisterMBean(final String name);
+
+    /**
+     * Stops JMXAgent.
+     * This method stops MBeanServiceTracker and all MBean handlers.
+     */
+    void stop();
+
+    /**
+     * Gets JMXAgentContext @see {@link JMXAgentContext}.
+     * @return JMXAgentContext instance.
+     */
+    JMXAgentContext getAgentContext();
+
+    /**
+     * Sets JMXAgentContext for this agent.
+     * @param agentContext JMXAgentContext instance created for this agent.
+     */
+    void setAgentContext(JMXAgentContext agentContext);
+
+    /**
+     * Gets registration {@link ExecutorService}.
+     * @return registration executor.
+     */
+    ExecutorService getRegistrationExecutor();
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/agent/JMXAgentContext.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/agent/JMXAgentContext.java
index b56de2e8..13b61cf0 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/agent/JMXAgentContext.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/agent/JMXAgentContext.java
@@ -1,3 +1,111 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.agent;
+
+import java.util.concurrent.ExecutorService;
+
+import javax.management.MBeanServer;
+
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.MBeanHandler;
+import org.osgi.framework.BundleContext;
+
+/**
+ * <p>This class <tt>JMXAgentContext</tt> represents context of JMXAgent.
+ * Delegates registration and unregistration methods to {@link JMXAgent}.</p>
+ * @see JMXAgent
+ * 
+ * @version $Rev$ $Date$
+ */
+public class JMXAgentContext {
+
+    private JMXAgent agent;
+    private BundleContext bundleContext;
+    private Logger logger;
+
+    /**
+     * Constructs new JMXAgentContext.
+     * @param bundleContext bundle context @see {@link BundleContext}.
+     * @param agent {@link JMXAgent}.
+     * @param log logger represents by @see {@link Logger}.
+     */
+    public JMXAgentContext(BundleContext bundleContext, JMXAgent agent, Logger log) {
+        this.bundleContext = bundleContext;
+        this.agent = agent;
+        this.logger = log;
+    }
+
+    /**
+     * Delegates invocation to JMX agent.
+     * @see org.apache.aries.jmx.agent.JMXAgent#registerMBeans(MBeanServer)
+     * 
+     */
+    public void registerMBeans(final MBeanServer server) {
+        agent.registerMBeans(server);
+    }
+
+    /**
+     * Delegates invocation to JMX agent.
+     * @see org.apache.aries.jmx.agent.JMXAgent#unregisterMBeans(MBeanServer)
+     */
+    public void unregisterMBeans(final MBeanServer server) {
+        agent.unregisterMBeans(server);
+    }
+
+    /**
+     * Delegates invocation to JMX agent.
+     * @see org.apache.aries.jmx.agent.JMXAgentl#registerMBean(MBeanHandler)
+     */
+    public void registerMBean(final MBeanHandler mbeanData) {
+        agent.registerMBean(mbeanData);
+    }
+
+    /**
+     * Delegates invocation to JMX agent.
+     * @see org.apache.aries.jmx.agent.JMXAgent#unregisterMBean(String)
+     */
+    public void unregisterMBean(final String name) {
+        agent.unregisterMBean(name);
+    }
+
+    /**
+     * Gets bundle context.
+     * @return bundle context.
+     */
+    public BundleContext getBundleContext() {
+        return bundleContext;
+    }
+
+    /**
+     * Gets a logger represents by @see {@link Logger}.
+     * @return LogService tracker.
+     */
+    public Logger getLogger() {
+        return logger;
+    }
+
+    /**
+     * Delegates invocation to JMX agent.
+     * @see org.apache.aries.jmx.agent.JMXAgent#getRegistrationExecutor()
+     */
+    public ExecutorService getRegistrationExecutor() {
+        return agent.getRegistrationExecutor();
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/agent/JMXAgentImpl.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/agent/JMXAgentImpl.java
index b56de2e8..49b347cf 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/agent/JMXAgentImpl.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/agent/JMXAgentImpl.java
@@ -1,3 +1,287 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.agent;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+import javax.management.InstanceAlreadyExistsException;
+import javax.management.InstanceNotFoundException;
+import javax.management.MBeanRegistrationException;
+import javax.management.MBeanServer;
+import javax.management.MalformedObjectNameException;
+import javax.management.NotCompliantMBeanException;
+import javax.management.ObjectName;
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.JMXThreadFactory;
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.MBeanHandler;
+import org.apache.aries.jmx.MBeanServiceTracker;
+import org.apache.aries.jmx.cm.ConfigurationAdminMBeanHandler;
+import org.apache.aries.jmx.framework.BundleRevisionsStateMBeanHandler;
+import org.apache.aries.jmx.framework.BundleStateMBeanHandler;
+import org.apache.aries.jmx.framework.FrameworkMBeanHandler;
+import org.apache.aries.jmx.framework.PackageStateMBeanHandler;
+import org.apache.aries.jmx.framework.ServiceStateMBeanHandler;
+import org.apache.aries.jmx.permissionadmin.PermissionAdminMBeanHandler;
+import org.apache.aries.jmx.provisioning.ProvisioningServiceMBeanHandler;
+import org.apache.aries.jmx.useradmin.UserAdminMBeanHandler;
+import org.osgi.framework.BundleContext;
+import org.osgi.service.log.LogService;
+import org.osgi.util.tracker.ServiceTracker;
+
+/**
+ * <p>
+ * Represent agent for MBeanServers registered in ServiceRegistry. Providing registration and unregistration methods.
+ * </p>
+ *
+ * @see JMXAgent
+ *
+ * @version $Rev$ $Date$
+ */
+public class JMXAgentImpl implements JMXAgent {
+
+    private ServiceTracker mbeanServiceTracker;
+    /**
+     * {@link MBeanHandler} store.
+     */
+    private Set<MBeanHandler> mbeansHandlers;
+    private JMXAgentContext agentContext;
+    private Logger logger;
+
+    /**
+     * Registration {@link ExecutorService}.
+     */
+    private ExecutorService registrationExecutor;
+
+    /**
+     * Constructs new JMXAgent.
+     *
+     * @param logger @see org.apache.aries.jmx.Logger
+     */
+    public JMXAgentImpl(Logger logger) {
+        this.logger = logger;
+        this.mbeansHandlers = new HashSet<MBeanHandler>();
+        this.registrationExecutor = Executors.newSingleThreadExecutor(new JMXThreadFactory("JMX OSGi Agent"));
+    }
+
+    /**
+     * @see org.apache.aries.jmx.agent.JMXAgent#start()
+     */
+    public void start() {
+        logger.log(LogService.LOG_INFO, "Starting JMX OSGi agent");
+        BundleContext bc = agentContext.getBundleContext();
+        MBeanHandler frameworkHandler = new FrameworkMBeanHandler(bc, logger);
+        frameworkHandler.open();
+        mbeansHandlers.add(frameworkHandler);
+        MBeanHandler bundleStateHandler = new BundleStateMBeanHandler(bc, logger);
+        bundleStateHandler.open();
+        mbeansHandlers.add(bundleStateHandler);
+        MBeanHandler revisionsStateHandler = new BundleRevisionsStateMBeanHandler(bc, logger);
+        revisionsStateHandler.open();
+        mbeansHandlers.add(revisionsStateHandler);
+        MBeanHandler serviceStateHandler = new ServiceStateMBeanHandler(bc, logger);
+        serviceStateHandler.open();
+        mbeansHandlers.add(serviceStateHandler);
+        MBeanHandler packageStateHandler = new PackageStateMBeanHandler(bc, logger);
+        packageStateHandler.open();
+        mbeansHandlers.add(packageStateHandler);
+        MBeanHandler permissionAdminHandler = new PermissionAdminMBeanHandler(agentContext);
+        permissionAdminHandler.open();
+        mbeansHandlers.add(permissionAdminHandler);
+        MBeanHandler userAdminHandler = new UserAdminMBeanHandler(agentContext);
+        userAdminHandler.open();
+        mbeansHandlers.add(userAdminHandler);
+        MBeanHandler configAdminHandler = new ConfigurationAdminMBeanHandler(agentContext);
+        configAdminHandler.open();
+        mbeansHandlers.add(configAdminHandler);
+        MBeanHandler provServiceHandler = new ProvisioningServiceMBeanHandler(agentContext);
+        provServiceHandler.open();
+        mbeansHandlers.add(provServiceHandler);
+        mbeanServiceTracker = new MBeanServiceTracker(agentContext);
+        mbeanServiceTracker.open();
+    }
+
+    /**
+     * @see org.apache.aries.jmx.agent.JMXAgent#registerMBeans(javax.management.MBeanServer)
+     */
+    public void registerMBeans(final MBeanServer server) {
+        for (MBeanHandler mbeanHandler : mbeansHandlers) {
+            String name = mbeanHandler.getName();
+            StandardMBean mbean = mbeanHandler.getMbean();
+            if (mbean != null) {
+                try {
+                    logger.log(LogService.LOG_INFO, "Registering " + mbean.getMBeanInterface().getName()
+                            + " to MBeanServer " + server + " with name " + name);
+                    server.registerMBean(mbean, new ObjectName(name));
+                } catch (InstanceAlreadyExistsException e) {
+                    logger.log(LogService.LOG_ERROR, "MBean is already registered", e);
+                } catch (MBeanRegistrationException e) {
+                    logger.log(LogService.LOG_ERROR, "Can't register MBean", e);
+                } catch (NotCompliantMBeanException e) {
+                    logger.log(LogService.LOG_ERROR, "MBean is not compliant MBean", e);
+                } catch (MalformedObjectNameException e) {
+                    logger.log(LogService.LOG_ERROR, "Try to register with no valid objectname", e);
+                } catch (NullPointerException e) {
+                    logger.log(LogService.LOG_ERROR, "Name of objectname can't be null", e);
+                }
+            }
+        }
+
+    }
+
+    /**
+     * @see org.apache.aries.jmx.agent.JMXAgent#unregisterMBeans(javax.management.MBeanServer)
+     */
+    public void unregisterMBeans(final MBeanServer server) {
+        for (MBeanHandler mBeanHandler : mbeansHandlers) {
+            try
+            {
+               String name = mBeanHandler.getName();
+               StandardMBean mbean = mBeanHandler.getMbean();
+               if (mbean != null) {
+                   logger.log(LogService.LOG_INFO, "Unregistering " + mbean.getMBeanInterface().getName()
+                         + " to MBeanServer " + server + " with name " + name);
+                   server.unregisterMBean(new ObjectName(name));
+               }
+            } catch (MBeanRegistrationException e) {
+               logger.log(LogService.LOG_ERROR, "Can't unregister MBean", e);
+            } catch (InstanceNotFoundException e) {
+               logger.log(LogService.LOG_ERROR, "Mbena doesn't exist in the repository", e);
+            } catch (MalformedObjectNameException e) {
+               logger.log(LogService.LOG_ERROR, "Try to unregister with no valid objectname", e);
+            } catch (NullPointerException e) {
+               logger.log(LogService.LOG_ERROR, "Name of objectname can't be null ", e);
+            } catch (Exception e) {
+               logger.log(LogService.LOG_ERROR, "Cannot unregister MBean: " + mBeanHandler, e);
+            }
+        }
+    }
+
+    /**
+     * @see org.apache.aries.jmx.agent.JMXAgent#registerMBean(org.apache.aries.jmx.MBeanHandler)
+     */
+    public void registerMBean(final MBeanHandler mBeanHandler) {
+        Object[] servers = getMBeanServers();
+        if (servers == null) {
+            logger.log(LogService.LOG_WARNING, "There are no MBean servers registred, can't register MBeans");
+            return;
+        }
+
+        for (Object server : servers) {
+            String name = mBeanHandler.getName();
+            StandardMBean mbean = mBeanHandler.getMbean();
+            try {
+                logger.log(LogService.LOG_INFO, "Registering " + mbean.getMBeanInterface().getName()
+                        + " to MBeanServer " + server + " with name " + name);
+                ((MBeanServer) server).registerMBean(mbean, new ObjectName(name));
+
+            } catch (InstanceAlreadyExistsException e) {
+                logger.log(LogService.LOG_ERROR, "MBean is already registered", e);
+            } catch (MBeanRegistrationException e) {
+                logger.log(LogService.LOG_ERROR, "Can't register MBean", e);
+            } catch (NotCompliantMBeanException e) {
+                logger.log(LogService.LOG_ERROR, "MBean is not compliant MBean, Stopping registration", e);
+                return;
+            } catch (MalformedObjectNameException e) {
+                logger.log(LogService.LOG_ERROR, "Try to register with no valid objectname, Stopping registration", e);
+                return;
+            } catch (NullPointerException e) {
+                logger.log(LogService.LOG_ERROR, "Name of objectname can't be null, Stopping registration", e);
+                return;
+            }
+        }
+
+    }
+
+    /**
+     * @see org.apache.aries.jmx.agent.JMXAgent#unregisterMBean(java.lang.String)
+     */
+    public void unregisterMBean(final String name) {
+        Object[] servers = getMBeanServers();
+        for (Object server : servers) {
+
+            try {
+                logger.log(LogService.LOG_INFO, "Unregistering mbean " + " to MBeanServer " + server + " with name "
+                        + name);
+                ((MBeanServer) server).unregisterMBean(new ObjectName(name));
+            } catch (MBeanRegistrationException e) {
+                logger.log(LogService.LOG_ERROR, "Can't register MBean", e);
+            } catch (InstanceNotFoundException e) {
+                logger.log(LogService.LOG_ERROR, "Mbena doesn't exist in the repository", e);
+            } catch (MalformedObjectNameException e) {
+                logger.log(LogService.LOG_ERROR, "Try to register with no valid objectname, Stopping registration", e);
+                return;
+            } catch (NullPointerException e) {
+                logger.log(LogService.LOG_ERROR, "Name of objectname can't be null, Stopping registration", e);
+                return;
+            }
+
+        }
+    }
+
+    /**
+     * @see org.apache.aries.jmx.agent.JMXAgent#stop()
+     */
+    public void stop() {
+        logger.log(LogService.LOG_INFO, "Stopping JMX OSGi agent");
+        mbeanServiceTracker.close();
+        for (MBeanHandler mBeanHandler : mbeansHandlers) {
+            mBeanHandler.close();
+        }
+        if (registrationExecutor != null && !registrationExecutor.isShutdown()) {
+            registrationExecutor.shutdown();
+        }
+    }
+
+    /**
+     * @see org.apache.aries.jmx.agent.JMXAgent#getAgentContext()
+     */
+    public JMXAgentContext getAgentContext() {
+        return agentContext;
+    }
+
+    /**
+     * @see org.apache.aries.jmx.agent.JMXAgent#setAgentContext(org.apache.aries.jmx.agent.JMXAgentContext)
+     */
+    public void setAgentContext(JMXAgentContext agentContext) {
+        this.agentContext = agentContext;
+    }
+
+    /**
+     * Gets all MBeanServers from MBeanServiceTracker.
+     *
+     * @return array of MBean servers.
+     */
+    private Object[] getMBeanServers() {
+        return mbeanServiceTracker.getServices();
+    }
+
+    /**
+     * @see org.apache.aries.jmx.agent.JMXAgent#getRegistrationExecutor()
+     */
+    public ExecutorService getRegistrationExecutor() {
+        return registrationExecutor;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/cm/ConfigurationAdmin.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/cm/ConfigurationAdmin.java
index b56de2e8..0bdee39d 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/cm/ConfigurationAdmin.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/cm/ConfigurationAdmin.java
@@ -1,3 +1,240 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.cm;
+
+import static org.osgi.jmx.JmxConstants.PROPERTIES_TYPE;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Dictionary;
+import java.util.Enumeration;
+import java.util.Hashtable;
+import java.util.List;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularDataSupport;
+
+import org.apache.aries.jmx.codec.PropertyData;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.jmx.service.cm.ConfigurationAdminMBean;
+import org.osgi.service.cm.Configuration;
+
+/**
+ * Implementation of <code>ConfigurationAdminMBean</code> 
+ *
+ * @version $Rev$ $Date$
+ */
+public class ConfigurationAdmin implements ConfigurationAdminMBean {
+
+    private org.osgi.service.cm.ConfigurationAdmin configurationAdmin;
+    
+    /**
+     * Constructs a ConfigurationAdmin implementation
+     * @param configurationAdmin instance of org.osgi.service.cm.ConfigurationAdmin service
+     */
+    public ConfigurationAdmin(org.osgi.service.cm.ConfigurationAdmin configurationAdmin) {
+        this.configurationAdmin = configurationAdmin;
+    }
+    
+    
+    /**
+     * @see org.osgi.jmx.service.cm.ConfigurationAdminMBean#createFactoryConfiguration(java.lang.String)
+     */
+    public String createFactoryConfiguration(String factoryPid) throws IOException {
+        return createFactoryConfigurationForLocation(factoryPid, null); 
+    }
+
+    /**
+     * @see org.osgi.jmx.service.cm.ConfigurationAdminMBean#createFactoryConfigurationForLocation(java.lang.String, java.lang.String)
+     */
+    public String createFactoryConfigurationForLocation(String factoryPid, String location) throws IOException {
+        if (factoryPid == null || factoryPid.length() < 1) {
+            throw new IOException("Argument factoryPid cannot be null or empty");
+        }
+        Configuration config = configurationAdmin.createFactoryConfiguration(factoryPid);
+        config.setBundleLocation(location);
+        return config.getPid();
+    }
+
+    /**
+     * @see org.osgi.jmx.service.cm.ConfigurationAdminMBean#delete(java.lang.String)
+     */
+    public void delete(String pid) throws IOException {
+       deleteForLocation(pid, null);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.cm.ConfigurationAdminMBean#deleteForLocation(java.lang.String, java.lang.String)
+     */
+    public void deleteForLocation(String pid, String location) throws IOException {
+        if (pid == null || pid.length() < 1) {
+            throw new IOException("Argument pid cannot be null or empty");
+        }
+        Configuration config = configurationAdmin.getConfiguration(pid, location);
+        config.delete();
+    }
+
+    /**
+     * @see org.osgi.jmx.service.cm.ConfigurationAdminMBean#deleteConfigurations(java.lang.String)
+     */
+    public void deleteConfigurations(String filter) throws IOException {
+        if (filter == null || filter.length() < 1) {
+            throw new IOException("Argument filter cannot be null or empty");
+        }
+        Configuration[] configuations = null;
+        try {
+            configuations = configurationAdmin.listConfigurations(filter);
+        } catch (InvalidSyntaxException e) {
+            throw new IOException("Invalid filter [" + filter + "] : " + e);
+        }
+        if (configuations != null) {
+            for (Configuration config : configuations) {
+                config.delete();
+            }
+        }
+    }
+
+    /**
+     * @see org.osgi.jmx.service.cm.ConfigurationAdminMBean#getBundleLocation(java.lang.String)
+     */
+    public String getBundleLocation(String pid) throws IOException {
+        if (pid == null || pid.length() < 1) {
+            throw new IOException("Argument pid cannot be null or empty");
+        }
+        Configuration config = configurationAdmin.getConfiguration(pid, null);
+        String bundleLocation = (config.getBundleLocation() == null) ? "Configuration is not yet bound to a bundle location" : config.getBundleLocation();
+        return bundleLocation;
+    }
+
+    /**
+     * @see org.osgi.jmx.service.cm.ConfigurationAdminMBean#getConfigurations(java.lang.String)
+     */
+    public String[][] getConfigurations(String filter) throws IOException {
+        if (filter == null || filter.length() < 1) {
+            throw new IOException("Argument filter cannot be null or empty");
+        }
+        List<String[]> result = new ArrayList<String[]>();
+        Configuration[] configurations = null;
+        try {
+            configurations = configurationAdmin.listConfigurations(filter);
+        } catch (InvalidSyntaxException e) {
+            throw new IOException("Invalid filter [" + filter + "] : " + e);
+        }
+        if (configurations != null) {
+            for (Configuration config : configurations) {
+                result.add(new String[] { config.getPid(), config.getBundleLocation() });
+            }
+        }
+        return result.toArray(new String[result.size()][]);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.cm.ConfigurationAdminMBean#getFactoryPid(java.lang.String)
+     */
+    public String getFactoryPid(String pid) throws IOException {
+       return getFactoryPidForLocation(pid, null);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.cm.ConfigurationAdminMBean#getFactoryPidForLocation(java.lang.String, java.lang.String)
+     */
+    public String getFactoryPidForLocation(String pid, String location) throws IOException {
+        if (pid == null || pid.length() < 1) {
+            throw new IOException("Argument pid cannot be null or empty");
+        }
+        Configuration config = configurationAdmin.getConfiguration(pid, location);
+        return config.getFactoryPid();
+    }
+
+    /**
+     * @see org.osgi.jmx.service.cm.ConfigurationAdminMBean#getProperties(java.lang.String)
+     */
+    public TabularData getProperties(String pid) throws IOException {
+       return getPropertiesForLocation(pid, null);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.cm.ConfigurationAdminMBean#getPropertiesForLocation(java.lang.String, java.lang.String)
+     */
+    @SuppressWarnings("unchecked")
+    public TabularData getPropertiesForLocation(String pid, String location) throws IOException {
+        if (pid == null || pid.length() < 1) {
+            throw new IOException("Argument pid cannot be null or empty");
+        }
+        TabularData propertiesTable = null;
+        Configuration config = configurationAdmin.getConfiguration(pid, location);
+        Dictionary<String, Object> properties = config.getProperties();
+        if (properties != null) {
+            propertiesTable = new TabularDataSupport(PROPERTIES_TYPE);
+            Enumeration<String> keys = properties.keys();
+            while (keys.hasMoreElements()) {
+                String key = keys.nextElement();
+                propertiesTable.put(PropertyData.newInstance(key, properties.get(key)).toCompositeData());
+            }
+        }
+        return propertiesTable;
+    }
+
+    /**
+     * @see org.osgi.jmx.service.cm.ConfigurationAdminMBean#setBundleLocation(java.lang.String, java.lang.String)
+     */
+    public void setBundleLocation(String pid, String location) throws IOException {
+        if (pid == null || pid.length() < 1) {
+            throw new IOException("Argument factoryPid cannot be null or empty");
+        }
+        Configuration config = configurationAdmin.getConfiguration(pid, null);
+        config.setBundleLocation(location);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.cm.ConfigurationAdminMBean#update(java.lang.String, javax.management.openmbean.TabularData)
+     */
+    public void update(String pid, TabularData configurationTable) throws IOException {
+        updateForLocation(pid, null, configurationTable);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.cm.ConfigurationAdminMBean#updateForLocation(java.lang.String, java.lang.String, javax.management.openmbean.TabularData)
+     */
+    @SuppressWarnings("unchecked")
+    public void updateForLocation(String pid, String location, TabularData configurationTable) throws IOException {
+        if (pid == null || pid.length() < 1) {
+            throw new IOException("Argument pid cannot be null or empty");
+        }
+        if (configurationTable == null) {
+            throw new IOException("Argument configurationTable cannot be null");
+        }
+                
+        if (!PROPERTIES_TYPE.equals(configurationTable.getTabularType())) {
+            throw new IOException("Invalid TabularType ["  + configurationTable.getTabularType() + "]");
+        }
+        Dictionary<String, Object> configurationProperties = new Hashtable<String, Object>();
+        Collection<CompositeData> compositeData = (Collection<CompositeData>) configurationTable.values();
+        for (CompositeData row: compositeData) {
+            PropertyData<? extends Class> propertyData = PropertyData.from(row);
+            configurationProperties.put(propertyData.getKey(), propertyData.getValue());
+        }
+        Configuration config = configurationAdmin.getConfiguration(pid, location);
+        config.update(configurationProperties);
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanHandler.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanHandler.java
index 56d8ebfd..e622cebf 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanHandler.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanHandler.java
@@ -1,2 +1,76 @@
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.cm;
+
+import javax.management.NotCompliantMBeanException;
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.AbstractCompendiumHandler;
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.MBeanHandler;
+import org.apache.aries.jmx.agent.JMXAgentContext;
+import org.osgi.jmx.service.cm.ConfigurationAdminMBean;
+import org.osgi.service.log.LogService;
+
+/**
+ * <p>
+ * Implementation of <code>MBeanHandler</code> which manages the <code>ConfigurationAdminMBean</code> implementation
+ * 
+ * @see MBeanHandler </p>
+ * 
+ * @version $Rev$ $Date$
+ */
+public class ConfigurationAdminMBeanHandler extends AbstractCompendiumHandler {
+
+    /**
+     * Constructs new ConfigurationAdminMBeanHandler instance
+     * 
+     * @param agentContext
+     *            JMXAgentContext instance
+     */
+    public ConfigurationAdminMBeanHandler(JMXAgentContext agentContext) {
+        super(agentContext, "org.osgi.service.cm.ConfigurationAdmin");
+    }
+
+    /**
+     * @see org.apache.aries.jmx.AbstractCompendiumHandler#constructInjectMBean(java.lang.Object)
+     */
+    @Override
+    protected StandardMBean constructInjectMBean(Object targetService) {
+        ConfigurationAdminMBean caMBean = new org.apache.aries.jmx.cm.ConfigurationAdmin(
+                (org.osgi.service.cm.ConfigurationAdmin) targetService);
+        StandardMBean mbean = null;
+        try {
+            mbean = new StandardMBean(caMBean, ConfigurationAdminMBean.class);
+        } catch (NotCompliantMBeanException e) {
+            Logger logger = agentContext.getLogger();
+            logger.log(LogService.LOG_ERROR, "Failed to instantiate MBean for "
+                    + ConfigurationAdminMBean.class.getName(), e);
+        }
+        return mbean;
+    }
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#getName()
+     */
+    public String getName() {
+        return ConfigurationAdminMBean.OBJECTNAME;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/AuthorizationData.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/AuthorizationData.java
index b56de2e8..f3142d68 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/AuthorizationData.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/AuthorizationData.java
@@ -1,3 +1,117 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.osgi.jmx.service.useradmin.UserAdminMBean;
+import org.osgi.service.useradmin.Authorization;
+
+/**
+ * <p>
+ * <tt>AuthorizationData</tt> represents Authorization Type @see {@link UserAdminMBean#AUTORIZATION_TYPE}.It is a codec
+ * for the <code>CompositeData</code> representing an Authorization .
+ * </p>
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class AuthorizationData {
+    
+    /**
+     * authorization context name.
+     */
+    private String name;
+    /**
+     * roles implied by authorization context.
+     */
+    private String[] roles;
+    
+    /**
+     * Constructs new AuthorizationData from Authorization. 
+     * @param auth {@link Authorization} instance.
+     */
+    public AuthorizationData(Authorization auth){
+        this.name = auth.getName();
+        this.roles = auth.getRoles();
+    }
+    
+    /**
+     * Constructs new AuthorizationData.
+     * 
+     * @param name of authorization context.
+     * @param roles implied by authorization context.
+     */
+    public AuthorizationData(String name, String[] roles){
+        this.name = name;
+        this.roles = roles;
+    }
+    /**
+     * Translates AuthorizationData to CompositeData represented by
+     * compositeType {@link UserAdminMBean#AUTORIZATION_TYPE}.
+     * 
+     * @return translated AuthorizationData to compositeData.
+     */
+    public CompositeData toCompositeData() {
+        try {
+            Map<String, Object> items = new HashMap<String, Object>();
+            items.put(UserAdminMBean.NAME, name);
+            items.put(UserAdminMBean.ROLES, roles);
+            return new CompositeDataSupport(UserAdminMBean.AUTORIZATION_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new IllegalStateException("Can't create CompositeData" + e);
+        }
+    }
+
+    /**
+     * Static factory method to create AuthorizationData from CompositeData object.
+     * 
+     * @param data {@link CompositeData} instance.
+     * @return AuthorizationData instance.
+     */
+    public static AuthorizationData from(CompositeData data) {
+        if(data == null){
+            return null;
+        }
+        String name = (String) data.get(UserAdminMBean.NAME);
+        String[] roles = (String[]) data.get(UserAdminMBean.ROLES);
+        return new AuthorizationData(name, roles);
+    }
+
+    /**
+     * @return the name
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * @return the roles
+     */
+    public String[] getRoles() {
+        return roles;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BatchActionResult.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BatchActionResult.java
index b56de2e8..fbe658a1 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BatchActionResult.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BatchActionResult.java
@@ -1,3 +1,167 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.osgi.jmx.framework.FrameworkMBean;
+
+/**
+ * <p>
+ * <tt>BatchInstallResult</tt> represents codec for resulting CompositeData of batch operations
+ * made on bundle via FrameworkMBean.
+ * It's converting batch install results to CompositeData {@link #toCompositeData()}
+ * and from CompositeData to this BatchActionResult {@link #from(CompositeData)}.
+ * It provides also constructors to build BatchActionResult.  
+ * Structure of compositeData is as defined in compositeType @see {@link FrameworkMBean#BATCH_ACTION_RESULT_TYPE}.
+ * </p>
+ * @see BatchResult
+ *
+ * @version $Rev$ $Date$
+ */
+public class BatchActionResult extends BatchResult{
+
+    /**
+     * @see FrameworkMBean#REMAINING_ID_ITEM
+     * @see FrameworkMBean#REMAINING_LOCATION_ITEM
+     */
+	private long[] remainingItems;
+	/**
+	 * @see FrameworkMBean#BUNDLE_IN_ERROR_ID_ITEM
+	 * @see FrameworkMBean#BUNDLE_IN_ERROR
+	 */
+	private long bundleInError;
+
+	/**
+	 * Constructs new BatchActionResult with completedItems array.
+     * Newly created object represents successful batch result.
+     * @param completedItems containing the list of bundles completing the batch operation.
+	 */
+	public BatchActionResult(long[] completedItems){
+		this.completed = completedItems;
+		success = true;
+	}
+	
+	 /**
+     * Constructs new BatchActionResult with error message.
+     * Newly created object represents failed batch result.
+     * @param error containing the error message of the batch operation.
+     */
+    public BatchActionResult(String error){
+        this.error = error;
+        success = false;
+    }
+	
+	/**
+	 * Constructs new BatchActionResult.
+     * Newly created object represents failed batch result.
+     * 
+     * @param completedItems containing the list of bundles completing the batch operation.
+     * @param error containing the error message of the batch operation.
+     * @param remainingItems remaining bundles unprocessed by the
+     * failing batch operation.
+     * @param bundleInError containing the bundle which caused the error during the batch
+     * operation.
+	 */
+	public BatchActionResult(long[] completedItems, String error, long[] remainingItems, long bundleInError){
+		this(completedItems,error,remainingItems,false,bundleInError);
+	}
+	
+	/**
+	 * Constructs new BatchActionResult.
+     * 
+     * @param completedItems containing the list of bundles completing the batch operation.
+     * @param error containing the error message of the batch operation.
+     * @param remainingItems remaining bundles unprocessed by the
+     * failing batch operation.
+     * @param success indicates if this operation was successful.
+     * @param bundleInError containing the bundle which caused the error during the batch
+     * operation.
+	 */
+	public BatchActionResult(long[] completedItems, String error, long[] remainingItems, boolean success, long bundleInError){
+		this.bundleInError = bundleInError;
+		this.completed = completedItems;
+		this.error = error;
+		this.remainingItems = remainingItems;
+		this.success = success;
+	}
+	
+	/**
+	 * Translates BatchActionResult to CompositeData represented by
+     * compositeType {@link FrameworkMBean#BATCH_ACTION_RESULT_TYPE}.
+     * 
+	 * @return translated BatchActionResult  to compositeData.
+	 */
+	public CompositeData toCompositeData(){
+		try {
+			Map<String, Object> items = new HashMap<String, Object>();
+			items.put(FrameworkMBean.BUNDLE_IN_ERROR, bundleInError);
+			items.put(FrameworkMBean.COMPLETED, toLongArray(completed));
+			items.put(FrameworkMBean.ERROR, error);
+			items.put(FrameworkMBean.REMAINING, toLongArray(remainingItems));
+			items.put(FrameworkMBean.SUCCESS, success);
+			return new CompositeDataSupport(FrameworkMBean.BATCH_ACTION_RESULT_TYPE, items);
+		} catch (OpenDataException e) {
+			throw new IllegalStateException("Can't create CompositeData" + e);
+		}
+	}
+	
+	/**
+	 * Static factory method to create BatchActionResult from CompositeData object.
+	 * 
+	 * @param data {@link CompositeData} instance.
+	 * @return BatchActionResult instance.
+	 */
+	public static BatchActionResult from(CompositeData data){
+	    if(data == null){
+	        return null;
+	    }
+		long bundleInError = (Long) data.get(FrameworkMBean.BUNDLE_IN_ERROR);
+		// need to convert primitive array to wrapper type array
+		// compositeData accept only wrapper type array
+		long[] completedItems = toLongPrimitiveArray((Long[])data.get(FrameworkMBean.COMPLETED));
+		long[] remainingItems = toLongPrimitiveArray((Long[]) data.get(FrameworkMBean.REMAINING));
+		String error = (String) data.get(FrameworkMBean.ERROR);
+		Boolean success = (Boolean) data.get(FrameworkMBean.SUCCESS);
+		return new BatchActionResult(completedItems, error, remainingItems, success, bundleInError);
+	}
+
+	/**
+	 * Gets remaining items id's.
+	 * @return the remainingItems.
+	 */
+	public long[] getRemainingItems() {
+		return remainingItems;
+	}
+
+	/**
+	 * Gets bundle in error id.
+	 * @return the bundleInError.
+	 */
+	public long getBundleInError() {
+		return bundleInError;
+	}
+	
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BatchInstallResult.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BatchInstallResult.java
index b56de2e8..0c26f442 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BatchInstallResult.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BatchInstallResult.java
@@ -1,3 +1,166 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.osgi.jmx.framework.FrameworkMBean;
+
+/**
+ * <p>
+ * <tt>BatchInstallResult</tt> represents codec for resulting CompositeData of
+ * FrameworkMBean installBundles methods.
+ * It converting batch install results to CompositeData {@link #toCompositeData()}
+ * and from CompositeData to this BatchInstallResult {@link #from(CompositeData)}.
+ * It provides also constructors to build BatchInstallResult.  
+ * Structure of compositeData as defined in compositeType @see {@link FrameworkMBean#BATCH_INSTALL_RESULT_TYPE}.
+ * </p>
+ * @see BatchResult
+ *
+ * @version $Rev$ $Date$
+ */
+public class BatchInstallResult extends BatchResult {
+
+    /**
+     * @see FrameworkMBean#REMAINING_LOCATION_ITEM
+     * @see FrameworkMBean#REMAINING
+     */
+    private String[] remainingLocationItems;
+    
+    /**
+     * @see FrameworkMBean#BUNDLE_IN_ERROR_LOCATION_ITEM
+     * @see FrameworkMBean#BUNDLE_IN_ERROR
+     */
+    private String bundleInError;
+
+    /**
+     * Constructs new BatchInstallResult with completedItems array.
+     * Newly created object represents successful batch result.
+     * @param completedItems containing the list of bundles completing the batch operation.
+     */
+    public BatchInstallResult(long[] completedItems) {
+        this.completed = completedItems;
+        success = true;
+    }
+
+    /**
+     * Constructs new BatchInstallResult with error message.
+     * Newly created object represents failed batch result.
+     * @param error containing the error message of the batch operation.
+     */
+    public BatchInstallResult(String error){
+        this.error = error;
+        success = false;
+    }
+    /**
+     * Constructs new BatchInstallResult.
+     * Newly created object represents failed batch result.
+     * 
+     * @param completedItems containing the list of bundles completing the batch operation.
+     * @param error containing the error message of the batch operation.
+     * @param remainingLocationItems remaining bundles unprocessed by the
+     * failing batch operation.
+     * @param bundleInError containing the bundle which caused the error during the batch
+     * operation.
+     */
+    public BatchInstallResult(long[] completedItems, String error, String[] remainingLocationItems, String bundleInError) {
+        this(completedItems, error, remainingLocationItems, false, bundleInError);
+    }
+
+    /**
+     * Constructs new BatchInstallResult.
+     * 
+     * @param completedItems containing the list of bundles completing the batch operation.
+     * @param error containing the error message of the batch operation.
+     * @param remainingLocationItems remaining bundles unprocessed by the
+     * failing batch operation.
+     * @param success indicates if this operation was successful.
+     * @param bundleInError containing the bundle which caused the error during the batch
+     * operation.
+     */
+    public BatchInstallResult(long[] completedItems, String error, String[] remainingLocationItems, boolean success,
+            String bundleInError) {
+        this.bundleInError = bundleInError;
+        this.completed = completedItems;
+        this.error = error;
+        this.remainingLocationItems = remainingLocationItems;
+        this.success = success;
+    }
+
+    /**
+     * Translates BatchInstallResult to CompositeData represented by
+     * compositeType {@link FrameworkMBean#BATCH_INSTALL_RESULT_TYPE}.
+     * 
+     * @return translated BatchInstallResult to compositeData.
+     */
+    public CompositeData toCompositeData() {
+        try {
+            Map<String, Object> items = new HashMap<String, Object>();
+            items.put(FrameworkMBean.BUNDLE_IN_ERROR, bundleInError);
+            items.put(FrameworkMBean.COMPLETED, toLongArray(completed));
+            items.put(FrameworkMBean.ERROR, error);
+            items.put(FrameworkMBean.REMAINING, remainingLocationItems);
+            items.put(FrameworkMBean.SUCCESS, success);
+            return new CompositeDataSupport(FrameworkMBean.BATCH_INSTALL_RESULT_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new IllegalStateException("Can't create CompositeData" + e);
+        }
+    }
+
+    /**
+     * Static factory method to create BatchInstallResult from CompositeData object.
+     * 
+     * @param data {@link CompositeData} instance.
+     * @return BatchInstallResult instance.
+     */
+    public static BatchInstallResult from(CompositeData data) {
+        if(data == null){
+            return null;
+        }
+        String bundleInError = (String) data.get(FrameworkMBean.BUNDLE_IN_ERROR);
+        long[] completedItems = toLongPrimitiveArray((Long[]) data.get(FrameworkMBean.COMPLETED));
+        String[] remainingLocationItems = (String[]) data.get(FrameworkMBean.REMAINING);
+        String error = (String) data.get(FrameworkMBean.ERROR);
+        boolean success = (Boolean) data.get(FrameworkMBean.SUCCESS);
+        return new BatchInstallResult(completedItems, error, remainingLocationItems, success, bundleInError);
+    }
+
+    /**
+     * Gets remaining location items.
+     * @return array of String with locations.
+     */
+    public String[] getRemainingLocationItems() {
+        return remainingLocationItems;
+    }
+
+    /**
+     * Gets bundle in error location.
+     * @return the bundleInError.
+     */
+    public String getBundleInError() {
+        return bundleInError;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BatchResult.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BatchResult.java
index b56de2e8..165189db 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BatchResult.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BatchResult.java
@@ -1,3 +1,116 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import org.osgi.jmx.framework.FrameworkMBean;
+
+/**
+ * <p>
+ * <tt>BatchResult</tt> represents abstract class for BatchResults.
+ * It contains common data structure of batch result:
+ * <ul>
+ * <li>completed containing the list of bundles completing the batch operation.</li>
+ * <li>error containing the error message of the batch operation.</li>
+ * <li>success indicates if this operation was successful.</li>
+ * </ul>
+ * </p>
+ * 
+ * 
+ * @version $Rev$ $Date$
+ */
+public abstract class BatchResult {
+
+    /**
+     * @see FrameworkMBean#COMPLETED_ITEM
+     * @see FrameworkMBean#COMPLETED
+     */
+    protected long[] completed;
+    /**
+     * @see FrameworkMBean#ERROR_ITEM
+     * @see FrameworkMBean#ERROR
+     */
+    protected String error;
+    /**
+     * @see FrameworkMBean#SUCCESS_ITEM
+     * @see FrameworkMBean#SUCCESS
+     */
+    protected boolean success;
+
+    /**
+     * Gets completed item id's.
+     * @return completed items id's.
+     */
+    public long[] getCompleted() {
+        return completed;
+    }
+
+    /**
+     * Gets error message.
+     * @return error message.
+     */
+    public String getError() {
+        return error;
+    }
+
+    /**
+     * Gets success value.
+     * @return true if success false if not.
+     */
+    public boolean isSuccess() {
+        return success;
+    }
+    
+    /**
+     * Converts primitive array of strings to Long array.
+     * 
+     * @param primitiveArray primitive long array.
+     * @return Long array.
+     */
+    protected Long[] toLongArray(long[] primitiveArray) {
+        if (primitiveArray == null) {
+            return null;
+        }
+        Long[] converted = new Long[primitiveArray.length];
+        for (int i = 0; i < primitiveArray.length; i++) {
+            converted[i] = primitiveArray[i];
+        }
+
+        return converted;
+    }
+
+    /**
+     * Converts Long array to primitive array of long.
+     * 
+     * @param wrapperArray Long array.
+     * @return primitive long array.
+     */
+    protected static long[] toLongPrimitiveArray(Long[] wrapperArray) {
+        if (wrapperArray == null) {
+            return null;
+        }
+        long[] converted = new long[wrapperArray.length];
+        for (int i = 0; i < wrapperArray.length; i++) {
+            converted[i] = wrapperArray[i];
+        }
+
+        return converted;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BundleData.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BundleData.java
index b56de2e8..b904f08f 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BundleData.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BundleData.java
@@ -1,3 +1,496 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import static org.apache.aries.jmx.util.FrameworkUtils.getBundleDependencies;
+import static org.apache.aries.jmx.util.FrameworkUtils.getBundleExportedPackages;
+import static org.apache.aries.jmx.util.FrameworkUtils.getBundleImportedPackages;
+import static org.apache.aries.jmx.util.FrameworkUtils.getBundleState;
+import static org.apache.aries.jmx.util.FrameworkUtils.getDependentBundles;
+import static org.apache.aries.jmx.util.FrameworkUtils.getFragmentIds;
+import static org.apache.aries.jmx.util.FrameworkUtils.getHostIds;
+import static org.apache.aries.jmx.util.FrameworkUtils.getRegisteredServiceIds;
+import static org.apache.aries.jmx.util.FrameworkUtils.getServicesInUseByBundle;
+import static org.apache.aries.jmx.util.FrameworkUtils.isBundlePendingRemoval;
+import static org.apache.aries.jmx.util.FrameworkUtils.isBundleRequiredByOthers;
+import static org.apache.aries.jmx.util.TypeUtils.toLong;
+import static org.apache.aries.jmx.util.TypeUtils.toPrimitive;
+import static org.osgi.jmx.framework.BundleStateMBean.BUNDLE_TYPE;
+import static org.osgi.jmx.framework.BundleStateMBean.EXPORTED_PACKAGES;
+import static org.osgi.jmx.framework.BundleStateMBean.FRAGMENT;
+import static org.osgi.jmx.framework.BundleStateMBean.FRAGMENTS;
+import static org.osgi.jmx.framework.BundleStateMBean.HEADERS;
+import static org.osgi.jmx.framework.BundleStateMBean.HEADERS_TYPE;
+import static org.osgi.jmx.framework.BundleStateMBean.HEADER_TYPE;
+import static org.osgi.jmx.framework.BundleStateMBean.HOSTS;
+import static org.osgi.jmx.framework.BundleStateMBean.IDENTIFIER;
+import static org.osgi.jmx.framework.BundleStateMBean.IMPORTED_PACKAGES;
+import static org.osgi.jmx.framework.BundleStateMBean.KEY;
+import static org.osgi.jmx.framework.BundleStateMBean.LAST_MODIFIED;
+import static org.osgi.jmx.framework.BundleStateMBean.LOCATION;
+import static org.osgi.jmx.framework.BundleStateMBean.PERSISTENTLY_STARTED;
+import static org.osgi.jmx.framework.BundleStateMBean.REGISTERED_SERVICES;
+import static org.osgi.jmx.framework.BundleStateMBean.REMOVAL_PENDING;
+import static org.osgi.jmx.framework.BundleStateMBean.REQUIRED;
+import static org.osgi.jmx.framework.BundleStateMBean.REQUIRED_BUNDLES;
+import static org.osgi.jmx.framework.BundleStateMBean.REQUIRING_BUNDLES;
+import static org.osgi.jmx.framework.BundleStateMBean.SERVICES_IN_USE;
+import static org.osgi.jmx.framework.BundleStateMBean.START_LEVEL;
+import static org.osgi.jmx.framework.BundleStateMBean.STATE;
+import static org.osgi.jmx.framework.BundleStateMBean.SYMBOLIC_NAME;
+import static org.osgi.jmx.framework.BundleStateMBean.VALUE;
+import static org.osgi.jmx.framework.BundleStateMBean.VERSION;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Dictionary;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.management.JMRuntimeException;
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularDataSupport;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.jmx.framework.BundleStateMBean;
+import org.osgi.service.packageadmin.PackageAdmin;
+import org.osgi.service.startlevel.StartLevel;
+
+/**
+ * <p>
+ * <tt>BundleData</tt> represents BundleData Type @see {@link BundleStateMBean#BUNDLE_TYPE}. It is a codec for the
+ * <code>CompositeData</code> representing an OSGi BundleData.
+ * </p>
+ *
+ * @version $Rev$ $Date$
+ */
+public class BundleData {
+
+    /**
+     * @see BundleStateMBean#EXPORTED_PACKAGES_ITEM
+     */
+    private String[] exportedPackages;
+
+    /**
+     * @see BundleStateMBean#FRAGMENT_ITEM
+     */
+    private boolean fragment;
+
+    /**
+     * @see BundleStateMBean#FRAGMENTS_ITEM
+     */
+    private long[] fragments;
+
+    /**
+     * @see BundleStateMBean#HEADER_TYPE
+     */
+    private List<Header> headers = new ArrayList<Header>();
+
+    /**
+     * @see BundleStateMBean#HOSTS_ITEM
+     */
+    private long[] hosts;
+
+    /**
+     * @see BundleStateMBean#IDENTIFIER_ITEM
+     */
+    private long identifier;
+
+    /**
+     * @see BundleStateMBean#IMPORTED_PACKAGES_ITEM
+     */
+    private String[] importedPackages;
+
+    /**
+     * @see BundleStateMBean#LAST_MODIFIED_ITEM
+     */
+    private long lastModified;
+
+    /**
+     * @see BundleStateMBean#LOCATION_ITEM
+     */
+    private String location;
+
+    /**
+     * @see BundleStateMBean#PERSISTENTLY_STARTED_ITEM
+     */
+    private boolean persistentlyStarted;
+
+    /**
+     * @see BundleStateMBean#REGISTERED_SERVICES_ITEM
+     */
+    private long[] registeredServices;
+
+    /**
+     * @see BundleStateMBean#REMOVAL_PENDING_ITEM
+     */
+    private boolean removalPending;
+
+    /**
+     * @see BundleStateMBean#REQUIRED_ITEM
+     */
+    private boolean required;
+
+    /**
+     * @see BundleStateMBean#REQUIRED_BUNDLES_ITEM
+     */
+    private long[] requiredBundles;
+
+    /**
+     * @see BundleStateMBean#REQUIRING_BUNDLES_ITEM
+     */
+    private long[] requiringBundles;
+
+    /**
+     * @see BundleStateMBean#SERVICES_IN_USE_ITEM
+     */
+    private long[] servicesInUse;
+
+    /**
+     * @see BundleStateMBean#START_LEVEL_ITEM
+     */
+    private int bundleStartLevel;
+
+    /**
+     * @see BundleStateMBean#STATE_ITEM
+     */
+    private String state;
+
+    /**
+     * @see BundleStateMBean#SYMBOLIC_NAME_ITEM
+     */
+    private String symbolicName;
+
+    /**
+     * @see BundleStateMBean#VERSION_ITEM
+     */
+    private String version;
+
+    private BundleData() {
+        super();
+    }
+
+    @SuppressWarnings("unchecked")
+    public BundleData(BundleContext localBundleContext, Bundle bundle, PackageAdmin packageAdmin, StartLevel startLevel) {
+        if (bundle == null) {
+            throw new IllegalArgumentException("Argument bundle cannot be null");
+        }
+        if (packageAdmin == null || startLevel == null) {
+            throw new IllegalArgumentException("Arguments PackageAdmin / startLevel cannot be null");
+        }
+        this.exportedPackages = getBundleExportedPackages(bundle, packageAdmin);
+        this.fragment = (PackageAdmin.BUNDLE_TYPE_FRAGMENT == packageAdmin.getBundleType(bundle));
+        this.fragments = getFragmentIds(bundle, packageAdmin);
+        Dictionary<String, String> bundleHeaders = bundle.getHeaders();
+        Enumeration<String> keys = bundleHeaders.keys();
+        while (keys.hasMoreElements()) {
+            String key = keys.nextElement();
+            headers.add(new Header(key, bundleHeaders.get(key)));
+        }
+        this.hosts = getHostIds(bundle, packageAdmin);
+        this.identifier = bundle.getBundleId();
+        this.importedPackages = getBundleImportedPackages(localBundleContext, bundle, packageAdmin);
+        this.lastModified = bundle.getLastModified();
+        this.location = bundle.getLocation();
+        this.persistentlyStarted = startLevel.isBundlePersistentlyStarted(bundle);
+        this.registeredServices = getRegisteredServiceIds(bundle);
+        this.removalPending = isBundlePendingRemoval(bundle, packageAdmin);
+        this.required = isBundleRequiredByOthers(bundle, packageAdmin);
+        this.requiredBundles = getBundleDependencies(localBundleContext, bundle, packageAdmin);
+        this.requiringBundles = getDependentBundles(bundle, packageAdmin);
+        this.servicesInUse = getServicesInUseByBundle(bundle);
+        this.bundleStartLevel = startLevel.getBundleStartLevel(bundle);
+        this.state = getBundleState(bundle);
+        this.symbolicName = bundle.getSymbolicName();
+        this.version = bundle.getVersion().toString();
+    }
+
+    /**
+     * Returns CompositeData representing a BundleData complete state typed by {@link BundleStateMBean#BUNDLE_TYPE}
+     *
+     * @return
+     */
+    public CompositeData toCompositeData() {
+        return toCompositeData(BundleStateMBean.BUNDLE_TYPE.keySet());
+    }
+
+    public CompositeData toCompositeData(Collection<String> itemNames) {
+        Map<String, Object> items = new HashMap<String, Object>();
+        items.put(IDENTIFIER, this.identifier);
+
+        if (itemNames.contains(EXPORTED_PACKAGES))
+            items.put(EXPORTED_PACKAGES, this.exportedPackages);
+
+        if (itemNames.contains(FRAGMENT))
+            items.put(FRAGMENT, this.fragment);
+
+        if (itemNames.contains(FRAGMENTS))
+            items.put(FRAGMENTS, toLong(this.fragments));
+
+        if (itemNames.contains(HOSTS))
+            items.put(HOSTS, toLong(this.hosts));
+
+        if (itemNames.contains(IMPORTED_PACKAGES))
+            items.put(IMPORTED_PACKAGES, this.importedPackages);
+
+        if (itemNames.contains(LAST_MODIFIED))
+            items.put(LAST_MODIFIED, this.lastModified);
+
+        if (itemNames.contains(LOCATION))
+            items.put(LOCATION, this.location);
+
+        if (itemNames.contains(PERSISTENTLY_STARTED))
+            items.put(PERSISTENTLY_STARTED, this.persistentlyStarted);
+
+        if (itemNames.contains(REGISTERED_SERVICES))
+            items.put(REGISTERED_SERVICES, toLong(this.registeredServices));
+
+        if (itemNames.contains(REMOVAL_PENDING))
+            items.put(REMOVAL_PENDING, this.removalPending);
+
+        if (itemNames.contains(REQUIRED))
+            items.put(REQUIRED, this.required);
+
+        if (itemNames.contains(REQUIRED_BUNDLES))
+            items.put(REQUIRED_BUNDLES, toLong(this.requiredBundles));
+
+        if (itemNames.contains(REQUIRING_BUNDLES))
+            items.put(REQUIRING_BUNDLES, toLong(this.requiringBundles));
+
+        if (itemNames.contains(SERVICES_IN_USE))
+            items.put(SERVICES_IN_USE, toLong(this.servicesInUse));
+
+        if (itemNames.contains(START_LEVEL))
+            items.put(START_LEVEL, this.bundleStartLevel);
+
+        if (itemNames.contains(STATE))
+            items.put(STATE, this.state);
+
+        if (itemNames.contains(SYMBOLIC_NAME))
+            items.put(SYMBOLIC_NAME, this.symbolicName);
+
+        if (itemNames.contains(VERSION))
+            items.put(VERSION, this.version);
+
+        if (itemNames.contains(HEADERS)) {
+            TabularData headerTable = new TabularDataSupport(HEADERS_TYPE);
+            for (Header header : this.headers) {
+                headerTable.put(header.toCompositeData());
+            }
+            items.put(HEADERS, headerTable);
+        }
+
+        String[] allItemNames = BUNDLE_TYPE.keySet().toArray(new String [] {});
+        Object[] itemValues = new Object[allItemNames.length];
+        for (int i=0; i < allItemNames.length; i++) {
+            itemValues[i] = items.get(allItemNames[i]);
+        }
+
+        try {
+            return new CompositeDataSupport(BUNDLE_TYPE, allItemNames, itemValues);
+        } catch (OpenDataException e) {
+            throw new IllegalStateException("Failed to create CompositeData for BundleData [" + this.identifier
+                    + "]", e);
+        }
+    }
+
+    /**
+     * Constructs a <code>BundleData</code> object from the given <code>CompositeData</code>
+     *
+     * @param compositeData
+     * @return
+     * @throws IlleglArgumentException
+     *             if compositeData is null or not of type {@link BundleStateMBean#BUNDLE_TYPE}
+     */
+    @SuppressWarnings("unchecked")
+    public static BundleData from(CompositeData compositeData) throws IllegalArgumentException {
+        if (compositeData == null) {
+            throw new IllegalArgumentException("Argument compositeData cannot be null");
+        }
+        if (!compositeData.getCompositeType().equals(BUNDLE_TYPE)) {
+            throw new IllegalArgumentException("Invalid CompositeType [" + compositeData.getCompositeType() + "]");
+        }
+        BundleData bundleData = new BundleData();
+        bundleData.exportedPackages = (String[]) compositeData.get(EXPORTED_PACKAGES);
+        bundleData.fragment = (Boolean) compositeData.get(FRAGMENT);
+        bundleData.fragments = toPrimitive((Long[]) compositeData.get(FRAGMENTS));
+        bundleData.hosts = toPrimitive((Long[]) compositeData.get(HOSTS));
+        bundleData.identifier = (Long) compositeData.get(IDENTIFIER);
+        bundleData.importedPackages = (String[]) compositeData.get(IMPORTED_PACKAGES);
+        bundleData.lastModified = (Long) compositeData.get(LAST_MODIFIED);
+        bundleData.location = (String) compositeData.get(LOCATION);
+        bundleData.persistentlyStarted = (Boolean) compositeData.get(PERSISTENTLY_STARTED);
+        bundleData.registeredServices = toPrimitive((Long[]) compositeData.get(REGISTERED_SERVICES));
+        bundleData.removalPending = (Boolean) compositeData.get(REMOVAL_PENDING);
+        bundleData.required = (Boolean) compositeData.get(REQUIRED);
+        bundleData.requiredBundles = toPrimitive((Long[]) compositeData.get(REQUIRED_BUNDLES));
+        bundleData.requiringBundles = toPrimitive((Long[]) compositeData.get(REQUIRING_BUNDLES));
+        bundleData.servicesInUse = toPrimitive((Long[]) compositeData.get(SERVICES_IN_USE));
+        bundleData.bundleStartLevel = (Integer) compositeData.get(START_LEVEL);
+        bundleData.state = (String) compositeData.get(STATE);
+        bundleData.symbolicName = (String) compositeData.get(SYMBOLIC_NAME);
+        bundleData.version = (String) compositeData.get(VERSION);
+        TabularData headerTable = (TabularData) compositeData.get(HEADERS);
+        Collection<CompositeData> headerData = (Collection<CompositeData>) headerTable.values();
+        for (CompositeData headerRow : headerData) {
+            bundleData.headers.add(Header.from(headerRow));
+        }
+        return bundleData;
+    }
+
+    public String[] getExportedPackages() {
+        return exportedPackages;
+    }
+
+    public boolean isFragment() {
+        return fragment;
+    }
+
+    public long[] getFragments() {
+        return fragments;
+    }
+
+    public List<Header> getHeaders() {
+        return headers;
+    }
+
+    public long[] getHosts() {
+        return hosts;
+    }
+
+    public long getIdentifier() {
+        return identifier;
+    }
+
+    public String[] getImportedPackages() {
+        return importedPackages;
+    }
+
+    public long getLastModified() {
+        return lastModified;
+    }
+
+    public String getLocation() {
+        return location;
+    }
+
+    public boolean isPersistentlyStarted() {
+        return persistentlyStarted;
+    }
+
+    public long[] getRegisteredServices() {
+        return registeredServices;
+    }
+
+    public boolean isRemovalPending() {
+        return removalPending;
+    }
+
+    public boolean isRequired() {
+        return required;
+    }
+
+    public long[] getRequiredBundles() {
+        return requiredBundles;
+    }
+
+    public long[] getRequiringBundles() {
+        return requiringBundles;
+    }
+
+    public long[] getServicesInUse() {
+        return servicesInUse;
+    }
+
+    public int getBundleStartLevel() {
+        return bundleStartLevel;
+    }
+
+    public String getState() {
+        return state;
+    }
+
+    public String getSymbolicName() {
+        return symbolicName;
+    }
+
+    public String getVersion() {
+        return version;
+    }
+
+    /*
+     * Represents key/value pair in BundleData headers
+     */
+    public static class Header {
+
+        private String key;
+        private String value;
+
+        public String getKey() {
+            return key;
+        }
+
+        public String getValue() {
+            return value;
+        }
+
+        private Header() {
+            super();
+        }
+
+        public Header(String key, String value) {
+            this.key = key;
+            this.value = value;
+        }
+
+        public CompositeData toCompositeData() throws JMRuntimeException {
+            CompositeData result = null;
+            Map<String, Object> items = new HashMap<String, Object>();
+            items.put(KEY, key);
+            items.put(VALUE, value);
+            try {
+                result = new CompositeDataSupport(HEADER_TYPE, items);
+            } catch (OpenDataException e) {
+                throw new JMRuntimeException("Failed to create CompositeData for header [" + key + ":" + value + "] - "
+                        + e.getMessage());
+            }
+            return result;
+        }
+
+        public static Header from(CompositeData compositeData) {
+            if (compositeData == null) {
+                throw new IllegalArgumentException("Argument compositeData cannot be null");
+            }
+            if (!compositeData.getCompositeType().equals(HEADER_TYPE)) {
+                throw new IllegalArgumentException("Invalid CompositeType [" + compositeData.getCompositeType() + "]");
+            }
+            Header header = new Header();
+            header.key = (String) compositeData.get(KEY);
+            header.value = (String) compositeData.get(VALUE);
+            return header;
+        }
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BundleEventData.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BundleEventData.java
index 17c97dcc..9f63f29c 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BundleEventData.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BundleEventData.java
@@ -1 +1,138 @@
   + text/plain
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import static org.osgi.jmx.framework.BundleStateMBean.BUNDLE_EVENT_TYPE;
+import static org.osgi.jmx.framework.BundleStateMBean.EVENT;
+import static org.osgi.jmx.framework.BundleStateMBean.IDENTIFIER;
+import static org.osgi.jmx.framework.BundleStateMBean.LOCATION;
+import static org.osgi.jmx.framework.BundleStateMBean.SYMBOLIC_NAME;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleEvent;
+import org.osgi.jmx.framework.BundleStateMBean;
+
+/**
+ * <p>
+ * <tt>BundleEventData</tt> represents BundleEvent Type @see {@link BundleStateMBean#BUNDLE_EVENT_TYPE}. It is a codec
+ * for the <code>CompositeData</code> representing an OSGi BundleEvent.
+ * </p>
+ * 
+ * @version $Rev$ $Date$
+ */
+public class BundleEventData {
+
+    /**
+     * @see BundleStateMBean#IDENTIFIER_ITEM
+     */
+    private long bundleId;
+
+    /**
+     * @see BundleStateMBean#LOCATION_ITEM
+     */
+    private String location;
+
+    /**
+     * @see BundleStateMBean#SYMBOLIC_NAME_ITEM
+     */
+    private String bundleSymbolicName;
+
+    /**
+     * @see BundleStateMBean#EVENT_ITEM
+     */
+    private int eventType;
+
+    private BundleEventData() {
+        super();
+    }
+
+    public BundleEventData(BundleEvent bundleEvent) {
+        this.eventType = bundleEvent.getType();
+        Bundle bundle = bundleEvent.getBundle();
+        this.bundleId = bundle.getBundleId();
+        this.location = bundle.getLocation();
+        this.bundleSymbolicName = bundle.getSymbolicName();
+    }
+
+    /**
+     * Returns CompositeData representing a BundleEvent typed by {@link BundleStateMBean#BUNDLE_EVENT_TYPE}
+     * 
+     * @return
+     */
+    public CompositeData toCompositeData() {
+        CompositeData result = null;
+        Map<String, Object> items = new HashMap<String, Object>();
+        items.put(IDENTIFIER, this.bundleId);
+        items.put(SYMBOLIC_NAME, this.bundleSymbolicName);
+        items.put(LOCATION, this.location);
+        items.put(EVENT, this.eventType);
+        try {
+            result = new CompositeDataSupport(BUNDLE_EVENT_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new IllegalStateException("Failed to create CompositeData for BundleEvent for Bundle ["
+                    + this.bundleId + "]", e);
+        }
+        return result;
+    }
+
+    /**
+     * Returns a <code>BundleEventData</code> representation of the given compositeData
+     * 
+     * @param compositeData
+     * @return
+     * @throws IllegalArgumentException
+     *             if the compositeData is null or incorrect type
+     */
+    public static BundleEventData from(CompositeData compositeData) throws IllegalArgumentException {
+        BundleEventData eventData = new BundleEventData();
+        if (compositeData == null) {
+            throw new IllegalArgumentException("Argument compositeData cannot be null");
+        }
+        if (!compositeData.getCompositeType().equals(BUNDLE_EVENT_TYPE)) {
+            throw new IllegalArgumentException("Invalid CompositeType [" + compositeData.getCompositeType() + "]");
+        }
+        eventData.bundleId = (Long) compositeData.get(IDENTIFIER);
+        eventData.bundleSymbolicName = (String) compositeData.get(SYMBOLIC_NAME);
+        eventData.eventType = (Integer) compositeData.get(EVENT);
+        eventData.location = (String) compositeData.get(LOCATION);
+        return eventData;
+    }
+
+    public long getBundleId() {
+        return bundleId;
+    }
+
+    public String getLocation() {
+        return location;
+    }
+
+    public String getBundleSymbolicName() {
+        return bundleSymbolicName;
+    }
+
+    public int getEventType() {
+        return eventType;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BundleWiringData.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BundleWiringData.java
index b56de2e8..25764444 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BundleWiringData.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/BundleWiringData.java
@@ -1,3 +1,109 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.CompositeType;
+import javax.management.openmbean.OpenDataException;
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularDataSupport;
+
+import org.osgi.framework.wiring.BundleCapability;
+import org.osgi.framework.wiring.BundleRequirement;
+import org.osgi.framework.wiring.BundleWire;
+import org.osgi.jmx.framework.BundleRevisionsStateMBean;
+
+public class BundleWiringData {
+    private final long bundleId;
+    private final List<BundleCapability> capabilities;
+    private final List<BundleRequirement> requirements;
+
+    public BundleWiringData(long bundleId, List<BundleCapability> capabilities, List<BundleRequirement> requirements, List<BundleWire> requiredWires) {
+        this.bundleId = bundleId;
+        this.capabilities = capabilities;
+        this.requirements = requirements;
+    }
+
+    public CompositeData toCompositeData() {
+        try {
+            Map<String, Object> items = new HashMap<String, Object>();
+            items.put(BundleRevisionsStateMBean.BUNDLE_ID, bundleId);
+            items.put(BundleRevisionsStateMBean.BUNDLE_REVISION_ID, null);
+
+            items.put(BundleRevisionsStateMBean.REQUIREMENTS, getRequirements());
+            items.put(BundleRevisionsStateMBean.CAPABILITIES, getCapabilities());
+            items.put(BundleRevisionsStateMBean.BUNDLE_WIRES_TYPE, null);
+
+            return new CompositeDataSupport(BundleRevisionsStateMBean.BUNDLE_WIRING_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new IllegalStateException("Can't create CompositeData" + e);
+        }
+    }
+
+    private CompositeData[] getCapabilities() throws OpenDataException {
+        CompositeData[] capData = new CompositeData[capabilities.size()];
+        for (int i=0; i < capabilities.size(); i++) {
+            BundleCapability capability = capabilities.get(i);
+            capData[i] = getCapReqCompositeData(BundleRevisionsStateMBean.BUNDLE_CAPABILITY_TYPE,
+                capability.getNamespace(), capability.getAttributes().entrySet(), capability.getDirectives().entrySet());
+        }
+        return capData;
+    }
+
+    private CompositeData[] getRequirements() throws OpenDataException {
+        CompositeData [] reqData = new CompositeData[requirements.size()];
+        for (int i=0; i < requirements.size(); i++) {
+            BundleRequirement requirement = requirements.get(i);
+            reqData[i] = getCapReqCompositeData(BundleRevisionsStateMBean.BUNDLE_REQUIREMENT_TYPE,
+                    requirement.getNamespace(), requirement.getAttributes().entrySet(), requirement.getDirectives().entrySet());
+        }
+        return reqData;
+    }
+
+    private CompositeData getCapReqCompositeData(CompositeType type, String namespace, Set<Map.Entry<String,Object>> attributeSet, Set<Map.Entry<String,String>> directiveSet) throws OpenDataException {
+        Map<String, Object> reqItems = new HashMap<String, Object>();
+
+        TabularData attributes = new TabularDataSupport(BundleRevisionsStateMBean.ATTRIBUTES_TYPE);
+        for (Map.Entry<String, Object> entry : attributeSet) {
+            PropertyData<?> pd = PropertyData.newInstance(entry.getKey(), entry.getValue());
+            attributes.put(pd.toCompositeData());
+        }
+        reqItems.put(BundleRevisionsStateMBean.ATTRIBUTES, attributes);
+
+        TabularData directives = new TabularDataSupport(BundleRevisionsStateMBean.DIRECTIVES_TYPE);
+        for (Map.Entry<String, String> entry : directiveSet) {
+            CompositeData directive = new CompositeDataSupport(BundleRevisionsStateMBean.DIRECTIVE_TYPE,
+                new String[] { BundleRevisionsStateMBean.KEY, BundleRevisionsStateMBean.VALUE },
+                new Object[] { entry.getKey(), entry.getValue() });
+            directives.put(directive);
+        }
+        reqItems.put(BundleRevisionsStateMBean.DIRECTIVES, directives);
+        reqItems.put(BundleRevisionsStateMBean.NAMESPACE, namespace);
+
+        CompositeData req = new CompositeDataSupport(type, reqItems);
+        return req;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/GroupData.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/GroupData.java
index b56de2e8..8fb31d9c 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/GroupData.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/GroupData.java
@@ -1,3 +1,138 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.osgi.jmx.service.useradmin.UserAdminMBean;
+import org.osgi.service.useradmin.Group;
+import org.osgi.service.useradmin.Role;
+
+/**
+ * <p>
+ * <tt>GroupData</tt> represents Group Type @see {@link UserAdminMBean#GROUP_TYPE}.It is a codec
+ * for the <code>CompositeData</code> representing a Group.
+ * </p>
+ * </p>
+ * 
+ * @version $Rev$ $Date$
+ */
+public class GroupData extends UserData {
+
+    /**
+     * @see UserAdminMBean#MEMBERS_ITEM
+     * @see UserAdminMBean#MEMBERS
+     */
+    private String[] members;
+    /**
+     * @see UserAdminMBean#REQUIRED_MEMBERS
+     * @see UserAdminMBean#REQUIRED_MEMBERS_ITEM
+     */
+    private String[] requiredMembers;
+
+    /**
+     * Constructs new GroupData from Group object.
+     * @param group {@link Group} instance.
+     */
+    public GroupData(Group group) {
+        super(group.getName(), Role.GROUP);
+        this.members = toArray(group.getMembers());
+        this.requiredMembers = toArray(group.getRequiredMembers());
+    }
+
+    /**
+     * Constructs new GroupData.
+     * 
+     * @param name group name.
+     * @param members basic members.
+     * @param requiredMembers required members.
+     */
+    public GroupData(String name, String[] members, String[] requiredMembers) {
+        super(name, Role.GROUP);
+        this.members = (members == null) ? new String[0] : members;
+        this.requiredMembers = (requiredMembers == null) ? new String[0] : requiredMembers;
+    }
+
+    /**
+     * Translates GroupData to CompositeData represented by compositeType {@link UserAdminMBean#GROUP_TYPE}.
+     * 
+     * @return translated GroupData to compositeData.
+     */
+    public CompositeData toCompositeData() {
+        try {
+            Map<String, Object> items = new HashMap<String, Object>();
+            items.put(UserAdminMBean.NAME, name);
+            items.put(UserAdminMBean.TYPE, type);
+            items.put(UserAdminMBean.MEMBERS, members);
+            items.put(UserAdminMBean.REQUIRED_MEMBERS, requiredMembers);
+            return new CompositeDataSupport(UserAdminMBean.GROUP_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new IllegalStateException("Can't create CompositeData" + e);
+        }
+    }
+
+    /**
+     * Static factory method to create GroupData from CompositeData object.
+     * 
+     * @param data
+     *            {@link CompositeData} instance.
+     * @return GroupData instance.
+     */
+    public static GroupData from(CompositeData data) {
+        if (data == null) {
+            return null;
+        }
+        String name = (String) data.get(UserAdminMBean.NAME);
+        String[] members = (String[]) data.get(UserAdminMBean.MEMBERS);
+        String[] requiredMembers = (String[]) data.get(UserAdminMBean.REQUIRED_MEMBERS);
+        return new GroupData(name, members, requiredMembers);
+    }
+
+    /**
+     * @return the members
+     */
+    public String[] getMembers() {
+        return members;
+    }
+
+    /**
+     * @return the requiredMembers
+     */
+    public String[] getRequiredMembers() {
+        return requiredMembers;
+    }
+
+    private static String[] toArray(Role[] roles) {
+        List<String> members = new ArrayList<String>();
+        if (roles != null) {
+            for (Role role : roles) {
+                members.add(role.getName());
+            }
+        }
+        return members.toArray(new String[members.size()]);
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/PackageData.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/PackageData.java
index b56de2e8..ae895693 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/PackageData.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/PackageData.java
@@ -1,3 +1,261 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularDataSupport;
+
+import org.osgi.framework.Bundle;
+import org.osgi.jmx.framework.PackageStateMBean;
+import org.osgi.service.packageadmin.ExportedPackage;
+
+/**
+ * <p>
+ * <tt>PackageData</tt>represents PackageType @see {@link PackageStateMBean#PACKAGE_TYPE}.
+ * It is a codec for the composite data representing an OSGi ExportedPackage.
+ * </p>
+ * 
+ * @version $Rev$ $Date$
+ */
+public class PackageData {
+
+    /**
+     * {@link PackageStateMBean#EXPORTING_BUNDLES}
+     */
+    long[] exportingBundles;
+
+    /**
+     * {@link PackageStateMBean#IMPORTING_BUNDLES}
+     */
+    long[] importingBundles;
+
+    /**
+     * {@link PackageStateMBean#NAME}
+     */
+    String name;
+
+    /**
+     * {@link PackageStateMBean#REMOVAL_PENDING}
+     */
+    boolean removalPending;
+
+    /**
+     * {@link PackageStateMBean#VERSION}
+     */
+    String version;
+
+    /**
+     * Constructs new PackageData with provided ExportedPackage.
+     * @param exportedPackage @see {@link ExportedPackage}.
+     */
+    public PackageData(ExportedPackage exportedPackage) {
+        this(new long[]{exportedPackage.getExportingBundle().getBundleId()}, toBundleIds(exportedPackage.getImportingBundles()),
+                exportedPackage.getName(), exportedPackage.isRemovalPending(), exportedPackage.getVersion().toString());
+
+    }
+
+    /**
+     * Constructs new PackageData.
+     * 
+     * @param exportingBundles the bundle the package belongs to.
+     * @param importingBundles the importing bundles of the package.
+     * @param name the package name.
+     * @param removalPending whether the package is pending removal.
+     * @param version package version.
+     */
+    public PackageData(long[] exportingBundles, long[] importingBundles, String name, boolean removalPending, String version) {
+        this.exportingBundles = exportingBundles;
+        this.importingBundles = importingBundles;
+        this.name = name;
+        this.removalPending = removalPending;
+        this.version = version;
+    }
+    
+    /**
+     * Translates PackageData to CompositeData represented by
+     * compositeType {@link PackageStateMBean#PACKAGE_TYPE}.
+     * 
+     * @return translated PackageData to compositeData.
+     */
+    public CompositeData toCompositeData() {
+        try {
+            Map<String, Object> items = new HashMap<String, Object>();
+            items.put(PackageStateMBean.EXPORTING_BUNDLES, toLongArray(exportingBundles));
+            items.put(PackageStateMBean.IMPORTING_BUNDLES, toLongArray(importingBundles));
+            items.put(PackageStateMBean.NAME, name);
+            items.put(PackageStateMBean.REMOVAL_PENDING, removalPending);
+            items.put(PackageStateMBean.VERSION, version);
+            return new CompositeDataSupport(PackageStateMBean.PACKAGE_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new IllegalStateException("Can't create CompositeData" + e);
+        }
+    }
+
+    /**
+     * Static factory method to create PackageData from CompositeData object.
+     * 
+     * @param data {@link CompositeData} instance.
+     * @return PackageData instance.
+     */
+    public static PackageData from(CompositeData data) {
+        if(data == null){
+            return null;
+        }
+        long[] exportingBundle = toLongPrimitiveArray((Long[])data.get(PackageStateMBean.EXPORTING_BUNDLES));
+        long[] importingBundles = toLongPrimitiveArray((Long[]) data.get(PackageStateMBean.IMPORTING_BUNDLES));
+        String name = (String) data.get(PackageStateMBean.NAME);
+        boolean removalPending = (Boolean) data.get(PackageStateMBean.REMOVAL_PENDING);
+        String version = (String) data.get(PackageStateMBean.VERSION);
+        return new PackageData(exportingBundle,importingBundles,name, removalPending,version);
+    }
+
+    /**
+     * Creates {@link TabularData} for set of PackageData's.
+     * 
+     * @param packages set of PackageData's
+     * @return {@link TabularData} instance.
+     */
+    public static TabularData tableFrom(Set<PackageData> packages){
+        TabularData table = new TabularDataSupport(PackageStateMBean.PACKAGES_TYPE);
+        for(PackageData pkg : packages){
+            table.put(pkg.toCompositeData());
+        }
+        return table;
+    }
+
+    /**
+     * Converts array of bundles to array of bundle id's.
+     * 
+     * @param bundles array of Bundle's.
+     * @return array of bundle id's.
+     */
+    public static long[] toBundleIds(Bundle[] bundles) {
+        if (bundles != null) {
+            long[] importingBundles = new long[bundles.length];
+            for (int i = 0; i < bundles.length; i++) {
+                importingBundles[i] = bundles[i].getBundleId();
+            }
+            return importingBundles;
+        }
+        return null;
+    }
+    
+    /**
+     * Converts primitive array of strings to Long array.
+     * 
+     * @param primitiveArray primitive long array.
+     * @return Long array.
+     */
+    protected Long[] toLongArray(long[] primitiveArray) {
+        if (primitiveArray == null) {
+            return null;
+        }
+        Long[] converted = new Long[primitiveArray.length];
+        for (int i = 0; i < primitiveArray.length; i++) {
+            converted[i] = primitiveArray[i];
+        }
+
+        return converted;
+    }
+
+    /**
+     * Converts Long array to primitive array of long.
+     * 
+     * @param wrapperArray Long array.
+     * @return primitive long array.
+     */
+    protected static long[] toLongPrimitiveArray(Long[] wrapperArray) {
+        if (wrapperArray == null) {
+            return null;
+        }
+        long[] converted = new long[wrapperArray.length];
+        for (int i = 0; i < wrapperArray.length; i++) {
+            converted[i] = wrapperArray[i];
+        }
+
+        return converted;
+    }
+
+    /**
+     * @return the exportingBundles
+     */
+    public long[] getExportingBundles() {
+        return exportingBundles;
+    }
+
+    /**
+     * @return the importingBundles
+     */
+    public long[] getImportingBundles() {
+        return importingBundles;
+    }
+
+    /**
+     * @return the name
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * @return the removalPending
+     */
+    public boolean isRemovalPending() {
+        return removalPending;
+    }
+
+    /**
+     * @return the version
+     */
+    public String getVersion() {
+        return version;
+    }
+    
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        PackageData that = (PackageData) o;
+
+        // exportingBundle must be always there
+        if (exportingBundles[0] != that.exportingBundles[0]) return false;
+        if (!name.equals(that.name)) return false;
+        if (!version.equals(that.version)) return false;
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = (int) (exportingBundles[0] ^ (exportingBundles[0] >>> 32));
+        result = 31 * result + name.hashCode();
+        result = 31 * result + version.hashCode();
+        return result;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/PropertyData.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/PropertyData.java
index b56de2e8..26f69687 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/PropertyData.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/PropertyData.java
@@ -1,3 +1,335 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import static org.apache.aries.jmx.util.TypeUtils.fromString;
+import static org.apache.aries.jmx.util.TypeUtils.primitiveTypes;
+import static org.apache.aries.jmx.util.TypeUtils.types;
+import static org.osgi.jmx.JmxConstants.ARRAY_OF;
+import static org.osgi.jmx.JmxConstants.KEY;
+import static org.osgi.jmx.JmxConstants.PROPERTY_TYPE;
+import static org.osgi.jmx.JmxConstants.P_BOOLEAN;
+import static org.osgi.jmx.JmxConstants.P_BYTE;
+import static org.osgi.jmx.JmxConstants.P_CHAR;
+import static org.osgi.jmx.JmxConstants.P_DOUBLE;
+import static org.osgi.jmx.JmxConstants.P_FLOAT;
+import static org.osgi.jmx.JmxConstants.P_INT;
+import static org.osgi.jmx.JmxConstants.P_LONG;
+import static org.osgi.jmx.JmxConstants.TYPE;
+import static org.osgi.jmx.JmxConstants.VALUE;
+import static org.osgi.jmx.JmxConstants.VECTOR_OF;
+
+import java.lang.reflect.Array;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.StringTokenizer;
+import java.util.Vector;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.osgi.jmx.JmxConstants;
+
+/**
+ * <p>
+ * <tt>PropertyData</tt> represents Property Type @see {@link JmxConstants#PROPERTY_TYPE}. It is a codec for the
+ * <code>CompositeData</code> representing a Property with an associated Type and Value.
+ * </p>
+ * 
+ * @version $Rev$ $Date$
+ */
+public class PropertyData<T> {
+
+    /**
+     * @see JmxConstants#KEY_ITEM
+     */
+    private String key;
+    
+    /**
+     * @see JmxConstants#SCALAR
+     */
+    private T value;
+    
+    /**
+     * @see JmxConstants#VALUE_ITEM
+     */
+    private String encodedValue;
+    
+    /**
+     * @see JmxConstants#TYPE_ITEM
+     */
+    private String encodedType;
+    
+    private PropertyData() {
+        super();
+    }
+    
+    
+    @SuppressWarnings("unchecked")
+    private PropertyData(String key, T value, String preservedBaseType) throws IllegalArgumentException {
+        if (key == null) {
+            throw new IllegalArgumentException("Argument key cannot be null");
+        }
+        if (value == null) {
+            throw new IllegalArgumentException("Argument value cannot be null");
+        }
+        this.key = key;
+        this.value = value;
+        Class<T> type = (Class<T>) value.getClass();
+        if (type.isArray()) {
+            this.encodedType = ARRAY_OF + type.getComponentType().getSimpleName();
+            StringBuilder builder = new StringBuilder();
+            int length = Array.getLength(value);
+            boolean useDelimiter = false;
+            for (int i = 0; i < length; i++) {
+                if (useDelimiter) {
+                    builder.append(",");
+                } else {
+                    useDelimiter = true;
+                }
+                builder.append(Array.get(value, i));
+            }
+            this.encodedValue = builder.toString();
+        } else if (type.equals(Vector.class)) {
+            Vector vector = (Vector) value;
+            Class<? extends Object> componentType = Object.class;
+            if (vector.size() > 0) {
+                componentType = vector.firstElement().getClass();
+            }
+            this.encodedType = VECTOR_OF + componentType.getSimpleName();
+            StringBuilder builder = new StringBuilder();
+            Vector valueVector = (Vector) value;
+            boolean useDelimiter = false;
+            for (Object val: valueVector) {
+                if (useDelimiter) {
+                    builder.append(",");
+                } else {
+                    useDelimiter = true;
+                }
+                builder.append(val);
+            }
+            this.encodedValue = builder.toString();
+        } else {
+            this.encodedType = (preservedBaseType == null) ? type.getSimpleName() : preservedBaseType;
+            this.encodedValue = value.toString();
+        }
+    }
+    
+    /**
+     * Static factory method for <code>PropertyData</code> instance parameterized by value's type
+     * @param <T>
+     * @param key
+     * @param value an instance of {@link JmxConstants#SCALAR}
+     * @return
+     * @throws IllegalArgumentException if key or value are null or value's type cannot be encoded
+     */
+    public static <T> PropertyData<T> newInstance(String key, T value) throws IllegalArgumentException {
+        return new PropertyData<T>(key, value, null);
+    }
+    
+    /**
+     * Static factory method for <code>PropertyData</code> instance which preserves encoded type
+     * information for primitive int type 
+     * @param key
+     * @param value
+     * @return
+     * @throws IllegalArgumentException if key or value are null or value's type cannot be encoded
+     */
+    public static PropertyData<Integer> newInstance(String key, int value) throws IllegalArgumentException {
+        return new PropertyData<Integer>(key, value, P_INT);
+    }
+    
+    /**
+     * Static factory method for <code>PropertyData</code> instance which preserves encoded type
+     * information for primitive long type 
+     * @param key
+     * @param value
+     * @return
+     * @throws IllegalArgumentException if key or value are null or value's type cannot be encoded
+     */
+    public static PropertyData<Long> newInstance(String key, long value) throws IllegalArgumentException {
+        return new PropertyData<Long>(key, value, P_LONG);
+    }
+  
+    /**
+     * Static factory method for <code>PropertyData</code> instance which preserves encoded type
+     * information for primitive float type 
+     * @param key
+     * @param value
+     * @return
+     * @throws IllegalArgumentException if key or value are null or value's type cannot be encoded
+     */
+    public static PropertyData<Float> newInstance(String key, float value) throws IllegalArgumentException {
+        return new PropertyData<Float>(key, value, P_FLOAT);
+    }
+    
+    /**
+     * Static factory method for <code>PropertyData</code> instance which preserves encoded type
+     * information for primitive double type 
+     * @param key
+     * @param value
+     * @return
+     * @throws IllegalArgumentException if key or value are null or value's type cannot be encoded
+     */
+    public static PropertyData<Double> newInstance(String key, double value) throws IllegalArgumentException {
+        return new PropertyData<Double>(key, value, P_DOUBLE);
+    }
+    
+    /**
+     * Static factory method for <code>PropertyData</code> instance which preserves encoded type
+     * information for primitive byte type 
+     * @param key
+     * @param value
+     * @return
+     * @throws IllegalArgumentException if key or value are null or value's type cannot be encoded
+     */
+    public static PropertyData<Byte> newInstance(String key, byte value) throws IllegalArgumentException {
+        return new PropertyData<Byte>(key, value, P_BYTE);
+    }
+    
+    /**
+     * Static factory method for <code>PropertyData</code> instance which preserves encoded type
+     * information for primitive char type 
+     * @param key
+     * @param value
+     * @return
+     * @throws IllegalArgumentException if key or value are null or value's type cannot be encoded
+     */
+    public static PropertyData<Character> newInstance(String key, char value) throws IllegalArgumentException {
+        return new PropertyData<Character>(key, value, P_CHAR);
+    }
+    
+    /**
+     * Static factory method for <code>PropertyData</code> instance which preserves encoded type
+     * information for primitive boolean type 
+     * @param key
+     * @param value
+     * @return
+     * @throws IllegalArgumentException if key or value are null or value's type cannot be encoded
+     */
+    public static PropertyData<Boolean> newInstance(String key, boolean value) throws IllegalArgumentException {
+        return new PropertyData<Boolean>(key, value, P_BOOLEAN);
+    }
+    
+
+    /**
+     * Returns CompositeData representing a Property typed by {@link JmxConstants#PROPERTY_TYPE}.
+     * @return
+     */
+    public CompositeData toCompositeData() {
+        CompositeData result = null;
+        Map<String, Object> items = new HashMap<String, Object>();
+        items.put(KEY, this.key);
+        items.put(VALUE, this.encodedValue);
+        items.put(TYPE, this.encodedType);
+        try {
+            result = new CompositeDataSupport(PROPERTY_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new IllegalStateException("Failed to create CompositeData for Property [" + this.key + ":" + this.value + "]", e);
+        }
+        return result;
+    }
+    
+    /**
+     * Constructs a <code>PropertyData</code> object from the given <code>CompositeData</code>
+     * @param compositeData
+     * @return
+     * @throws IlleglArgumentException if compositeData is null or not of type {@link JmxConstants#PROPERTY_TYPE}
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> PropertyData<T> from(CompositeData compositeData) throws IllegalArgumentException {
+        if ( compositeData == null ) {
+            throw new IllegalArgumentException("Argument compositeData cannot be null");
+        }
+        if (!compositeData.getCompositeType().equals(PROPERTY_TYPE)) {
+            throw new IllegalArgumentException("Invalid CompositeType [" + compositeData.getCompositeType() + "]");
+        }
+        PropertyData propertyData = new PropertyData();
+        propertyData.key = (String) compositeData.get(KEY);
+        propertyData.encodedType = (String) compositeData.get(TYPE);
+        propertyData.encodedValue = (String) compositeData.get(VALUE);
+        if (propertyData.encodedType == null || propertyData.encodedType.length() < 1) {
+            throw new IllegalArgumentException ("Cannot determine type from compositeData : " + compositeData);
+        }
+        StringTokenizer values = new StringTokenizer(propertyData.encodedValue, ",");
+        int valuesLength = values.countTokens();
+        if (propertyData.encodedType.startsWith(ARRAY_OF)) {
+            String[] arrayTypeParts = propertyData.encodedType.split("\\s");
+            if (arrayTypeParts.length < 3) {
+                throw new IllegalArgumentException("Cannot parse Array type from type item : " + propertyData.encodedType);
+            }
+            String arrayTypeName = arrayTypeParts[2].trim();
+            if (!types.containsKey(arrayTypeName)) {
+                throw new IllegalArgumentException ("Cannot determine type from value : " + arrayTypeName);
+            }
+            Class<? extends Object> arrayType = types.get(arrayTypeName);
+            propertyData.value = Array.newInstance(arrayType, valuesLength);
+            int index = 0;
+            while (values.hasMoreTokens()) {
+                Array.set(propertyData.value, index++, fromString(arrayType, values.nextToken()));
+            }
+        } else if (propertyData.encodedType.startsWith(VECTOR_OF)) {
+            String[] vectorTypeParts = propertyData.encodedType.split("\\s");
+            if (vectorTypeParts.length < 3) {
+                throw new IllegalArgumentException("Cannot parse Array type from type item : " + propertyData.encodedType);
+            }
+            String vectorTypeName = vectorTypeParts[2].trim();
+            if (!types.containsKey(vectorTypeName)) {
+                throw new IllegalArgumentException ("Cannot determine type from value : " + vectorTypeName);
+            }
+            Class<? extends Object> vectorType = types.get(vectorTypeName);
+            Vector vector = new Vector();
+            while (values.hasMoreTokens()) {
+                vector.add(fromString(vectorType, values.nextToken()));
+            }
+            propertyData.value = vector;
+        } else {
+            if (!types.containsKey(propertyData.encodedType)) {
+                throw new IllegalArgumentException ("Cannot determine type from value : " + propertyData.encodedType);
+            }
+            Class<? extends Object> valueType = types.get(propertyData.encodedType);
+            propertyData.value = fromString(valueType, propertyData.encodedValue);
+        }
+        return propertyData;
+    }
+ 
+    
+    public String getKey() {
+        return key;
+    }
+
+    public T getValue() {
+        return value;
+    }
+
+    public String getEncodedType() {
+        return encodedType;
+    }
+    
+    public String getEncodedValue() {
+        return encodedValue;
+    }
+
+    public boolean isEncodingPrimitive() {
+        return primitiveTypes.containsKey(encodedType);
+    }
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/RoleData.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/RoleData.java
index b56de2e8..2e532368 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/RoleData.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/RoleData.java
@@ -1,3 +1,160 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import java.util.Collection;
+import java.util.Dictionary;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularDataSupport;
+
+import org.osgi.jmx.JmxConstants;
+import org.osgi.jmx.service.useradmin.UserAdminMBean;
+import org.osgi.service.useradmin.Role;
+
+
+/**
+ * <p>
+ * <tt>RoleData</tt> represents Role Type @see {@link UserAdminMBean#ROLE_TYPE}.It is a codec
+ * for the <code>CompositeData</code> representing a Role.
+ * </p>
+ *
+ * @version $Rev$ $Date$
+ */
+public class RoleData {
+    
+    /**
+     * role name.
+     */
+    protected String name;
+    /**
+     * role type.
+     */
+    protected int type;
+    
+    /**
+     * Constructs new RoleData from Role object.
+     * @param role {@link Role} instance.
+     */
+    public RoleData(Role role){
+        this(role.getName(),role.getType());
+    }
+    
+    /**
+     * Constructs new RoleData.
+     * @param name role name.
+     * @param type role type.
+     */
+    public RoleData(String name, int type){
+        this.name = name;
+        this.type = type;
+    }
+    
+    /**
+     * Translates RoleData to CompositeData represented by
+     * compositeType {@link UserAdminMBean#ROLE_TYPE}.
+     * 
+     * @return translated RoleData to compositeData.
+     */
+    public CompositeData toCompositeData() {
+        try {
+            Map<String, Object> items = new HashMap<String, Object>();
+            items.put(UserAdminMBean.NAME, name);
+            items.put(UserAdminMBean.TYPE, type);
+            return new CompositeDataSupport(UserAdminMBean.ROLE_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new IllegalStateException("Can't create CompositeData" + e);
+        }
+    }
+
+    /**
+     * Static factory method to create RoleData from CompositeData object.
+     * 
+     * @param data {@link CompositeData} instance.
+     * @return RoleData instance.
+     */
+    public static RoleData from(CompositeData data) {
+        if(data == null){
+            return null;
+        }
+        String name = (String) data.get(UserAdminMBean.NAME);
+        int type = (Integer) data.get(UserAdminMBean.TYPE);
+        return new RoleData(name, type);
+    }
+
+    /**
+     * Creates TabularData from Dictionary.
+     * 
+     * @param props Dictionary instance.
+     * @return TabularData instance.
+     */
+    protected static TabularData toTabularData(Dictionary<String, Object> props){
+        if(props == null){
+            return null;
+        }
+        TabularData data = new TabularDataSupport(JmxConstants.PROPERTIES_TYPE);
+        for (Enumeration<String> keys = props.keys(); keys.hasMoreElements();) {
+            String key = keys.nextElement();
+            data.put(PropertyData.newInstance(key, props.get(key)).toCompositeData());
+        }
+        return data;
+    }
+    
+    /**
+     * Creates properties from TabularData object.
+     * 
+     * @param data {@link TabularData} instance.
+     * @return translated tabular data to properties {@link Dictionary}.
+     */
+    protected static Dictionary<String, Object> propertiesFrom(TabularData data){
+        if(data == null){
+            return null;
+        }
+        
+        Dictionary<String, Object> props = new Hashtable<String, Object>();
+        for(CompositeData compositeData : (Collection<CompositeData>)data.values()){
+            PropertyData  property = PropertyData.from(compositeData);
+            props.put(property.getKey(), property.getValue());
+        }
+        
+        return props;
+    }
+    /**
+     * @return the name
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * @return the type
+     */
+    public int getType() {
+        return type;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/ServiceData.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/ServiceData.java
index b56de2e8..4f19e352 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/ServiceData.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/ServiceData.java
@@ -1,3 +1,168 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import static org.apache.aries.jmx.util.FrameworkUtils.getBundleIds;
+import static org.apache.aries.jmx.util.TypeUtils.toLong;
+import static org.apache.aries.jmx.util.TypeUtils.toPrimitive;
+import static org.osgi.jmx.framework.ServiceStateMBean.BUNDLE_IDENTIFIER;
+import static org.osgi.jmx.framework.ServiceStateMBean.IDENTIFIER;
+import static org.osgi.jmx.framework.ServiceStateMBean.OBJECT_CLASS;
+import static org.osgi.jmx.framework.ServiceStateMBean.SERVICE_TYPE;
+import static org.osgi.jmx.framework.ServiceStateMBean.USING_BUNDLES;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.osgi.framework.Constants;
+import org.osgi.framework.ServiceReference;
+import org.osgi.jmx.framework.ServiceStateMBean;
+
+/**
+ * <p>
+ * <tt>ServiceData</tt> represents Service Type @see {@link ServiceStateMBean#SERVICE_TYPE}. It is a codec for the
+ * <code>CompositeData</code> representing an OSGi <code>ServiceReference</code>.
+ * </p>
+ * 
+ * @version $Rev$ $Date$
+ */
+public class ServiceData {
+
+    /**
+     * @see ServiceStateMBean#IDENTIFIER_ITEM
+     */
+    private long serviceId;
+    
+    /**
+     * @see ServiceStateMBean#BUNDLE_IDENTIFIER_ITEM
+     */
+    private long bundleId;
+    
+    /**
+     * @see ServiceStateMBean#OBJECT_CLASS_ITEM
+     */
+    private String[] serviceInterfaces;
+    
+    // keep properties for next version of the spec
+    ///**
+    // * @see ServiceStateMBean#PROPERTIES_ITEM
+    // */
+    //private List<PropertyData<? extends Object>> properties = new ArrayList<PropertyData<? extends Object>>();
+    
+    /**
+     * @see ServiceStateMBean#USING_BUNDLES_ITEM
+     */
+    private long[] usingBundles;
+
+    private ServiceData() {
+        super();
+    }
+
+    public ServiceData(ServiceReference serviceReference) throws IllegalArgumentException {
+        if (serviceReference == null) {
+            throw new IllegalArgumentException("Argument serviceReference cannot be null");
+        }
+        this.serviceId = (Long) serviceReference.getProperty(Constants.SERVICE_ID);
+        this.bundleId = serviceReference.getBundle().getBundleId();
+        this.serviceInterfaces = (String[]) serviceReference.getProperty(Constants.OBJECTCLASS);
+        this.usingBundles = getBundleIds(serviceReference.getUsingBundles());
+        //for (String propertyKey: serviceReference.getPropertyKeys()) {
+        //    this.properties.add(PropertyData.newInstance(propertyKey, serviceReference.getProperty(propertyKey)));
+        //}
+    }
+
+    /**
+     * Returns CompositeData representing a ServiceReference typed by {@link ServiceStateMBean#SERVICE_TYPE}.
+     * @return
+     */
+    public CompositeData toCompositeData() {
+        CompositeData result = null;
+        Map<String, Object> items = new HashMap<String, Object>();
+        items.put(IDENTIFIER, this.serviceId);
+        items.put(BUNDLE_IDENTIFIER, this.bundleId);
+        items.put(OBJECT_CLASS, this.serviceInterfaces);
+        //TabularData propertiesTable = new TabularDataSupport(PROPERTIES_TYPE);
+        //for (PropertyData<? extends Object> propertyData : this.properties) {
+        //    propertiesTable.put(propertyData.toCompositeData());
+        //}
+        // items.put(PROPERTIES, propertiesTable);
+        items.put(USING_BUNDLES, toLong(this.usingBundles));
+        try {
+            result = new CompositeDataSupport(SERVICE_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new IllegalStateException("Failed to create CompositeData for ServiceReference with "
+                    + Constants.SERVICE_ID + " [" + this.serviceId + "]", e);
+        }
+        return result;
+    }
+
+    /**
+     * Constructs a <code>ServiceData</code> object from the given <code>CompositeData</code>
+     * 
+     * @param compositeData
+     * @return
+     * @throws IlleglArugmentException
+     *             if compositeData is null or not of type {@link ServiceStateMBean#SERVICE_TYPE}.
+     */
+    public static ServiceData from(CompositeData compositeData) {
+        if (compositeData == null) {
+            throw new IllegalArgumentException("Argument compositeData cannot be null");
+        }
+        if (!compositeData.getCompositeType().equals(SERVICE_TYPE)) {
+            throw new IllegalArgumentException("Invalid CompositeType [" + compositeData.getCompositeType() + "]");
+        }
+        ServiceData serviceData = new ServiceData();
+        serviceData.serviceId = (Long) compositeData.get(IDENTIFIER);
+        serviceData.bundleId = (Long) compositeData.get(BUNDLE_IDENTIFIER);
+        serviceData.serviceInterfaces = (String[]) compositeData.get(OBJECT_CLASS);
+        serviceData.usingBundles = toPrimitive((Long[]) compositeData.get(USING_BUNDLES));
+        // TabularData propertiesTable = (TabularData) compositeData.get(PROPERTIES);
+        // Collection<CompositeData> propertyData = (Collection<CompositeData>) propertiesTable.values();
+        // for (CompositeData propertyRow: propertyData) {
+        //     serviceData.properties.add(PropertyData.from(propertyRow));
+        // }
+        return serviceData;
+    }
+
+    public long getServiceId() {
+        return serviceId;
+    }
+
+    public long getBundleId() {
+        return bundleId;
+    }
+
+    public String[] getServiceInterfaces() {
+        return serviceInterfaces;
+    }
+
+    //public List<PropertyData<? extends Object>> getProperties() {
+    //    return properties;
+    //}
+
+    public long[] getUsingBundles() {
+        return usingBundles;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/ServiceEventData.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/ServiceEventData.java
index 1f8bddab..eb31e2da 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/ServiceEventData.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/ServiceEventData.java
@@ -1,3 +1,167 @@
   + native
   + text/plain
   + Revision Date
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import static org.osgi.jmx.framework.ServiceStateMBean.BUNDLE_IDENTIFIER;
+import static org.osgi.jmx.framework.ServiceStateMBean.BUNDLE_LOCATION;
+import static org.osgi.jmx.framework.ServiceStateMBean.BUNDLE_SYMBOLIC_NAME;
+import static org.osgi.jmx.framework.ServiceStateMBean.EVENT;
+import static org.osgi.jmx.framework.ServiceStateMBean.IDENTIFIER;
+import static org.osgi.jmx.framework.ServiceStateMBean.OBJECT_CLASS;
+import static org.osgi.jmx.framework.ServiceStateMBean.SERVICE_EVENT_TYPE;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.Constants;
+import org.osgi.framework.ServiceEvent;
+import org.osgi.framework.ServiceReference;
+import org.osgi.jmx.framework.ServiceStateMBean;
+
+/**
+ <p>
+ * <tt>ServiceEventData</tt> represents ServiceEvent Type @see {@link ServiceStateMBean#SERVICE_EVENT_TYPE}.
+ * It is a codec for the <code>CompositeData</code> representing an OSGi ServiceEvent.
+ * </p>
+ *
+ * @version $Rev$ $Date$
+ */
+public class ServiceEventData {
+
+    /**
+     * @see ServiceStateMBean#IDENTIFIER_ITEM
+     */
+    private long serviceId;
+    
+    /**
+     * @see ServiceStateMBean#OBJECT_CLASS_ITEM
+     */
+    private String[] serviceInterfaces;
+    
+    /**
+     * @see ServiceStateMBean#BUNDLE_IDENTIFIER_ITEM
+     */
+    private long bundleId;
+    
+    /**
+     * @see ServiceStateMBean#BUNDLE_LOCATION_ITEM
+     */
+    private String bundleLocation;
+    
+    /**
+     * @see ServiceStateMBean#BUNDLE_SYMBOLIC_NAME_ITEM
+     */
+    private String bundleSymbolicName;
+    
+    /**
+     * @see ServiceStateMBean#EVENT_ITEM
+     */
+    private int eventType;
+    
+    
+    private ServiceEventData(){
+        super();
+    }
+    
+    public ServiceEventData(ServiceEvent serviceEvent) {
+        ServiceReference serviceReference = serviceEvent.getServiceReference();
+        this.serviceId = (Long) serviceReference.getProperty(Constants.SERVICE_ID);
+        this.serviceInterfaces = (String[]) serviceReference.getProperty(Constants.OBJECTCLASS);
+        Bundle bundle = serviceReference.getBundle();
+        this.bundleId = bundle.getBundleId();
+        this.bundleLocation = bundle.getLocation();
+        this.bundleSymbolicName = bundle.getSymbolicName();
+        this.eventType = serviceEvent.getType();
+    }
+    
+    /**
+     * Returns CompositeData representing a ServiceEvent typed by {@link ServiceStateMBean#SERVICE_EVENT_TYPE}.
+     * @return
+     */
+    public CompositeData toCompositeData() {
+        CompositeData result = null;
+        Map<String, Object> items = new HashMap<String, Object>();
+        items.put(IDENTIFIER, this.serviceId);
+        items.put(OBJECT_CLASS, this.serviceInterfaces);
+        items.put(BUNDLE_IDENTIFIER, this.bundleId);
+        items.put(BUNDLE_LOCATION, this.bundleLocation);
+        items.put(BUNDLE_SYMBOLIC_NAME, this.bundleSymbolicName);
+        items.put(EVENT, this.eventType);
+        try {
+            result = new CompositeDataSupport(SERVICE_EVENT_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new IllegalStateException("Failed to create CompositeData for ServiceEvent for Service [" + this.serviceId + "]", e);
+        }
+        return result;
+    }
+    
+    /**
+     * Returns a <code>ServiceEventData</code> representation of the given compositeData
+     * @param compositeData
+     * @return
+     * @throws IllegalArgumentException if the compositeData is null or incorrect type
+     */
+    public static ServiceEventData from(CompositeData compositeData) throws IllegalArgumentException {
+        ServiceEventData serviceEventData = new ServiceEventData();
+        if ( compositeData == null ) {
+            throw new IllegalArgumentException("Argument compositeData cannot be null");
+        }
+        if (!compositeData.getCompositeType().equals(SERVICE_EVENT_TYPE)) {
+            throw new IllegalArgumentException("Invalid CompositeType [" + compositeData.getCompositeType() + "]");
+        }
+        serviceEventData.serviceId = (Long) compositeData.get(IDENTIFIER);
+        serviceEventData.serviceInterfaces = (String[]) compositeData.get(OBJECT_CLASS);
+        serviceEventData.bundleId = (Long) compositeData.get(BUNDLE_IDENTIFIER);
+        serviceEventData.bundleLocation = (String) compositeData.get(BUNDLE_LOCATION);
+        serviceEventData.bundleSymbolicName = (String) compositeData.get(BUNDLE_SYMBOLIC_NAME);
+        serviceEventData.eventType = (Integer) compositeData.get(EVENT);
+        return serviceEventData;
+    }
+    
+    public long getServiceId() {
+        return serviceId;
+    }
+    
+    public String[] getServiceInterfaces() {
+        return serviceInterfaces;
+    }
+    
+    public long getBundleId() {
+        return bundleId;
+    }
+    
+    public String getBundleLocation() {
+        return bundleLocation;
+    }
+    
+    public String getBundleSymbolicName() {
+        return bundleSymbolicName;
+    }
+    
+    public int getEventType() {
+        return eventType;
+    }
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/UserData.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/UserData.java
index e69de29b..782e287b 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/UserData.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/codec/UserData.java
@@ -0,0 +1,90 @@
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.OpenDataException;
+
+import org.osgi.jmx.service.useradmin.UserAdminMBean;
+import org.osgi.service.useradmin.User;
+
+/**
+ * <p>
+ * <tt>UserData</tt> represents User Type @see {@link UserAdminMBean#USER_TYPE}.It is a codec
+ * for the <code>CompositeData</code> representing a User.
+ * </p>
+ * @see RoleData
+ *
+ * @version $Rev$ $Date$
+ */
+public class UserData extends RoleData {
+
+    /**
+     * Constructs new UserData.
+     * 
+     * @param name user name.
+     * @param type role type.
+     */
+    public UserData(String name, int type){
+        super(name, type);
+    }
+    
+    /**
+     * Constructs new UserData from {@link User} object.
+     * 
+     * @param user {@link User} instance.
+     */
+    public UserData(User user){
+        this(user.getName(), user.getType());
+    }
+    
+    /**
+     * Translates UserData to CompositeData represented by
+     * compositeType {@link UserAdminMBean#USER_TYPE}.
+     * 
+     * @return translated UserData to compositeData.
+     */
+    public CompositeData toCompositeData() {
+        try {
+            Map<String, Object> items = new HashMap<String, Object>();
+            items.put(UserAdminMBean.NAME, name);
+            items.put(UserAdminMBean.TYPE, type);
+            return new CompositeDataSupport(UserAdminMBean.USER_TYPE, items);
+        } catch (OpenDataException e) {
+            throw new IllegalStateException("Can't create CompositeData" + e);
+        }
+    }
+
+    /**
+     * Static factory method to create UserData from CompositeData object.
+     * 
+     * @param data {@link CompositeData} instance.
+     * @return UserData instance.
+     */
+    public static UserData from(CompositeData data) {
+        if(data == null){
+            return null;
+        }
+        String name = (String) data.get(UserAdminMBean.NAME);
+        int type = (Integer)data.get(UserAdminMBean.TYPE);
+        return new UserData(name, type);
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleRevisionsState.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleRevisionsState.java
index b56de2e8..81649a45 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleRevisionsState.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleRevisionsState.java
@@ -1,3 +1,129 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import java.io.IOException;
+import java.util.List;
+
+import javax.management.openmbean.ArrayType;
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeType;
+
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.codec.BundleWiringData;
+import org.apache.aries.jmx.util.FrameworkUtils;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.wiring.BundleCapability;
+import org.osgi.framework.wiring.BundleRequirement;
+import org.osgi.framework.wiring.BundleRevision;
+import org.osgi.framework.wiring.BundleWire;
+import org.osgi.framework.wiring.BundleWiring;
+import org.osgi.jmx.framework.BundleRevisionsStateMBean;
+
+public class BundleRevisionsState implements BundleRevisionsStateMBean {
+    private final BundleContext bundleContext;
+    private final Logger logger;
+
+
+    public BundleRevisionsState(BundleContext bundleContext, Logger logger) {
+        this.bundleContext = bundleContext;
+        this.logger = logger;
+    }
+
+    /* (non-Javadoc)
+     * @see org.osgi.jmx.framework.BundleRevisionsStateMBean#getCurrentRevisionDeclaredRequirements(long, java.lang.String)
+     */
+    public ArrayType getCurrentRevisionDeclaredRequirements(long bundleId, String namespace) {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    /* (non-Javadoc)
+     * @see org.osgi.jmx.framework.BundleRevisionsStateMBean#getCurrentRevisionDeclaredCapabilities(long, java.lang.String)
+     */
+    public ArrayType getCurrentRevisionDeclaredCapabilities(long bundleId, String namespace) {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    /* (non-Javadoc)
+     * @see org.osgi.jmx.framework.BundleRevisionsStateMBean#getCurrentWiring(long, java.lang.String)
+     */
+    public CompositeData getCurrentWiring(long bundleId, String namespace) throws IOException {
+        Bundle bundle = FrameworkUtils.resolveBundle(bundleContext, bundleId);
+        BundleRevision currentRevision = bundle.adapt(BundleRevision.class);
+        BundleWiring wiring = currentRevision.getWiring();
+        List<BundleCapability> capabilities = wiring.getCapabilities(namespace);
+        List<BundleRequirement> requirements = wiring.getRequirements(namespace);
+        List<BundleWire> requiredWires = wiring.getRequiredWires(namespace);
+
+        BundleWiringData data = new BundleWiringData(bundle.getBundleId(), capabilities, requirements, requiredWires);
+        return data.toCompositeData();
+    }
+
+    /* (non-Javadoc)
+     * @see org.osgi.jmx.framework.BundleRevisionsStateMBean#getCurrentWiringClosure(long)
+     */
+    public CompositeData getCurrentWiringClosure(long rootBundleId) throws IOException {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    /* (non-Javadoc)
+     * @see org.osgi.jmx.framework.BundleRevisionsStateMBean#getRevisionsDeclaredRequirements(long, java.lang.String, boolean)
+     */
+    public ArrayType getRevisionsDeclaredRequirements(long bundleId, String namespace, boolean inUse) {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    /* (non-Javadoc)
+     * @see org.osgi.jmx.framework.BundleRevisionsStateMBean#getRevisionsDeclaredCapabilities(long, java.lang.String, boolean)
+     */
+    public ArrayType getRevisionsDeclaredCapabilities(long bundleId, String namespace, boolean inUse) {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    /* (non-Javadoc)
+     * @see org.osgi.jmx.framework.BundleRevisionsStateMBean#getRevisionsWiring(long, java.lang.String)
+     */
+    public ArrayType getRevisionsWiring(long bundleId, String namespace) {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    /* (non-Javadoc)
+     * @see org.osgi.jmx.framework.BundleRevisionsStateMBean#getWiringClosure(long, java.lang.String)
+     */
+    public ArrayType getWiringClosure(long rootBundleId, String namespace) {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    /* (non-Javadoc)
+     * @see org.osgi.jmx.framework.BundleRevisionsStateMBean#matches(javax.management.openmbean.CompositeType, javax.management.openmbean.CompositeType)
+     */
+    public boolean matches(CompositeType provider, CompositeType requirer) {
+        // TODO Auto-generated method stub
+        return false;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleRevisionsStateMBeanHandler.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleRevisionsStateMBeanHandler.java
index b56de2e8..758fe6f5 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleRevisionsStateMBeanHandler.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleRevisionsStateMBeanHandler.java
@@ -1,3 +1,79 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import javax.management.NotCompliantMBeanException;
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.MBeanHandler;
+import org.apache.aries.jmx.util.shared.RegistrableStandardEmitterMBean;
+import org.osgi.framework.BundleContext;
+import org.osgi.jmx.framework.BundleRevisionsStateMBean;
+import org.osgi.service.log.LogService;
+
+public class BundleRevisionsStateMBeanHandler implements MBeanHandler {
+    private final String name;
+    private final BundleContext bundleContext;
+    private final Logger logger;
+
+    private StandardMBean mbean;
+    private BundleRevisionsState revisionsStateMBean;
+
+    public BundleRevisionsStateMBeanHandler(BundleContext bundleContext, Logger logger) {
+        this.bundleContext = bundleContext;
+        this.logger = logger;
+        this.name = BundleRevisionsStateMBean.OBJECTNAME;
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.aries.jmx.MBeanHandler#open()
+     */
+    public void open() {
+        revisionsStateMBean = new BundleRevisionsState(bundleContext, logger);
+        try {
+            mbean = new RegistrableStandardEmitterMBean(revisionsStateMBean, BundleRevisionsStateMBean.class);
+        } catch (NotCompliantMBeanException e) {
+            logger.log(LogService.LOG_ERROR, "Failed to instantiate MBean for " + BundleRevisionsStateMBean.class.getName(), e);
+        }
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.aries.jmx.MBeanHandler#getMbean()
+     */
+    public StandardMBean getMbean() {
+        return mbean;
+    }
+
+
+    /* (non-Javadoc)
+     * @see org.apache.aries.jmx.MBeanHandler#close()
+     */
+    public void close() {
+        // not used
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.aries.jmx.MBeanHandler#getName()
+     */
+    public String getName() {
+        return name;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleState.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleState.java
index b56de2e8..092cf664 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleState.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleState.java
@@ -1,3 +1,404 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import static org.apache.aries.jmx.util.FrameworkUtils.getBundleDependencies;
+import static org.apache.aries.jmx.util.FrameworkUtils.getBundleExportedPackages;
+import static org.apache.aries.jmx.util.FrameworkUtils.getBundleImportedPackages;
+import static org.apache.aries.jmx.util.FrameworkUtils.getBundleState;
+import static org.apache.aries.jmx.util.FrameworkUtils.getDependentBundles;
+import static org.apache.aries.jmx.util.FrameworkUtils.getFragmentIds;
+import static org.apache.aries.jmx.util.FrameworkUtils.getHostIds;
+import static org.apache.aries.jmx.util.FrameworkUtils.getRegisteredServiceIds;
+import static org.apache.aries.jmx.util.FrameworkUtils.getServicesInUseByBundle;
+import static org.apache.aries.jmx.util.FrameworkUtils.isBundlePendingRemoval;
+import static org.apache.aries.jmx.util.FrameworkUtils.isBundleRequiredByOthers;
+import static org.apache.aries.jmx.util.FrameworkUtils.resolveBundle;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Dictionary;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+import javax.management.MBeanNotificationInfo;
+import javax.management.MBeanRegistration;
+import javax.management.MBeanServer;
+import javax.management.Notification;
+import javax.management.NotificationBroadcasterSupport;
+import javax.management.ObjectName;
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularDataSupport;
+
+import org.apache.aries.jmx.JMXThreadFactory;
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.codec.BundleData;
+import org.apache.aries.jmx.codec.BundleData.Header;
+import org.apache.aries.jmx.codec.BundleEventData;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.BundleEvent;
+import org.osgi.framework.BundleListener;
+import org.osgi.jmx.framework.BundleStateMBean;
+import org.osgi.service.log.LogService;
+import org.osgi.service.packageadmin.PackageAdmin;
+import org.osgi.service.startlevel.StartLevel;
+
+/**
+ * Implementation of <code>BundleStateMBean</code> which emits JMX <code>Notification</code> on <code>Bundle</code>
+ * state changes.
+ *
+ * @version $Rev$ $Date$
+ */
+public class BundleState extends NotificationBroadcasterSupport implements BundleStateMBean, MBeanRegistration {
+
+    protected Logger logger;
+    protected BundleContext bundleContext;
+    protected PackageAdmin packageAdmin;
+    protected StartLevel startLevel;
+
+    protected ExecutorService eventDispatcher;
+    protected BundleListener bundleListener;
+    private AtomicInteger notificationSequenceNumber = new AtomicInteger(1);
+    private Lock lock = new ReentrantLock();
+    private AtomicInteger registrations = new AtomicInteger(0);
+
+    // notification type description
+    public static String BUNDLE_EVENT = "org.osgi.bundle.event";
+
+    public BundleState(BundleContext bundleContext, PackageAdmin packageAdmin, StartLevel startLevel, Logger logger) {
+        this.bundleContext = bundleContext;
+        this.packageAdmin = packageAdmin;
+        this.startLevel = startLevel;
+        this.logger = logger;
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#getExportedPackages(long)
+     */
+    public String[] getExportedPackages(long bundleId) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        return getBundleExportedPackages(bundle, packageAdmin);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#getFragments(long)
+     */
+    public long[] getFragments(long bundleId) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        return getFragmentIds(bundle, packageAdmin);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#getHeaders(long)
+     */
+    @SuppressWarnings("unchecked")
+    public TabularData getHeaders(long bundleId) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        List<Header> headers = new ArrayList<Header>();
+        Dictionary<String, String> bundleHeaders = bundle.getHeaders();
+        Enumeration<String> keys = bundleHeaders.keys();
+        while (keys.hasMoreElements()) {
+            String key = keys.nextElement();
+            headers.add(new Header(key, bundleHeaders.get(key)));
+        }
+        TabularData headerTable = new TabularDataSupport(HEADERS_TYPE);
+        for (Header header : headers) {
+            headerTable.put(header.toCompositeData());
+        }
+        return headerTable;
+    }
+
+    public String getHeader(long bundleId, String key) throws IOException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        return bundle.getHeaders().get(key);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#getHosts(long)
+     */
+    public long[] getHosts(long fragmentId) throws IOException, IllegalArgumentException {
+        Bundle fragment = resolveBundle(bundleContext, fragmentId);
+        return getHostIds(fragment, packageAdmin);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#getImportedPackages(long)
+     */
+    public String[] getImportedPackages(long bundleId) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        return getBundleImportedPackages(bundleContext, bundle, packageAdmin);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#getLastModified(long)
+     */
+    public long getLastModified(long bundleId) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        return bundle.getLastModified();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#getLocation(long)
+     */
+    public String getLocation(long bundleId) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        return bundle.getLocation();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#getRegisteredServices(long)
+     */
+    public long[] getRegisteredServices(long bundleId) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        return getRegisteredServiceIds(bundle);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#getRequiredBundles(long)
+     */
+    public long[] getRequiredBundles(long bundleIdentifier) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleIdentifier);
+        return getBundleDependencies(bundleContext, bundle, packageAdmin);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#getRequiringBundles(long)
+     */
+    public long[] getRequiringBundles(long bundleIdentifier) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleIdentifier);
+        return getDependentBundles(bundle, packageAdmin);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#getServicesInUse(long)
+     */
+    public long[] getServicesInUse(long bundleIdentifier) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleIdentifier);
+        return getServicesInUseByBundle(bundle);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#getStartLevel(long)
+     */
+    public int getStartLevel(long bundleId) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        return startLevel.getBundleStartLevel(bundle);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#getState(long)
+     */
+    public String getState(long bundleId) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        return getBundleState(bundle);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#getSymbolicName(long)
+     */
+    public String getSymbolicName(long bundleId) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        return bundle.getSymbolicName();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#getVersion(long)
+     */
+    public String getVersion(long bundleId) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        return bundle.getVersion().toString();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#isFragment(long)
+     */
+    public boolean isFragment(long bundleId) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        return (PackageAdmin.BUNDLE_TYPE_FRAGMENT == packageAdmin.getBundleType(bundle));
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#isPersistentlyStarted(long)
+     */
+    public boolean isPersistentlyStarted(long bundleId) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        return startLevel.isBundlePersistentlyStarted(bundle);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#isRemovalPending(long)
+     */
+    public boolean isRemovalPending(long bundleId) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        return isBundlePendingRemoval(bundle, packageAdmin);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#isRequired(long)
+     */
+    public boolean isRequired(long bundleId) throws IOException, IllegalArgumentException {
+        Bundle bundle = resolveBundle(bundleContext, bundleId);
+        return isBundleRequiredByOthers(bundle, packageAdmin);
+    }
+
+
+
+    public CompositeData getBundle(long id) throws IOException {
+        Bundle bundle = bundleContext.getBundle(id);
+        if (bundle == null)
+            return null;
+
+        BundleData data = new BundleData(bundleContext, bundle, packageAdmin, startLevel);
+        return data.toCompositeData();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.BundleStateMBean#listBundles()
+     */
+    public TabularData listBundles() throws IOException {
+        return listBundles(BundleStateMBean.BUNDLE_TYPE.keySet());
+    }
+
+    public TabularData listBundles(String ... items) throws IOException {
+        return listBundles(Arrays.asList(items));
+    }
+
+    private TabularData listBundles(Collection<String> items) throws IOException {
+        Bundle[] containerBundles = bundleContext.getBundles();
+        List<BundleData> bundleDatas = new ArrayList<BundleData>();
+        if (containerBundles != null) {
+            for (Bundle containerBundle : containerBundles) {
+                bundleDatas.add(new BundleData(bundleContext, containerBundle, packageAdmin, startLevel));
+            }
+        }
+        TabularData bundleTable = new TabularDataSupport(BUNDLES_TYPE);
+        for (BundleData bundleData : bundleDatas) {
+            bundleTable.put(bundleData.toCompositeData(items));
+        }
+        return bundleTable;
+    }
+
+    /**
+     * @see javax.management.NotificationBroadcasterSupport#getNotificationInfo()
+     */
+    public MBeanNotificationInfo[] getNotificationInfo() {
+        String[] types = new String[] { BUNDLE_EVENT };
+        String name = Notification.class.getName();
+        String description = "A BundleEvent issued from the Framework describing a bundle lifecycle change";
+        MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description);
+        return new MBeanNotificationInfo[] { info };
+    }
+
+    /**
+     * @see javax.management.MBeanRegistration#postDeregister()
+     */
+    public void postDeregister() {
+        if (registrations.decrementAndGet() < 1) {
+            shutDownDispatcher();
+        }
+    }
+
+    /**
+     * @see javax.management.MBeanRegistration#postRegister(java.lang.Boolean)
+     */
+    public void postRegister(Boolean registrationDone) {
+        if (registrationDone && registrations.incrementAndGet() == 1) {
+            eventDispatcher = Executors.newSingleThreadExecutor(new JMXThreadFactory("JMX OSGi Bundle State Event Dispatcher"));
+            bundleContext.addBundleListener(bundleListener);
+        }
+    }
+
+    /**
+     * @see javax.management.MBeanRegistration#preDeregister()
+     */
+    public void preDeregister() throws Exception {
+        // No action
+    }
+
+    /**
+     * @see javax.management.MBeanRegistration#preRegister(javax.management.MBeanServer, javax.management.ObjectName)
+     */
+    public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception {
+        lock.lock();
+        try {
+            if (bundleListener == null) {
+                bundleListener = new BundleListener() {
+                    public void bundleChanged(BundleEvent event) {
+                        final Notification notification = new Notification(EVENT, OBJECTNAME,
+                                notificationSequenceNumber.getAndIncrement());
+                        try {
+                            notification.setUserData(new BundleEventData(event).toCompositeData());
+                            eventDispatcher.submit(new Runnable() {
+                                public void run() {
+                                    sendNotification(notification);
+                                }
+                            });
+                        } catch (RejectedExecutionException re) {
+                            logger.log(LogService.LOG_WARNING, "Task rejected for JMX Notification dispatch of event ["
+                                    + event + "] - Dispatcher may have been shutdown");
+                        } catch (Exception e) {
+                            logger.log(LogService.LOG_WARNING,
+                                    "Exception occured on JMX Notification dispatch for event [" + event + "]", e);
+                        }
+                    }
+                };
+            }
+        } finally {
+            lock.unlock();
+        }
+        return name;
+    }
+
+    /*
+     * Shuts down the notification dispatcher
+     * [ARIES-259] MBeans not getting unregistered reliably
+     */
+    protected void shutDownDispatcher() {
+        if (bundleListener != null) {
+            try {
+               bundleContext.removeBundleListener(bundleListener);
+            }
+            catch (Exception e) {
+               // ignore
+            }
+        }
+        if (eventDispatcher != null) {
+            eventDispatcher.shutdown();
+        }
+    }
+
+    /*
+     * Returns the ExecutorService used to dispatch Notifications
+     */
+    protected ExecutorService getEventDispatcher() {
+        return eventDispatcher;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleStateMBeanHandler.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleStateMBeanHandler.java
index 6dc540c5..41a868ef 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleStateMBeanHandler.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/BundleStateMBeanHandler.java
@@ -1,3 +1,124 @@
   + Revision Date
   + native
   + text/plain
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import static org.osgi.jmx.framework.BundleStateMBean.OBJECTNAME;
+
+import javax.management.NotCompliantMBeanException;
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.MBeanHandler;
+import org.apache.aries.jmx.util.shared.RegistrableStandardEmitterMBean;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceReference;
+import org.osgi.jmx.framework.BundleStateMBean;
+import org.osgi.service.log.LogService;
+import org.osgi.service.packageadmin.PackageAdmin;
+import org.osgi.service.startlevel.StartLevel;
+
+/**
+ * <p>
+ * Implementation of <code>MBeanHandler</code> which manages the <code>BundleState</code>
+ * MBean implementation
+ * @see MBeanHandler
+ * </p> 
+ *
+ * @version $Rev$ $Date$
+ */
+public class BundleStateMBeanHandler implements MBeanHandler {
+
+    private Logger logger;
+    private String name;
+    private StandardMBean mbean;
+    private BundleState bundleStateMBean;
+    private BundleContext bundleContext;
+    private ServiceReference packageAdminRef;
+    private ServiceReference startLevelRef;
+    
+    
+    public BundleStateMBeanHandler(BundleContext bundleContext, Logger logger) {
+        this.bundleContext = bundleContext;
+        this.logger = logger;
+        this.name = OBJECTNAME;
+    }
+    
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#open()
+     */
+    public void open() {
+        packageAdminRef = bundleContext.getServiceReference(PackageAdmin.class.getName());
+        PackageAdmin packageAdmin = (PackageAdmin) bundleContext.getService(packageAdminRef);
+        startLevelRef = bundleContext.getServiceReference(StartLevel.class.getName());
+        StartLevel startLevel = (StartLevel) bundleContext.getService(startLevelRef);
+        bundleStateMBean = new BundleState(bundleContext, packageAdmin, startLevel, logger);
+        try {
+            mbean = new RegistrableStandardEmitterMBean(bundleStateMBean, BundleStateMBean.class);
+        } catch (NotCompliantMBeanException e) {
+            logger.log(LogService.LOG_ERROR, "Failed to instantiate MBean for " + BundleStateMBean.class.getName(), e);
+        }
+    }
+    
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#getMbean()
+     */
+    public StandardMBean getMbean() {
+       return mbean;
+    }
+    
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#getName()
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#close()
+     */
+    public void close() {
+        if (packageAdminRef != null) {
+            try {
+                bundleContext.ungetService(packageAdminRef);
+            } catch (RuntimeException e) {
+                logger.log(LogService.LOG_WARNING, "Exception occured during cleanup", e);
+            }
+            packageAdminRef = null;
+        }
+        if (startLevelRef != null) {
+            try {
+                bundleContext.ungetService(startLevelRef);
+            } catch (RuntimeException e) {
+                logger.log(LogService.LOG_WARNING, "Exception occured during cleanup", e);
+            }
+            startLevelRef = null;
+        }
+        // ensure dispatcher is shutdown even if postDeRegister is not honored
+        if (bundleStateMBean != null) {
+            bundleStateMBean.shutDownDispatcher();
+        }
+    }
+
+   
+
+   
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/Framework.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/Framework.java
index 17c97dcc..88ff2f38 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/Framework.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/Framework.java
@@ -1 +1,512 @@
   + text/plain
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+
+import javax.management.openmbean.CompositeData;
+
+import org.apache.aries.jmx.codec.BatchActionResult;
+import org.apache.aries.jmx.codec.BatchInstallResult;
+import org.apache.aries.jmx.util.FrameworkUtils;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.jmx.framework.FrameworkMBean;
+import org.osgi.service.packageadmin.PackageAdmin;
+import org.osgi.service.startlevel.StartLevel;
+
+/**
+ * <p>
+ * <tt>Framework</tt> represents {@link FrameworkMBean} implementation.
+ * </p>
+ * @see FrameworkMBean
+ * 
+ * @version $Rev$ $Date$
+ */
+public class Framework implements FrameworkMBean {
+
+    private StartLevel startLevel;
+    private PackageAdmin packageAdmin;
+    private BundleContext context;
+
+    /**
+     * Constructs new FrameworkMBean.
+     * 
+     * @param context bundle context of jmx bundle.
+     * @param startLevel @see {@link StartLevel} service reference.
+     * @param packageAdmin @see {@link PackageAdmin} service reference.
+     */
+    public Framework(BundleContext context, StartLevel startLevel, PackageAdmin packageAdmin) {
+        this.context = context;
+        this.startLevel = startLevel;
+        this.packageAdmin = packageAdmin;
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#getFrameworkStartLevel()
+     */
+    public int getFrameworkStartLevel() throws IOException {
+        return startLevel.getStartLevel();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#getInitialBundleStartLevel()
+     */
+    public int getInitialBundleStartLevel() throws IOException {
+        return startLevel.getInitialBundleStartLevel();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#installBundle(java.lang.String)
+     */
+    public long installBundle(String location) throws IOException {
+        try {
+            Bundle bundle = context.installBundle(location);
+            return bundle.getBundleId();
+        } catch (Exception e) {
+            IOException ioex = new IOException("Installation of a bundle with location " + location + " failed with the message: " + e.getMessage());
+            ioex.initCause(e);
+            throw ioex;
+        }
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#installBundleFromURL(String, String)
+     */
+    public long installBundleFromURL(String location, String url) throws IOException {
+        InputStream inputStream = null;
+        try {
+            inputStream = createStream(url);
+            Bundle bundle = context.installBundle(location, inputStream);
+            return bundle.getBundleId();
+        } catch (Exception e) {
+            IOException ioex = new IOException("Installation of a bundle with location " + location + " failed with the message: " + e.getMessage());
+            ioex.initCause(e);
+            throw ioex;
+        } finally {
+            if (inputStream != null) {
+                try {
+                    inputStream.close();
+                } catch (IOException ioe) {
+                }
+            }
+        }
+    }
+
+    public InputStream createStream(String url) throws IOException {
+        return new URL(url).openStream();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#installBundles(java.lang.String[])
+     */
+    public CompositeData installBundles(String[] locations) throws IOException {
+        if(locations == null){
+           return new BatchInstallResult("Failed to install bundles locations can't be null").toCompositeData(); 
+        }
+        long[] ids = new long[locations.length];
+        for (int i = 0; i < locations.length; i++) {
+            try {
+                long id = installBundle(locations[i]);
+                ids[i] = id;
+            } catch (Throwable t) {
+                long[] completed = new long[i];
+                System.arraycopy(ids, 0, completed, 0, i);
+                String[] remaining = new String[locations.length - i - 1];
+                System.arraycopy(locations, i + 1, remaining, 0, remaining.length);
+                return new BatchInstallResult(completed, t.toString(), remaining, locations[i]).toCompositeData();
+            }
+        }
+
+        return new BatchInstallResult(ids).toCompositeData();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#installBundlesFromURL(String[], String[])
+     */
+    public CompositeData installBundlesFromURL(String[] locations, String[] urls) throws IOException {
+        if(locations == null || urls == null){
+            return new BatchInstallResult("Failed to install bundles arguments can't be null").toCompositeData(); 
+        }
+        
+        if(locations.length != urls.length){
+            return new BatchInstallResult("Failed to install bundles size of arguments should be same").toCompositeData(); 
+        }
+        long[] ids = new long[locations.length];
+        for (int i = 0; i < locations.length; i++) {
+            try {
+                long id = installBundleFromURL(locations[i], urls[i]);
+                ids[i] = id;
+            } catch (Throwable t) {
+                long[] completed = new long[i];
+                System.arraycopy(ids, 0, completed, 0, i);
+                String[] remaining = new String[locations.length - i - 1];
+                System.arraycopy(locations, i + 1, remaining, 0, remaining.length);
+                return new BatchInstallResult(completed, t.toString(), remaining, locations[i]).toCompositeData();
+            }
+        }
+        return new BatchInstallResult(ids).toCompositeData();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#refreshBundle(long)
+     */
+    public void refreshBundle(long bundleIdentifier) throws IOException {
+        Bundle bundle = FrameworkUtils.resolveBundle(context, bundleIdentifier);
+        packageAdmin.refreshPackages(new Bundle[] { bundle });
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#refreshBundles(long[])
+     */
+    public void refreshBundles(long[] bundleIdentifiers) throws IOException {    
+       Bundle[] bundles = null;
+       if(bundleIdentifiers != null) {       
+          bundles = new Bundle[bundleIdentifiers.length];
+          for (int i = 0; i < bundleIdentifiers.length; i++) {  
+              try {
+                  bundles[i] = FrameworkUtils.resolveBundle(context, bundleIdentifiers[i]);
+              } catch (Exception e) {
+                  IOException ex = new IOException("Unable to find bundle with id " + bundleIdentifiers[i]);
+                  ex.initCause(e);
+                  throw ex;
+              }
+          }
+       }
+       packageAdmin.refreshPackages(bundles);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#resolveBundle(long)
+     */
+    public boolean resolveBundle(long bundleIdentifier) throws IOException {
+        Bundle bundle = FrameworkUtils.resolveBundle(context, bundleIdentifier);
+        return packageAdmin.resolveBundles(new Bundle[] { bundle });
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#resolveBundles(long[])
+     */
+    public boolean resolveBundles(long[] bundleIdentifiers) throws IOException {
+       Bundle[] bundles = null;
+       if(bundleIdentifiers != null) {       
+          bundles = new Bundle[bundleIdentifiers.length];
+          for (int i = 0; i < bundleIdentifiers.length; i++) {       
+              try {
+                  bundles[i] = FrameworkUtils.resolveBundle(context, bundleIdentifiers[i]);
+              } catch (Exception e) {
+                  IOException ex = new IOException("Unable to find bundle with id " + bundleIdentifiers[i]);
+                  ex.initCause(e);
+                  throw ex;
+              }
+          }
+       }
+       return packageAdmin.resolveBundles(bundles);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#restartFramework()
+     */
+    public void restartFramework() throws IOException {
+        Bundle bundle = FrameworkUtils.resolveBundle(context, 0);
+        try {
+            bundle.update();
+        } catch (Exception be) {
+            IOException ioex = new IOException("Framework restart failed with message: " + be.getMessage());
+            ioex.initCause(be);
+            throw ioex;
+        }
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#setBundleStartLevel(long, int)
+     */
+    public void setBundleStartLevel(long bundleIdentifier, int newlevel) throws IOException {
+        Bundle bundle = FrameworkUtils.resolveBundle(context, bundleIdentifier);
+        try {
+            startLevel.setBundleStartLevel(bundle, newlevel);
+        } catch (IllegalArgumentException e) {
+            IOException ioex = new IOException("Setting the start level for bundle with id " + bundle.getBundleId() + " to level " + newlevel + " failed with message: " + e.getMessage());
+            ioex.initCause(e);
+            throw ioex;
+        }
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#setBundleStartLevels(long[], int[])
+     */
+    public CompositeData setBundleStartLevels(long[] bundleIdentifiers, int[] newlevels) throws IOException {
+        if (bundleIdentifiers == null || newlevels == null) {
+            return new BatchActionResult("Failed to setBundleStartLevels arguments can't be null").toCompositeData(); 
+        }
+        
+        if (bundleIdentifiers != null && newlevels != null && bundleIdentifiers.length != newlevels.length) {
+            return new BatchActionResult("Failed to setBundleStartLevels size of arguments should be same").toCompositeData(); 
+        }
+        for (int i = 0; i < bundleIdentifiers.length; i++) {
+            try {
+                setBundleStartLevel(bundleIdentifiers[i], newlevels[i]);
+            } catch (Throwable t) {
+                return createFailedBatchActionResult(bundleIdentifiers, i, t);
+            }
+        }
+        return new BatchActionResult(bundleIdentifiers).toCompositeData();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#setFrameworkStartLevel(int)
+     */
+    public void setFrameworkStartLevel(int newlevel) throws IOException {
+        try {
+            startLevel.setStartLevel(newlevel);
+        } catch (Exception e) {
+            IOException ioex = new IOException("Setting the framework start level to " + newlevel + " failed with message: " + e.getMessage());
+            ioex.initCause(e);
+            throw ioex;
+        }
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#setInitialBundleStartLevel(int)
+     */
+    public void setInitialBundleStartLevel(int newlevel) throws IOException {
+        try {
+            startLevel.setInitialBundleStartLevel(newlevel);
+        } catch (Exception e) {
+            IOException ioex = new IOException("Setting the initial start level to " + newlevel + " failed with message: " + e.getMessage());
+            ioex.initCause(e);
+            throw ioex;
+        }        
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#shutdownFramework()
+     */
+    public void shutdownFramework() throws IOException {
+        Bundle bundle = FrameworkUtils.resolveBundle(context, 0);
+        try {
+            bundle.stop();
+        } catch (Exception be) {
+            IOException ioex = new IOException("Stopping the framework failed with message: " + be.getMessage());
+            ioex.initCause(be);
+            throw ioex;
+        }
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#startBundle(long)
+     */
+    public void startBundle(long bundleIdentifier) throws IOException {
+        Bundle bundle = FrameworkUtils.resolveBundle(context, bundleIdentifier);
+        try {
+            bundle.start();
+        } catch (Exception be) {
+            IOException ioex = new IOException("Start of bundle with id " + bundleIdentifier + " failed with message: " + be.getMessage());
+            ioex.initCause(be);
+            throw ioex;
+        }
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#startBundles(long[])
+     */
+    public CompositeData startBundles(long[] bundleIdentifiers) throws IOException {
+        if (bundleIdentifiers == null) {
+            return new BatchActionResult("Failed to start bundles, bundle id's can't be null").toCompositeData(); 
+        }
+        for (int i = 0; i < bundleIdentifiers.length; i++) {
+            try {
+                startBundle(bundleIdentifiers[i]);
+            } catch (Throwable t) {
+                return createFailedBatchActionResult(bundleIdentifiers, i, t);
+            }
+        }
+        return new BatchActionResult(bundleIdentifiers).toCompositeData();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#stopBundle(long)
+     */
+    public void stopBundle(long bundleIdentifier) throws IOException {
+        Bundle bundle = FrameworkUtils.resolveBundle(context, bundleIdentifier);
+        try {
+            bundle.stop();
+        } catch (Exception e) {
+            IOException ioex = new IOException("Stop of bundle with id " + bundleIdentifier + " failed with message: " + e.getMessage());
+            ioex.initCause(e);
+            throw ioex;
+        }
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#stopBundles(long[])
+     */
+    public CompositeData stopBundles(long[] bundleIdentifiers) throws IOException {
+        if (bundleIdentifiers == null) {
+            return new BatchActionResult("Failed to stop bundles, bundle id's can't be null").toCompositeData(); 
+        }
+        for (int i = 0; i < bundleIdentifiers.length; i++) {
+            try {
+                stopBundle(bundleIdentifiers[i]);
+            } catch (Throwable t) {
+                return createFailedBatchActionResult(bundleIdentifiers, i, t);
+            }
+        }
+        return new BatchActionResult(bundleIdentifiers).toCompositeData();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#uninstallBundle(long)
+     */
+    public void uninstallBundle(long bundleIdentifier) throws IOException {
+        Bundle bundle = FrameworkUtils.resolveBundle(context, bundleIdentifier);
+        try {
+            bundle.uninstall();
+        } catch (Exception be) {
+            IOException ioex = new IOException("Uninstall of bundle with id " + bundleIdentifier + " failed with message: " + be.getMessage());
+            ioex.initCause(be);
+            throw ioex;
+        }
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#uninstallBundles(long[])
+     */
+    public CompositeData uninstallBundles(long[] bundleIdentifiers) throws IOException {
+        if (bundleIdentifiers == null) {
+            return new BatchActionResult("Failed uninstall bundles, bundle id's can't be null").toCompositeData(); 
+        }
+        for (int i = 0; i < bundleIdentifiers.length; i++) {
+            try {
+                uninstallBundle(bundleIdentifiers[i]);
+            } catch (Throwable t) {
+                return createFailedBatchActionResult(bundleIdentifiers, i, t);
+            }
+        }
+        return new BatchActionResult(bundleIdentifiers).toCompositeData();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#updateBundle(long)
+     */
+    public void updateBundle(long bundleIdentifier) throws IOException {
+        Bundle bundle = FrameworkUtils.resolveBundle(context, bundleIdentifier);
+        try {
+            bundle.update();
+        } catch (Exception be) {
+            IOException ioex = new IOException("Update of bundle with id " + bundleIdentifier + " failed with message: " + be.getMessage());
+            ioex.initCause(be);
+            throw ioex;
+        }
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#updateBundleFromURL(long, String)
+     */
+    public void updateBundleFromURL(long bundleIdentifier, String url) throws IOException {
+        Bundle bundle = FrameworkUtils.resolveBundle(context, bundleIdentifier);
+        InputStream inputStream = null;
+        try {
+            inputStream = createStream(url);
+            bundle.update(inputStream);
+        } catch (Exception be) {
+            IOException ioex = new IOException("Update of bundle with id " + bundleIdentifier + " from url " + url + " failed with message: " + be.getMessage());
+            ioex.initCause(be);
+            throw ioex;
+        } finally {
+            if (inputStream != null) {
+                try {
+                    inputStream.close();
+                } catch (IOException ioe) {
+
+                }
+            }          
+        }
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#updateBundles(long[])
+     */
+    public CompositeData updateBundles(long[] bundleIdentifiers) throws IOException {
+        if (bundleIdentifiers == null) {
+            return new BatchActionResult("Failed to update bundles, bundle id's can't be null").toCompositeData();
+        }
+        for (int i = 0; i < bundleIdentifiers.length; i++) {
+            try {
+                updateBundle(bundleIdentifiers[i]);
+            } catch (Throwable t) {
+                return createFailedBatchActionResult(bundleIdentifiers, i, t);
+            }
+        }
+        return new BatchActionResult(bundleIdentifiers).toCompositeData();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#updateBundlesFromURL(long[], String[])
+     */
+    public CompositeData updateBundlesFromURL(long[] bundleIdentifiers, String[] urls) throws IOException {
+        if(bundleIdentifiers == null || urls == null){
+            return new BatchActionResult("Failed to update bundles arguments can't be null").toCompositeData(); 
+        }
+        
+        if(bundleIdentifiers != null && urls != null && bundleIdentifiers.length != urls.length){
+            return new BatchActionResult("Failed to update bundles size of arguments should be same").toCompositeData(); 
+        }
+        for (int i = 0; i < bundleIdentifiers.length; i++) {
+            try {
+                updateBundleFromURL(bundleIdentifiers[i], urls[i]);
+            } catch (Throwable t) {
+                return createFailedBatchActionResult(bundleIdentifiers, i, t);
+            }
+        }
+        return new BatchActionResult(bundleIdentifiers).toCompositeData();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.FrameworkMBean#updateFramework()
+     */
+    public void updateFramework() throws IOException {
+        Bundle bundle = FrameworkUtils.resolveBundle(context, 0);
+        try {
+            bundle.update();
+        } catch (Exception be) {
+            IOException ioex = new IOException("Update of framework bundle failed with message: " + be.getMessage());
+            ioex.initCause(be);
+            throw ioex;
+        }
+    }
+
+    /**
+     * Create {@link BatchActionResult}, when the operation fail.
+     * 
+     * @param bundleIdentifiers bundle ids for operation.
+     * @param i index of loop pointing on which operation fails.
+     * @param t Throwable thrown by failed operation.
+     * @return created BatchActionResult instance.
+     */
+    private CompositeData createFailedBatchActionResult(long[] bundleIdentifiers, int i, Throwable t) {
+        long[] completed = new long[i];
+        System.arraycopy(bundleIdentifiers, 0, completed, 0, i);
+        long[] remaining = new long[bundleIdentifiers.length - i - 1];
+        System.arraycopy(bundleIdentifiers, i + 1, remaining, 0, remaining.length);
+        return new BatchActionResult(completed, t.toString(), remaining, bundleIdentifiers[i]).toCompositeData();
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/FrameworkMBeanHandler.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/FrameworkMBeanHandler.java
index b56de2e8..eeb70f29 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/FrameworkMBeanHandler.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/FrameworkMBeanHandler.java
@@ -1,3 +1,99 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import javax.management.NotCompliantMBeanException;
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.MBeanHandler;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceReference;
+import org.osgi.jmx.framework.FrameworkMBean;
+import org.osgi.service.log.LogService;
+import org.osgi.service.packageadmin.PackageAdmin;
+import org.osgi.service.startlevel.StartLevel;
+
+/**
+ * <p>
+ * <tt>FrameworkMBeanHandler</tt> represents MBeanHandler which
+ * holding information about {@link FrameworkMBean}.</p>
+ * 
+ * @see MBeanHandler
+ * 
+ * @version $Rev$ $Date$
+ */
+public class FrameworkMBeanHandler implements MBeanHandler {
+
+    private String name;
+    private StandardMBean mbean;
+    private BundleContext context;
+    private Logger logger;
+
+    /**
+     * Constructs new FrameworkMBeanHandler.
+     * 
+     * @param context bundle context of JMX bundle.
+     * @param logger @see {@link Logger}.
+     */
+    public FrameworkMBeanHandler(BundleContext context, Logger logger) {
+        this.context = context;
+        this.name = FrameworkMBean.OBJECTNAME;
+        this.logger = logger;
+    }
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#getMbean()
+     */
+    public StandardMBean getMbean() {
+        return mbean;
+    }
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#open()
+     */
+    public void open() {
+        ServiceReference adminRef = context.getServiceReference(PackageAdmin.class.getCanonicalName());
+        PackageAdmin packageAdmin = (PackageAdmin) context.getService(adminRef);
+        ServiceReference startLevelRef = context.getServiceReference(StartLevel.class.getCanonicalName());
+        StartLevel startLevel = (StartLevel) context.getService(startLevelRef);
+        FrameworkMBean framework = new Framework(context, startLevel, packageAdmin);
+        try {
+            mbean = new StandardMBean(framework, FrameworkMBean.class);
+        } catch (NotCompliantMBeanException e) {
+            logger.log(LogService.LOG_ERROR, "Not compliant MBean", e);
+        }
+    }
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#close()
+     */
+    public void close() {
+        //not used
+    }
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#getName()
+     */
+    public String getName() {
+        return name;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/PackageState.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/PackageState.java
index 17c97dcc..131ca07e 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/PackageState.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/PackageState.java
@@ -1 +1,149 @@
   + text/plain
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import javax.management.openmbean.TabularData;
+
+import org.apache.aries.jmx.codec.PackageData;
+import org.apache.aries.jmx.util.FrameworkUtils;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Version;
+import org.osgi.jmx.framework.PackageStateMBean;
+import org.osgi.service.packageadmin.ExportedPackage;
+import org.osgi.service.packageadmin.PackageAdmin;
+
+/**
+ * <p>
+ * <tt>PackageState</tt> represents implementation of PackageStateMBean.
+ * </p>
+ * 
+ * @see PackageStateMBean
+ * 
+ * @version $Rev$ $Date$
+ */
+public class PackageState implements PackageStateMBean {
+
+    /**
+     * {@link PackageAdmin} service reference.
+     */
+    private PackageAdmin packageAdmin;
+    private BundleContext context;
+
+    /**
+     * Constructs new PackagesState MBean.
+     * 
+     * @param context bundle context.
+     * @param packageAdmin {@link PackageAdmin} service reference.
+     */
+    public PackageState(BundleContext context, PackageAdmin packageAdmin) {
+        this.context = context;
+        this.packageAdmin = packageAdmin;
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.PackageStateMBean#getExportingBundles(String, String)
+     */
+    public long[] getExportingBundles(String packageName, String version) throws IOException {
+        if (packageName == null || packageName.length() < 1) {
+            throw new IOException("Package name cannot be null or empty");
+        }
+        ExportedPackage[] exportedPackages = packageAdmin.getExportedPackages(packageName);
+        if (exportedPackages != null) {
+            Version ver = Version.parseVersion(version);
+            List<Bundle> exportingBundles = new ArrayList<Bundle>();
+            for (ExportedPackage exportedPackage : exportedPackages) {
+                if (exportedPackage.getVersion().equals(ver)) {
+                    Bundle bundle  = exportedPackage.getExportingBundle();
+                    exportingBundles.add(bundle);
+                }
+            }
+            
+            return FrameworkUtils.getBundleIds(exportingBundles);
+        }
+        return null;
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.PackageStateMBean#getImportingBundles(String, String, long)
+     */
+    public long[] getImportingBundles(String packageName, String version, long exportingBundle) throws IOException {
+        if (packageName == null || packageName.length() < 1) {
+            throw new IOException("Package name cannot be null or empty");
+        }
+        ExportedPackage[] exportedPackages = packageAdmin.getExportedPackages(packageName);
+        if (exportedPackages != null) {
+            Version ver = Version.parseVersion(version);
+            for (ExportedPackage exportedPackage : exportedPackages) {
+                if (exportedPackage.getVersion().equals(ver)
+                        && exportedPackage.getExportingBundle().getBundleId() == exportingBundle) {
+                    Bundle[] bundles = exportedPackage.getImportingBundles();
+                    if (bundles != null) {
+                        return FrameworkUtils.getBundleIds(bundles);
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.PackageStateMBean#isRemovalPending(String, String, long)
+     */
+    public boolean isRemovalPending(String packageName, String version, long exportingBundle) throws IOException {
+        if (packageName == null || packageName.length() < 1) {
+            throw new IOException("Package name cannot be null or empty");
+        }
+        ExportedPackage[] exportedPackages = packageAdmin.getExportedPackages(packageName);
+        if (exportedPackages != null) {
+            Version ver = Version.parseVersion(version);
+            for (ExportedPackage exportedPackage : exportedPackages) {
+                if (exportedPackage.getVersion().equals(ver)
+                        && exportedPackage.getExportingBundle().getBundleId() == exportingBundle
+                        && exportedPackage.isRemovalPending()) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.PackageStateMBean#listPackages()
+     */
+    public TabularData listPackages() throws IOException {
+        Set<PackageData> packages = new HashSet<PackageData>();
+        for (Bundle bundle : context.getBundles()) {
+            ExportedPackage[] exportedPackages = packageAdmin.getExportedPackages(bundle);
+            if (exportedPackages != null) {
+                for (ExportedPackage exportedPackage : exportedPackages) {
+                    packages.add(new PackageData(exportedPackage));
+                }
+            }
+
+        }
+        return PackageData.tableFrom(packages);
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/PackageStateMBeanHandler.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/PackageStateMBeanHandler.java
index b56de2e8..df70f730 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/PackageStateMBeanHandler.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/PackageStateMBeanHandler.java
@@ -1,3 +1,97 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import javax.management.NotCompliantMBeanException;
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.MBeanHandler;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceReference;
+import org.osgi.jmx.framework.PackageStateMBean;
+import org.osgi.service.log.LogService;
+import org.osgi.service.packageadmin.PackageAdmin;
+
+/**
+ * <p>
+ * <tt>PackageStateMBeanHandler</tt> represents MBeanHandler which
+ * holding information about {@link PackageStateMBean}.</p>
+ * 
+ * @see MBeanHandler
+ *
+ * @version $Rev$ $Date$
+ */
+public class PackageStateMBeanHandler implements MBeanHandler {
+
+    private String name;
+    private StandardMBean mbean;
+    private BundleContext context;
+    private Logger logger;
+
+    /**
+     * Constructs new PackageStateMBeanHandler.
+     * 
+     * @param context bundle context of JMX bundle.
+     * @param logger @see {@link Logger}.
+     */
+    public PackageStateMBeanHandler(BundleContext context, Logger logger) {
+        this.context = context;
+        this.name = PackageStateMBean.OBJECTNAME;
+        this.logger = logger;
+    }
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#getMbean()
+     */
+    public StandardMBean getMbean() {
+        return mbean;
+    }
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#open()
+     */
+    public void open() {
+        ServiceReference adminRef = context.getServiceReference(PackageAdmin.class.getCanonicalName());
+        PackageAdmin packageAdmin = (PackageAdmin) context.getService(adminRef);
+        PackageStateMBean packageState = new PackageState(context, packageAdmin);
+        try {
+            mbean = new StandardMBean(packageState, PackageStateMBean.class);
+        } catch (NotCompliantMBeanException e) {
+            logger.log(LogService.LOG_ERROR, "Not compliant MBean", e);
+        }
+    }
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#close()
+     */
+    public void close() {
+        //not used
+    }
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#getName()
+     */
+    public String getName() {
+        return name;
+    }
+
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/ServiceState.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/ServiceState.java
index b56de2e8..877365bf 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/ServiceState.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/ServiceState.java
@@ -1,3 +1,236 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import static org.apache.aries.jmx.util.FrameworkUtils.getBundleIds;
+import static org.apache.aries.jmx.util.FrameworkUtils.resolveService;
+import static org.osgi.jmx.JmxConstants.PROPERTIES_TYPE;
+
+import java.io.IOException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+
+import javax.management.MBeanNotificationInfo;
+import javax.management.MBeanRegistration;
+import javax.management.MBeanServer;
+import javax.management.Notification;
+import javax.management.NotificationBroadcasterSupport;
+import javax.management.ObjectName;
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularDataSupport;
+
+import org.apache.aries.jmx.JMXThreadFactory;
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.codec.PropertyData;
+import org.apache.aries.jmx.codec.ServiceData;
+import org.apache.aries.jmx.codec.ServiceEventData;
+import org.osgi.framework.AllServiceListener;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Constants;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.ServiceEvent;
+import org.osgi.framework.ServiceReference;
+import org.osgi.jmx.framework.ServiceStateMBean;
+import org.osgi.service.log.LogService;
+
+/**
+ * Implementation of <code>ServiceStateMBean</code> which emits JMX <code>Notification</code> for framework
+ * <code>ServiceEvent</code> events
+ * 
+ * @version $Rev$ $Date$
+ */
+public class ServiceState extends NotificationBroadcasterSupport implements ServiceStateMBean, MBeanRegistration {
+
+    protected Logger logger;
+    private BundleContext bundleContext;
+
+    protected ExecutorService eventDispatcher;
+    protected AllServiceListener serviceListener;
+    private AtomicInteger notificationSequenceNumber = new AtomicInteger(1);
+    private AtomicInteger registrations = new AtomicInteger(0);
+    private Lock lock = new ReentrantLock();
+    // notification type description
+    public static String SERVICE_EVENT = "org.osgi.service.event";
+
+    public ServiceState(BundleContext bundleContext, Logger logger) {
+        if (bundleContext == null) {
+            throw new IllegalArgumentException("Argument bundleContext cannot be null");
+        }
+        this.bundleContext = bundleContext;
+        this.logger = logger;
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.ServiceStateMBean#getBundleIdentifier(long)
+     */
+    public long getBundleIdentifier(long serviceId) throws IOException {
+        ServiceReference reference = resolveService(bundleContext, serviceId);
+        return reference.getBundle().getBundleId();
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.ServiceStateMBean#getObjectClass(long)
+     */
+    public String[] getObjectClass(long serviceId) throws IOException {
+        ServiceReference reference = resolveService(bundleContext, serviceId);
+        return (String[]) reference.getProperty(Constants.OBJECTCLASS);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.ServiceStateMBean#getProperties(long)
+     */
+    public TabularData getProperties(long serviceId) throws IOException {
+        ServiceReference reference = resolveService(bundleContext, serviceId);
+        TabularData propertiesTable = new TabularDataSupport(PROPERTIES_TYPE);
+        for (String propertyKey : reference.getPropertyKeys()) {
+            propertiesTable.put(PropertyData.newInstance(propertyKey, reference.getProperty(propertyKey))
+                    .toCompositeData());
+        }
+        return propertiesTable;
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.ServiceStateMBean#getUsingBundles(long)
+     */
+    public long[] getUsingBundles(long serviceId) throws IOException {
+        ServiceReference reference = resolveService(bundleContext, serviceId);
+        Bundle[] usingBundles = reference.getUsingBundles();
+        return getBundleIds(usingBundles);
+    }
+
+    /**
+     * @see org.osgi.jmx.framework.ServiceStateMBean#listServices()
+     */
+    public TabularData listServices() throws IOException {
+        TabularData servicesTable = new TabularDataSupport(SERVICES_TYPE);
+        ServiceReference[] allServiceReferences = null;
+        try {
+            allServiceReferences = bundleContext.getAllServiceReferences(null, null);
+        } catch (InvalidSyntaxException e) {
+            throw new IllegalStateException("Failed to retrieve all service references", e);
+        }
+        if (allServiceReferences != null) {
+            for (ServiceReference reference : allServiceReferences) {
+                servicesTable.put(new ServiceData(reference).toCompositeData());
+            }
+        }
+        return servicesTable;
+    }
+
+    /**
+     * @see javax.management.NotificationBroadcasterSupport#getNotificationInfo()
+     */
+    public MBeanNotificationInfo[] getNotificationInfo() {
+        String[] types = new String[] { SERVICE_EVENT };
+        String name = Notification.class.getName();
+        String description = "A ServiceEvent issued from the Framework describing a service lifecycle change";
+        MBeanNotificationInfo info = new MBeanNotificationInfo(types, name, description);
+        return new MBeanNotificationInfo[] { info };
+    }
+
+    /**
+     * @see javax.management.MBeanRegistration#postDeregister()
+     */
+    public void postDeregister() {
+        if (registrations.decrementAndGet() < 1) {
+            shutDownDispatcher();
+        }
+    }
+
+    /**
+     * @see javax.management.MBeanRegistration#postRegister(java.lang.Boolean)
+     */
+    public void postRegister(Boolean registrationDone) {
+        if (registrationDone && registrations.incrementAndGet() == 1) {
+            eventDispatcher = Executors.newSingleThreadExecutor(new JMXThreadFactory("JMX OSGi Service State Event Dispatcher"));
+            bundleContext.addServiceListener(serviceListener);
+        }
+    }
+
+    public void preDeregister() throws Exception {
+        // No action
+    }
+
+    /**
+     * @see javax.management.MBeanRegistration#preRegister(javax.management.MBeanServer, javax.management.ObjectName)
+     */
+    public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception {
+        lock.lock();
+        try {
+            if (serviceListener == null) {
+                serviceListener = new AllServiceListener() {
+                    public void serviceChanged(ServiceEvent serviceevent) {
+                        final Notification notification = new Notification(EVENT, OBJECTNAME,
+                                notificationSequenceNumber.getAndIncrement());
+                        try {
+                            notification.setUserData(new ServiceEventData(serviceevent).toCompositeData());
+                            eventDispatcher.submit(new Runnable() {
+                                public void run() {
+                                    sendNotification(notification);
+                                }
+                            });
+                        } catch (RejectedExecutionException re) {
+                            logger.log(LogService.LOG_WARNING, "Task rejected for JMX Notification dispatch of event ["
+                                    + serviceevent + "] - Dispatcher may have been shutdown");
+                        } catch (Exception e) {
+                            logger.log(LogService.LOG_WARNING,
+                                    "Exception occured on JMX Notification dispatch for event [" + serviceevent + "]",
+                                    e);
+                        }
+                    }
+                };
+            }
+        } finally {
+            lock.unlock();
+        }
+        return name;
+    }
+
+    /*
+     * Shuts down the notification dispatcher
+     * [ARIES-259] MBeans not getting unregistered reliably
+     */
+    protected void shutDownDispatcher() {
+        if (serviceListener != null) {
+            try {
+               bundleContext.removeServiceListener(serviceListener);
+            }
+            catch (Exception e) {
+               // ignore
+            }
+        }
+        if (eventDispatcher != null) {  
+            eventDispatcher.shutdown();
+        }
+    }
+
+    /*
+     * Returns the ExecutorService used to dispatch Notifications
+     */
+    protected ExecutorService getEventDispatcher() {
+        return eventDispatcher;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/ServiceStateMBeanHandler.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/ServiceStateMBeanHandler.java
index 1f8bddab..40881060 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/ServiceStateMBeanHandler.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/framework/ServiceStateMBeanHandler.java
@@ -1,3 +1,96 @@
   + native
   + text/plain
   + Revision Date
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import static org.osgi.jmx.framework.ServiceStateMBean.OBJECTNAME;
+
+import javax.management.NotCompliantMBeanException;
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.MBeanHandler;
+import org.apache.aries.jmx.util.shared.RegistrableStandardEmitterMBean;
+import org.osgi.framework.BundleContext;
+import org.osgi.jmx.framework.ServiceStateMBean;
+import org.osgi.service.log.LogService;
+
+/**
+ * <p>
+ * Implementation of <code>MBeanHandler</code> which manages the <code>ServiceState</code>
+ * MBean implementation
+ * @see MBeanHandler
+ * </p> 
+ *
+ * @version $Rev$ $Date$
+ */
+public class ServiceStateMBeanHandler implements MBeanHandler {
+
+    private String name;
+    private StandardMBean mbean;
+    private ServiceState serviceStateMBean;
+    private BundleContext bundleContext;
+    private Logger logger;
+    
+    
+    public ServiceStateMBeanHandler(BundleContext bundleContext, Logger logger) {
+        this.bundleContext = bundleContext;
+        this.logger = logger;
+        this.name = OBJECTNAME;
+    }
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#open()
+     */
+    public void open() {
+        serviceStateMBean = new ServiceState(bundleContext, logger);
+        try {
+            mbean = new RegistrableStandardEmitterMBean(serviceStateMBean, ServiceStateMBean.class);
+        } catch (NotCompliantMBeanException e) {
+            logger.log(LogService.LOG_ERROR, "Failed to instantiate MBean for " + ServiceStateMBean.class.getName(), e);
+        }
+    }
+    
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#getMbean()
+     */
+    public StandardMBean getMbean() {
+        return mbean;
+    }
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#getName()
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#close()
+     */
+    public void close() {
+       // ensure dispatcher is shutdown even if postDeRegister is not honored
+       if (serviceStateMBean != null) {
+           serviceStateMBean.shutDownDispatcher();
+       }
+    }
+    
+    
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/permissionadmin/PermissionAdmin.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/permissionadmin/PermissionAdmin.java
index b56de2e8..b2dea7b1 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/permissionadmin/PermissionAdmin.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/permissionadmin/PermissionAdmin.java
@@ -1,3 +1,129 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.permissionadmin;
+
+import java.io.IOException;
+
+import org.osgi.jmx.service.permissionadmin.PermissionAdminMBean;
+import org.osgi.service.permissionadmin.PermissionInfo;
+
+/**
+ * <p>
+ * <tt>PermissionAdmin</tt> represents implementation of PermissionAdminMBean.
+ * </p>
+ * @see PermissionAdminMBean
+ * 
+ * @version $Rev$ $Date$
+ */
+public class PermissionAdmin implements PermissionAdminMBean {
+
+    /**
+     * {@link org.osgi.service.permissionadmin.PermissionAdmin} service.
+     */
+    private org.osgi.service.permissionadmin.PermissionAdmin permAdmin;
+
+    /**
+     * Constructs new PermissionAdmin MBean. 
+     * 
+     * @param permAdmin {@link org.osgi.service.permissionadmin.PermissionAdmin} service reference.
+     */
+    public PermissionAdmin(org.osgi.service.permissionadmin.PermissionAdmin permAdmin) {
+        this.permAdmin = permAdmin;
+    }
+
+    /**
+     * @see org.osgi.jmx.service.permissionadmin.PermissionAdminMBean#getPermissions(java.lang.String)
+     */
+    public String[] getPermissions(String location) throws IOException {
+        if (location == null) {
+            throw new IOException("Location cannot be null");
+        }
+        PermissionInfo[] permissions = permAdmin.getPermissions(location);
+        if (permissions != null) {
+            String[] encoded = new String[permissions.length];
+            for (int i = 0; i < permissions.length; i++) {
+                PermissionInfo info = permissions[i];
+                encoded[i] = info.getEncoded();
+            }
+            return encoded;
+        }
+        return null;
+    }
+
+    /**
+     * @see org.osgi.jmx.service.permissionadmin.PermissionAdminMBean#listDefaultPermissions()
+     */
+    public String[] listDefaultPermissions() throws IOException {
+        PermissionInfo[] permissions = permAdmin.getDefaultPermissions();
+        if (permissions != null) {
+            String[] encoded = new String[permissions.length];
+            for (int i = 0; i < permissions.length; i++) {
+                PermissionInfo info = permissions[i];
+                encoded[i] = info.getEncoded();
+            }
+            return encoded;
+        }
+        return null;
+    }
+
+    /**
+     * @see org.osgi.jmx.service.permissionadmin.PermissionAdminMBean#listLocations()
+     */
+    public String[] listLocations() throws IOException {
+        return permAdmin.getLocations();
+    }
+
+    /**
+     * @see org.osgi.jmx.service.permissionadmin.PermissionAdminMBean#setDefaultPermissions(java.lang.String[])
+     */
+    public void setDefaultPermissions(String[] encodedPermissions) throws IOException {
+        PermissionInfo[] permissions = toPermissionInfo(encodedPermissions);
+        permAdmin.setDefaultPermissions(permissions);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.permissionadmin.PermissionAdminMBean#setPermissions(java.lang.String,
+     *      java.lang.String[])
+     */
+    public void setPermissions(String location, String[] encodedPermissions) throws IOException {
+        if (location == null) {
+            throw new IOException("Location cannot be null");
+        }
+        PermissionInfo[] permissions = toPermissionInfo(encodedPermissions);
+        permAdmin.setPermissions(location, permissions);
+    }
+
+    private static PermissionInfo[] toPermissionInfo(String[] encodedPermissions) throws IOException {
+        if (encodedPermissions == null) {
+            return null;
+        }
+        PermissionInfo[] permissions = new PermissionInfo[encodedPermissions.length];
+        for (int i = 0; i < encodedPermissions.length; i++) {
+            try {
+                permissions[i] = new PermissionInfo(encodedPermissions[i]);
+            } catch (Exception e) {
+                IOException ex = new IOException("Invalid encoded permission: " + encodedPermissions[i]);
+                ex.initCause(e);
+                throw ex;
+            }
+        }
+        return permissions;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/permissionadmin/PermissionAdminMBeanHandler.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/permissionadmin/PermissionAdminMBeanHandler.java
index 1f8bddab..49f7c31c 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/permissionadmin/PermissionAdminMBeanHandler.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/permissionadmin/PermissionAdminMBeanHandler.java
@@ -1,3 +1,74 @@
   + native
   + text/plain
   + Revision Date
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.permissionadmin;
+
+import javax.management.NotCompliantMBeanException;
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.AbstractCompendiumHandler;
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.MBeanHandler;
+import org.apache.aries.jmx.agent.JMXAgentContext;
+import org.osgi.jmx.service.permissionadmin.PermissionAdminMBean;
+import org.osgi.service.log.LogService;
+
+/**
+ * <p>
+ * <tt>PermissionAdminMBeanHandler</tt> represents MBeanHandler which
+ * holding information about {@link PermissionAdminMBean}.</p>
+ * @see MBeanHandler
+ * 
+ * @version $Rev$ $Date$
+ */
+public class PermissionAdminMBeanHandler extends AbstractCompendiumHandler {
+
+    /**
+     * Constructs new PermissionAdminMBeanHandler.
+     * 
+     * @param agentContext JMXAgentContext instance.
+     */
+    public PermissionAdminMBeanHandler(JMXAgentContext agentContext) {
+        super(agentContext, "org.osgi.service.permissionadmin.PermissionAdmin");
+    }
+
+    /**
+     * @see org.apache.aries.jmx.AbstractCompendiumHandler#constructInjectMBean(java.lang.Object)
+     */
+    @Override
+    protected StandardMBean constructInjectMBean(Object targetService) {
+        PermissionAdminMBean paMBean = new PermissionAdmin((org.osgi.service.permissionadmin.PermissionAdmin) targetService);
+        StandardMBean mbean = null;
+        try {
+            mbean = new StandardMBean(paMBean, PermissionAdminMBean.class);
+        } catch (NotCompliantMBeanException e) {
+            Logger logger = agentContext.getLogger();
+            logger.log(LogService.LOG_ERROR, "Not compliant MBean", e);
+        }
+        return mbean;
+    }
+
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#getName()
+     */
+    public String getName() {
+        return PermissionAdminMBean.OBJECTNAME;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/provisioning/ProvisioningService.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/provisioning/ProvisioningService.java
index b56de2e8..cd076dcc 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/provisioning/ProvisioningService.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/provisioning/ProvisioningService.java
@@ -1,3 +1,124 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.provisioning;
+
+import static org.osgi.jmx.JmxConstants.PROPERTIES_TYPE;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.Collection;
+import java.util.Dictionary;
+import java.util.Enumeration;
+import java.util.Hashtable;
+import java.util.zip.ZipInputStream;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularDataSupport;
+
+import org.apache.aries.jmx.codec.PropertyData;
+import org.osgi.jmx.service.provisioning.ProvisioningServiceMBean;
+
+/**
+ * Implementation of <code>ProvisioningServiceMBean</code> 
+ *
+ * @version $Rev$ $Date$
+ */
+public class ProvisioningService implements ProvisioningServiceMBean {
+
+    private org.osgi.service.provisioning.ProvisioningService provisioningService;
+    
+    /**
+     * Constructs new ProvisioningService instance
+     * @param provisioningService instance of org.osgi.service.provisioning.ProvisioningService service
+     */
+    public ProvisioningService(org.osgi.service.provisioning.ProvisioningService provisioningService){
+        this.provisioningService = provisioningService;
+    }
+    
+    /**
+     * @see org.osgi.jmx.service.provisioning.ProvisioningServiceMBean#addInformationFromZip(java.lang.String)
+     */
+    public void addInformationFromZip(String zipURL) throws IOException {
+        if (zipURL == null || zipURL.length() < 1) {
+            throw new IOException("Argument zipURL cannot be null or empty");
+        }
+        InputStream is = createStream(zipURL);
+        ZipInputStream zis = new ZipInputStream(is);
+        try {
+            provisioningService.addInformation(zis);
+        } finally {
+            zis.close();
+        }
+    }
+
+    /**
+     * @see org.osgi.jmx.service.provisioning.ProvisioningServiceMBean#addInformation(javax.management.openmbean.TabularData)
+     */
+    public void addInformation(TabularData info) throws IOException {
+        Dictionary<String, Object> provisioningInfo = extractProvisioningDictionary(info);
+        provisioningService.addInformation(provisioningInfo);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.provisioning.ProvisioningServiceMBean#listInformation()
+     */
+    @SuppressWarnings("unchecked")
+    public TabularData listInformation() throws IOException {
+        TabularData propertiesTable = new TabularDataSupport(PROPERTIES_TYPE);
+        Dictionary<String, Object> information = (Dictionary<String, Object>) provisioningService.getInformation();
+        if (information != null) {
+            Enumeration<String> keys = information.keys();
+            while (keys.hasMoreElements()) {
+                String key = keys.nextElement();
+                propertiesTable.put(PropertyData.newInstance(key, information.get(key)).toCompositeData());
+            }
+        }
+        return propertiesTable;
+    }
+
+    /**
+     * @see org.osgi.jmx.service.provisioning.ProvisioningServiceMBean#setInformation(javax.management.openmbean.TabularData)
+     */
+    public void setInformation(TabularData info) throws IOException {
+        Dictionary<String, Object> provisioningInfo = extractProvisioningDictionary(info);
+        provisioningService.setInformation(provisioningInfo);
+    }
+    
+    
+    @SuppressWarnings("unchecked")
+    protected Dictionary<String, Object> extractProvisioningDictionary(TabularData info) {
+        Dictionary<String, Object> provisioningInfo = new Hashtable<String, Object>();
+        if (info != null) {
+            Collection<CompositeData> compositeData = (Collection<CompositeData>) info.values();
+            for (CompositeData row: compositeData) {
+                PropertyData<? extends Class> propertyData = PropertyData.from(row);
+                provisioningInfo.put(propertyData.getKey(), propertyData.getValue());
+            }
+        }
+        return provisioningInfo;
+    }
+
+    protected InputStream createStream(String url) throws IOException {
+        return new URL(url).openStream();
+    }
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanHandler.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanHandler.java
index 56d8ebfd..55788ae7 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanHandler.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanHandler.java
@@ -1,2 +1,76 @@
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.provisioning;
+
+import javax.management.NotCompliantMBeanException;
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.AbstractCompendiumHandler;
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.MBeanHandler;
+import org.apache.aries.jmx.agent.JMXAgentContext;
+import org.osgi.jmx.service.provisioning.ProvisioningServiceMBean;
+import org.osgi.service.log.LogService;
+
+/**
+ * <p>
+ * Implementation of <code>MBeanHandler</code> which manages the <code>ProvisioningServiceMBean</code> implementation
+ * 
+ * @see MBeanHandler
+ * 
+ * @version $Rev$ $Date$
+ */
+public class ProvisioningServiceMBeanHandler extends AbstractCompendiumHandler {
+
+    /**
+     * Constructs new ProvisioningServiceMBeanHandler instance
+     * 
+     * @param agentContext
+     *            JMXAgentContext instance
+     */
+    public ProvisioningServiceMBeanHandler(JMXAgentContext agentContext) {
+        super(agentContext, "org.osgi.service.provisioning.ProvisioningService");
+    }
+
+    /**
+     * @see org.apache.aries.jmx.AbstractCompendiumHandler#constructInjectMBean(java.lang.Object)
+     */
+    @Override
+    protected StandardMBean constructInjectMBean(Object targetService) {
+        ProvisioningService psMBean = new ProvisioningService(
+                (org.osgi.service.provisioning.ProvisioningService) targetService);
+        StandardMBean mbean = null;
+        try {
+            mbean = new StandardMBean(psMBean, ProvisioningServiceMBean.class);
+        } catch (NotCompliantMBeanException e) {
+            Logger logger = agentContext.getLogger();
+            logger.log(LogService.LOG_ERROR, "Failed to instantiate MBean for "
+                    + ProvisioningServiceMBean.class.getName(), e);
+        }
+        return mbean;
+    }
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#getName()
+     */
+    public String getName() {
+        return ProvisioningServiceMBean.OBJECTNAME;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/useradmin/UserAdmin.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/useradmin/UserAdmin.java
index 56d8ebfd..a36fe102 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/useradmin/UserAdmin.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/useradmin/UserAdmin.java
@@ -1,2 +1,619 @@
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.useradmin;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Dictionary;
+import java.util.Enumeration;
+import java.util.List;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularDataSupport;
+
+import org.apache.aries.jmx.codec.AuthorizationData;
+import org.apache.aries.jmx.codec.GroupData;
+import org.apache.aries.jmx.codec.PropertyData;
+import org.apache.aries.jmx.codec.RoleData;
+import org.apache.aries.jmx.codec.UserData;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.jmx.JmxConstants;
+import org.osgi.jmx.service.useradmin.UserAdminMBean;
+import org.osgi.service.useradmin.Authorization;
+import org.osgi.service.useradmin.Group;
+import org.osgi.service.useradmin.Role;
+import org.osgi.service.useradmin.User;
+
+/**
+ * <p>
+ * <tt>UserAdmin</tt> represents {@link UserAdminMBean} implementation.
+ * </p>
+ * 
+ * @see UserAdminMBean
+ * 
+ * @version $Rev$ $Date$
+ */
+public class UserAdmin implements UserAdminMBean {
+
+    /**
+     * @see org.osgi.service.useradmin.UserAdmin service reference;
+     */
+    private org.osgi.service.useradmin.UserAdmin userAdmin;
+
+    /**
+     * Constructs new UserAdmin MBean.
+     * 
+     * @param userAdmin
+     *            {@link UserAdmin} service reference.
+     */
+    public UserAdmin(org.osgi.service.useradmin.UserAdmin userAdmin) {
+        this.userAdmin = userAdmin;
+    }
+
+    /**
+     * Validate Role against roleType.
+     * 
+     * @see Role#USER
+     * @see Role#GROUP
+     * @see Role#USER_ANYONE
+     * 
+     * @param role
+     *            Role instance.
+     * @param roleType
+     *            role type.
+     */
+    private void validateRoleType(Role role, int roleType) throws IOException {
+        if (role.getType() != roleType) {
+            throw new IOException("Unexpected role type. Expected " + roleType + " but got " + role.getType());
+        }
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#addCredential(java.lang.String, byte[], java.lang.String)
+     */
+    public void addCredential(String key, byte[] value, String username) throws IOException {
+        addCredential(key, (Object)value, username);
+    }
+    
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#addCredentialString(String, String, String)
+     */
+    public void addCredentialString(String key, String value, String username) throws IOException {
+        addCredential(key, (Object)value, username);
+    }
+
+    private void addCredential(String key, Object value, String username) throws IOException {
+        if (username == null) {
+            throw new IOException("User name cannot be null");
+        }
+        if (key == null) {
+            throw new IOException("Credential key cannot be null");
+        }
+        Role role = userAdmin.getRole(username);
+        if (role == null) {
+            throw new IOException("Operation fails user with provided username = [" + username + "] doesn't exist");
+        }
+        validateRoleType(role, Role.USER);
+        Dictionary<String, Object> credentials = ((User) role).getCredentials();
+        if (credentials != null) {
+            credentials.put(key, value);
+        }
+    }
+    
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#addMember(java.lang.String, java.lang.String)
+     */
+    public boolean addMember(String groupname, String rolename) throws IOException {
+        if (groupname == null) {
+            throw new IOException("Group name cannot be null");
+        }
+        if (rolename == null) {
+            throw new IOException("Role name cannot be null");
+        }
+        Role group = userAdmin.getRole(groupname);
+        Role member = userAdmin.getRole(rolename);
+        if (group == null) {
+            throw new IOException("Operation fails role with provided groupname = [" + groupname + "] doesn't exist");
+        }
+        validateRoleType(group, Role.GROUP);
+        return ((Group) group).addMember(member);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#addPropertyString(String, String, String)
+     */
+    public void addPropertyString(String key, String value, String rolename) throws IOException {
+        addRoleProperty(key, value, rolename);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#addProperty(java.lang.String, byte[], java.lang.String)
+     */
+    public void addProperty(String key, byte[] value, String rolename) throws IOException {
+        addRoleProperty(key, value, rolename); 
+    }
+    
+    /**
+     * @see UserAdminMBean#addProperty(String, byte[], String)
+     * @see UserAdminMBean#addProperty(String, String, String)
+     */
+    private void addRoleProperty(String key, Object value, String rolename) throws IOException {
+        if (rolename == null) {
+            throw new IOException("Role name cannot be null");
+        }
+        if (key == null) {
+            throw new IOException("Property key cannot be null");
+        }
+        Role role = userAdmin.getRole(rolename);
+        if (role == null) {
+            throw new IOException("Operation fails role with provided rolename = [" + rolename + "] doesn't exist");
+        }
+        Dictionary<String, Object>  properties = role.getProperties();
+        if (properties != null) {
+            properties.put(key, value);
+        }        
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#addRequiredMember(java.lang.String, java.lang.String)
+     */
+    public boolean addRequiredMember(String groupname, String rolename) throws IOException {
+        if (groupname == null) {
+            throw new IOException("Group name cannot be null");
+        }
+        if (rolename == null) {
+            throw new IOException("Role name cannot be null");
+        }
+        Role group = userAdmin.getRole(groupname);
+        Role member = userAdmin.getRole(rolename);
+        if (group == null) {
+            throw new IOException("Operation fails role with provided groupname = [" + groupname + "] doesn't exist");
+        }
+        validateRoleType(group, Role.GROUP);
+        return ((Group) group).addRequiredMember(member);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#createGroup(java.lang.String)
+     */
+    public void createGroup(String name) throws IOException {
+        if (name == null) {
+            throw new IOException("Group name cannot be null");
+        }
+        userAdmin.createRole(name, Role.GROUP);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#createRole(java.lang.String)
+     */
+    public void createRole(String name) throws IOException {
+        throw new IOException("Deprecated: use createGroup or createUser");
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#createUser(java.lang.String)
+     */
+    public void createUser(String name) throws IOException {
+        if (name == null) {
+            throw new IOException("User name cannot be null");
+        }
+        userAdmin.createRole(name, Role.USER);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#getAuthorization(java.lang.String)
+     */
+    public CompositeData getAuthorization(String username) throws IOException {
+        if (username== null) {
+            throw new IOException("User name cannot be null");
+        }
+        Role role = userAdmin.getRole(username);
+        if (role == null) {
+            return null;
+        }
+        validateRoleType(role, Role.USER);
+        Authorization auth = userAdmin.getAuthorization((User) role);
+        if (auth == null) {
+            return null;
+        }
+
+        return new AuthorizationData(auth).toCompositeData();
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#getCredentials(java.lang.String)
+     */
+    public TabularData getCredentials(String username) throws IOException {
+        if (username == null) {
+            throw new IOException("User name cannot be null");
+        }
+        Role role = userAdmin.getRole(username);
+        if (role == null) {
+            return null;
+        }
+        validateRoleType(role, Role.USER);
+        Dictionary<String, Object> credentials = ((User) role).getCredentials();
+        if (credentials == null) {
+            return null;
+        }
+        TabularData data = new TabularDataSupport(JmxConstants.PROPERTIES_TYPE);
+        for (Enumeration<String> keys = credentials.keys(); keys.hasMoreElements();) {
+            String key = keys.nextElement();
+            data.put(PropertyData.newInstance(key, credentials.get(key)).toCompositeData());
+        }
+        return data;
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#getGroup(java.lang.String)
+     */
+    public CompositeData getGroup(String groupname) throws IOException {
+        if (groupname == null) {
+            throw new IOException("Group name cannot be null");
+        }
+        Role role = userAdmin.getRole(groupname);
+        if (role == null) {
+            return null;
+        }
+        validateRoleType(role, Role.GROUP);
+        return new GroupData((Group) role).toCompositeData();
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#getGroups(java.lang.String)
+     */
+    public String[] getGroups(String filter) throws IOException {
+        Role[] roles = null;
+        try {
+            roles = userAdmin.getRoles(filter);
+        } catch (InvalidSyntaxException ise) {
+            IOException ioex = new IOException("Operation fails illegal filter provided: " + filter);
+            ioex.initCause(ise);
+            throw ioex;
+        }
+
+        if (roles == null) {
+            return null;
+        }
+
+        return getRoleByType(roles, Role.GROUP);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#getImpliedRoles(java.lang.String)
+     */
+    public String[] getImpliedRoles(String username) throws IOException {
+        if (username == null) {
+            throw new IOException("User name cannot be null");
+        }
+        Role role = userAdmin.getRole(username);
+        if (role != null) {
+            validateRoleType(role, Role.USER);
+            Authorization auth = userAdmin.getAuthorization((User) role);
+            if (auth != null) {
+                return auth.getRoles();
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#getMembers(java.lang.String)
+     */
+    public String[] getMembers(String groupname) throws IOException {
+        if (groupname == null) {
+            throw new IOException("Group name cannot be null");
+        }
+        Role role = userAdmin.getRole(groupname);
+        if (role != null) {
+            validateRoleType(role, Role.GROUP);
+            Role[] roles = ((Group) role).getMembers();
+            if (roles != null) {
+                String[] members = new String[roles.length];
+                for (int i = 0; i < roles.length; i++) {
+                    members[i] = roles[i].getName();
+                }
+                return members;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#getProperties(java.lang.String)
+     */
+    public TabularData getProperties(String rolename) throws IOException {
+        if (rolename == null) {
+            throw new IOException("Role name cannot be null");
+        }
+        Role role = userAdmin.getRole(rolename);
+        if (role == null) {
+            return null;
+        }
+        Dictionary<String, Object> properties = role.getProperties();
+        if (properties == null) {
+            return null;
+        }
+        TabularData data = new TabularDataSupport(JmxConstants.PROPERTIES_TYPE);
+        for (Enumeration<String> keys = properties.keys(); keys.hasMoreElements();) {
+            String key = keys.nextElement();
+            data.put(PropertyData.newInstance(key, properties.get(key)).toCompositeData());
+        }
+        return data;
+
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#getRequiredMembers(java.lang.String)
+     */
+    public String[] getRequiredMembers(String groupname) throws IOException {
+        if (groupname == null) {
+            throw new IOException("Group name cannot be null");
+        }
+        Role role = userAdmin.getRole(groupname);
+        if (role != null) {
+            validateRoleType(role, Role.GROUP);
+            Role[] roles = ((Group) role).getRequiredMembers();
+            if (roles != null) {
+                String[] reqMembers = new String[roles.length];
+                for (int i = 0; i < roles.length; i++) {
+                    reqMembers[i] = roles[i].getName();
+                }
+                return reqMembers;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#getRole(java.lang.String)
+     */
+    public CompositeData getRole(String name) throws IOException {
+        if (name == null) {
+            throw new IOException("Role name cannot be null");
+        }
+        Role role = userAdmin.getRole(name);
+        if (role == null) {
+            return null;
+        }
+        return new RoleData(role).toCompositeData();
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#getRoles(java.lang.String)
+     */
+    public String[] getRoles(String filter) throws IOException {
+        Role[] roles = null;
+        try {
+            roles = userAdmin.getRoles(filter);
+        } catch (InvalidSyntaxException ise) {
+            IOException ioex = new IOException("Operation fails illegal filter provided: " + filter);
+            ioex.initCause(ise);
+            throw ioex;
+        }
+        if (roles == null) {
+            return null;
+        }
+        return getRoleByType(roles, Role.ROLE);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#getUser(java.lang.String)
+     */
+    public CompositeData getUser(String username) throws IOException {
+        if (username == null) {
+            throw new IOException("User name cannot be null");
+        }
+        Role role = userAdmin.getRole(username);
+        if (role == null) {
+            return null;
+        }
+        validateRoleType(role, Role.USER);
+        return new UserData((User) role).toCompositeData();
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#getUserWithProperty(String, String)
+     */
+    public String getUserWithProperty(String key, String value) throws IOException {
+        if (key == null) {
+            throw new IOException("Property key cannot be null");
+        }
+        User user = userAdmin.getUser(key, value);
+        if (user == null) {
+            return null;
+        }
+        return user.getName();
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#getUsers(java.lang.String)
+     */
+    public String[] getUsers(String filter) throws IOException {
+        Role[] roles = null;
+        try {
+            roles = userAdmin.getRoles(filter);
+        } catch (InvalidSyntaxException ise) {
+            IOException ioex = new IOException("Operation fails illegal filter provided: " + filter);
+            ioex.initCause(ise);
+            throw ioex;
+        }
+        if (roles == null) {
+            return null;
+        }
+        return getRoleByType(roles, Role.USER);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#listGroups()
+     */
+    public String[] listGroups() throws IOException {
+        Role[] roles = null;
+        try {
+            roles = userAdmin.getRoles(null);
+        } catch (InvalidSyntaxException e) {
+            // shouldn't happened we are not using filter
+        }
+        if (roles == null) {
+            return null;
+        }
+        return getRoleByType(roles, Role.GROUP);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#listRoles()
+     */
+    public String[] listRoles() throws IOException {
+        Role[] roles = null;
+        try {
+            roles = userAdmin.getRoles(null);
+        } catch (InvalidSyntaxException e) {
+            // shouldn't happened we are not using filter
+        }
+
+        if (roles == null) {
+            return null;
+        }
+
+        return getRoleByType(roles, Role.ROLE);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#listUsers()
+     */
+    public String[] listUsers() throws IOException {
+        Role[] roles = null;
+        try {
+            roles = userAdmin.getRoles(null);
+        } catch (InvalidSyntaxException e) {
+            // shouldn't happened we are not using filter
+        }
+        if (roles == null) {
+            return null;
+        }
+        return getRoleByType(roles, Role.USER);
+    }
+
+    /**
+     * Gets role names by type from provided roles array.
+     * 
+     * @param roles
+     *            array of Role's.
+     * @param roleType
+     *            role Type.
+     * @return array of role names.
+     */
+    private String[] getRoleByType(Role[] roles, int roleType) {
+        List<String> rs = new ArrayList<String>();
+        for (Role role : roles) {
+            if (roleType == Role.ROLE) {
+                rs.add(role.getName());
+                continue;
+            }
+
+            if (role.getType() == roleType) {
+                rs.add(role.getName());
+            }
+        }
+        return rs.toArray(new String[rs.size()]);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#removeCredential(java.lang.String, java.lang.String)
+     */
+    public void removeCredential(String key, String username) throws IOException {
+        if (username == null) {
+            throw new IOException("User name cannot be null");
+        }
+        if (key == null) {
+            throw new IOException("Credential key cannot be null");
+        }
+        Role role = userAdmin.getRole(username);
+        if (role == null) {
+            throw new IOException("Operation fails can't find user with username = [" + username + "] doesn't exist");
+        }
+        validateRoleType(role, Role.USER);
+        ((User) role).getCredentials().remove(key);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#removeGroup(java.lang.String)
+     */
+    public boolean removeGroup(String name) throws IOException {
+        if (name == null) {
+            throw new IOException("Group name cannot be null");
+        }
+        return userAdmin.removeRole(name);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#removeMember(java.lang.String, java.lang.String)
+     */
+    public boolean removeMember(String groupname, String rolename) throws IOException {
+        if (groupname == null) {
+            throw new IOException("Group name cannot be null");
+        }
+        if (rolename == null) {
+            throw new IOException("Role name cannot be null");
+        }
+        Role group = userAdmin.getRole(groupname);
+        Role member = userAdmin.getRole(rolename);
+        if (group == null) {
+            throw new IOException("Operation fails role with provided groupname = [" + groupname + "] doesn't exist");
+        }
+        validateRoleType(group, Role.GROUP);
+        return ((Group) group).removeMember(member);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#removeProperty(java.lang.String, java.lang.String)
+     */
+    public void removeProperty(String key, String rolename) throws IOException {
+        if (rolename == null) {
+            throw new IOException("Role name cannot be null");
+        }
+        Role role = userAdmin.getRole(rolename);
+        if (role == null) {
+            throw new IOException("Operation fails role with provided rolename = [" + rolename + "] doesn't exist");
+        }
+        role.getProperties().remove(key);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#removeRole(java.lang.String)
+     */
+    public boolean removeRole(String name) throws IOException {
+        if (name == null) {
+            throw new IOException("Role name cannot be null");
+        }
+        return userAdmin.removeRole(name);
+    }
+
+    /**
+     * @see org.osgi.jmx.service.useradmin.UserAdminMBean#removeUser(java.lang.String)
+     */
+    public boolean removeUser(String name) throws IOException {
+        if (name == null) {
+            throw new IOException("User name cannot be null");
+        }
+        return userAdmin.removeRole(name);
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/useradmin/UserAdminMBeanHandler.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/useradmin/UserAdminMBeanHandler.java
index 1f8bddab..b3c65207 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/useradmin/UserAdminMBeanHandler.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/useradmin/UserAdminMBeanHandler.java
@@ -1,3 +1,76 @@
   + native
   + text/plain
   + Revision Date
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.useradmin;
+
+import javax.management.NotCompliantMBeanException;
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.AbstractCompendiumHandler;
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.MBeanHandler;
+import org.apache.aries.jmx.agent.JMXAgentContext;
+import org.osgi.jmx.service.permissionadmin.PermissionAdminMBean;
+import org.osgi.jmx.service.useradmin.UserAdminMBean;
+import org.osgi.service.log.LogService;
+
+/**
+ * <p>
+ * <tt>UserAdminMBeanHandler</tt> represents MBeanHandler which
+ * holding information about {@link PermissionAdminMBean}.</p>
+ * @see AbstractCompendiumHandler
+ * @see MBeanHandler
+ *
+ * @version $Rev$ $Date$
+ */
+public class UserAdminMBeanHandler extends AbstractCompendiumHandler {
+
+    /**
+     * Constructs new UserAdminMBeanHandler.
+     * 
+     * @param agentContext JMXAgentContext instance.
+     */
+    public UserAdminMBeanHandler(JMXAgentContext agentContext) {
+        super(agentContext, "org.osgi.service.useradmin.UserAdmin");
+    }
+
+    /**
+     * @see org.apache.aries.jmx.AbstractCompendiumHandler#constructInjectMBean(java.lang.Object)
+     */
+    @Override
+    protected StandardMBean constructInjectMBean(Object targetService) {       
+        UserAdminMBean uaMBean = new UserAdmin((org.osgi.service.useradmin.UserAdmin) targetService); 
+        StandardMBean mbean = null;
+        try {
+            mbean = new StandardMBean(uaMBean, UserAdminMBean.class);
+        } catch (NotCompliantMBeanException e) {
+            Logger logger = agentContext.getLogger();
+            logger.log(LogService.LOG_ERROR, "Not compliant MBean", e);
+        }
+        return mbean;
+    }
+
+    /**
+     * @see org.apache.aries.jmx.MBeanHandler#getName()
+     */
+    public String getName() {
+        return UserAdminMBean.OBJECTNAME;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/util/FrameworkUtils.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/util/FrameworkUtils.java
index b56de2e8..bde52137 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/util/FrameworkUtils.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/util/FrameworkUtils.java
@@ -1,3 +1,641 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.util;
+
+import static org.osgi.jmx.framework.BundleStateMBean.ACTIVE;
+import static org.osgi.jmx.framework.BundleStateMBean.INSTALLED;
+import static org.osgi.jmx.framework.BundleStateMBean.RESOLVED;
+import static org.osgi.jmx.framework.BundleStateMBean.STARTING;
+import static org.osgi.jmx.framework.BundleStateMBean.STOPPING;
+import static org.osgi.jmx.framework.BundleStateMBean.UNINSTALLED;
+import static org.osgi.jmx.framework.BundleStateMBean.UNKNOWN;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Dictionary;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.aries.util.ManifestHeaderUtils;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Constants;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.ServiceReference;
+import org.osgi.service.packageadmin.ExportedPackage;
+import org.osgi.service.packageadmin.PackageAdmin;
+import org.osgi.service.packageadmin.RequiredBundle;
+
+/**
+ * This class contains common utilities related to Framework operations for the MBean implementations
+ * 
+ * @version $Rev$ $Date$
+ */
+public class FrameworkUtils {
+
+    private FrameworkUtils() {
+        super();
+    }
+
+    /**
+     * 
+     * Returns the Bundle object for a given id
+     * 
+     * @param bundleContext
+     * @param bundleId
+     * @return
+     * @throws IllegalArgumentException
+     *             if no Bundle is found with matching bundleId
+     */
+    public static Bundle resolveBundle(BundleContext bundleContext, long bundleId) throws IOException {
+        if (bundleContext == null) {
+            throw new IllegalArgumentException("Argument bundleContext cannot be null");
+        }
+        Bundle bundle = bundleContext.getBundle(bundleId);
+        if (bundle == null) {
+            throw new IOException("Bundle with id [" + bundleId + "] not found");
+        }
+        return bundle;
+    }
+
+    /**
+     * Returns an array of bundleIds
+     * 
+     * @param bundles
+     *            array of <code>Bundle</code> objects
+     * @return bundleIds in sequence
+     */
+    public static long[] getBundleIds(Bundle[] bundles) {
+        long[] result;
+        if (bundles == null) {
+            result = new long[0];
+        } else {
+            result = new long[bundles.length];
+            for (int i = 0; i < bundles.length; i++) {
+                result[i] = bundles[i].getBundleId();
+            }
+        }
+        return result;
+    }
+    
+    public static long[] getBundleIds(List<Bundle> bundles) { 
+        long[] result;
+        if (bundles == null) {
+            result = new long[0];
+        } else {
+            result = new long[bundles.size()];
+            for (int i = 0; i < bundles.size(); i++) {
+                result[i] = bundles.get(i).getBundleId();
+            }
+        }
+        return result;
+    }
+
+    /**
+     * 
+     * Returns the ServiceReference object with matching service.id
+     * 
+     * @param bundleContext
+     * @param serviceId
+     * @return ServiceReference with matching service.id property
+     * @throws IllegalArgumentException if bundleContext is null
+     * @throws IOException if no service is found with the given id
+     */
+    public static ServiceReference resolveService(BundleContext bundleContext, long serviceId) throws IOException {
+        if (bundleContext == null) {
+            throw new IllegalArgumentException("Argument bundleContext cannot be null");
+        }
+        ServiceReference result = null;
+        try {
+            ServiceReference[] references = bundleContext.getAllServiceReferences(null, "(" + Constants.SERVICE_ID
+                    + "=" + serviceId + ")");
+            if (references == null || references.length < 1) {
+                throw new IOException("Service with id [" + serviceId + "] not found");
+            } else {
+                result = references[0];
+            }
+        } catch (InvalidSyntaxException e) {
+            IOException ioex = new IOException("Failure when resolving service ");
+            ioex.initCause(e);
+            throw ioex;
+        }
+        return result;
+    }
+
+    /**
+     * Returns an array of service.id values
+     * 
+     * @param serviceReferences
+     *            array of <code>ServiceReference</code> objects
+     * @return service.id values in sequence
+     */
+    public static long[] getServiceIds(ServiceReference[] serviceReferences) {
+        long result[] = (serviceReferences == null) ? new long[0] : new long[serviceReferences.length];
+        for (int i = 0; i < result.length; i++) {
+            result[i] = (Long) serviceReferences[i].getProperty(Constants.SERVICE_ID);
+        }
+        return result;
+    }
+
+    /**
+     * Returns the packages exported by the specified bundle
+     * 
+     * @param bundle
+     * @param packageAdmin
+     * @return
+     * @throws IllegalArgumentException
+     *             if bundle or packageAdmin are null
+     */
+    public static String[] getBundleExportedPackages(Bundle bundle, PackageAdmin packageAdmin)
+            throws IllegalArgumentException {
+        if (bundle == null) {
+            throw new IllegalArgumentException("Argument bundle cannot be null");
+        }
+        if (packageAdmin == null) {
+            throw new IllegalArgumentException("Argument packageAdmin cannot be null");
+        }
+        String[] exportedPackages;
+        ExportedPackage[] exported = packageAdmin.getExportedPackages(bundle);
+        if (exported != null) {
+            exportedPackages = new String[exported.length];
+            for (int i = 0; i < exported.length; i++) {
+                exportedPackages[i] = exported[i].getName() + ";" + exported[i].getVersion().toString();
+            }
+        } else {
+            exportedPackages = new String[0];
+        }
+        return exportedPackages;
+    }
+
+    /**
+     * Returns the bundle ids of any resolved fragments
+     * 
+     * @param bundle
+     * @param packageAdmin
+     * @return
+     * @throws IllegalArgumentException
+     *             if bundle or packageAdmin are null
+     */
+    public static long[] getFragmentIds(Bundle bundle, PackageAdmin packageAdmin) throws IllegalArgumentException {
+        if (bundle == null) {
+            throw new IllegalArgumentException("Argument bundle cannot be null");
+        }
+        if (packageAdmin == null) {
+            throw new IllegalArgumentException("Argument packageAdmin cannot be null");
+        }
+        long[] fragmentIds;
+        Bundle[] fragments = packageAdmin.getFragments(bundle);
+        if (fragments != null) {
+            fragmentIds = getBundleIds(fragments);
+        } else {
+            fragmentIds = new long[0];
+        }
+        return fragmentIds;
+    }
+
+    /**
+     * Returns the bundle ids of any resolved hosts
+     * 
+     * @param fragment
+     * @param packageAdmin
+     * @return
+     * @throws IllegalArgumentException
+     *             if fragment or packageAdmin are null
+     */
+    public static long[] getHostIds(Bundle fragment, PackageAdmin packageAdmin) throws IllegalArgumentException {
+        if (fragment == null) {
+            throw new IllegalArgumentException("Argument bundle cannot be null");
+        }
+        if (packageAdmin == null) {
+            throw new IllegalArgumentException("Argument packageAdmin cannot be null");
+        }
+        long[] hostIds;
+        Bundle[] hosts = packageAdmin.getHosts(fragment);
+        if (hosts != null) {
+            hostIds = getBundleIds(hosts);
+        } else {
+            hostIds = new long[0];
+        }
+        return hostIds;
+    }
+
+    /**
+     * Returns the resolved package imports for the given bundle
+     * 
+     * @param localBundleContext
+     *            BundleContext object of this bundle/caller
+     * @param bundle
+     *            target Bundle object to query imported packages for
+     * @param packageAdmin
+     * 
+     * @return
+     * @throws IllegalArgumentException
+     *             if fragment or packageAdmin are null
+     */
+    public static String[] getBundleImportedPackages(BundleContext localBundleContext, Bundle bundle,
+            PackageAdmin packageAdmin) throws IllegalArgumentException {
+        if (bundle == null) {
+            throw new IllegalArgumentException("Argument bundle cannot be null");
+        }
+        if (packageAdmin == null) {
+            throw new IllegalArgumentException("Argument packageAdmin cannot be null");
+        }
+        
+        List<String> result = new ArrayList<String>();
+        for (ExportedPackage ep : getBundleImportedPackagesRaw(localBundleContext, bundle, packageAdmin)) {
+          result.add(ep.getName()+";"+ep.getVersion());
+        }
+        
+        return result.toArray(new String[0]);
+    }
+    
+    @SuppressWarnings("unchecked")
+    private static Collection<ExportedPackage> getBundleImportedPackagesRaw(BundleContext localBundleContext, Bundle bundle, PackageAdmin packageAdmin) throws IllegalArgumentException 
+    {
+      List<ExportedPackage> result = new ArrayList<ExportedPackage>();
+      Dictionary<String, String> bundleHeaders = bundle.getHeaders();
+      String dynamicImportHeader = bundleHeaders.get(Constants.DYNAMICIMPORT_PACKAGE);
+      // if DynamicImport-Package used, then do full iteration
+      // else means no dynamic import or has dynamic import but no wildcard "*" in it.
+      if (dynamicImportHeader != null && dynamicImportHeader.contains("*")) {
+          Bundle[] bundles = localBundleContext.getBundles();
+          for (Bundle candidate : bundles) {
+              if (candidate.equals(bundle)) {
+                  continue;
+              }
+              ExportedPackage[] candidateExports = packageAdmin.getExportedPackages(candidate);
+              if (candidateExports != null) {
+                  for (ExportedPackage exportedPackage : candidateExports) {
+                      Bundle[] userBundles = exportedPackage.getImportingBundles();
+                      if (userBundles != null && arrayContains(userBundles, bundle)) {
+                          result.add(exportedPackage);
+                      }
+                  }// end for candidateExports
+              }
+          }// end for bundles
+      } else { // only query ExportPackage for package names declared as imported
+          List<String> importPackages = new ArrayList<String>();
+          String importPackageHeader = bundleHeaders.get(Constants.IMPORT_PACKAGE);
+          if (importPackageHeader != null && importPackageHeader.length() > 0) {
+            importPackages.addAll(extractHeaderDeclaration(importPackageHeader));
+          }
+          if (dynamicImportHeader != null) {
+            importPackages.addAll(extractHeaderDeclaration(dynamicImportHeader));
+          }
+          for (String packageName : importPackages) {
+              ExportedPackage[] candidateExports = packageAdmin.getExportedPackages(packageName);
+              if (candidateExports != null) {
+                  for (ExportedPackage exportedPackage : candidateExports) {
+                      Bundle[] userBundles = exportedPackage.getImportingBundles();
+                      if (userBundles != null && arrayContains(userBundles, bundle)) {
+                          result.add(exportedPackage);
+                      }
+                  }// end for candidateExports
+              }
+          }
+      }
+      return result;
+    }
+
+    /**
+     * Returns the service.id values for services registered by the given bundle
+     * 
+     * @param bundle
+     * @return
+     * @throws IllegalArgumentException
+     *             if bundle is null
+     * @throws IlleglStateException
+     *             if bundle has been uninstalled
+     */
+    public static long[] getRegisteredServiceIds(Bundle bundle) throws IllegalArgumentException, IllegalStateException {
+        if (bundle == null) {
+            throw new IllegalArgumentException("Argument bundle cannot be null");
+        }
+        long[] serviceIds;
+        ServiceReference[] serviceReferences = bundle.getRegisteredServices();
+        if (serviceReferences != null) {
+            serviceIds = new long[serviceReferences.length];
+            for (int i = 0; i < serviceReferences.length; i++) {
+                serviceIds[i] = (Long) serviceReferences[i].getProperty(Constants.SERVICE_ID);
+            }
+        } else {
+            serviceIds = new long[0];
+        }
+        return serviceIds;
+    }
+
+    /**
+     * Returns the service.id values of services being used by the given bundle
+     * 
+     * @param bundle
+     * @return
+     * @throws IllegalArgumentException
+     *             if bundle is null
+     * @throws IlleglStateException
+     *             if bundle has been uninstalled
+     */
+    public static long[] getServicesInUseByBundle(Bundle bundle) throws IllegalArgumentException, IllegalStateException {
+        if (bundle == null) {
+            throw new IllegalArgumentException("Argument bundle cannot be null");
+        }
+        long[] serviceIds;
+        ServiceReference[] serviceReferences = bundle.getServicesInUse();
+        if (serviceReferences != null) {
+            serviceIds = new long[serviceReferences.length];
+            for (int i = 0; i < serviceReferences.length; i++) {
+                serviceIds[i] = (Long) serviceReferences[i].getProperty(Constants.SERVICE_ID);
+            }
+        } else {
+            serviceIds = new long[0];
+        }
+        return serviceIds;
+    }
+
+    /**
+     * Returns the status of pending removal
+     * 
+     * @param bundle
+     * @return true if the bundle is pending removal
+     * @throws IllegalArgumentException
+     *             if bundle or packageAdmin are null
+     */
+    public static boolean isBundlePendingRemoval(Bundle bundle, PackageAdmin packageAdmin)
+            throws IllegalArgumentException {
+        if (bundle == null) {
+            throw new IllegalArgumentException("Argument bundle cannot be null");
+        }
+        if (packageAdmin == null) {
+            throw new IllegalArgumentException("Argument packageAdmin cannot be null");
+        }
+        boolean result = false;
+        ExportedPackage[] exportedPackages = packageAdmin.getExportedPackages(bundle);
+        if (exportedPackages != null) {
+            for (ExportedPackage exportedPackage : exportedPackages) {
+                if (exportedPackage.isRemovalPending()) {
+                    result = true;
+                    break;
+                }
+            }
+        }
+        if (!result) {
+            RequiredBundle[] requiredBundles = packageAdmin.getRequiredBundles(bundle.getSymbolicName());
+            if (requiredBundles != null) {
+                for (RequiredBundle requiredBundle : requiredBundles) {
+                    Bundle required = requiredBundle.getBundle();
+                    if (required == bundle) {
+                        result = requiredBundle.isRemovalPending();
+                        break;
+                    }
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Checks if the given bundle is currently required by other bundles
+     * 
+     * @param bundle
+     * @param packageAdmin
+     * @return
+     * @throws IllegalArgumentException
+     *             if bundle or packageAdmin are null
+     */
+    public static boolean isBundleRequiredByOthers(Bundle bundle, PackageAdmin packageAdmin)
+            throws IllegalArgumentException {
+        if (bundle == null) {
+            throw new IllegalArgumentException("Argument bundle cannot be null");
+        }
+        if (packageAdmin == null) {
+            throw new IllegalArgumentException("Argument packageAdmin cannot be null");
+        }
+        boolean result = false;
+        // Check imported packages (statically or dynamically)
+        ExportedPackage[] exportedPackages = packageAdmin.getExportedPackages(bundle);
+        if (exportedPackages != null) {
+            for (ExportedPackage exportedPackage : exportedPackages) {
+                Bundle[] importingBundles = exportedPackage.getImportingBundles();
+                if (importingBundles != null && importingBundles.length > 0) {
+                    result = true;
+                    break;
+                }
+            }
+        }
+        if (!result) {
+            // Check required bundles
+            RequiredBundle[] requiredBundles = packageAdmin.getRequiredBundles(bundle.getSymbolicName());
+            if (requiredBundles != null) {
+                for (RequiredBundle requiredBundle : requiredBundles) {
+                    Bundle required = requiredBundle.getBundle();
+                    if (required == bundle) {
+                        Bundle[] requiring = requiredBundle.getRequiringBundles();
+                        if (requiring != null && requiring.length > 0) {
+                            result = true;
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        if (!result) {
+            // Check fragment bundles
+            Bundle[] fragments = packageAdmin.getFragments(bundle);
+            if (fragments != null && fragments.length > 0) {
+                result = true;
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Returns an array of ids of bundles the given bundle depends on
+     * 
+     * @param localBundleContext
+     *            BundleContext object of this bundle/caller
+     * @param bundle
+     *            target Bundle object to query dependencies for
+     * @param packageAdmin
+     * 
+     * @return
+     * @throws IllegalArgumentException
+     *             if bundle or packageAdmin are null
+     */
+    @SuppressWarnings("unchecked")
+    public static long[] getBundleDependencies(BundleContext localBundleContext, 
+                                               Bundle bundle,
+                                               PackageAdmin packageAdmin) throws IllegalArgumentException {
+        if (bundle == null) {
+            throw new IllegalArgumentException("Argument bundle cannot be null");
+        }
+        if (packageAdmin == null) {
+            throw new IllegalArgumentException("Argument packageAdmin cannot be null");
+        }
+        Set<Bundle> dependencies = new HashSet<Bundle>();
+        
+        for (ExportedPackage ep : getBundleImportedPackagesRaw(localBundleContext, bundle, packageAdmin)) {
+          dependencies.add(ep.getExportingBundle());
+        }
+        
+        // Handle required bundles
+        Dictionary<String, String> bundleHeaders = bundle.getHeaders();
+        String requireBundleHeader = bundleHeaders.get(Constants.REQUIRE_BUNDLE);
+        if (requireBundleHeader != null) { // only check if Require-Bundle is used
+        	List<String> bundleSymbolicNames = extractHeaderDeclaration(requireBundleHeader);
+            for (String bundleSymbolicName: bundleSymbolicNames) {
+                RequiredBundle[] candidateRequiredBundles = packageAdmin.getRequiredBundles(bundleSymbolicName);
+                if (candidateRequiredBundles != null) {
+                    for (RequiredBundle candidateRequiredBundle : candidateRequiredBundles) {
+                        Bundle[] bundlesRequiring = candidateRequiredBundle.getRequiringBundles();
+                        if (bundlesRequiring != null && arrayContains(bundlesRequiring, bundle)) {
+                            dependencies.add(candidateRequiredBundle.getBundle());
+                        }
+                    }
+                }
+            }
+        }
+        // Handle fragment bundles
+        Bundle[] hosts = packageAdmin.getHosts(bundle);
+        if (hosts != null) {
+            for (Bundle host : hosts) {
+                dependencies.add(host);
+            }
+        }
+        return getBundleIds(dependencies.toArray(new Bundle[dependencies.size()]));
+    }
+    
+    /**
+     * Returns an array of ids of bundles that depend on the given bundle
+     * 
+     * @param bundle
+     * @param packageAdmin
+     * @return
+     * @throws IllegalArgumentException
+     *             if bundle or packageAdmin are null
+     */
+    public static long[] getDependentBundles(Bundle bundle, PackageAdmin packageAdmin) throws IllegalArgumentException {
+        if (bundle == null) {
+            throw new IllegalArgumentException("Argument bundle cannot be null");
+        }
+        if (packageAdmin == null) {
+            throw new IllegalArgumentException("Argument packageAdmin cannot be null");
+        }        
+        Set<Bundle> dependencies = new HashSet<Bundle>();
+        // Handle imported packages (statically or dynamically)
+        ExportedPackage[] exportedPackages = packageAdmin.getExportedPackages(bundle);
+        if (exportedPackages != null) {
+            for (ExportedPackage exportedPackage : exportedPackages) {
+                Bundle[] importingBundles = exportedPackage.getImportingBundles();
+                if (importingBundles != null) {
+                    for (Bundle importingBundle : importingBundles) {
+                        dependencies.add(importingBundle);
+                    }
+                }
+            }
+        }
+        // Handle required bundles
+        RequiredBundle[] requiredBundles = packageAdmin.getRequiredBundles(bundle.getSymbolicName());
+        if (requiredBundles != null) {
+            for (RequiredBundle requiredBundle : requiredBundles) {
+                Bundle required = requiredBundle.getBundle();
+                if (required == bundle) {
+                    Bundle[] requiringBundles = requiredBundle.getRequiringBundles();
+                    if (requiringBundles != null) {
+                        for (Bundle requiringBundle : requiringBundles) {
+                            dependencies.add(requiringBundle);
+                        }
+                    }
+                }
+            }
+        }
+        // Handle fragment bundles
+        Bundle[] fragments = packageAdmin.getFragments(bundle);
+        if (fragments != null) {
+            for (Bundle fragment : fragments) {
+                dependencies.add(fragment);
+            }
+        }
+        return getBundleIds(dependencies.toArray(new Bundle[dependencies.size()]));
+    }
+
+    /**
+     * Returns a String representation of the bundles state
+     * 
+     * @param bundle
+     * @return
+     */
+    public static String getBundleState(Bundle bundle) {
+        String state = UNKNOWN;
+        switch (bundle.getState()) {
+        case Bundle.INSTALLED:
+            state = INSTALLED;
+            break;
+        case Bundle.RESOLVED:
+            state = RESOLVED;
+            break;
+        case Bundle.STARTING:
+            state = STARTING;
+            break;
+        case Bundle.ACTIVE:
+            state = ACTIVE;
+            break;
+        case Bundle.STOPPING:
+            state = STOPPING;
+            break;
+        case Bundle.UNINSTALLED:
+            state = UNINSTALLED;
+        }
+        return state;
+    }
+
+    /*
+     * Checks if an object exists in the given array (based on object equality)
+     */
+    public static boolean arrayContains(Object[] array, Object value) {
+        boolean result = false;
+        if (array != null && value != null) {
+            for (Object element : array) {
+                if (value.equals(element)) {
+                    result = true;
+                    break;
+                }
+            }
+        }
+        return result;
+    }
+
+    /*
+     * Will parse a header value, strip out trailing attributes and return a list of declarations
+     */
+    public static List<String> extractHeaderDeclaration(String headerStatement) {
+        List<String> result = new ArrayList<String>();
+        
+        for (String headerDeclaration : ManifestHeaderUtils.split(headerStatement, ",")) {
+            String name = headerDeclaration.contains(";") ? headerDeclaration.substring(0, headerDeclaration
+                    .indexOf(";")) : headerDeclaration;
+            result.add(name);
+        }
+        
+        return result;
+    }
+    
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/util/TypeUtils.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/util/TypeUtils.java
index b56de2e8..22e739a5 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/util/TypeUtils.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/util/TypeUtils.java
@@ -1,3 +1,197 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.util;
+
+import static org.osgi.jmx.JmxConstants.BIGDECIMAL;
+import static org.osgi.jmx.JmxConstants.BIGINTEGER;
+import static org.osgi.jmx.JmxConstants.BOOLEAN;
+import static org.osgi.jmx.JmxConstants.BYTE;
+import static org.osgi.jmx.JmxConstants.CHARACTER;
+import static org.osgi.jmx.JmxConstants.DOUBLE;
+import static org.osgi.jmx.JmxConstants.FLOAT;
+import static org.osgi.jmx.JmxConstants.INTEGER;
+import static org.osgi.jmx.JmxConstants.LONG;
+import static org.osgi.jmx.JmxConstants.P_BOOLEAN;
+import static org.osgi.jmx.JmxConstants.P_BYTE;
+import static org.osgi.jmx.JmxConstants.P_CHAR;
+import static org.osgi.jmx.JmxConstants.P_DOUBLE;
+import static org.osgi.jmx.JmxConstants.P_FLOAT;
+import static org.osgi.jmx.JmxConstants.P_INT;
+import static org.osgi.jmx.JmxConstants.P_LONG;
+import static org.osgi.jmx.JmxConstants.P_SHORT;
+import static org.osgi.jmx.JmxConstants.SHORT;
+import static org.osgi.jmx.JmxConstants.STRING;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.Dictionary;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * This class provides common utilities related to type conversions for the MBean implementations
+ * 
+ * @version $Rev$ $Date$
+ */
+public class TypeUtils {
+
+    private TypeUtils() {
+        super();
+    }
+
+    public static Map<String, Class<? extends Object>> primitiveTypes = new HashMap<String, Class<? extends Object>>();
+    public static Map<String, Class<? extends Object>> wrapperTypes = new HashMap<String, Class<? extends Object>>();
+    public static Map<String, Class<? extends Object>> mathTypes = new HashMap<String, Class<? extends Object>>();
+    public static Map<Class<? extends Object>, Class<? extends Object>> primitiveToWrapper = new HashMap<Class<? extends Object>, Class<? extends Object>>();
+    public static Map<String, Class<? extends Object>> types = new HashMap<String, Class<? extends Object>>();
+
+    static {
+        primitiveTypes.put(P_FLOAT, Float.TYPE);
+        primitiveTypes.put(P_INT, Integer.TYPE);
+        primitiveTypes.put(P_LONG, Long.TYPE);
+        primitiveTypes.put(P_DOUBLE, Double.TYPE);
+        primitiveTypes.put(P_BYTE, Byte.TYPE);
+        primitiveTypes.put(P_SHORT, Short.TYPE);
+        primitiveTypes.put(P_CHAR, Character.TYPE);
+        primitiveTypes.put(P_BOOLEAN, Boolean.TYPE);
+        primitiveToWrapper.put(Float.TYPE, Float.class);
+        primitiveToWrapper.put(Integer.TYPE, Integer.class);
+        primitiveToWrapper.put(Long.TYPE, Long.class);
+        primitiveToWrapper.put(Double.TYPE, Double.class);
+        primitiveToWrapper.put(Byte.TYPE, Byte.class);
+        primitiveToWrapper.put(Short.TYPE, Short.class);
+        primitiveToWrapper.put(Boolean.TYPE, Boolean.class);
+        wrapperTypes.put(INTEGER, Integer.class);
+        wrapperTypes.put(FLOAT, Float.class);
+        wrapperTypes.put(LONG, Long.class);
+        wrapperTypes.put(DOUBLE, Double.class);
+        wrapperTypes.put(BYTE, Byte.class);
+        wrapperTypes.put(SHORT, Short.class);
+        wrapperTypes.put(BOOLEAN, Boolean.class);
+        wrapperTypes.put(CHARACTER, Character.class);
+        mathTypes.put(BIGDECIMAL, BigDecimal.class);
+        mathTypes.put(BIGINTEGER, BigInteger.class);
+        types.put(STRING, String.class);
+        types.putAll(primitiveTypes);
+        types.putAll(wrapperTypes);
+        types.putAll(mathTypes);
+    }
+
+    /**
+     * Converts a <code>Dictionary</code> object to a <code>Map</code>
+     * 
+     * @param dictionary
+     * @return
+     */
+    public static Map<String, String> fromDictionary(Dictionary<String, String> dictionary) {
+        Map<String, String> result = new HashMap<String, String>();
+        Enumeration<String> keys = dictionary.keys();
+        while (keys.hasMoreElements()) {
+            String key = keys.nextElement();
+            result.put(key, dictionary.get(key));
+        }
+        return result;
+    }
+
+    /**
+     * Converts primitive long[] array to Long[]
+     * 
+     * @param array
+     * @return
+     */
+    public static Long[] toLong(long[] array) {
+        Long[] toArray = (array == null) ? new Long[0] : new Long[array.length];
+        for (int i = 0; i < toArray.length; i++) {
+            toArray[i] = array[i];
+        }
+        return toArray;
+    }
+
+    /**
+     * Converts Long[] array to primitive
+     * 
+     * @param array
+     * @return
+     */
+    public static long[] toPrimitive(Long[] array) {
+        long[] toArray = (array == null) ? new long[0] : new long[array.length];
+        for (int i = 0; i < toArray.length; i++) {
+            toArray[i] = array[i];
+        }
+        return toArray;
+    }
+
+    /**
+     * Converts a String value to an Object of the specified type
+     * 
+     * @param type
+     *            one of types listed in {@link #types}
+     * @param value
+     * @return instance of class <code>type</code>
+     * @throws IllegalArgumentException
+     *             if type or value are null or if the Class type does not support a valueOf() or cannot be converted to
+     *             a wrapper type
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> T fromString(Class<T> type, String value) {
+        if (type == null || !types.containsValue(type)) {
+            throw new IllegalArgumentException("Cannot convert to type argument : " + type);
+        }
+        if (value == null || value.length() < 1) {
+            throw new IllegalArgumentException("Argument value cannot be null or empty");
+        }
+        T result = null;
+        try {
+            if (type.equals(String.class)) {
+                result = (T) value;
+            } else if (type.equals(Character.class) || type.equals(Character.TYPE)) {
+                result = (T) Character.valueOf(value.charAt(0));
+            } else if (wrapperTypes.containsValue(type) || mathTypes.containsValue(type)) {
+                Constructor<? extends Object> constructor = type.getConstructor(String.class);
+                result = (T) constructor.newInstance(value);
+            } else if (primitiveToWrapper.containsKey(type)) { // attempt to promote to wrapper and resolve to the base
+                                                               // type
+                Class<? extends Object> promotedType = primitiveToWrapper.get(type);
+                char[] simpleTypeName = type.getName().toCharArray();
+                simpleTypeName[0] = Character.toUpperCase(simpleTypeName[0]);
+                String parseMethodName = "parse" + new String(simpleTypeName);
+                Method parseMethod = promotedType.getDeclaredMethod(parseMethodName, String.class);
+                result = (T) parseMethod.invoke(null, value);
+            } 
+        } catch (SecurityException e) {
+            throw new IllegalArgumentException("Cannot convert value [" + value + "] to type [" + type + "]", e);
+        } catch (NoSuchMethodException e) {
+            throw new IllegalArgumentException("Cannot convert value [" + value + "] to type [" + type + "]", e);
+        } catch (IllegalArgumentException e) {
+            throw new IllegalArgumentException("Cannot convert value [" + value + "] to type [" + type + "]", e);
+        } catch (IllegalAccessException e) {
+            throw new IllegalArgumentException("Cannot convert value [" + value + "] to type [" + type + "]", e);
+        } catch (InvocationTargetException e) {
+            throw new IllegalArgumentException("Cannot convert value [" + value + "] to type [" + type + "]", e);
+        } catch (InstantiationException e) {
+            throw new IllegalArgumentException("Cannot convert value [" + value + "] to type [" + type + "]", e);
+        }
+        return result;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/util/shared/RegistrableStandardEmitterMBean.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/util/shared/RegistrableStandardEmitterMBean.java
index b56de2e8..83876e14 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/util/shared/RegistrableStandardEmitterMBean.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/main/java/org/apache/aries/jmx/util/shared/RegistrableStandardEmitterMBean.java
@@ -1,3 +1,156 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.util.shared;
+
+import javax.management.ListenerNotFoundException;
+import javax.management.MBeanInfo;
+import javax.management.MBeanNotificationInfo;
+import javax.management.MBeanRegistration;
+import javax.management.MBeanServer;
+import javax.management.NotCompliantMBeanException;
+import javax.management.NotificationEmitter;
+import javax.management.NotificationFilter;
+import javax.management.NotificationListener;
+import javax.management.ObjectName;
+import javax.management.StandardMBean;
+
+/**
+ * The <code>StandardMBean</code> does not appear to delegate correctly to the underlying MBean implementation. Due to
+ * issues surrounding the <code>MBeanRegistration</code> callback methods and <code>NotificationEmmitter</code> methods,
+ * this subclass was introduced to force the delegation
+ * 
+ * @version $Rev$ $Date$
+ */
+public class RegistrableStandardEmitterMBean extends StandardMBean implements MBeanRegistration, NotificationEmitter {
+
+    public <T> RegistrableStandardEmitterMBean(T impl, Class<T> intf) throws NotCompliantMBeanException {
+        super(impl, intf);
+    }
+
+    /**
+     * @see javax.management.StandardMBean#getMBeanInfo()
+     */
+    public MBeanInfo getMBeanInfo() {
+        MBeanInfo mbeanInfo = super.getMBeanInfo();
+        if (mbeanInfo != null) {
+            MBeanNotificationInfo[] notificationInfo;
+            Object impl = getImplementation();
+            if (impl instanceof NotificationEmitter) {
+                notificationInfo = ((NotificationEmitter) (impl)).getNotificationInfo();
+            } else {
+                notificationInfo = new MBeanNotificationInfo[0];
+            }
+            mbeanInfo = new MBeanInfo(mbeanInfo.getClassName(), mbeanInfo.getDescription(), mbeanInfo.getAttributes(),
+                    mbeanInfo.getConstructors(), mbeanInfo.getOperations(), notificationInfo);
+        }
+        return mbeanInfo;
+    }
+
+    /**
+     * @see javax.management.MBeanRegistration#postDeregister()
+     */
+    public void postDeregister() {
+        Object impl = getImplementation();
+        if (impl instanceof MBeanRegistration) {
+            ((MBeanRegistration) impl).postDeregister();
+        }
+    }
+
+    /**
+     * @see javax.management.MBeanRegistration#postRegister(java.lang.Boolean)
+     */
+    public void postRegister(Boolean registrationDone) {
+        Object impl = getImplementation();
+        if (impl instanceof MBeanRegistration) {
+            ((MBeanRegistration) impl).postRegister(registrationDone);
+        }
+    }
+
+    /**
+     * @see javax.management.MBeanRegistration#preDeregister()
+     */
+    public void preDeregister() throws Exception {
+        Object impl = getImplementation();
+        if (impl instanceof MBeanRegistration) {
+            ((MBeanRegistration) impl).preDeregister();
+        }
+    }
+
+    /**
+     * @see javax.management.MBeanRegistration#preRegister(javax.management.MBeanServer, javax.management.ObjectName)
+     */
+    public ObjectName preRegister(MBeanServer server, ObjectName name) throws Exception {
+        ObjectName result = name;
+        Object impl = getImplementation();
+        if (impl instanceof MBeanRegistration) {
+            result = ((MBeanRegistration) impl).preRegister(server, name);
+        }
+        return result;
+    }
+
+    /**
+     * @see javax.management.NotificationEmitter#removeNotificationListener(javax.management.NotificationListener,
+     *      javax.management.NotificationFilter, java.lang.Object)
+     */
+    public void removeNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback)
+            throws ListenerNotFoundException {
+        Object impl = getImplementation();
+        if (impl instanceof NotificationEmitter) {
+            ((NotificationEmitter) (impl)).removeNotificationListener(listener, filter, handback);
+        }
+    }
+
+    /**
+     * @see javax.management.NotificationBroadcaster#addNotificationListener(javax.management.NotificationListener,
+     *      javax.management.NotificationFilter, java.lang.Object)
+     */
+    public void addNotificationListener(NotificationListener listener, NotificationFilter filter, Object handback)
+            throws IllegalArgumentException {
+        Object impl = getImplementation();
+        if (impl instanceof NotificationEmitter) {
+            ((NotificationEmitter) (impl)).addNotificationListener(listener, filter, handback);
+        }
+    }
+
+    /**
+     * @see javax.management.NotificationBroadcaster#getNotificationInfo()
+     */
+    public MBeanNotificationInfo[] getNotificationInfo() {
+        MBeanNotificationInfo[] result;
+        Object impl = getImplementation();
+        if (impl instanceof NotificationEmitter) {
+            result = ((NotificationEmitter) (impl)).getNotificationInfo();
+        } else {
+            result = new MBeanNotificationInfo[0];
+        }
+        return result;
+    }
+
+    /**
+     * @see javax.management.NotificationBroadcaster#removeNotificationListener(javax.management.NotificationListener)
+     */
+    public void removeNotificationListener(NotificationListener listener) throws ListenerNotFoundException {
+        Object impl = getImplementation();
+        if (impl instanceof NotificationEmitter) {
+            ((NotificationEmitter) (impl)).removeNotificationListener(listener);
+        }
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/CompendiumHandlerTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/CompendiumHandlerTest.java
index b56de2e8..785024de 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/CompendiumHandlerTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/CompendiumHandlerTest.java
@@ -1,3 +1,140 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx;
+
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.agent.JMXAgentContext;
+import org.junit.After;
+import org.junit.Test;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Filter;
+import org.osgi.framework.ServiceReference;
+
+public class CompendiumHandlerTest {
+
+    protected AbstractCompendiumHandler target;
+    
+    @After
+    public void tearDown(){
+        target = null;
+    }
+    
+    
+    @Test
+    public void testAddingServiceWillInitiateMBeanRegistration() throws Exception {
+        
+        Object service = new Object();
+        
+        ServiceReference reference = mock(ServiceReference.class);
+        BundleContext bundleContext = mock(BundleContext.class);
+        when(bundleContext.getService(reference)).thenReturn(service);
+        
+        Logger agentLogger = mock(Logger.class);
+        JMXAgentContext agentContext = mock(JMXAgentContext.class);
+        when(agentContext.getBundleContext()).thenReturn(bundleContext);
+        when(agentContext.getLogger()).thenReturn(agentLogger);
+        ExecutorService executor = Executors.newSingleThreadExecutor();
+        when(agentContext.getRegistrationExecutor()).thenReturn(executor);
+        
+        AbstractCompendiumHandler concreteHandler = new CompendiumHandler(agentContext, "org.osgi.service.Xxx");
+        target = spy(concreteHandler);
+        
+        target.addingService(reference);
+
+        executor.shutdown();
+        executor.awaitTermination(2, TimeUnit.SECONDS);
+        
+        //service only got once
+        verify(bundleContext).getService(reference);
+        //template method is invoked
+        verify(target).constructInjectMBean(service);
+        //registration is invoked on context
+        verify(agentContext).registerMBean(target);
+        
+    }
+
+    @Test
+    public void testRemovedServiceWillUnregisterMBean() throws Exception{
+        
+        Object service = new Object();
+        ServiceReference reference = mock(ServiceReference.class);
+        
+        BundleContext bundleContext = mock(BundleContext.class);
+        Logger agentLogger = mock(Logger.class);
+        JMXAgentContext agentContext = mock(JMXAgentContext.class);
+        when(agentContext.getBundleContext()).thenReturn(bundleContext);
+        when(agentContext.getLogger()).thenReturn(agentLogger);
+        ExecutorService executor = Executors.newSingleThreadExecutor();
+        when(agentContext.getRegistrationExecutor()).thenReturn(executor);
+        
+        AbstractCompendiumHandler concreteHandler = new CompendiumHandler(agentContext, "org.osgi.service.Xxx");
+        target = spy(concreteHandler);
+        
+        String name = "osgi.compendium:service=xxx,version=1.0";
+        doReturn(name).when(target).getName();
+        
+        target.removedService(reference, service);
+
+        executor.shutdown();
+        executor.awaitTermination(2, TimeUnit.SECONDS);
+        
+        //service unget
+        verify(bundleContext).ungetService(reference);
+        //unregister is invoked on context
+        verify(agentContext).unregisterMBean(name);
+        
+    }
+
+   
+    
+    /*
+     * Concrete implementation used for test
+     */
+    class CompendiumHandler extends AbstractCompendiumHandler {
+
+        protected CompendiumHandler(JMXAgentContext agentContext, Filter filter) {
+            super(agentContext, filter);
+        }
+
+        protected CompendiumHandler(JMXAgentContext agentContext, String clazz) {
+            super(agentContext, clazz);
+        }
+        
+        protected StandardMBean constructInjectMBean(Object targetService) {
+            return null;
+        }
+
+        public String getName() {
+            return null;
+        }
+        
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanHandlerTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanHandlerTest.java
index 56d8ebfd..bd199b0a 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanHandlerTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanHandlerTest.java
@@ -1,2 +1,54 @@
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.cm;
+
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Mockito.mock;
+
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.agent.JMXAgentContext;
+import org.junit.Test;
+import org.osgi.framework.BundleContext;
+import org.osgi.service.cm.ConfigurationAdmin;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class ConfigurationAdminMBeanHandlerTest {
+
+    
+    @Test
+    public void testConstructInjectMBean() {
+        
+        BundleContext bundleContext = mock(BundleContext.class);
+        Logger agentLogger = mock(Logger.class);   
+        JMXAgentContext agentContext = new JMXAgentContext(bundleContext, null, agentLogger);
+        ConfigurationAdmin cAdmin = mock(ConfigurationAdmin.class);
+        
+        ConfigurationAdminMBeanHandler handler = new ConfigurationAdminMBeanHandler(agentContext);
+        StandardMBean mbean = handler.constructInjectMBean(cAdmin);
+        assertNotNull(mbean);
+        
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminTest.java
index 1f8bddab..abe02ec3 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminTest.java
@@ -1,3 +1,251 @@
   + native
   + text/plain
   + Revision Date
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.cm;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.reset;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.osgi.jmx.JmxConstants.PROPERTIES_TYPE;
+
+import java.util.Dictionary;
+import java.util.Hashtable;
+
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularDataSupport;
+
+import org.apache.aries.jmx.codec.PropertyData;
+import org.junit.Test;
+import org.mockito.ArgumentCaptor;
+import org.osgi.framework.Constants;
+import org.osgi.service.cm.Configuration;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class ConfigurationAdminTest {
+
+   
+    @Test
+    public void testCreateFactoryConfiguration() throws Exception {
+        
+        org.osgi.service.cm.ConfigurationAdmin admin = mock(org.osgi.service.cm.ConfigurationAdmin.class);
+        String fpid = "org.apache.aries.jmx.mock.factory";
+        Configuration config = mock(Configuration.class);
+        
+        when(admin.createFactoryConfiguration(eq(fpid))).thenReturn(config);
+        when(admin.createFactoryConfiguration(eq(fpid), anyString())).thenReturn(config);
+        when(config.getPid()).thenReturn(fpid + "-1260133982371-0");
+        
+        ConfigurationAdmin mbean = new ConfigurationAdmin(admin);
+        assertEquals(fpid + "-1260133982371-0", mbean.createFactoryConfiguration(fpid));
+        assertEquals(fpid + "-1260133982371-0", mbean.createFactoryConfigurationForLocation(fpid, "/bundlex"));
+        
+    }
+
+   
+    @Test
+    public void testDelete() throws Exception {
+        
+        org.osgi.service.cm.ConfigurationAdmin admin = mock(org.osgi.service.cm.ConfigurationAdmin.class);
+        String pid = "org.apache.aries.jmx.mock";
+        Configuration config = mock(Configuration.class);
+        
+        when(admin.getConfiguration(pid, null)).thenReturn(config);
+        
+        ConfigurationAdmin mbean = new ConfigurationAdmin(admin);
+        mbean.delete(pid);
+        verify(config).delete();
+        
+        reset(config);
+        
+        when(admin.getConfiguration(pid, "location")).thenReturn(config);
+        mbean.deleteForLocation(pid, "location");
+        verify(config).delete();
+        
+    }
+
+  
+    @Test
+    public void testDeleteConfigurations() throws Exception {
+
+        org.osgi.service.cm.ConfigurationAdmin admin = mock(org.osgi.service.cm.ConfigurationAdmin.class);
+        String filter = "(" + Constants.SERVICE_PID + "=org.apache.aries.jmx.mock)";
+        
+        Configuration a = mock(Configuration.class);
+        Configuration b = mock(Configuration.class);
+        
+        when(admin.listConfigurations(filter)).thenReturn(new Configuration[] { a, b });
+        
+        ConfigurationAdmin mbean = new ConfigurationAdmin(admin);
+        mbean.deleteConfigurations(filter);
+
+        verify(a).delete();
+        verify(b).delete();
+        
+    }
+
+   
+    @Test
+    public void testGetBundleLocation() throws Exception {
+
+        org.osgi.service.cm.ConfigurationAdmin admin = mock(org.osgi.service.cm.ConfigurationAdmin.class);
+        String pid = "org.apache.aries.jmx.mock";
+        Configuration config = mock(Configuration.class);
+        
+        when(admin.getConfiguration(pid, null)).thenReturn(config);
+        when(config.getBundleLocation()).thenReturn("/location");
+        ConfigurationAdmin mbean = new ConfigurationAdmin(admin);
+        
+        assertEquals("/location", mbean.getBundleLocation(pid));
+        
+    }
+
+ 
+    @Test
+    public void testGetConfigurations() throws Exception {
+     
+        org.osgi.service.cm.ConfigurationAdmin admin = mock(org.osgi.service.cm.ConfigurationAdmin.class);
+        String factoryPid = "org.apache.aries.jmx.factory.mock";
+        String filter = "(" + org.osgi.service.cm.ConfigurationAdmin.SERVICE_FACTORYPID + "=org.apache.aries.jmx.factory.mock)";
+        String location = "../location";
+        
+        Configuration a = mock(Configuration.class);
+        when(a.getPid()).thenReturn(factoryPid + "-2160133952674-0");
+        when(a.getBundleLocation()).thenReturn(location);
+        Configuration b = mock(Configuration.class);
+        when(b.getPid()).thenReturn(factoryPid + "-1260133982371-1");
+        when(b.getBundleLocation()).thenReturn(location);
+        
+        when(admin.listConfigurations(filter)).thenReturn(new Configuration[] { a, b});
+        
+        ConfigurationAdmin mbean = new ConfigurationAdmin(admin);
+        String[][] result = mbean.getConfigurations(filter);
+        assertEquals(2, result.length);
+        assertArrayEquals(new String[]{ factoryPid + "-2160133952674-0", location }, result[0] );
+        assertArrayEquals(new String[]{ factoryPid + "-1260133982371-1", location }, result[1] );
+        
+    }
+
+   
+    @Test
+    public void testGetFactoryPid() throws Exception {
+
+        org.osgi.service.cm.ConfigurationAdmin admin = mock(org.osgi.service.cm.ConfigurationAdmin.class);
+        String factoryPid = "org.apache.aries.jmx.factory.mock";
+        
+        Configuration config = mock(Configuration.class);
+        when(admin.getConfiguration(eq(factoryPid  + "-1260133982371-0"), anyString())).thenReturn(config);
+        when(config.getFactoryPid()).thenReturn(factoryPid);
+        
+        ConfigurationAdmin mbean = new ConfigurationAdmin(admin);
+        assertEquals(factoryPid, mbean.getFactoryPid(factoryPid  + "-1260133982371-0"));
+        assertEquals(factoryPid, mbean.getFactoryPidForLocation(factoryPid  + "-1260133982371-0", "location"));
+        
+    }
+
+    
+    @Test
+    public void testGetProperties() throws Exception {
+
+        org.osgi.service.cm.ConfigurationAdmin admin = mock(org.osgi.service.cm.ConfigurationAdmin.class);
+        String pid = "org.apache.aries.jmx.mock";
+        Configuration config = mock(Configuration.class);
+        
+        Dictionary<String, Object> props = new Hashtable<String, Object>();
+        props.put("one", "value");
+        props.put("two", 2);
+        when(admin.getConfiguration(eq(pid), anyString())).thenReturn(config);
+        when(config.getProperties()).thenReturn(props);
+        
+        ConfigurationAdmin mbean = new ConfigurationAdmin(admin);
+        
+        TabularData properties = mbean.getPropertiesForLocation(pid, null);
+        assertNotNull(properties);
+        assertEquals(PROPERTIES_TYPE, properties.getTabularType());
+        assertEquals(2, properties.values().size());
+        PropertyData<? extends Object> oneData = PropertyData.from(properties.get(new Object[]{ "one"}));
+        assertEquals("value", oneData.getValue());
+        PropertyData<? extends Object> twoData = PropertyData.from(properties.get(new Object[]{ "two"}));
+        assertEquals(2, twoData.getValue());
+        assertEquals("2", twoData.getEncodedValue());
+        
+    }
+
+   
+
+    @Test
+    public void testSetBundleLocation() throws Exception {
+
+        org.osgi.service.cm.ConfigurationAdmin admin = mock(org.osgi.service.cm.ConfigurationAdmin.class);
+        String pid = "org.apache.aries.jmx.mock";
+        
+        Configuration config = mock(Configuration.class);
+        when(admin.getConfiguration(pid, null)).thenReturn(config);
+        
+        ConfigurationAdmin mbean = new ConfigurationAdmin(admin);
+        mbean.setBundleLocation(pid, "file:/newlocation");
+        
+        ArgumentCaptor<String> locationArgument = ArgumentCaptor.forClass(String.class);
+        verify(config).setBundleLocation(locationArgument.capture());
+        
+        assertEquals("file:/newlocation", locationArgument.getValue());
+        
+    }
+
+   
+    @SuppressWarnings("unchecked")
+    @Test
+    public void testUpdateTabularData() throws Exception {
+       
+        TabularData data = new TabularDataSupport(PROPERTIES_TYPE);
+        PropertyData<String> p1 = PropertyData.newInstance("one", "first");
+        data.put(p1.toCompositeData());
+        PropertyData<Integer> p2 = PropertyData.newInstance("two", 3);
+        data.put(p2.toCompositeData());
+        
+        org.osgi.service.cm.ConfigurationAdmin admin = mock(org.osgi.service.cm.ConfigurationAdmin.class);
+        String pid = "org.apache.aries.jmx.mock";
+        
+        Configuration config = mock(Configuration.class);
+        when(admin.getConfiguration(pid, null)).thenReturn(config);
+        
+        ConfigurationAdmin mbean = new ConfigurationAdmin(admin);
+        mbean.updateForLocation(pid, null, data);
+        
+        ArgumentCaptor<Dictionary> props = ArgumentCaptor.forClass(Dictionary.class);
+        verify(config).update(props.capture());
+        
+        Dictionary configProperties = props.getValue();
+        assertEquals("first", configProperties.get("one"));
+        assertEquals(3, configProperties.get("two"));
+        
+    }
+
+  
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/BundleDataTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/BundleDataTest.java
index b56de2e8..86799709 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/BundleDataTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/BundleDataTest.java
@@ -1,3 +1,279 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+import static org.osgi.jmx.framework.BundleStateMBean.BUNDLES_TYPE;
+import static org.osgi.jmx.framework.BundleStateMBean.BUNDLE_TYPE;
+import static org.osgi.jmx.framework.BundleStateMBean.EXPORTED_PACKAGES;
+import static org.osgi.jmx.framework.BundleStateMBean.FRAGMENT;
+import static org.osgi.jmx.framework.BundleStateMBean.FRAGMENTS;
+import static org.osgi.jmx.framework.BundleStateMBean.HEADERS;
+import static org.osgi.jmx.framework.BundleStateMBean.HEADERS_TYPE;
+import static org.osgi.jmx.framework.BundleStateMBean.HEADER_TYPE;
+import static org.osgi.jmx.framework.BundleStateMBean.HOSTS;
+import static org.osgi.jmx.framework.BundleStateMBean.IDENTIFIER;
+import static org.osgi.jmx.framework.BundleStateMBean.IMPORTED_PACKAGES;
+import static org.osgi.jmx.framework.BundleStateMBean.KEY;
+import static org.osgi.jmx.framework.BundleStateMBean.LAST_MODIFIED;
+import static org.osgi.jmx.framework.BundleStateMBean.LOCATION;
+import static org.osgi.jmx.framework.BundleStateMBean.PERSISTENTLY_STARTED;
+import static org.osgi.jmx.framework.BundleStateMBean.REGISTERED_SERVICES;
+import static org.osgi.jmx.framework.BundleStateMBean.REMOVAL_PENDING;
+import static org.osgi.jmx.framework.BundleStateMBean.REQUIRED;
+import static org.osgi.jmx.framework.BundleStateMBean.REQUIRED_BUNDLES;
+import static org.osgi.jmx.framework.BundleStateMBean.REQUIRING_BUNDLES;
+import static org.osgi.jmx.framework.BundleStateMBean.SERVICES_IN_USE;
+import static org.osgi.jmx.framework.BundleStateMBean.START_LEVEL;
+import static org.osgi.jmx.framework.BundleStateMBean.STATE;
+import static org.osgi.jmx.framework.BundleStateMBean.SYMBOLIC_NAME;
+import static org.osgi.jmx.framework.BundleStateMBean.VALUE;
+import static org.osgi.jmx.framework.BundleStateMBean.VERSION;
+
+import java.util.Dictionary;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Hashtable;
+import java.util.Map;
+import java.util.Set;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularDataSupport;
+
+import org.apache.aries.jmx.codec.BundleData.Header;
+import org.junit.Test;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Constants;
+import org.osgi.framework.ServiceReference;
+import org.osgi.framework.Version;
+import org.osgi.service.packageadmin.ExportedPackage;
+import org.osgi.service.packageadmin.PackageAdmin;
+import org.osgi.service.packageadmin.RequiredBundle;
+import org.osgi.service.startlevel.StartLevel;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class BundleDataTest {
+
+    
+    @Test
+    public void testToCompositeData() throws Exception {
+        
+        Bundle bundle = mock(Bundle.class);
+        BundleContext context = mock(BundleContext.class);
+        PackageAdmin packageAdmin = mock(PackageAdmin.class);
+        StartLevel startLevel = mock(StartLevel.class);
+        
+        Bundle b1 = mock(Bundle.class);
+        when(b1.getSymbolicName()).thenReturn("b1");
+        when(b1.getBundleId()).thenReturn(new Long(44));
+        Bundle b2 = mock(Bundle.class);
+        when(b2.getSymbolicName()).thenReturn("b2");
+        when(b2.getBundleId()).thenReturn(new Long(55));
+        Bundle b3 = mock(Bundle.class);
+        when(b3.getSymbolicName()).thenReturn("b3");
+        when(b3.getBundleId()).thenReturn(new Long(66));
+        when(context.getBundles()).thenReturn(new Bundle[] { bundle, b1, b2, b3 });
+      
+        when(bundle.getSymbolicName()).thenReturn("test");
+        when(bundle.getVersion()).thenReturn(Version.emptyVersion);
+        when(bundle.getBundleId()).thenReturn(new Long(1));
+        when(bundle.getLastModified()).thenReturn(new Long(12345));
+        when(bundle.getLocation()).thenReturn("location");
+        
+        //headers
+        Dictionary<String, String> headers = new Hashtable<String, String>();
+        headers.put(Constants.BUNDLE_SYMBOLICNAME, "test");
+        headers.put(Constants.BUNDLE_VERSION, "0.0.0");
+        when(bundle.getHeaders()).thenReturn(headers);
+        
+        //exported packages
+        ExportedPackage exported = mock(ExportedPackage.class);
+        when(exported.getName()).thenReturn("org.apache.aries.jmx");
+        when(exported.getVersion()).thenReturn(new Version("1.0.0"));
+        when(exported.getExportingBundle()).thenReturn(bundle);
+        when(packageAdmin.getExportedPackages(bundle)).thenReturn(new ExportedPackage[] { exported });
+        
+        //imported packages
+        ExportedPackage ep1 = mock(ExportedPackage.class);
+        when(ep1.getImportingBundles()).thenReturn(new Bundle[] { bundle, b2, b3 });
+        when(ep1.getName()).thenReturn("org.apache.aries.jmx.b1");
+        when(ep1.getVersion()).thenReturn(Version.emptyVersion);
+        when(ep1.getExportingBundle()).thenReturn(b1);
+        ExportedPackage ep2 = mock(ExportedPackage.class);
+        when(ep2.getImportingBundles()).thenReturn(new Bundle[] { bundle, b3 });
+        when(ep2.getName()).thenReturn("org.apache.aries.jmx.b2");
+        when(ep2.getVersion()).thenReturn(Version.parseVersion("2.0.1"));
+        when(ep2.getExportingBundle()).thenReturn(b2);
+        headers.put(Constants.DYNAMICIMPORT_PACKAGE, "*");
+  
+        when(packageAdmin.getExportedPackages(b1)).thenReturn(new ExportedPackage[] { ep1 });
+        when(packageAdmin.getExportedPackages(b2)).thenReturn(new ExportedPackage[] { ep2 });
+        when(packageAdmin.getExportedPackages(b3)).thenReturn(null);
+        
+        //required bundles
+        RequiredBundle rb1 = mock(RequiredBundle.class);
+        when(rb1.getBundle()).thenReturn(b1);
+        when(rb1.getRequiringBundles()).thenReturn(new Bundle[] { bundle, b2 });
+        RequiredBundle rb2 = mock(RequiredBundle.class);
+        when(rb2.getBundle()).thenReturn(b2);
+        when(rb2.getRequiringBundles()).thenReturn(new Bundle[] { b1 });
+        RequiredBundle rb3 = mock(RequiredBundle.class);
+        when(rb3.getBundle()).thenReturn(b3);
+        when(rb3.getRequiringBundles()).thenReturn(new Bundle[] { bundle, b1, b2 });
+        headers.put(Constants.REQUIRE_BUNDLE, "b1;bundle-version=\"1.0.0\",b3;bundle-version=\"2.0.0\"");
+        when(packageAdmin.getRequiredBundles("b1")).thenReturn(new RequiredBundle[] { rb1 });
+        when(packageAdmin.getRequiredBundles("b2")).thenReturn(new RequiredBundle[] { rb2 });
+        when(packageAdmin.getRequiredBundles("b3")).thenReturn(new RequiredBundle[] { rb3 });
+        
+        //services in use
+        ServiceReference s1 = mock(ServiceReference.class);
+        when(s1.getProperty(Constants.SERVICE_ID)).thenReturn(new Long(15));
+        ServiceReference s2 = mock(ServiceReference.class);
+        when(s2.getProperty(Constants.SERVICE_ID)).thenReturn(new Long(16));
+        ServiceReference s3 = mock(ServiceReference.class);
+        when(s3.getProperty(Constants.SERVICE_ID)).thenReturn(new Long(17));
+        
+        when(bundle.getServicesInUse()).thenReturn(new ServiceReference[] { s1, s2, s3 });
+        
+        BundleData b = new BundleData(context, bundle, packageAdmin, startLevel);
+        CompositeData compositeData = b.toCompositeData();
+        
+        assertEquals("test", compositeData.get(SYMBOLIC_NAME));
+        assertEquals("0.0.0", compositeData.get(VERSION));
+        TabularData headerTable = (TabularData) compositeData.get(HEADERS);
+        assertEquals(4, headerTable.values().size());
+        CompositeData header = headerTable.get(new Object[]{Constants.BUNDLE_SYMBOLICNAME});
+        assertNotNull(header);
+        String value = (String) header.get(VALUE);
+        assertEquals("test", value);
+        String key = (String)header.get(KEY);
+        assertEquals(Constants.BUNDLE_SYMBOLICNAME, key);
+        
+        
+        TabularData bundleTable = new TabularDataSupport(BUNDLES_TYPE);
+        bundleTable.put(b.toCompositeData());
+   
+        CompositeData bundleData = bundleTable.get(new Object[]{Long.valueOf(1)});
+        assertNotNull(bundleData);
+        String location = (String) bundleData.get(LOCATION);
+        assertEquals("location", location);
+        
+        assertArrayEquals(new String[] { "org.apache.aries.jmx;1.0.0"} , (String[]) compositeData.get(EXPORTED_PACKAGES));
+        assertArrayEquals(new String[] { "org.apache.aries.jmx.b1;0.0.0" , "org.apache.aries.jmx.b2;2.0.1"}, (String[]) compositeData.get(IMPORTED_PACKAGES));
+        assertEquals(toSet(new long[] { 44, 55, 66 }), toSet((Long[]) compositeData.get(REQUIRED_BUNDLES)));
+        assertArrayEquals(new Long[] { new Long(15), new Long(16), new Long(17) },(Long[]) compositeData.get(SERVICES_IN_USE));
+        assertEquals("UNKNOWN", compositeData.get(STATE)); //default no return stub
+        assertEquals(0,((Long[]) compositeData.get(HOSTS)).length);
+        assertEquals(0, ((Long[]) compositeData.get(FRAGMENTS)).length);
+        
+    }
+
+   
+    @Test
+    public void testFromCompositeData() throws Exception {
+
+        Map<String, Object> items = new HashMap<String, Object>();
+        items.put(EXPORTED_PACKAGES, new String[] { "org.apache.aries.jmx;1.0.0"});
+        items.put(FRAGMENT, false);
+        items.put(FRAGMENTS, new Long[0]);
+        items.put(HOSTS, new Long[0]);
+        items.put(IDENTIFIER, new Long(3));
+        items.put(IMPORTED_PACKAGES, new String[] { "org.apache.aries.jmx.b1;0.0.0" , "org.apache.aries.jmx.b2;2.0.1"});
+        items.put(LAST_MODIFIED, new Long(8797));
+        items.put(LOCATION, "");
+        items.put(PERSISTENTLY_STARTED, false);
+        items.put(REGISTERED_SERVICES, new Long[0]);
+        items.put(REMOVAL_PENDING, false);
+        items.put(REQUIRED, true);
+        items.put(REQUIRED_BUNDLES, new Long[] { new Long(44), new Long(66) });
+        items.put(REQUIRING_BUNDLES, new Long[0]);
+        items.put(SERVICES_IN_USE, new Long[] { new Long(15), new Long(16), new Long(17) });
+        items.put(START_LEVEL, 1);
+        items.put(STATE, "ACTIVE");
+        items.put(SYMBOLIC_NAME, "test");
+        items.put(VERSION, "0.0.0");
+        TabularData headerTable = new TabularDataSupport(HEADERS_TYPE);
+        headerTable.put(new Header("a", "a").toCompositeData());
+        headerTable.put(new Header("b", "b").toCompositeData());
+        items.put(HEADERS, headerTable);
+        CompositeData compositeData = new CompositeDataSupport(BUNDLE_TYPE, items);
+        
+        BundleData b = BundleData.from(compositeData);
+        
+        assertEquals("test", b.getSymbolicName());
+        assertEquals("0.0.0", b.getVersion());
+        assertEquals(2, b.getHeaders().size());
+        assertArrayEquals(new String[] { "org.apache.aries.jmx;1.0.0"} , b.getExportedPackages());
+        assertArrayEquals(new String[] { "org.apache.aries.jmx.b1;0.0.0" , "org.apache.aries.jmx.b2;2.0.1"}, b.getImportedPackages());
+        assertArrayEquals(new long[] { 44, 66 }, b.getRequiredBundles());
+        assertArrayEquals(new long[] { 15, 16, 17 }, b.getServicesInUse());
+        assertEquals("ACTIVE", b.getState()); //default no return stub
+        assertEquals(0, b.getHosts().length);
+        assertEquals(0, b.getFragments().length);
+    }
+
+    @Test
+    public void testHeaderToCompositeData() throws Exception{
+        
+        Header h1 = new Header("a", "b");
+        CompositeData compositeData = h1.toCompositeData();
+       
+        assertEquals("a", compositeData.get(KEY));
+        assertEquals("b", compositeData.get(VALUE));
+        
+    }
+    
+    @Test
+    public void testHeaderFromCompositeData() throws Exception {
+        
+        CompositeData compositeData = new CompositeDataSupport(HEADER_TYPE, new String[] { KEY, VALUE } , new String [] { "c", "d" });
+        Header header = Header.from(compositeData);
+        assertEquals("c", header.getKey());
+        assertEquals("d", header.getValue());
+        
+    }
+        
+    private static Set<Long> toSet(long[] array) {
+        Set<Long> set = new HashSet<Long>();
+        for (long value : array) {
+            set.add(value);
+        }
+        return set;
+    }
+    
+    private static Set<Long> toSet(Long[] array) {
+        Set<Long> set = new HashSet<Long>();
+        for (Long value : array) {
+            set.add(value);
+        }
+        return set;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/BundleEventDataTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/BundleEventDataTest.java
index b56de2e8..da2f34ea 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/BundleEventDataTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/BundleEventDataTest.java
@@ -1,3 +1,89 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+import static org.osgi.jmx.framework.BundleStateMBean.BUNDLE_EVENT_TYPE;
+import static org.osgi.jmx.framework.BundleStateMBean.EVENT;
+import static org.osgi.jmx.framework.BundleStateMBean.IDENTIFIER;
+import static org.osgi.jmx.framework.BundleStateMBean.LOCATION;
+import static org.osgi.jmx.framework.BundleStateMBean.SYMBOLIC_NAME;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+
+import org.junit.Test;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleEvent;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class BundleEventDataTest {
+
+   
+    @Test
+    public void testToCompositeData() throws Exception {
+
+        BundleEvent event = mock(BundleEvent.class);
+        Bundle bundle = mock(Bundle.class);
+        when(event.getBundle()).thenReturn(bundle);
+        when(bundle.getSymbolicName()).thenReturn("test");
+        when(bundle.getBundleId()).thenReturn(new Long(4));
+        when(bundle.getLocation()).thenReturn("location");
+        when(event.getType()).thenReturn(BundleEvent.INSTALLED);
+        
+        BundleEventData eventData = new BundleEventData(event);
+        CompositeData eventCompositeData = eventData.toCompositeData();
+        
+        assertEquals(new Long(4), (Long) eventCompositeData.get(IDENTIFIER));
+        assertEquals("test", (String) eventCompositeData.get(SYMBOLIC_NAME));
+        assertEquals(new Integer(BundleEvent.INSTALLED),  (Integer) eventCompositeData.get(EVENT));
+        assertEquals("location",  (String) eventCompositeData.get(LOCATION));
+        
+    }
+
+    
+    @Test
+    public void testFrom() throws Exception {
+
+        Map<String, Object> items = new HashMap<String, Object>();
+        items.put(IDENTIFIER, new Long(7));
+        items.put(SYMBOLIC_NAME, "t");
+        items.put(LOCATION, "l");
+        items.put(EVENT, BundleEvent.RESOLVED);
+
+        CompositeData compositeData = new CompositeDataSupport(BUNDLE_EVENT_TYPE, items);
+        BundleEventData event = BundleEventData.from(compositeData);
+        
+        assertEquals(7, event.getBundleId());
+        assertEquals("t", event.getBundleSymbolicName());
+        assertEquals("l", event.getLocation());
+        assertEquals(BundleEvent.RESOLVED, event.getEventType());
+            
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/PropertyDataTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/PropertyDataTest.java
index b56de2e8..c35519e5 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/PropertyDataTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/PropertyDataTest.java
@@ -1,3 +1,327 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.osgi.jmx.JmxConstants.BIGINTEGER;
+import static org.osgi.jmx.JmxConstants.BOOLEAN;
+import static org.osgi.jmx.JmxConstants.CHARACTER;
+import static org.osgi.jmx.JmxConstants.DOUBLE;
+import static org.osgi.jmx.JmxConstants.INTEGER;
+import static org.osgi.jmx.JmxConstants.KEY;
+import static org.osgi.jmx.JmxConstants.PROPERTY_TYPE;
+import static org.osgi.jmx.JmxConstants.P_BOOLEAN;
+import static org.osgi.jmx.JmxConstants.P_CHAR;
+import static org.osgi.jmx.JmxConstants.P_DOUBLE;
+import static org.osgi.jmx.JmxConstants.P_INT;
+import static org.osgi.jmx.JmxConstants.STRING;
+import static org.osgi.jmx.JmxConstants.TYPE;
+import static org.osgi.jmx.JmxConstants.VALUE;
+
+import java.math.BigInteger;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Vector;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+
+import org.junit.Test;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class PropertyDataTest {
+
+   
+    @Test
+    public void testToCompositeDataForPrimitiveTypes() throws Exception {
+        
+        PropertyData<Integer> intData = PropertyData.newInstance("test", 1);
+        CompositeData intCData = intData.toCompositeData();
+        assertEquals("test", intCData.get(KEY));
+        assertEquals("1", intCData.get(VALUE));
+        assertEquals(P_INT, intCData.get(TYPE));
+        
+        PropertyData<Double> doubleData = PropertyData.newInstance("test", 1.0);
+        CompositeData doubleCData = doubleData.toCompositeData();
+        assertEquals("test", doubleCData.get(KEY));
+        assertEquals("1.0", doubleCData.get(VALUE));
+        assertEquals(P_DOUBLE, doubleCData.get(TYPE));
+        
+        PropertyData<Character> charData = PropertyData.newInstance("test", 'c');
+        CompositeData charCData = charData.toCompositeData();
+        assertEquals("test", charCData.get(KEY));
+        assertEquals("c", charCData.get(VALUE));
+        assertEquals(P_CHAR, charCData.get(TYPE));
+        
+        PropertyData<Boolean> booleanData = PropertyData.newInstance("test", true);
+        CompositeData booleanCData = booleanData.toCompositeData();
+        assertEquals("test", booleanCData.get(KEY));
+        assertEquals("true", booleanCData.get(VALUE));
+        assertEquals(P_BOOLEAN, booleanCData.get(TYPE));
+    }
+    
+    @Test
+    public void testFromCompositeDataForPrimitiveTypes() throws Exception {
+        
+        Map<String, Object> items = new HashMap<String, Object>();
+        items.put(KEY, "key");
+        items.put(VALUE, "1");
+        items.put(TYPE, P_INT);
+        CompositeData compositeData = new CompositeDataSupport(PROPERTY_TYPE, items);
+        
+        PropertyData<Integer> intData = PropertyData.from(compositeData);
+        assertEquals("key", intData.getKey());
+        assertEquals(new Integer(1), intData.getValue());
+        assertEquals(P_INT, intData.getEncodedType());
+        assertTrue(intData.isEncodingPrimitive());
+        
+        items.clear();
+        items.put(KEY, "key");
+        items.put(VALUE, "1.0");
+        items.put(TYPE, P_DOUBLE);
+        compositeData = new CompositeDataSupport(PROPERTY_TYPE, items);
+        
+        PropertyData<Double> doubleData = PropertyData.from(compositeData);
+        assertEquals("key", doubleData.getKey());
+        assertEquals(Double.valueOf(1.0), doubleData.getValue());
+        assertEquals(P_DOUBLE, doubleData.getEncodedType());
+        assertTrue(doubleData.isEncodingPrimitive());
+        
+        items.clear();
+        items.put(KEY, "key");
+        items.put(VALUE, "a");
+        items.put(TYPE, P_CHAR);
+        compositeData = new CompositeDataSupport(PROPERTY_TYPE, items);
+        
+        PropertyData<Character> charData = PropertyData.from(compositeData);
+        assertEquals("key", charData.getKey());
+        assertEquals(Character.valueOf('a'), charData.getValue());
+        assertEquals(P_CHAR, charData.getEncodedType());
+        assertTrue(charData.isEncodingPrimitive());
+        
+        items.clear();
+        items.put(KEY, "key");
+        items.put(VALUE, "true");
+        items.put(TYPE, P_BOOLEAN);
+        compositeData = new CompositeDataSupport(PROPERTY_TYPE, items);
+        
+        PropertyData<Boolean> booleanData = PropertyData.from(compositeData);
+        assertEquals("key", booleanData.getKey());
+        assertTrue(booleanData.getValue());
+        assertEquals(P_BOOLEAN, booleanData.getEncodedType());
+        assertTrue(booleanData.isEncodingPrimitive());
+        
+    }
+    
+    @Test
+    public void testToCompositeDataForWrapperTypes() {
+        
+        PropertyData<Integer> intData = PropertyData.newInstance("test", new Integer(1));
+        CompositeData intCData = intData.toCompositeData();
+        assertEquals("test", intCData.get(KEY));
+        assertEquals("1", intCData.get(VALUE));
+        assertEquals(INTEGER, intCData.get(TYPE));
+        
+        PropertyData<Double> doubleData = PropertyData.newInstance("test", new Double(1.0));
+        CompositeData doubleCData = doubleData.toCompositeData();
+        assertEquals("test", doubleCData.get(KEY));
+        assertEquals("1.0", doubleCData.get(VALUE));
+        assertEquals(DOUBLE, doubleCData.get(TYPE));
+        
+        PropertyData<Character> charData = PropertyData.newInstance("test", Character.valueOf('c'));
+        CompositeData charCData = charData.toCompositeData();
+        assertEquals("test", charCData.get(KEY));
+        assertEquals("c", charCData.get(VALUE));
+        assertEquals(CHARACTER, charCData.get(TYPE));
+        
+        PropertyData<Boolean> booleanData = PropertyData.newInstance("test", Boolean.TRUE);
+        CompositeData booleanCData = booleanData.toCompositeData();
+        assertEquals("test", booleanCData.get(KEY));
+        assertEquals("true", booleanCData.get(VALUE));
+        assertEquals(BOOLEAN, booleanCData.get(TYPE));
+        
+    }
+    
+    @Test
+    public void testFromCompositeDataForWrapperTypes() throws Exception {
+        
+        Map<String, Object> items = new HashMap<String, Object>();
+        items.put(KEY, "key");
+        items.put(VALUE, "1");
+        items.put(TYPE, INTEGER);
+        CompositeData compositeData = new CompositeDataSupport(PROPERTY_TYPE, items);
+        
+        PropertyData<Integer> intData = PropertyData.from(compositeData);
+        assertEquals("key", intData.getKey());
+        assertEquals(new Integer(1), intData.getValue());
+        assertEquals(INTEGER, intData.getEncodedType());
+        assertFalse(intData.isEncodingPrimitive());
+        
+        items.clear();
+        items.put(KEY, "key");
+        items.put(VALUE, "1.0");
+        items.put(TYPE, DOUBLE);
+        compositeData = new CompositeDataSupport(PROPERTY_TYPE, items);
+        
+        PropertyData<Double> doubleData = PropertyData.from(compositeData);
+        assertEquals("key", doubleData.getKey());
+        assertEquals(Double.valueOf(1.0), doubleData.getValue());
+        assertEquals(DOUBLE, doubleData.getEncodedType());
+        assertFalse(doubleData.isEncodingPrimitive());
+        
+        items.clear();
+        items.put(KEY, "key");
+        items.put(VALUE, "a");
+        items.put(TYPE, CHARACTER);
+        compositeData = new CompositeDataSupport(PROPERTY_TYPE, items);
+        
+        PropertyData<Character> charData = PropertyData.from(compositeData);
+        assertEquals("key", charData.getKey());
+        assertEquals(Character.valueOf('a'), charData.getValue());
+        assertEquals(CHARACTER, charData.getEncodedType());
+        assertFalse(charData.isEncodingPrimitive());
+        
+        items.clear();
+        items.put(KEY, "key");
+        items.put(VALUE, "true");
+        items.put(TYPE, BOOLEAN);
+        compositeData = new CompositeDataSupport(PROPERTY_TYPE, items);
+        
+        PropertyData<Boolean> booleanData = PropertyData.from(compositeData);
+        assertEquals("key", booleanData.getKey());
+        assertTrue(booleanData.getValue());
+        assertEquals(BOOLEAN, booleanData.getEncodedType());
+        assertFalse(booleanData.isEncodingPrimitive());
+        
+    }
+    
+    @Test
+    public void testToFromCompositeDataForAdditionalTypes() {
+        
+        PropertyData<String> stringData = PropertyData.newInstance("test", "value");
+        
+        CompositeData stringCData = stringData.toCompositeData();
+        assertEquals("test", stringCData.get(KEY));
+        assertEquals("value", stringCData.get(VALUE));
+        assertEquals(STRING, stringCData.get(TYPE));
+        
+        stringData = PropertyData.from(stringCData);
+        assertEquals("test", stringData.getKey());
+        assertEquals("value", stringData.getValue());
+        assertEquals(STRING, stringData.getEncodedType());
+        
+        PropertyData<BigInteger> bigIntData = PropertyData.newInstance("test", new BigInteger("1"));
+        
+        CompositeData bigIntCData = bigIntData.toCompositeData();
+        assertEquals("test", bigIntCData.get(KEY));
+        assertEquals("1", bigIntCData.get(VALUE));
+        assertEquals(BIGINTEGER, bigIntCData.get(TYPE));
+        
+        bigIntData = PropertyData.from(bigIntCData);
+        assertEquals("test", bigIntData.getKey());
+        assertEquals(new BigInteger("1"), bigIntData.getValue());
+        assertEquals(BIGINTEGER, bigIntData.getEncodedType());
+        
+    }
+
+    @Test
+    public void testToFromCompositeDataForArrayTypes() {
+        
+        //long[]
+        long[] primitiveLongValues = new long[] { 1, 2, 3 };
+        PropertyData<long[]> primitiveLongArrayData = PropertyData.newInstance("test", primitiveLongValues);
+        CompositeData primitiveLongArrayCData = primitiveLongArrayData.toCompositeData();
+        assertEquals("test", primitiveLongArrayCData.get(KEY));
+        assertEquals("1,2,3", primitiveLongArrayCData.get(VALUE));
+        assertEquals("Array of long", primitiveLongArrayCData.get(TYPE));
+        primitiveLongArrayData = PropertyData.from(primitiveLongArrayCData);
+        assertEquals("test", primitiveLongArrayData.getKey());
+        assertEquals("Array of long", primitiveLongArrayData.getEncodedType());
+        assertArrayEquals(primitiveLongValues, primitiveLongArrayData.getValue());
+        
+        //Long[]
+        Long[] longValues = new Long[] { new Long(4), new Long(5), new Long(6) };
+        PropertyData<Long[]> longArrayData = PropertyData.newInstance("test", longValues);
+        CompositeData longArrayCData = longArrayData.toCompositeData();
+        assertEquals("test", longArrayCData.get(KEY));
+        assertEquals("4,5,6", longArrayCData.get(VALUE));
+        assertEquals("Array of Long", longArrayCData.get(TYPE));
+        longArrayData = PropertyData.from(longArrayCData);
+        assertEquals("test", longArrayData.getKey());
+        assertEquals("Array of Long", longArrayData.getEncodedType());
+        assertArrayEquals(longValues, longArrayData.getValue());
+        
+        //char[]
+        char[] primitiveCharValues = new char[] { 'a', 'b', 'c' };
+        PropertyData<char[]> primitiveCharArrayData = PropertyData.newInstance("test", primitiveCharValues);
+        CompositeData primitiveCharArrayCData = primitiveCharArrayData.toCompositeData();
+        assertEquals("test", primitiveCharArrayCData.get(KEY));
+        assertEquals("a,b,c", primitiveCharArrayCData.get(VALUE));
+        assertEquals("Array of char", primitiveCharArrayCData.get(TYPE));
+        primitiveCharArrayData = PropertyData.from(primitiveCharArrayCData);
+        assertEquals("test", primitiveCharArrayData.getKey());
+        assertEquals("Array of char", primitiveCharArrayData.getEncodedType());
+        assertArrayEquals(primitiveCharValues, primitiveCharArrayData.getValue());
+        
+        //Character[]
+        Character[] charValues = new Character[] { 'a', 'b', 'c' };
+        PropertyData<Character[]> charArrayData = PropertyData.newInstance("test", charValues);
+        CompositeData charArrayCData = charArrayData.toCompositeData();
+        assertEquals("test", charArrayCData.get(KEY));
+        assertEquals("a,b,c", charArrayCData.get(VALUE));
+        assertEquals("Array of Character", charArrayCData.get(TYPE));
+        charArrayData = PropertyData.from(charArrayCData);
+        assertEquals("test", charArrayData.getKey());
+        assertEquals("Array of Character", charArrayData.getEncodedType());
+        assertArrayEquals(charValues, charArrayData.getValue());
+        
+    }
+    
+    @Test
+    public void testToFromCompositeDataForVector() {
+        
+        Vector<Long> vector = new Vector<Long>();
+        vector.add(new Long(40));
+        vector.add(new Long(50));
+        vector.add(new Long(60));
+        
+        PropertyData<Vector<Long>> vectorPropertyData = PropertyData.newInstance("test", vector);
+        CompositeData vectorCompositeData = vectorPropertyData.toCompositeData();
+     
+        assertEquals("test", vectorCompositeData.get(KEY));
+        assertEquals("40,50,60", vectorCompositeData.get(VALUE));
+        assertEquals("Vector of Long", vectorCompositeData.get(TYPE));
+        
+        vectorPropertyData = PropertyData.from(vectorCompositeData);
+        assertEquals("test", vectorPropertyData.getKey());
+        assertEquals("Vector of Long", vectorPropertyData.getEncodedType());
+        assertArrayEquals(vector.toArray(new Long[vector.size()]), vectorPropertyData.getValue().toArray(new Long[vector.size()]));
+        
+    }
+    
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/ServiceDataTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/ServiceDataTest.java
index e69de29b..4c04b54d 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/ServiceDataTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/ServiceDataTest.java
@@ -0,0 +1,151 @@
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+import static org.osgi.jmx.framework.BundleStateMBean.IDENTIFIER;
+import static org.osgi.jmx.framework.ServiceStateMBean.BUNDLE_IDENTIFIER;
+import static org.osgi.jmx.framework.ServiceStateMBean.OBJECT_CLASS;
+import static org.osgi.jmx.framework.ServiceStateMBean.SERVICE_TYPE;
+import static org.osgi.jmx.framework.ServiceStateMBean.USING_BUNDLES;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+
+import org.junit.Test;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.Constants;
+import org.osgi.framework.ServiceReference;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class ServiceDataTest {
+
+   
+    @Test
+    public void testToCompositeData() throws Exception {
+
+        ServiceReference reference = mock(ServiceReference.class);
+        Bundle bundle = mock(Bundle.class);
+        String[] interfaces = new String[] { "org.apache.aries.jmx.Test", "org.apache.aries.jmx.Mock" };
+       
+        Bundle b1 = mock(Bundle.class);
+        when(b1.getBundleId()).thenReturn(new Long(6));
+        Bundle b2 = mock(Bundle.class);
+        when(b2.getBundleId()).thenReturn(new Long(9));
+        
+     
+        when(reference.getProperty(Constants.SERVICE_ID)).thenReturn(new Long(98));
+        when(reference.getBundle()).thenReturn(bundle);
+        when(bundle.getBundleId()).thenReturn(new Long(34));
+        when(reference.getProperty(Constants.OBJECTCLASS)).thenReturn(interfaces);
+        when(reference.getUsingBundles()).thenReturn(new Bundle[] { b1, b2 });
+        when(reference.getPropertyKeys()).thenReturn( new String[] {"x.vendor", "x.domain", "x.index", "x.optimized" } );
+        when(reference.getProperty("x.vendor")).thenReturn("aries");
+        when(reference.getProperty("x.domain")).thenReturn("test");
+        when(reference.getProperty("x.index")).thenReturn(new Long(67));
+        when(reference.getProperty("x.optimized")).thenReturn(true);
+        
+        
+        ServiceData serviceData = new ServiceData(reference);
+        
+        CompositeData compositeData = serviceData.toCompositeData();
+        assertEquals(new Long(98), compositeData.get(IDENTIFIER));
+        assertEquals(new Long(34), compositeData.get(BUNDLE_IDENTIFIER));
+        assertArrayEquals( new Long[] {new Long(6), new Long(9)}, (Long[]) compositeData.get(USING_BUNDLES));
+        assertArrayEquals(interfaces, (String[]) compositeData.get(OBJECT_CLASS));
+        // keep Properties for next version
+        //TabularData propertiesTable = (TabularData) compositeData.get(PROPERTIES);
+        //Collection<CompositeData> propertyData = (Collection<CompositeData>) propertiesTable.values();
+        //assertEquals(4, propertyData.size());
+        //for (CompositeData propertyRow: propertyData) {
+        //    String key = (String) propertyRow.get(KEY);
+        //    if (key.equals("x.vendor")) {
+        //        assertEquals("aries", propertyRow.get(VALUE));
+        //        assertEquals(STRING, propertyRow.get(TYPE));
+        //    } else if (key.equals("x.domain")) {
+        //        assertEquals("test", propertyRow.get(VALUE));
+        //        assertEquals(STRING, propertyRow.get(TYPE));
+        //    } else if (key.equals("x.index")) {
+        //        assertEquals("67", propertyRow.get(VALUE));
+        //        assertEquals(LONG, propertyRow.get(TYPE));
+        //    } else if (key.equals("x.optimized")) {
+        //        assertEquals("true", propertyRow.get(VALUE));
+        //        assertEquals(BOOLEAN, propertyRow.get(TYPE));
+        //    } else {
+        //        fail("unknown key parsed from properties");
+        //    }
+        //}
+    }
+
+   
+    @Test
+    public void testFromCompositeData() throws Exception {
+        
+        Map<String, Object> items = new HashMap<String, Object>();
+        items.put(IDENTIFIER, new Long(99));
+        items.put(BUNDLE_IDENTIFIER, new Long(5));
+        items.put(USING_BUNDLES, new Long[] { new Long(10), new Long(11) });
+        items.put(OBJECT_CLASS, new String[] { "org.apache.aries.jmx.Test", "org.apache.aries.jmx.Mock" });
+        //TabularData propertyTable = new TabularDataSupport(PROPERTIES_TYPE);
+        //propertyTable.put(PropertyData.newInstance("a", true).toCompositeData());
+        //propertyTable.put(PropertyData.newInstance("b", "value").toCompositeData());
+        //propertyTable.put(PropertyData.newInstance("c", new int[] {1, 2}).toCompositeData());
+        //propertyTable.put(PropertyData.newInstance("d", new Long[] {new Long(3), new Long(4)}).toCompositeData());
+        //items.put(PROPERTIES, propertyTable);
+        CompositeData compositeData = new CompositeDataSupport(SERVICE_TYPE, items);
+        
+        ServiceData data = ServiceData.from(compositeData);
+        assertEquals(99, data.getServiceId());
+        assertEquals(5, data.getBundleId());
+        assertArrayEquals(new long[] {10, 11}, data.getUsingBundles());
+        assertArrayEquals(new String[] { "org.apache.aries.jmx.Test", "org.apache.aries.jmx.Mock" }, data.getServiceInterfaces());
+        
+        //List<PropertyData<? extends Object>> properties = data.getProperties();
+        //assertEquals(4, properties.size());
+        
+        //for (PropertyData<? extends Object> property: properties) {
+        //    if (property.getKey().equals("a")) {
+        //        assertTrue((Boolean) property.getValue());
+        //        assertEquals(P_BOOLEAN, property.getEncodedType());
+        //    } else if (property.getKey().equals("b")) {
+        //        assertEquals("value", property.getValue());
+        //        assertEquals(STRING, property.getEncodedType());
+        //    } else if (property.getKey().equals("c")) {
+        //        assertArrayEquals(new int[] { 1, 2 }, (int[]) property.getValue());
+        //        assertEquals("Array of int", property.getEncodedType());
+        //        assertEquals("1,2", property.getEncodedValue());
+        //    } else if (property.getKey().equals("d")) {
+        //        assertArrayEquals(new Long[] {new Long(3), new Long(4) }, (Long[]) property.getValue());
+        //        assertEquals("Array of Long", property.getEncodedType());
+        //        assertEquals("3,4", property.getEncodedValue());
+        //    } else {
+        //        fail("unknown key parsed from properties");
+        //    }
+        //}       
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/ServiceEventDataTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/ServiceEventDataTest.java
index 1f8bddab..2fbfe4b6 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/ServiceEventDataTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/codec/ServiceEventDataTest.java
@@ -1,3 +1,105 @@
   + native
   + text/plain
   + Revision Date
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.codec;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+import static org.osgi.jmx.framework.ServiceStateMBean.BUNDLE_IDENTIFIER;
+import static org.osgi.jmx.framework.ServiceStateMBean.BUNDLE_LOCATION;
+import static org.osgi.jmx.framework.ServiceStateMBean.BUNDLE_SYMBOLIC_NAME;
+import static org.osgi.jmx.framework.ServiceStateMBean.EVENT;
+import static org.osgi.jmx.framework.ServiceStateMBean.IDENTIFIER;
+import static org.osgi.jmx.framework.ServiceStateMBean.OBJECT_CLASS;
+import static org.osgi.jmx.framework.ServiceStateMBean.SERVICE_EVENT_TYPE;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeDataSupport;
+
+import org.junit.Test;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.Constants;
+import org.osgi.framework.ServiceEvent;
+import org.osgi.framework.ServiceReference;
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class ServiceEventDataTest {
+
+    
+    @Test
+    public void testToCompositeData() throws Exception {
+
+        ServiceEvent event = mock(ServiceEvent.class);
+        ServiceReference reference = mock(ServiceReference.class);
+        Bundle bundle = mock(Bundle.class);
+        
+        when(event.getType()).thenReturn(ServiceEvent.REGISTERED);
+        when(event.getServiceReference()).thenReturn(reference);
+        when(reference.getProperty(Constants.SERVICE_ID)).thenReturn(new Long(44));
+        when(reference.getProperty(Constants.OBJECTCLASS)).thenReturn(new String[] {"org.apache.aries.jmx.Mock"});
+        when(reference.getBundle()).thenReturn(bundle);
+        when(bundle.getBundleId()).thenReturn(new Long(1));
+        when(bundle.getLocation()).thenReturn("string");
+        when(bundle.getSymbolicName()).thenReturn("org.apache.aries.jmx.core");
+        
+        ServiceEventData eventData = new ServiceEventData(event);
+        CompositeData data = eventData.toCompositeData();
+        
+        assertEquals(new Long(44), data.get(IDENTIFIER));
+        assertEquals(new Long(1), data.get(BUNDLE_IDENTIFIER));
+        assertEquals("string", data.get(BUNDLE_LOCATION));
+        assertEquals("org.apache.aries.jmx.core", data.get(BUNDLE_SYMBOLIC_NAME));
+        assertArrayEquals(new String[] {"org.apache.aries.jmx.Mock" }, (String[]) data.get(OBJECT_CLASS));
+        assertEquals(ServiceEvent.REGISTERED, data.get(EVENT));
+        
+    }
+
+    
+    @Test
+    public void testFrom() throws Exception {
+        
+        Map<String, Object> items = new HashMap<String, Object>();
+        items.put(IDENTIFIER, new Long(7));
+        items.put(BUNDLE_IDENTIFIER, new Long(67));
+        items.put(BUNDLE_LOCATION, "string");
+        items.put(BUNDLE_SYMBOLIC_NAME, "test");
+        items.put(OBJECT_CLASS, new String[] {"org.apache.aries.jmx.Mock" });
+        items.put(EVENT, ServiceEvent.MODIFIED);
+
+        CompositeData compositeData = new CompositeDataSupport(SERVICE_EVENT_TYPE, items);
+        ServiceEventData event = ServiceEventData.from(compositeData);
+        
+        assertEquals(7, event.getServiceId());
+        assertEquals(67, event.getBundleId());
+        assertArrayEquals(new String[] {"org.apache.aries.jmx.Mock" }, event.getServiceInterfaces());
+        assertEquals("test", event.getBundleSymbolicName());
+        assertEquals("string", event.getBundleLocation());
+        assertEquals(ServiceEvent.MODIFIED, event.getEventType());
+        
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/BundleStateMBeanHandlerTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/BundleStateMBeanHandlerTest.java
index b56de2e8..0ab121a6 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/BundleStateMBeanHandlerTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/BundleStateMBeanHandlerTest.java
@@ -1,3 +1,67 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import static org.junit.Assert.*;
+
+import org.apache.aries.jmx.Logger;
+import org.junit.Test;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceReference;
+import org.osgi.service.packageadmin.PackageAdmin;
+import org.osgi.service.startlevel.StartLevel;
+
+import static org.mockito.Mockito.*;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class BundleStateMBeanHandlerTest {
+
+    
+    @Test
+    public void testOpenAndClose() throws Exception {
+        
+        BundleContext context = mock(BundleContext.class);
+        Logger logger = mock(Logger.class);
+        
+        ServiceReference packageAdminRef = mock(ServiceReference.class);
+        PackageAdmin packageAdmin = mock(PackageAdmin.class);
+        when(context.getServiceReference(PackageAdmin.class.getName())).thenReturn(packageAdminRef);
+        when(context.getService(packageAdminRef)).thenReturn(packageAdmin);
+        ServiceReference startLevelRef = mock(ServiceReference.class);
+        StartLevel startLevel = mock(StartLevel.class);
+        when(context.getServiceReference(StartLevel.class.getName())).thenReturn(startLevelRef);
+        when(context.getService(startLevelRef)).thenReturn(startLevel);
+        
+        BundleStateMBeanHandler handler = new BundleStateMBeanHandler(context, logger);
+        handler.open();
+        
+        assertNotNull(handler.getMbean());
+        
+        handler.close();
+        verify(context).ungetService(packageAdminRef);
+        verify(context).ungetService(startLevelRef);
+        
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/BundleStateTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/BundleStateTest.java
index b56de2e8..92ede76c 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/BundleStateTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/BundleStateTest.java
@@ -1,3 +1,191 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.atMost;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.osgi.jmx.framework.BundleStateMBean.OBJECTNAME;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+
+import javax.management.MBeanServer;
+import javax.management.Notification;
+import javax.management.NotificationListener;
+import javax.management.ObjectName;
+import javax.management.openmbean.CompositeData;
+
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.codec.BundleEventData;
+import org.junit.Test;
+import org.mockito.ArgumentCaptor;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.BundleEvent;
+import org.osgi.framework.BundleListener;
+import org.osgi.service.packageadmin.PackageAdmin;
+import org.osgi.service.startlevel.StartLevel;
+
+
+public class BundleStateTest {
+
+    @Test
+    public void testNotificationsForBundleEvents() throws Exception {
+        
+        BundleContext context = mock(BundleContext.class);
+        PackageAdmin admin = mock(PackageAdmin.class);
+        StartLevel startLevel = mock(StartLevel.class);
+        Logger logger = mock(Logger.class);
+        
+        //holder for Notifications captured
+        final List<Notification> received = new LinkedList<Notification>();
+        
+        BundleState bundleState = new BundleState(context, admin, startLevel, logger);
+        
+        Bundle b1 = mock(Bundle.class);
+        when(b1.getBundleId()).thenReturn(new Long(9));
+        when(b1.getSymbolicName()).thenReturn("bundle");
+        when(b1.getLocation()).thenReturn("file:/location");
+        
+        BundleEvent installedEvent = mock(BundleEvent.class);
+        when(installedEvent.getBundle()).thenReturn(b1);
+        when(installedEvent.getType()).thenReturn(BundleEvent.INSTALLED);
+       
+        BundleEvent resolvedEvent = mock(BundleEvent.class);
+        when(resolvedEvent.getBundle()).thenReturn(b1);
+        when(resolvedEvent.getType()).thenReturn(BundleEvent.RESOLVED);
+        
+        MBeanServer server = mock(MBeanServer.class);
+        
+        //setup for notification
+        ObjectName objectName = new ObjectName(OBJECTNAME);
+        bundleState.preRegister(server, objectName);
+        bundleState.postRegister(true);
+        
+        //add NotificationListener to receive the events
+        bundleState.addNotificationListener(new NotificationListener() {
+            public void handleNotification(Notification notification, Object handback) {
+               received.add(notification);
+            }
+        }, null, null);
+        
+        // capture the BundleListener registered with BundleContext to issue BundleEvents
+        ArgumentCaptor<BundleListener> argument = ArgumentCaptor.forClass(BundleListener.class);        
+        verify(context).addBundleListener(argument.capture());
+        
+        //send events
+        BundleListener listener = argument.getValue();
+        listener.bundleChanged(installedEvent);
+        listener.bundleChanged(resolvedEvent);
+        
+        //shutdown dispatcher via unregister callback 
+        bundleState.postDeregister();
+        //check the BundleListener is cleaned up
+        verify(context).removeBundleListener(listener);
+        
+        ExecutorService dispatcher = bundleState.getEventDispatcher();
+        assertTrue(dispatcher.isShutdown());
+        dispatcher.awaitTermination(2, TimeUnit.SECONDS);
+        assertTrue(dispatcher.isTerminated());
+        
+        assertEquals(2, received.size());
+        Notification installed = received.get(0);
+        assertEquals(1, installed.getSequenceNumber());
+        CompositeData installedCompositeData = (CompositeData) installed.getUserData();
+        BundleEventData installedData = BundleEventData.from(installedCompositeData);
+        assertEquals("bundle", installedData.getBundleSymbolicName());
+        assertEquals(9, installedData.getBundleId());
+        assertEquals("file:/location", installedData.getLocation());
+        assertEquals(BundleEvent.INSTALLED, installedData.getEventType());
+        
+        Notification resolved = received.get(1);
+        assertEquals(2, resolved.getSequenceNumber());
+        CompositeData resolvedCompositeData = (CompositeData) resolved.getUserData();
+        BundleEventData resolvedData = BundleEventData.from(resolvedCompositeData);
+        assertEquals("bundle", resolvedData.getBundleSymbolicName());
+        assertEquals(9, resolvedData.getBundleId());
+        assertEquals("file:/location", resolvedData.getLocation());
+        assertEquals(BundleEvent.RESOLVED, resolvedData.getEventType());
+        
+    }
+    
+    @Test
+    public void testLifeCycleOfNotificationSupport() throws Exception {
+        
+        BundleContext context = mock(BundleContext.class);
+        PackageAdmin admin = mock(PackageAdmin.class);
+        StartLevel startLevel = mock(StartLevel.class);
+        Logger logger = mock(Logger.class);
+        
+        BundleState bundleState = new BundleState(context, admin, startLevel, logger);
+        
+        MBeanServer server1 = mock(MBeanServer.class);
+        MBeanServer server2 = mock(MBeanServer.class);
+
+        ObjectName objectName = new ObjectName(OBJECTNAME);
+        bundleState.preRegister(server1, objectName);
+        bundleState.postRegister(true);
+        
+        // capture the BundleListener registered with BundleContext
+        ArgumentCaptor<BundleListener> argument = ArgumentCaptor.forClass(BundleListener.class);        
+        verify(context).addBundleListener(argument.capture());
+        assertEquals(1, argument.getAllValues().size());
+        
+        BundleListener listener = argument.getValue();
+        assertNotNull(listener);
+        
+        ExecutorService dispatcher = bundleState.getEventDispatcher();
+        
+        //do registration with another server
+        bundleState.preRegister(server2, objectName);
+        bundleState.postRegister(true);
+        
+        // check no more actions on BundleContext
+        argument = ArgumentCaptor.forClass(BundleListener.class);        
+        verify(context, atMost(1)).addBundleListener(argument.capture());
+        assertEquals(1, argument.getAllValues().size());
+        
+        //do one unregister
+        bundleState.postDeregister();
+        
+        //verify bundleListener not invoked
+        verify(context, never()).removeBundleListener(listener);
+        assertFalse(dispatcher.isShutdown());
+        
+        //do second unregister and check cleanup
+        bundleState.postDeregister();
+        verify(context).removeBundleListener(listener);
+        assertTrue(dispatcher.isShutdown());
+        dispatcher.awaitTermination(2, TimeUnit.SECONDS);
+        assertTrue(dispatcher.isTerminated());
+        
+      
+        
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/FrameworkTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/FrameworkTest.java
index 1f8bddab..1f8f498f 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/FrameworkTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/FrameworkTest.java
@@ -1,3 +1,507 @@
   + native
   + text/plain
   + Revision Date
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+import javax.management.openmbean.CompositeData;
+
+import org.junit.Assert;
+
+import org.apache.aries.jmx.codec.BatchActionResult;
+import org.apache.aries.jmx.codec.BatchInstallResult;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.BundleException;
+import org.osgi.jmx.framework.FrameworkMBean;
+import org.osgi.service.packageadmin.PackageAdmin;
+import org.osgi.service.startlevel.StartLevel;
+
+/**
+ * {@link FrameworkMBean} test case.
+ * 
+ * 
+ * @version $Rev$ $Date$
+ */
+public class FrameworkTest {
+
+    @Mock
+    private StartLevel startLevel;
+    @Mock
+    private PackageAdmin admin;
+    @Mock
+    private BundleContext context;
+    private Framework mbean;
+
+    @Before
+    public void setUp() throws Exception {
+        MockitoAnnotations.initMocks(this);
+        mbean = new Framework(context, startLevel, admin);
+    }
+
+    @Test
+    public void testGetFrameworkStartLevel() throws IOException {
+        Mockito.when(startLevel.getStartLevel()).thenReturn(1);
+        int level = mbean.getFrameworkStartLevel();
+        Assert.assertEquals(1, level);
+    }
+
+    @Test
+    public void testGetInitialBundleStartLevel() throws IOException {
+        Mockito.when(startLevel.getInitialBundleStartLevel()).thenReturn(2);
+        int level = mbean.getInitialBundleStartLevel();
+        Mockito.verify(startLevel).getInitialBundleStartLevel();
+        Assert.assertEquals(2, level);
+    }
+
+    @Test
+    public void testInstallBundle() throws Exception {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.installBundle("file:test.jar")).thenReturn(bundle);
+        Mockito.when(bundle.getBundleId()).thenReturn(Long.valueOf(2));
+        long bundleId = mbean.installBundle("file:test.jar");
+        Assert.assertEquals(2, bundleId);
+        Mockito.reset(context);
+        Mockito.when(context.installBundle("file:test2.jar")).thenThrow(new BundleException("location doesn't exist"));
+
+        try {
+            mbean.installBundle("file:test2.jar");
+            Assert.fail("Shouldn't go to this stage, location doesn't exist");
+        } catch (IOException e) {
+            // ok
+        }
+
+    }
+
+    @Test
+    public void testInstallBundleFromURL() throws Exception {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.installBundle(Mockito.anyString(), Mockito.any(InputStream.class))).thenReturn(bundle);
+        Mockito.when(bundle.getBundleId()).thenReturn(Long.valueOf(2));
+        Framework spiedMBean = Mockito.spy(mbean);
+        InputStream stream = Mockito.mock(InputStream.class);
+        Mockito.doReturn(stream).when(spiedMBean).createStream("test.jar");
+        long bundleId = spiedMBean.installBundleFromURL("file:test.jar", "test.jar");
+        Assert.assertEquals(2, bundleId);
+        Mockito.reset(context);
+        Mockito.doReturn(stream).when(spiedMBean).createStream(Mockito.anyString());
+        Mockito.when(context.installBundle(Mockito.anyString(), Mockito.any(InputStream.class))).thenThrow(
+                new BundleException("location doesn't exist"));
+
+        try {
+            spiedMBean.installBundleFromURL("file:test2.jar", "test.jar");
+            Assert.fail("Shouldn't go to this stage, location doesn't exist");
+        } catch (IOException e) {
+            // ok
+        }
+    }
+
+    @Test
+    public void testInstallBundles() throws Exception {
+        String[] locations = new String[] { "file:test.jar" };
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.installBundle("file:test.jar")).thenReturn(bundle);
+        Mockito.when(bundle.getBundleId()).thenReturn(Long.valueOf(2));
+        CompositeData data = mbean.installBundles(locations);
+        BatchInstallResult batch = BatchInstallResult.from(data);
+        Assert.assertNotNull(batch);
+        Assert.assertEquals(2, batch.getCompleted()[0]);
+        Assert.assertTrue(batch.isSuccess());
+        Assert.assertNull(batch.getError());
+        Assert.assertNull(batch.getRemainingLocationItems());
+        Mockito.reset(context);
+        Mockito.when(context.installBundle("file:test.jar")).thenThrow(new BundleException("location doesn't exist"));
+        CompositeData data2 = mbean.installBundles(locations);
+        BatchInstallResult batch2 = BatchInstallResult.from(data2);
+        Assert.assertNotNull(batch2);
+        Assert.assertNotNull(batch2.getCompleted());
+        Assert.assertEquals(0, batch2.getCompleted().length);
+        Assert.assertFalse(batch2.isSuccess());
+        Assert.assertNotNull(batch2.getError());
+        Assert.assertEquals("file:test.jar", batch2.getBundleInError());
+        Assert.assertNotNull(batch2.getRemainingLocationItems());
+        Assert.assertEquals(0, batch2.getRemainingLocationItems().length); 
+    }
+
+    @Test
+    public void testInstallBundlesFromURL() throws Exception {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.installBundle(Mockito.anyString(), Mockito.any(InputStream.class))).thenReturn(bundle);
+        Mockito.when(bundle.getBundleId()).thenReturn(Long.valueOf(2));
+        Framework spiedMBean = Mockito.spy(mbean);
+        InputStream stream = Mockito.mock(InputStream.class);
+        Mockito.doReturn(stream).when(spiedMBean).createStream(Mockito.anyString());
+        CompositeData data = spiedMBean.installBundlesFromURL(new String[] { "file:test.jar" }, new String[] { "test.jar" });
+        Assert.assertNotNull(data);
+        BatchInstallResult batch = BatchInstallResult.from(data);
+        Assert.assertEquals(2, batch.getCompleted()[0]);
+        Assert.assertTrue(batch.isSuccess());
+        Assert.assertNull(batch.getError());
+        Assert.assertNull(batch.getRemainingLocationItems());
+        Mockito.reset(context);
+        Mockito.when(spiedMBean.createStream(Mockito.anyString())).thenReturn(stream);
+        Mockito.when(context.installBundle(Mockito.anyString(), Mockito.any(InputStream.class))).thenThrow(
+                new BundleException("location doesn't exist"));
+        CompositeData data2 = spiedMBean.installBundlesFromURL(new String[] { "file:test.jar" }, new String[] { "test.jar" });
+        BatchInstallResult batch2 = BatchInstallResult.from(data2);
+        Assert.assertNotNull(batch2);
+        Assert.assertNotNull(batch2.getCompleted());
+        Assert.assertEquals(0, batch2.getCompleted().length);
+        Assert.assertFalse(batch2.isSuccess());
+        Assert.assertNotNull(batch2.getError());
+        Assert.assertEquals("file:test.jar", batch2.getBundleInError());
+        Assert.assertNotNull(batch2.getRemainingLocationItems());
+        Assert.assertEquals(0, batch2.getRemainingLocationItems().length);     
+    }
+
+    @Test
+    public void testRefreshBundle() throws Exception {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(1)).thenReturn(bundle);
+
+        mbean.refreshBundle(1);
+        Mockito.verify(admin).refreshPackages((Bundle[]) Mockito.any());
+
+        try {
+            mbean.refreshBundle(2);
+            Assert.fail("IOException should be thrown");
+        } catch (IOException e) {
+            // expected
+        }
+    }
+
+    @Test
+    public void testRefreshBundles() throws IOException {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(1)).thenReturn(bundle);
+
+        mbean.refreshBundles(new long[] { 1 });
+        Mockito.verify(admin).refreshPackages((Bundle[]) Mockito.any());
+
+        mbean.refreshBundles(null);
+        Mockito.verify(admin).refreshPackages(null);
+    }
+
+    @Test
+    public void testResolveBundle() throws IOException {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(1)).thenReturn(bundle);
+
+        mbean.resolveBundle(1);
+        Mockito.verify(admin).resolveBundles(new Bundle[] { bundle });
+    }
+
+    @Test
+    public void testResolveBundles() throws IOException {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(1)).thenReturn(bundle);
+
+        mbean.resolveBundles(new long[] { 1 });
+        Mockito.verify(admin).resolveBundles(new Bundle[] { bundle });
+
+        mbean.resolveBundles(null);
+        Mockito.verify(admin).resolveBundles(null);
+    }
+
+    @Test
+    public void testRestartFramework() throws Exception {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(0)).thenReturn(bundle);
+        mbean.restartFramework();
+        Mockito.verify(bundle).update();
+    }
+
+    @Test
+    public void testSetBundleStartLevel() throws IOException {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(2)).thenReturn(bundle);
+        mbean.setBundleStartLevel(2, 1);
+        Mockito.verify(startLevel).setBundleStartLevel(bundle, 1);
+    }
+
+    @Test
+    public void testSetBundleStartLevels() throws IOException {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(2)).thenReturn(bundle);
+        CompositeData data = mbean.setBundleStartLevels(new long[] { 2 }, new int[] { 2 });
+        Mockito.verify(startLevel).setBundleStartLevel(bundle, 2);
+        BatchActionResult batch = BatchActionResult.from(data);
+        Assert.assertEquals(2, batch.getCompleted()[0]);
+        Assert.assertTrue(batch.isSuccess());
+        Assert.assertNull(batch.getError());
+        Assert.assertNull(batch.getRemainingItems());
+
+        CompositeData data2 = mbean.setBundleStartLevels(new long[] { 2 }, new int[] { 2, 4 });
+        BatchActionResult batch2 = BatchActionResult.from(data2);
+        Assert.assertNull(batch2.getCompleted());
+        Assert.assertFalse(batch2.isSuccess());
+        Assert.assertNotNull(batch2.getError());
+        Assert.assertNull(batch2.getRemainingItems());
+
+    }
+
+    @Test
+    public void testSetFrameworkStartLevel() throws IOException {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(0)).thenReturn(bundle);
+        mbean.setFrameworkStartLevel(1);
+        Mockito.verify(startLevel).setStartLevel(1);
+
+    }
+
+    @Test
+    public void testSetInitialBundleStartLevel() throws IOException {
+        mbean.setInitialBundleStartLevel(5);
+        Mockito.verify(startLevel).setInitialBundleStartLevel(5);
+    }
+
+    @Test
+    public void testShutdownFramework() throws Exception {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(0)).thenReturn(bundle);
+        mbean.shutdownFramework();
+        Mockito.verify(bundle).stop();
+    }
+
+    @Test
+    public void testStartBundle() throws Exception {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(5)).thenReturn(bundle);
+        mbean.startBundle(5);
+        Mockito.verify(bundle).start();
+
+        Mockito.reset(context);
+        Mockito.when(context.getBundle(6)).thenReturn(bundle);
+        Mockito.doThrow(new BundleException("")).when(bundle).start();
+
+        try {
+            mbean.startBundle(6);
+            Assert.fail("Shouldn't go to this stage, BundleException was thrown");
+        } catch (IOException ioe) {
+            // expected
+        }
+        
+        Mockito.when(context.getBundle(6)).thenReturn(null);
+        try {
+            mbean.startBundle(6);
+            Assert.fail("IOException should be thrown");
+        } catch (IOException e) {
+            //expected
+        }
+    }
+
+    @Test
+    public void testStartBundles() throws Exception {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(5)).thenReturn(bundle);
+        CompositeData data = mbean.startBundles(new long[] { 5 });
+        Mockito.verify(bundle).start();
+
+        BatchActionResult batch = BatchActionResult.from(data);
+        Assert.assertEquals(5, batch.getCompleted()[0]);
+        Assert.assertTrue(batch.isSuccess());
+        Assert.assertNull(batch.getError());
+        Assert.assertNull(batch.getRemainingItems());
+
+        CompositeData data2 = mbean.startBundles(null);
+
+        BatchActionResult batch2 = BatchActionResult.from(data2);
+        Assert.assertNull(batch2.getCompleted());
+        Assert.assertFalse(batch2.isSuccess());
+        Assert.assertNotNull(batch2.getError());
+        Assert.assertNull(batch2.getRemainingItems());
+    }
+
+    @Test
+    public void testStopBundle() throws Exception {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(5)).thenReturn(bundle);
+        mbean.stopBundle(5);
+        Mockito.verify(bundle).stop();
+        
+        Mockito.when(context.getBundle(5)).thenReturn(null);
+        try {
+            mbean.stopBundle(5);
+            Assert.fail("IOException should be thrown");
+        } catch (IOException e) {
+            //expected
+        }
+       
+    }
+
+    @Test
+    public void testStopBundles() throws Exception {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(5)).thenReturn(bundle);
+        CompositeData data = mbean.stopBundles(new long[] { 5 });
+        Mockito.verify(bundle).stop();
+
+        BatchActionResult batch = BatchActionResult.from(data);
+        Assert.assertEquals(5, batch.getCompleted()[0]);
+        Assert.assertTrue(batch.isSuccess());
+        Assert.assertNull(batch.getError());
+        Assert.assertNull(batch.getRemainingItems());
+
+        CompositeData data2 = mbean.stopBundles(null);
+
+        BatchActionResult batch2 = BatchActionResult.from(data2);
+        Assert.assertNull(batch2.getCompleted());
+        Assert.assertFalse(batch2.isSuccess());
+        Assert.assertNotNull(batch2.getError());
+        Assert.assertNull(batch2.getRemainingItems());
+    }
+
+    @Test
+    public void testUninstallBundle() throws Exception {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(5)).thenReturn(bundle);
+        mbean.uninstallBundle(5);
+        Mockito.verify(bundle).uninstall();
+    }
+
+    @Test
+    public void testUninstallBundles() throws Exception {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(5)).thenReturn(bundle);
+        CompositeData data = mbean.uninstallBundles(new long[] { 5 });
+        Mockito.verify(bundle).uninstall();
+        BatchActionResult batch = BatchActionResult.from(data);
+        Assert.assertEquals(5, batch.getCompleted()[0]);
+        Assert.assertTrue(batch.isSuccess());
+        Assert.assertNull(batch.getError());
+        Assert.assertNull(batch.getRemainingItems());
+
+        CompositeData data2 = mbean.uninstallBundles(null);
+
+        BatchActionResult batch2 = BatchActionResult.from(data2);
+        Assert.assertNull(batch2.getCompleted());
+        Assert.assertFalse(batch2.isSuccess());
+        Assert.assertNotNull(batch2.getError());
+        Assert.assertNull(batch2.getRemainingItems());
+    }
+
+    @Test
+    public void testUpdateBundle() throws Exception {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(5)).thenReturn(bundle);
+        mbean.updateBundle(5);
+        Mockito.verify(bundle).update();
+    }
+
+    @Test
+    public void testUpdateBundleFromUrl() throws Exception {
+        Framework spiedMBean = Mockito.spy(mbean);
+        InputStream stream = Mockito.mock(InputStream.class);
+        Mockito.doReturn(stream).when(spiedMBean).createStream(Mockito.anyString());
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(5)).thenReturn(bundle);
+        spiedMBean.updateBundleFromURL(5, "file:test.jar");
+        Mockito.verify(bundle).update(stream);
+    }
+
+    @Test
+    public void testUpdateBundles() throws Exception {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(5)).thenReturn(bundle);
+        CompositeData data = mbean.updateBundles(new long[] { 5 });
+        Mockito.verify(bundle).update();
+        BatchActionResult batch = BatchActionResult.from(data);
+        Assert.assertEquals(5, batch.getCompleted()[0]);
+        Assert.assertTrue(batch.isSuccess());
+        Assert.assertNull(batch.getError());
+        Assert.assertNull(batch.getRemainingItems());
+
+        CompositeData data2 = mbean.updateBundles(null);
+
+        BatchActionResult batch2 = BatchActionResult.from(data2);
+        Assert.assertNull(batch2.getCompleted());
+        Assert.assertFalse(batch2.isSuccess());
+        Assert.assertNotNull(batch2.getError());
+        Assert.assertNull(batch2.getRemainingItems());
+
+        Mockito.reset(bundle);
+        CompositeData data3 = mbean.updateBundles(new long[] { 6 });
+        Mockito.when(context.getBundle(6)).thenReturn(bundle);
+        Mockito.doThrow(new BundleException("")).when(bundle).update();
+        BatchActionResult batch3 = BatchActionResult.from(data3);
+        Assert.assertEquals(0, batch3.getCompleted().length);
+        Assert.assertFalse(batch3.isSuccess());
+        Assert.assertNotNull(batch3.getError());
+        Assert.assertEquals(6, batch3.getBundleInError());
+
+        Bundle bundle6 = Mockito.mock(Bundle.class);
+        Bundle bundle8 = Mockito.mock(Bundle.class);
+        Bundle bundle7 = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(6)).thenReturn(bundle6);
+        Mockito.when(context.getBundle(8)).thenReturn(bundle8);
+        Mockito.when(context.getBundle(7)).thenReturn(bundle7);
+        Mockito.doThrow(new BundleException("")).when(bundle8).update();
+        CompositeData data4 = mbean.updateBundles(new long[] { 6, 8, 7 });
+        BatchActionResult batch4 = BatchActionResult.from(data4);
+        Mockito.verify(bundle6).update();
+        Assert.assertEquals(1, batch4.getCompleted().length);
+        // should contain only bundleid 6
+        Assert.assertEquals(6, batch4.getCompleted()[0]);
+        Assert.assertFalse(batch4.isSuccess());
+        Assert.assertNotNull(batch4.getError());
+        Assert.assertEquals(8, batch4.getBundleInError());
+        Assert.assertEquals(1, batch4.getRemainingItems().length);
+        // should contain only bundleid 7
+        Assert.assertEquals(7, batch4.getRemainingItems()[0]);
+    }
+
+    @Test
+    public void testUpdateBundlesFromURL() throws Exception {
+        Framework spiedMBean = Mockito.spy(mbean);
+        InputStream stream = Mockito.mock(InputStream.class);
+        Mockito.doReturn(stream).when(spiedMBean).createStream(Mockito.anyString());
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(5)).thenReturn(bundle);
+        CompositeData data = spiedMBean.updateBundlesFromURL(new long[] { 5 }, new String[] { "file:test.jar" });
+        Mockito.verify(bundle).update(stream);
+        BatchActionResult batch = BatchActionResult.from(data);
+        Assert.assertEquals(5, batch.getCompleted()[0]);
+        Assert.assertTrue(batch.isSuccess());
+        Assert.assertNull(batch.getError());
+        Assert.assertNull(batch.getRemainingItems());
+
+        CompositeData data2 = spiedMBean.updateBundlesFromURL(new long[] { 2, 4 }, new String[] { "file:test.jar" });
+        BatchActionResult batch2 = BatchActionResult.from(data2);
+        Assert.assertFalse(batch2.isSuccess());
+        Assert.assertNotNull(batch2.getError());
+        Assert.assertNotNull(batch2.getError());
+        Assert.assertNull(batch2.getRemainingItems());
+    }
+
+    @Test
+    public void testUpdateFramework() throws Exception {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundle(0)).thenReturn(bundle);
+        mbean.restartFramework();
+        Mockito.verify(bundle).update();
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/PackageStateTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/PackageStateTest.java
index b56de2e8..60c4101c 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/PackageStateTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/PackageStateTest.java
@@ -1,3 +1,134 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import java.io.IOException;
+import java.util.Collection;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.TabularData;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Version;
+import org.osgi.jmx.framework.PackageStateMBean;
+import org.osgi.service.packageadmin.ExportedPackage;
+import org.osgi.service.packageadmin.PackageAdmin;
+
+/**
+ * {@link PackageStateMBean} test case.
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class PackageStateTest {
+    
+    @Mock
+    private BundleContext context;
+    @Mock
+    private PackageAdmin admin;
+    private PackageState mbean;
+    
+
+    @Before
+    public void setUp() throws Exception {
+        MockitoAnnotations.initMocks(this);
+        mbean = new PackageState(context, admin);
+    }
+
+    @Test
+    public void testGetExportingBundles() throws IOException {
+        ExportedPackage exported = Mockito.mock(ExportedPackage.class);
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Mockito.when(exported.getVersion()).thenReturn(Version.parseVersion("1.0.0"));
+        Mockito.when(exported.getExportingBundle()).thenReturn(bundle);
+        Mockito.when(bundle.getBundleId()).thenReturn(Long.valueOf(5));
+        ExportedPackage exported2 = Mockito.mock(ExportedPackage.class);
+        Bundle bundle2 = Mockito.mock(Bundle.class);
+        Mockito.when(exported2.getVersion()).thenReturn(Version.parseVersion("1.0.0"));
+        Mockito.when(exported2.getExportingBundle()).thenReturn(bundle2);
+        Mockito.when(bundle2.getBundleId()).thenReturn(Long.valueOf(6));
+        Mockito.when(admin.getExportedPackages(Mockito.anyString())).thenReturn(new ExportedPackage[]{exported, exported2});
+        long[] ids = mbean.getExportingBundles("test", "1.0.0");
+        Assert.assertNotNull(ids);
+        Assert.assertArrayEquals(new long[]{5,6}, ids);
+    }
+
+    @Test
+    public void testGetImportingBundles() throws IOException {
+        ExportedPackage exported = Mockito.mock(ExportedPackage.class);
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Bundle exportingBundle = Mockito.mock(Bundle.class);
+        Mockito.when(exported.getVersion()).thenReturn(Version.parseVersion("1.0.0"));
+        Mockito.when(exported.getExportingBundle()).thenReturn(exportingBundle);
+        Mockito.when(exportingBundle.getBundleId()).thenReturn(Long.valueOf(2));
+        Mockito.when(exported.getImportingBundles()).thenReturn(new Bundle[]{bundle});
+        Mockito.when(bundle.getBundleId()).thenReturn(Long.valueOf(4));
+        Mockito.when(admin.getExportedPackages(Mockito.anyString())).thenReturn(new ExportedPackage[]{exported});
+        long[] ids = mbean.getImportingBundles("test", "1.0.0", 2);
+        Assert.assertArrayEquals(new long[]{4}, ids);
+    }
+
+    @Test
+    public void testIsRemovalPending() throws IOException {
+        ExportedPackage exported = Mockito.mock(ExportedPackage.class);
+        Bundle expBundle = Mockito.mock(Bundle.class);
+        Mockito.when(exported.getVersion()).thenReturn(Version.parseVersion("1.0.0"));
+        Mockito.when(exported.isRemovalPending()).thenReturn(true);
+        Mockito.when(exported.getExportingBundle()).thenReturn(expBundle);
+        Mockito.when(expBundle.getBundleId()).thenReturn(Long.valueOf(2));
+        Mockito.when(admin.getExportedPackages(Mockito.anyString())).thenReturn(new ExportedPackage[]{exported});
+        boolean isRemoval = mbean.isRemovalPending("test", "1.0.0", Long.valueOf(2));
+        Assert.assertTrue(isRemoval);
+    }
+
+    @Test
+    public void testListPackages() throws IOException {
+        Bundle bundle = Mockito.mock(Bundle.class);
+        Bundle impBundle = Mockito.mock(Bundle.class);
+        Mockito.when(context.getBundles()).thenReturn(new Bundle[]{bundle});
+        ExportedPackage exported = Mockito.mock(ExportedPackage.class);
+        Mockito.when(exported.getVersion()).thenReturn(Version.parseVersion("1.0.0"));
+        Mockito.when(exported.getImportingBundles()).thenReturn(new Bundle[]{impBundle});
+        Mockito.when(exported.getName()).thenReturn("test");
+        Mockito.when(exported.getExportingBundle()).thenReturn(bundle);
+        Mockito.when(bundle.getBundleId()).thenReturn(Long.valueOf(4));
+        Mockito.when(impBundle.getBundleId()).thenReturn(Long.valueOf(5));
+        Mockito.when(admin.getExportedPackages(bundle)).thenReturn(new ExportedPackage[]{exported});
+        TabularData table = mbean.listPackages();
+        Assert.assertEquals(PackageStateMBean.PACKAGES_TYPE,table.getTabularType());
+        Collection values = table.values();
+        Assert.assertEquals(1, values.size());
+        CompositeData data = (CompositeData) values.iterator().next();
+        Long[] exportingBundles = (Long[])data.get(PackageStateMBean.EXPORTING_BUNDLES);
+        Assert.assertArrayEquals(new Long[]{Long.valueOf(4)}, exportingBundles);
+        String name = (String) data.get(PackageStateMBean.NAME);
+        Assert.assertEquals("test", name);
+        String version = (String) data.get(PackageStateMBean.VERSION);
+        Assert.assertEquals("1.0.0", version);
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/ServiceStateMBeanHandlerTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/ServiceStateMBeanHandlerTest.java
index b56de2e8..45b1b768 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/ServiceStateMBeanHandlerTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/ServiceStateMBeanHandlerTest.java
@@ -1,3 +1,50 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import static org.junit.Assert.*;
+import static org.mockito.Mockito.*;
+
+import org.apache.aries.jmx.Logger;
+import org.junit.Test;
+import org.osgi.framework.BundleContext;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class ServiceStateMBeanHandlerTest {
+
+   
+    @Test
+    public void testOpen() throws Exception {
+        
+        BundleContext context = mock(BundleContext.class);
+        Logger logger = mock(Logger.class);
+        
+        ServiceStateMBeanHandler handler = new ServiceStateMBeanHandler(context, logger);
+        handler.open();
+        
+        assertNotNull(handler.getMbean());
+        
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/ServiceStateTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/ServiceStateTest.java
index b56de2e8..5fdf3394 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/ServiceStateTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/framework/ServiceStateTest.java
@@ -1,3 +1,205 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Mockito.atMost;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.osgi.jmx.framework.ServiceStateMBean.BUNDLE_IDENTIFIER;
+import static org.osgi.jmx.framework.ServiceStateMBean.BUNDLE_LOCATION;
+import static org.osgi.jmx.framework.ServiceStateMBean.BUNDLE_SYMBOLIC_NAME;
+import static org.osgi.jmx.framework.ServiceStateMBean.EVENT;
+import static org.osgi.jmx.framework.ServiceStateMBean.IDENTIFIER;
+import static org.osgi.jmx.framework.ServiceStateMBean.OBJECTNAME;
+import static org.osgi.jmx.framework.ServiceStateMBean.OBJECT_CLASS;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.TimeUnit;
+
+import javax.management.MBeanServer;
+import javax.management.Notification;
+import javax.management.NotificationListener;
+import javax.management.ObjectName;
+import javax.management.openmbean.CompositeData;
+
+import org.apache.aries.jmx.Logger;
+import org.junit.Test;
+import org.mockito.ArgumentCaptor;
+import org.osgi.framework.AllServiceListener;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Constants;
+import org.osgi.framework.ServiceEvent;
+import org.osgi.framework.ServiceReference;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class ServiceStateTest {
+
+    
+    @Test
+    public void testNotificationsForServiceEvents() throws Exception {
+        
+        BundleContext context = mock(BundleContext.class);
+        Logger logger = mock(Logger.class);
+        
+        ServiceState serviceState = new ServiceState(context, logger);
+        
+        ServiceReference reference = mock(ServiceReference.class);
+        Bundle b1 = mock(Bundle.class);
+        
+        when(b1.getBundleId()).thenReturn(new Long(9));
+        when(b1.getSymbolicName()).thenReturn("bundle");
+        when(b1.getLocation()).thenReturn("file:/location");
+        when(reference.getBundle()).thenReturn(b1);
+        when(reference.getProperty(Constants.SERVICE_ID)).thenReturn(new Long(44));
+        when(reference.getProperty(Constants.OBJECTCLASS)).thenReturn(new String[] {"org.apache.aries.jmx.Mock"});
+        
+        ServiceEvent registeredEvent = mock(ServiceEvent.class);
+        when(registeredEvent.getServiceReference()).thenReturn(reference);
+        when(registeredEvent.getType()).thenReturn(ServiceEvent.REGISTERED);
+       
+        ServiceEvent modifiedEvent = mock(ServiceEvent.class);
+        when(modifiedEvent.getServiceReference()).thenReturn(reference);
+        when(modifiedEvent.getType()).thenReturn(ServiceEvent.MODIFIED);
+        
+        MBeanServer server = mock(MBeanServer.class);
+        
+        //setup for notification
+        ObjectName objectName = new ObjectName(OBJECTNAME);
+        serviceState.preRegister(server, objectName);
+        serviceState.postRegister(true);
+        
+        //holder for Notifications captured
+        final List<Notification> received = new LinkedList<Notification>();
+        
+        //add NotificationListener to receive the events
+        serviceState.addNotificationListener(new NotificationListener() {
+            public void handleNotification(Notification notification, Object handback) {
+               received.add(notification);
+            }
+        }, null, null);
+        
+        // capture the ServiceListener registered with BundleContext to issue ServiceEvents
+        ArgumentCaptor<AllServiceListener> argument = ArgumentCaptor.forClass(AllServiceListener.class);        
+        verify(context).addServiceListener(argument.capture());
+        
+        //send events
+        AllServiceListener serviceListener = argument.getValue();
+        serviceListener.serviceChanged(registeredEvent);
+        serviceListener.serviceChanged(modifiedEvent);
+        
+        //shutdown dispatcher via unregister callback 
+        serviceState.postDeregister();
+        //check the ServiceListener is cleaned up
+        verify(context).removeServiceListener(serviceListener);
+        
+        ExecutorService dispatcher = serviceState.getEventDispatcher();
+        assertTrue(dispatcher.isShutdown());
+        dispatcher.awaitTermination(2, TimeUnit.SECONDS);
+        assertTrue(dispatcher.isTerminated());
+        
+        assertEquals(2, received.size());
+        Notification registered = received.get(0);
+        assertEquals(1, registered.getSequenceNumber());
+        CompositeData data = (CompositeData) registered.getUserData();
+        assertEquals(new Long(44), data.get(IDENTIFIER));
+        assertEquals(new Long(9), data.get(BUNDLE_IDENTIFIER));
+        assertEquals("file:/location", data.get(BUNDLE_LOCATION));
+        assertEquals("bundle", data.get(BUNDLE_SYMBOLIC_NAME));
+        assertArrayEquals(new String[] {"org.apache.aries.jmx.Mock" }, (String[]) data.get(OBJECT_CLASS));
+        assertEquals(ServiceEvent.REGISTERED, data.get(EVENT));
+        
+        Notification modified = received.get(1);
+        assertEquals(2, modified.getSequenceNumber());
+        data = (CompositeData) modified.getUserData();
+        assertEquals(new Long(44), data.get(IDENTIFIER));
+        assertEquals(new Long(9), data.get(BUNDLE_IDENTIFIER));
+        assertEquals("file:/location", data.get(BUNDLE_LOCATION));
+        assertEquals("bundle", data.get(BUNDLE_SYMBOLIC_NAME));
+        assertArrayEquals(new String[] {"org.apache.aries.jmx.Mock" }, (String[]) data.get(OBJECT_CLASS));
+        assertEquals(ServiceEvent.MODIFIED, data.get(EVENT));
+        
+    }
+    
+    @Test
+    public void testLifeCycleOfNotificationSupport() throws Exception {
+        
+        BundleContext context = mock(BundleContext.class);
+        Logger logger = mock(Logger.class);
+        
+        ServiceState serviceState = new ServiceState(context, logger);
+        
+        MBeanServer server1 = mock(MBeanServer.class);
+        MBeanServer server2 = mock(MBeanServer.class);
+
+        ObjectName objectName = new ObjectName(OBJECTNAME);
+        serviceState.preRegister(server1, objectName);
+        serviceState.postRegister(true);
+        
+        // capture the ServiceListener registered with BundleContext to issue ServiceEvents
+        ArgumentCaptor<AllServiceListener> argument = ArgumentCaptor.forClass(AllServiceListener.class);        
+        verify(context).addServiceListener(argument.capture());
+        
+        AllServiceListener serviceListener = argument.getValue();
+        assertNotNull(serviceListener);
+        
+        ExecutorService dispatcher = serviceState.getEventDispatcher();
+        
+        //do registration with another server
+        serviceState.preRegister(server2, objectName);
+        serviceState.postRegister(true);
+        
+        // check no more actions on BundleContext
+        argument = ArgumentCaptor.forClass(AllServiceListener.class);              
+        verify(context, atMost(1)).addServiceListener(argument.capture());
+        assertEquals(1, argument.getAllValues().size());
+        
+        //do one unregister
+        serviceState.postDeregister();
+        
+        //verify bundleListener not invoked
+        verify(context, never()).removeServiceListener(serviceListener);
+        assertFalse(dispatcher.isShutdown());
+        
+        //do second unregister and check cleanup
+        serviceState.postDeregister();
+        verify(context).removeServiceListener(serviceListener);
+        assertTrue(dispatcher.isShutdown());
+        dispatcher.awaitTermination(2, TimeUnit.SECONDS);
+        assertTrue(dispatcher.isTerminated());
+        
+      
+        
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/permissionadmin/PermissionAdminTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/permissionadmin/PermissionAdminTest.java
index 56d8ebfd..81dfca0a 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/permissionadmin/PermissionAdminTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/permissionadmin/PermissionAdminTest.java
@@ -1,2 +1,128 @@
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.permissionadmin;
+
+import java.io.IOException;
+
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import org.osgi.jmx.service.permissionadmin.PermissionAdminMBean;
+import org.osgi.service.permissionadmin.PermissionInfo;
+
+/**
+ * {@link PermissionAdminMBean} test case.
+ * 
+ * 
+ * @version $Rev$ $Date$
+ */
+public class PermissionAdminTest {
+
+    @Mock
+    private org.osgi.service.permissionadmin.PermissionAdmin permAdmin;
+    private PermissionAdminMBean mbean;
+
+    @Before
+    public void setUp() {
+        MockitoAnnotations.initMocks(this);
+        mbean = new PermissionAdmin(permAdmin);
+    }
+
+    @Test
+    public void testGetPermissions() throws IOException {
+        PermissionInfo info = new PermissionInfo("Admin", "test", "get");
+        PermissionInfo[] permInfos = new PermissionInfo[] { info, info };
+
+        Mockito.when(permAdmin.getPermissions(Mockito.anyString())).thenReturn(permInfos);
+        String[] permissions = mbean.getPermissions("test");
+
+        Assert.assertNotNull(permissions);
+        Assert.assertEquals(2, permissions.length);
+        Assert.assertArrayEquals("Checks encoded permissions", new String[] { info.getEncoded(), info.getEncoded() },
+                permissions);
+        
+        Mockito.reset(permAdmin);
+        Mockito.when(permAdmin.getPermissions(Mockito.anyString())).thenReturn(null);
+        String[] permissions2 = mbean.getPermissions("test");
+
+        Assert.assertNull(permissions2);
+    }
+
+    @Test
+    public void testListDefaultPermissions() throws IOException {
+        PermissionInfo info = new PermissionInfo("Admin", "test", "get");
+        PermissionInfo[] permInfos = new PermissionInfo[] { info, info };
+
+        Mockito.when(permAdmin.getDefaultPermissions()).thenReturn(permInfos);
+        String[] permissions = mbean.listDefaultPermissions();
+
+        Assert.assertNotNull(permissions);
+        Assert.assertEquals(2, permissions.length);
+        Assert.assertArrayEquals("Checks encoded default permissions", new String[] { info.getEncoded(), info.getEncoded() },
+                permissions);
+        
+        Mockito.reset(permAdmin);
+        Mockito.when(permAdmin.getDefaultPermissions()).thenReturn(null);
+        String[] permissions2 = mbean.listDefaultPermissions();
+
+        Assert.assertNull(permissions2);
+    }
+
+    @Test
+    public void testListLocations() throws IOException {
+        String[] locations1 = new String[] { "test1", "test2" };
+        Mockito.when(permAdmin.getLocations()).thenReturn(locations1);
+        String[] locations2 = mbean.listLocations();
+        Assert.assertNotNull(locations2);
+        Assert.assertEquals(2, locations2.length);
+        Assert.assertSame(locations1, locations2);
+    }
+
+    @Test
+    public void testSetDefaultPermissions() throws IOException {
+        PermissionInfo info1 = new PermissionInfo("Admin", "test", "get");
+        PermissionInfo info2 = new PermissionInfo("Admin", "test2", "get");
+        PermissionInfo[] permInfos = new PermissionInfo[] { info1, info2 };
+        String[] encodedPermissions = new String[2];
+        int i = 0;
+        for (PermissionInfo info : permInfos) {
+            encodedPermissions[i++] = info.getEncoded();
+        }
+        mbean.setDefaultPermissions(encodedPermissions);
+        Mockito.verify(permAdmin).setDefaultPermissions(permInfos);
+    }
+
+    @Test
+    public void testSetPermissions() throws IOException {
+        PermissionInfo info1 = new PermissionInfo("Admin", "test", "set");
+        PermissionInfo info2 = new PermissionInfo("Admin", "test2", "set");
+        PermissionInfo[] permInfos = new PermissionInfo[] { info1, info2 };
+        String[] encodedPermissions = new String[2];
+        int i = 0;
+        for (PermissionInfo info : permInfos) {
+            encodedPermissions[i++] = info.getEncoded();
+        }
+        mbean.setPermissions("test", encodedPermissions);
+        Mockito.verify(permAdmin).setPermissions("test", permInfos);
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanHandlerTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanHandlerTest.java
index 56d8ebfd..a6e462ad 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanHandlerTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanHandlerTest.java
@@ -1,2 +1,55 @@
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.provisioning;
+
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Mockito.mock;
+
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.agent.JMXAgentContext;
+import org.junit.Test;
+import org.osgi.framework.BundleContext;
+import org.osgi.service.provisioning.ProvisioningService;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class ProvisioningServiceMBeanHandlerTest {
+
+    
+    @Test
+    public void testConstructInjectMBean() {
+        
+        BundleContext bundleContext = mock(BundleContext.class);
+        Logger agentLogger = mock(Logger.class);   
+        JMXAgentContext agentContext = new JMXAgentContext(bundleContext, null, agentLogger);
+        ProvisioningService provService = mock(ProvisioningService.class);
+        
+        ProvisioningServiceMBeanHandler handler = new ProvisioningServiceMBeanHandler(agentContext);
+        StandardMBean mbean = handler.constructInjectMBean(provService);
+        assertNotNull(mbean);
+        
+    }
+
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceTest.java
index b56de2e8..2b6089f4 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceTest.java
@@ -1,3 +1,158 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.provisioning;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.doReturn;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+import static org.osgi.jmx.JmxConstants.PROPERTIES_TYPE;
+import static org.osgi.service.provisioning.ProvisioningService.PROVISIONING_AGENT_CONFIG;
+import static org.osgi.service.provisioning.ProvisioningService.PROVISIONING_REFERENCE;
+import static org.osgi.service.provisioning.ProvisioningService.PROVISIONING_RSH_SECRET;
+import static org.osgi.service.provisioning.ProvisioningService.PROVISIONING_SPID;
+import static org.osgi.service.provisioning.ProvisioningService.PROVISIONING_UPDATE_COUNT;
+
+import java.io.InputStream;
+import java.util.Dictionary;
+import java.util.Hashtable;
+import java.util.zip.ZipInputStream;
+
+import javax.management.openmbean.TabularData;
+import javax.management.openmbean.TabularDataSupport;
+
+import org.apache.aries.jmx.codec.PropertyData;
+import org.junit.Test;
+import org.mockito.ArgumentCaptor;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class ProvisioningServiceTest {
+
+   
+    @Test
+    public void testAddInformationFromZip() throws Exception {
+
+        org.osgi.service.provisioning.ProvisioningService provService = mock(org.osgi.service.provisioning.ProvisioningService.class);
+        ProvisioningService mbean = new ProvisioningService(provService);
+        ProvisioningService spiedMBean = spy(mbean);
+        
+        InputStream is = mock(InputStream.class);
+        doReturn(is).when(spiedMBean).createStream("file://prov.zip");
+        
+        spiedMBean.addInformationFromZip("file://prov.zip");
+        verify(provService).addInformation(any(ZipInputStream.class));
+        verify(is).close();
+        
+    }
+
+    
+    @Test
+    @SuppressWarnings("unchecked")
+    public void testAddInformationWithTabularData() throws Exception {
+        
+        org.osgi.service.provisioning.ProvisioningService provService = mock(org.osgi.service.provisioning.ProvisioningService.class);
+        ProvisioningService mbean = new ProvisioningService(provService);
+        
+        TabularData data = new TabularDataSupport(PROPERTIES_TYPE);
+        PropertyData<byte[]> p1 = PropertyData.newInstance(PROVISIONING_AGENT_CONFIG, new byte[] { 20, 30, 40 });
+        data.put(p1.toCompositeData());
+        PropertyData<String> p2 = PropertyData.newInstance(PROVISIONING_SPID, "x.test");
+        data.put(p2.toCompositeData());
+        
+        mbean.addInformation(data);
+        ArgumentCaptor<Dictionary> dictionaryArgument = ArgumentCaptor.forClass(Dictionary.class);
+        verify(provService).addInformation(dictionaryArgument.capture());
+        
+        Dictionary<String, Object> info = dictionaryArgument.getValue();
+        assertEquals(2, info.size() );
+        assertArrayEquals(new byte[] { 20, 30, 40 }, (byte[]) info.get(PROVISIONING_AGENT_CONFIG));
+        assertEquals("x.test", info.get(PROVISIONING_SPID));
+        
+    }
+
+    
+    @Test
+    public void testListInformation() throws Exception {
+
+        org.osgi.service.provisioning.ProvisioningService provService = mock(org.osgi.service.provisioning.ProvisioningService.class);
+        ProvisioningService mbean = new ProvisioningService(provService);
+        
+        Dictionary<String, Object> info = new Hashtable<String, Object>();
+        info.put(PROVISIONING_AGENT_CONFIG, new byte[] { 20, 30, 40 });
+        info.put(PROVISIONING_SPID, "x.test");
+        info.put(PROVISIONING_REFERENCE, "rsh://0.0.0.0/provX");
+        info.put(PROVISIONING_RSH_SECRET, new byte[] { 15, 25, 35 });
+        info.put(PROVISIONING_UPDATE_COUNT, 1);
+        
+        when(provService.getInformation()).thenReturn(info);
+        
+        TabularData provData = mbean.listInformation();
+        assertNotNull(provData);
+        assertEquals(PROPERTIES_TYPE, provData.getTabularType());
+        assertEquals(5, provData.values().size());
+        PropertyData<byte[]> agentConfig = PropertyData.from(provData.get(new Object[]{ PROVISIONING_AGENT_CONFIG }));
+        assertArrayEquals(new byte[] { 20, 30, 40 }, agentConfig.getValue());
+        PropertyData<String> spid = PropertyData.from(provData.get(new Object[] { PROVISIONING_SPID }));
+        assertEquals("x.test", spid.getValue());
+        PropertyData<String> ref = PropertyData.from(provData.get(new Object[] { PROVISIONING_REFERENCE }));
+        assertEquals("rsh://0.0.0.0/provX", ref.getValue());
+        PropertyData<byte[]> sec = PropertyData.from(provData.get(new Object[] { PROVISIONING_RSH_SECRET }));
+        assertArrayEquals(new byte[] { 15, 25, 35 }, sec.getValue());
+        PropertyData<Integer> count = PropertyData.from(provData.get(new Object[] { PROVISIONING_UPDATE_COUNT }));
+        assertEquals(new Integer(1), count.getValue());
+        
+    }
+
+   
+    @Test
+    @SuppressWarnings("unchecked")
+    public void testSetInformation() throws Exception {
+      
+        org.osgi.service.provisioning.ProvisioningService provService = mock(org.osgi.service.provisioning.ProvisioningService.class);
+        ProvisioningService mbean = new ProvisioningService(provService);
+        
+        TabularData data = new TabularDataSupport(PROPERTIES_TYPE);
+        PropertyData<String> p1 = PropertyData.newInstance(PROVISIONING_REFERENCE, "rsh://0.0.0.0/provX");
+        data.put(p1.toCompositeData());
+        PropertyData<String> p2 = PropertyData.newInstance(PROVISIONING_SPID, "x.test");
+        data.put(p2.toCompositeData());
+        
+        mbean.setInformation(data);
+        
+        ArgumentCaptor<Dictionary> dictionaryArgument = ArgumentCaptor.forClass(Dictionary.class);
+        verify(provService).setInformation(dictionaryArgument.capture());
+        
+        Dictionary<String, Object> info = dictionaryArgument.getValue();
+        assertEquals(2, info.size() );
+        assertEquals("rsh://0.0.0.0/provX", info.get(PROVISIONING_REFERENCE));
+        assertEquals("x.test", info.get(PROVISIONING_SPID));
+        
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/useradmin/UserAdminTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/useradmin/UserAdminTest.java
index a12fd0ee..a4d59d2e 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/useradmin/UserAdminTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/useradmin/UserAdminTest.java
@@ -1,2 +1,598 @@
   + native
   + Revision Date
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.useradmin;
+
+import java.io.IOException;
+import java.util.Dictionary;
+import java.util.Hashtable;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.TabularData;
+
+import org.apache.aries.jmx.codec.AuthorizationData;
+import org.apache.aries.jmx.codec.GroupData;
+import org.apache.aries.jmx.codec.RoleData;
+import org.apache.aries.jmx.codec.UserData;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+import org.osgi.jmx.JmxConstants;
+import org.osgi.service.useradmin.Authorization;
+import org.osgi.service.useradmin.Group;
+import org.osgi.service.useradmin.Role;
+import org.osgi.service.useradmin.User;
+
+/**
+ * UserAdminMBean test case.
+ * 
+ * @version $Rev$ $Date$
+ */
+public class UserAdminTest {
+
+    @Mock
+    private org.osgi.service.useradmin.UserAdmin userAdmin;
+    private UserAdmin mbean;
+
+    /**
+     * @throws java.lang.Exception
+     */
+    @Before
+    public void setUp() throws Exception {
+        MockitoAnnotations.initMocks(this);
+        mbean = new UserAdmin(userAdmin);
+    }
+
+    /**
+     * Test method for
+     * {@link org.apache.aries.jmx.useradmin.UserAdmin#addCredential(java.lang.String, byte[], java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testAddCredential() throws IOException {
+        User user1 = Mockito.mock(User.class);
+        Dictionary<String, Object> credentials = new Hashtable<String, Object>();
+        Mockito.when(userAdmin.getRole("user1")).thenReturn(user1);
+        Mockito.when(user1.getType()).thenReturn(Role.USER);
+        Mockito.when(user1.getCredentials()).thenReturn(credentials);
+        mbean.addCredential("password", new byte[] { 1, 2 }, "user1");
+        Assert.assertArrayEquals(new byte[] { 1, 2 }, (byte[]) credentials.get("password"));
+
+    }
+
+    /**
+     * Test method for
+     * {@link org.apache.aries.jmx.useradmin.UserAdmin#addCredentialString(String, String, String)}
+     * .
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testAddCredentialString() throws IOException {
+        User user1 = Mockito.mock(User.class);
+        Dictionary<String, Object> credentials = new Hashtable<String, Object>();
+        Mockito.when(userAdmin.getRole("user1")).thenReturn(user1);
+        Mockito.when(user1.getType()).thenReturn(Role.USER);
+        Mockito.when(user1.getCredentials()).thenReturn(credentials);
+        mbean.addCredentialString("password", "1234", "user1");
+        Assert.assertEquals("1234", (String) credentials.get("password"));
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#addMember(java.lang.String, java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testAddMember() throws IOException {
+        Group group1 = Mockito.mock(Group.class);
+        User user1 = Mockito.mock(User.class);
+        Mockito.when(userAdmin.getRole("group1")).thenReturn(group1);
+        Mockito.when(userAdmin.getRole("user1")).thenReturn(user1);
+        Mockito.when(group1.getType()).thenReturn(Role.GROUP);
+        Mockito.when(group1.addMember(user1)).thenReturn(true);
+        boolean isAdded = mbean.addMember("group1", "user1");
+        Assert.assertTrue(isAdded);
+        Mockito.verify(group1).addMember(user1);
+    }
+
+    /**
+     * Test method for
+     * {@link org.apache.aries.jmx.useradmin.UserAdmin#addPropertyString(String, String, String)}
+     * .
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testAddPropertyString() throws IOException {
+        User user1 = Mockito.mock(User.class);
+        Dictionary<String, Object> props = new Hashtable<String, Object>();
+        Mockito.when(userAdmin.getRole("user1")).thenReturn(user1);
+        Mockito.when(user1.getType()).thenReturn(Role.USER);
+        Mockito.when(user1.getProperties()).thenReturn(props);
+        mbean.addPropertyString("key", "1234", "user1");
+        Assert.assertEquals("1234", (String) props.get("key"));
+    }
+
+    /**
+     * Test method for
+     * {@link org.apache.aries.jmx.useradmin.UserAdmin#addProperty(java.lang.String, byte[], java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testAddProperty() throws IOException {
+        User user1 = Mockito.mock(User.class);
+        Dictionary<String, Object> props = new Hashtable<String, Object>();
+        Mockito.when(userAdmin.getRole("user1")).thenReturn(user1);
+        Mockito.when(user1.getType()).thenReturn(Role.USER);
+        Mockito.when(user1.getProperties()).thenReturn(props);
+        mbean.addProperty("key", new byte[] { 1, 2 }, "user1");
+        Assert.assertArrayEquals(new byte[] { 1, 2 }, (byte[]) props.get("key"));
+    }
+
+    /**
+     * Test method for
+     * {@link org.apache.aries.jmx.useradmin.UserAdmin#addRequiredMember(java.lang.String, java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testAddRequiredMember() throws IOException {
+        Group group1 = Mockito.mock(Group.class);
+        User user1 = Mockito.mock(User.class);
+        Mockito.when(userAdmin.getRole("group1")).thenReturn(group1);
+        Mockito.when(userAdmin.getRole("user1")).thenReturn(user1);
+        Mockito.when(group1.getType()).thenReturn(Role.GROUP);
+        Mockito.when(group1.addRequiredMember(user1)).thenReturn(true);
+        boolean isAdded = mbean.addRequiredMember("group1", "user1");
+        Assert.assertTrue(isAdded);
+        Mockito.verify(group1).addRequiredMember(user1);
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#createGroup(java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testCreateGroup() throws IOException {
+        mbean.createGroup("group1");
+        Mockito.verify(userAdmin).createRole("group1", Role.GROUP);
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#createRole(java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testCreateRole() throws IOException {
+        try {
+            mbean.createRole("role1");
+            Assert.fail("Function did not throw exception as expected");
+        } catch (IOException e) {
+            // expected
+        }
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#createUser(java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testCreateUser() throws IOException {
+        mbean.createUser("user1");
+        Mockito.verify(userAdmin).createRole("user1", Role.USER);
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#getAuthorization(java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testGetAuthorization() throws IOException {
+        Authorization auth = Mockito.mock(Authorization.class);
+        User user = Mockito.mock(User.class);
+        Mockito.when(user.getType()).thenReturn(Role.USER);
+        Mockito.when(userAdmin.getAuthorization(user)).thenReturn(auth);
+        Mockito.when(userAdmin.getRole("role1")).thenReturn(user);
+        Mockito.when(auth.getName()).thenReturn("auth1");
+        Mockito.when(auth.getRoles()).thenReturn(new String[]{"role1"});
+        CompositeData data = mbean.getAuthorization("role1");
+        Assert.assertNotNull(data);
+        AuthorizationData authData = AuthorizationData.from(data);
+        Assert.assertNotNull(authData);
+        Assert.assertEquals("auth1", authData.getName());
+        Assert.assertArrayEquals(new String[] { "role1" }, authData.getRoles());
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#getCredentials(java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testGetCredentials() throws IOException {
+        User user1 = Mockito.mock(User.class);
+        Dictionary<String, Object> properties = new Hashtable<String, Object>();
+        properties.put("key", "value");
+        Mockito.when(user1.getCredentials()).thenReturn(properties);
+        Mockito.when(user1.getType()).thenReturn(Role.USER);
+        Mockito.when(userAdmin.getRole(Mockito.anyString())).thenReturn(user1);
+        TabularData data = mbean.getCredentials("user1");
+        Assert.assertNotNull(data);
+        Assert.assertEquals(JmxConstants.PROPERTIES_TYPE, data.getTabularType());
+        CompositeData composite = data.get(new Object[] { "key" });
+        Assert.assertNotNull(composite);
+        Assert.assertEquals("key", (String) composite.get(JmxConstants.KEY));
+        Assert.assertEquals("value", (String) composite.get(JmxConstants.VALUE));
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#getGroup(java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testGetGroup() throws IOException {
+        Group group1 = Mockito.mock(Group.class);
+        Mockito.when(group1.getType()).thenReturn(Role.GROUP);
+        Mockito.when(group1.getName()).thenReturn("group1");
+        Role role1 = Mockito.mock(Role.class);
+        Mockito.when(role1.getName()).thenReturn("role1");
+        Role role2 = Mockito.mock(Role.class);
+        Mockito.when(role2.getName()).thenReturn("role2");
+        Mockito.when(group1.getRequiredMembers()).thenReturn(new Role[] { role1 });
+        Mockito.when(group1.getMembers()).thenReturn(new Role[] { role2 });
+        Mockito.when(userAdmin.getRole(Mockito.anyString())).thenReturn(group1);
+        CompositeData data = mbean.getGroup("group1");
+        Assert.assertNotNull(data);
+        GroupData group = GroupData.from(data);
+        Assert.assertNotNull(group);
+        Assert.assertEquals("group1", group.getName());
+        Assert.assertEquals(Role.GROUP, group.getType());
+        Assert.assertArrayEquals(new String[] { "role2" }, group.getMembers());
+        Assert.assertArrayEquals(new String[] { "role1" }, group.getRequiredMembers());
+        Mockito.verify(userAdmin).getRole(Mockito.anyString());
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#getGroups(java.lang.String)}.
+     * 
+     * @throws Exception
+     */
+    @Test
+    public void testGetGroups() throws Exception {
+        Group group1 = Mockito.mock(Group.class);
+        Mockito.when(group1.getType()).thenReturn(Role.GROUP);
+        Mockito.when(group1.getName()).thenReturn("group1");
+        Mockito.when(userAdmin.getRoles("name=group1")).thenReturn(new Role[] { group1 });
+        String[] groups = mbean.getGroups("name=group1");
+        Assert.assertArrayEquals(new String[] { "group1" }, groups);
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#getImpliedRoles(java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testGetImpliedRoles() throws IOException {
+        User user1 = Mockito.mock(User.class);
+        Authorization auth = Mockito.mock(Authorization.class);
+        Mockito.when(user1.getType()).thenReturn(Role.USER);
+        Mockito.when(auth.getRoles()).thenReturn(new String[] { "role1" });
+        Mockito.when(userAdmin.getRole("role1")).thenReturn(user1);
+        Mockito.when(userAdmin.getAuthorization(user1)).thenReturn(auth);
+        String[] roles = mbean.getImpliedRoles("role1");
+        Assert.assertArrayEquals(new String[] { "role1" }, roles);
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#getMembers(java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testGetMembers() throws IOException {
+        Group group1 = Mockito.mock(Group.class);
+        Mockito.when(group1.getType()).thenReturn(Role.GROUP);
+        Mockito.when(group1.getName()).thenReturn("group1");
+        User user1 = Mockito.mock(Group.class);
+        Mockito.when(user1.getName()).thenReturn("user1");
+        Mockito.when(group1.getMembers()).thenReturn(new Role[] { user1 });
+        Mockito.when(userAdmin.getRole("group1")).thenReturn(group1);
+        String[] members = mbean.getMembers("group1");
+        Assert.assertArrayEquals(new String[] { "user1" }, members);
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#getProperties(java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testGetProperties() throws IOException {
+        User user1 = Mockito.mock(User.class);
+        Dictionary<String, Object> properties = new Hashtable<String, Object>();
+        properties.put("key", "value");
+        Mockito.when(user1.getProperties()).thenReturn(properties);
+        Mockito.when(userAdmin.getRole(Mockito.anyString())).thenReturn(user1);
+        TabularData data = mbean.getProperties("user1");
+        Assert.assertNotNull(data);
+        Assert.assertEquals(JmxConstants.PROPERTIES_TYPE, data.getTabularType());
+        CompositeData composite = data.get(new Object[] { "key" });
+        Assert.assertNotNull(composite);
+        Assert.assertEquals("key", (String) composite.get(JmxConstants.KEY));
+        Assert.assertEquals("value", (String) composite.get(JmxConstants.VALUE));
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#getRequiredMembers(java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testGetRequiredMembers() throws IOException {
+        Group group1 = Mockito.mock(Group.class);
+        Mockito.when(group1.getType()).thenReturn(Role.GROUP);
+        Mockito.when(group1.getName()).thenReturn("group1");
+        User user1 = Mockito.mock(Group.class);
+        Mockito.when(user1.getName()).thenReturn("user1");
+        Mockito.when(group1.getRequiredMembers()).thenReturn(new Role[] { user1 });
+        Mockito.when(userAdmin.getRole("group1")).thenReturn(group1);
+        String[] members = mbean.getRequiredMembers("group1");
+        Assert.assertArrayEquals(new String[] { "user1" }, members);
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#getRole(java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testGetRole() throws IOException {
+        User user1 = Mockito.mock(User.class);
+        Mockito.when(user1.getType()).thenReturn(Role.USER);
+        Mockito.when(user1.getName()).thenReturn("user1");
+        Mockito.when(userAdmin.getRole(Mockito.anyString())).thenReturn(user1);
+        CompositeData data = mbean.getRole("user1");
+        Assert.assertNotNull(data);
+        RoleData role = RoleData.from(data);
+        Assert.assertNotNull(role);
+        Assert.assertEquals("user1", role.getName());
+        Assert.assertEquals(Role.USER, role.getType());
+        Mockito.verify(userAdmin).getRole(Mockito.anyString());
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#getRoles(java.lang.String)}.
+     * 
+     * @throws Exception
+     */
+    @Test
+    public void testGetRoles() throws Exception {
+        User user1 = Mockito.mock(User.class);
+        Mockito.when(user1.getType()).thenReturn(Role.USER);
+        Mockito.when(user1.getName()).thenReturn("user1");
+        Mockito.when(userAdmin.getRoles("name=user1")).thenReturn(new Role[] { user1 });
+        String[] roles = mbean.getRoles("name=user1");
+        Assert.assertArrayEquals(new String[] { "user1" }, roles);
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#getUser(java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testGetUser() throws IOException {
+        User user1 = Mockito.mock(User.class);
+        Mockito.when(user1.getType()).thenReturn(Role.USER);
+        Mockito.when(user1.getName()).thenReturn("user1");
+        Mockito.when(userAdmin.getRole(Mockito.anyString())).thenReturn(user1);
+        CompositeData data = mbean.getUser("user1");
+        Assert.assertNotNull(data);
+        UserData user = UserData.from(data);
+        Assert.assertNotNull(user);
+        Assert.assertEquals("user1", user.getName());
+        Assert.assertEquals(Role.USER, user.getType());
+        Mockito.verify(userAdmin).getRole(Mockito.anyString());
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#getUserWithProperty(String, String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testGetUserString() throws IOException {
+        User user1 = Mockito.mock(User.class);
+        Mockito.when(user1.getType()).thenReturn(Role.USER);
+        Mockito.when(user1.getName()).thenReturn("user1");
+        Mockito.when(userAdmin.getUser("key", "valuetest")).thenReturn(user1);
+        String username = mbean.getUserWithProperty("key", "valuetest");
+        Assert.assertEquals(username, "user1");
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#getUsers(java.lang.String)}.
+     * 
+     * @throws Exception
+     */
+    @Test
+    public void testGetUsers() throws Exception {
+        User user1 = Mockito.mock(User.class);
+        Mockito.when(user1.getType()).thenReturn(Role.USER);
+        Mockito.when(user1.getName()).thenReturn("user1");
+        Mockito.when(userAdmin.getRoles("name=user1")).thenReturn(new Role[] { user1 });
+        String[] roles = mbean.getUsers("name=user1");
+        Assert.assertArrayEquals(new String[] { "user1" }, roles);
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#listGroups()}.
+     * 
+     * @throws Exception
+     */
+    @Test
+    public void testListGroups() throws Exception {
+        Group group1 = Mockito.mock(Group.class);
+        Mockito.when(group1.getType()).thenReturn(Role.GROUP);
+        Mockito.when(group1.getName()).thenReturn("group1");
+        Group group2 = Mockito.mock(Group.class);
+        Mockito.when(group2.getType()).thenReturn(Role.GROUP);
+        Mockito.when(group2.getName()).thenReturn("group2");
+        Mockito.when(userAdmin.getRoles(null)).thenReturn(new Role[] { group1, group2 });
+        String[] groups = mbean.listGroups();
+        Assert.assertArrayEquals(new String[] { "group1", "group2" }, groups);
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#listRoles()}.
+     * 
+     * @throws Exception
+     */
+    @Test
+    public void testListRoles() throws Exception {
+        User user1 = Mockito.mock(User.class);
+        Mockito.when(user1.getType()).thenReturn(Role.USER);
+        Mockito.when(user1.getName()).thenReturn("user1");
+        User user2 = Mockito.mock(User.class);
+        Mockito.when(user2.getType()).thenReturn(Role.USER);
+        Mockito.when(user2.getName()).thenReturn("user2");
+        Mockito.when(userAdmin.getRoles(null)).thenReturn(new Role[] { user1, user2 });
+        String[] roles = mbean.listRoles();
+        Assert.assertArrayEquals(new String[] { "user1", "user2" }, roles);
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#listUsers()}.
+     * 
+     * @throws Exception
+     */
+    @Test
+    public void testListUsers() throws Exception {
+        User user1 = Mockito.mock(User.class);
+        Mockito.when(user1.getType()).thenReturn(Role.USER);
+        Mockito.when(user1.getName()).thenReturn("user1");
+        User user2 = Mockito.mock(User.class);
+        Mockito.when(user2.getType()).thenReturn(Role.USER);
+        Mockito.when(user2.getName()).thenReturn("user2");
+        Mockito.when(userAdmin.getRoles(null)).thenReturn(new Role[] { user1, user2 });
+        String[] roles = mbean.listUsers();
+        Assert.assertArrayEquals(new String[] { "user1", "user2" }, roles);
+    }
+
+    /**
+     * Test method for
+     * {@link org.apache.aries.jmx.useradmin.UserAdmin#removeCredential(java.lang.String, java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testRemoveCredential() throws IOException {
+        User user1 = Mockito.mock(User.class);
+        Dictionary<String, Object> cred = new Hashtable<String, Object>();
+        Mockito.when(userAdmin.getRole("user1")).thenReturn(user1);
+        Mockito.when(user1.getType()).thenReturn(Role.USER);
+        Mockito.when(user1.getCredentials()).thenReturn(cred);
+        mbean.removeCredential("key", "user1");
+        Assert.assertEquals(0, cred.size());
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#removeGroup(java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testRemoveGroup() throws IOException {
+        Mockito.when(userAdmin.removeRole("group1")).thenReturn(true);
+        boolean isRemoved = mbean.removeGroup("group1");
+        Assert.assertTrue(isRemoved);
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#removeMember(java.lang.String, java.lang.String)}
+     * .
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testRemoveMember() throws IOException {
+        Group group1 = Mockito.mock(Group.class);
+        User user1 = Mockito.mock(User.class);
+        Mockito.when(userAdmin.getRole("group1")).thenReturn(group1);
+        Mockito.when(userAdmin.getRole("user1")).thenReturn(user1);
+        Mockito.when(group1.getType()).thenReturn(Role.GROUP);
+        Mockito.when(group1.removeMember(user1)).thenReturn(true);
+        boolean isAdded = mbean.removeMember("group1", "user1");
+        Assert.assertTrue(isAdded);
+        Mockito.verify(group1).removeMember(user1);
+    }
+
+    /**
+     * Test method for
+     * {@link org.apache.aries.jmx.useradmin.UserAdmin#removeProperty(java.lang.String, java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testRemoveProperty() throws IOException {
+        User user1 = Mockito.mock(User.class);
+        Dictionary<String, Object> props = new Hashtable<String, Object>();
+        Mockito.when(userAdmin.getRole("user1")).thenReturn(user1);
+        Mockito.when(user1.getType()).thenReturn(Role.USER);
+        Mockito.when(user1.getProperties()).thenReturn(props);
+        mbean.removeProperty("key", "user1");
+        Assert.assertEquals(0, props.size());
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#removeRole(java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testRemoveRole() throws IOException {
+        Mockito.when(userAdmin.removeRole("role1")).thenReturn(true);
+        boolean isRemoved = mbean.removeRole("role1");
+        Assert.assertTrue(isRemoved);
+    }
+
+    /**
+     * Test method for {@link org.apache.aries.jmx.useradmin.UserAdmin#removeUser(java.lang.String)}.
+     * 
+     * @throws IOException
+     */
+    @Test
+    public void testRemoveUser() throws IOException {
+        Mockito.when(userAdmin.removeRole("user1")).thenReturn(true);
+        boolean isRemoved = mbean.removeUser("user1");
+        Assert.assertTrue(isRemoved);
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/util/FrameworkUtilsTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/util/FrameworkUtilsTest.java
index b56de2e8..19348c46 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/util/FrameworkUtilsTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/util/FrameworkUtilsTest.java
@@ -1,3 +1,297 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.util;
+
+import static org.apache.aries.jmx.util.FrameworkUtils.getBundleDependencies;
+import static org.apache.aries.jmx.util.FrameworkUtils.getBundleExportedPackages;
+import static org.apache.aries.jmx.util.FrameworkUtils.getBundleIds;
+import static org.apache.aries.jmx.util.FrameworkUtils.getBundleImportedPackages;
+import static org.apache.aries.jmx.util.FrameworkUtils.getRegisteredServiceIds;
+import static org.apache.aries.jmx.util.FrameworkUtils.getServiceIds;
+import static org.apache.aries.jmx.util.FrameworkUtils.getServicesInUseByBundle;
+import static org.apache.aries.jmx.util.FrameworkUtils.isBundlePendingRemoval;
+import static org.apache.aries.jmx.util.FrameworkUtils.isBundleRequiredByOthers;
+import static org.apache.aries.jmx.util.FrameworkUtils.resolveService;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.Dictionary;
+import java.util.HashSet;
+import java.util.Hashtable;
+import java.util.Set;
+
+import org.junit.Test;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Constants;
+import org.osgi.framework.ServiceReference;
+import org.osgi.framework.Version;
+import org.osgi.service.packageadmin.ExportedPackage;
+import org.osgi.service.packageadmin.PackageAdmin;
+import org.osgi.service.packageadmin.RequiredBundle;
+
+/**
+ * 
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class FrameworkUtilsTest {
+
+   
+    @Test
+    public void testGetBundleIds() throws Exception {
+
+        assertEquals(0, getBundleIds((Bundle[])null).length);
+        assertEquals(0, getBundleIds(new Bundle[0]).length);
+        
+        Bundle b1 = mock(Bundle.class);
+        when(b1.getBundleId()).thenReturn(new Long(47));
+        Bundle b2 = mock(Bundle.class);
+        when(b2.getBundleId()).thenReturn(new Long(23));
+        
+        assertArrayEquals(new long[] { 47 , 23 }, getBundleIds(new Bundle[] { b1, b2 }));
+        
+    }
+    
+    @Test
+    public void testResolveService() throws Exception {
+        
+        BundleContext context = mock(BundleContext.class);
+        ServiceReference reference = mock(ServiceReference.class);
+        when(context.getAllServiceReferences(anyString(), anyString())).thenReturn(new ServiceReference[] { reference });        
+        ServiceReference result = resolveService(context, 998);
+        assertNotNull(result);
+        
+    }
+
+    @Test
+    public void testGetServiceIds() throws Exception {
+        
+        assertEquals(0, getServiceIds(null).length);
+        assertEquals(0, getServiceIds(new ServiceReference[0]).length);
+        
+        ServiceReference s1 = mock(ServiceReference.class);
+        when(s1.getProperty(Constants.SERVICE_ID)).thenReturn(new Long(15));
+        ServiceReference s2 = mock(ServiceReference.class);
+        when(s2.getProperty(Constants.SERVICE_ID)).thenReturn(new Long(5));
+        ServiceReference s3 = mock(ServiceReference.class);
+        when(s3.getProperty(Constants.SERVICE_ID)).thenReturn(new Long(25));
+        
+        assertArrayEquals(new long[] { 15, 5, 25 }, 
+                getServiceIds(new ServiceReference[] {s1, s2, s3} ) );
+    }
+    
+    @Test
+    public void testGetBundleExportedPackages() throws Exception {
+        
+        Bundle bundle = mock(Bundle.class);
+        PackageAdmin admin = mock(PackageAdmin.class);
+        
+        assertEquals(0, getBundleExportedPackages(bundle, admin).length);
+        
+        ExportedPackage exported = mock(ExportedPackage.class);
+        when(exported.getName()).thenReturn("org.apache.aries.jmx");
+        when(exported.getVersion()).thenReturn(new Version("1.0.0"));
+        when(admin.getExportedPackages(bundle)).thenReturn(new ExportedPackage[] { exported });
+        
+        assertArrayEquals(new String[] { "org.apache.aries.jmx;1.0.0"} , getBundleExportedPackages(bundle, admin));
+        
+    }
+    
+    
+    @Test
+    public void testGetBundleImportedPackages() throws Exception {
+        
+        Bundle bundle = mock(Bundle.class);
+        BundleContext context = mock(BundleContext.class);
+        
+        Bundle b1 = mock(Bundle.class);
+        Bundle b2 = mock(Bundle.class);
+        Bundle b3 = mock(Bundle.class);
+        when(context.getBundles()).thenReturn(new Bundle[] { bundle, b1, b2, b3 });
+        
+        ExportedPackage ep1 = mock(ExportedPackage.class);
+        when(ep1.getImportingBundles()).thenReturn(new Bundle[] { bundle, b2, b3 });
+        when(ep1.getName()).thenReturn("org.apache.aries.jmx.b1");
+        when(ep1.getVersion()).thenReturn(Version.emptyVersion);
+        ExportedPackage ep2 = mock(ExportedPackage.class);
+        when(ep2.getImportingBundles()).thenReturn(new Bundle[] { bundle, b3 });
+        when(ep2.getName()).thenReturn("org.apache.aries.jmx.b2");
+        when(ep2.getVersion()).thenReturn(Version.parseVersion("2.0.1"));
+        
+        PackageAdmin admin = mock(PackageAdmin.class);
+        when(admin.getExportedPackages(b1)).thenReturn(new ExportedPackage[] { ep1 });
+        when(admin.getExportedPackages(b2)).thenReturn(new ExportedPackage[] { ep2 });
+        when(admin.getExportedPackages(b3)).thenReturn(null);
+        
+        //check first with DynamicImport
+        Dictionary<String, String> headers = new Hashtable<String, String>();
+        headers.put(Constants.DYNAMICIMPORT_PACKAGE, "*");
+        when(bundle.getHeaders()).thenReturn(headers);
+        assertArrayEquals(new String[] { "org.apache.aries.jmx.b1;0.0.0" , "org.apache.aries.jmx.b2;2.0.1"} 
+                    , getBundleImportedPackages(context, bundle, admin));
+        
+        //check with ImportPackage statement
+        headers.remove(Constants.DYNAMICIMPORT_PACKAGE);
+        String importPackageStatement = "org.apache.aries.jmx.b1;version=0.0.0;resolution:=optional,org.apache.aries.jmx.b2;attribute:=value;version=\"[2.0, 3.0)\""; 
+        headers.put(Constants.IMPORT_PACKAGE, importPackageStatement);
+        when(admin.getExportedPackages("org.apache.aries.jmx.b1")).thenReturn(new ExportedPackage[] { ep1 });
+        when(admin.getExportedPackages("org.apache.aries.jmx.b2")).thenReturn(new ExportedPackage[] { ep2 });
+        
+        assertArrayEquals(new String[] { "org.apache.aries.jmx.b1;0.0.0" , "org.apache.aries.jmx.b2;2.0.1"} 
+                    , getBundleImportedPackages(context, bundle, admin));
+        
+        
+    }
+    
+    @Test
+    public void testGetRegisteredServiceIds() throws Exception {
+        
+        Bundle bundle = mock(Bundle.class);
+        
+        ServiceReference s1 = mock(ServiceReference.class);
+        when(s1.getProperty(Constants.SERVICE_ID)).thenReturn(new Long(56));
+        ServiceReference s2 = mock(ServiceReference.class);
+        when(s2.getProperty(Constants.SERVICE_ID)).thenReturn(new Long(5));
+        ServiceReference s3 = mock(ServiceReference.class);
+        when(s3.getProperty(Constants.SERVICE_ID)).thenReturn(new Long(34));
+        
+        when(bundle.getRegisteredServices()).thenReturn(new ServiceReference[] { s1, s2, s3 });
+        
+        assertArrayEquals(new long[] { 56, 5, 34}, getRegisteredServiceIds(bundle));
+        
+    }
+    
+    @Test
+    public void testGetServicesInUseByBundle() throws Exception {
+        
+        Bundle bundle = mock(Bundle.class);
+        
+        ServiceReference s1 = mock(ServiceReference.class);
+        when(s1.getProperty(Constants.SERVICE_ID)).thenReturn(new Long(15));
+        ServiceReference s2 = mock(ServiceReference.class);
+        when(s2.getProperty(Constants.SERVICE_ID)).thenReturn(new Long(16));
+        ServiceReference s3 = mock(ServiceReference.class);
+        when(s3.getProperty(Constants.SERVICE_ID)).thenReturn(new Long(17));
+        
+        when(bundle.getServicesInUse()).thenReturn(new ServiceReference[] { s1, s2, s3 });
+        
+        assertArrayEquals(new long[] { 15, 16, 17 }, getServicesInUseByBundle(bundle));
+        
+    }
+    
+    @Test
+    public void testIsBundlePendingRemoval() throws Exception {
+        
+        Bundle bundle = mock(Bundle.class);
+        when(bundle.getSymbolicName()).thenReturn("org.apache.testb");
+        
+        RequiredBundle reqBundle = mock(RequiredBundle.class);
+        when(reqBundle.getBundle()).thenReturn(bundle);
+        when(reqBundle.isRemovalPending()).thenReturn(true);
+        
+        PackageAdmin admin = mock(PackageAdmin.class);
+        when(admin.getRequiredBundles("org.apache.testb")).thenReturn(new RequiredBundle[] { reqBundle });
+        
+        assertTrue(isBundlePendingRemoval(bundle, admin));
+        
+    }
+    
+    @Test
+    public void testIsBundleRequiredByOthers() throws Exception {
+        
+        Bundle bundle = mock(Bundle.class);
+        when(bundle.getSymbolicName()).thenReturn("org.apache.testb");
+        
+        RequiredBundle reqBundle = mock(RequiredBundle.class);
+        when(reqBundle.getBundle()).thenReturn(bundle);
+        when(reqBundle.getRequiringBundles()).thenReturn(new Bundle[0]);
+        
+        PackageAdmin admin = mock(PackageAdmin.class);
+        when(admin.getRequiredBundles("org.apache.testb")).thenReturn(new RequiredBundle[] { reqBundle });
+        
+        assertFalse(isBundleRequiredByOthers(bundle, admin));
+        
+        Bundle user = mock(Bundle.class);
+        when(reqBundle.getRequiringBundles()).thenReturn(new Bundle[] { user });
+        
+        assertTrue(isBundleRequiredByOthers(bundle, admin));
+    }
+    
+    
+    @Test
+    public void testGetBundleDependencies() throws Exception {
+        
+        Bundle bundle = mock(Bundle.class);
+        BundleContext context = mock(BundleContext.class);
+       
+        Bundle b1 = mock(Bundle.class);
+        when(b1.getSymbolicName()).thenReturn("b1");
+        when(b1.getBundleId()).thenReturn(new Long(44));
+        Bundle b2 = mock(Bundle.class);
+        when(b2.getSymbolicName()).thenReturn("b2");
+        when(b2.getBundleId()).thenReturn(new Long(55));
+        Bundle b3 = mock(Bundle.class);
+        when(b3.getSymbolicName()).thenReturn("b3");
+        when(b3.getBundleId()).thenReturn(new Long(66));
+        
+        when(context.getBundles()).thenReturn(new Bundle[] { bundle, b1, b2, b3 });
+        
+        Dictionary<String, String> headers = new Hashtable<String, String>();
+        when(bundle.getHeaders()).thenReturn(headers);
+        
+        PackageAdmin admin = mock(PackageAdmin.class);
+        assertEquals(0, getBundleDependencies(context, bundle, admin).length);
+        
+        RequiredBundle rb1 = mock(RequiredBundle.class);
+        when(rb1.getBundle()).thenReturn(b1);
+        when(rb1.getRequiringBundles()).thenReturn(new Bundle[] { bundle, b2 });
+        RequiredBundle rb2 = mock(RequiredBundle.class);
+        when(rb2.getBundle()).thenReturn(b2);
+        when(rb2.getRequiringBundles()).thenReturn(new Bundle[] { b1 });
+        RequiredBundle rb3 = mock(RequiredBundle.class);
+        when(rb3.getBundle()).thenReturn(b3);
+        when(rb3.getRequiringBundles()).thenReturn(new Bundle[] { bundle, b1, b2 });
+        
+        headers.put(Constants.REQUIRE_BUNDLE, "b1;bundle-version=\"1.0.0\",b3;bundle-version=\"2.0.0\"");
+        
+        when(admin.getRequiredBundles("b1")).thenReturn(new RequiredBundle[] { rb1 });
+        when(admin.getRequiredBundles("b2")).thenReturn(new RequiredBundle[] { rb2 });
+        when(admin.getRequiredBundles("b3")).thenReturn(new RequiredBundle[] { rb3 });
+        
+        assertEquals(toSet(new long[] { 44, 66 }), toSet(getBundleDependencies(context, bundle, admin)));
+    }
+    
+    private static Set<Long> toSet(long[] array) {
+        Set<Long> set = new HashSet<Long>();
+        for (long value : array) {
+            set.add(value);
+        }
+        return set;
+    }
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/util/TypeUtilsTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/util/TypeUtilsTest.java
index 1f8bddab..c4a85162 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/util/TypeUtilsTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core/src/test/java/org/apache/aries/jmx/util/TypeUtilsTest.java
@@ -1,3 +1,107 @@
   + native
   + text/plain
   + Revision Date
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.util;
+
+import static org.apache.aries.jmx.util.TypeUtils.fromDictionary;
+import static org.apache.aries.jmx.util.TypeUtils.fromString;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.Dictionary;
+import java.util.Hashtable;
+import java.util.Map;
+
+import org.junit.Test;
+
+public class TypeUtilsTest {
+
+    
+    @Test
+    public void testMapFromDictionary() throws Exception{
+        
+        Dictionary<String, String> dictionary = new Hashtable<String, String>();
+        dictionary.put("one", "1");
+        dictionary.put("two", "2");
+        
+        Map<String,String> map = fromDictionary(dictionary);
+        assertEquals(2, map.size());
+        assertEquals("1", map.get("one"));
+        assertEquals("2", map.get("two"));
+        
+    }
+    
+    @Test
+    public void testFromString() throws Exception {
+        
+        String value;
+        
+        value = "1";
+        Integer integerValue = fromString(Integer.class, value);
+        assertEquals(new Integer(1), integerValue);
+        
+        int intValue = fromString(Integer.TYPE, value);
+        assertEquals(1, intValue);
+        
+        Long wrappedLongValue = fromString(Long.class, value);
+        assertEquals(Long.valueOf(1), wrappedLongValue);
+        
+        long longValue = fromString(Long.TYPE, value);
+        assertEquals(1, longValue);
+        
+        Double wrappedDoubleValue = fromString(Double.class, value);
+        assertEquals(Double.valueOf(1), wrappedDoubleValue);
+        
+        double doubleValue = fromString(Double.TYPE, value);
+        assertEquals(1, doubleValue, 0);
+        
+        Float wrappedFloatValue = fromString(Float.class, value);
+        assertEquals(Float.valueOf(1), wrappedFloatValue);
+        
+        float floatValue = fromString(Float.TYPE, value);
+        assertEquals(1, floatValue, 0);
+        
+        Short shortValue = fromString(Short.class, value);
+        assertEquals(Short.valueOf(value), shortValue);
+        
+        Byte byteValue = fromString(Byte.class, value);
+        assertEquals(Byte.valueOf(value), byteValue);
+        
+        value = "true";
+        assertTrue(fromString(Boolean.class, value));
+        assertTrue(fromString(Boolean.TYPE, value));
+        
+        char charValue = fromString(Character.TYPE, "a");
+        assertEquals('a', charValue);
+        Character characterValue = fromString(Character.class, "a");
+        assertEquals(Character.valueOf('a'), characterValue);
+        
+        BigDecimal bigDecimal = fromString(BigDecimal.class, "2");
+        assertEquals(new BigDecimal("2"), bigDecimal);
+     
+        BigInteger bigInteger = fromString(BigInteger.class, "2");
+        assertEquals(new BigInteger("2"), bigInteger);
+        
+        String stringValue = fromString(String.class, value);
+        assertEquals(stringValue, value);
+        
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core-whiteboard/src/main/java/org/apache/aries/jmx/core/whiteboard/Activator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core-whiteboard/src/main/java/org/apache/aries/jmx/core/whiteboard/Activator.java
index e69de29b..4b737ecf 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core-whiteboard/src/main/java/org/apache/aries/jmx/core/whiteboard/Activator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-core-whiteboard/src/main/java/org/apache/aries/jmx/core/whiteboard/Activator.java
@@ -0,0 +1,432 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.core.whiteboard;
+
+import java.util.Hashtable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.apache.aries.jmx.Logger;
+import org.apache.aries.jmx.framework.BundleState;
+import org.apache.aries.jmx.framework.Framework;
+import org.apache.aries.jmx.framework.PackageState;
+import org.apache.aries.jmx.framework.ServiceState;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleActivator;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Constants;
+import org.osgi.framework.Filter;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.ServiceFactory;
+import org.osgi.framework.ServiceReference;
+import org.osgi.framework.ServiceRegistration;
+import org.osgi.jmx.framework.BundleStateMBean;
+import org.osgi.jmx.framework.FrameworkMBean;
+import org.osgi.jmx.framework.PackageStateMBean;
+import org.osgi.jmx.framework.ServiceStateMBean;
+import org.osgi.jmx.service.cm.ConfigurationAdminMBean;
+import org.osgi.jmx.service.permissionadmin.PermissionAdminMBean;
+import org.osgi.jmx.service.provisioning.ProvisioningServiceMBean;
+import org.osgi.jmx.service.useradmin.UserAdminMBean;
+import org.osgi.service.cm.ConfigurationAdmin;
+import org.osgi.service.packageadmin.PackageAdmin;
+import org.osgi.service.permissionadmin.PermissionAdmin;
+import org.osgi.service.provisioning.ProvisioningService;
+import org.osgi.service.startlevel.StartLevel;
+import org.osgi.service.useradmin.UserAdmin;
+import org.osgi.util.tracker.ServiceTracker;
+import org.osgi.util.tracker.ServiceTrackerCustomizer;
+
+public class Activator implements BundleActivator, ServiceTrackerCustomizer
+{
+  private ServiceTracker tracker;
+  private BundleContext ctx;
+  private ConcurrentMap<Long, ServiceRegistration> _provisioningMBeans = new ConcurrentHashMap<Long, ServiceRegistration>();
+  private ConcurrentMap<Long, ServiceRegistration> _userAdminMBeans = new ConcurrentHashMap<Long, ServiceRegistration>();
+  private ConcurrentMap<Long, ServiceRegistration> _configAdminMBeans = new ConcurrentHashMap<Long, ServiceRegistration>();
+
+  private AtomicReference<ServiceRegistration> _serviceStateMbean = new AtomicReference<ServiceRegistration>();
+  private AtomicReference<ServiceRegistration> _permissionAdminMbean = new AtomicReference<ServiceRegistration>();
+  private AtomicReference<ServiceRegistration> _packageStateMbean = new AtomicReference<ServiceRegistration>();
+  private AtomicReference<ServiceRegistration> _bundleState = new AtomicReference<ServiceRegistration>();
+  private AtomicReference<ServiceRegistration> _framework = new AtomicReference<ServiceRegistration>();
+
+  private AtomicReference<ServiceReference> _startLevel = new AtomicReference<ServiceReference>();
+  private AtomicReference<ServiceReference> _packageAdmin = new AtomicReference<ServiceReference>();
+
+  private static final String PACKAGE_ADMIN = "org.osgi.service.packageadmin.PackageAdmin";
+  private static final String START_LEVEL = "org.osgi.service.startlevel.StartLevel";
+  private static final String PERMISSION_ADMIN = "org.osgi.service.permissionadmin.PermissionAdmin";
+  private static final String CONFIG_ADMIN = "org.osgi.service.cm.ConfigurationAdmin";
+  private static final String USER_ADMIN = "org.osgi.service.useradmin.UserAdmin";
+  private static final String PROVISIONING_SERVICE = "org.osgi.service.provisioning.ProvisioningService";
+
+  private Logger logger;
+  
+  private class MBeanServiceProxy<T> implements ServiceFactory
+  {
+    private Factory<T> objectFactory;
+    private AtomicReference<T> result = new AtomicReference<T>();
+    
+    private MBeanServiceProxy(Factory<T> factory) {
+      objectFactory = factory;
+    }
+    
+    public Object getService(Bundle bundle, ServiceRegistration registration)
+    {
+      if (result.get() == null) {
+        result.compareAndSet(null, objectFactory.create());
+      }
+      return result.get();
+    }
+    
+    public void ungetService(Bundle bundle, ServiceRegistration registration, Object service)
+    {
+    }
+  }
+
+  private interface Factory<T>
+  {
+    public abstract T create();
+  }
+  
+  private abstract class BaseFactory<T> implements Factory<T>
+  {
+    public abstract T create(PackageAdmin pa, StartLevel sl);
+    public final T create()
+    {
+      StartLevel sl = null;
+      PackageAdmin pa = null;
+      
+      ServiceReference slRef = _startLevel.get();
+      if (slRef != null) {
+        sl = (StartLevel) ctx.getService(slRef);
+      }
+      ServiceReference paRef = _packageAdmin.get();
+      
+      if (paRef != null) {
+        pa = (PackageAdmin) ctx.getService(paRef);
+      }
+      
+      if (pa == null) {
+        ctx.ungetService(slRef);
+      }
+      
+      if (sl != null && pa != null) {
+        return create(pa, sl);
+      } else {
+        return null;
+      }
+    }
+  }
+
+  public void start(BundleContext context) throws Exception
+  {
+    ctx = context;
+    logger = new Logger(ctx);
+    
+    Filter filter = getFilter(context, PACKAGE_ADMIN, START_LEVEL,
+        PERMISSION_ADMIN, CONFIG_ADMIN, USER_ADMIN,
+        PROVISIONING_SERVICE);
+
+    tracker = new ServiceTracker(context, filter, this);
+    tracker.open();
+    
+    registerMBean(ServiceStateMBean.class.getName(), new Factory<ServiceStateMBean>() {
+      public ServiceStateMBean create()
+      {
+        return new ServiceState(ctx, logger);
+      }
+    }, ServiceStateMBean.OBJECTNAME, _serviceStateMbean );
+  }
+
+  private Filter getFilter(BundleContext ctx, String ... services) throws InvalidSyntaxException
+  {
+    StringBuilder builder = new StringBuilder("(|");
+    
+    for (String type : services) {
+      builder.append('(');
+      builder.append(Constants.OBJECTCLASS);
+      builder.append('=');
+      builder.append(type);
+      builder.append(')');
+    }
+    
+    builder.append(')');
+    return ctx.createFilter(builder.toString());
+  }
+
+  public void stop(BundleContext context) throws Exception
+  {
+    tracker.close();
+  }
+
+  public Object addingService(ServiceReference reference)
+  {
+    Object tracked = null;
+    
+    String[] types = (String[]) reference.getProperty(Constants.OBJECTCLASS);
+    
+    for (String t : types) {
+      if (PACKAGE_ADMIN.equals(t)) {
+        foundPackageAdmin(reference);
+        tracked = reference;
+      } else if (START_LEVEL.equals(t)) {
+        foundStartLevel(reference);
+        tracked = reference;
+      } else if (PERMISSION_ADMIN.equals(t)) {
+        foundPermissionAdmin(reference);
+        tracked = reference;
+      } else if (CONFIG_ADMIN.equals(t)) {
+        foundConfigAdmin(reference);
+        tracked = reference;
+      } else if (USER_ADMIN.equals(t)) {
+        foundUserAdmin(reference);
+        tracked = reference;
+      } else if (PROVISIONING_SERVICE.equals(t)) {
+        foundProvisioningService(reference);
+        tracked = reference;
+      }
+    }
+    
+    return tracked;
+  }
+
+  private <T> void registerMBean(String type, Factory<T> factory, String objectName, AtomicReference<ServiceRegistration> result)
+  {
+    synchronized (result) {
+      ServiceRegistration reg = registerAnMbean(type, factory, objectName);
+      
+      if (!!!result.compareAndSet(null, reg)) {
+        reg.unregister();
+      }
+    }
+  }
+  
+  private <T> void registerMBean(String type, Factory<T> factory, String objectName, ConcurrentMap<Long, ServiceRegistration> mbeans,
+      ServiceReference referencedServices, String underlyingType)
+  {
+    try {
+      Class.forName(underlyingType);
+      if (referencedServices.isAssignableTo(ctx.getBundle(), underlyingType)) {
+        ServiceRegistration reg = registerAnMbean(type, factory, objectName);
+  
+        Long id = (Long) reg.getReference().getProperty(Constants.SERVICE_ID);
+        mbeans.put(id, reg);
+      }
+    } catch (ClassNotFoundException e) {
+    }
+  }
+
+  private <T> ServiceRegistration registerAnMbean(String type, Factory<T> factory, String objectName)
+  {
+    Hashtable<String, Object> properties = new Hashtable<String, Object>();
+    properties.put("jmx.objectname", objectName);
+    
+    Object service = new MBeanServiceProxy<T>(factory);
+    
+    ServiceRegistration reg = ctx.registerService(type, service, properties);
+    return reg;
+  }
+  
+  private void foundPermissionAdmin(final ServiceReference reference)
+  {
+    registerMBean(PermissionAdminMBean.class.getName(), new Factory<PermissionAdminMBean>() {
+      public PermissionAdminMBean create()
+      {
+        PermissionAdmin service = (PermissionAdmin) ctx.getService(reference);
+        
+        if (service == null) return null;
+        else return new org.apache.aries.jmx.permissionadmin.PermissionAdmin(service);
+      }
+    }, PermissionAdminMBean.OBJECTNAME, _permissionAdminMbean);
+  }
+
+  private void foundProvisioningService(final ServiceReference reference)
+  {
+    registerMBean(ProvisioningServiceMBean.class.getName(), new Factory<ProvisioningServiceMBean>() {
+        public ProvisioningServiceMBean create()
+        {
+          ProvisioningService service = (ProvisioningService) ctx.getService(reference);
+          
+          if (service == null) return null;
+          else return new org.apache.aries.jmx.provisioning.ProvisioningService(service);
+        }
+      }, ProvisioningServiceMBean.OBJECTNAME, _provisioningMBeans, reference, PROVISIONING_SERVICE);
+  }
+
+  private void foundUserAdmin(final ServiceReference reference)
+  {
+    try {
+      Class.forName(USER_ADMIN);
+      if (reference.isAssignableTo(ctx.getBundle(), USER_ADMIN)) {
+        registerMBean(UserAdminMBean.class.getName(), new Factory<UserAdminMBean>() {
+          public UserAdminMBean create()
+          {
+            UserAdmin service = (UserAdmin) ctx.getService(reference);
+            
+            if (service == null) return null;
+            else return new org.apache.aries.jmx.useradmin.UserAdmin(service);
+          }
+        }, UserAdminMBean.OBJECTNAME, _userAdminMBeans, reference, USER_ADMIN);
+      }
+    } catch (ClassNotFoundException e) {
+    }
+  }
+
+  private void foundConfigAdmin(final ServiceReference reference)
+  {
+    registerMBean(ConfigurationAdminMBean.class.getName(), new Factory<ConfigurationAdminMBean>() {
+      public ConfigurationAdminMBean create()
+      {
+        ConfigurationAdmin service = (ConfigurationAdmin) ctx.getService(reference);
+        
+        if (service == null) return null;
+        else return new org.apache.aries.jmx.cm.ConfigurationAdmin(service);
+      }
+    }, ConfigurationAdminMBean.OBJECTNAME, _configAdminMBeans, reference, CONFIG_ADMIN);
+  }
+
+  private void foundStartLevel(final ServiceReference reference)
+  {
+    if (_startLevel.compareAndSet(null, reference)) {
+      registerBundleStateAndFrameworkIfPossible();
+    }
+  }
+
+  private void foundPackageAdmin(final ServiceReference reference)
+  {
+    registerMBean(PackageStateMBean.class.getName(), new Factory<PackageStateMBean>() {
+      public PackageStateMBean create()
+      {
+        PackageAdmin service = (PackageAdmin) ctx.getService(reference);
+        
+        if (service == null) return null;
+        else return new PackageState(ctx, service);
+      }
+    }, PackageStateMBean.OBJECTNAME, _packageStateMbean);
+    
+    if (_packageAdmin.compareAndSet(null, reference)) {
+      registerBundleStateAndFrameworkIfPossible();
+    }
+  }
+
+  // This method is synchronized to ensure that notification of StartLevel and PackageAdmin
+  // on different threads at the same time doesn't cause problems. It only affects these services
+  // so it shouldn't be too expensive.
+  private synchronized void registerBundleStateAndFrameworkIfPossible()
+  {
+      if (_bundleState.get() == null && _startLevel.get() != null && _packageAdmin.get() != null) {
+        registerMBean(BundleStateMBean.class.getName(), new BaseFactory<BundleStateMBean>() {
+          @Override
+          public BundleStateMBean create(PackageAdmin pa, StartLevel sl)
+          {
+            return new BundleState(ctx, pa, sl, logger);
+          }
+        }, BundleStateMBean.OBJECTNAME, _bundleState);
+      }
+      if (_framework.get() == null && _startLevel.get() != null && _packageAdmin.get() != null) {
+        registerMBean(FrameworkMBean.class.getName(), new BaseFactory<FrameworkMBean>() {
+          @Override
+          public FrameworkMBean create(PackageAdmin pa, StartLevel sl)
+          {
+            return new Framework(ctx, sl, pa);
+          }
+        }, FrameworkMBean.OBJECTNAME, _framework);
+      }
+  }
+
+  public void modifiedService(ServiceReference reference, Object service)
+  {
+  }
+
+  public void removedService(ServiceReference reference, Object service)
+  {
+    String[] types = (String[]) reference.getProperty(Constants.OBJECTCLASS);
+    
+    for (String t : types) {
+      if (PACKAGE_ADMIN.equals(t)) {
+        lostPackageAdmin(reference);
+      } else if (START_LEVEL.equals(t)) {
+        lostStartLevel(reference);
+      } else if (PERMISSION_ADMIN.equals(t)) {
+        lostPermissionAdmin(reference);
+      } else if (CONFIG_ADMIN.equals(t)) {
+        lostConfigAdmin(reference);
+      } else if (USER_ADMIN.equals(t)) {
+        lostUserAdmin(reference);
+      } else if (PROVISIONING_SERVICE.equals(t)) {
+        lostProvisioningService(reference);
+      }
+    }
+    
+  }
+
+  private void lostProvisioningService(ServiceReference reference)
+  {
+    unregister(reference, _provisioningMBeans);
+  }
+
+  private void lostUserAdmin(ServiceReference reference)
+  {
+    unregister(reference, _userAdminMBeans);
+  }
+
+  private void lostConfigAdmin(ServiceReference reference)
+  {
+    unregister(reference, _configAdminMBeans);
+  }
+  
+  private void unregister(ServiceReference reference, ConcurrentMap<Long, ServiceRegistration> mbeans)
+  {
+    Long id = (Long) reference.getProperty(Constants.SERVICE_ID);
+    ServiceRegistration reg = mbeans.remove(id);
+    if (reg != null) reg.unregister();
+  }
+
+  private void lostPermissionAdmin(ServiceReference reference)
+  {
+    safeUnregister(_permissionAdminMbean);
+  }
+
+  private void lostStartLevel(ServiceReference reference)
+  {
+    if (_startLevel.compareAndSet(reference, null)) {
+      safeUnregister(_bundleState);
+      safeUnregister(_framework);
+    }
+  }
+
+  private void lostPackageAdmin(ServiceReference reference)
+  {
+    if (_packageAdmin.compareAndSet(reference, null)) {
+      safeUnregister(_bundleState);
+      safeUnregister(_framework);
+      
+      safeUnregister(_packageStateMbean);
+    }
+  }
+
+  private void safeUnregister(AtomicReference<ServiceRegistration> atomicRegistration)
+  {
+    ServiceRegistration reg = atomicRegistration.getAndSet(null);
+    if (reg != null) reg.unregister();
+  }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/AbstractIntegrationTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/AbstractIntegrationTest.java
index 17c97dcc..1fac472d 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/AbstractIntegrationTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/AbstractIntegrationTest.java
@@ -1 +1,110 @@
   + text/plain
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx;
+
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.fail;
+import javax.management.InstanceNotFoundException;
+import javax.management.MBeanServer;
+import javax.management.MBeanServerFactory;
+import javax.management.MBeanServerInvocationHandler;
+import javax.management.ObjectName;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.runner.RunWith;
+import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.osgi.framework.ServiceReference;
+import org.osgi.framework.ServiceRegistration;
+
+/**
+ * @version $Rev$ $Date$
+ */
+@RunWith(JUnit4TestRunner.class)
+public class AbstractIntegrationTest extends org.apache.aries.itest.AbstractIntegrationTest {
+    
+    ServiceRegistration registration;
+    ServiceReference reference;
+    protected MBeanServer mbeanServer;
+
+    @Before
+    public void setUp() throws Exception {
+        mbeanServer = MBeanServerFactory.createMBeanServer();
+
+        registration = bundleContext.registerService(MBeanServer.class
+                .getCanonicalName(), mbeanServer, null);
+            
+        String key = MBeanServer.class.getCanonicalName();
+        System.out.println(key);
+
+        reference = bundleContext.getServiceReference(key);
+        assertNotNull(reference);
+        MBeanServer mbeanService = (MBeanServer) bundleContext.getService(reference);
+        assertNotNull(mbeanService);
+        
+        doSetUp();
+    }
+    
+    /**
+     * A hook for subclasses.
+     * 
+     * @throws Exception
+     */
+    protected void doSetUp() throws Exception {}
+    
+    @After
+    public void tearDown() throws Exception {
+        bundleContext.ungetService(reference);
+        //plainRegistration.unregister();
+    }
+    
+    protected void waitForMBean(ObjectName name) throws Exception {
+        waitForMBean(name, 10);        
+    }
+    
+    protected void waitForMBean(ObjectName name, int timeoutInSeconds) throws Exception {
+        int i=0;
+        while (true) {
+            try {
+                mbeanServer.getObjectInstance(name);
+                break;
+            } catch (InstanceNotFoundException e) {
+                if (i == timeoutInSeconds) {
+                    throw new Exception(name + " mbean is not available after waiting " + timeoutInSeconds + " seconds");
+                }
+            }
+            i++;
+            Thread.sleep(1000);
+        }
+    }
+    
+    @SuppressWarnings("unchecked")
+    protected <T> T getMBean(String name, Class<T> type) {
+        ObjectName objectName = null;
+        try {
+            objectName = new ObjectName(name);
+        } catch (Exception e) {
+            fail(e.toString());
+        }
+        assertNotNull(mbeanServer);
+        assertNotNull(objectName);
+        T mbean = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, objectName,
+                type, false);
+        return mbean;
+    }    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanTest.java
index 17c97dcc..58d698cb 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanTest.java
@@ -1 +1,256 @@
   + text/plain
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.cm;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.ops4j.pax.exam.CoreOptions.provision;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.modifyBundle;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.newBundle;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.withBnd;
+
+import static org.apache.aries.itest.ExtraOptions.*;
+
+import java.io.InputStream;
+import java.util.Dictionary;
+
+import javax.management.ObjectName;
+import javax.management.openmbean.TabularData;
+
+import org.apache.aries.jmx.AbstractIntegrationTest;
+import org.apache.aries.jmx.codec.PropertyData;
+import org.apache.aries.jmx.test.bundlea.api.InterfaceA;
+import org.apache.aries.jmx.test.bundleb.api.InterfaceB;
+import org.apache.aries.jmx.test.bundleb.api.MSF;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.ops4j.pax.exam.CoreOptions;
+import org.ops4j.pax.exam.Customizer;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.Constants;
+import org.osgi.framework.Filter;
+import org.osgi.jmx.service.cm.ConfigurationAdminMBean;
+import org.osgi.service.cm.ConfigurationAdmin;
+import org.osgi.util.tracker.ServiceTracker;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class ConfigurationAdminMBeanTest extends AbstractIntegrationTest {
+
+    @Configuration
+    public static Option[] configuration() {
+        return testOptions(
+                        CoreOptions.equinox(),
+                        paxLogging("INFO"),
+                        
+                        mavenBundle("org.apache.felix", "org.apache.felix.configadmin"),
+                        mavenBundle("org.osgi", "org.osgi.compendium"),
+                        mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx"),
+                        mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.whiteboard"),
+                        new Customizer() {
+                            public InputStream customizeTestProbe(InputStream testProbe) throws Exception {
+                                return modifyBundle(testProbe)
+                                           .removeHeader(Constants.DYNAMICIMPORT_PACKAGE)
+                                           .set(Constants.REQUIRE_BUNDLE, "org.apache.aries.jmx.test.bundlea,org.apache.aries.jmx.test.bundleb")
+                                           .build(withBnd());
+                            }
+                        },
+                        provision(newBundle()
+                                .add(org.apache.aries.jmx.test.bundlea.Activator.class)
+                                .add(org.apache.aries.jmx.test.bundlea.api.InterfaceA.class)
+                                .add(org.apache.aries.jmx.test.bundlea.impl.A.class)
+                                .set(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundlea")
+                                .set(Constants.BUNDLE_VERSION, "2.0.0")
+                                .set(Constants.EXPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api;version=2.0.0")
+                                .set(Constants.IMPORT_PACKAGE,
+                                        "org.osgi.framework;version=1.5.0,org.osgi.util.tracker,org.apache.aries.jmx.test.bundleb.api;version=1.1.0;resolution:=optional" +
+                                        ",org.osgi.service.cm")
+                                .set(Constants.BUNDLE_ACTIVATOR,
+                                        org.apache.aries.jmx.test.bundlea.Activator.class.getName())
+                                .build(withBnd())),
+                        provision(newBundle()
+                                .add(org.apache.aries.jmx.test.bundleb.Activator.class)
+                                .add(org.apache.aries.jmx.test.bundleb.api.InterfaceB.class)
+                                .add(org.apache.aries.jmx.test.bundleb.api.MSF.class)
+                                .add(org.apache.aries.jmx.test.bundleb.impl.B.class)
+                                .set(Constants.BUNDLE_SYMBOLICNAME,"org.apache.aries.jmx.test.bundleb")
+                                .set(Constants.BUNDLE_VERSION, "1.0.0")
+                                .set(Constants.EXPORT_PACKAGE,"org.apache.aries.jmx.test.bundleb.api;version=1.1.0")
+                                .set(Constants.IMPORT_PACKAGE,"org.osgi.framework;version=1.5.0,org.osgi.util.tracker" +
+                                        ",org.osgi.service.cm")
+                                .set(Constants.BUNDLE_ACTIVATOR,
+                                        org.apache.aries.jmx.test.bundleb.Activator.class.getName())
+                                .build(withBnd()))
+                        );
+    }
+    
+    @Override
+    public void doSetUp() throws Exception {
+        waitForMBean(new ObjectName(ConfigurationAdminMBean.OBJECTNAME));
+    }
+    
+    @Ignore("ManagedServiceFactory tests failing.. " +
+            "Some issues surrounding creating a factory configuration and then retrieving by pid to update.. Needs investigation")
+    @Test
+    @SuppressWarnings("unchecked")
+    public void testMBeanInterface() throws Exception {
+        
+        ConfigurationAdminMBean mbean = getMBean(ConfigurationAdminMBean.OBJECTNAME, ConfigurationAdminMBean.class);
+        assertNotNull(mbean);
+       
+        // get bundles
+        
+        Bundle a = context().getBundleByName("org.apache.aries.jmx.test.bundlea");
+        assertNotNull(a);
+        
+        Bundle b = context().getBundleByName("org.apache.aries.jmx.test.bundleb");
+        assertNotNull(b);
+       
+        
+        // get services
+        
+        ServiceTracker trackerA = new ServiceTracker(bundleContext, InterfaceA.class.getName(), null);
+        trackerA.open();
+        InterfaceA managedServiceA = (InterfaceA) trackerA.getService();
+        assertNotNull(managedServiceA);
+        
+        Filter filter = bundleContext.createFilter("(" + Constants.SERVICE_PID + "=jmx.test.B.factory)");
+        ServiceTracker trackerMSF = new ServiceTracker(bundleContext, filter, null);
+        trackerMSF.open();
+        MSF managedFactory = (MSF) trackerMSF.getService();
+        assertNotNull(managedFactory);
+        
+        ServiceTracker tracker = new ServiceTracker(bundleContext, ConfigurationAdmin.class.getName(), null);
+        tracker.open();
+        ConfigurationAdmin configAdmin = (ConfigurationAdmin) tracker.getService();
+        assertNotNull(configAdmin);
+        
+        // ManagedService operations
+        
+        assertNull(managedServiceA.getConfig());
+        
+        // create a configuration for A
+        TabularData data = mbean.getProperties("org.apache.aries.jmx.test.ServiceA");
+        assertEquals(0, data.size());
+        
+        PropertyData<String> p1 = PropertyData.newInstance("A1", "first");
+        data.put(p1.toCompositeData());
+        PropertyData<Integer> p2 = PropertyData.newInstance("A2", 2);
+        data.put(p2.toCompositeData());
+        
+        mbean.update("org.apache.aries.jmx.test.ServiceA", data);
+        
+        Thread.sleep(1000);
+        Dictionary<String, Object> config = managedServiceA.getConfig();
+        assertNotNull(config);
+        assertEquals(3, config.size());
+        assertEquals("org.apache.aries.jmx.test.ServiceA", config.get(Constants.SERVICE_PID));
+        assertEquals("first", config.get("A1"));
+        assertEquals(2, config.get("A2"));
+        
+        //delete
+        mbean.deleteForLocation("org.apache.aries.jmx.test.ServiceA", a.getLocation());
+        
+        Thread.sleep(1000);
+        assertNull(managedServiceA.getConfig());
+        
+        
+        // ManagedServiceFactory operations
+        
+        String cpid = mbean.createFactoryConfiguration("jmx.test.B.factory");
+        assertNotNull(cpid);
+        assertTrue(cpid.contains("jmx.test.B.factory"));
+        
+        TabularData fConfig = mbean.getProperties(cpid);
+        assertNotNull(fConfig);
+        assertEquals(0, fConfig.values().size());
+        
+        PropertyData<String> prop1 = PropertyData.newInstance("B1", "value1");
+        fConfig.put(prop1.toCompositeData());
+        PropertyData<Boolean> prop2 = PropertyData.newInstance("B2", true);
+        fConfig.put(prop2.toCompositeData());
+        
+        mbean.update(cpid, fConfig);
+        
+        Thread.sleep(1000);
+        
+        InterfaceB configured = managedFactory.getConfigured(cpid);
+        assertNotNull(configured);
+        config = configured.getConfig();
+        assertNotNull(config);
+        assertTrue(config.size() >= 4);
+        assertEquals("jmx.test.B.factory", config.get(ConfigurationAdmin.SERVICE_FACTORYPID));
+        assertEquals(cpid, config.get(Constants.SERVICE_PID));
+        assertEquals("value1", config.get("B1"));
+        assertEquals("true", config.get("B2"));
+        
+        assertEquals("jmx.test.B.factory", mbean.getFactoryPid(cpid));
+        
+        mbean.delete(cpid);
+        
+        Thread.sleep(1000);
+        
+        assertNull(managedFactory.getConfigured(cpid));
+       
+        // list operations
+        
+        data = mbean.getProperties("org.apache.aries.jmx.test.ServiceA");
+        assertEquals(0, data.size());
+        
+        p1 = PropertyData.newInstance("A1", "a1Value");
+        data.put(p1.toCompositeData());
+        
+        mbean.update("org.apache.aries.jmx.test.ServiceA", data);
+        
+        Thread.sleep(1000);
+        
+        config = managedServiceA.getConfig();
+        assertNotNull(config);
+        assertEquals(2, config.size());
+        assertEquals("org.apache.aries.jmx.test.ServiceA", config.get(Constants.SERVICE_PID));
+        assertEquals("a1Value", config.get("A1"));
+
+        
+        String[][] configurations = mbean.getConfigurations("(A1=a1Value)");
+        assertNotNull(configurations);
+        assertEquals(1, configurations.length);
+        assertEquals("org.apache.aries.jmx.test.ServiceA", configurations[0][0]);
+        assertEquals(a.getLocation(), configurations[0][1]);
+        
+        // delete with filter
+        mbean.deleteConfigurations("(A1=a1Value)");
+        
+        Thread.sleep(1000);
+        
+        assertNull(managedServiceA.getConfig());
+        
+        //clean up
+        
+        trackerA.close();
+        trackerMSF.close();
+        tracker.close();
+        
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanWhiteboardTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanWhiteboardTest.java
index 56d8ebfd..b16ec5be 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanWhiteboardTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/cm/ConfigurationAdminMBeanWhiteboardTest.java
@@ -1,2 +1,47 @@
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.cm;
+
+import org.apache.aries.itest.ExtraOptions;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.ops4j.pax.exam.options.MavenArtifactProvisionOption;
+
+public class ConfigurationAdminMBeanWhiteboardTest extends ConfigurationAdminMBeanTest
+{
+  @Configuration
+  public static Option[] configuration() {
+    Option[] options = ConfigurationAdminMBeanTest.configuration();
+    
+    for (int i = 0; i < options.length; i++)
+    {
+      if (options[i] instanceof MavenArtifactProvisionOption) {
+        MavenArtifactProvisionOption po = (MavenArtifactProvisionOption) options[i];
+        String url = po.getURL();
+        if (url.contains("mvn:org.apache.aries.jmx/org.apache.aries.jmx/")) {
+          options[i] = ExtraOptions.mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.core.whiteboard");
+        }
+      }
+    }
+    
+    return options;
+  }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/BundleRevisionsStateMBeanTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/BundleRevisionsStateMBeanTest.java
index 17c97dcc..4d076dac 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/BundleRevisionsStateMBeanTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/BundleRevisionsStateMBeanTest.java
@@ -1 +1,157 @@
   + text/plain
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import static org.apache.aries.itest.ExtraOptions.mavenBundle;
+import static org.apache.aries.itest.ExtraOptions.paxLogging;
+import static org.apache.aries.itest.ExtraOptions.testOptions;
+import static org.ops4j.pax.exam.CoreOptions.provision;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.newBundle;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.withBnd;
+
+import java.io.IOException;
+
+import javax.management.ObjectName;
+import javax.management.openmbean.CompositeData;
+
+import org.apache.aries.jmx.AbstractIntegrationTest;
+import org.junit.Assert;
+import org.junit.Test;
+import org.ops4j.pax.exam.CoreOptions;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.Constants;
+import org.osgi.framework.wiring.BundleWiring;
+import org.osgi.jmx.framework.BundleRevisionsStateMBean;
+import org.osgi.jmx.framework.PackageStateMBean;
+
+/**
+ *
+ *
+ * @version $Rev: 1190259 $ $Date: 2011-10-28 12:46:48 +0100 (Fri, 28 Oct 2011) $
+ */
+public class BundleRevisionsStateMBeanTest extends AbstractIntegrationTest {
+
+    @Configuration
+    public static Option[] configuration() {
+        return testOptions(
+                //  new VMOption( "-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000" ),
+                //  new TimeoutOption( 0 ),
+
+            PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),
+            CoreOptions.equinox().version("3.7.0.v20110613"),
+            paxLogging("INFO"),
+
+            mavenBundle("org.apache.felix", "org.apache.felix.configadmin"),
+            mavenBundle("org.osgi", "org.osgi.compendium"),
+            mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx"),
+            mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.api"),
+            mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.whiteboard"),
+            mavenBundle("org.apache.aries", "org.apache.aries.util"),
+            provision(newBundle()
+                    .add(org.apache.aries.jmx.test.bundlea.Activator.class)
+                    .add(org.apache.aries.jmx.test.bundlea.api.InterfaceA.class)
+                    .add(org.apache.aries.jmx.test.bundlea.impl.A.class)
+                    .set(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundlea")
+                    .set(Constants.BUNDLE_VERSION, "2.0.0")
+                    .set(Constants.EXPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api;version=2.0.0")
+                    .set(Constants.IMPORT_PACKAGE,
+                            "org.osgi.framework;version=1.5.0,org.osgi.util.tracker,org.apache.aries.jmx.test.bundleb.api;version=1.1.0;resolution:=optional" +
+                            ",org.osgi.service.cm")
+                    .set(Constants.BUNDLE_ACTIVATOR,
+                            org.apache.aries.jmx.test.bundlea.Activator.class.getName())
+                    .build(withBnd())),
+            provision(newBundle()
+                    .add(org.apache.aries.jmx.test.bundleb.Activator.class)
+                    .add(org.apache.aries.jmx.test.bundleb.api.InterfaceB.class)
+                    .add(org.apache.aries.jmx.test.bundleb.api.MSF.class)
+                    .add(org.apache.aries.jmx.test.bundleb.impl.B.class)
+                    .set(Constants.BUNDLE_SYMBOLICNAME,"org.apache.aries.jmx.test.bundleb")
+                    .set(Constants.BUNDLE_VERSION, "1.0.0")
+                    .set(Constants.EXPORT_PACKAGE,"org.apache.aries.jmx.test.bundleb.api;version=1.1.0")
+                    .set(Constants.IMPORT_PACKAGE,"org.osgi.framework;version=1.5.0,org.osgi.util.tracker," +
+                            "org.osgi.service.cm,org.apache.aries.jmx.test.fragmentc")
+                    .set(Constants.BUNDLE_ACTIVATOR,
+                            org.apache.aries.jmx.test.bundleb.Activator.class.getName())
+                    .build(withBnd())),
+            provision(newBundle()
+                    .add(org.apache.aries.jmx.test.fragmentc.C.class)
+                    .set(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.fragc")
+                    .set(Constants.FRAGMENT_HOST, "org.apache.aries.jmx.test.bundlea")
+                    .set(Constants.EXPORT_PACKAGE, "org.apache.aries.jmx.test.fragmentc")
+                    .build(withBnd())),
+            provision(newBundle()
+                    .set(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundled")
+                    .set(Constants.BUNDLE_VERSION, "3.0.0")
+                    .set(Constants.REQUIRE_BUNDLE, "org.apache.aries.jmx.test.bundlea;bundle-version=2.0.0")
+                    .build(withBnd()))
+            );
+
+    }
+
+    @Override
+    public void doSetUp() throws Exception {
+        waitForMBean(new ObjectName(PackageStateMBean.OBJECTNAME));
+    }
+
+    @Test
+    public void testMBeanInterface() throws IOException {
+        // BundleStateMBean bsMBean = getMBean(BundleStateMBean.OBJECTNAME, BundleStateMBean.class);
+        BundleRevisionsStateMBean brsMBean = getMBean(BundleRevisionsStateMBean.OBJECTNAME, BundleRevisionsStateMBean.class);
+
+        Bundle a = context().getBundleByName("org.apache.aries.jmx.test.bundlea");
+
+        CompositeData wiring = brsMBean.getCurrentWiring(a.getBundleId(), BundleRevisionsStateMBean.PACKAGE_NAMESPACE);
+
+        Assert.assertEquals(BundleRevisionsStateMBean.BUNDLE_WIRING_TYPE, wiring.getCompositeType());
+        Assert.assertEquals(a.getBundleId(), wiring.get(BundleRevisionsStateMBean.BUNDLE_ID));
+
+        BundleWiring bw = a.adapt(BundleWiring.class);
+        CompositeData[] capabilities = (CompositeData[]) wiring.get(BundleRevisionsStateMBean.CAPABILITIES);
+        Assert.assertEquals(bw.getCapabilities(BundleRevisionsStateMBean.PACKAGE_NAMESPACE).size(), capabilities.length);
+
+        /*
+        PackageStateMBean packagaState = getMBean(PackageStateMBean.OBJECTNAME, PackageStateMBean.class);
+        assertNotNull(packagaState);
+
+        long[] exportingBundles = packagaState.getExportingBundles("org.osgi.jmx.framework", "1.5.0");
+        assertNotNull(exportingBundles);
+        assertTrue("Should find a bundle exporting org.osgi.jmx.framework", exportingBundles.length > 0);
+
+        long[] exportingBundles2 = packagaState.getExportingBundles("test", "1.0.0");
+        assertNull("Shouldn't find a bundle exporting test package", exportingBundles2);
+
+        long[] importingBundlesId = packagaState
+                .getImportingBundles("org.osgi.jmx.framework", "1.5.0", exportingBundles[0]);
+        assertTrue("Should find bundles importing org.osgi.jmx.framework", importingBundlesId.length > 0);
+
+        TabularData table = packagaState.listPackages();
+        assertNotNull("TabularData containing CompositeData with packages info shouldn't be null", table);
+        assertEquals("TabularData should be a type PACKAGES", PackageStateMBean.PACKAGES_TYPE, table.getTabularType());
+        Collection colData = table.values();
+        assertNotNull("Collection of CompositeData shouldn't be null", colData);
+        assertFalse("Collection of CompositeData should contain elements", colData.isEmpty());
+
+        boolean isRemovalPending = packagaState.isRemovalPending("org.osgi.jmx.framework", "1.5.0", exportingBundles[0]);
+        assertFalse("Should removal pending on org.osgi.jmx.framework be false", isRemovalPending);
+        */
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/BundleStateMBeanTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/BundleStateMBeanTest.java
index 6dc540c5..35a38d1e 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/BundleStateMBeanTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/BundleStateMBeanTest.java
@@ -1,3 +1,287 @@
   + Revision Date
   + native
   + text/plain
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import static org.apache.aries.itest.ExtraOptions.mavenBundle;
+import static org.apache.aries.itest.ExtraOptions.paxLogging;
+import static org.apache.aries.itest.ExtraOptions.testOptions;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.ops4j.pax.exam.CoreOptions.provision;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.newBundle;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.withBnd;
+import static org.osgi.jmx.framework.BundleStateMBean.OBJECTNAME;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import javax.management.Notification;
+import javax.management.NotificationListener;
+import javax.management.ObjectName;
+import javax.management.openmbean.TabularData;
+
+import org.apache.aries.jmx.AbstractIntegrationTest;
+import org.apache.aries.jmx.codec.BundleData.Header;
+import org.junit.Test;
+import org.ops4j.pax.exam.CoreOptions;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.Constants;
+import org.osgi.framework.ServiceReference;
+import org.osgi.framework.Version;
+import org.osgi.jmx.framework.BundleStateMBean;
+import org.osgi.service.packageadmin.ExportedPackage;
+import org.osgi.service.packageadmin.PackageAdmin;
+
+/**
+ * @version $Rev$ $Date$
+ */
+public class BundleStateMBeanTest extends AbstractIntegrationTest {
+
+    @Configuration
+    public static Option[] configuration() {
+        return testOptions(
+                        // new VMOption( "-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000" ),
+                        // new TimeoutOption( 0 ),
+
+                        PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),
+                        CoreOptions.equinox().version("3.7.0.v20110613"),
+                        paxLogging("INFO"),
+
+                        mavenBundle("org.apache.felix", "org.apache.felix.configadmin"),
+                        mavenBundle("org.osgi", "org.osgi.compendium"),
+                        mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx"),
+                        mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.api"),
+                        mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.whiteboard"),
+                        mavenBundle("org.apache.aries", "org.apache.aries.util"),
+                        provision(newBundle()
+                                .add(org.apache.aries.jmx.test.bundlea.Activator.class)
+                                .add(org.apache.aries.jmx.test.bundlea.api.InterfaceA.class)
+                                .add(org.apache.aries.jmx.test.bundlea.impl.A.class)
+                                .set(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundlea")
+                                .set(Constants.BUNDLE_VERSION, "2.0.0")
+                                .set(Constants.EXPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api;version=2.0.0")
+                                .set(Constants.IMPORT_PACKAGE,
+                                        "org.osgi.framework;version=1.5.0,org.osgi.util.tracker,org.apache.aries.jmx.test.bundleb.api;version=1.1.0;resolution:=optional" +
+                                        ",org.osgi.service.cm")
+                                .set(Constants.BUNDLE_ACTIVATOR,
+                                        org.apache.aries.jmx.test.bundlea.Activator.class.getName())
+                                .build(withBnd())),
+                        provision(newBundle()
+                                .add(org.apache.aries.jmx.test.bundleb.Activator.class)
+                                .add(org.apache.aries.jmx.test.bundleb.api.InterfaceB.class)
+                                .add(org.apache.aries.jmx.test.bundleb.api.MSF.class)
+                                .add(org.apache.aries.jmx.test.bundleb.impl.B.class)
+                                .set(Constants.BUNDLE_SYMBOLICNAME,"org.apache.aries.jmx.test.bundleb")
+                                .set(Constants.BUNDLE_VERSION, "1.0.0")
+                                .set(Constants.EXPORT_PACKAGE,"org.apache.aries.jmx.test.bundleb.api;version=1.1.0")
+                                .set(Constants.IMPORT_PACKAGE,"org.osgi.framework;version=1.5.0,org.osgi.util.tracker," +
+                                		"org.osgi.service.cm,org.apache.aries.jmx.test.fragmentc")
+                                .set(Constants.BUNDLE_ACTIVATOR,
+                                        org.apache.aries.jmx.test.bundleb.Activator.class.getName())
+                                .build(withBnd())),
+                        provision(newBundle()
+                                .add(org.apache.aries.jmx.test.fragmentc.C.class)
+                                .set(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.fragc")
+                                .set(Constants.FRAGMENT_HOST, "org.apache.aries.jmx.test.bundlea")
+                                .set(Constants.EXPORT_PACKAGE, "org.apache.aries.jmx.test.fragmentc")
+                                .build(withBnd())),
+                        provision(newBundle()
+                                .set(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundled")
+                                .set(Constants.BUNDLE_VERSION, "3.0.0")
+                                .set(Constants.REQUIRE_BUNDLE, "org.apache.aries.jmx.test.bundlea;bundle-version=2.0.0")
+                                .build(withBnd()))
+                        );
+    }
+
+    @Override
+    public void doSetUp() throws Exception {
+        waitForMBean(new ObjectName(BundleStateMBean.OBJECTNAME));
+    }
+
+    @Test
+    public void testMBeanInterface() throws Exception {
+
+        BundleStateMBean mbean = getMBean(OBJECTNAME, BundleStateMBean.class);
+        assertNotNull(mbean);
+
+        //get bundles
+
+        Bundle a = context().getBundleByName("org.apache.aries.jmx.test.bundlea");
+        assertNotNull(a);
+
+        Bundle b = context().getBundleByName("org.apache.aries.jmx.test.bundleb");
+        assertNotNull(b);
+
+        Bundle frag = context().getBundleByName("org.apache.aries.jmx.test.fragc");
+        assertNotNull(frag);
+
+        Bundle d = context().getBundleByName("org.apache.aries.jmx.test.bundled");
+        assertNotNull(d);
+
+        // exportedPackages
+
+        String[] exports = mbean.getExportedPackages(a.getBundleId());
+        assertEquals(2, exports.length);
+
+        List<String> packages = Arrays.asList(exports);
+        assertTrue(packages.contains("org.apache.aries.jmx.test.bundlea.api;2.0.0"));
+        assertTrue(packages.contains("org.apache.aries.jmx.test.fragmentc;0.0.0"));
+
+        //fragments
+
+        long[] fragments = mbean.getFragments(a.getBundleId());
+        assertEquals(1, fragments.length);
+        assertEquals(frag.getBundleId() , fragments[0]);
+
+        //headers
+
+        TabularData headers = mbean.getHeaders(b.getBundleId());
+        assertNotNull(headers);
+        assertEquals(BundleStateMBean.HEADERS_TYPE, headers.getTabularType());
+        assertTrue(headers.values().size() >= 4 );
+        assertEquals("org.apache.aries.jmx.test.bundleb", Header.from(headers.get(new Object[] {Constants.BUNDLE_SYMBOLICNAME})).getValue());
+
+        //hosts
+
+        long[] hosts = mbean.getHosts(frag.getBundleId());
+        assertEquals(1, hosts.length);
+        assertEquals(a.getBundleId() , hosts[0]);
+
+        //imported packages
+
+        String[] imports = mbean.getImportedPackages(a.getBundleId());
+        assertTrue(imports.length >= 3);
+        List<String> importedPackages = Arrays.asList(imports);
+
+        Version version = getPackageVersion("org.osgi.framework");
+        assertTrue(importedPackages.contains("org.osgi.framework;" + version.toString()));
+        assertTrue(importedPackages.contains("org.apache.aries.jmx.test.bundleb.api;1.1.0"));
+
+        //last modified
+
+        assertTrue(mbean.getLastModified(b.getBundleId()) > 0);
+
+        //location
+
+        assertEquals(b.getLocation(), mbean.getLocation(b.getBundleId()));
+
+        //registered services
+
+        long[] serviceIds = mbean.getRegisteredServices(a.getBundleId());
+        assertEquals(1, serviceIds.length);
+
+        //required bundles
+
+        long[] required = mbean.getRequiredBundles(d.getBundleId());
+        assertEquals(1, required.length);
+        assertEquals(a.getBundleId(), required[0]);
+
+        //requiring bundles
+
+        long[] requiring = mbean.getRequiringBundles(a.getBundleId());
+        assertEquals(3, requiring.length);
+        assertTrue(b.getSymbolicName(), arrayContains(b.getBundleId(), requiring));
+        assertTrue(frag.getSymbolicName(), arrayContains(frag.getBundleId(), requiring));
+        assertTrue(d.getSymbolicName(), arrayContains(d.getBundleId(), requiring));
+
+        //services in use
+
+        long[] servicesInUse = mbean.getServicesInUse(a.getBundleId());
+        assertEquals(1, servicesInUse.length);
+
+        //start level
+
+        long startLevel = mbean.getStartLevel(b.getBundleId());
+        assertTrue(startLevel >= 0);
+
+        //state
+
+        assertEquals("ACTIVE", mbean.getState(b.getBundleId()));
+
+        //isFragment
+
+        assertFalse(mbean.isFragment(b.getBundleId()));
+        assertTrue(mbean.isFragment(frag.getBundleId()));
+
+        //isRemovalPending
+        assertFalse(mbean.isRemovalPending(b.getBundleId()));
+
+        // isRequired
+
+        assertTrue(mbean.isRequired(a.getBundleId()));
+        assertTrue(mbean.isRequired(b.getBundleId()));
+
+        // listBundles
+
+        TabularData bundlesTable = mbean.listBundles();
+        assertNotNull(bundlesTable);
+        assertEquals(BundleStateMBean.BUNDLES_TYPE, bundlesTable.getTabularType());
+        assertEquals(bundleContext.getBundles().length, bundlesTable.values().size());
+
+
+        // notifications
+
+        final List<Notification> received = new ArrayList<Notification>();
+
+        mbeanServer.addNotificationListener(new ObjectName(BundleStateMBean.OBJECTNAME), new NotificationListener() {
+            public void handleNotification(Notification notification, Object handback) {
+               received.add(notification);
+            }
+        }, null, null);
+
+        assertEquals(Bundle.ACTIVE, b.getState());
+        b.stop();
+        assertEquals(Bundle.RESOLVED, b.getState());
+        b.start();
+        assertEquals(Bundle.ACTIVE, b.getState());
+
+        int i = 0;
+        while (received.size() < 2 && i < 3) {
+            Thread.sleep(1000);
+            i++;
+        }
+
+        assertEquals(2, received.size());
+
+    }
+
+    private Version getPackageVersion(String packageName) {
+        ServiceReference paRef = context().getServiceReference(PackageAdmin.class.getName());
+        PackageAdmin pa = (PackageAdmin) context().getService(paRef);
+        ExportedPackage pkg = pa.getExportedPackage(packageName);
+        Version version = pkg.getVersion();
+        return version;
+    }
+
+    private static boolean arrayContains(long value, long[] values) {
+        for (long i : values) {
+            if (i == value) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/BundleStateMBeanWhiteboardTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/BundleStateMBeanWhiteboardTest.java
index 56d8ebfd..17c23fc0 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/BundleStateMBeanWhiteboardTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/BundleStateMBeanWhiteboardTest.java
@@ -1,2 +1,48 @@
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import org.apache.aries.itest.ExtraOptions;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.ops4j.pax.exam.options.MavenArtifactProvisionOption;
+
+public class BundleStateMBeanWhiteboardTest extends BundleStateMBeanTest
+{
+  @Configuration
+  public static Option[] configuration() {
+    Option[] options = BundleStateMBeanTest.configuration();
+    
+    for (int i = 0; i < options.length; i++)
+    {
+      if (options[i] instanceof MavenArtifactProvisionOption) {
+        MavenArtifactProvisionOption po = (MavenArtifactProvisionOption) options[i];
+        String url = po.getURL();
+        if (url.contains("mvn:org.apache.aries.jmx/org.apache.aries.jmx/")) {
+          options[i] = ExtraOptions.mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.core.whiteboard");
+        }
+      }
+    }
+    
+    return options;
+  }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/FrameworkMBeanTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/FrameworkMBeanTest.java
index 56d8ebfd..61e5bd68 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/FrameworkMBeanTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/FrameworkMBeanTest.java
@@ -1,2 +1,109 @@
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import static org.apache.aries.itest.ExtraOptions.mavenBundle;
+import static org.apache.aries.itest.ExtraOptions.paxLogging;
+import static org.apache.aries.itest.ExtraOptions.testOptions;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.jar.JarOutputStream;
+import java.util.jar.Manifest;
+
+import javax.management.ObjectName;
+import javax.management.openmbean.CompositeData;
+
+import org.apache.aries.jmx.AbstractIntegrationTest;
+import org.apache.aries.jmx.codec.BatchActionResult;
+import org.junit.Test;
+import org.ops4j.pax.exam.CoreOptions;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.osgi.jmx.framework.FrameworkMBean;
+
+/**
+ * @version $Rev$ $Date$
+ */
+public class FrameworkMBeanTest extends AbstractIntegrationTest {
+
+    @Configuration
+    public static Option[] configuration() {
+        return testOptions(
+            PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),
+            CoreOptions.equinox().version("3.7.0.v20110613"),
+            paxLogging("INFO"),
+
+            mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx"),
+            mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.api"),
+            mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.whiteboard"),
+            mavenBundle("org.apache.aries", "org.apache.aries.util")
+        );
+    }
+
+    @Override
+    public void doSetUp() throws Exception {
+        waitForMBean(new ObjectName(FrameworkMBean.OBJECTNAME));
+    }
+
+    @Test
+    public void testMBeanInterface() throws IOException {
+        FrameworkMBean framework = getMBean(FrameworkMBean.OBJECTNAME, FrameworkMBean.class);
+        assertNotNull(framework);
+
+        long[] bundleIds = new long[]{1,2};
+        int[] newlevels = new int[]{1,1};
+        CompositeData compData = framework.setBundleStartLevels(bundleIds, newlevels);
+        assertNotNull(compData);
+
+        BatchActionResult batch2 = BatchActionResult.from(compData);
+        assertNotNull(batch2.getCompleted());
+        assertTrue(batch2.isSuccess());
+        assertNull(batch2.getError());
+        assertNull(batch2.getRemainingItems());
+
+        File file = File.createTempFile("bundletest", ".jar");
+        file.deleteOnExit();
+        Manifest man = new Manifest();
+        man.getMainAttributes().putValue("Manifest-Version", "1.0");
+        JarOutputStream jaros = new JarOutputStream(new FileOutputStream(file), man);
+        jaros.flush();
+        jaros.close();
+
+        long bundleId = 0;
+        try {
+            bundleId = framework.installBundleFromURL(file.getAbsolutePath(), file.toURI().toString());
+        } catch (Exception e) {
+            fail("Installation of test bundle shouldn't fail");
+        }
+
+        try{
+            framework.uninstallBundle(bundleId);
+        } catch (Exception e) {
+            fail("Uninstallation of test bundle shouldn't fail");
+        }
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/FrameworkMBeanWhiteboardTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/FrameworkMBeanWhiteboardTest.java
index 17c97dcc..b4271ca1 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/FrameworkMBeanWhiteboardTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/FrameworkMBeanWhiteboardTest.java
@@ -1 +1,47 @@
   + text/plain
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import org.apache.aries.itest.ExtraOptions;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.ops4j.pax.exam.options.MavenArtifactProvisionOption;
+
+public class FrameworkMBeanWhiteboardTest extends FrameworkMBeanTest
+{
+  @Configuration
+  public static Option[] configuration() {
+    Option[] options = FrameworkMBeanTest.configuration();
+    
+    for (int i = 0; i < options.length; i++)
+    {
+      if (options[i] instanceof MavenArtifactProvisionOption) {
+        MavenArtifactProvisionOption po = (MavenArtifactProvisionOption) options[i];
+        String url = po.getURL();
+        if (url.contains("mvn:org.apache.aries.jmx/org.apache.aries.jmx/")) {
+          options[i] = ExtraOptions.mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.core.whiteboard");
+        }
+      }
+    }
+    
+    return options;
+  }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/PackageStateMBeanTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/PackageStateMBeanTest.java
index e69de29b..997ea935 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/PackageStateMBeanTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/PackageStateMBeanTest.java
@@ -0,0 +1,93 @@
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import static org.apache.aries.itest.ExtraOptions.mavenBundle;
+import static org.apache.aries.itest.ExtraOptions.paxLogging;
+import static org.apache.aries.itest.ExtraOptions.testOptions;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import java.io.IOException;
+import java.util.Collection;
+
+import javax.management.ObjectName;
+import javax.management.openmbean.TabularData;
+
+import org.apache.aries.jmx.AbstractIntegrationTest;
+import org.junit.Test;
+import org.ops4j.pax.exam.CoreOptions;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.osgi.jmx.framework.PackageStateMBean;
+
+/**
+ *
+ *
+ * @version $Rev$ $Date$
+ */
+public class PackageStateMBeanTest extends AbstractIntegrationTest {
+
+    @Configuration
+    public static Option[] configuration() {
+        return testOptions(
+            PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),
+            CoreOptions.equinox().version("3.7.0.v20110613"),
+            paxLogging("INFO"),
+            mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx"),
+            mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.api"),
+            mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.whiteboard"),
+            mavenBundle("org.apache.aries", "org.apache.aries.util"));
+    }
+
+    @Override
+    public void doSetUp() throws Exception {
+        waitForMBean(new ObjectName(PackageStateMBean.OBJECTNAME));
+    }
+
+    @Test
+    public void testMBeanInterface() throws IOException {
+        PackageStateMBean packagaState = getMBean(PackageStateMBean.OBJECTNAME, PackageStateMBean.class);
+        assertNotNull(packagaState);
+
+        long[] exportingBundles = packagaState.getExportingBundles("org.osgi.jmx.framework", "1.5.0");
+        assertNotNull(exportingBundles);
+        assertTrue("Should find a bundle exporting org.osgi.jmx.framework", exportingBundles.length > 0);
+
+        long[] exportingBundles2 = packagaState.getExportingBundles("test", "1.0.0");
+        assertNull("Shouldn't find a bundle exporting test package", exportingBundles2);
+
+        long[] importingBundlesId = packagaState
+                .getImportingBundles("org.osgi.jmx.framework", "1.5.0", exportingBundles[0]);
+        assertTrue("Should find bundles importing org.osgi.jmx.framework", importingBundlesId.length > 0);
+
+        TabularData table = packagaState.listPackages();
+        assertNotNull("TabularData containing CompositeData with packages info shouldn't be null", table);
+        assertEquals("TabularData should be a type PACKAGES", PackageStateMBean.PACKAGES_TYPE, table.getTabularType());
+        Collection colData = table.values();
+        assertNotNull("Collection of CompositeData shouldn't be null", colData);
+        assertFalse("Collection of CompositeData should contain elements", colData.isEmpty());
+
+        boolean isRemovalPending = packagaState.isRemovalPending("org.osgi.jmx.framework", "1.5.0", exportingBundles[0]);
+        assertFalse("Should removal pending on org.osgi.jmx.framework be false", isRemovalPending);
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/PackageStateMBeanWhiteboardTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/PackageStateMBeanWhiteboardTest.java
index 17c97dcc..18b8aa87 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/PackageStateMBeanWhiteboardTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/PackageStateMBeanWhiteboardTest.java
@@ -1 +1,47 @@
   + text/plain
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import org.apache.aries.itest.ExtraOptions;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.ops4j.pax.exam.options.MavenArtifactProvisionOption;
+
+public class PackageStateMBeanWhiteboardTest extends PackageStateMBeanTest
+{
+  @Configuration
+  public static Option[] configuration() {
+    Option[] options = PackageStateMBeanTest.configuration();
+    
+    for (int i = 0; i < options.length; i++)
+    {
+      if (options[i] instanceof MavenArtifactProvisionOption) {
+        MavenArtifactProvisionOption po = (MavenArtifactProvisionOption) options[i];
+        String url = po.getURL();
+        if (url.contains("mvn:org.apache.aries.jmx/org.apache.aries.jmx/")) {
+          options[i] = ExtraOptions.mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.core.whiteboard");
+        }
+      }
+    }
+    
+    return options;
+  }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/ServiceStateMBeanTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/ServiceStateMBeanTest.java
index b56de2e8..17320253 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/ServiceStateMBeanTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/ServiceStateMBeanTest.java
@@ -1,3 +1,228 @@
   + text/plain
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import static org.apache.aries.itest.ExtraOptions.mavenBundle;
+import static org.apache.aries.itest.ExtraOptions.paxLogging;
+import static org.apache.aries.itest.ExtraOptions.testOptions;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.ops4j.pax.exam.CoreOptions.provision;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.modifyBundle;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.newBundle;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.withBnd;
+
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import javax.management.Notification;
+import javax.management.NotificationListener;
+import javax.management.ObjectName;
+import javax.management.openmbean.TabularData;
+
+import org.apache.aries.jmx.AbstractIntegrationTest;
+import org.apache.aries.jmx.codec.PropertyData;
+import org.apache.aries.jmx.test.bundlea.api.InterfaceA;
+import org.apache.aries.jmx.test.bundleb.api.InterfaceB;
+import org.junit.Test;
+import org.ops4j.pax.exam.CoreOptions;
+import org.ops4j.pax.exam.Customizer;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.Constants;
+import org.osgi.framework.ServiceReference;
+import org.osgi.jmx.JmxConstants;
+import org.osgi.jmx.framework.ServiceStateMBean;
+import org.osgi.service.cm.ManagedService;
+import org.osgi.service.cm.ManagedServiceFactory;
+
+/**
+ *
+ *
+ * @version $Rev$ $Date$
+ */
+public class ServiceStateMBeanTest extends AbstractIntegrationTest {
+
+    @Configuration
+    public static Option[] configuration() {
+        return testOptions(
+                        PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),
+                        CoreOptions.equinox().version("3.7.0.v20110613"),
+                        paxLogging("INFO"),
+
+                        mavenBundle("org.apache.felix", "org.apache.felix.configadmin"),
+                        mavenBundle("org.osgi", "org.osgi.compendium"),
+                        mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx"),
+                        mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.api"),
+                        mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.whiteboard"),
+                        mavenBundle("org.apache.aries", "org.apache.aries.util"),
+
+                        new Customizer() {
+                            public InputStream customizeTestProbe(InputStream testProbe) throws Exception {
+                                return modifyBundle(testProbe)
+                                           .removeHeader(Constants.DYNAMICIMPORT_PACKAGE)
+                                           .set(Constants.REQUIRE_BUNDLE, "org.apache.aries.jmx.test.bundlea,org.apache.aries.jmx.test.bundleb")
+                                           .build(withBnd());
+                            }
+                        },
+                        provision(newBundle()
+                                .add(org.apache.aries.jmx.test.bundlea.Activator.class)
+                                .add(org.apache.aries.jmx.test.bundlea.api.InterfaceA.class)
+                                .add(org.apache.aries.jmx.test.bundlea.impl.A.class)
+                                .set(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundlea")
+                                .set(Constants.BUNDLE_VERSION, "2.0.0")
+                                .set(Constants.EXPORT_PACKAGE, "org.apache.aries.jmx.test.bundlea.api;version=2.0.0")
+                                .set(Constants.IMPORT_PACKAGE,
+                                        "org.osgi.framework;version=1.5.0,org.osgi.util.tracker,org.apache.aries.jmx.test.bundleb.api;version=1.1.0;resolution:=optional" +
+                                        ",org.osgi.service.cm")
+                                .set(Constants.BUNDLE_ACTIVATOR,
+                                        org.apache.aries.jmx.test.bundlea.Activator.class.getName())
+                                .build(withBnd())),
+                        provision(newBundle()
+                                .add(org.apache.aries.jmx.test.bundleb.Activator.class)
+                                .add(org.apache.aries.jmx.test.bundleb.api.InterfaceB.class)
+                                .add(org.apache.aries.jmx.test.bundleb.api.MSF.class)
+                                .add(org.apache.aries.jmx.test.bundleb.impl.B.class)
+                                .set(Constants.BUNDLE_SYMBOLICNAME,"org.apache.aries.jmx.test.bundleb")
+                                .set(Constants.BUNDLE_VERSION, "1.0.0")
+                                .set(Constants.EXPORT_PACKAGE,"org.apache.aries.jmx.test.bundleb.api;version=1.1.0")
+                                .set(Constants.IMPORT_PACKAGE,"org.osgi.framework;version=1.5.0,org.osgi.util.tracker" +
+                                		",org.osgi.service.cm")
+                                .set(Constants.BUNDLE_ACTIVATOR,
+                                        org.apache.aries.jmx.test.bundleb.Activator.class.getName())
+                                .build(withBnd()))//,
+                                /* For debugging, uncomment the next two lines */
+//                              vmOption("-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=7777"),
+//                              waitForFrameworkStartup()
+                        );
+    }
+
+    @Override
+    public void doSetUp() throws Exception {
+        waitForMBean(new ObjectName(ServiceStateMBean.OBJECTNAME));
+    }
+
+    @Test
+    public void testMBeanInterface() throws Exception {
+
+        ServiceStateMBean mbean = getMBean(ServiceStateMBean.OBJECTNAME, ServiceStateMBean.class);
+        assertNotNull(mbean);
+
+        //get bundles
+
+        Bundle a = context().getBundleByName("org.apache.aries.jmx.test.bundlea");
+        assertNotNull(a);
+
+        Bundle b = context().getBundleByName("org.apache.aries.jmx.test.bundleb");
+        assertNotNull(b);
+
+        // get services
+
+        ServiceReference refA = bundleContext.getServiceReference(InterfaceA.class.getName());
+        assertNotNull(refA);
+        long serviceAId = (Long) refA.getProperty(Constants.SERVICE_ID);
+        assertTrue(serviceAId > -1);
+
+        ServiceReference refB = bundleContext.getServiceReference(InterfaceB.class.getName());
+        assertNotNull(refB);
+        long serviceBId = (Long) refB.getProperty(Constants.SERVICE_ID);
+        assertTrue(serviceBId > -1);
+
+        ServiceReference[] refs = bundleContext.getServiceReferences(ManagedServiceFactory.class.getName(), "(" + Constants.SERVICE_PID + "=jmx.test.B.factory)");
+        assertNotNull(refs);
+        assertEquals(1, refs.length);
+        ServiceReference msf = refs[0];
+
+
+        // getBundleIdentifier
+
+        assertEquals(a.getBundleId(), mbean.getBundleIdentifier(serviceAId));
+
+        //getObjectClass
+
+        String[] objectClass = mbean.getObjectClass(serviceAId);
+        assertEquals(2, objectClass.length);
+        List<String> classNames = Arrays.asList(objectClass);
+        assertTrue(classNames.contains(InterfaceA.class.getName()));
+        assertTrue(classNames.contains(ManagedService.class.getName()));
+
+        // getProperties
+
+        TabularData serviceProperties = mbean.getProperties(serviceBId);
+        assertNotNull(serviceProperties);
+        assertEquals(JmxConstants.PROPERTIES_TYPE, serviceProperties.getTabularType());
+        assertTrue(serviceProperties.values().size() > 1);
+        assertEquals("org.apache.aries.jmx.test.ServiceB",
+                PropertyData.from(serviceProperties.get(new Object[] { Constants.SERVICE_PID })).getValue());
+
+        // getUsingBundles
+
+        long[] usingBundles = mbean.getUsingBundles(serviceBId);
+        assertEquals(1, usingBundles.length);
+        assertEquals(a.getBundleId(), usingBundles[0]);
+
+        // listServices
+
+        TabularData allServices = mbean.listServices();
+        assertNotNull(allServices);
+        assertEquals(bundleContext.getAllServiceReferences(null, null).length, allServices.values().size());
+
+        // notifications
+
+        final List<Notification> received = new ArrayList<Notification>();
+
+        mbeanServer.addNotificationListener(new ObjectName(ServiceStateMBean.OBJECTNAME), new NotificationListener() {
+            public void handleNotification(Notification notification, Object handback) {
+               received.add(notification);
+            }
+        }, null, null);
+
+
+        assertNotNull(refB);
+        assertNotNull(msf);
+        b.stop();
+        refB = bundleContext.getServiceReference(InterfaceB.class.getName());
+        refs = bundleContext.getServiceReferences(ManagedServiceFactory.class.getName(), "(" + Constants.SERVICE_PID + "=jmx.test.B.factory)");
+        assertNull(refs);
+        assertNull(refB);
+        b.start();
+        refB = bundleContext.getServiceReference(InterfaceB.class.getName());
+        refs = bundleContext.getServiceReferences(ManagedServiceFactory.class.getName(), "(" + Constants.SERVICE_PID + "=jmx.test.B.factory)");
+        assertNotNull(refB);
+        assertNotNull(refs);
+        assertEquals(1, refs.length);
+
+        int i = 0;
+        while (received.size() < 4 && i < 3) {
+            Thread.sleep(1000);
+            i++;
+        }
+
+        assertEquals(4, received.size());
+
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/ServiceStateMBeanWhiteboardTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/ServiceStateMBeanWhiteboardTest.java
index a12fd0ee..30e00fb6 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/ServiceStateMBeanWhiteboardTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/framework/ServiceStateMBeanWhiteboardTest.java
@@ -1,2 +1,48 @@
   + native
   + Revision Date
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.framework;
+
+import org.apache.aries.itest.ExtraOptions;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.ops4j.pax.exam.options.MavenArtifactProvisionOption;
+
+public class ServiceStateMBeanWhiteboardTest extends ServiceStateMBeanTest
+{
+  @Configuration
+  public static Option[] configuration() {
+    Option[] options = ServiceStateMBeanTest.configuration();
+    
+    for (int i = 0; i < options.length; i++)
+    {
+      if (options[i] instanceof MavenArtifactProvisionOption) {
+        MavenArtifactProvisionOption po = (MavenArtifactProvisionOption) options[i];
+        String url = po.getURL();
+        if (url.contains("mvn:org.apache.aries.jmx/org.apache.aries.jmx/")) {
+          options[i] = ExtraOptions.mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.core.whiteboard");
+        }
+      }
+    }
+    
+    return options;
+  }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/permissionadmin/PermissionAdminMBeanTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/permissionadmin/PermissionAdminMBeanTest.java
index 17c97dcc..2d8b9f0f 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/permissionadmin/PermissionAdminMBeanTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/permissionadmin/PermissionAdminMBeanTest.java
@@ -1 +1,146 @@
   + text/plain
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.permissionadmin;
+
+import static org.apache.aries.itest.ExtraOptions.mavenBundle;
+import static org.apache.aries.itest.ExtraOptions.paxLogging;
+import static org.apache.aries.itest.ExtraOptions.testOptions;
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.ops4j.pax.exam.CoreOptions.provision;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.newBundle;
+import static org.ops4j.pax.swissbox.tinybundles.core.TinyBundles.withBnd;
+
+import java.io.IOException;
+
+import javax.management.ObjectName;
+
+import org.apache.aries.jmx.AbstractIntegrationTest;
+import org.junit.Test;
+import org.ops4j.pax.exam.CoreOptions;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.Constants;
+import org.osgi.framework.ServiceReference;
+import org.osgi.jmx.service.permissionadmin.PermissionAdminMBean;
+import org.osgi.service.permissionadmin.PermissionAdmin;
+import org.osgi.service.permissionadmin.PermissionInfo;
+
+/**
+ *
+ *
+ * @version $Rev$ $Date$
+ */
+public class PermissionAdminMBeanTest extends AbstractIntegrationTest {
+
+    @Configuration
+    public static Option[] configuration() {
+        return testOptions(
+            PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),
+            CoreOptions.equinox().version("3.7.0.v20110613"),
+            paxLogging("INFO"),
+            mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx"),
+            mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.api"),
+            mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.whiteboard"),
+            mavenBundle("org.apache.aries", "org.apache.aries.util"),
+            provision(newBundle()
+                    .add(org.apache.aries.jmx.test.bundlea.Activator.class)
+                    .add(org.apache.aries.jmx.test.bundlea.api.InterfaceA.class)
+                    .add(org.apache.aries.jmx.test.bundlea.impl.A.class)
+                    .set(Constants.BUNDLE_SYMBOLICNAME, "org.apache.aries.jmx.test.bundlea")
+                    .set(Constants.BUNDLE_VERSION, "2.0.0")
+                    .set(Constants.IMPORT_PACKAGE,
+                            "org.osgi.framework;version=1.5.0,org.osgi.util.tracker,org.apache.aries.jmx.test.bundleb.api;version=1.1.0;resolution:=optional")
+                    .set(Constants.BUNDLE_ACTIVATOR,
+                            org.apache.aries.jmx.test.bundlea.Activator.class.getName())
+                    .build(withBnd()))
+                    /* For debugging, uncomment the next two lines */
+//                     vmOption("-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=7778"),
+//                     waitForFrameworkStartup()
+        );
+    }
+
+    @Override
+    public void doSetUp() throws Exception {
+        waitForMBean(new ObjectName(PermissionAdminMBean.OBJECTNAME));
+    }
+
+    @Test
+    public void testMBeanInterface() throws IOException {
+        PermissionAdminMBean mBean = getMBean(PermissionAdminMBean.OBJECTNAME, PermissionAdminMBean.class);
+        PermissionAdmin permAdminService = getService(PermissionAdmin.class);
+        assertNotNull(permAdminService);
+
+        String[] serviceLocation = permAdminService.getLocations();
+        String[] mBeanLocations = mBean.listLocations();
+        assertArrayEquals(serviceLocation, mBeanLocations);
+
+        PermissionInfo defPerm = new PermissionInfo("AllPermission", "*", "*");
+        permAdminService.setDefaultPermissions(new PermissionInfo[]{defPerm});
+        PermissionInfo[] permissions = permAdminService.getDefaultPermissions();
+        assertNotNull(permissions);
+
+        String[] encoded = toEncodedPerm(permissions);
+        String[] mBeanDefPermissions = mBean.listDefaultPermissions();
+        assertArrayEquals(encoded, mBeanDefPermissions);
+
+        Bundle a = context().getBundleByName("org.apache.aries.jmx.test.bundlea");
+        assertNotNull(a);
+
+        String location = a.getLocation();
+
+        PermissionInfo bundleaPerm = new PermissionInfo("ServicePermission", "ServiceA", "GET");
+        mBean.setPermissions(location, new String[]{bundleaPerm.getEncoded()});
+
+        String[] serviceBundleaPerm = toEncodedPerm(permAdminService.getPermissions(location));
+        String[] mBeanBundleaPerm = mBean.getPermissions(location);
+        assertNotNull(mBeanBundleaPerm);
+        assertArrayEquals(serviceBundleaPerm, mBeanBundleaPerm);
+
+        PermissionInfo defaultPerm = new PermissionInfo("AllPermission", "*", "GET");
+        mBean.setDefaultPermissions(new String[]{defaultPerm.getEncoded()});
+
+        String[] serviceDefaultPerm = toEncodedPerm(permAdminService.getDefaultPermissions());
+        String[] mBeanDefaultPerm = mBean.listDefaultPermissions();
+        assertNotNull(mBeanDefaultPerm);
+        assertArrayEquals(serviceDefaultPerm, mBeanDefaultPerm);
+    }
+
+    private String[] toEncodedPerm(PermissionInfo[] permissions){
+        assertNotNull(permissions);
+        String[] encoded = new String[permissions.length];
+        for (int i = 0; i < permissions.length; i++) {
+            PermissionInfo info = permissions[i];
+            encoded[i] = info.getEncoded();
+        }
+        return encoded;
+    }
+
+    private <S> S getService(Class<S> serviceInterface){
+        ServiceReference ref =  bundleContext.getServiceReference(serviceInterface.getName());
+        if(ref != null){
+            Object service = bundleContext.getService(ref);
+            if(service != null){
+                return (S)service;
+            }
+        }
+        return null;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/permissionadmin/PermissionAdminMBeanWhiteboardTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/permissionadmin/PermissionAdminMBeanWhiteboardTest.java
index 56d8ebfd..449ad5dc 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/permissionadmin/PermissionAdminMBeanWhiteboardTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/permissionadmin/PermissionAdminMBeanWhiteboardTest.java
@@ -1,2 +1,48 @@
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.permissionadmin;
+
+import org.apache.aries.itest.ExtraOptions;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.ops4j.pax.exam.options.MavenArtifactProvisionOption;
+
+public class PermissionAdminMBeanWhiteboardTest extends PermissionAdminMBeanTest
+{
+  @Configuration
+  public static Option[] configuration() {
+    Option[] options = PermissionAdminMBeanTest.configuration();
+    
+    for (int i = 0; i < options.length; i++)
+    {
+      if (options[i] instanceof MavenArtifactProvisionOption) {
+        MavenArtifactProvisionOption po = (MavenArtifactProvisionOption) options[i];
+        String url = po.getURL();
+        if (url.contains("mvn:org.apache.aries.jmx/org.apache.aries.jmx/")) {
+          options[i] = ExtraOptions.mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.core.whiteboard");
+        }
+      }
+    }
+    
+    return options;
+  }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanTest.java
index e69de29b..d47a9407 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanTest.java
@@ -0,0 +1,165 @@
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.provisioning;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.osgi.service.provisioning.ProvisioningService.PROVISIONING_AGENT_CONFIG;
+import static org.osgi.service.provisioning.ProvisioningService.PROVISIONING_REFERENCE;
+
+import static org.apache.aries.itest.ExtraOptions.*;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.util.Dictionary;
+import java.util.jar.JarOutputStream;
+import java.util.jar.Manifest;
+import java.util.zip.ZipEntry;
+
+import javax.management.ObjectName;
+import javax.management.openmbean.TabularData;
+
+import org.apache.aries.jmx.AbstractIntegrationTest;
+import org.apache.aries.jmx.codec.PropertyData;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.ops4j.pax.exam.CoreOptions;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.osgi.jmx.JmxConstants;
+import org.osgi.jmx.service.provisioning.ProvisioningServiceMBean;
+import org.osgi.service.provisioning.ProvisioningService;
+import org.osgi.util.tracker.ServiceTracker;
+
+/**
+ * 
+ * 
+ * @version $Rev$ $Date$
+ */
+public class ProvisioningServiceMBeanTest extends AbstractIntegrationTest {
+
+
+    @Configuration
+    public static Option[] configuration() {
+        return testOptions(
+                        CoreOptions.equinox(),
+                        paxLogging("INFO"),
+                        mavenBundle("org.osgi", "org.osgi.compendium"), 
+                        mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.whiteboard"),
+                        mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx"),
+                        mavenBundle("org.apache.aries", "org.apache.aries.util"));
+    }
+
+    @Override
+    public void doSetUp() throws Exception {
+        waitForMBean(new ObjectName(ProvisioningServiceMBean.OBJECTNAME));
+    }
+
+    @Ignore("For now.. Cannot find public repo for org.eclipse.equinox.ip")
+    @Test
+    @SuppressWarnings("unchecked")
+    public void testMBeanInterface() throws Exception {
+
+        ProvisioningServiceMBean mbean = getMBean(ProvisioningServiceMBean.OBJECTNAME, ProvisioningServiceMBean.class);
+        assertNotNull(mbean);
+        
+        ServiceTracker tracker = new ServiceTracker(bundleContext, ProvisioningService.class.getName(), null);
+        tracker.open();
+        ProvisioningService ps = (ProvisioningService) tracker.getService();
+        assertNotNull(ps);
+        
+        Dictionary<String, Object> info;
+        
+        // add information URL (create temp zip file)
+        
+        File  provZip = File.createTempFile("Prov-jmx-itests", ".zip");
+        Manifest man = new Manifest();
+        man.getMainAttributes().putValue("Manifest-Version", "1.0");
+        man.getMainAttributes().putValue("Content-Type", "application/zip");
+        JarOutputStream jout = new JarOutputStream(new FileOutputStream(provZip), man);
+        ZipEntry entry = new ZipEntry(PROVISIONING_AGENT_CONFIG);
+        jout.putNextEntry( entry );
+        jout.write(new byte[] { 10, 20, 30 });
+        jout.closeEntry();
+        jout.flush();
+        jout.close();
+        
+        provZip.deleteOnExit();
+        
+        mbean.addInformationFromZip(provZip.toURL().toExternalForm());
+        
+        //check the info has been added
+        
+        info = ps.getInformation();
+        assertNotNull(info);
+        assertTrue(info.size() >= 1);
+        byte[] config = (byte[]) info.get(PROVISIONING_AGENT_CONFIG);
+        assertNotNull(config);
+        assertArrayEquals(new byte[] { 10, 20, 30 }, config);
+        
+        
+        // test list information
+        
+        TabularData data = mbean.listInformation();
+        assertNotNull(data);
+        assertEquals(JmxConstants.PROPERTIES_TYPE, data.getTabularType());
+        assertTrue(data.values().size() >= 1);
+        PropertyData<byte[]> configEntry = PropertyData.from(data.get(new Object[] {PROVISIONING_AGENT_CONFIG }));
+        assertNotNull(configEntry);
+        assertArrayEquals(new byte[] { 10, 20, 30 }, configEntry.getValue());
+
+        
+        // test add information
+        
+        PropertyData<String> reference = PropertyData.newInstance(PROVISIONING_REFERENCE, "rsh://0.0.0.0/provX");
+        data.put(reference.toCompositeData());
+        
+        mbean.addInformation(data);
+        
+        info = ps.getInformation();
+        assertNotNull(info);
+        assertTrue(info.size() >= 2);
+        config = (byte[]) info.get(PROVISIONING_AGENT_CONFIG);
+        assertNotNull(config);
+        assertArrayEquals(new byte[] { 10, 20, 30 }, config);
+        String ref = (String) info.get(PROVISIONING_REFERENCE);
+        assertNotNull(ref);
+        assertEquals("rsh://0.0.0.0/provX", ref);
+        
+        
+        // test set information
+        
+        data.clear();
+        PropertyData<String> newRef = PropertyData.newInstance(PROVISIONING_REFERENCE, "rsh://0.0.0.0/newProvRef");
+        data.put(newRef.toCompositeData());
+        
+        mbean.setInformation(data);
+        info = ps.getInformation();
+        assertNotNull(info);
+        assertTrue(info.size() >= 1);
+        assertNull(info.get(PROVISIONING_AGENT_CONFIG));
+       
+        ref = (String) info.get(PROVISIONING_REFERENCE);
+        assertNotNull(ref);
+        assertEquals("rsh://0.0.0.0/newProvRef", ref);
+        
+        
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanWhiteboardTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanWhiteboardTest.java
index 56d8ebfd..687cd3ab 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanWhiteboardTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/provisioning/ProvisioningServiceMBeanWhiteboardTest.java
@@ -1,2 +1,47 @@
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.provisioning;
+
+import org.apache.aries.itest.ExtraOptions;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.ops4j.pax.exam.options.MavenArtifactProvisionOption;
+
+public class ProvisioningServiceMBeanWhiteboardTest extends ProvisioningServiceMBeanTest
+{
+  @Configuration
+  public static Option[] configuration() {
+    Option[] options = ProvisioningServiceMBeanTest.configuration();
+    
+    for (int i = 0; i < options.length; i++)
+    {
+      if (options[i] instanceof MavenArtifactProvisionOption) {
+        MavenArtifactProvisionOption po = (MavenArtifactProvisionOption) options[i];
+        String url = po.getURL();
+        if (url.contains("mvn:org.apache.aries.jmx/org.apache.aries.jmx/")) {
+          options[i] = ExtraOptions.mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.core.whiteboard");
+        }
+      }
+    }
+    
+    return options;
+  }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/BlueprintMBeanTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/BlueprintMBeanTest.java
index 17c97dcc..7f7193eb 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/BlueprintMBeanTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/BlueprintMBeanTest.java
@@ -1 +1,241 @@
   + text/plain
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+import static org.apache.aries.itest.ExtraOptions.*;
+
+import javax.management.MBeanServerInvocationHandler;
+import javax.management.ObjectName;
+import javax.management.openmbean.TabularData;
+
+import org.apache.aries.jmx.AbstractIntegrationTest;
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+import org.apache.aries.jmx.blueprint.BlueprintStateMBean;
+import org.apache.aries.jmx.test.blueprint.framework.BeanPropertyValidator;
+import org.apache.aries.jmx.test.blueprint.framework.BeanValidator;
+import org.apache.aries.jmx.test.blueprint.framework.BlueprintEventValidator;
+import org.apache.aries.jmx.test.blueprint.framework.CollectionValidator;
+import org.apache.aries.jmx.test.blueprint.framework.MapEntryValidator;
+import org.apache.aries.jmx.test.blueprint.framework.RefValidator;
+import org.apache.aries.jmx.test.blueprint.framework.ReferenceListValidator;
+import org.apache.aries.jmx.test.blueprint.framework.ReferenceListenerValidator;
+import org.apache.aries.jmx.test.blueprint.framework.ReferenceValidator;
+import org.apache.aries.jmx.test.blueprint.framework.RegistrationListenerValidator;
+import org.apache.aries.jmx.test.blueprint.framework.ServiceValidator;
+import org.apache.aries.jmx.test.blueprint.framework.ValueValidator;
+import org.junit.Test;
+import org.ops4j.pax.exam.CoreOptions;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.junit.Configuration;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.Constants;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.ServiceReference;
+import org.osgi.service.blueprint.container.BlueprintContainer;
+
+public class BlueprintMBeanTest extends AbstractIntegrationTest {
+    
+    @Configuration
+    public static Option[] configuration() {    
+        return testOptions(
+                CoreOptions.equinox(), 
+                paxLogging("INFO"),
+                
+                mavenBundle("org.apache.felix", "org.apache.felix.configadmin"),
+                mavenBundle("org.apache.aries", "org.apache.aries.util"),
+                mavenBundle("asm", "asm-all"),
+                mavenBundle("org.apache.aries.proxy", "org.apache.aries.proxy"),
+                mavenBundle("org.apache.aries.blueprint", "org.apache.aries.blueprint"), 
+                mavenBundle("org.apache.aries.blueprint", "org.apache.aries.blueprint.sample"), 
+                mavenBundle("org.apache.aries.jmx", "org.apache.aries.jmx.blueprint"),
+                mavenBundle("org.osgi", "org.osgi.compendium")
+        );
+    }  
+
+    @Override
+    public void doSetUp() throws Exception {
+        waitForMBean(new ObjectName(BlueprintStateMBean.OBJECTNAME));
+        waitForMBean(new ObjectName(BlueprintMetadataMBean.OBJECTNAME));
+       
+       // Wait enough time for osgi framework and blueprint bundles to be set up
+       System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Waiting for bundles to be set up");
+       context().getService(BlueprintContainer.class, "(osgi.blueprint.container.symbolicname=org.apache.aries.blueprint)");
+       context().getService(BlueprintContainer.class, "(osgi.blueprint.container.symbolicname=org.apache.aries.blueprint.sample)");
+    }
+    
+    @Test
+    public void BlueprintSample() throws Exception {
+        System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Start Test Blueprint Sample");
+        
+        //////////////////////////////
+        //Test BlueprintStateMBean
+        //////////////////////////////
+        
+        //find the Blueprint Sample bundle id and the blueprint extender bundle id
+        long sampleBundleId = -1;
+        long extenderBundleId = -1;     // the blueprint extender bundle "org.apache.geronimo.blueprint.geronimo-blueprint" is also a blueprint bundle.
+        for (Bundle bundle : bundleContext.getBundles()){
+            if (bundle.getSymbolicName().equals("org.apache.aries.blueprint.sample")) sampleBundleId = bundle.getBundleId();
+            if (bundle.getSymbolicName().equals("org.apache.aries.blueprint")) extenderBundleId = bundle.getBundleId();
+        }
+        if (-1==sampleBundleId) fail("Blueprint Sample Bundle is not found!");
+        if (-1==extenderBundleId) fail("Blueprint Extender Bundle is not found!");
+        
+        //retrieve the proxy object
+        BlueprintStateMBean stateProxy = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, new ObjectName(BlueprintStateMBean.OBJECTNAME), BlueprintStateMBean.class, false);
+        
+        // test getBlueprintBundleIds
+        long[] bpBundleIds = stateProxy.getBlueprintBundleIds();
+        assertEquals(2, bpBundleIds.length);
+        // test getLastEvent
+        BlueprintEventValidator sampleValidator = new BlueprintEventValidator(sampleBundleId, extenderBundleId, 2);
+        sampleValidator.validate(stateProxy.getLastEvent(sampleBundleId));
+        // test getLastEvents
+        TabularData lastEvents = stateProxy.getLastEvents();
+        assertEquals(BlueprintStateMBean.OSGI_BLUEPRINT_EVENTS_TYPE,lastEvents.getTabularType());
+        sampleValidator.validate(lastEvents.get(new Long[]{sampleBundleId}));
+        
+        //////////////////////////////
+        //Test BlueprintMetadataMBean
+        //////////////////////////////
+        
+        //find the Blueprint Sample bundle's container service id
+        Bundle sampleBundle = bundleContext.getBundle(sampleBundleId);
+        String filter = "(&(osgi.blueprint.container.symbolicname=" // no similar one in interfaces
+                + sampleBundle.getSymbolicName() + ")(osgi.blueprint.container.version=" + sampleBundle.getVersion() + "))";
+        ServiceReference[] serviceReferences = null;
+        try {
+            serviceReferences = bundleContext.getServiceReferences(BlueprintContainer.class.getName(), filter);
+        } catch (InvalidSyntaxException e) {
+            throw new RuntimeException(e);
+        }
+        long sampleBlueprintContainerServiceId = (Long) serviceReferences[0].getProperty(Constants.SERVICE_ID);
+        
+        //retrieve the proxy object
+        BlueprintMetadataMBean metadataProxy = MBeanServerInvocationHandler.newProxyInstance(mbeanServer, new ObjectName(BlueprintMetadataMBean.OBJECTNAME), BlueprintMetadataMBean.class, false);
+        
+        // test getBlueprintContainerServiceIds
+        long[] bpContainerServiceIds = metadataProxy.getBlueprintContainerServiceIds();
+        assertEquals(2, bpContainerServiceIds.length);
+        
+        // test getBlueprintContainerServiceId
+        assertEquals(sampleBlueprintContainerServiceId, metadataProxy.getBlueprintContainerServiceId(sampleBundleId));
+        
+        // test getComponentMetadata
+        // bean: foo
+        BeanValidator bv_foo = new BeanValidator("org.apache.aries.blueprint.sample.Foo", "init", "destroy");
+        
+        BeanPropertyValidator bpv_a = new BeanPropertyValidator("a");
+        bpv_a.setObjectValueValidator(new ValueValidator("5"));
+        
+        BeanPropertyValidator bpv_b = new BeanPropertyValidator("b");
+        bpv_b.setObjectValueValidator(new ValueValidator("-1"));
+        
+        BeanPropertyValidator bpv_bar = new BeanPropertyValidator("bar");
+        bpv_bar.setObjectValueValidator(new RefValidator("bar"));
+        
+        BeanPropertyValidator bpv_currency = new BeanPropertyValidator("currency");
+        bpv_currency.setObjectValueValidator(new ValueValidator("PLN"));
+        
+        BeanPropertyValidator bpv_date = new BeanPropertyValidator("date");
+        bpv_date.setObjectValueValidator(new ValueValidator("2009.04.17"));
+        
+        bv_foo.addPropertyValidators(bpv_a, bpv_b, bpv_bar, bpv_currency, bpv_date);
+        bv_foo.validate(metadataProxy.getComponentMetadata(sampleBlueprintContainerServiceId, "foo"));
+        
+        // bean: bar
+        BeanPropertyValidator bpv_value = new BeanPropertyValidator("value");
+        bpv_value.setObjectValueValidator(new ValueValidator("Hello FooBar"));
+        
+        BeanPropertyValidator bpv_context = new BeanPropertyValidator("context");
+        bpv_context.setObjectValueValidator(new RefValidator("blueprintBundleContext"));
+        
+        CollectionValidator cv = new CollectionValidator("java.util.List");
+        cv.addCollectionValueValidators(new ValueValidator("a list element"), new ValueValidator("5", "java.lang.Integer"));
+        BeanPropertyValidator bpv_list = new BeanPropertyValidator("list");
+        bpv_list.setObjectValueValidator(cv);
+        
+        BeanValidator bv_bar = new BeanValidator("org.apache.aries.blueprint.sample.Bar");
+        bv_bar.addPropertyValidators(bpv_value, bpv_context, bpv_list);
+        bv_bar.validate(metadataProxy.getComponentMetadata(sampleBlueprintContainerServiceId, "bar"));
+        
+        // service: ref=foo, no componentId set. So using it to test getComponentIdsByType.
+        String[] serviceComponentIds = metadataProxy.getComponentIdsByType(sampleBlueprintContainerServiceId, BlueprintMetadataMBean.SERVICE_METADATA);
+        assertEquals("There should be two service components in this sample", 2, serviceComponentIds.length);
+        
+        MapEntryValidator mev = new MapEntryValidator();
+        mev.setKeyValueValidator(new ValueValidator("key"), new ValueValidator("value"));
+        
+        RegistrationListenerValidator rglrv = new RegistrationListenerValidator("serviceRegistered", "serviceUnregistered");
+        rglrv.setListenerComponentValidator(new RefValidator("fooRegistrationListener"));
+        
+        ServiceValidator sv = new ServiceValidator(4);
+        sv.setServiceComponentValidator(new RefValidator("foo"));
+        sv.addMapEntryValidator(mev);
+        sv.addRegistrationListenerValidator(rglrv);
+        sv.validate(metadataProxy.getComponentMetadata(sampleBlueprintContainerServiceId, serviceComponentIds[0]));
+        
+        // bean: fooRegistrationListener
+        BeanValidator bv_fooRegistrationListener = new BeanValidator("org.apache.aries.blueprint.sample.FooRegistrationListener");
+        bv_fooRegistrationListener.validate(metadataProxy.getComponentMetadata(sampleBlueprintContainerServiceId, "fooRegistrationListener"));
+        
+        // reference: ref2
+        ReferenceListenerValidator rlrv_1 = new ReferenceListenerValidator("bind", "unbind");
+        rlrv_1.setListenerComponentValidator(new RefValidator("bindingListener"));
+        
+        ReferenceValidator rv = new ReferenceValidator("org.apache.aries.blueprint.sample.InterfaceA", 100);
+        rv.addReferenceListenerValidator(rlrv_1);
+        rv.validate(metadataProxy.getComponentMetadata(sampleBlueprintContainerServiceId, "ref2"));
+        
+        // bean: bindingListener
+        BeanValidator bv_bindingListener = new BeanValidator("org.apache.aries.blueprint.sample.BindingListener");
+        bv_bindingListener.validate(metadataProxy.getComponentMetadata(sampleBlueprintContainerServiceId, "bindingListener"));
+
+        // reference-list: ref-list
+        ReferenceListenerValidator rlrv_2 = new ReferenceListenerValidator("bind", "unbind");
+        rlrv_2.setListenerComponentValidator(new RefValidator("listBindingListener"));
+        
+        ReferenceListValidator rlv_ref_list = new ReferenceListValidator("org.apache.aries.blueprint.sample.InterfaceA");
+        rlv_ref_list.addReferenceListenerValidator(rlrv_2);
+        rlv_ref_list.validate(metadataProxy.getComponentMetadata(sampleBlueprintContainerServiceId, "ref-list"));
+        
+        // bean: listBindingListener
+        BeanValidator bv_listBindingListener = new BeanValidator("org.apache.aries.blueprint.sample.BindingListener");
+        bv_listBindingListener.validate(metadataProxy.getComponentMetadata(sampleBlueprintContainerServiceId, "listBindingListener"));
+                
+        // bean: circularReference
+        ReferenceListenerValidator rlrv_3 = new ReferenceListenerValidator("bind", "unbind");
+        rlrv_3.setListenerComponentValidator(new RefValidator("circularReference"));
+        
+        ReferenceListValidator rlv_2 = new ReferenceListValidator("org.apache.aries.blueprint.sample.InterfaceA", 2);
+        rlv_2.addReferenceListenerValidator(rlrv_3);
+        
+        BeanPropertyValidator bpv_list_2 = new BeanPropertyValidator("list");
+        bpv_list_2.setObjectValueValidator(rlv_2);
+        
+        BeanValidator bv_circularReference = new BeanValidator("org.apache.aries.blueprint.sample.BindingListener", "init");
+        bv_circularReference.addPropertyValidators(bpv_list_2);
+        bv_circularReference.validate(metadataProxy.getComponentMetadata(sampleBlueprintContainerServiceId, "circularReference"));
+    }
+            
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractArgumentPropertyValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractArgumentPropertyValidator.java
index b56de2e8..df1096e9 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractArgumentPropertyValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractArgumentPropertyValidator.java
@@ -1,3 +1,51 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeType;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+
+abstract class AbstractArgumentPropertyValidator extends AbstractCompositeDataValidator {
+    // if not set, means do not care about the value
+    private ObjectValueValidator objectValueValidator = null;
+    
+    public AbstractArgumentPropertyValidator(CompositeType type){
+        super(type);
+    }
+    
+    public void setObjectValueValidator(ObjectValueValidator objectValueValidator){
+        this.objectValueValidator = objectValueValidator;
+    }
+    
+    public void validate(CompositeData target){
+        super.validate(target);
+        
+        if (objectValueValidator != null){
+            Byte[] byteArrayValue = (Byte[])target.get(BlueprintMetadataMBean.VALUE);
+            CompositeData value = Util.decode(byteArrayValue);
+            
+            objectValueValidator.validate(value);
+        }
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractCompositeDataValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractCompositeDataValidator.java
index b56de2e8..0c5de6ac 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractCompositeDataValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractCompositeDataValidator.java
@@ -1,3 +1,61 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeType;
+
+abstract public class AbstractCompositeDataValidator {
+        
+        private CompositeType type;
+        private Map<String, Object> expectValues;
+                
+        protected AbstractCompositeDataValidator(CompositeType type){
+            this.type = type;
+            expectValues = new HashMap<String, Object>();
+        }
+                
+        void setExpectValue(String key, Object value){
+            expectValues.put(key, value);
+        }
+        
+        public void validate(CompositeData target){
+            if (!type.equals(target.getCompositeType()))
+                fail("Expect type is " + type + ", but target type is " +target.getCompositeType());
+            Set<String> keys = expectValues.keySet();
+            Iterator<String> it = keys.iterator();
+            while (it.hasNext()) {
+                String key = it.next();
+                assertEquals(expectValues.get(key), target.get(key));
+            }
+            
+        }
+        
+    }
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractListenerComponentValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractListenerComponentValidator.java
index 1f8bddab..01473340 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractListenerComponentValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractListenerComponentValidator.java
@@ -1,3 +1,49 @@
   + native
   + text/plain
   + Revision Date
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import static junit.framework.Assert.assertNotNull;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeType;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+
+abstract class AbstractListenerComponentValidator extends AbstractCompositeDataValidator {
+    
+    // a TargetValidator can be one of BeanValidator, ReferenceValidator, RefValidator
+    TargetValidator listenerComponentValidator = null;
+    
+    protected AbstractListenerComponentValidator(CompositeType type){
+        super(type);
+    }
+    
+    public void setListenerComponentValidator(TargetValidator targetValidator){
+        this.listenerComponentValidator = targetValidator;
+    }
+    
+    public void validate(CompositeData target){
+        super.validate(target);
+        assertNotNull("This Validator must have a TargetValidator to validate listener component", listenerComponentValidator);
+        listenerComponentValidator.validate(Util.decode((Byte[])target.get(BlueprintMetadataMBean.LISTENER_COMPONENT)));
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractServiceReferenceValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractServiceReferenceValidator.java
index 6dc540c5..4c20c9e6 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractServiceReferenceValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/AbstractServiceReferenceValidator.java
@@ -1,3 +1,57 @@
   + Revision Date
   + native
   + text/plain
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import static org.junit.Assert.fail;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.management.openmbean.CompositeData;
+import javax.management.openmbean.CompositeType;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+
+abstract class AbstractServiceReferenceValidator extends AbstractCompositeDataValidator implements NonNullObjectValueValidator {
+    private List<ReferenceListenerValidator> referenceListenerValidators = new ArrayList<ReferenceListenerValidator>();
+    
+    protected AbstractServiceReferenceValidator(CompositeType type) {
+        super(type);
+    }
+    
+    public void addReferenceListenerValidator(ReferenceListenerValidator... validators){
+        for (ReferenceListenerValidator validator : validators)
+            this.referenceListenerValidators.add(validator);
+    }
+    
+    public void validate(CompositeData target){
+        super.validate(target);
+        if (referenceListenerValidators.size() != 0){
+            CompositeData[] referenceListeners = (CompositeData[])target.get(BlueprintMetadataMBean.REFERENCE_LISTENERS);
+            if ( referenceListenerValidators.size() != referenceListeners.length )
+                fail("The quantity of the listeners is not the same, expect " +referenceListenerValidators.size()+" but got "+ referenceListeners.length);
+            for (int i=0; i<referenceListenerValidators.size(); i++)
+                referenceListenerValidators.get(i).validate(referenceListeners[i]);
+        }
+    }
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BeanArgumentValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BeanArgumentValidator.java
index b56de2e8..6a75f6aa 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BeanArgumentValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BeanArgumentValidator.java
@@ -1,3 +1,34 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+
+public class BeanArgumentValidator extends AbstractArgumentPropertyValidator{
+    
+    public BeanArgumentValidator(int index, String valueType){
+        super(BlueprintMetadataMBean.BEAN_ARGUMENT_TYPE);
+        setExpectValue(BlueprintMetadataMBean.INDEX, index);
+        setExpectValue(BlueprintMetadataMBean.VALUE_TYPE, valueType);
+    }
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BeanPropertyValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BeanPropertyValidator.java
index b56de2e8..741e3a5c 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BeanPropertyValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BeanPropertyValidator.java
@@ -1,3 +1,33 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+
+public class BeanPropertyValidator extends AbstractArgumentPropertyValidator{
+    
+    public BeanPropertyValidator(String name){
+        super(BlueprintMetadataMBean.BEAN_PROPERTY_TYPE);
+        setExpectValue(BlueprintMetadataMBean.NAME, name);            
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BeanValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BeanValidator.java
index b56de2e8..87ddf800 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BeanValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BeanValidator.java
@@ -1,3 +1,104 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.management.openmbean.CompositeData;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+
+
+public class BeanValidator extends AbstractCompositeDataValidator implements NonNullObjectValueValidator, TargetValidator{
+    
+    private boolean validateArgumentsFlag = true;
+    private List<BeanArgumentValidator> beanArgumentValidators = new ArrayList<BeanArgumentValidator>();
+    private boolean validatePropertiesFlag = true;
+    private List<BeanPropertyValidator> beanPropertyValidators = new ArrayList<BeanPropertyValidator>();
+    
+    public BeanValidator(String className){
+        super(BlueprintMetadataMBean.BEAN_METADATA_TYPE);
+        setExpectValue(BlueprintMetadataMBean.CLASS_NAME, className);
+    }
+    
+    public BeanValidator(String className, String initMethod){
+        super(BlueprintMetadataMBean.BEAN_METADATA_TYPE);
+        setExpectValue(BlueprintMetadataMBean.CLASS_NAME, className);
+        setExpectValue(BlueprintMetadataMBean.INIT_METHOD, initMethod);
+    }
+    
+    public BeanValidator(String className, String initMethod, String destroyMethod){
+        super(BlueprintMetadataMBean.BEAN_METADATA_TYPE);
+        setExpectValue(BlueprintMetadataMBean.CLASS_NAME, className);
+        setExpectValue(BlueprintMetadataMBean.INIT_METHOD, initMethod);
+        setExpectValue(BlueprintMetadataMBean.DESTROY_METHOD, destroyMethod);
+    }
+    
+    public void setValidateArgumentsFlag(boolean flag){
+        validateArgumentsFlag = flag;
+    }
+    
+    public void addArgumentValidators(BeanArgumentValidator... validators){
+        for (BeanArgumentValidator beanArgumentValidator : validators)
+            beanArgumentValidators.add(beanArgumentValidator);
+    }
+    
+    public void setValidatePropertiesFlag(boolean flag){
+        validatePropertiesFlag = flag;
+    }
+            
+    public void addPropertyValidators(BeanPropertyValidator... validators){
+        for (BeanPropertyValidator beanPropertyValidator : validators)
+            beanPropertyValidators.add(beanPropertyValidator);
+    }
+    
+    public void validate(CompositeData target){
+        super.validate(target);
+        
+        //Validate args
+        if (validateArgumentsFlag){
+            CompositeData[] args = (CompositeData[])target.get(BlueprintMetadataMBean.ARGUMENTS);  
+            assertNotNull(args); // at least CompositeData[0]
+            assertEquals("The size of arguments is not equals, expect " + beanArgumentValidators.size() + " but got " + args.length, 
+                    beanArgumentValidators.size(), args.length);
+            for (int i=0; i<beanArgumentValidators.size(); i++) // the order of the arg validators should be the same with the args
+                beanArgumentValidators.get(i).validate(args[i]);
+        }
+        
+        //Validate props
+        if (validatePropertiesFlag){
+            CompositeData[] props = (CompositeData[])target.get(BlueprintMetadataMBean.PROPERTIES);
+            assertNotNull(props);
+            assertEquals("The size of properties is not equals, expect " + beanPropertyValidators.size() + " but got " + props.length, 
+                    beanPropertyValidators.size(), props.length);
+            for (int i=0; i<beanPropertyValidators.size(); i++)
+                beanPropertyValidators.get(i).validate(props[i]);
+            
+        }
+        
+    }
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BlueprintEventValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BlueprintEventValidator.java
index b56de2e8..bb82fde1 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BlueprintEventValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/BlueprintEventValidator.java
@@ -1,3 +1,35 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import org.apache.aries.jmx.blueprint.BlueprintStateMBean;
+
+
+public class BlueprintEventValidator extends AbstractCompositeDataValidator{
+    public BlueprintEventValidator(long bundleId, long extenderBundleId, int eventType){
+        super(BlueprintStateMBean.OSGI_BLUEPRINT_EVENT_TYPE);  
+        setExpectValue(BlueprintStateMBean.BUNDLE_ID, bundleId);
+        setExpectValue(BlueprintStateMBean.EXTENDER_BUNDLE_ID, extenderBundleId);
+        setExpectValue(BlueprintStateMBean.EVENT_TYPE, eventType);
+    }
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/CollectionValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/CollectionValidator.java
index b56de2e8..7ebf61b5 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/CollectionValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/CollectionValidator.java
@@ -1,3 +1,64 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import java.util.ArrayList;
+import java.util.List;
+import static org.junit.Assert.*;
+
+import javax.management.openmbean.CompositeData;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+
+public class CollectionValidator extends AbstractCompositeDataValidator implements NonNullObjectValueValidator {
+    
+    private List<ObjectValueValidator> collectionValueValidators = new ArrayList<ObjectValueValidator>();
+    
+    public CollectionValidator(String collectionClass){
+        super(BlueprintMetadataMBean.COLLECTION_METADATA_TYPE);
+        setExpectValue(BlueprintMetadataMBean.COLLECTION_CLASS, collectionClass);
+    }
+    
+    public CollectionValidator(String collectionClass, String valueType){
+        super(BlueprintMetadataMBean.COLLECTION_METADATA_TYPE);
+        setExpectValue(BlueprintMetadataMBean.COLLECTION_CLASS, collectionClass);
+        setExpectValue(BlueprintMetadataMBean.VALUE_TYPE, valueType);
+    }
+    
+    public void addCollectionValueValidators (ObjectValueValidator...objectValueValidators){
+        for (ObjectValueValidator objectValueValidator: objectValueValidators)
+            collectionValueValidators.add(objectValueValidator);
+    }
+    
+    public void validate(CompositeData target){
+        super.validate(target);
+        if (collectionValueValidators.size() != 0){
+            Byte[][] allWrapValues = (Byte[][])target.get(BlueprintMetadataMBean.VALUES);
+            if ( collectionValueValidators.size() != allWrapValues.length )
+                fail("The quantity of the values is not the same, expect " +collectionValueValidators.size()+" but got "+ allWrapValues.length);
+            for(int i=0;i<collectionValueValidators.size();i++){
+                collectionValueValidators.get(i).validate(Util.decode(allWrapValues[i]));
+            }
+                
+        }
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/MapEntryValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/MapEntryValidator.java
index b56de2e8..f96d914f 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/MapEntryValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/MapEntryValidator.java
@@ -1,3 +1,53 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import javax.management.openmbean.CompositeData;
+import static junit.framework.Assert.*;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+
+public class MapEntryValidator extends AbstractCompositeDataValidator {
+    
+    NonNullObjectValueValidator keyValidator = null;
+    
+    ObjectValueValidator valueValidator = null;
+    
+    public MapEntryValidator(){
+        super(BlueprintMetadataMBean.MAP_ENTRY_TYPE);
+    }
+    
+    public void setKeyValueValidator(NonNullObjectValueValidator keyValidator, ObjectValueValidator valueValidator){
+        this.keyValidator = keyValidator;
+        this.valueValidator = valueValidator;        
+    }
+    
+    public void validate(CompositeData target){
+        super.validate(target); //do nothing
+        assertNotNull("keyValidator can not be null", keyValidator);
+        assertNotNull("valueValidator can not be null", valueValidator);
+        
+        keyValidator.validate(Util.decode((Byte[])target.get(BlueprintMetadataMBean.KEY)));
+        valueValidator.validate(Util.decode((Byte[])target.get(BlueprintMetadataMBean.VALUE)));
+    }
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/NonNullObjectValueValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/NonNullObjectValueValidator.java
index b56de2e8..ceb8bc31 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/NonNullObjectValueValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/NonNullObjectValueValidator.java
@@ -1,3 +1,26 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+public interface NonNullObjectValueValidator extends ObjectValueValidator{
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ObjectValueValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ObjectValueValidator.java
index 1f8bddab..18b38c8b 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ObjectValueValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ObjectValueValidator.java
@@ -1,3 +1,26 @@
   + native
   + text/plain
   + Revision Date
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+public interface ObjectValueValidator extends Validator{
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/RefValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/RefValidator.java
index b56de2e8..e951c00b 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/RefValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/RefValidator.java
@@ -1,3 +1,31 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+
+public class RefValidator extends AbstractCompositeDataValidator implements NonNullObjectValueValidator, TargetValidator {
+    public RefValidator(String componentId){
+        super(BlueprintMetadataMBean.REF_METADATA_TYPE);
+        setExpectValue(BlueprintMetadataMBean.COMPONENT_ID, componentId);
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ReferenceListValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ReferenceListValidator.java
index b56de2e8..8bae6346 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ReferenceListValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ReferenceListValidator.java
@@ -1,3 +1,40 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+
+public class ReferenceListValidator extends AbstractServiceReferenceValidator {
+    
+    public ReferenceListValidator (String interfaceName){
+        super(BlueprintMetadataMBean.REFERENCE_LIST_METADATA_TYPE);
+        this.setExpectValue(BlueprintMetadataMBean.INTERFACE, interfaceName);
+    }
+    
+    public ReferenceListValidator (String interfaceName, int availability){
+        super(BlueprintMetadataMBean.REFERENCE_LIST_METADATA_TYPE);
+        this.setExpectValue(BlueprintMetadataMBean.INTERFACE, interfaceName);
+        this.setExpectValue(BlueprintMetadataMBean.AVAILABILITY, availability);
+    }
+    
+   
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ReferenceListenerValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ReferenceListenerValidator.java
index b56de2e8..e64cde37 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ReferenceListenerValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ReferenceListenerValidator.java
@@ -1,3 +1,34 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+
+public class ReferenceListenerValidator extends AbstractListenerComponentValidator {
+    
+    public ReferenceListenerValidator(String bindMethod,String unbindMethod){
+        super(BlueprintMetadataMBean.REFERENCE_LISTENER_TYPE);
+        this.setExpectValue(BlueprintMetadataMBean.BIND_METHOD, bindMethod);
+        this.setExpectValue(BlueprintMetadataMBean.UNBIND_METHOD, unbindMethod);
+    }
+        
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ReferenceValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ReferenceValidator.java
index 1f8bddab..dfb6695f 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ReferenceValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ReferenceValidator.java
@@ -1,3 +1,34 @@
   + native
   + text/plain
   + Revision Date
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+
+public class ReferenceValidator extends AbstractServiceReferenceValidator implements TargetValidator{
+    
+    public ReferenceValidator(String interfaceName, long timeout){
+        super(BlueprintMetadataMBean.REFERENCE_METADATA_TYPE);
+        this.setExpectValue(BlueprintMetadataMBean.INTERFACE, interfaceName);
+        this.setExpectValue(BlueprintMetadataMBean.TIMEOUT, timeout);
+    }
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/RegistrationListenerValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/RegistrationListenerValidator.java
index b56de2e8..84bfecc9 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/RegistrationListenerValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/RegistrationListenerValidator.java
@@ -1,3 +1,34 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+
+public class RegistrationListenerValidator extends AbstractListenerComponentValidator {
+    
+    public RegistrationListenerValidator(String registrationMethod,String unregistrationMethod){
+        super(BlueprintMetadataMBean.REGISTRATION_LISTENER_TYPE);
+        this.setExpectValue(BlueprintMetadataMBean.REGISTRATION_METHOD, registrationMethod);
+        this.setExpectValue(BlueprintMetadataMBean.UNREGISTRATION_METHOD, unregistrationMethod);
+    }
+      
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ServiceValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ServiceValidator.java
index b56de2e8..d06683fb 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ServiceValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ServiceValidator.java
@@ -1,3 +1,83 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import static junit.framework.Assert.assertNotNull;
+import static org.junit.Assert.fail;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import javax.management.openmbean.CompositeData;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+
+public class ServiceValidator extends AbstractCompositeDataValidator implements NonNullObjectValueValidator {
+    // a TargetValidator can be one of BeanValidator, ReferenceValidator, RefValidator
+    TargetValidator serviceComponentValidator = null;
+    
+    List<MapEntryValidator> servicePropertyValidators = new ArrayList<MapEntryValidator>();
+    List<RegistrationListenerValidator> registrationListenerValidators = new ArrayList<RegistrationListenerValidator>();
+    
+    public ServiceValidator(int autoExport){
+        super(BlueprintMetadataMBean.SERVICE_METADATA_TYPE);
+        this.setExpectValue(BlueprintMetadataMBean.AUTO_EXPORT, autoExport);
+    }
+    
+    public void setServiceComponentValidator(TargetValidator targetValidator){
+        this.serviceComponentValidator = targetValidator;
+    }
+    
+    public void addMapEntryValidator(MapEntryValidator... validators){
+        for (MapEntryValidator validator : validators)
+            this.servicePropertyValidators.add(validator);
+    }
+        
+    public void addRegistrationListenerValidator(RegistrationListenerValidator... validators){
+        for (RegistrationListenerValidator validator : validators)
+            this.registrationListenerValidators.add(validator);
+    }
+    
+    public void validate(CompositeData target){
+        super.validate(target);
+        assertNotNull("ServiceValidator must have a TargetValidator for service component", serviceComponentValidator);
+        serviceComponentValidator.validate(Util.decode((Byte[])target.get(BlueprintMetadataMBean.SERVICE_COMPONENT)));
+        
+        if (servicePropertyValidators.size()!=0){
+            CompositeData[] serviceProperties = (CompositeData[])target.get(BlueprintMetadataMBean.SERVICE_PROPERTIES);
+            if ( servicePropertyValidators.size() != serviceProperties.length )
+                fail("The quantity of the service properties is not the same, expect " +servicePropertyValidators.size()+" but got "+ serviceProperties.length);
+            for (int i=0; i<servicePropertyValidators.size(); i++)
+                servicePropertyValidators.get(i).validate(serviceProperties[i]);
+        }
+        
+        if (registrationListenerValidators.size() != 0){
+            CompositeData[] registrationListeners = (CompositeData[])target.get(BlueprintMetadataMBean.REGISTRATION_LISTENERS);
+            if ( registrationListenerValidators.size() != registrationListeners.length )
+                fail("The quantity of the registration listeners is not the same, expect " +registrationListenerValidators.size()+" but got "+ registrationListeners.length);
+            for (int i=0; i<registrationListenerValidators.size(); i++)
+                registrationListenerValidators.get(i).validate(registrationListeners[i]);
+        }
+        
+    }
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/TargetValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/TargetValidator.java
index b56de2e8..c382fbec 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/TargetValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/TargetValidator.java
@@ -1,3 +1,26 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+public interface TargetValidator extends Validator {
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/Util.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/Util.java
index b56de2e8..e226a417 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/Util.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/Util.java
@@ -1,3 +1,51 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import java.io.ByteArrayInputStream;
+import java.io.ObjectInputStream;
+
+import javax.management.openmbean.CompositeData;
+
+public class Util {
+    
+    public static CompositeData decode(Byte[] wrap){
+        if (null == wrap) return null;
+
+        byte[] prim = new byte[wrap.length];
+        for (int i = 0; i < wrap.length; i++) {
+            prim[i] = wrap[i];
+        }
+        
+        ByteArrayInputStream inBytes = new ByteArrayInputStream(prim);
+        ObjectInputStream inObject;
+        CompositeData data;
+        try {
+            inObject = new ObjectInputStream(inBytes);
+            data = (CompositeData) inObject.readObject();
+            inObject.close();
+            return data;
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }         
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/Validator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/Validator.java
index b56de2e8..7c0e57be 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/Validator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/Validator.java
@@ -1,3 +1,28 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import javax.management.openmbean.CompositeData;
+
+public interface Validator {
+    public void validate(CompositeData target);
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ValueValidator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ValueValidator.java
index b56de2e8..43731d6b 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ValueValidator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework/ValueValidator.java
@@ -1,3 +1,39 @@
   + text/plain
   + Revision Date
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.test.blueprint.framework;
+
+import org.apache.aries.jmx.blueprint.BlueprintMetadataMBean;
+
+public class ValueValidator extends AbstractCompositeDataValidator implements NonNullObjectValueValidator{
+    
+    public ValueValidator(String stringValue){
+        super(BlueprintMetadataMBean.VALUE_METADATA_TYPE);
+        setExpectValue(BlueprintMetadataMBean.STRING_VALUE, stringValue);
+    }
+    
+    public ValueValidator(String stringValue, String type){
+        super(BlueprintMetadataMBean.VALUE_METADATA_TYPE);
+        setExpectValue(BlueprintMetadataMBean.STRING_VALUE, stringValue);
+        setExpectValue(BlueprintMetadataMBean.TYPE, type);
+    }
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundlea/Activator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundlea/Activator.java
index 56d8ebfd..c8c0fefb 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundlea/Activator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundlea/Activator.java
@@ -1,2 +1,66 @@
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.test.bundlea;
+
+import java.util.Dictionary;
+import java.util.Hashtable;
+
+import org.apache.aries.jmx.test.bundlea.api.InterfaceA;
+import org.apache.aries.jmx.test.bundlea.impl.A;
+import org.apache.aries.jmx.test.bundleb.api.InterfaceB;
+import org.osgi.framework.BundleActivator;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Constants;
+import org.osgi.framework.ServiceRegistration;
+import org.osgi.service.cm.ManagedService;
+import org.osgi.util.tracker.ServiceTracker;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class Activator implements BundleActivator {
+
+    ServiceRegistration registration;
+    ServiceTracker tracker;
+    
+    /* (non-Javadoc)
+     * @see org.osgi.framework.BundleActivator#start(org.osgi.framework.BundleContext)
+     */
+    public void start(BundleContext context) throws Exception {
+        
+        tracker = new ServiceTracker(context, InterfaceB.class.getName(), null);
+        tracker.open();
+        
+        Dictionary<String, Object> props = new Hashtable<String, Object>();
+        props.put(Constants.SERVICE_PID, "org.apache.aries.jmx.test.ServiceA");
+        registration = context.registerService(new String[] { InterfaceA.class.getName(), ManagedService.class.getName() }, new A(tracker), props);
+        
+    }
+
+    /* (non-Javadoc)
+     * @see org.osgi.framework.BundleActivator#stop(org.osgi.framework.BundleContext)
+     */
+    public void stop(BundleContext context) throws Exception {
+        registration.unregister();
+        tracker.close();
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundlea/api/InterfaceA.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundlea/api/InterfaceA.java
index 56d8ebfd..866d1daa 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundlea/api/InterfaceA.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundlea/api/InterfaceA.java
@@ -1,2 +1,37 @@
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.test.bundlea.api;
+
+import java.util.Dictionary;
+
+import org.osgi.service.cm.ManagedService;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+@SuppressWarnings("unchecked")
+public interface InterfaceA extends ManagedService {
+
+    boolean invoke();
+    
+    Dictionary getConfig();
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundlea/impl/A.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundlea/impl/A.java
index 56d8ebfd..52de5d04 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundlea/impl/A.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundlea/impl/A.java
@@ -1,2 +1,66 @@
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.test.bundlea.impl;
+
+import java.util.Dictionary;
+
+import org.apache.aries.jmx.test.bundlea.api.InterfaceA;
+import org.apache.aries.jmx.test.bundleb.api.InterfaceB;
+import org.osgi.service.cm.ConfigurationException;
+import org.osgi.util.tracker.ServiceTracker;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+@SuppressWarnings("unchecked")
+public class A implements InterfaceA {
+
+    private ServiceTracker tracker;
+    private Dictionary props;
+    
+    public A(ServiceTracker tracker) {
+        this.tracker = tracker;
+    }
+    
+    /* (non-Javadoc)
+     * @see org.apache.aries.jmx.test.bundlea.api.InterfaceA#invoke()
+     */
+    public boolean invoke() {
+        
+        if (tracker.getService() != null) {
+            InterfaceB service = (InterfaceB) tracker.getService();
+            return service.invoke();
+        } else {
+            return false;
+        }
+        
+    }
+
+    public void updated(Dictionary dictionary) throws ConfigurationException {
+        this.props = dictionary;
+    }
+    
+    // test cback
+    public Dictionary getConfig() {
+        return this.props;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/Activator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/Activator.java
index 56d8ebfd..7b6d7703 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/Activator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/Activator.java
@@ -1,2 +1,63 @@
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.test.bundleb;
+
+import java.util.Dictionary;
+import java.util.Hashtable;
+
+import org.apache.aries.jmx.test.bundleb.api.InterfaceB;
+import org.apache.aries.jmx.test.bundleb.api.MSF;
+import org.apache.aries.jmx.test.bundleb.impl.B;
+import org.osgi.framework.BundleActivator;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Constants;
+import org.osgi.framework.ServiceRegistration;
+import org.osgi.service.cm.ManagedServiceFactory;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class Activator implements BundleActivator {
+
+    ServiceRegistration plainRegistration;
+    ServiceRegistration msfRegistration;
+    
+    /* (non-Javadoc)
+     * @see org.osgi.framework.BundleActivator#start(org.osgi.framework.BundleContext)
+     */
+    public void start(BundleContext context) throws Exception {
+        Dictionary<String, Object> props = new Hashtable<String, Object>();
+        props.put(Constants.SERVICE_PID, "org.apache.aries.jmx.test.ServiceB");
+        plainRegistration = context.registerService(InterfaceB.class.getName(), new B(), props);
+        Dictionary<String, Object> fprops = new Hashtable<String, Object>();
+        fprops.put(Constants.SERVICE_PID, "jmx.test.B.factory");
+        msfRegistration = context.registerService(ManagedServiceFactory.class.getName(), new MSF(), fprops);
+    }
+
+    /* (non-Javadoc)
+     * @see org.osgi.framework.BundleActivator#stop(org.osgi.framework.BundleContext)
+     */
+    public void stop(BundleContext context) throws Exception {
+        plainRegistration.unregister();
+        msfRegistration.unregister();
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/api/InterfaceB.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/api/InterfaceB.java
index 56d8ebfd..bc7b7d38 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/api/InterfaceB.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/api/InterfaceB.java
@@ -1,2 +1,37 @@
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.test.bundleb.api;
+
+import java.util.Dictionary;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+@SuppressWarnings("unchecked")
+public interface InterfaceB {
+
+    boolean invoke();
+    
+    void configure(Dictionary<String, Object> props);
+    
+    Dictionary getConfig();
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/api/MSF.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/api/MSF.java
index 56d8ebfd..c9fbbe4c 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/api/MSF.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/api/MSF.java
@@ -1,2 +1,62 @@
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.test.bundleb.api;
+
+import java.util.Dictionary;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.aries.jmx.test.bundleb.impl.B;
+import org.osgi.service.cm.ConfigurationException;
+import org.osgi.service.cm.ManagedServiceFactory;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+@SuppressWarnings("unchecked")
+public class MSF implements ManagedServiceFactory {
+
+    Map<String, InterfaceB> configured = new HashMap<String, InterfaceB>();
+    
+    public void deleted(String pid) {
+       configured.remove(pid);
+    }
+
+    public String getName() {
+        return "jmx.test.B.factory";
+    }
+
+    public void updated(String pid, Dictionary dictionary) throws ConfigurationException {
+        if (configured.containsKey(pid)) {
+            configured.get(pid).configure(dictionary);
+        } else {
+            InterfaceB ser = new B();
+            ser.configure(dictionary);
+            configured.put(pid, ser);
+        }
+    }
+
+    // test cback
+    public InterfaceB getConfigured(String pid) {
+        return configured.get(pid);
+    }
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/impl/B.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/impl/B.java
index 56d8ebfd..6e5f4925 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/impl/B.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/bundleb/impl/B.java
@@ -1,2 +1,47 @@
   + Revision Date
   + native
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.test.bundleb.impl;
+
+import java.util.Dictionary;
+
+import org.apache.aries.jmx.test.bundleb.api.InterfaceB;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+@SuppressWarnings("unchecked")
+public class B implements InterfaceB {
+
+    private Dictionary<String, Object> conf;
+    
+    public boolean invoke() {
+       return (conf == null);
+    }
+
+    public void configure(Dictionary<String, Object> props) {
+        this.conf = props;
+    }
+
+    // test cback
+    public Dictionary getConfig() {
+        return this.conf;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/fragmentc/C.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/fragmentc/C.java
index 9dee62c1..c5aaf7ab 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/fragmentc/C.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/fragmentc/C.java
@@ -2,3 +2,33 @@
   + Revision Date
   + native
   Merged /aries/trunk/sandbox/jmx-next/jmx-itests/src/test/java/org/apache/aries/jmx/test/blueprint/framework:r1189122-1190455
+/**
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package org.apache.aries.jmx.test.fragmentc;
+
+/**
+ * 
+ *
+ * @version $Rev$ $Date$
+ */
+public class C {
+
+    boolean invoke() {
+        return true;
+    }
+    
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/ops4j/pax/runner/platform/equinox/internal/SsActivator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/ops4j/pax/runner/platform/equinox/internal/SsActivator.java
index e69de29b..e459e069 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/ops4j/pax/runner/platform/equinox/internal/SsActivator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-itests/src/test/java/org/ops4j/pax/runner/platform/equinox/internal/SsActivator.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.ops4j.pax.runner.platform.equinox.internal;
+
+import org.ops4j.pax.runner.platform.PlatformBuilder;
+import org.ops4j.pax.runner.platform.builder.AbstractPlatformBuilderActivator;
+import org.osgi.framework.BundleContext;
+
+public class SsActivator extends AbstractPlatformBuilderActivator
+{
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected PlatformBuilder[] createPlatformBuilders( final BundleContext bundleContext )
+    {
+        return new PlatformBuilder[]{
+            new EquinoxPlatformBuilder( bundleContext, "3.2.1" ),
+            new EquinoxPlatformBuilder( bundleContext, "3.3.0" ),
+            new EquinoxPlatformBuilder( bundleContext, "3.3.1" ),
+            new EquinoxPlatformBuilder( bundleContext, "3.3.2" ),
+            new EquinoxPlatformBuilder( bundleContext, "3.4.0" ),
+            new EquinoxPlatformBuilder( bundleContext, "3.4.1" ),
+            new EquinoxPlatformBuilder( bundleContext, "3.4.2" ),
+            new EquinoxPlatformBuilder( bundleContext, "3.5.0" ),
+            new EquinoxPlatformBuilder( bundleContext, "3.5.1" ),
+            new EquinoxPlatformBuilder( bundleContext, "3.6.0" ),
+            new EquinoxPlatformBuilder( bundleContext, "3.7.0.V20110613" ),
+            new EquinoxPlatformBuilderSnapshot( bundleContext )
+        };
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/main/java/org/apache/aries/jmx/whiteboard/Activator.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/main/java/org/apache/aries/jmx/whiteboard/Activator.java
index e8961f8b..a74a1ea4 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/main/java/org/apache/aries/jmx/whiteboard/Activator.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/main/java/org/apache/aries/jmx/whiteboard/Activator.java
@@ -1,2 +1,114 @@
   + Author Date Id Revision Rev Url
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.whiteboard;
+
+import javax.management.MBeanServer;
+
+import org.osgi.framework.BundleActivator;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.ServiceReference;
+import org.osgi.util.tracker.ServiceTracker;
+
+public class Activator implements BundleActivator {
+
+    private JmxWhiteboardSupport jmxWhiteBoard;
+
+    private ServiceTracker mbeanServerTracker;
+
+    private ServiceTracker mbeanTracker;
+
+    public void start(BundleContext context) throws Exception {
+        jmxWhiteBoard = new JmxWhiteboardSupport();
+
+        mbeanServerTracker = new MBeanServerTracker(context);
+        mbeanServerTracker.open();
+
+        mbeanTracker = new MBeanTracker(context);
+        mbeanTracker.open(true);
+    }
+
+    public void stop(BundleContext context) throws Exception {
+        if (mbeanTracker != null) {
+            mbeanTracker.close();
+            mbeanTracker = null;
+        }
+
+        if (mbeanServerTracker != null) {
+            mbeanServerTracker.close();
+            mbeanServerTracker = null;
+        }
+
+        jmxWhiteBoard = null;
+    }
+
+    private class MBeanServerTracker extends ServiceTracker {
+
+        public MBeanServerTracker(BundleContext context) {
+            super(context, MBeanServer.class.getName(), null);
+        }
+
+        @Override
+        public Object addingService(ServiceReference reference) {
+            MBeanServer mbeanServer = (MBeanServer) super.addingService(reference);
+            jmxWhiteBoard.addMBeanServer(mbeanServer);
+            return mbeanServer;
+        }
+
+        @Override
+        public void removedService(ServiceReference reference, Object service) {
+            if (service instanceof MBeanServer) {
+                jmxWhiteBoard.removeMBeanServer((MBeanServer) service);
+            }
+            super.removedService(reference, service);
+        }
+    }
+
+    private class MBeanTracker extends ServiceTracker {
+
+        /**
+         * Listens for any services registered with a "jmx.objectname" service
+         * property. If the property is not a non-empty String object the service
+         * is expected to implement the MBeanRegistration interface to create
+         * the name dynamically.
+         */
+        private static final String SIMPLE_MBEAN_FILTER = "("
+            + JmxWhiteboardSupport.PROP_OBJECT_NAME+ "=*)";
+
+        public MBeanTracker(BundleContext context)
+                throws InvalidSyntaxException {
+            super(context, context.createFilter(SIMPLE_MBEAN_FILTER), null);
+        }
+
+        @Override
+        public Object addingService(ServiceReference reference) {
+            Object mbean = super.addingService(reference);
+            jmxWhiteBoard.registerMBean(mbean, reference);
+            return mbean;
+        }
+
+        @Override
+        public void removedService(ServiceReference reference, Object service) {
+            jmxWhiteBoard.unregisterMBean(service);
+            super.removedService(reference, service);
+        }
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/main/java/org/apache/aries/jmx/whiteboard/JmxWhiteboardSupport.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/main/java/org/apache/aries/jmx/whiteboard/JmxWhiteboardSupport.java
index e8961f8b..d1592383 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/main/java/org/apache/aries/jmx/whiteboard/JmxWhiteboardSupport.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/main/java/org/apache/aries/jmx/whiteboard/JmxWhiteboardSupport.java
@@ -1,2 +1,132 @@
   + Author Date Id Revision Rev Url
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.whiteboard;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.IdentityHashMap;
+
+import javax.management.MBeanRegistration;
+import javax.management.MBeanServer;
+import javax.management.MalformedObjectNameException;
+import javax.management.ObjectName;
+
+import org.osgi.framework.ServiceReference;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+class JmxWhiteboardSupport {
+
+    static final String PROP_OBJECT_NAME = "jmx.objectname";
+
+    /** default log */
+    private final Logger log = LoggerFactory.getLogger(getClass());
+
+    private MBeanServer[] mbeanServers = new MBeanServer[0];
+
+    // mapping registered MBean services to their MBeanHolder objects
+    private final IdentityHashMap<Object, MBeanHolder> mbeans = new IdentityHashMap<Object, MBeanHolder>();
+
+    protected synchronized void addMBeanServer(final MBeanServer mbeanServer) {
+
+        log.debug("addMBeanServer: Adding MBeanServer {}", mbeanServer);
+
+        ArrayList<MBeanServer> serverList = new ArrayList<MBeanServer>(
+            Arrays.asList(mbeanServers));
+        serverList.add(mbeanServer);
+        mbeanServers = serverList.toArray(new MBeanServer[serverList.size()]);
+
+        // register all mbeans with the new server
+        for (MBeanHolder mbean : mbeans.values()) {
+            mbean.register(mbeanServer);
+        }
+    }
+
+    protected synchronized void removeMBeanServer(final MBeanServer mbeanServer) {
+
+        log.debug("removeMBeanServer: Removing MBeanServer {}", mbeanServer);
+
+        // remove all dynamically registered mbeans from the server
+        for (MBeanHolder mbean : mbeans.values()) {
+            mbean.unregister(mbeanServer);
+        }
+
+        ArrayList<MBeanServer> serverList = new ArrayList<MBeanServer>(
+            Arrays.asList(mbeanServers));
+        serverList.remove(mbeanServer);
+        mbeanServers = serverList.toArray(new MBeanServer[serverList.size()]);
+    }
+
+    protected synchronized void registerMBean(Object mbean, final ServiceReference props) {
+
+        log.debug("registerMBean: Adding MBean {}", mbean);
+
+        ObjectName objectName = getObjectName(props);
+        if (objectName != null || mbean instanceof MBeanRegistration) {
+            MBeanHolder holder = MBeanHolder.create(mbean, objectName);
+            if (holder != null) {
+                MBeanServer[] mbeanServers = this.mbeanServers;
+                for (MBeanServer mbeanServer : mbeanServers) {
+                    holder.register(mbeanServer);
+                }
+                mbeans.put(mbean, holder);
+            } else {
+                log.error(
+                    "registerMBean: Cannot register MBean service {} with MBean servers: Not an instanceof DynamicMBean or not MBean spec compliant standard MBean",
+                    mbean);
+            }
+        } else {
+            log.error(
+                "registerMBean: MBean service {} not registered with valid jmx.objectname propety and not implementing MBeanRegistration interface; not registering with MBean servers",
+                mbean);
+        }
+    }
+
+    protected synchronized void unregisterMBean(Object mbean) {
+
+        log.debug("unregisterMBean: Removing MBean {}", mbean);
+
+        final MBeanHolder holder = mbeans.remove(mbean);
+        if (holder != null) {
+            holder.unregister();
+        }
+    }
+
+    private ObjectName getObjectName(final ServiceReference props) {
+        Object oName = props.getProperty(PROP_OBJECT_NAME);
+        if (oName instanceof ObjectName) {
+            return (ObjectName) oName;
+        } else if (oName instanceof String) {
+            try {
+                return new ObjectName((String) oName);
+            } catch (MalformedObjectNameException e) {
+                log.error("getObjectName: Provided ObjectName property "
+                    + oName + " cannot be used as an ObjectName", e);
+            }
+        } else {
+            log.info(
+                "getObjectName: Missing {} service property (or wrong type); registering if MBean is MBeanRegistration implementation",
+                PROP_OBJECT_NAME);
+        }
+
+        return null;
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/main/java/org/apache/aries/jmx/whiteboard/MBeanHolder.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/main/java/org/apache/aries/jmx/whiteboard/MBeanHolder.java
index e8961f8b..31c1bba6 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/main/java/org/apache/aries/jmx/whiteboard/MBeanHolder.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/main/java/org/apache/aries/jmx/whiteboard/MBeanHolder.java
@@ -1,2 +1,153 @@
   + Author Date Id Revision Rev Url
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.whiteboard;
+
+import java.util.IdentityHashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import javax.management.DynamicMBean;
+import javax.management.InstanceAlreadyExistsException;
+import javax.management.InstanceNotFoundException;
+import javax.management.MBeanRegistrationException;
+import javax.management.MBeanServer;
+import javax.management.NotCompliantMBeanException;
+import javax.management.ObjectInstance;
+import javax.management.ObjectName;
+import javax.management.StandardMBean;
+
+import org.apache.aries.jmx.util.shared.RegistrableStandardEmitterMBean;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+final class MBeanHolder {
+
+    /** default log */
+    private final Logger log = LoggerFactory.getLogger(getClass());
+
+    private final Object mbean;
+
+    private final ObjectName requestedObjectName;
+
+    private final Map<MBeanServer, ObjectName> registrations;
+
+    static <T> MBeanHolder create(final T mbean,
+            final ObjectName requestedObjectName) {
+        if (mbean instanceof DynamicMBean) {
+            return new MBeanHolder(mbean, requestedObjectName);
+        } else if (mbean == null) {
+            return null;
+        }
+
+        Class<?> mbeanClass = mbean.getClass();
+        @SuppressWarnings("unchecked") // This is all in aid of getting new StandardMBean to work.
+        Class<T> mbeanInterface = (Class<T>) getMBeanInterface(mbeanClass);
+        if (mbeanInterface == null) {
+            return null;
+        }
+
+        if (mbeanInterface.getName().equals(
+            mbeanClass.getName().concat("MBean"))) {
+            return new MBeanHolder(mbean, requestedObjectName);
+        }
+
+        try {
+            StandardMBean stdMbean = new RegistrableStandardEmitterMBean(mbean, mbeanInterface);
+            return new MBeanHolder(stdMbean, requestedObjectName);
+        } catch (NotCompliantMBeanException e) {
+            LoggerFactory.getLogger(MBeanHolder.class).error(
+                "create: Cannot create StandardMBean for " + mbean
+                    + " of type " + mbeanClass + " for interface "
+                    + mbeanInterface, e);
+            return null;
+        }
+    }
+
+    private static Class<?> getMBeanInterface(final Class<?> mbeanClass) {
+        if (mbeanClass == null) {
+            return null;
+        }
+
+        for (Class<?> i : mbeanClass.getInterfaces()) {
+            if (i.getName().endsWith("MBean")) {
+                return i;
+            }
+
+            Class<?> mbeanInterface = getMBeanInterface(i);
+            if (mbeanInterface != null) {
+                return mbeanInterface;
+            }
+        }
+
+        if (mbeanClass.getSuperclass() != null) {
+            return getMBeanInterface(mbeanClass.getSuperclass());
+        }
+
+        return null;
+    }
+
+    private MBeanHolder(final Object mbean, final ObjectName requestedObjectName) {
+        this.mbean = mbean;
+        this.requestedObjectName = requestedObjectName;
+        this.registrations = new IdentityHashMap<MBeanServer, ObjectName>();
+    }
+
+    void register(final MBeanServer server) {
+        ObjectInstance instance;
+        try {
+            instance = server.registerMBean(mbean, requestedObjectName);
+            registrations.put(server, instance.getObjectName());
+        } catch (InstanceAlreadyExistsException e) {
+            log.error("register: Failure registering MBean " + mbean, e);
+        } catch (MBeanRegistrationException e) {
+            log.error("register: Failure registering MBean " + mbean, e);
+        } catch (NotCompliantMBeanException e) {
+            log.error("register: Failure registering MBean " + mbean, e);
+        }
+    }
+
+    void unregister(final MBeanServer server) {
+        final ObjectName registeredName = registrations.remove(server);
+        if (registeredName != null) {
+            unregister(server, registeredName);
+        }
+    }
+
+    void unregister() {
+        for (Entry<MBeanServer, ObjectName> entry : registrations.entrySet()) {
+            unregister(entry.getKey(), entry.getValue());
+        }
+        registrations.clear();
+    }
+
+    private void unregister(final MBeanServer server, final ObjectName name) {
+        try {
+            server.unregisterMBean(name);
+        } catch (MBeanRegistrationException e) {
+            log.error("unregister: preDeregister of " + name
+                + " threw an exception", e);
+        } catch (InstanceNotFoundException e) {
+            // not really expected !
+            log.error("unregister: Unexpected unregistration problem of MBean "
+                + name, e);
+        }
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/MBeanServerTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/MBeanServerTest.java
index e69de29b..0063cef0 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/MBeanServerTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/MBeanServerTest.java
@@ -0,0 +1,77 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.whiteboard.integration;
+
+import javax.management.MBeanServer;
+import javax.management.ObjectName;
+
+import junit.framework.TestCase;
+
+import org.apache.aries.jmx.whiteboard.integration.helper.IntegrationTestBase;
+import org.apache.aries.jmx.whiteboard.integration.helper.TestClass;
+import org.apache.aries.jmx.whiteboard.integration.helper.TestClassMBean;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.osgi.framework.ServiceRegistration;
+
+/**
+ * The <code>MBeanTest</code> tests MBean registration with MBean Servers
+ */
+@RunWith(JUnit4TestRunner.class)
+public class MBeanServerTest extends IntegrationTestBase {
+
+    @Test
+    public void test_MServerBean() throws Exception {
+        final String instanceName = "simple.test.instance";
+        final String objectNameString = "domain:instance=" + instanceName;
+        final ObjectName objectName = new ObjectName(objectNameString);
+        final TestClass testInstance = new TestClass(instanceName);
+
+        // get or create the dynamic MBean Server
+        final MBeanServer server = getOrCreateMBeanServer();
+
+        // MBean server not registered as service, unknown object
+        assertNotRegistered(server, objectName);
+
+        // expect the MBean to be registered with the static server
+        final ServiceRegistration mBeanReg = registerService(
+            TestClassMBean.class.getName(), testInstance, objectNameString);
+
+        // MBean server not registered, expect object to not be known
+        assertNotRegistered(server, objectName);
+
+        // register MBean server, expect MBean registered
+        ServiceRegistration mBeanServerReg = registerMBeanServer(server);
+        assertRegistered(server, objectName);
+
+        // expect MBean to return expected value
+        TestCase.assertEquals(instanceName,
+            server.getAttribute(objectName, "InstanceName"));
+
+        // unregister MBean server, expect MBean to be unregistered
+        mBeanServerReg.unregister();
+        assertNotRegistered(server, objectName);
+
+        // unregister MBean, expect to not be registered any more
+        mBeanReg.unregister();
+        assertNotRegistered(server, objectName);
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/MBeanTest.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/MBeanTest.java
index 17c97dcc..a99594e3 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/MBeanTest.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/MBeanTest.java
@@ -1 +1,122 @@
   + text/plain
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.whiteboard.integration;
+
+import javax.management.DynamicMBean;
+import javax.management.MBeanServer;
+import javax.management.ObjectName;
+
+import junit.framework.TestCase;
+
+import org.apache.aries.jmx.whiteboard.integration.helper.IntegrationTestBase;
+import org.apache.aries.jmx.whiteboard.integration.helper.TestClass;
+import org.apache.aries.jmx.whiteboard.integration.helper.TestClassMBean;
+import org.apache.aries.jmx.whiteboard.integration.helper.TestStandardMBean;
+import org.apache.aries.jmx.whiteboard.integration.helper2.TestClass2;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.osgi.framework.ServiceRegistration;
+
+/**
+ * The <code>MBeanTest</code> tests MBean registration with MBean Servers
+ */
+@RunWith(JUnit4TestRunner.class)
+public class MBeanTest extends IntegrationTestBase {
+
+    @Test
+    public void test_simple_MBean() throws Exception {
+        final String instanceName = "simple.test.instance";
+        final String objectNameString = "domain:instance=" + instanceName;
+        final ObjectName objectName = new ObjectName(objectNameString);
+        final TestClass testInstance = new TestClass(instanceName);
+
+        final MBeanServer server = getStaticMBeanServer();
+
+        // expect MBean to not be registered yet
+        assertNotRegistered(server, objectName);
+
+        // expect the MBean to be registered with the static server
+        final ServiceRegistration reg = registerService(
+            TestClassMBean.class.getName(), testInstance, objectNameString);
+        assertRegistered(server, objectName);
+
+        // expect MBean to return expected value
+        TestCase.assertEquals(instanceName,
+            server.getAttribute(objectName, "InstanceName"));
+
+        // unregister MBean, expect to not be registered any more
+        reg.unregister();
+        assertNotRegistered(server, objectName);
+    }
+
+    @Test
+    public void test_simple_MBean_different_package() throws Exception {
+        final String instanceName = "simple.test.instance.2";
+        final String objectNameString = "domain:instance=" + instanceName;
+        final ObjectName objectName = new ObjectName(objectNameString);
+        final TestClass testInstance = new TestClass2(instanceName);
+
+        final MBeanServer server = getStaticMBeanServer();
+
+        // expect MBean to not be registered yet
+        assertNotRegistered(server, objectName);
+
+        // expect the MBean to be registered with the static server
+        final ServiceRegistration reg = registerService(
+            TestClassMBean.class.getName(), testInstance, objectNameString);
+        assertRegistered(server, objectName);
+
+        // expect MBean to return expected value
+        TestCase.assertEquals(instanceName,
+            server.getAttribute(objectName, "InstanceName"));
+
+        // unregister MBean, expect to not be registered any more
+        reg.unregister();
+        assertNotRegistered(server, objectName);
+    }
+
+    @Test
+    public void test_StandardMBean() throws Exception {
+        final String instanceName = "standard.test.instance";
+        final String objectNameString = "domain:instance=" + instanceName;
+        final ObjectName objectName = new ObjectName(objectNameString);
+        final TestStandardMBean testInstance = new TestStandardMBean(
+            instanceName);
+
+        final MBeanServer server = getStaticMBeanServer();
+
+        // expect MBean to not be registered yet
+        assertNotRegistered(server, objectName);
+
+        // expect the MBean to be registered with the static server
+        final ServiceRegistration reg = registerService(
+            DynamicMBean.class.getName(), testInstance, objectNameString);
+        assertRegistered(server, objectName);
+
+        // expect MBean to return expected value
+        TestCase.assertEquals(instanceName,
+            server.getAttribute(objectName, "InstanceName"));
+
+        // unregister MBean, expect to not be registered any more
+        reg.unregister();
+        assertNotRegistered(server, objectName);
+    }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/IntegrationTestBase.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/IntegrationTestBase.java
index e8961f8b..54988fbe 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/IntegrationTestBase.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/IntegrationTestBase.java
@@ -1,2 +1,203 @@
   + Author Date Id Revision Rev Url
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.whiteboard.integration.helper;
+
+import static org.ops4j.pax.exam.CoreOptions.mavenBundle;
+import static org.ops4j.pax.exam.CoreOptions.options;
+import static org.ops4j.pax.exam.CoreOptions.provision;
+import static org.ops4j.pax.exam.CoreOptions.waitForFrameworkStartup;
+import static org.ops4j.pax.exam.CoreOptions.wrappedBundle;
+import static org.ops4j.pax.exam.OptionUtils.combine;
+
+import java.io.File;
+import java.util.Dictionary;
+import java.util.Hashtable;
+
+import javax.management.InstanceNotFoundException;
+import javax.management.MBeanServer;
+import javax.management.MBeanServerFactory;
+import javax.management.ObjectInstance;
+import javax.management.ObjectName;
+
+import junit.framework.TestCase;
+
+import org.junit.After;
+import org.junit.Before;
+import org.ops4j.pax.exam.CoreOptions;
+import org.ops4j.pax.exam.Inject;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceRegistration;
+
+public class IntegrationTestBase {
+
+    // the name of the system property providing the bundle file to be installed
+    // and tested
+    protected static final String BUNDLE_JAR_SYS_PROP = "project.bundle.file";
+
+    // the default bundle jar file name
+    protected static final String BUNDLE_JAR_DEFAULT = "target/jmx-whiteboard.jar";
+
+    // the JVM option to set to enable remote debugging
+    protected static final String DEBUG_VM_OPTION = "-Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=30303";
+
+    // the actual JVM option set, extensions may implement a static
+    // initializer overwriting this value to have the configuration()
+    // method include it when starting the OSGi framework JVM
+    protected static String paxRunnerVmOption = null;
+
+    private static MBeanServer staticServer;
+
+    private MBeanServer server;
+
+    @Inject
+    protected BundleContext bundleContext;
+
+    private ServiceRegistration staticServerRegistration;
+
+    protected static final String PROP_NAME = "theValue";
+
+    protected static final Dictionary<String, String> theConfig;
+
+    static {
+        theConfig = new Hashtable<String, String>();
+        theConfig.put(PROP_NAME, PROP_NAME);
+    }
+
+    @org.ops4j.pax.exam.junit.Configuration
+    public static Option[] configuration() {
+        final String bundleFileName = System.getProperty(BUNDLE_JAR_SYS_PROP,
+            BUNDLE_JAR_DEFAULT);
+        final File bundleFile = new File(bundleFileName);
+        if (!bundleFile.canRead()) {
+            throw new IllegalArgumentException("Cannot read from bundle file "
+                + bundleFileName + " specified in the " + BUNDLE_JAR_SYS_PROP
+                + " system property");
+        }
+
+        final Option[] base = options(
+            provision(
+                CoreOptions.bundle(bundleFile.toURI().toString()),
+                mavenBundle("org.ops4j.pax.swissbox",
+                    "pax-swissbox-tinybundles", "1.0.0"),
+                mavenBundle("org.apache.felix", "org.apache.felix.configadmin",
+                    "1.2.8"), mavenBundle("org.slf4j", "slf4j-api", "1.5.2"),
+                mavenBundle("org.slf4j", "slf4j-simple", "1.5.2")),
+            waitForFrameworkStartup());
+        final Option vmOption = (paxRunnerVmOption != null)
+                ? PaxRunnerOptions.vmOption(paxRunnerVmOption)
+                : null;
+        
+        Option[] options = combine(base, vmOption);
+        return updateOptions (options);
+    }
+    
+    // This method is copied from AbstractIntegrationTest 
+    // in org.apache.aries.jmx.itests
+    protected static Option[] updateOptions(Option[] options) {
+      // We need to add pax-exam-junit here when running with the ibm
+      // jdk to avoid the following exception during the test run:
+      // ClassNotFoundException: org.ops4j.pax.exam.junit.Configuration
+      if ("IBM Corporation".equals(System.getProperty("java.vendor"))) {
+          Option[] ibmOptions = options(
+              wrappedBundle(mavenBundle("org.ops4j.pax.exam", "pax-exam-junit"))
+          );
+          options = combine(ibmOptions, options);
+      }
+      return options;
+  }
+
+    @Before
+    public void setUp() {
+        staticServerRegistration = registerMBeanServer(getStaticMBeanServer());
+    }
+
+    @After
+    public void tearDown() {
+        staticServerRegistration.unregister();
+    }
+
+    protected MBeanServer getStaticMBeanServer() {
+        if (staticServer == null) {
+            staticServer = MBeanServerFactory.createMBeanServer("StaticServerDomain");
+        }
+        return staticServer;
+    }
+
+    protected MBeanServer getMBeanServer() {
+        return server;
+    }
+
+    protected MBeanServer getOrCreateMBeanServer() {
+        if (server == null) {
+            server = MBeanServerFactory.createMBeanServer("DynamicServerDomain");
+        }
+        return server;
+    }
+
+    protected void dropMBeanServer() {
+        if (server != null) {
+            MBeanServerFactory.releaseMBeanServer(server);
+            server = null;
+        }
+    }
+
+    protected ServiceRegistration registerMBeanServer(final MBeanServer server) {
+        return registerService(MBeanServer.class.getName(), server, null);
+    }
+
+    protected ServiceRegistration registerService(final String clazz,
+            final Object service, final String objectName) {
+        Hashtable<String, String> properties;
+        if (objectName != null) {
+            properties = new Hashtable<String, String>();
+            properties.put("jmx.objectname", objectName);
+        } else {
+            properties = null;
+        }
+        return bundleContext.registerService(clazz, service, properties);
+    }
+
+    protected void assertRegistered(final MBeanServer server,
+            final ObjectName objectName) {
+        try {
+            ObjectInstance instance = server.getObjectInstance(objectName);
+            TestCase.assertNotNull(instance);
+            TestCase.assertEquals(objectName, instance.getObjectName());
+        } catch (InstanceNotFoundException nfe) {
+            TestCase.fail("Expected instance of " + objectName
+                + " registered with MBeanServer");
+        }
+    }
+
+    protected void assertNotRegistered(final MBeanServer server,
+            final ObjectName objectName) {
+        try {
+            server.getObjectInstance(objectName);
+            TestCase.fail("Unexpected instance of " + objectName
+                + " registered with MBeanServer");
+        } catch (InstanceNotFoundException nfe) {
+            // expected, ignore
+        }
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/TestClass.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/TestClass.java
index e8961f8b..3ee9799e 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/TestClass.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/TestClass.java
@@ -1,2 +1,43 @@
   + Author Date Id Revision Rev Url
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.whiteboard.integration.helper;
+
+/**
+ * The <code>TestClass</code> is a simple class which will be registered as a
+ * Simple MBean implementing the {@link TestClassMBean} interface.
+ */
+public class TestClass implements TestClassMBean {
+
+    private final String instanceName;
+
+    public TestClass() {
+        this(null);
+    }
+
+    public TestClass(final String name) {
+        this.instanceName = (name == null) ? getClass().getName() : name;
+    }
+
+    public String getInstanceName() {
+        return instanceName;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/TestClassMBean.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/TestClassMBean.java
index e8961f8b..6019a86c 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/TestClassMBean.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/TestClassMBean.java
@@ -1,2 +1,31 @@
   + Author Date Id Revision Rev Url
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.whiteboard.integration.helper;
+
+/**
+ * The <code>TestClassMBean</code> is the simple MBean interface for the
+ * {@link TestClass} class.
+ */
+public interface TestClassMBean {
+
+    String getInstanceName();
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/TestStandardMBean.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/TestStandardMBean.java
index e8961f8b..9b23d428 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/TestStandardMBean.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper/TestStandardMBean.java
@@ -1,2 +1,44 @@
   + Author Date Id Revision Rev Url
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.whiteboard.integration.helper;
+
+import javax.management.NotCompliantMBeanException;
+import javax.management.StandardMBean;
+
+public class TestStandardMBean extends StandardMBean implements TestClassMBean {
+
+    private final String instanceName;
+
+    protected TestStandardMBean() throws NotCompliantMBeanException {
+        this(null);
+    }
+
+    public TestStandardMBean(final String name)
+            throws NotCompliantMBeanException {
+        super(TestClassMBean.class);
+        this.instanceName = (name == null) ? getClass().getName() : name;
+    }
+
+    public String getInstanceName() {
+        return instanceName;
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper2/TestClass2.java b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper2/TestClass2.java
index e8961f8b..e0d7b61c 100644
--- a/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper2/TestClass2.java
+++ b/aries/branches/oct-2011-release/sandbox/jmx-next/jmx-whiteboard/src/test/java/org/apache/aries/jmx/whiteboard/integration/helper2/TestClass2.java
@@ -1,2 +1,40 @@
   + Author Date Id Revision Rev Url
   + native
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.jmx.whiteboard.integration.helper2;
+
+import org.apache.aries.jmx.whiteboard.integration.helper.TestClass;
+
+
+/**
+ * The <code>TestClass2</code> is a simple class which will be registered as a
+ * Simple MBean implementing the {@link TestClassMBean} interface.
+ */
+public class TestClass2 extends TestClass {
+
+    public TestClass2() {
+        this(null);
+    }
+
+    public TestClass2(final String name) {
+        super(name);
+    }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/AccountService.java b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/AccountService.java
index e69de29b..a472022d 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/AccountService.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/AccountService.java
@@ -0,0 +1,30 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.samples.bank.api; 
+
+public interface AccountService {
+
+	int open (String name);
+	String name(int accountNumber);
+	int balance (int accountNumber);
+	void deposit (int accountNumber, int funds);
+	void withdraw (int accountNumber, int funds);
+		
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/AccountServicesToOutsideWorld.java b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/AccountServicesToOutsideWorld.java
index e69de29b..7201e367 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/AccountServicesToOutsideWorld.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/AccountServicesToOutsideWorld.java
@@ -0,0 +1,34 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.samples.bank.api;
+
+/* Front end to WSDL and web clients */
+
+public interface AccountServicesToOutsideWorld
+{
+	int openChequingAccount (String name, int assets, int liabilities);
+	int openLineOfCreditAccount (String name, int assets, int liabilities);
+	
+	String name (int accountNumber);
+	int balance (int accountNumber);
+	void deposit (int accountNumber, int funds);
+	void withdraw (int accountNumber, int funds);
+	void transfer (int fromAccountNumber, int toAccountNumber, int funds);
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/ChequingAccountService.java b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/ChequingAccountService.java
index e69de29b..36c4fded 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/ChequingAccountService.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/ChequingAccountService.java
@@ -0,0 +1,24 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.samples.bank.api;
+
+public interface ChequingAccountService extends AccountService {
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/Constants.java b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/Constants.java
index e69de29b..e1607938 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/Constants.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/Constants.java
@@ -0,0 +1,27 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.samples.bank.api;
+
+public final class Constants {
+	public static final int CHEQUING_ACCOUNT_BASE = 1000;
+	public static final int CHEQUING_ACCOUNT_MAX = 1999;
+	public static final int LINEOFCREDIT_ACCOUNT_BASE = 2000;
+	public static final int LINEOFCREDIT_ACCOUNT_MAX = 2999;
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/CreditCheckService.java b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/CreditCheckService.java
index e69de29b..2ed4c9bc 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/CreditCheckService.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/CreditCheckService.java
@@ -0,0 +1,24 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.samples.bank.api;
+
+public interface CreditCheckService {
+  public double risk (String name, int assets, int liabilities);
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/LineOfCreditAccountService.java b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/LineOfCreditAccountService.java
index e69de29b..253d544a 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/LineOfCreditAccountService.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-api/src/main/java/org/apache/aries/samples/bank/api/LineOfCreditAccountService.java
@@ -0,0 +1,24 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.samples.bank.api;
+
+public interface LineOfCreditAccountService extends AccountService {
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-biz/src/main/java/org/apache/aries/samples/bank/biz/AccountServicesToOutsideWorldImpl.java b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-biz/src/main/java/org/apache/aries/samples/bank/biz/AccountServicesToOutsideWorldImpl.java
index e69de29b..b94a1735 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-biz/src/main/java/org/apache/aries/samples/bank/biz/AccountServicesToOutsideWorldImpl.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-biz/src/main/java/org/apache/aries/samples/bank/biz/AccountServicesToOutsideWorldImpl.java
@@ -0,0 +1,119 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.samples.bank.biz;
+
+import org.apache.aries.samples.bank.api.AccountService;
+import org.apache.aries.samples.bank.api.AccountServicesToOutsideWorld;
+import org.apache.aries.samples.bank.api.ChequingAccountService;
+import org.apache.aries.samples.bank.api.Constants;
+import org.apache.aries.samples.bank.api.CreditCheckService;
+import org.apache.aries.samples.bank.api.LineOfCreditAccountService;
+
+public class AccountServicesToOutsideWorldImpl implements AccountServicesToOutsideWorld {
+
+  private ChequingAccountService _chequingAccountService;
+  private LineOfCreditAccountService _lineOfCreditAccountService;
+  private CreditCheckService _creditCheckService;
+  private double _riskThreshold;
+
+  public void setChequingAccountService(ChequingAccountService c) {
+    _chequingAccountService = c;
+  }
+
+  public void setLineOfCreditAccountService(LineOfCreditAccountService l) {
+    _lineOfCreditAccountService = l;
+  }
+
+  public void setCreditCheckService(CreditCheckService c) {
+    _creditCheckService = c;
+  }
+
+  public void setRiskThreshold(double r) {
+    _riskThreshold = r;
+  }
+
+  private static final int NO_ACCOUNT = -1; 
+
+  @Override
+  public int openChequingAccount(String name, int assets, int liabilities) {
+    int accountNumber = _chequingAccountService.open(name);
+    System.out.println("AccountAccessServiceImpl.openChequingAccount(" + name + "," + assets + ","
+        + liabilities + ") = " + accountNumber);
+    return accountNumber;
+  }
+
+  @Override
+  public int openLineOfCreditAccount(String name, int assets, int liabilities) {
+    System.out.println("AccountAccessServiceImpl.openLineOfCreditAccount(" + name + "," + assets
+        + "," + liabilities + ") riskThreshold = " + _riskThreshold);
+    double risk = _creditCheckService.risk(name, assets, liabilities);
+    int accountNumber = NO_ACCOUNT;
+    if (risk < _riskThreshold)
+      accountNumber = _lineOfCreditAccountService.open(name);
+    System.out.println("AccountAccessServiceImpl.openLineOfCreditAccount(" + name + "," + assets
+        + "," + liabilities + ") = " + accountNumber);
+    return accountNumber;
+  }
+
+  @Override
+  public int balance(int accountNumber) {
+    int balance = accountServiceFor(accountNumber).balance(accountNumber);
+    System.out.println("AccountAccessServiceImpl.balance(" + accountNumber + ") = " + balance);
+    return balance;
+  }
+
+  @Override
+  public void deposit(int accountNumber, int funds) {
+    accountServiceFor(accountNumber).deposit(accountNumber, funds);
+    System.out.println("AccountAccessServiceImpl.deposit(" + accountNumber + "," + funds + ")");
+  }
+
+  @Override
+  public void withdraw(int accountNumber, int funds) {
+    accountServiceFor(accountNumber).withdraw(accountNumber, funds);
+    System.out.println("AccountAccessServiceImpl.withdraw(" + accountNumber + "," + funds + ")");
+  }
+
+  @Override
+  public void transfer(int fromAccountNumber, int toAccountNumber, int funds) {
+    withdraw(fromAccountNumber, funds);
+    deposit(toAccountNumber, funds);
+    System.out.println("AccountAccessServiceImpl.transfer(" + fromAccountNumber + ","
+        + toAccountNumber + "," + funds + ")");
+  }
+
+  @Override
+  public String name(int accountNumber) {
+    String result = accountServiceFor(accountNumber).name(accountNumber);
+    System.out.println("AccountServicesToOutsideWorldImpl.name(" + accountNumber + ") = " + result);
+    return result;
+  }
+
+  private AccountService accountServiceFor(int accountNumber) {
+    if (accountNumber >= Constants.CHEQUING_ACCOUNT_BASE
+        && accountNumber <= Constants.CHEQUING_ACCOUNT_MAX)
+      return _chequingAccountService;
+    else if (accountNumber >= Constants.LINEOFCREDIT_ACCOUNT_BASE
+        && accountNumber <= Constants.LINEOFCREDIT_ACCOUNT_MAX)
+      return _lineOfCreditAccountService;
+    else
+      return null;
+  }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-chequingAccount/src/main/java/org/apache/aries/samples/bank/chequingAccount/ChequingAccountServiceImpl.java b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-chequingAccount/src/main/java/org/apache/aries/samples/bank/chequingAccount/ChequingAccountServiceImpl.java
index e69de29b..f8c68159 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-chequingAccount/src/main/java/org/apache/aries/samples/bank/chequingAccount/ChequingAccountServiceImpl.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-chequingAccount/src/main/java/org/apache/aries/samples/bank/chequingAccount/ChequingAccountServiceImpl.java
@@ -0,0 +1,85 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.bank.chq;
+
+import org.apache.aries.samples.bank.api.ChequingAccountService;
+import org.apache.aries.samples.bank.api.Constants;
+
+/* This class is to become a Session Bean according to our original design. */
+
+public class ChequingAccountServiceImpl implements ChequingAccountService {
+
+	class AccountRecord { 
+		String name;
+		public String getName() {
+			return name;
+		}
+		int balance;
+		public int getBalance() {
+			return balance;
+		}
+		public void setBalance(int balance) {
+			this.balance = balance;
+		}
+		public AccountRecord (String name) {
+			this.name = name;
+			balance = 0;
+		}
+	}
+	
+	private static final int BASE = Constants.CHEQUING_ACCOUNT_BASE;
+	private static int nextAccount_ = BASE;
+	private static AccountRecord[] _accounts = new AccountRecord[10];
+
+	@Override
+	public int open(String name) {
+		int accountNumber = nextAccount_++;
+		_accounts[accountNumber-BASE] = new AccountRecord (name);
+		System.out.println("ChequingAccountServiceImpl.open() = "+accountNumber);
+		return accountNumber;
+	}
+
+	@Override
+	public int balance(int accountNumber) {
+		int balance = _accounts[accountNumber-BASE].getBalance();
+		System.out.println("ChequingAccountServiceImpl.balance("+accountNumber+") = "+balance);
+		return balance;
+	}
+
+	@Override
+	public void deposit(int accountNumber, int funds) {
+		AccountRecord record = _accounts[accountNumber-BASE];
+		record.setBalance(record.getBalance() + funds);
+		System.out.println("ChequingAccountServiceImpl.deposit("+accountNumber+","+funds+")");
+	}
+
+	@Override
+	public void withdraw(int accountNumber, int funds) {
+		AccountRecord record = _accounts[accountNumber-BASE];
+		record.setBalance(record.getBalance() - funds);
+		System.out.println("ChequingAccountServiceImpl.withdraw("+accountNumber+","+funds+")");
+	}
+
+	@Override
+	public String name(int accountNumber) {
+		String name =_accounts[accountNumber-BASE].getName();
+		System.out.println ("ChequingAccountServiceImpl.getName("+accountNumber+" = " + name);
+		return name;
+	}
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-creditCheck/src/main/java/org/apache/aries/samples/bank/creditCheck/CreditCheckServiceImpl.java b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-creditCheck/src/main/java/org/apache/aries/samples/bank/creditCheck/CreditCheckServiceImpl.java
index e69de29b..60a07d2f 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-creditCheck/src/main/java/org/apache/aries/samples/bank/creditCheck/CreditCheckServiceImpl.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-creditCheck/src/main/java/org/apache/aries/samples/bank/creditCheck/CreditCheckServiceImpl.java
@@ -0,0 +1,43 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.samples.bank.cc;
+
+import org.apache.aries.samples.bank.api.CreditCheckService;
+
+public class CreditCheckServiceImpl implements CreditCheckService {
+
+  private static final int MIN = -10000;
+  private static final int MAX = 10000;
+  
+  @Override
+  public double risk(String name, int assets, int liabilities) {
+    int equity = assets - liabilities;
+    double risk = 1.0;
+    if (equity <= MIN)
+      risk = 1.0;
+    else if (equity >= MAX)
+      risk = 0.0;
+    else
+      risk = ((double)(MAX-equity)) / (MAX-MIN);
+    System.out.println("EJB: CreditCheck.risk("+name+","+assets+","+liabilities+") = "+risk);
+    return risk;
+  }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-lineOfCreditAccount/src/main/java/org/apache/aries/samples/bank/lineOfCreditAccount/LineOfCreditAccountServiceImpl.java b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-lineOfCreditAccount/src/main/java/org/apache/aries/samples/bank/lineOfCreditAccount/LineOfCreditAccountServiceImpl.java
index e69de29b..4ff78af3 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-lineOfCreditAccount/src/main/java/org/apache/aries/samples/bank/lineOfCreditAccount/LineOfCreditAccountServiceImpl.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-lineOfCreditAccount/src/main/java/org/apache/aries/samples/bank/lineOfCreditAccount/LineOfCreditAccountServiceImpl.java
@@ -0,0 +1,86 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.bank.loc;
+
+import org.apache.aries.samples.bank.api.Constants;
+import org.apache.aries.samples.bank.api.LineOfCreditAccountService;
+
+// We could make an Abstract class to base this and ChequingAccountServiceImpl from if we decide
+// to keep those two classes around. 
+public class LineOfCreditAccountServiceImpl implements LineOfCreditAccountService {
+
+  class AccountRecord { 
+    String name;
+    public String getName() {
+      return name;
+    }
+    int balance;
+    public int getBalance() {
+      return balance;
+    }
+    public void setBalance(int balance) {
+      this.balance = balance;
+    }
+    public AccountRecord (String name) {
+      this.name = name;
+      balance = 0;
+    }
+  }
+  
+  private static final int BASE = Constants.LINEOFCREDIT_ACCOUNT_BASE;
+  private static int nextAccount_ = BASE;
+  private static AccountRecord[] _accounts = new AccountRecord[10];
+
+  @Override
+  public int open(String name) {
+    int accountNumber = nextAccount_++;
+    _accounts[accountNumber-BASE] = new AccountRecord (name);
+    System.out.println("LineOfCreditAccountServiceImpl.open() = "+accountNumber);
+    return accountNumber;
+  }
+
+  @Override
+  public int balance(int accountNumber) {
+    int balance = _accounts[accountNumber-BASE].getBalance();
+    System.out.println("LineOfCreditAccountServiceImpl.balance("+accountNumber+") = "+balance);
+    return balance;
+  }
+
+  @Override
+  public void deposit(int accountNumber, int funds) {
+    AccountRecord record = _accounts[accountNumber-BASE];
+    record.setBalance(record.getBalance() + funds);
+    System.out.println("LineOfCreditAccountServiceImpl.deposit("+accountNumber+","+funds+")");
+  }
+
+  @Override
+  public void withdraw(int accountNumber, int funds) {
+    AccountRecord record = _accounts[accountNumber-BASE];
+    record.setBalance(record.getBalance() - funds);
+    System.out.println("LineOfCreditAccountServiceImpl.withdraw("+accountNumber+","+funds+")");
+  }
+
+  @Override
+  public String name(int accountNumber) {
+    String name =_accounts[accountNumber-BASE].getName();
+    System.out.println ("LineOfCreditAccountServiceImpl.getName("+accountNumber+" = " + name);
+    return name;
+  }
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-web/src/main/java/org/apache/aries/samples/bank/web/CreateAccount.java b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-web/src/main/java/org/apache/aries/samples/bank/web/CreateAccount.java
index e69de29b..4c2e7773 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-web/src/main/java/org/apache/aries/samples/bank/web/CreateAccount.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-web/src/main/java/org/apache/aries/samples/bank/web/CreateAccount.java
@@ -0,0 +1,81 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.samples.bank.web;
+
+import java.io.IOException;
+import java.io.Writer;
+
+import javax.naming.InitialContext;
+import javax.naming.NamingException;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.aries.samples.bank.api.AccountServicesToOutsideWorld;
+
+/**
+ * Servlet implementation class CreateAccount
+ */
+public class CreateAccount extends HttpServlet {
+	private static final long serialVersionUID = 1L;
+       
+ 	/**
+	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
+	 */
+	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
+
+		String name = request.getParameter("name");
+		int assets = Integer.parseInt(request.getParameter("assets"));
+		int liabilities = Integer.parseInt(request.getParameter("liabilities"));
+		String accountType = request.getParameter("accountType");
+		Writer writer = response.getWriter();
+		
+		AccountServicesToOutsideWorld accAccess;
+		try { 
+			InitialContext ic = new InitialContext();
+			accAccess = (AccountServicesToOutsideWorld) ic.lookup
+			  ("osgi:service/" + AccountServicesToOutsideWorld.class.getName());
+		} catch (NamingException nx) { 
+			throw new ServletException (nx);
+		}
+		
+		int newAccountNumber;
+		if (accAccess != null) { 
+			if (accountType.equals("Chequing")) { 
+				newAccountNumber = accAccess.openChequingAccount(name, assets, liabilities);
+			} else { 
+				newAccountNumber = accAccess.openLineOfCreditAccount(name, assets, liabilities);
+			}
+			
+			writer.write("<html><head></head><body>");
+			if (newAccountNumber >= 0) { 
+				writer.write ("Successfully opened <a href=\"ViewAccount?accountNumber=" + newAccountNumber 
+						+ "\">Account number " + newAccountNumber + "</a>");
+			} else { 
+				writer.write ("New account request denied: computer says no.");
+			}
+		} else { 
+			writer.write("<br/>INTERNAL ERROR: Unable to find AccountAccessService");
+		}
+		writer.write("<br/><br/><a href=\"index.html\">back to main menu</a></body></html>");
+	}
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-web/src/main/java/org/apache/aries/samples/bank/web/ViewAccount.java b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-web/src/main/java/org/apache/aries/samples/bank/web/ViewAccount.java
index e69de29b..ad5fb6f8 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/bank/bank-web/src/main/java/org/apache/aries/samples/bank/web/ViewAccount.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/bank/bank-web/src/main/java/org/apache/aries/samples/bank/web/ViewAccount.java
@@ -0,0 +1,106 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.bank.web;
+
+import java.io.IOException;
+import java.io.Writer;
+
+import javax.naming.InitialContext;
+import javax.naming.NamingException;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.aries.samples.bank.api.AccountServicesToOutsideWorld;
+
+/**
+ * Servlet implementation class ViewAccount
+ */
+public class ViewAccount extends HttpServlet {
+  private static final long serialVersionUID = 1L;
+
+  protected void doGet(HttpServletRequest request, HttpServletResponse response)
+      throws ServletException, IOException {
+    process(request, response);
+  }
+
+  /**
+   * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse
+   *      response)
+   */
+  protected void doPost(HttpServletRequest request, HttpServletResponse response)
+      throws ServletException, IOException {
+    process(request, response);
+  }
+
+  private void process(HttpServletRequest request, HttpServletResponse response)
+      throws ServletException, IOException {
+    int accountNumber = Integer.parseInt(request.getParameter("accountNumber"));
+    Writer writer = response.getWriter();
+    writer.write("<html><head></head><body>");
+
+    AccountServicesToOutsideWorld accAccess;
+    try {
+      InitialContext ic = new InitialContext();
+      accAccess = (AccountServicesToOutsideWorld) ic.lookup("osgi:service/"
+          + AccountServicesToOutsideWorld.class.getName());
+    } catch (NamingException nx) {
+      throw new ServletException(nx);
+    }
+
+    if (accAccess != null) {
+      String operation = request.getParameter("operation");
+      if (operation != null) {
+        int amount = Integer.parseInt(request.getParameter("amount"));
+        if (operation.equals("deposit")) {
+          accAccess.deposit(accountNumber, amount);
+        } else if (operation.equals("withdraw")) {
+          accAccess.withdraw(accountNumber, amount);
+        } else {
+          System.out.println("Unknown operation " + operation
+              + " in ViewAccount");
+        }
+      }
+
+      String name = accAccess.name(accountNumber);
+      int balance = accAccess.balance(accountNumber);
+      writer.write("<br/>Account " + accountNumber + " name `"
+          + name + "` balance: " + balance);
+      
+      // Deposit or withdraw
+      writer.write("<form action=\"ViewAccount\" method=\"POST\">");
+      writer.write("<input type=\"hidden\" name=\"accountNumber\" value=\""
+          + accountNumber + "\"/>");
+      writer.write("<select name=\"operation\"><option value=\"deposit\">deposit</option>");
+      writer.write("<option value=\"withdraw\">withdraw</option></select>");
+      writer.write("<input name=\"amount\" type=\"text\"/>");
+      writer.write("<input type=\"submit\" value=\"submit request\" /></form>");
+
+      //TODO: transfer
+      writer.write("<br/>TODO: Form to make a transfer goes here<br/>");
+      writer.write("<a href=\"index.html\">back to main menu</a>");
+    } else {
+      writer.write("<br/>ERROR: Unable to find AccountAccessService");
+    }
+   
+    writer.write("</body></html>");
+    writer.close();
+  }
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ComponentInfo.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ComponentInfo.java
index e69de29b..11474b7f 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ComponentInfo.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ComponentInfo.java
@@ -0,0 +1,43 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.api;
+
+import java.util.List;
+import java.util.Map;
+
+public interface ComponentInfo {
+   String getId();
+   /**
+    * always needed, id's must be unique globally, or within their containing component info.
+    * (impl notes.. (for bundles)
+    * Id's will probably NOT be bundle id's... we need the id to be fixed between framework restarts,
+    * to enable things like storing coords for onscreen renderings of components
+    * Id's will probably end up being path based, /component.id/component.id etc .. for sanities sake.
+    * Component properties are information that forms part of a component, keys will vary depending on 
+    * what the component represents. The GUI will handle rendering based on key names.
+    */
+   Map<String,String> getComponentProperties();
+
+   
+   /**
+	* children are only supported in concept currently.. no gui work done yet for them..   
+    * List of any contained components for this component.    
+    */
+   List<ComponentInfo> getChildren(); 
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ComponentInfoProvider.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ComponentInfoProvider.java
index 9e1dca2a..6533c363 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ComponentInfoProvider.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ComponentInfoProvider.java
@@ -1 +1,77 @@
   + target
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.api;
+
+import java.util.Collection;
+
+/**
+ * Provides information about components within a model.
+ * 
+ * Good usage practice would be to subscribe a listener .. and THEN call
+ * getComponents.. (doing it the other way round risks leaving a window during
+ * which a change could occur, and you not be informed). (doing it this way
+ * round, at worst, you'll see an update before you handle getComponents, and
+ * since an update can be an add, you'll just process it twice)
+ * 
+ */
+public interface ComponentInfoProvider {
+
+	/**
+	 * Callback interface implemented by users of the ComponentInfoProvider
+	 * interface, allowing notification of changes, or deletions to components
+	 * they have been informed about.
+	 */
+	static interface ComponentInfoListener {
+		// called to add, or update a component.
+		public void updateComponent(ComponentInfo b);
+
+		public void removeComponent(ComponentInfo b);
+	};
+
+	/**
+	 * Gets the current set of 'top level' components in this model.
+	 * 
+	 * Any nested components are only obtainable via the 'getChildren' method on
+	 * ComponentInfo.
+	 * 
+	 * @return
+	 */
+	Collection<ComponentInfo> getComponents();
+
+	/**
+	 * Gets a component for an id previously returned via getComponents, or
+	 * updateComponent
+	 * 
+	 * @param id
+	 * @return component, or null if component id is either unknown, or deleted.
+	 */
+	ComponentInfo getComponentForId(String id);
+
+	/**
+	 * Add a listener to this Info Provider, to be informed of
+	 * changes/deletions.
+	 * 
+	 * @param listener
+	 */
+	public void registerComponentInfoListener(ComponentInfoListener listener);
+
+	// TODO: unregisterComponentInfoListener ;-)
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ModelInfoService.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ModelInfoService.java
index e69de29b..a4ed520d 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ModelInfoService.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ModelInfoService.java
@@ -0,0 +1,30 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.api;
+
+/**
+ * The top level service interface published to the service registry
+ *
+ * A model is something with components, with relationships between them.
+ */
+public interface ModelInfoService {
+	String getName();
+	ComponentInfoProvider getComponentInfoProvider();
+	RelationshipInfoProvider getRelationshipInfoProvider();
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ParameterizedRelationshipAspect.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ParameterizedRelationshipAspect.java
index e69de29b..722fe18d 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ParameterizedRelationshipAspect.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/ParameterizedRelationshipAspect.java
@@ -0,0 +1,30 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.api;
+
+import java.util.List;
+
+public interface ParameterizedRelationshipAspect extends RelationshipAspect{
+	   static class Parameter{
+		   String key;
+		   String value;
+	   };
+	   List<Parameter> getProvidedParameters(); //any parameters specified by the supplier of the dependency.
+	   List<Parameter> getConsumedParameters(); //any parameters specified by the consumer of the dependency.
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/RelationshipAspect.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/RelationshipAspect.java
index e69de29b..a08e0fc6 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/RelationshipAspect.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/RelationshipAspect.java
@@ -0,0 +1,23 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.api;
+
+public interface RelationshipAspect {
+	public String getType();
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/RelationshipInfo.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/RelationshipInfo.java
index e69de29b..4f2a6321 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/RelationshipInfo.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/RelationshipInfo.java
@@ -0,0 +1,38 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.api;
+
+import java.util.List;
+
+//This represents a single dependency between two components
+public interface RelationshipInfo {
+	
+	   //relationships are unique by type&name combined.
+	
+	   String getType(); //String describing the type of this dependency.		   
+	   String getName();  //name of this dependency.
+	   
+	   //the provider/consumer side of this relationship.
+	   ComponentInfo getProvidedBy();	   
+	   //consumers can of course, be empty. (thats empty.. NOT null)
+	   List<ComponentInfo> getConsumedBy();
+	   
+	   //relationship aspects are not fully integrated yet.. avoid until stable ;-)
+	   List<RelationshipAspect> getRelationshipAspects();   
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/RelationshipInfoProvider.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/RelationshipInfoProvider.java
index e69de29b..345e9c0f 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/RelationshipInfoProvider.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/RelationshipInfoProvider.java
@@ -0,0 +1,34 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.api;
+
+import java.util.Collection;
+
+public interface RelationshipInfoProvider {
+	static interface RelationshipInfoListener {
+		public void updateRelationship(RelationshipInfo b);
+
+		public void removeRelationship(RelationshipInfo b);
+	};
+
+	Collection<RelationshipInfo> getRelationships();
+
+	public void registerRelationshipInfoListener(
+			RelationshipInfoListener listener);
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/VersionedRelationshipAspect.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/VersionedRelationshipAspect.java
index e69de29b..27824f7d 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/VersionedRelationshipAspect.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/api/VersionedRelationshipAspect.java
@@ -0,0 +1,25 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.api;
+
+public interface VersionedRelationshipAspect extends RelationshipAspect {
+	   String getProvidedVersion(); //this will be an exact version.
+	   String getConsumedVersion(); //this will be either a range, or an exact version. 
+	                                //provided version will either match, or be in the range.
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/info/ComponentInfoImpl.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/info/ComponentInfoImpl.java
index e69de29b..2fd0c18a 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/info/ComponentInfoImpl.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/info/ComponentInfoImpl.java
@@ -0,0 +1,49 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.info;
+
+import java.util.List;
+import java.util.Map;
+import org.apache.aries.samples.goat.api.ComponentInfo;
+
+public class ComponentInfoImpl implements ComponentInfo {
+
+	List<ComponentInfo> children;
+	Map<String,String> componentProperties;
+	String id;
+	public List<ComponentInfo> getChildren() {
+		return children;
+	}
+	public void setChildren(List<ComponentInfo> children) {
+		this.children = children;
+	}
+	public Map<String, String> getComponentProperties() {
+		return componentProperties;
+	}
+	public void setComponentProperties(Map<String, String> componentProperties) {
+		this.componentProperties = componentProperties;
+	}
+	public String getId() {
+		return id;
+	}
+	public void setId(String id) {
+		this.id = id;
+	}
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/info/RelationshipInfoImpl.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/info/RelationshipInfoImpl.java
index e69de29b..75a19c13 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/info/RelationshipInfoImpl.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-api/src/main/java/org/apache/aries/samples/goat/info/RelationshipInfoImpl.java
@@ -0,0 +1,62 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.info;
+import java.util.List;
+import org.apache.aries.samples.goat.api.RelationshipInfo;
+import org.apache.aries.samples.goat.api.RelationshipAspect;
+import org.apache.aries.samples.goat.api.ComponentInfo;;
+
+public class RelationshipInfoImpl implements RelationshipInfo {
+	List<ComponentInfo> consumedBy;
+	List<RelationshipAspect> relationshipAspects;
+	String name;
+	ComponentInfo providedBy;
+	String type;
+	public List<ComponentInfo> getConsumedBy() {
+		return consumedBy;
+	}
+	public void setConsumedBy(List<ComponentInfo> consumedBy) {
+		this.consumedBy = consumedBy;
+	}
+	public List<RelationshipAspect> getRelationshipAspects() {
+		return relationshipAspects;
+	}
+	public void setRelationshipAspects(List<RelationshipAspect> relationshipAspects) {
+		this.relationshipAspects = relationshipAspects;
+	}
+	public String getName() {
+		return name;
+	}
+	public void setName(String name) {
+		this.name = name;
+	}
+	public ComponentInfo getProvidedBy() {
+		return providedBy;
+	}
+	public void setProvidedBy(ComponentInfo providedBy) {
+		this.providedBy = providedBy;
+	}
+	public String getType() {
+		return type;
+	}
+	public void setType(String type) {
+		this.type = type;
+	}
+	
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-bundlecontext-modelprovider/src/main/java/org/apache/aries/samples/goat/bundlecontextmodel/BundleContextInfoProvider.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-bundlecontext-modelprovider/src/main/java/org/apache/aries/samples/goat/bundlecontextmodel/BundleContextInfoProvider.java
index e69de29b..1d704ecd 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-bundlecontext-modelprovider/src/main/java/org/apache/aries/samples/goat/bundlecontextmodel/BundleContextInfoProvider.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-bundlecontext-modelprovider/src/main/java/org/apache/aries/samples/goat/bundlecontextmodel/BundleContextInfoProvider.java
@@ -0,0 +1,297 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.bundlecontextmodel;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.BundleEvent;
+import org.osgi.framework.BundleListener;
+import org.osgi.framework.ServiceEvent;
+import org.osgi.framework.ServiceListener;
+import org.osgi.framework.ServiceReference;
+import org.osgi.service.packageadmin.ExportedPackage;
+import org.osgi.service.packageadmin.PackageAdmin;
+
+import org.apache.aries.samples.goat.info.ComponentInfoImpl;
+import org.apache.aries.samples.goat.info.RelationshipInfoImpl;
+
+import org.apache.aries.samples.goat.api.ComponentInfo;
+import org.apache.aries.samples.goat.api.ComponentInfoProvider;
+import org.apache.aries.samples.goat.api.ModelInfoService;
+import org.apache.aries.samples.goat.api.RelationshipAspect;
+import org.apache.aries.samples.goat.api.RelationshipInfo;
+import org.apache.aries.samples.goat.api.RelationshipInfoProvider;
+
+public class BundleContextInfoProvider implements ModelInfoService, RelationshipInfoProvider, ComponentInfoProvider, BundleListener, ServiceListener {
+	
+	private Map<String, ComponentInfo>biCache = new HashMap<String,ComponentInfo>();
+	
+	private Map<String, RelationshipInfo>riCache = new HashMap<String,RelationshipInfo>();
+	
+	private List<ComponentInfoListener> clisteners=null;
+	private List<RelationshipInfoListener> rlisteners=null;
+
+	private BundleContext ctx=null;
+	
+	public BundleContextInfoProvider(BundleContext ctx){
+		System.err.println("BCIP built!");
+		this.ctx = ctx;
+		this.clisteners = Collections.synchronizedList(new ArrayList<ComponentInfoListener>());
+		this.rlisteners = Collections.synchronizedList(new ArrayList<RelationshipInfoListener>());
+		this.ctx.addBundleListener(this);		
+		this.ctx.addServiceListener(this);		
+	}
+	
+	
+
+	public List<ComponentInfo> getComponents() {
+		System.err.println("BCIP getBundles called");
+		Bundle[] bundles = this.ctx.getBundles();
+		List<ComponentInfo> result = new ArrayList<ComponentInfo>();
+		
+		for(int i=0; i<bundles.length; i++){
+			System.err.println("BCIP converting "+i);
+			result.add( getComponentForId( getKeyForBundle(bundles[i])) );
+		}
+
+		System.err.println("BCIP returning data");
+		return result;
+	}
+
+
+	public void registerComponentInfoListener(ComponentInfoListener listener) {
+		clisteners.add(listener);
+	}
+	
+	public void registerRelationshipInfoListener(RelationshipInfoListener listener) {
+		rlisteners.add(listener);
+	}
+
+	
+	private Bundle getBundleForIDKey(BundleContext ctx, String id){
+		String s =id.substring("/root/".length());
+		Long l = Long.parseLong(s);
+		return ctx.getBundle(l.longValue());
+	}
+
+	private String bundleStateToString(int bundleState){
+		switch(bundleState){
+		case Bundle.UNINSTALLED : return "UNINSTALLED";
+		case Bundle.INSTALLED : return "INSTALLED";
+		case Bundle.RESOLVED : return "RESOLVED";
+		case Bundle.STARTING : return "STARTING";
+		case Bundle.STOPPING : return "STOPPING";
+		case Bundle.ACTIVE : return "ACTIVE";
+		default : return "UNKNOWN["+bundleState+"]";
+		}
+	} 
+	
+	public ComponentInfo getComponentForId(String id) {
+		if(biCache.containsKey(id)){
+			return biCache.get(id);
+		}
+		
+		Bundle b = getBundleForIDKey(ctx,id);		
+		ComponentInfoImpl bii = new ComponentInfoImpl();
+		
+		bii.setId(getKeyForBundle(b));
+		
+		HashSet<Long> allDepSet = new HashSet<Long>();
+		
+		bii.setComponentProperties(new HashMap<String,String>());
+		
+		bii.getComponentProperties().put("BundleID", ""+b.getBundleId());
+		bii.getComponentProperties().put("State", bundleStateToString(b.getState()));
+		bii.getComponentProperties().put("SymbolicName", b.getSymbolicName());
+		bii.getComponentProperties().put("Version", ""+b.getVersion());
+		
+		Enumeration<String> e = b.getHeaders().keys();
+		while(e.hasMoreElements()){
+			String key = e.nextElement();
+
+			//Ideally we'd add everything here.. but until we add the filtering in the ui
+			//its easier to just filter here.. for now, all 'extra' properties are removed.
+
+			if(! (key.equals("Import-Package") || key.equals("Export-Package")) ){
+			  //bii.getComponentProperties().put(key, String.valueOf(b.getHeaders().get(key)));
+			}
+		}
+		
+		bii.setChildren(new ArrayList<ComponentInfo>());
+		
+		biCache.put(id, bii);		
+		return bii;
+	}
+
+
+
+	public void bundleChanged(BundleEvent arg0) {
+		String id = getKeyForBundle(arg0.getBundle());
+		if(biCache.containsKey(id)){
+			biCache.remove(id);
+		}
+
+		ComponentInfo bi = getComponentForId(getKeyForBundle(arg0.getBundle()));
+		
+		for(ComponentInfoListener bil : clisteners){
+			bil.updateComponent(bi);
+		}
+		
+	}
+
+	private String getKeyForBundle(Bundle b){
+		return "/root/"+b.getBundleId();
+	}
+
+	@Override
+	public List<RelationshipInfo> getRelationships() {
+		
+		ArrayList<RelationshipInfo> r = new ArrayList<RelationshipInfo>();
+		
+		Bundle bundles[] = ctx.getBundles();
+		PackageAdmin pa = (PackageAdmin)ctx.getService(ctx.getServiceReference(PackageAdmin.class.getName().toString()));
+		
+		if(bundles!=null && bundles.length!=0){
+			for(Bundle b: bundles){
+				String bkey = getKeyForBundle(b);
+				ComponentInfo ci = getComponentForId(bkey);
+				
+				//add all the packages..
+				//we only add exports, as imports are implied in the reverse
+				ExportedPackage eps[] = pa.getExportedPackages(b);
+				if(eps!=null && eps.length!=0){
+					for(ExportedPackage ep : eps){
+						RelationshipInfoImpl ri = new RelationshipInfoImpl();
+						ri.setProvidedBy( ci );
+						ri.setType("Package");
+						ri.setName(ep.getName());
+						ri.setRelationshipAspects(new ArrayList<RelationshipAspect>());
+						ri.setConsumedBy(new ArrayList<ComponentInfo>());
+						//TODO: add versioning aspect.
+						Bundle imps[] = ep.getImportingBundles();
+						if(imps!=null && imps.length!=0){
+							for(Bundle imp : imps){
+								ri.getConsumedBy().add(getComponentForId(getKeyForBundle(imp)));
+							}
+						}
+						r.add(ri);						
+					}
+				}
+			
+				//add all the services.. 
+				//we only add registered services, as ones in use are handled in the reverse
+				ServiceReference srs[] = b.getRegisteredServices();
+				if(srs!=null && srs.length!=0){
+					for(ServiceReference sr : srs){	
+						RelationshipInfoImpl ri = getRIforSR(sr);
+						ri.setProvidedBy( ci );
+						r.add(ri);
+					}
+				}
+				
+			}
+		}
+		
+		
+		return r;
+	}
+
+    private RelationshipInfoImpl getRIforSR(ServiceReference sr){
+		RelationshipInfoImpl ri = new RelationshipInfoImpl();
+		ri.setType("Service");
+		String serviceNames="";
+		String []objectClasses = (String[])sr.getProperty("objectClass");
+		if(objectClasses!=null){
+			for(String objectClass : objectClasses){
+				serviceNames+=","+objectClass;
+			}
+		}
+		if(serviceNames.length()>1){
+			serviceNames = serviceNames.substring(1);
+		}
+		
+		ri.setName(serviceNames);
+		ri.setRelationshipAspects(new ArrayList<RelationshipAspect>());
+		//TODO: add service parameters
+		ri.setConsumedBy(new ArrayList<ComponentInfo>());
+		
+		Bundle using[] = sr.getUsingBundles();
+		if(using!=null && using.length!=0){
+			for(Bundle u : using){
+				ri.getConsumedBy().add(getComponentForId(getKeyForBundle(u)));
+			}
+		}
+        return ri;
+    }
+
+	@Override
+	public String getName() {
+		return "Bundle Context Info Provider 1.0";
+	}
+
+
+
+	@Override
+	public ComponentInfoProvider getComponentInfoProvider() {
+		return this;
+	}
+
+
+
+	@Override
+	public RelationshipInfoProvider getRelationshipInfoProvider() {
+		return this;
+	}
+
+
+
+	@Override
+	public void serviceChanged(ServiceEvent arg0) {
+		if(arg0.getType() == ServiceEvent.REGISTERED || arg0.getType() == ServiceEvent.MODIFIED || arg0.getType() == ServiceEvent.MODIFIED_ENDMATCH){
+			ServiceReference sr = arg0.getServiceReference();
+			RelationshipInfoImpl ri = getRIforSR(sr);
+			ComponentInfo ci = getComponentForId(getKeyForBundle(sr.getBundle()));
+			ri.setProvidedBy(ci);
+			
+			for(RelationshipInfoListener ril : rlisteners){
+				ril.updateRelationship(ri);
+			}
+		}else if(arg0.getType() == ServiceEvent.UNREGISTERING){
+			ServiceReference sr = arg0.getServiceReference();
+			RelationshipInfoImpl ri = getRIforSR(sr);
+			ComponentInfo ci = getComponentForId(getKeyForBundle(sr.getBundle()));
+			ri.setProvidedBy(ci);
+			
+			for(RelationshipInfoListener ril : rlisteners){
+				ril.removeRelationship(ri);
+			}			
+		}
+		
+
+	}
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyInfoProvider.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyInfoProvider.java
index e69de29b..8a87f00b 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyInfoProvider.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyInfoProvider.java
@@ -0,0 +1,88 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.dummy;
+
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.aries.samples.goat.info.ComponentInfoImpl;
+
+import org.apache.aries.samples.goat.api.ComponentInfo;
+import org.apache.aries.samples.goat.api.ComponentInfoProvider;
+
+public class DummyInfoProvider implements ComponentInfoProvider {
+	
+	ComponentInfoImpl a = new ComponentInfoImpl();
+	ComponentInfoImpl b = new ComponentInfoImpl();
+	ComponentInfoImpl c = new ComponentInfoImpl();
+		
+	public DummyInfoProvider(){
+				
+		a.setId("/root/"+1);
+		Map<String,String> props = new HashMap<String,String>();
+		props.put("SymbolicName", "Uber.Bundle");
+		props.put("Version", "1.0.0");
+		props.put("State", "ACTIVE");
+		props.put("BundleID", "1");
+		a.setComponentProperties(props);
+		
+		b.setId("/root/"+2);
+		props = new HashMap<String,String>();
+		props.put("SymbolicName", "Fred");
+		props.put("Version", "1.0.0");
+		props.put("State", "RESOLVED");
+		props.put("BundleID", "2");
+		b.setComponentProperties(props);
+		
+		c.setId("/root/"+3);
+		props = new HashMap<String,String>();
+		props.put("SymbolicName", "Wilma");
+		props.put("Version", "1.0.0");
+		props.put("State", "ACTIVE");
+		props.put("BundleID", "3");
+		c.setComponentProperties(props);
+	}
+
+	@Override
+	public List<ComponentInfo> getComponents() {
+		List<ComponentInfo> result = new ArrayList<ComponentInfo>();
+		result.add(a);
+		result.add(b);
+		result.add(c);
+		return result;
+	}
+
+	@Override
+	public ComponentInfo getComponentForId(String id) {
+		if("/root/1".equals(id)) return a;
+		if("/root/2".equals(id)) return b;
+		if("/root/3".equals(id)) return c;
+		return null;
+	}
+
+	@Override
+	public void registerComponentInfoListener(ComponentInfoListener listener) {
+		//no-op
+	}
+
+}
+
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyModelService.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyModelService.java
index e69de29b..1a4930b4 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyModelService.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyModelService.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.dummy;
+
+import org.apache.aries.samples.goat.api.ComponentInfoProvider;
+import org.apache.aries.samples.goat.api.ModelInfoService;
+import org.apache.aries.samples.goat.api.RelationshipInfoProvider;
+
+public class DummyModelService implements ModelInfoService {
+
+	private final static ComponentInfoProvider cip = new DummyInfoProvider();
+	private final static RelationshipInfoProvider rip = new DummyRelationshipProvider(cip);
+	
+	@Override
+	public String getName() {
+		return "Dummy Model Service";
+	}
+
+	@Override
+	public ComponentInfoProvider getComponentInfoProvider() {
+		return cip;
+	}
+
+	@Override
+	public RelationshipInfoProvider getRelationshipInfoProvider() {
+		return rip;
+	}
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyRelationshipProvider.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyRelationshipProvider.java
index e69de29b..441fbd16 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyRelationshipProvider.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyRelationshipProvider.java
@@ -0,0 +1,112 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.dummy;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.aries.samples.goat.info.RelationshipInfoImpl;
+
+import org.apache.aries.samples.goat.api.ComponentInfo;
+import org.apache.aries.samples.goat.api.ComponentInfoProvider;
+import org.apache.aries.samples.goat.api.RelationshipInfo;
+import org.apache.aries.samples.goat.api.RelationshipInfoProvider;
+
+public class DummyRelationshipProvider implements RelationshipInfoProvider {
+
+	ComponentInfoProvider cip = null;
+	
+	public DummyRelationshipProvider(ComponentInfoProvider cip){
+		this.cip = cip;
+	}
+	
+	@Override
+	public List<RelationshipInfo> getRelationships() {
+		
+		ArrayList<RelationshipInfo> ris = new ArrayList<RelationshipInfo>();
+		
+		ComponentInfo ci1 = cip.getComponentForId("/root/1");
+		ComponentInfo ci2 = cip.getComponentForId("/root/2");
+		ComponentInfo ci3 = cip.getComponentForId("/root/3");
+		
+		RelationshipInfoImpl ri1 = new RelationshipInfoImpl();
+		RelationshipInfoImpl ri2 = new RelationshipInfoImpl();
+		RelationshipInfoImpl ri3 = new RelationshipInfoImpl();
+		RelationshipInfoImpl ri4 = new RelationshipInfoImpl();
+		RelationshipInfoImpl ri5 = new RelationshipInfoImpl();
+		RelationshipInfoImpl ri6 = new RelationshipInfoImpl();
+		ris.add(ri1);
+		ris.add(ri2);
+		ris.add(ri3);
+		ris.add(ri4);
+		ris.add(ri5);
+		ris.add(ri6);
+		
+		ri1.setName("i.am.exported.by.1.and.used.by.2.and.3");
+		ri1.setProvidedBy(ci1);
+		ArrayList<ComponentInfo> c = new ArrayList<ComponentInfo>();
+		c.add(ci2);
+		c.add(ci3);
+		ri1.setConsumedBy(c);
+		ri1.setType("Package"); 
+		
+		ri2.setName("i.am.exported.by.1.and.used.by.3");
+		ri2.setProvidedBy(ci1);
+		c = new ArrayList<ComponentInfo>();
+		c.add(ci3);
+		ri2.setConsumedBy(c);
+		ri2.setType("Package"); 
+		
+		ri3.setName("i.am.exported.by.2.and.used.by.3");
+		ri3.setProvidedBy(ci2);
+		c = new ArrayList<ComponentInfo>();
+		c.add(ci3);
+		ri3.setConsumedBy(c);
+		ri3.setType("Package"); 
+		
+		ri4.setName("i.am.exported.by.3.and.used.by.2");
+		ri4.setProvidedBy(ci3);
+		c = new ArrayList<ComponentInfo>();
+		c.add(ci2);
+		ri4.setConsumedBy(c);
+		ri4.setType("Package"); 
+
+		ri5.setName("i.am.a.funky.service.from.3.used.by.2");
+		ri5.setProvidedBy(ci3);
+		c = new ArrayList<ComponentInfo>();
+		c.add(ci2);
+		ri5.setConsumedBy(c);
+		ri5.setType("Service");
+		
+		ri6.setName("i.am.a.funky.service.from.1.used.by.2");
+		ri6.setProvidedBy(ci1);
+		c = new ArrayList<ComponentInfo>();
+		c.add(ci2);
+		ri6.setConsumedBy(c);
+		ri6.setType("Service");
+		return ris;
+	}
+
+	@Override
+	public void registerRelationshipInfoListener(RelationshipInfoListener listener) {
+		// TODO Auto-generated method stub
+
+	}
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy2-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyInfoProvider.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy2-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyInfoProvider.java
index e69de29b..a5deabd6 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy2-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyInfoProvider.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy2-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyInfoProvider.java
@@ -0,0 +1,88 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.dummy2;
+
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.aries.samples.goat.info.ComponentInfoImpl;
+
+import org.apache.aries.samples.goat.api.ComponentInfo;
+import org.apache.aries.samples.goat.api.ComponentInfoProvider;
+
+public class DummyInfoProvider implements ComponentInfoProvider {
+	
+	ComponentInfoImpl a = new ComponentInfoImpl();
+	ComponentInfoImpl b = new ComponentInfoImpl();
+	ComponentInfoImpl c = new ComponentInfoImpl();
+		
+	public DummyInfoProvider(){
+				
+		a.setId("/root/"+1);
+		Map<String,String> props = new HashMap<String,String>();
+		props.put("SymbolicName", "Mickey.Bundle");
+		props.put("Version", "1.0.0");
+		props.put("State", "RESOLVED");
+		props.put("BundleID", "1");
+		a.setComponentProperties(props);
+		
+		b.setId("/root/"+2);
+		props = new HashMap<String,String>();
+		props.put("SymbolicName", "Mouse");
+		props.put("Version", "1.0.0");
+		props.put("State", "ACTIVE");
+		props.put("BundleID", "2");
+		b.setComponentProperties(props);
+		
+		c.setId("/root/"+3);
+		props = new HashMap<String,String>();
+		props.put("SymbolicName", "Barney");
+		props.put("Version", "1.0.0");
+		props.put("State", "ACTIVE");
+		props.put("BundleID", "3");
+		c.setComponentProperties(props);
+	}
+
+	@Override
+	public List<ComponentInfo> getComponents() {
+		List<ComponentInfo> result = new ArrayList<ComponentInfo>();
+		result.add(a);
+		result.add(b);
+		result.add(c);
+		return result;
+	}
+
+	@Override
+	public ComponentInfo getComponentForId(String id) {
+		if("/root/1".equals(id)) return a;
+		if("/root/2".equals(id)) return b;
+		if("/root/3".equals(id)) return c;
+		return null;
+	}
+
+	@Override
+	public void registerComponentInfoListener(ComponentInfoListener listener) {
+		//no-op
+	}
+
+}
+
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy2-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyModelService2.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy2-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyModelService2.java
index e69de29b..0faabe50 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy2-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyModelService2.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy2-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyModelService2.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.dummy2;
+
+import org.apache.aries.samples.goat.api.ComponentInfoProvider;
+import org.apache.aries.samples.goat.api.ModelInfoService;
+import org.apache.aries.samples.goat.api.RelationshipInfoProvider;
+
+public class DummyModelService2 implements ModelInfoService {
+
+	private final static ComponentInfoProvider cip = new DummyInfoProvider();
+	private final static RelationshipInfoProvider rip = new DummyRelationshipProvider(cip);
+	
+	@Override
+	public String getName() {
+		return "Dummy Model Service";
+	}
+
+	@Override
+	public ComponentInfoProvider getComponentInfoProvider() {
+		return cip;
+	}
+
+	@Override
+	public RelationshipInfoProvider getRelationshipInfoProvider() {
+		return rip;
+	}
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy2-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyRelationshipProvider.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy2-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyRelationshipProvider.java
index e69de29b..71aec4ba 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy2-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyRelationshipProvider.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-dummy2-provider/src/main/java/org/apache/aries/samples/goat/dummy/DummyRelationshipProvider.java
@@ -0,0 +1,112 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.dummy2;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.aries.samples.goat.info.RelationshipInfoImpl;
+
+import org.apache.aries.samples.goat.api.ComponentInfo;
+import org.apache.aries.samples.goat.api.ComponentInfoProvider;
+import org.apache.aries.samples.goat.api.RelationshipInfo;
+import org.apache.aries.samples.goat.api.RelationshipInfoProvider;
+
+public class DummyRelationshipProvider implements RelationshipInfoProvider {
+
+	ComponentInfoProvider cip = null;
+	
+	public DummyRelationshipProvider(ComponentInfoProvider cip){
+		this.cip = cip;
+	}
+	
+	@Override
+	public List<RelationshipInfo> getRelationships() {
+		
+		ArrayList<RelationshipInfo> ris = new ArrayList<RelationshipInfo>();
+		
+		ComponentInfo ci1 = cip.getComponentForId("/root/1");
+		ComponentInfo ci2 = cip.getComponentForId("/root/2");
+		ComponentInfo ci3 = cip.getComponentForId("/root/3");
+		
+		RelationshipInfoImpl ri1 = new RelationshipInfoImpl();
+		RelationshipInfoImpl ri2 = new RelationshipInfoImpl();
+		RelationshipInfoImpl ri3 = new RelationshipInfoImpl();
+		RelationshipInfoImpl ri4 = new RelationshipInfoImpl();
+		RelationshipInfoImpl ri5 = new RelationshipInfoImpl();
+		RelationshipInfoImpl ri6 = new RelationshipInfoImpl();
+		ris.add(ri1);
+		ris.add(ri2);
+		ris.add(ri3);
+		ris.add(ri4);
+		ris.add(ri5);
+		ris.add(ri6);
+		
+		ri1.setName("i.am.exported.by.1.and.used.by.2.and.3");
+		ri1.setProvidedBy(ci1);
+		ArrayList<ComponentInfo> c = new ArrayList<ComponentInfo>();
+		c.add(ci2);
+		c.add(ci3);
+		ri1.setConsumedBy(c);
+		ri1.setType("Package"); 
+		
+		ri2.setName("i.am.exported.by.1.and.used.by.3");
+		ri2.setProvidedBy(ci1);
+		c = new ArrayList<ComponentInfo>();
+		c.add(ci3);
+		ri2.setConsumedBy(c);
+		ri2.setType("Package"); 
+		
+		ri3.setName("i.am.exported.by.2.and.used.by.3");
+		ri3.setProvidedBy(ci2);
+		c = new ArrayList<ComponentInfo>();
+		c.add(ci3);
+		ri3.setConsumedBy(c);
+		ri3.setType("Package"); 
+		
+		ri4.setName("i.am.exported.by.3.and.used.by.2");
+		ri4.setProvidedBy(ci3);
+		c = new ArrayList<ComponentInfo>();
+		c.add(ci2);
+		ri4.setConsumedBy(c);
+		ri4.setType("Package"); 
+
+		ri5.setName("i.am.a.funky.service.from.3.used.by.2");
+		ri5.setProvidedBy(ci3);
+		c = new ArrayList<ComponentInfo>();
+		c.add(ci2);
+		ri5.setConsumedBy(c);
+		ri5.setType("Service");
+		
+		ri6.setName("i.am.a.funky.service.from.1.used.by.2");
+		ri6.setProvidedBy(ci1);
+		c = new ArrayList<ComponentInfo>();
+		c.add(ci2);
+		ri6.setConsumedBy(c);
+		ri6.setType("Service");
+		return ris;
+	}
+
+	@Override
+	public void registerRelationshipInfoListener(RelationshipInfoListener listener) {
+		// TODO Auto-generated method stub
+
+	}
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-info-enhancer/src/main/java/org/apache/aries/samples/goat/enhancer/Activator.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-info-enhancer/src/main/java/org/apache/aries/samples/goat/enhancer/Activator.java
index e69de29b..db76bdf3 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-info-enhancer/src/main/java/org/apache/aries/samples/goat/enhancer/Activator.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-info-enhancer/src/main/java/org/apache/aries/samples/goat/enhancer/Activator.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.samples.goat.enhancer;
+
+import org.osgi.framework.BundleActivator;
+import org.osgi.framework.BundleContext;
+
+public class Activator implements BundleActivator {
+
+	private ServiceInterceptor interceptor;
+
+	@Override
+	public void start(BundleContext ctx) throws Exception {
+		interceptor = new ServiceInterceptor(ctx);
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see
+	 * org.osgi.framework.BundleActivator#stop(org.osgi.framework.BundleContext)
+	 */
+	@Override
+	public void stop(BundleContext arg0) throws Exception {
+		interceptor.stop();
+	}
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-info-enhancer/src/main/java/org/apache/aries/samples/goat/enhancer/ModelInfoEnhancerService.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-info-enhancer/src/main/java/org/apache/aries/samples/goat/enhancer/ModelInfoEnhancerService.java
index e69de29b..6c846803 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-info-enhancer/src/main/java/org/apache/aries/samples/goat/enhancer/ModelInfoEnhancerService.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-info-enhancer/src/main/java/org/apache/aries/samples/goat/enhancer/ModelInfoEnhancerService.java
@@ -0,0 +1,339 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.enhancer;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.aries.samples.goat.api.ComponentInfo;
+import org.apache.aries.samples.goat.api.ComponentInfoProvider;
+import org.apache.aries.samples.goat.api.ModelInfoService;
+import org.apache.aries.samples.goat.api.RelationshipInfo;
+import org.apache.aries.samples.goat.api.RelationshipInfoProvider;
+
+import org.apache.aries.samples.goat.info.ComponentInfoImpl;
+import org.apache.aries.samples.goat.info.RelationshipInfoImpl;
+
+public class ModelInfoEnhancerService implements ModelInfoService,
+		ComponentInfoProvider, RelationshipInfoProvider,
+		ComponentInfoProvider.ComponentInfoListener,
+		RelationshipInfoProvider.RelationshipInfoListener {
+
+	private static final String SERVICE_REGISTRATION = "Service registration";
+
+	private static final String SERVICE_USAGE = "Service usage";
+
+	// TODO where should we expose these shared strings?
+	private static final String SERVICE = "Service";
+
+	private ModelInfoService originalService;
+
+	private final Map<String, ComponentInfo> components = new HashMap<String, ComponentInfo>();
+	private final Map<String, RelationshipInfo> relationships = new HashMap<String, RelationshipInfo>();
+
+	private final List<ComponentInfoListener> clisteners;
+	private final List<RelationshipInfoListener> rlisteners;
+
+	public ModelInfoEnhancerService(ModelInfoService infoService) {
+
+		clisteners = Collections
+				.synchronizedList(new ArrayList<ComponentInfoListener>());
+		rlisteners = Collections
+				.synchronizedList(new ArrayList<RelationshipInfoListener>());
+
+		this.originalService = infoService;
+		Collection<ComponentInfo> originalComponents = originalService
+				.getComponentInfoProvider().getComponents();
+		// We keep all the original components
+		for (ComponentInfo info : originalComponents) {
+			components.put(info.getId(), info);
+		}
+		// We add a new component for each service
+		Collection<RelationshipInfo> originalRelationships = originalService
+				.getRelationshipInfoProvider().getRelationships();
+		// We keep all the original components
+		for (RelationshipInfo rel : originalRelationships) {
+
+			if (SERVICE.equals(rel.getType())) {
+				ComponentInfoImpl serviceComponent = new ComponentInfoImpl();
+				String id = constructServiceComponentId(rel);
+				serviceComponent.setId(id);
+				Map<String, String> componentProperties = new HashMap<String, String>();
+				componentProperties.put("Name", rel.getName());
+				serviceComponent.setComponentProperties(componentProperties);
+
+				components.put(id, serviceComponent);
+
+				// Make new relationships;
+
+				RelationshipInfoImpl registration = new RelationshipInfoImpl();
+				registration.setType(SERVICE_REGISTRATION);
+				registration.setName(rel.getName());
+				registration.setProvidedBy(rel.getProvidedBy());
+				registration.setRelationshipAspects(rel
+						.getRelationshipAspects());
+
+				ArrayList<ComponentInfo> arrayList = new ArrayList<ComponentInfo>();
+				arrayList.add(serviceComponent);
+				registration.setConsumedBy(arrayList);
+
+				relationships.put(constructId(registration), registration);
+
+				RelationshipInfoImpl consumption = new RelationshipInfoImpl();
+				consumption.setType(SERVICE_USAGE);
+				consumption.setName(rel.getName());
+				consumption.setProvidedBy(serviceComponent);
+				consumption.setConsumedBy(rel.getConsumedBy());
+				consumption
+						.setRelationshipAspects(rel.getRelationshipAspects());
+
+				relationships.put(constructId(consumption), consumption);
+
+			} else {
+				// Pass non-service relationships through
+				relationships.put(constructId(rel), rel);
+
+			}
+
+			originalService.getComponentInfoProvider()
+					.registerComponentInfoListener(this);
+			originalService.getRelationshipInfoProvider()
+					.registerRelationshipInfoListener(this);
+		}
+
+	}
+
+	@Override
+	public String getName() {
+		return "Model Enhancer Service";
+	}
+
+	@Override
+	public ComponentInfoProvider getComponentInfoProvider() {
+		return this;
+	}
+
+	@Override
+	public RelationshipInfoProvider getRelationshipInfoProvider() {
+		return this;
+	}
+
+	@Override
+	public Collection<RelationshipInfo> getRelationships() {
+		return relationships.values();
+	}
+
+	@Override
+	public Collection<ComponentInfo> getComponents() {
+		return components.values();
+	}
+
+	@Override
+	public ComponentInfo getComponentForId(String id) {
+		return components.get(id);
+	}
+
+	@Override
+	public void registerRelationshipInfoListener(
+			RelationshipInfoListener listener) {
+		rlisteners.add(listener);
+	}
+
+	@Override
+	public void registerComponentInfoListener(ComponentInfoListener listener) {
+		clisteners.add(listener);
+	}
+
+	@Override
+	public void updateRelationship(RelationshipInfo r) {
+		if (SERVICE.equals(r.getType())) {
+			updateSyntheticServiceArtefactsAndNotifyListeners(r);
+		} else {
+			// Update our copy
+			relationships.put(constructId(r), r);
+			// This shouldn't affect us, but pass it on to our listeners
+			for (RelationshipInfoListener listener : rlisteners) {
+				listener.updateRelationship(r);
+			}
+		}
+
+	}
+
+	@Override
+	public void removeRelationship(RelationshipInfo r) {
+
+		if (SERVICE.equals(r.getType())) {
+			removeSyntheticServiceArtefactsAndNotifyListeners(r);
+		} else {
+			// We don't want to track this relationship anymore
+			String id = constructId(r);
+			RelationshipInfo relationship = relationships.get(id);
+			relationships.remove(id);
+			if (relationship != null) {
+				// This shouldn't affect us, but pass it on to our listeners
+				for (RelationshipInfoListener listener : rlisteners) {
+					listener.removeRelationship(relationship);
+				}
+			}
+		}
+
+	}
+
+	@Override
+	public void updateComponent(ComponentInfo b) {
+		// Update our copy
+		components.put(b.getId(), b);
+		// This shouldn't affect us, but pass it on to our listeners
+		for (ComponentInfoListener listener : clisteners) {
+			listener.updateComponent(b);
+		}
+
+	}
+
+	@Override
+	public void removeComponent(ComponentInfo b) {
+		// This shouldn't affect us unless it has relationships pointing to it
+		// Cheerfully assume that gets handled upstream
+
+		// We don't want to know about this component anymore
+		ComponentInfo component = components.remove(b);
+		if (component != null) {// This shouldn't affect us, but pass it on to
+								// our listeners
+			for (ComponentInfoListener listener : clisteners) {
+				listener.removeComponent(component);
+			}
+		}
+
+	}
+
+	private String constructServiceComponentId(RelationshipInfo rel) {
+		return "/syntheticenhancedservices/" + rel.getName() + "/"
+				+ rel.getProvidedBy().getId();
+	}
+
+	private String constructId(RelationshipInfo b) {
+		return b.getType() + "/" + b.getName() + "/"
+				+ b.getProvidedBy().getId();
+	}
+
+	private void removeSyntheticServiceArtefactsAndNotifyListeners(
+			RelationshipInfo r) {
+		// We need to remove our two relationships and the synthetic
+		// component
+
+		String componentId = constructServiceComponentId(r);
+
+		// Do the relationships first
+		// The registration has type "service registration", and the
+		// original provider and name
+		String registrationRelationshipId = SERVICE_REGISTRATION + "/"
+				+ r.getName() + "/" + r.getProvidedBy().getId();
+		RelationshipInfo registrationRelationship = relationships
+				.get(registrationRelationshipId);
+
+		// The consumers have type "service usage", and the
+		// original name, and the new provided by
+
+		String usageRelationshipId = SERVICE_USAGE + "/" + r.getName() + "/"
+				+ componentId;
+		RelationshipInfo usageRelationship = relationships
+				.get(usageRelationshipId);
+
+		relationships.remove(usageRelationshipId);
+		relationships.remove(registrationRelationshipId);
+
+		// Tell our listeners about the relationships first
+
+		for (RelationshipInfoListener listener : rlisteners) {
+			if (usageRelationship != null) {
+				listener.removeRelationship(usageRelationship);
+			}
+			if (registrationRelationship != null) {
+				listener.removeRelationship(registrationRelationship);
+			}
+
+		}
+
+		ComponentInfo component = components.remove(componentId);
+		if (component != null) {
+			// Tell our listeners their service component went away
+			for (ComponentInfoListener listener : clisteners) {
+				listener.removeComponent(component);
+			}
+		}
+	}
+
+	private void updateSyntheticServiceArtefactsAndNotifyListeners(
+			RelationshipInfo r) {
+		// We need to update our two relationships and the synthetic
+		// component
+		// Hopefully the thing which changed won't prevent us
+		// from finding our relationship
+
+		String componentId = constructServiceComponentId(r);
+
+		// Do the relationships first
+		// The registration has type "service registration", and the
+		// original provider and name
+		String registrationRelationshipId = SERVICE_REGISTRATION + "/"
+				+ r.getName() + "/" + r.getProvidedBy().getId();
+		RelationshipInfoImpl registrationRelationship = (RelationshipInfoImpl) relationships
+				.get(registrationRelationshipId);
+		registrationRelationship.setName(r.getName());
+		registrationRelationship.setRelationshipAspects(r
+				.getRelationshipAspects());
+
+		// The consumers have type "service usage", and the
+		// original name, and the new provided by
+
+		String usageRelationshipId = SERVICE_USAGE + "/" + r.getName() + "/"
+				+ componentId;
+		RelationshipInfoImpl usageRelationship = (RelationshipInfoImpl) relationships
+				.get(usageRelationshipId);
+
+		// The consumers may have changed, so we update the usage relationship
+		usageRelationship.setConsumedBy(r.getConsumedBy());
+		usageRelationship.setName(r.getName());
+		usageRelationship.setRelationshipAspects(r.getRelationshipAspects());
+
+		// Tell our listeners about the relationships first
+
+		for (RelationshipInfoListener listener : rlisteners) {
+			if (usageRelationship != null) {
+				listener.updateRelationship(usageRelationship);
+			}
+			if (registrationRelationship != null) {
+				listener.updateRelationship(registrationRelationship);
+			}
+
+		}
+
+		ComponentInfo component = components.get(componentId);
+		if (component != null) {
+			// Tell our listeners their service component was updated
+			for (ComponentInfoListener listener : clisteners) {
+				listener.updateComponent(component);
+			}
+		}
+	}
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-info-enhancer/src/main/java/org/apache/aries/samples/goat/enhancer/ServiceInterceptor.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-info-enhancer/src/main/java/org/apache/aries/samples/goat/enhancer/ServiceInterceptor.java
index 9e1dca2a..058bb526 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-info-enhancer/src/main/java/org/apache/aries/samples/goat/enhancer/ServiceInterceptor.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-info-enhancer/src/main/java/org/apache/aries/samples/goat/enhancer/ServiceInterceptor.java
@@ -1 +1,132 @@
   + target
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.samples.goat.enhancer;
+
+import java.util.Dictionary;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.Map;
+
+import org.apache.aries.samples.goat.api.ModelInfoService;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.ServiceEvent;
+import org.osgi.framework.ServiceListener;
+import org.osgi.framework.ServiceReference;
+import org.osgi.framework.ServiceRegistration;
+
+public class ServiceInterceptor implements ServiceListener {
+
+	private static final String DISPLAY_NAME = "displayName";
+	/**
+   * 
+   */
+	public static final String SERVICE_ID = "service.id";
+	private final BundleContext ctx;
+	private final Map<String, ServiceRegistration> registrations = new HashMap<String, ServiceRegistration>();
+
+	public ServiceInterceptor(BundleContext ctx) {
+		this.ctx = ctx;
+		// Check all the existing services
+		try {
+			// Handle any existing services
+			ServiceReference[] references = ctx.getAllServiceReferences(
+					ModelInfoService.class.getName(), null);
+
+
+			ctx.addServiceListener(this, "(objectclass='"
+						+ ModelInfoService.class.getName() + "')");
+
+			//If we found any service references...
+			if(references != null && references.length != 0) {
+				for (ServiceReference reference : references) {
+					registerServiceEnhancer(reference);
+				}
+			}
+
+
+		} catch (InvalidSyntaxException e) {
+			e.printStackTrace();
+		}
+		// We could listen for find events and mask the original services if we
+		// wanted to
+		// ServiceRegistration findRegistration =
+		// ctx.registerService(FindHook.class.getName(),
+		// new InterceptorFindHook(), null);
+	}
+
+	/*
+	 * (non-Javadoc)
+	 * 
+	 * @see
+	 * org.osgi.framework.ServiceListener#serviceChanged(org.osgi.framework.
+	 * ServiceEvent)
+	 */
+	@Override
+	public void serviceChanged(ServiceEvent event) {
+		ServiceReference reference = event.getServiceReference();
+		if (event != null && event.getType() == ServiceEvent.REGISTERED) {
+			registerServiceEnhancer(reference);
+
+		} else if (event != null
+				&& event.getType() == ServiceEvent.UNREGISTERING) {
+			// Better unregister our enhancer
+			Object id = reference.getProperty(SERVICE_ID);
+			ServiceRegistration registration = registrations.get(id);
+			if (registration != null) {
+				registration.unregister();
+				registrations.remove(id);
+			}
+		}
+
+	}
+
+	@SuppressWarnings({ "rawtypes", "unchecked" })
+	private void registerServiceEnhancer(ServiceReference reference) {
+		Object actualService = ctx.getService(reference);
+
+		if (actualService instanceof ModelInfoService) {
+			ModelInfoService infoService = (ModelInfoService) actualService;
+			Object serviceId = reference.getProperty(SERVICE_ID);
+			Object enhancer = new ModelInfoEnhancerService(infoService);
+			Dictionary properties = new Hashtable();
+			Object originalDisplayName = reference.getProperty(DISPLAY_NAME);
+			properties.put(DISPLAY_NAME, originalDisplayName + " [enhanced]");
+			ServiceRegistration registration = ctx.registerService(
+					ModelInfoService.class.getName(), enhancer, properties);
+			registrations.put(serviceId + "", registration);
+		} else {
+			System.out.println("Oh dear - unexpected service "
+					+ actualService.getClass());
+		}
+	}
+
+	/**
+   * 
+   */
+	public void stop() {
+		for (ServiceRegistration registration : registrations.values()) {
+			registration.unregister();
+		}
+
+	}
+
+}
diff --git a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-web/src/main/java/org/apache/aries/samples/goat/web/ServerSideClass.java b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-web/src/main/java/org/apache/aries/samples/goat/web/ServerSideClass.java
index 9e1dca2a..8ece51d5 100644
--- a/aries/branches/oct-2011-release/sandbox/samples/goat/goat-web/src/main/java/org/apache/aries/samples/goat/web/ServerSideClass.java
+++ b/aries/branches/oct-2011-release/sandbox/samples/goat/goat-web/src/main/java/org/apache/aries/samples/goat/web/ServerSideClass.java
@@ -1 +1,285 @@
   + target
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.samples.goat.web;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.servlet.ServletContext;
+
+import org.apache.aries.samples.goat.info.ComponentInfoImpl;
+import org.apache.aries.samples.goat.info.RelationshipInfoImpl;
+
+import org.apache.aries.samples.goat.api.ComponentInfo;
+import org.apache.aries.samples.goat.api.ComponentInfoProvider;
+import org.apache.aries.samples.goat.api.ModelInfoService;
+import org.apache.aries.samples.goat.api.RelationshipInfo;
+import org.apache.aries.samples.goat.api.RelationshipInfoProvider;
+
+import org.directwebremoting.Browser;
+import org.directwebremoting.ScriptBuffer;
+import org.directwebremoting.ScriptSession;
+import org.directwebremoting.ServerContextFactory;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.ServiceReference;
+
+public class ServerSideClass {
+
+	private String modelInfoServiceHint = "";
+
+	private ModelInfoService ModelInfoService = null;
+
+	private Map<ModelInfoService, ComponentInfoProvider.ComponentInfoListener> clisteners = new HashMap<ModelInfoService, ComponentInfoProvider.ComponentInfoListener>();
+	private Map<ModelInfoService, RelationshipInfoProvider.RelationshipInfoListener> rlisteners = new HashMap<ModelInfoService, RelationshipInfoProvider.RelationshipInfoListener>();
+
+	private class ComponentInfoListenerImpl implements
+			ComponentInfoProvider.ComponentInfoListener {
+		String server;
+
+		public ComponentInfoListenerImpl(String server) {
+			this.server = server;
+		}
+
+		public void updateComponent(ComponentInfo b) {
+			if (this.server.equals(modelInfoServiceHint)) {
+				// todo: only issue the add for the new bundle, and affected
+				// other bundles.
+				//getInitialComponents(modelInfoServiceHint);
+				//System.out.println("State is: " + b.getComponentProperties().get("State"));
+				addFunctionCall("addComponent", b);
+			}
+		}
+
+		public void removeComponent(ComponentInfo b) {
+			// todo
+		}
+	}
+	private class RelationshipInfoListenerImpl implements
+			RelationshipInfoProvider.RelationshipInfoListener {
+		String server;
+
+		public RelationshipInfoListenerImpl(String server) {
+			this.server = server;
+		}
+
+		public void updateRelationship(RelationshipInfo r) {
+			if (this.server.equals(modelInfoServiceHint)) {
+				addFunctionCall("addRelationship", r);
+			}
+		}
+
+		public void removeRelationship(RelationshipInfo r) {
+			// todo
+		}
+	}
+
+	public ServerSideClass() {
+		System.err.println("SSC Built!");
+
+	}
+
+	@SuppressWarnings("unused")
+	private String bundleStateToString(int bundleState) {
+		switch (bundleState) {
+		case Bundle.UNINSTALLED:
+			return "UNINSTALLED";
+		case Bundle.INSTALLED:
+			return "INSTALLED";
+		case Bundle.RESOLVED:
+			return "RESOLVED";
+		case Bundle.STARTING:
+			return "STARTING";
+		case Bundle.STOPPING:
+			return "STOPPING";
+		case Bundle.ACTIVE:
+			return "ACTIVE";
+		default:
+			return "UNKNOWN[" + bundleState + "]";
+		}
+	}
+
+	/**
+	 * this is invoked by a page onload.. so until it's invoked.. we dont care
+	 * about components
+	 */
+	public void getInitialComponents(String dataProvider) {
+
+		System.err.println("GET INITIAL BUNDLES ASKED TO USE DATAPROVIDER "
+				+ dataProvider);
+
+		if (dataProvider == null)
+			throw new IllegalArgumentException(
+					"Unable to accept 'null' as a dataProvider");
+
+		// do we need to update?
+		if (!this.modelInfoServiceHint.equals(dataProvider)) {
+
+			this.modelInfoServiceHint = dataProvider;
+
+			if (!(this.ModelInfoService == null)) {
+				// we already had a provider.. we need to shut down the existing
+				// components & relationships in the browsers..
+				addFunctionCall("forgetAboutEverything");
+			}
+
+			ServletContext context = org.directwebremoting.ServerContextFactory
+					.get().getServletContext();
+			Object o = context.getAttribute("osgi-bundlecontext");
+			if (o != null) {
+				if (o instanceof BundleContext) {
+					BundleContext b_ctx = (BundleContext) o;
+
+					System.err.println("Looking up bcip");
+					try {
+						ServiceReference sr[] = b_ctx.getServiceReferences(
+								ModelInfoService.class.getName(),
+								"(displayName=" + this.modelInfoServiceHint
+										+ ")");
+						if (sr != null) {
+							System.err.println("Getting bcip");
+							this.ModelInfoService = (ModelInfoService) b_ctx
+									.getService(sr[0]);
+							System.err.println("Got bcip "
+									+ this.ModelInfoService);
+						} else {
+							System.err.println("UNABLE TO FIND BCIP!!");
+							System.err.println("UNABLE TO FIND BCIP!!");
+							System.err.println("UNABLE TO FIND BCIP!!");
+						}
+					} catch (InvalidSyntaxException ise) {
+
+					}
+
+					if (this.ModelInfoService != null) {
+						if (!rlisteners.containsKey(this.ModelInfoService)) {
+							RelationshipInfoProvider.RelationshipInfoListener rl = new RelationshipInfoListenerImpl(
+									this.modelInfoServiceHint);
+							rlisteners.put(this.ModelInfoService, rl);
+							this.ModelInfoService.getRelationshipInfoProvider()
+									.registerRelationshipInfoListener(rl);
+						}
+
+						if (!clisteners.containsKey(this.ModelInfoService)) {
+							ComponentInfoProvider.ComponentInfoListener cl = new ComponentInfoListenerImpl(
+									this.modelInfoServiceHint);
+							clisteners.put(this.ModelInfoService, cl);
+							this.ModelInfoService.getComponentInfoProvider()
+									.registerComponentInfoListener(cl);
+						}
+					}
+				}
+			}
+
+		}
+
+		Collection<ComponentInfo> bis = this.ModelInfoService
+				.getComponentInfoProvider().getComponents();
+		System.err.println("Got " + (bis == null ? "null" : bis.size())
+				+ " components back from the provider ");
+		if (bis != null) {
+			for (ComponentInfo b : bis) {
+
+				System.err.println("Adding Component .. " + b.getId());
+
+				addFunctionCall("addComponent", b);
+			}
+		}
+
+		Collection<RelationshipInfo> ris = this.ModelInfoService
+				.getRelationshipInfoProvider().getRelationships();
+		System.err.println("Got " + (ris == null ? "null" : ris.size())
+				+ " relationships back from the provider ");
+		if (ris != null) {
+			for (RelationshipInfo r : ris) {
+				System.err.println("Adding relationship type " + r.getType()
+						+ " called " + r.getName() + " from "
+						+ r.getProvidedBy().getId());
+
+				addFunctionCall("addRelationship", r);
+			}
+		}
+
+	}
+
+	private void addFunctionCall(String name, Object... params) {
+		final ScriptBuffer script = new ScriptBuffer();
+		script.appendScript(name).appendScript("(");
+		for (int i = 0; i < params.length; i++) {
+			if (i != 0)
+				script.appendScript(",");
+			script.appendData(params[i]);
+		}
+		script.appendScript(");");
+		Browser.withAllSessions(new Runnable() {
+			public void run() {
+				for (ScriptSession s : Browser.getTargetSessions()) {
+					s.addScript(script);
+				}
+			}
+		});
+	}
+
+	public String[] getProviders() {
+		System.err.println("Getting providers...");
+		ArrayList<String> result = new ArrayList<String>();
+		ServletContext context = ServerContextFactory.get().getServletContext();
+		Object o = context.getAttribute("osgi-bundlecontext");
+		if (o != null) {
+			if (o instanceof BundleContext) {
+				BundleContext b_ctx = (BundleContext) o;
+				try {
+					System.err.println("Getting providers [2]...");
+					ServiceReference[] srs = b_ctx.getServiceReferences(
+							ModelInfoService.class.getName(), null);
+					System.err.println("Got.. " + srs);
+					if (srs == null || srs.length == 0) {
+						System.err.println("NO DATA PROVIDERS");
+						throw new RuntimeException(
+								"Unable to find any data providers");
+					}
+					System.err.println("Processing srs as loop.");
+					for (ServiceReference sr : srs) {
+						System.err.println("Processing srs entry...");
+
+						String name = (String.valueOf(sr
+								.getProperty("displayName")));
+
+						result.add(name);
+					}
+					System.err.println("Processed srs as loop.");
+				} catch (InvalidSyntaxException e) {
+					// wont happen, the exception relates to the filter, (2nd
+					// arg above), which is constant null.
+				}
+			}
+		}
+		System.err.println("Returning " + result.size());
+		String[] arr = new String[result.size()];
+		arr = result.toArray(arr);
+		for (String x : arr) {
+			System.err.println(" - " + x);
+		}
+		return arr;
+	}
+}
