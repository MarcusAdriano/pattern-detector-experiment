diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/catalog/types/RoutineAliasInfo.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/catalog/types/RoutineAliasInfo.java
index 25cfb1af..b7be7a61 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/catalog/types/RoutineAliasInfo.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/catalog/types/RoutineAliasInfo.java
@@ -90,6 +90,9 @@ SQL Specific name (future)
 	*/
 	private boolean	calledOnNullInput;
 
+	// What type of alias is this: PROCEDURE or FUNCTION?
+	private char aliasType;
+
 	public RoutineAliasInfo() {
 	}
 
@@ -121,6 +124,7 @@ public RoutineAliasInfo(String methodName, int parameterCount, String[] paramete
 		this.sqlAllowed = sqlAllowed;
 		this.calledOnNullInput = calledOnNullInput;
 		this.returnType = returnType;
+		setAliasType();
 
 		if (SanityManager.DEBUG) {
 
@@ -230,6 +234,7 @@ public void readExternal( ObjectInput in )
 			parameterTypes = null;
 			parameterModes = null;
 		}
+		setAliasType();
 	}
 
 	/**
@@ -265,6 +270,15 @@ public void writeExternal( ObjectOutput out )
 	 */
 	public	int	getTypeFormatId()	{ return StoredFormatIds.ROUTINE_INFO_V01_ID; }
 
+	/**
+	 * Get this alias info as a string.  NOTE: The "ALIASINFO" column
+	 * in the SYSALIASES table will return the result of this method
+	 * on a ResultSet.getString() call.  That said, since the dblook
+	 * utility uses ResultSet.getString() to retrieve ALIASINFO and
+	 * to generate the DDL, THIS METHOD MUST RETURN A STRING THAT
+	 * IS SYNTACTICALLY VALID, or else the DDL generated by dblook
+	 * will be incorrect.
+	 */
 	public String toString() {
 
 		StringBuffer sb = new StringBuffer(100);
@@ -274,21 +288,42 @@ public String toString() {
 			if (i != 0)
 				sb.append(',');
 
+			if (aliasType == AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR) {
+			// This is a PROCEDURE.  We only want to print the
+			// parameter mode (ex. "IN", "OUT", "INOUT") for procedures--
+			// we don't do it for functions since use of the "IN" keyword
+			// is not part of the FUNCTION syntax.
 			sb.append(RoutineAliasInfo.parameterMode(parameterModes[i]));
 			sb.append(' ');
+			}
 			sb.append(parameterNames[i]);
 			sb.append(' ');
 			sb.append(parameterTypes[i].getSQLstring());
 		}
 		sb.append(')');
 
+		if (aliasType == AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR) {
+		// this a FUNCTION, so syntax requires us to append the return type.
+			sb.append(" RETURNS " + returnType.getSQLstring());
+		}
+
 		sb.append(" LANGUAGE JAVA PARAMETER STYLE JAVA ");
 		sb.append(RoutineAliasInfo.SQL_CONTROL[getSQLAllowed()]);
-		if (dynamicResultSets != 0) {
+		if ((aliasType == AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR) &&
+			(dynamicResultSets != 0))
+		{ // Only print dynamic result sets if this is a PROCEDURE
+		  // because it's not valid syntax for FUNCTIONs.
 			sb.append(" DYNAMIC RESULT SETS ");
 			sb.append(dynamicResultSets);
 		}
 
+		if (aliasType == AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR) {
+		// this a FUNCTION, so append the syntax telling what to
+		// do with a null parameter.
+			sb.append(calledOnNullInput ? " CALLED " : " RETURNS NULL ");
+			sb.append("ON NULL INPUT");
+		}
+		
 		return sb.toString();
 	}
 
@@ -304,4 +339,18 @@ public static String parameterMode(int parameterMode) {
 			return "UNKNOWN";
 		}
 	}
+
+	/**
+	 * Set the type of this alias based on whether or not
+	 * the returnType is null.
+	 */
+	private void setAliasType()
+	{
+		if (returnType == null)
+		// must be a PROCEDURE.
+			aliasType = AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR;
+		else
+		// must be a FUNCTION.
+			aliasType = AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR;
+	}
 }
diff --git a/incubator/derby/code/trunk/java/tools/org/apache/derby/impl/tools/dblook/DB_Alias.java b/incubator/derby/code/trunk/java/tools/org/apache/derby/impl/tools/dblook/DB_Alias.java
index e69de29b..69cf2384 100644
--- a/incubator/derby/code/trunk/java/tools/org/apache/derby/impl/tools/dblook/DB_Alias.java
+++ b/incubator/derby/code/trunk/java/tools/org/apache/derby/impl/tools/dblook/DB_Alias.java
@@ -0,0 +1,201 @@
+/*
+
+   Derby - Class org.apache.derby.impl.tools.dblook.DB_Alias
+
+   Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.impl.tools.dblook;
+
+import java.sql.Connection;
+import java.sql.Statement;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.DatabaseMetaData;
+
+import java.util.HashMap;
+import org.apache.derby.tools.dblook;
+
+public class DB_Alias {
+
+	// Prepared statements use throughout the DDL
+	// generation process.
+
+	/* ************************************************
+	 * Generate the DDL for all stored procedures and
+	 * functions in a given database and write it to
+	 * output via Logs.java.
+	 * @param conn Connection to the source database.
+	 ****/
+
+	public static void doProceduresAndFunctions(Connection conn)
+		throws SQLException {
+
+		// First do stored procedures.
+		Statement stmt = conn.createStatement();
+		ResultSet rs = stmt.executeQuery("SELECT ALIAS, ALIASINFO, " +
+			"ALIASID, SCHEMAID, JAVACLASSNAME, SYSTEMALIAS FROM SYS.SYSALIASES " +
+			"WHERE ALIASTYPE='P'");
+		generateDDL(rs, 'P');	// 'P' => for PROCEDURES
+
+		// Now do functions.
+		rs = stmt.executeQuery("SELECT ALIAS, ALIASINFO, " +
+			"ALIASID, SCHEMAID, JAVACLASSNAME, SYSTEMALIAS FROM SYS.SYSALIASES " +
+			"WHERE ALIASTYPE='F'");
+		generateDDL(rs, 'F');	// 'F' => for FUNCTIONS
+
+		rs.close();
+		stmt.close();
+		return;
+
+	}
+
+	/* ************************************************
+	 * Generate the DDL for either stored procedures or
+	 * functions in a given database, depending on the
+	 * the received aliasType.
+	 * @param rs Result set holding either stored procedures
+	 *  or functions.
+	 * @param aliasType Indication of whether we're generating
+	 *  stored procedures or functions.
+	 ****/
+	private static void generateDDL(ResultSet rs, char aliasType)
+		throws SQLException
+	{
+
+		boolean firstTime = true;
+		while (rs.next()) {
+
+			if (rs.getBoolean(6))
+			// it's a system alias, so we ignore it.
+				continue;
+
+			String procSchema = dblook.lookupSchemaId(rs.getString(4));
+			if (dblook.isIgnorableSchema(procSchema))
+				continue;
+
+			if (firstTime) {
+				Logs.reportString("----------------------------------------------");
+				Logs.reportMessage((aliasType == 'P')
+					? "DBLOOK_StoredProcHeader"
+					: "DBLOOK_FunctionHeader");
+				Logs.reportString("----------------------------------------------\n");
+			}
+
+			String aliasName = rs.getString(1);
+			String fullName = dblook.addQuotes(
+				dblook.expandDoubleQuotes(aliasName));
+			fullName = procSchema + "." + fullName;
+
+			String creationString = createProcOrFuncString(
+				fullName, rs, aliasType);
+			Logs.writeToNewDDL(creationString);
+			Logs.writeStmtEndToNewDDL();
+			Logs.writeNewlineToNewDDL();
+			firstTime = false;
+
+		}
+
+	}
+
+	/* ************************************************
+	 * Generate DDL for a specific stored procedure or
+	 * function.
+	 * @param aliasName Name of the current procedure/function
+	 * @param aliasInfo Info about the current procedure/function
+	 * @param aliasType Indicator of whether we're generating
+	 *  a stored procedure or a function.
+	 * @return DDL for the current stored procedure is
+	 *   returned, as a String.
+	 ****/
+
+	private static String createProcOrFuncString(String aliasName,
+		ResultSet aliasInfo, char aliasType) throws SQLException
+	{
+
+		StringBuffer alias = new StringBuffer("CREATE ");
+		if (aliasType == 'P')
+			alias.append("PROCEDURE ");
+		else if (aliasType == 'F')
+			alias.append("FUNCTION ");
+		alias.append(aliasName);
+		alias.append(" ");
+
+		String params = aliasInfo.getString(2);
+
+		// Just grab the parameter part; we'll get the method name later.
+		alias.append(params.substring(params.indexOf("("), params.length()));
+		alias.append(" ");
+
+		// Now add the external name.
+		alias.append("EXTERNAL NAME '");
+		alias.append(aliasInfo.getString(5));
+		alias.append(".");
+		// Get method name from parameter string fetched above.
+		alias.append(params.substring(0, params.indexOf("(")));
+		alias.append("' ");
+
+		return alias.toString();
+
+	}
+
+	/* ************************************************
+	 * Generate the DDL for all synonyms in a given
+	 * database. On successul return, the DDL for the
+	 * synonyms has been written to output via Logs.java.
+	 * @param conn Connection to the source database.
+	 * @return 
+	 ****/
+	public static void doSynonyms(Connection conn) throws SQLException
+	{
+		Statement stmt = conn.createStatement();
+		ResultSet rs = stmt.executeQuery("SELECT ALIAS, SCHEMAID, " +
+			"ALIASINFO, SYSTEMALIAS FROM SYS.SYSALIASES A WHERE ALIASTYPE='S'");
+
+		boolean firstTime = true;
+		while (rs.next()) {
+			if (rs.getBoolean(4))
+			// it's a system alias, so we ignore it.
+				continue;
+
+			String aliasSchema = dblook.lookupSchemaId(rs.getString(2));
+			if (dblook.isIgnorableSchema(aliasSchema))
+				continue;
+
+			if (firstTime) {
+				Logs.reportString("----------------------------------------------");
+				Logs.reportMessage("DBLOOK_SynonymHeader");
+				Logs.reportString("----------------------------------------------\n");
+			}
+
+			String aliasName = rs.getString(1);
+			String aliasFullName = dblook.addQuotes(
+				dblook.expandDoubleQuotes(aliasName));
+			aliasFullName = aliasSchema + "." + aliasFullName;
+
+			Logs.writeToNewDDL("CREATE SYNONYM "+aliasFullName+" FOR "+rs.getString(3));
+			Logs.writeStmtEndToNewDDL();
+			Logs.writeNewlineToNewDDL();
+			firstTime = false;
+		}
+
+		rs.close();
+		stmt.close();
+		return;
+
+	}
+}
diff --git a/incubator/derby/code/trunk/java/tools/org/apache/derby/impl/tools/dblook/DB_StoredProcedure.java b/incubator/derby/code/trunk/java/tools/org/apache/derby/impl/tools/dblook/DB_StoredProcedure.java
index 30f8370f..e69de29b 100644
--- a/incubator/derby/code/trunk/java/tools/org/apache/derby/impl/tools/dblook/DB_StoredProcedure.java
+++ b/incubator/derby/code/trunk/java/tools/org/apache/derby/impl/tools/dblook/DB_StoredProcedure.java
@@ -1,169 +0,0 @@
-/*
-
-   Derby - Class org.apache.derby.impl.tools.dblook.DB_StoredProcedure
-
-   Copyright 2004 The Apache Software Foundation or its licensors, as applicable.
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-
-package org.apache.derby.impl.tools.dblook;
-
-import java.sql.Connection;
-import java.sql.Statement;
-import java.sql.PreparedStatement;
-import java.sql.ResultSet;
-import java.sql.SQLException;
-import java.sql.DatabaseMetaData;
-
-import java.util.HashMap;
-import org.apache.derby.tools.dblook;
-
-public class DB_StoredProcedure {
-
-	// Prepared statements use throughout the DDL
-	// generation process.
-
-	/* ************************************************
-	 * Generate the DDL for all stored procedures in a given
-	 * database.
-	 * @param conn Connection to the source database.
-	 * @return The DDL for the stored procedures has been
-	 *  written to output via Logs.java.
-	 ****/
-
-	public static void doStoredProcedures(Connection conn)
-		throws SQLException {
-
-		Statement stmt = conn.createStatement();
-		ResultSet rs = stmt.executeQuery("SELECT ALIAS, ALIASINFO, " +
-			"ALIASID, SCHEMAID, JAVACLASSNAME, SYSTEMALIAS FROM SYS.SYSALIASES " +
-			"WHERE ALIASTYPE='P'");
-
-		boolean firstTime = true;
-		while (rs.next()) {
-
-			if (rs.getBoolean(6))
-			// it's a system alias, so we ignore it.
-				continue;
-
-			String procSchema = dblook.lookupSchemaId(rs.getString(4));
-			if (dblook.isIgnorableSchema(procSchema))
-				continue;
-
-			if (firstTime) {
-				Logs.reportString("----------------------------------------------");
-				Logs.reportMessage("DBLOOK_StoredProcHeader");
-				Logs.reportString("----------------------------------------------\n");
-			}
-
-			String procName = rs.getString(1);
-			String procFullName = dblook.addQuotes(
-				dblook.expandDoubleQuotes(procName));
-			procFullName = procSchema + "." + procFullName;
-
-			String creationString = createProcString(procFullName, rs);
-			Logs.writeToNewDDL(creationString);
-			Logs.writeStmtEndToNewDDL();
-			Logs.writeNewlineToNewDDL();
-			firstTime = false;
-
-		}
-
-		rs.close();
-		stmt.close();
-		return;
-
-	}
-
-	/* ************************************************
-	 * Generate DDL for a specific stored procedure.
-	 * @param procName Name of the current stored procedure.
-	 * @param aProc Info about the current stored procedure.
-	 * @return DDL for the current stored procedure is
-	 *   returned, as a String.
-	 ****/
-
-	private static String createProcString(String procName,
-		ResultSet aProc) throws SQLException
-	{
-
-		StringBuffer proc = new StringBuffer("CREATE PROCEDURE ");
-		proc.append(procName);
-		proc.append(" ");
-
-		String params = aProc.getString(2);
-
-		// Just grab the parameter part; we'll get the method name later.
-		proc.append(params.substring(params.indexOf("("), params.length()));
-		proc.append(" ");
-
-		// Now add the external name.
-		proc.append("EXTERNAL NAME '");
-		proc.append(aProc.getString(5));
-		proc.append(".");
-		// Get method name from parameter string fetched above.
-		proc.append(params.substring(0, params.indexOf("(")));
-		proc.append("' ");
-
-		return proc.toString();
-
-	}
-
-	/* ************************************************
-	 * Generate the DDL for all synonyms in a given
-	 * database. On successul return, the DDL for the stored procedures
-	 * has been written to output via Logs.java.
-	 * @param conn Connection to the source database.
-	 * @return 
-	 ****/
-	public static void doSynonyms(Connection conn) throws SQLException
-	{
-		Statement stmt = conn.createStatement();
-		ResultSet rs = stmt.executeQuery("SELECT ALIAS, SCHEMAID, " +
-			"ALIASINFO, SYSTEMALIAS FROM SYS.SYSALIASES A WHERE ALIASTYPE='S'");
-
-		boolean firstTime = true;
-		while (rs.next()) {
-			if (rs.getBoolean(4))
-			// it's a system alias, so we ignore it.
-				continue;
-
-			String aliasSchema = dblook.lookupSchemaId(rs.getString(2));
-			if (dblook.isIgnorableSchema(aliasSchema))
-				continue;
-
-			if (firstTime) {
-				Logs.reportString("----------------------------------------------");
-				Logs.reportMessage("DBLOOK_SynonymHeader");
-				Logs.reportString("----------------------------------------------\n");
-			}
-
-			String aliasName = rs.getString(1);
-			String aliasFullName = dblook.addQuotes(
-				dblook.expandDoubleQuotes(aliasName));
-			aliasFullName = aliasSchema + "." + aliasFullName;
-
-			Logs.writeToNewDDL("CREATE SYNONYM "+aliasFullName+" FOR "+rs.getString(3));
-			Logs.writeStmtEndToNewDDL();
-			Logs.writeNewlineToNewDDL();
-			firstTime = false;
-		}
-
-		rs.close();
-		stmt.close();
-		return;
-
-	}
-}
diff --git a/incubator/derby/code/trunk/java/tools/org/apache/derby/tools/dblook.java b/incubator/derby/code/trunk/java/tools/org/apache/derby/tools/dblook.java
index d6143c9d..61c8bc3e 100644
--- a/incubator/derby/code/trunk/java/tools/org/apache/derby/tools/dblook.java
+++ b/incubator/derby/code/trunk/java/tools/org/apache/derby/tools/dblook.java
@@ -44,7 +44,7 @@
 import org.apache.derby.impl.tools.dblook.DB_Key;
 import org.apache.derby.impl.tools.dblook.DB_Table;
 import org.apache.derby.impl.tools.dblook.DB_Schema;
-import org.apache.derby.impl.tools.dblook.DB_StoredProcedure;
+import org.apache.derby.impl.tools.dblook.DB_Alias;
 import org.apache.derby.impl.tools.dblook.DB_Trigger;
 import org.apache.derby.impl.tools.dblook.DB_View;
 import org.apache.derby.impl.tools.dblook.Logs;
@@ -523,12 +523,12 @@ private void go()
 			if (tableList == null) {
 			// Don't do these if user just wants table-related objects.
 				DB_Jar.doJars(sourceDBName, this.conn);
-				DB_StoredProcedure.doStoredProcedures(this.conn);
+				DB_Alias.doProceduresAndFunctions(this.conn);
 			}
 
 			DB_Table.doTables(this.conn, tableIdToNameMap);
 			DB_Index.doIndexes(this.conn);
-			DB_StoredProcedure.doSynonyms(this.conn);
+			DB_Alias.doSynonyms(this.conn);
 			DB_Key.doKeys(this.conn);
 			DB_Check.doChecks(this.conn);
 
