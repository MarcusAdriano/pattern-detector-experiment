diff --git a/lucene/dev/branches/lucene3453/lucene/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java b/lucene/dev/branches/lucene3453/lucene/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
index cf5c4c72..d8278da9 100644
--- a/lucene/dev/branches/lucene3453/lucene/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
+++ b/lucene/dev/branches/lucene3453/lucene/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
@@ -386,7 +386,7 @@ public void testNumericRangeQuery() throws Exception {
     Highlighter highlighter = new Highlighter(this, scorer);
     
     for (int i = 0; i < hits.totalHits; i++) {
-      String text = searcher.doc(hits.scoreDocs[i].doc).get(NUMERIC_FIELD_NAME);
+      String text = searcher.doc(hits.scoreDocs[i].doc).getField(NUMERIC_FIELD_NAME).numericValue().toString();
       TokenStream tokenStream = analyzer.tokenStream(FIELD_NAME, new StringReader(text));
 
       highlighter.setTextFragmenter(new SimpleFragmenter(40));
@@ -1738,25 +1738,21 @@ public void setUp() throws Exception {
       addDoc(writer, text);
     }
     Document doc = new Document();
-    NumericField nfield = new NumericField(NUMERIC_FIELD_NAME, NumericField.getFieldType(NumericField.DataType.INT, true));
-    nfield.setIntValue(1);
-    doc.add(nfield);
+    doc.add(new NumericField(NUMERIC_FIELD_NAME, 1, NumericField.getFieldType(NumericField.DataType.INT, true)));
     writer.addDocument(doc, analyzer);
-    nfield = new NumericField(NUMERIC_FIELD_NAME, NumericField.getFieldType(NumericField.DataType.INT, true));
-    nfield.setIntValue(3);
+
     doc = new Document();
-    doc.add(nfield);
+    doc.add(new NumericField(NUMERIC_FIELD_NAME, 3, NumericField.getFieldType(NumericField.DataType.INT, true)));
     writer.addDocument(doc, analyzer);
-    nfield = new NumericField(NUMERIC_FIELD_NAME, NumericField.getFieldType(NumericField.DataType.INT, true));
-    nfield.setIntValue(5);
+
     doc = new Document();
-    doc.add(nfield);
+    doc.add(new NumericField(NUMERIC_FIELD_NAME, 5, NumericField.getFieldType(NumericField.DataType.INT, true)));
     writer.addDocument(doc, analyzer);
-    nfield = new NumericField(NUMERIC_FIELD_NAME, NumericField.getFieldType(NumericField.DataType.INT, true));
-    nfield.setIntValue(7);
+
     doc = new Document();
-    doc.add(nfield);
+    doc.add(new NumericField(NUMERIC_FIELD_NAME, 7, NumericField.getFieldType(NumericField.DataType.INT, true)));
     writer.addDocument(doc, analyzer);
+
     writer.forceMerge(1);
     writer.close();
     reader = IndexReader.open(ramDir);
diff --git a/lucene/dev/branches/lucene3453/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java b/lucene/dev/branches/lucene3453/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
index 9bb1dde5..64f7bd1e 100644
--- a/lucene/dev/branches/lucene3453/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
+++ b/lucene/dev/branches/lucene3453/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
@@ -98,8 +98,8 @@ private void addPoint(IndexWriter writer, String name, double lat, double lng) t
     doc.add(newField("name", name, TextField.TYPE_STORED));
     
     // convert the lat / long to lucene fields
-    doc.add(new NumericField(latField, Integer.MAX_VALUE, NumericField.getFieldType(NumericField.DataType.DOUBLE, true)).setDoubleValue(lat));
-    doc.add(new NumericField(lngField, Integer.MAX_VALUE, NumericField.getFieldType(NumericField.DataType.DOUBLE, true)).setDoubleValue(lng));
+    doc.add(new NumericField(latField, lat, NumericField.getFieldType(NumericField.DataType.DOUBLE, true)));
+    doc.add(new NumericField(lngField, lng, NumericField.getFieldType(NumericField.DataType.DOUBLE, true)));
     
     // add a default meta field to make searching all documents easy 
     doc.add(newField("metafile", "doc", TextField.TYPE_STORED));
@@ -107,7 +107,7 @@ private void addPoint(IndexWriter writer, String name, double lat, double lng) t
     int ctpsize = ctps.size();
     for (int i =0; i < ctpsize; i++){
       CartesianTierPlotter ctp = ctps.get(i);
-      doc.add(new NumericField(ctp.getTierFieldName(), Integer.MAX_VALUE, NumericField.getFieldType(NumericField.DataType.DOUBLE, true)).setDoubleValue(ctp.getTierBoxId(lat,lng)));
+      doc.add(new NumericField(ctp.getTierFieldName(), ctp.getTierBoxId(lat, lng), NumericField.getFieldType(NumericField.DataType.DOUBLE, true)));
       
       doc.add(newField(geoHashPrefix, GeoHashUtils.encode(lat,lng), StringField.TYPE_STORED));
     }
@@ -248,8 +248,8 @@ public void testAntiM() throws IOException, InvalidGeoException {
       Document d = searcher.doc(scoreDocs[i].doc);
 
       String name = d.get("name");
-      double rsLat = Double.parseDouble(d.get(latField));
-      double rsLng = Double.parseDouble(d.get(lngField));
+      double rsLat = d.getField(latField).numericValue().doubleValue();
+      double rsLng = d.getField(lngField).numericValue().doubleValue();
       Double geo_distance = distances.get(scoreDocs[i].doc);
 
       double distance = DistanceUtils.getDistanceMi(lat, lng, rsLat, rsLng);
@@ -317,8 +317,8 @@ public void testPoleFlipping() throws IOException, InvalidGeoException {
     for(int i =0 ; i < results; i++){
       Document d = searcher.doc(scoreDocs[i].doc);
       String name = d.get("name");
-      double rsLat = Double.parseDouble(d.get(latField));
-      double rsLng = Double.parseDouble(d.get(lngField));
+      double rsLat = d.getField(latField).numericValue().doubleValue();
+      double rsLng = d.getField(lngField).numericValue().doubleValue();
       Double geo_distance = distances.get(scoreDocs[i].doc);
 
       double distance = DistanceUtils.getDistanceMi(lat, lng, rsLat, rsLng);
@@ -389,8 +389,8 @@ public void testRange() throws IOException, InvalidGeoException {
         Document d = searcher.doc(scoreDocs[i].doc);
       
         String name = d.get("name");
-        double rsLat = Double.parseDouble(d.get(latField));
-        double rsLng = Double.parseDouble(d.get(lngField)); 
+        double rsLat = d.getField(latField).numericValue().doubleValue();
+        double rsLng = d.getField(lngField).numericValue().doubleValue(); 
         Double geo_distance = distances.get(scoreDocs[i].doc);
       
         double distance = DistanceUtils.getDistanceMi(lat, lng, rsLat, rsLng);
@@ -461,8 +461,8 @@ public void testGeoHashRange() throws IOException, InvalidGeoException {
         Document d = searcher.doc(scoreDocs[i].doc);
 	      
         String name = d.get("name");
-        double rsLat = Double.parseDouble(d.get(latField));
-        double rsLng = Double.parseDouble(d.get(lngField)); 
+        double rsLat = d.getField(latField).numericValue().doubleValue();
+        double rsLng = d.getField(lngField).numericValue().doubleValue(); 
         Double geo_distance = distances.get(scoreDocs[i].doc);
 	      
         double distance = DistanceUtils.getDistanceMi(lat, lng, rsLat, rsLng);
diff --git a/lucene/dev/branches/lucene3453/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestDistance.java b/lucene/dev/branches/lucene3453/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestDistance.java
index 9f6707b1..6a4ed916 100644
--- a/lucene/dev/branches/lucene3453/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestDistance.java
+++ b/lucene/dev/branches/lucene3453/lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestDistance.java
@@ -66,8 +66,8 @@ private void addPoint(IndexWriter writer, String name, double lat, double lng) t
     doc.add(newField("name", name, TextField.TYPE_STORED));
     
     // convert the lat / long to lucene fields
-    doc.add(new NumericField(latField, Integer.MAX_VALUE, NumericField.getFieldType(NumericField.DataType.DOUBLE, true)).setDoubleValue(lat));
-    doc.add(new NumericField(lngField, Integer.MAX_VALUE, NumericField.getFieldType(NumericField.DataType.DOUBLE, true)).setDoubleValue(lng));
+    doc.add(new NumericField(latField, lat, NumericField.getFieldType(NumericField.DataType.DOUBLE, true)));
+    doc.add(new NumericField(lngField, lng, NumericField.getFieldType(NumericField.DataType.DOUBLE, true)));
     
     // add a default meta field to make searching all documents easy 
     doc.add(newField("metafile", "doc", TextField.TYPE_STORED));
diff --git a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/codecs/DocValuesConsumer.java b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/codecs/DocValuesConsumer.java
index 82a7e360..7efe4d52 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/codecs/DocValuesConsumer.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/codecs/DocValuesConsumer.java
@@ -19,9 +19,8 @@
 import java.io.IOException;
 
 import org.apache.lucene.codecs.lucene40.values.Writer;
+import org.apache.lucene.document.DocValuesField;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.StringField;
 import org.apache.lucene.index.DocValues.Source;
 import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.IndexableField;
@@ -112,9 +111,40 @@ protected void merge(DocValues reader, int docBase, int docCount, Bits liveDocs)
     final Source source = reader.getDirectSource();
     assert source != null;
     int docID = docBase;
-    FieldType ft = new FieldType(StringField.TYPE_UNSTORED);
-    ft.setDocValueType(reader.type());
-    final Field scratchField = new Field("", "", ft);
+    final DocValues.Type type = reader.type();
+    final Field scratchField;
+    switch(type) {
+    case VAR_INTS:
+      scratchField = new DocValuesField("", (long) 0, type);
+      break;
+    case FIXED_INTS_16:
+      scratchField = new DocValuesField("", (short) 0, type);
+      break;
+    case FIXED_INTS_32:
+      scratchField = new DocValuesField("", 0, type);
+      break;
+    case FIXED_INTS_64:
+      scratchField = new DocValuesField("", (long) 0, type);
+      break;
+    case FIXED_INTS_8:
+      scratchField = new DocValuesField("", (byte) 0, type);
+      break;
+    case FLOAT_32:
+      scratchField = new DocValuesField("", (float) 0, type);
+      break;
+    case FLOAT_64:
+      scratchField = new DocValuesField("", (double) 0, type);
+      break;
+    case BYTES_FIXED_STRAIGHT:
+    case BYTES_FIXED_DEREF:
+    case BYTES_VAR_STRAIGHT:
+    case BYTES_VAR_DEREF:
+      scratchField = new DocValuesField("", new BytesRef(), type);
+      break;
+    default:
+      assert false;
+      scratchField = null;
+    }
     for (int i = 0; i < docCount; i++) {
       if (liveDocs == null || liveDocs.get(i)) {
         mergeDoc(scratchField, source, docID++, i);
diff --git a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/DocValuesField.java b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/DocValuesField.java
index e7c0a3e7..badc2bc4 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/DocValuesField.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/DocValuesField.java
@@ -16,7 +16,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import java.io.Reader;
 import java.util.Comparator;
 
 import org.apache.lucene.index.IndexableFieldType;
@@ -31,14 +30,16 @@
  * example usage, adding an int value:
  * 
  * <pre>
- * document.add(new DocValuesField(name).setInt(value));
+ * DocValuesField field = new DocValuesField(name, DocValues.Type.VAR_INTS);
+ * field.setInt(value);
+ * document.add(field);
  * </pre>
  * 
  * For optimal performance, re-use the <code>DocValuesField</code> and
  * {@link Document} instance for more than one document:
  * 
  * <pre>
- *  DocValuesField field = new DocValuesField(name);
+ *  DocValuesField field = new DocValuesField(name, DocValues.Type.VAR_INTS);
  *  Document document = new Document();
  *  document.add(field);
  * 
@@ -73,185 +74,119 @@
 
 public class DocValuesField extends Field {
 
-  protected BytesRef bytes;
-  protected Number numberValue;
   protected Comparator<BytesRef> bytesComparator;
 
-  // nocommit sugar ctors taking byte, short, int, etc.?
-
-  /**
-   * Creates a new {@link DocValuesField} with the given name.
-   */
-  public DocValuesField(String name, DocValues.Type docValueType) {
+  public DocValuesField(String name, BytesRef bytes, DocValues.Type docValueType) {
     super(name, new FieldType());
-    if (docValueType == null) {
-      throw new NullPointerException("docValueType cannot be null");
+    // nocommit use enumset
+    if (docValueType != DocValues.Type.BYTES_FIXED_STRAIGHT &&
+        docValueType != DocValues.Type.BYTES_FIXED_DEREF &&
+        docValueType != DocValues.Type.BYTES_VAR_STRAIGHT &&
+        docValueType != DocValues.Type.BYTES_VAR_DEREF &&
+        docValueType != DocValues.Type.BYTES_FIXED_SORTED &&
+        docValueType != DocValues.Type.BYTES_VAR_SORTED) {
+      throw new IllegalArgumentException("docValueType must be BYTE_FIXED_STRAIGHT, BYTE_FIXED_DEREF, BYTES_VAR_STRAIGHT, BYTES_VAR_DEREF, BYTES_FIXED_SORTED or BYTES_VAR_SORTED; got " + docValueType);
     }
+    fieldsData = bytes;
     FieldType ft = (FieldType) type;
     ft.setDocValueType(docValueType);
     ft.freeze();
   }
 
-  public DocValuesField(String name, IndexableFieldType type) {
-    super(name, type);
-    if (type.docValueType() == null) {
-      throw new NullPointerException("docValueType cannot be null");
-    }
-  }
-
-  /**
-   * Sets the given <code>long</code> value.
-   */
-  public void setInt(long value) {
-    // nocommit assert type matches
-    numberValue = value;
-  }
-
-  /**
-   * Sets the given <code>int</code> value.
-   */
-  public void setInt(int value) {
-    // nocommit assert type matches
-    numberValue = value;
+  public DocValuesField(String name, byte value, DocValues.Type docValueType) {
+    super(name, new FieldType());
+    // nocommit use enumset
+    if (docValueType != DocValues.Type.VAR_INTS &&
+        docValueType != DocValues.Type.FIXED_INTS_8 &&
+        docValueType != DocValues.Type.FIXED_INTS_16 &&
+        docValueType != DocValues.Type.FIXED_INTS_32 &&
+        docValueType != DocValues.Type.FIXED_INTS_64) {
+      throw new IllegalArgumentException("docValueType must be VAR_INTS, FIXED_INTS_8/16/32/64; got " + docValueType);
   }
-
-  /**
-   * Sets the given <code>short</code> value.
-   */
-  public void setInt(short value) {
-    // nocommit assert type matches
-    numberValue = value;
+    FieldType ft = (FieldType) type;
+    ft.setDocValueType(docValueType);
+    ft.freeze();
+    fieldsData = Byte.valueOf(value);
   }
 
-  /**
-   * Sets the given <code>byte</code> value.
-   */
-  public void setInt(byte value) {
-    // nocommit assert type matches
-    numberValue = value;
+  public DocValuesField(String name, short value, DocValues.Type docValueType) {
+    super(name, new FieldType());
+    // nocommit use enumset
+    if (docValueType != DocValues.Type.VAR_INTS &&
+        docValueType != DocValues.Type.FIXED_INTS_8 &&
+        docValueType != DocValues.Type.FIXED_INTS_16 &&
+        docValueType != DocValues.Type.FIXED_INTS_32 &&
+        docValueType != DocValues.Type.FIXED_INTS_64) {
+      throw new IllegalArgumentException("docValueType must be VAR_INTS, FIXED_INTS_8/16/32/64; got " + docValueType);
   }
-
-  /**
-   * Sets the given <code>float</code> value.
-   */
-  public void setFloat(float value) {
-    // nocommit assert type matches
-    numberValue = value;
+    FieldType ft = (FieldType) type;
+    ft.setDocValueType(docValueType);
+    ft.freeze();
+    fieldsData = Short.valueOf(value);
   }
 
-  /**
-   * Sets the given <code>double</code> value.
-   */
-  public void setFloat(double value) {
-    // nocommit assert type matches
-    numberValue = value;
+  public DocValuesField(String name, int value, DocValues.Type docValueType) {
+    super(name, new FieldType());
+    // nocommit use enumset
+    if (docValueType != DocValues.Type.VAR_INTS &&
+        docValueType != DocValues.Type.FIXED_INTS_8 &&
+        docValueType != DocValues.Type.FIXED_INTS_16 &&
+        docValueType != DocValues.Type.FIXED_INTS_32 &&
+        docValueType != DocValues.Type.FIXED_INTS_64) {
+      throw new IllegalArgumentException("docValueType must be VAR_INTS, FIXED_INTS_8/16/32/64; got " + docValueType);
   }
-
-  /**
-   * Sets the given {@link BytesRef} value.
-   */
-  public void setBytes(BytesRef value) {
-    bytes = value;
+    FieldType ft = (FieldType) type;
+    ft.setDocValueType(docValueType);
+    ft.freeze();
+    fieldsData = Integer.valueOf(value);
   }
 
-  /**
-   * Sets the given {@link BytesRef} value, the field's {@link Type} and the
-   * field's comparator. If the {@link Comparator} is set to <code>null</code>
-   * the default for the given {@link Type} is used instead.
-   * 
-   * @throws IllegalArgumentException
-   *           if the value or the type are null
-   */
-  // nocommit what to do w/ comparator...
-  /*
-  public void setBytes(BytesRef value, DocValues.Type type, Comparator<BytesRef> comp) {
-    if (value == null) {
-      throw new IllegalArgumentException("value must not be null");
-    }
-    setDocValuesType(type);
-    if (bytes == null) {
-      bytes = BytesRef.deepCopyOf(value);
-    } else {
-      bytes.copyBytes(value);
+  public DocValuesField(String name, long value, DocValues.Type docValueType) {
+    super(name, new FieldType());
+    // nocommit use enumset
+    if (docValueType != DocValues.Type.VAR_INTS &&
+        docValueType != DocValues.Type.FIXED_INTS_8 &&
+        docValueType != DocValues.Type.FIXED_INTS_16 &&
+        docValueType != DocValues.Type.FIXED_INTS_32 &&
+        docValueType != DocValues.Type.FIXED_INTS_64) {
+      throw new IllegalArgumentException("docValueType must be VAR_INTS, FIXED_INTS_8/16/32/64; got " + docValueType);
     }
-    bytesComparator = comp;
-  }
-  */
-
-  @Override
-  public BytesRef binaryValue() {
-    return bytes;
+    FieldType ft = (FieldType) type;
+    ft.setDocValueType(docValueType);
+    ft.freeze();
+    fieldsData = Long.valueOf(value);
   }
 
-  /**
-   * Returns the set {@link BytesRef} comparator or <code>null</code> if not set
-   */
-  /*
-  public Comparator<BytesRef> bytesComparator() {
-    return bytesComparator;
+  public DocValuesField(String name, float value, DocValues.Type docValueType) {
+    super(name, new FieldType());
+    if (docValueType != DocValues.Type.FLOAT_32 &&
+        docValueType != DocValues.Type.FLOAT_64) {
+      throw new IllegalArgumentException("docValueType must be FLOAT_32/64; got " + docValueType);
   }
-  */
-
-  @Override
-  public Number numericValue() {
-    return numberValue;
+    FieldType ft = (FieldType) type;
+    ft.setDocValueType(docValueType);
+    ft.freeze();
+    fieldsData = Float.valueOf(value);
   }
 
-  /**
-   * Sets the {@link BytesRef} comparator for this field. If the field has a
-   * numeric {@link Type} the comparator will be ignored.
-   */
-  /*
-  public void setBytesComparator(Comparator<BytesRef> comp) {
-    this.bytesComparator = comp;
+  public DocValuesField(String name, double value, DocValues.Type docValueType) {
+    super(name, new FieldType());
+    if (docValueType != DocValues.Type.FLOAT_32 &&
+        docValueType != DocValues.Type.FLOAT_64) {
+      throw new IllegalArgumentException("docValueType must be FLOAT_32/64; got " + docValueType);
   }
-  */
-
-  /**
-   * Returns always <code>null</code>
-   */
-  @Override
-  public Reader readerValue() {
-    return null;
+    FieldType ft = (FieldType) type;
+    ft.setDocValueType(docValueType);
+    ft.freeze();
+    fieldsData = Double.valueOf(value);
   }
 
-  @Override
-  public String toString() {
-    final String value;
-    switch (type.docValueType()) {
-    case BYTES_FIXED_DEREF:
-    case BYTES_FIXED_STRAIGHT:
-    case BYTES_VAR_DEREF:
-    case BYTES_VAR_STRAIGHT:
-    case BYTES_FIXED_SORTED:
-    case BYTES_VAR_SORTED:
-      // don't use to unicode string this is not necessarily unicode here
-      value = "bytes: " + bytes.toString();
-      break;
-    case FIXED_INTS_16:
-      value = "int16: " + numberValue;
-      break;
-    case FIXED_INTS_32:
-      value = "int32: " + numberValue;
-      break;
-    case FIXED_INTS_64:
-      value = "int64: " + numberValue;
-      break;
-    case FIXED_INTS_8:
-      value = "int8: " + numberValue;
-      break;
-    case VAR_INTS:
-      value = "vint: " + numberValue;
-      break;
-    case FLOAT_32:
-      value = "float32: " + numberValue;
-      break;
-    case FLOAT_64:
-      value = "float64: " + numberValue;
-      break;
-    default:
-      throw new IllegalArgumentException("unknown type: " + type);
+  // nocommit need static or dynamic type checking here:
+  public DocValuesField(String name, Object value, IndexableFieldType type) {
+    super(name, type);
+    if (type.docValueType() == null) {
+      throw new NullPointerException("docValueType cannot be null");
     }
-    return "<" + name() + ": DocValuesField " + value + ">";
+    fieldsData = value;
   }
 }
diff --git a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/DocumentStoredFieldVisitor.java b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/DocumentStoredFieldVisitor.java
index 9af745a2..5ee7961a 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/DocumentStoredFieldVisitor.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/DocumentStoredFieldVisitor.java
@@ -74,25 +74,25 @@ public void stringField(FieldInfo fieldInfo, String value) throws IOException {
   @Override
   public void intField(FieldInfo fieldInfo, int value) {
     FieldType ft = NumericField.getFieldType(NumericField.DataType.INT, true);
-    doc.add(new NumericField(fieldInfo.name, ft).setIntValue(value));
+    doc.add(new NumericField(fieldInfo.name, Integer.valueOf(value), ft));
   }
 
   @Override
   public void longField(FieldInfo fieldInfo, long value) {
     FieldType ft = NumericField.getFieldType(NumericField.DataType.LONG, true);
-    doc.add(new NumericField(fieldInfo.name, ft).setLongValue(value));
+    doc.add(new NumericField(fieldInfo.name, Long.valueOf(value), ft));
   }
 
   @Override
   public void floatField(FieldInfo fieldInfo, float value) {
     FieldType ft = NumericField.getFieldType(NumericField.DataType.FLOAT, true);
-    doc.add(new NumericField(fieldInfo.name, ft).setFloatValue(value));
+    doc.add(new NumericField(fieldInfo.name, Float.valueOf(value), ft));
   }
 
   @Override
   public void doubleField(FieldInfo fieldInfo, double value) {
     FieldType ft = NumericField.getFieldType(NumericField.DataType.DOUBLE, true);
-    doc.add(new NumericField(fieldInfo.name, ft).setDoubleValue(value));
+    doc.add(new NumericField(fieldInfo.name, Double.valueOf(value), ft));
   }
 
   @Override
diff --git a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/Field.java b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/Field.java
index a1a87482..66826134 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/Field.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/Field.java
@@ -22,19 +22,26 @@
 import java.io.StringReader;
 
 import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.NumericTokenStream;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
-import org.apache.lucene.index.IndexableFieldType;
 import org.apache.lucene.index.IndexableField;
+import org.apache.lucene.index.IndexableFieldType;
 import org.apache.lucene.util.BytesRef;
 
 /**
- * A field is a section of a Document. Each field has three
+ * Expert: directly creata a field for a document.  Most
+ * users should use one of the sugar subclasses {@link
+ * NumericField}, {@link DocValuesField}, {@link
+ * StringField}, {@link TextField}, {@link BinaryField}.
+ *
+ * <p/> A field is a section of a Document. Each field has three
  * parts: name, type andvalue. Values may be text
  * (String, Reader or pre-analyzed TokenStream), binary
  * (byte[]), or numeric (a Number).  Fields are optionally stored in the
  * index, so that they may be returned with hits on the document.
+ *
  * <p/>
  * NOTE: the field type is an {@link IndexableFieldType}.  Making changes
  * to the state of the IndexableFieldType will impact any
@@ -45,14 +52,17 @@
   
   protected final IndexableFieldType type;
   protected final String name;
-  // the data object for all different kind of field values
+
+  // Field's value:
   protected Object fieldsData;
 
-  // nocommit why not stuffed into fieldsData...?  hmm are you
-  // allowed to have field value *and* tokenStream?... messy
-  // pre-analyzed tokenStream for indexed fields
+  // Pre-analyzed tokenStream for indexed fields; this is
+  // separate from fieldsData because you are allowed to
+  // have both; eg maybe field has a String value but you
+  // customize how it's tokenized:
   protected TokenStream tokenStream;
-  // length/offset for all primitive types
+
+  protected transient NumericTokenStream numericTokenStream;
 
   protected float boost = 1.0f;
 
@@ -61,15 +71,21 @@ protected Field(String name, IndexableFieldType type) {
     this.type = type;
   }
   
+  /**
+   * Create field with Reader value.
+   */
   public Field(String name, Reader reader, IndexableFieldType type) {
     if (name == null) {
-      throw new NullPointerException("name cannot be null");
+      throw new IllegalArgumentException("name cannot be null");
     }
     if (reader == null) {
       throw new NullPointerException("reader cannot be null");
     }
+    if (type.stored()) {
+      throw new IllegalArgumentException("fields with a Reader value cannot be stored");
+    }
     if (type.indexed() && !type.tokenized()) {
-      throw new IllegalArgumentException("Non-tokenized fields must use String values");
+      throw new IllegalArgumentException("non-tokenized fields must use String values");
     }
     
     this.name = name;
@@ -77,22 +93,22 @@ public Field(String name, Reader reader, IndexableFieldType type) {
     this.type = type;
   }
 
+  /**
+   * Create field with TokenStream value.
+   */
   public Field(String name, TokenStream tokenStream, IndexableFieldType type) {
     if (name == null) {
-      throw new NullPointerException("name cannot be null");
+      throw new IllegalArgumentException("name cannot be null");
     }
     if (tokenStream == null) {
       throw new NullPointerException("tokenStream cannot be null");
     }
-    if (!type.indexed()) {
-      throw new IllegalArgumentException("TokenStream fields must be indexed");
+    if (!type.indexed() || !type.tokenized()) {
+      throw new IllegalArgumentException("TokenStream fields must be indexed and tokenized");
     }
     if (type.stored()) {
       throw new IllegalArgumentException("TokenStream fields cannot be stored");
     }
-    if (type.indexed() && !type.tokenized()) {
-      throw new IllegalArgumentException("Non-tokenized fields must use String values");
-    }
     
     this.name = name;
     this.fieldsData = null;
@@ -100,28 +116,41 @@ public Field(String name, TokenStream tokenStream, IndexableFieldType type) {
     this.type = type;
   }
   
+  /**
+   * Create field with binary value.
+   */
   public Field(String name, byte[] value, IndexableFieldType type) {
     this(name, value, 0, value.length, type);
   }
 
+  /**
+   * Create field with binary value.
+   */
   public Field(String name, byte[] value, int offset, int length, IndexableFieldType type) {
     this(name, new BytesRef(value, offset, length), type);
   }
 
-  // nocommit numerics ctors too
-
+  /**
+   * Create field with binary value.
+   *
+   * <p>NOTE: the provided BytesRef is not copied so be sure
+   * not to change it until you're done with this field.
+   */
   public Field(String name, BytesRef bytes, IndexableFieldType type) {
-    if (type.indexed() && !type.tokenized()) {
-      throw new IllegalArgumentException("Non-tokenized fields must use String values");
+    if (name == null) {
+      throw new IllegalArgumentException("name cannot be null");
+    }
+    if (type.indexed()) {
+      throw new IllegalArgumentException("Fields with BytesRef values cannot be indexed");
     }
-
     this.fieldsData = bytes;
     this.type = type;
     this.name = name;
   }
 
-  // nocommit test case for LUCENE-3616 (and other invalid combos)
-  
+  /**
+   * Create field with String value.
+   */
   public Field(String name, String value, IndexableFieldType type) {
     if (name == null) {
       throw new IllegalArgumentException("name cannot be null");
@@ -130,8 +159,6 @@ public Field(String name, String value, IndexableFieldType type) {
       throw new IllegalArgumentException("value cannot be null");
     }
     if (!type.stored() && !type.indexed()) {
-      // nocommit... but it could be DocValue'd (only) tand
-      // that's ok...?
       throw new IllegalArgumentException("it doesn't make sense to have a field that "
         + "is neither indexed nor stored");
     }
@@ -145,8 +172,6 @@ public Field(String name, String value, IndexableFieldType type) {
     this.fieldsData = value;
   }
 
-  // nocommit Object getValue()?
-
   /**
    * The value of the field as a String, or null. If null, the Reader value or
    * binary value is used. Exactly one of stringValue(), readerValue(), and
@@ -190,9 +215,8 @@ public TokenStream tokenStreamValue() {
    * </p>
    */
   public void setValue(String value) {
-    if (isBinary()) {
-      throw new IllegalArgumentException(
-          "cannot set a String value on a binary field");
+    if (!(fieldsData instanceof String)) {
+      throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to String");
     }
     fieldsData = value;
   }
@@ -202,13 +226,8 @@ public void setValue(String value) {
    * href="#setValue(java.lang.String)">setValue(String)</a>.
    */
   public void setValue(Reader value) {
-    if (isBinary()) {
-      throw new IllegalArgumentException(
-          "cannot set a Reader value on a binary field");
-    }
-    if (type.stored()) {
-      throw new IllegalArgumentException(
-          "cannot set a Reader value on a stored field");
+    if (!(fieldsData instanceof Reader)) {
+      throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to Reader");
     }
     fieldsData = value;
   }
@@ -217,23 +236,85 @@ public void setValue(Reader value) {
    * Expert: change the value of this field. See <a
    * href="#setValue(java.lang.String)">setValue(String)</a>.
    */
-  // nocommit why not setValue(bytesref)...?
   public void setValue(byte[] value) {
-    if (!isBinary()) {
-      throw new IllegalArgumentException(
-          "cannot set a byte[] value on a non-binary field");
-    }
-    fieldsData = new BytesRef(value);
+    setValue(new BytesRef(value));
   }
 
-  // nocommit jdocs warning that we hold ref
+  /**
+   * Expert: change the value of this field. See <a
+   * href="#setValue(java.lang.String)">setValue(String)</a>.
+   *
+   * <p>NOTE: the provided BytesRef is not copied so be sure
+   * not to change it until you're done with this field.
+   */
   public void setValue(BytesRef value) {
+    if (!(fieldsData instanceof BytesRef)) {
+      throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to BytesRef");
+    }
+    if (type.indexed()) {
+      throw new IllegalArgumentException("cannot set a Reader value on an indexed field");
+    }
     fieldsData = value;
   }
 
-  // nocommit jdocs
-  public void setValue(Number value) {
-    fieldsData = value;
+  public void setValue(byte value) {
+    if (!(fieldsData instanceof Byte)) {
+      throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to Byte");
+    }
+    if (numericTokenStream != null) {
+      numericTokenStream.setIntValue((int) value);
+    }
+    fieldsData = Byte.valueOf(value);
+  }
+
+  public void setValue(short value) {
+    if (!(fieldsData instanceof Short)) {
+      throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to Short");
+    }
+    if (numericTokenStream != null) {
+      numericTokenStream.setIntValue((int) value);
+    }
+    fieldsData = Short.valueOf(value);
+  }
+
+  public void setValue(int value) {
+    if (!(fieldsData instanceof Integer)) {
+      throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to Integer");
+    }
+    if (numericTokenStream != null) {
+      numericTokenStream.setIntValue(value);
+    }
+    fieldsData = Integer.valueOf(value);
+  }
+
+  public void setValue(long value) {
+    if (!(fieldsData instanceof Long)) {
+      throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to Long");
+    }
+    if (numericTokenStream != null) {
+      numericTokenStream.setLongValue(value);
+    }
+    fieldsData = Long.valueOf(value);
+  }
+
+  public void setValue(float value) {
+    if (!(fieldsData instanceof Float)) {
+      throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to Float");
+    }
+    if (numericTokenStream != null) {
+      numericTokenStream.setFloatValue(value);
+    }
+    fieldsData = Float.valueOf(value);
+  }
+
+  public void setValue(double value) {
+    if (!(fieldsData instanceof Double)) {
+      throw new IllegalArgumentException("cannot change value type from " + fieldsData.getClass().getSimpleName() + " to Double");
+    }
+    if (numericTokenStream != null) {
+      numericTokenStream.setDoubleValue(value);
+    }
+    fieldsData = Double.valueOf(value);
   }
 
   /**
@@ -243,8 +324,10 @@ public void setValue(Number value) {
    */
   public void setTokenStream(TokenStream tokenStream) {
     if (!type.indexed() || !type.tokenized()) {
-      throw new IllegalArgumentException(
-          "cannot set token stream on non indexed and tokenized field");
+      throw new IllegalArgumentException("TokenStream fields must be indexed and tokenized");
+    }
+    if (type.numericType() != null) {
+      throw new IllegalArgumentException("cannot set private TokenStream on numeric fields");
     }
     this.tokenStream = tokenStream;
   }
@@ -286,19 +369,13 @@ public Number numericValue() {
   }
 
   public BytesRef binaryValue() {
-    if (!isBinary()) {
-      return null;
-    } else {
+    if (fieldsData instanceof BytesRef) {
       return (BytesRef) fieldsData;
+    } else {
+      return null;
     }
   }
   
-  /** methods from inner IndexableFieldType */
-  
-  public boolean isBinary() {
-    return fieldsData instanceof BytesRef;
-  }
-  
   /** Prints a Field for human consumption. */
   @Override
   public String toString() {
@@ -316,7 +393,7 @@ public String toString() {
     return result.toString();
   }
   
-  /** Returns FieldType for this field. */
+  /** Returns the {@link IndexableFieldType} for this field. */
   public IndexableFieldType fieldType() {
     return type;
   }
@@ -329,6 +406,38 @@ public TokenStream tokenStream(Analyzer analyzer) throws IOException {
       return null;
     }
 
+    final NumericField.DataType numericType = fieldType().numericType();
+    if (numericType != null) {
+      if (numericTokenStream == null) {
+        // lazy init the TokenStream as it is heavy to instantiate
+        // (attributes,...) if not needed (stored field loading)
+        numericTokenStream = new NumericTokenStream(type.numericPrecisionStep());
+        // initialize value in TokenStream
+        final Number val = (Number) fieldsData;
+        switch (numericType) {
+        case INT:
+          numericTokenStream.setIntValue(val.intValue());
+          break;
+        case LONG:
+          numericTokenStream.setLongValue(val.longValue());
+          break;
+        case FLOAT:
+          numericTokenStream.setFloatValue(val.floatValue());
+          break;
+        case DOUBLE:
+          numericTokenStream.setDoubleValue(val.doubleValue());
+          break;
+        default:
+          assert false : "Should never get here";
+        }
+      } else {
+        // OK -- previously cached and we already updated if
+        // setters were called.
+      }
+
+      return numericTokenStream;
+    }
+
     if (!fieldType().tokenized()) {
       if (stringValue() == null) {
         throw new IllegalArgumentException("Non-Tokenized Fields must have a String value");
@@ -365,6 +474,6 @@ public void reset() throws IOException {
       return analyzer.tokenStream(name(), new StringReader(stringValue()));
     }
 
-    throw new IllegalArgumentException("Field must have either TokenStream, String or Reader value");
+    throw new IllegalArgumentException("Field must have either TokenStream, String, Reader or Number value");
   }
 }
diff --git a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/FieldType.java b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/FieldType.java
index 51d68295..e3da0c79 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/FieldType.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/FieldType.java
@@ -20,6 +20,7 @@
 import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.index.IndexableFieldType;
+import org.apache.lucene.util.NumericUtils;
 
 public class FieldType implements IndexableFieldType {
 
@@ -34,6 +35,7 @@
   private DocValues.Type docValueType;
   private NumericField.DataType numericType;
   private boolean frozen;
+  private int numericPrecisionStep = NumericUtils.PRECISION_STEP_DEFAULT;
 
   public FieldType(IndexableFieldType ref) {
     this.indexed = ref.indexed();
@@ -159,6 +161,19 @@ public void setNumericType(NumericField.DataType type) {
     return numericType;
   }
 
+  public void setNumericPrecisionStep(int precisionStep) {
+    checkIfFrozen();
+    if (precisionStep < 1) {
+      throw new IllegalArgumentException("precisionStep must be >= 1 (got " + precisionStep + ")");
+    }
+    this.numericPrecisionStep = precisionStep;
+  }
+
+  @Override
+  public int numericPrecisionStep() {
+    return numericPrecisionStep;
+  }
+
   /** Prints a Field for human consumption. */
   @Override
   public final String toString() {
@@ -197,9 +212,16 @@ public final String toString() {
         result.append(",indexOptions=");
         result.append(indexOptions);
       }
+      if (numericType != null) {
+        result.append(",numericType=");
+        result.append(numericType);
+        result.append(",numericPrecisionStep=");
+        result.append(numericPrecisionStep);
+      }
     }
     if (docValueType != null) {
-      result.append(",docValueType=" + docValueType);
+      result.append(",docValueType=");
+      result.append(docValueType);
     }
     
     return result.toString();
diff --git a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/NumericField.java b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/NumericField.java
index f34a940b..69437570 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/NumericField.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/document/NumericField.java
@@ -18,9 +18,6 @@
  */
 
 
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.NumericTokenStream;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.document.NumericField.DataType;
 import org.apache.lucene.util.NumericUtils;
@@ -35,20 +32,20 @@
  * int value:
  * 
  * <pre>
- * document.add(new NumericField(name).setIntValue(value));
+ * document.add(new NumericField(name, value));
  * </pre>
  * 
  * For optimal performance, re-use the <code>NumericField</code> and
  * {@link Document} instance for more than one document:
  * 
  * <pre>
- *  NumericField field = new NumericField(name);
+ *  NumericField field = new NumericField(name, NumericField.DataType.INT);
  *  Document document = new Document();
  *  document.add(field);
  * 
  *  for(all documents) {
  *    ...
- *    field.setIntValue(value)
+ *    field.setValue(value)
  *    writer.addDocument(document);
  *    ...
  *  }
@@ -136,10 +133,8 @@
   /** Data type of the value in {@link NumericField}.
    * @since 3.2
    */
-  public static enum DataType { INT, LONG, FLOAT, DOUBLE }
-
-  private transient NumericTokenStream numericTS;
-  private final int precisionStep;
+  // nocommit promote to oal.index
+  public static enum DataType {INT, LONG, FLOAT, DOUBLE}
 
   // nocommit -- we can precompute static array indexed by
   // type.ord()?  and give them names ... TYPE_INT_STORED, etc.
@@ -157,225 +152,70 @@ public static FieldType getFieldType(DataType type, boolean stored) {
     return ft;
   }
 
-  // nocommit: add sugar ctors taking native type value & inferring
-  // DataType from it...
-
-  /** Creates an int NumericField with the provided value. */
+  /** Creates an int NumericField with the provided value
+   *  and default <code>precisionStep</code> {@link
+   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). */
   public NumericField(String name, int value) {
-    this(name, NumericUtils.PRECISION_STEP_DEFAULT, getFieldType(DataType.INT, false));
-    setIntValue(value);
+    super(name, getFieldType(DataType.INT, false));
+    fieldsData = Integer.valueOf(value);
   }
 
-  /** Creates a long NumericField with the provided value. */
+  /** Creates a long NumericField with the provided value.
+   *  and default <code>precisionStep</code> {@link
+   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). */
   public NumericField(String name, long value) {
-    this(name, NumericUtils.PRECISION_STEP_DEFAULT, getFieldType(DataType.LONG, false));
-    setLongValue(value);
+    super(name, getFieldType(DataType.LONG, false));
+    fieldsData = Long.valueOf(value);
   }
 
-  /** Creates a float NumericField with the provided value. */
+  /** Creates a float NumericField with the provided value.
+   *  and default <code>precisionStep</code> {@link
+   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). */
   public NumericField(String name, float value) {
-    this(name, NumericUtils.PRECISION_STEP_DEFAULT, getFieldType(DataType.FLOAT, false));
-    setFloatValue(value);
+    super(name, getFieldType(DataType.FLOAT, false));
+    fieldsData = Float.valueOf(value);
   }
 
-  /** Creates a double NumericField with the provided value. */
+  /** Creates a double NumericField with the provided value.
+   *  and default <code>precisionStep</code> {@link
+   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). */
   public NumericField(String name, double value) {
-    this(name, NumericUtils.PRECISION_STEP_DEFAULT, getFieldType(DataType.DOUBLE, false));
-    setDoubleValue(value);
-  }
-  
-  /**
-   * Creates a field for numeric values using the default
-   * <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT} (4).
-   * The instance is not yet initialized with a numeric value, before indexing a
-   * document containing this field, set a value using the various set
-   * <em>???</em>Value() methods. This constructor creates an indexed, but not
-   * stored field.
-   * 
-   * @param name
-   *          the field name
-   */
-  public NumericField(String name, DataType type) {
-    this(name, NumericUtils.PRECISION_STEP_DEFAULT, getFieldType(type, false));
-  }
-  
-  /**
-   * Creates a field for numeric values using the default
-   * <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT} (4).
-   * The instance is not yet initialized with a numeric value, before indexing a
-   * document containing this field, set a value using the various set
-   * <em>???</em>Value() methods.
-   * 
-   * @param name
-   *          the field name
-   * @param type
-   *          if the defualt field should be altered, e.g. stored, 
-   *          {@link Document#getField} then returns {@code NumericField} 
-   *          instances on search results, or indexed using 
-   *          {@link NumericTokenStream}
-   */
-  public NumericField(String name, FieldType type) {
-    this(name, NumericUtils.PRECISION_STEP_DEFAULT, type);
-  }
-  
-  /**
-   * Creates a field for numeric values with the specified
-   * <code>precisionStep</code>. The instance is not yet initialized with a
-   * numeric value, before indexing a document containing this field, set a
-   * value using the various set<em>???</em>Value() methods. This constructor
-   * creates an indexed, but not stored field.
-   * 
-   * @param name
-   *          the field name
-   * @param precisionStep
-   *          the used <a
-   *          href="../search/NumericRangeQuery.html#precisionStepDesc"
-   *          >precision step</a>
-   */
-  public NumericField(String name, int precisionStep, DataType type) {
-    this(name, precisionStep, getFieldType(type, false));
+    super(name, getFieldType(DataType.DOUBLE, false));
+    fieldsData = Double.valueOf(value);
   }
   
-  /**
-   * Creates a field for numeric values with the specified
-   * <code>precisionStep</code>. The instance is not yet initialized with a
-   * numeric value, before indexing a document containing this field, set a
-   * value using the various set<em>???</em>Value() methods.
-   * 
-   * @param name
-   *          the field name
-   * @param precisionStep
-   *          the used <a
-   *          href="../search/NumericRangeQuery.html#precisionStepDesc"
-   *          >precision step</a>
-   * @param type
-   *          if the default field should be altered, e.g. stored, 
-   *          {@link Document#getField} then returns {@code NumericField} 
-   *          instances on search results, or indexed using 
-   *          {@link NumericTokenStream}
-   */
-  public NumericField(String name, int precisionStep, FieldType type) {
+  public NumericField(String name, Number value, FieldType type) {
     super(name, type);
-    if (type.numericType() == null) {
-      throw new IllegalArgumentException("FieldType.numericType() is null");
-    }
-    if (precisionStep < 1) {
-      throw new IllegalArgumentException("precisionStep must be >=1");
-    }
-    this.precisionStep = precisionStep;
+    final NumericField.DataType numericType = type.numericType();
+    if (numericType == null) {
+      throw new IllegalArgumentException("FieldType.numericType() cannot be null");
   }
   
-  /** Returns a {@link NumericTokenStream} for indexing the numeric value. */
-  public TokenStream tokenStream(Analyzer analyzer) {
-    if (!type.indexed()) return null;
-    if (numericTS == null) {
-      // lazy init the TokenStream as it is heavy to instantiate
-      // (attributes,...),
-      // if not needed (stored field loading)
-      numericTS = new NumericTokenStream(precisionStep);
-      // initialize value in TokenStream
-      final Number val = (Number) fieldsData;
-      switch (type.numericType()) {
+    switch(numericType) {
       case INT:
-        numericTS.setIntValue(val.intValue());
+      if (!(value instanceof Integer)) {
+        throw new IllegalArgumentException("value must be an Integer but got " + value);
+      }
         break;
       case LONG:
-        numericTS.setLongValue(val.longValue());
+      if (!(value instanceof Long)) {
+        throw new IllegalArgumentException("value must be a Long but got " + value);
+      }
         break;
       case FLOAT:
-        numericTS.setFloatValue(val.floatValue());
+      if (!(value instanceof Float)) {
+        throw new IllegalArgumentException("value must be a Float but got " + value);
+      }
         break;
       case DOUBLE:
-        numericTS.setDoubleValue(val.doubleValue());
+      if (!(value instanceof Double)) {
+        throw new IllegalArgumentException("value must be a Double but got " + value);
+      }
         break;
       default:
         assert false : "Should never get here";
       }
-    }
-    return numericTS;
-  }
-  
-  /**
-   * Returns the numeric value as a string. It is recommended to
-   * use {@link Document#getField} instead that returns {@code NumericField}
-   * instances. You can then use {@link #numericValue} to return the stored
-   * value.
-   */
-  @Override
-  public String stringValue() {
-    return (fieldsData == null) ? null : fieldsData.toString();
-  }
-  
-  /** Returns the precision step. */
-  public int getPrecisionStep() {
-    return precisionStep;
-  }
-  
-  /**
-   * Initializes the field with the supplied <code>long</code> value.
-   * 
-   * @param value
-   *          the numeric value
-   * @return this instance, because of this you can use it the following way:
-   *         <code>document.add(new NumericField(name, precisionStep).setLongValue(value))</code>
-   */
-  public NumericField setLongValue(final long value) {
-    if (type.numericType() != DataType.LONG) {
-      throw new IllegalArgumentException("cannot set long value when FieldType.numericType() is " + type.numericType());
-    }
-    if (numericTS != null) numericTS.setLongValue(value);
-    fieldsData = Long.valueOf(value);
-    return this;
-  }
   
-  /**
-   * Initializes the field with the supplied <code>int</code> value.
-   * 
-   * @param value
-   *          the numeric value
-   * @return this instance, because of this you can use it the following way:
-   *         <code>document.add(new NumericField(name, precisionStep).setIntValue(value))</code>
-   */
-  public NumericField setIntValue(final int value) {
-    if (type.numericType() != DataType.INT) {
-      throw new IllegalArgumentException("cannot set int value when FieldType.numericType() is " + type.numericType());
-    }
-    if (numericTS != null) numericTS.setIntValue(value);
-    fieldsData = Integer.valueOf(value);
-    return this;
-  }
-  
-  /**
-   * Initializes the field with the supplied <code>double</code> value.
-   * 
-   * @param value
-   *          the numeric value
-   * @return this instance, because of this you can use it the following way:
-   *         <code>document.add(new NumericField(name, precisionStep).setDoubleValue(value))</code>
-   */
-  public NumericField setDoubleValue(final double value) {
-    if (type.numericType() != DataType.DOUBLE) {
-      throw new IllegalArgumentException("cannot set double value when FieldType.numericType() is " + type.numericType());
-    }
-    if (numericTS != null) numericTS.setDoubleValue(value);
-    fieldsData = Double.valueOf(value);
-    return this;
-  }
-  
-  /**
-   * Initializes the field with the supplied <code>float</code> value.
-   * 
-   * @param value
-   *          the numeric value
-   * @return this instance, because of this you can use it the following way:
-   *         <code>document.add(new NumericField(name, precisionStep).setFloatValue(value))</code>
-   */
-  public NumericField setFloatValue(final float value) {
-    if (type.numericType() != DataType.FLOAT) {
-      throw new IllegalArgumentException("cannot set float value when FieldType.numericType() is " + type.numericType());
-    }
-    if (numericTS != null) numericTS.setFloatValue(value);
-    fieldsData = Float.valueOf(value);
-    return this;
+    fieldsData = value;
   }
 }
diff --git a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/DocValues.java b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/DocValues.java
index 2703cc11..8ba6d3a3 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/DocValues.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/DocValues.java
@@ -493,6 +493,7 @@ public int getValueCount() {
      * </p>
      */
     FIXED_INTS_64,
+
     /**
      * A 32 bit floating point value. By default there is no compression
      * applied. To fit custom float values into less than 32bit either a custom
@@ -507,6 +508,7 @@ public int getValueCount() {
      * </p>
      */
     FLOAT_32,
+
     /**
      * 
      * A 64 bit floating point value. By default there is no compression
@@ -613,7 +615,6 @@ public int getValueCount() {
      * @see SortedSource
      */
     BYTES_FIXED_SORTED
-    
   }
   
   /**
diff --git a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/IndexableFieldType.java b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/IndexableFieldType.java
index 084dc255..3e14db7b 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/IndexableFieldType.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/IndexableFieldType.java
@@ -58,4 +58,7 @@
    * non-null then the field's value will be indexed
    * numerically. */
   public NumericField.DataType numericType();
+
+  /** Precision step for numeric field. */
+  public int numericPrecisionStep();
 }
diff --git a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/NormsConsumer.java b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/NormsConsumer.java
index 8bbd9b3c..12106111 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/NormsConsumer.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/NormsConsumer.java
@@ -73,8 +73,7 @@ public void flush(Map<FieldInfo,InvertedDocEndConsumerPerField> fieldsToFlush, S
             } else if (fi.isIndexed) {
               anythingFlushed = true;
               final DocValuesConsumer valuesConsumer = newConsumer(new PerDocWriteState(state), fi);
-              final DocValuesField value = new DocValuesField("", Type.BYTES_FIXED_STRAIGHT);
-              value.setBytes(new BytesRef(new byte[] {0x00}));
+              final DocValuesField value = new DocValuesField("", new BytesRef(new byte[] {0x0}), Type.BYTES_FIXED_STRAIGHT);
               valuesConsumer.add(state.numDocs-1, value);
               valuesConsumer.finish(state.numDocs);
             }
diff --git a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/NormsConsumerPerField.java b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/NormsConsumerPerField.java
index 05f90c2f..136c0ce6 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/NormsConsumerPerField.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/java/org/apache/lucene/index/NormsConsumerPerField.java
@@ -29,8 +29,8 @@
   private final Similarity similarity;
   private final FieldInvertState fieldState;
   private DocValuesConsumer consumer;
-  private final DocValuesField value = new DocValuesField("", Type.BYTES_FIXED_STRAIGHT);
   private final BytesRef spare = new BytesRef(1);
+  private final DocValuesField value = new DocValuesField("", spare, Type.BYTES_FIXED_STRAIGHT);
   private final NormsConsumer parent;
   
   public NormsConsumerPerField(final DocInverterPerField docInverterPerField, final FieldInfo fieldInfo, NormsConsumer parent) {
@@ -53,7 +53,6 @@ void finish() throws IOException {
     if (fieldInfo.isIndexed && !fieldInfo.omitNorms) {
       DocValuesConsumer consumer = getConsumer();
       spare.bytes[0] = similarity.computeNorm(fieldState);
-      value.setBytes(spare);
       consumer.add(docState.docID, value);
     }    
   }
diff --git a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/document/TestDocument.java b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/document/TestDocument.java
index 2deeaa31..d10d7014 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/document/TestDocument.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/document/TestDocument.java
@@ -1,5 +1,6 @@
 package org.apache.lucene.document;
 
+import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.RandomIndexWriter;
@@ -274,18 +275,15 @@ public void testFieldSetValue() throws Exception {
     assertEquals("did not see all IDs", 7, result);
   }
   
-  public void testFieldSetValueChangeBinary() {
-    Field field1 = new BinaryField("field1", new byte[0]);
-    Field field2 = new Field("field2", "", TextField.TYPE_STORED);
+  // LUCENE-3616
+  public void testInvalidFields() {
     try {
-      field1.setValue("abc");
-      fail("did not hit expected exception");
-    } catch (IllegalArgumentException iae) {
-      // expected
-    }
-    try {
-      field2.setValue(new byte[0]);
-      fail("did not hit expected exception");
+      new Field("foo", new Tokenizer() {
+        @Override
+        public boolean incrementToken() {
+          return false;
+        }}, StringField.TYPE_STORED);
+      fail("did not hit expected exc");
     } catch (IllegalArgumentException iae) {
       // expected
     }
diff --git a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestAddIndexes.java b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestAddIndexes.java
index f16fef06..9758b773 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestAddIndexes.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestAddIndexes.java
@@ -1256,9 +1256,7 @@ public void testDocValues() throws IOException {
     RandomIndexWriter w = new RandomIndexWriter(random, d1);
     Document doc = new Document();
     doc.add(newField("id", "1", StringField.TYPE_STORED));
-    DocValuesField dv = new DocValuesField("dv", DocValues.Type.VAR_INTS);
-    dv.setInt(1);
-    doc.add(dv);
+    doc.add(new DocValuesField("dv", 1, DocValues.Type.VAR_INTS));
     w.addDocument(doc);
     IndexReader r1 = w.getReader();
     w.close();
@@ -1267,9 +1265,7 @@ public void testDocValues() throws IOException {
     w = new RandomIndexWriter(random, d2);
     doc = new Document();
     doc.add(newField("id", "2", StringField.TYPE_STORED));
-    dv = new DocValuesField("dv", DocValues.Type.VAR_INTS);
-    dv.setInt(2);
-    doc.add(dv);
+    doc.add(new DocValuesField("dv", 2, DocValues.Type.VAR_INTS));
     w.addDocument(doc);
     IndexReader r2 = w.getReader();
     w.close();
diff --git a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
index c7ce26e2..6ee51656 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
@@ -540,8 +540,8 @@ private void addDoc(IndexWriter writer, int id) throws IOException
     doc.add(new Field("content2", "here is more content with aaa aaa aaa", customType2));
     doc.add(new Field("fie\u2C77ld", "field with non-ascii name", customType2));
     // add numeric fields, to test if flex preserves encoding
-    doc.add(new NumericField("trieInt", 4, NumericField.DataType.INT).setIntValue(id));
-    doc.add(new NumericField("trieLong", 4, NumericField.DataType.LONG).setLongValue(id));
+    doc.add(new NumericField("trieInt", id));
+    doc.add(new NumericField("trieLong", (long) id));
     writer.addDocument(doc);
   }
 
diff --git a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestDocValuesIndexing.java b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestDocValuesIndexing.java
index 620c32c0..5c2577b6 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestDocValuesIndexing.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestDocValuesIndexing.java
@@ -21,7 +21,6 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.List;
@@ -74,9 +73,7 @@ public void testDocValuesSimple() throws CorruptIndexException, IOException {
     IndexWriter writer = new IndexWriter(dir, writerConfig(false));
     for (int i = 0; i < 5; i++) {
       Document doc = new Document();
-      DocValuesField valuesField = new DocValuesField("docId", DocValues.Type.VAR_INTS);
-      valuesField.setInt(i);
-      doc.add(valuesField);
+      doc.add(new DocValuesField("docId", i, DocValues.Type.VAR_INTS));
       doc.add(new TextField("docId", "" + i));
       writer.addDocument(doc);
     }
@@ -565,17 +562,47 @@ private Source getSource(DocValues values) throws IOException {
       Type.FLOAT_32,
       Type.FLOAT_64);
 
-  private FixedBitSet indexValues(IndexWriter w, int numValues, Type value,
+  private FixedBitSet indexValues(IndexWriter w, int numValues, Type valueType,
       List<Type> valueVarList, boolean withDeletions, int bytesSize)
       throws CorruptIndexException, IOException {
-    final boolean isNumeric = NUMERICS.contains(value);
+    final boolean isNumeric = NUMERICS.contains(valueType);
     FixedBitSet deleted = new FixedBitSet(numValues);
     Document doc = new Document();
-    DocValuesField valField = new DocValuesField(value.name(), value);
+    final DocValuesField valField;
+    if (isNumeric) {
+      switch (valueType) {
+      case VAR_INTS:
+        valField = new DocValuesField(valueType.name(), (long) 0, valueType);
+        break;
+      case FIXED_INTS_16:
+        valField = new DocValuesField(valueType.name(), (short) 0, valueType);
+        break;
+      case FIXED_INTS_32:
+        valField = new DocValuesField(valueType.name(), 0, valueType);
+        break;
+      case FIXED_INTS_64:
+        valField = new DocValuesField(valueType.name(), (long) 0, valueType);
+        break;
+      case FIXED_INTS_8:
+        valField = new DocValuesField(valueType.name(), (byte) 0, valueType);
+        break;
+      case FLOAT_32:
+        valField = new DocValuesField(valueType.name(), (float) 0, valueType);
+        break;
+      case FLOAT_64:
+        valField = new DocValuesField(valueType.name(), (double) 0, valueType);
+        break;
+      default:
+        valField = null;
+        fail("unhandled case");
+      }
+    } else {
+      valField = new DocValuesField(valueType.name(), new BytesRef(), valueType);
+    }
     doc.add(valField);
     final BytesRef bytesRef = new BytesRef();
 
-    final String idBase = value.name() + "_";
+    final String idBase = valueType.name() + "_";
     final byte[] b = new byte[bytesSize];
     if (bytesRef != null) {
       bytesRef.bytes = b;
@@ -585,38 +612,37 @@ private FixedBitSet indexValues(IndexWriter w, int numValues, Type value,
     byte upto = 0;
     for (int i = 0; i < numValues; i++) {
       if (isNumeric) {
-        switch (value) {
+        switch (valueType) {
         case VAR_INTS:
-          valField.setInt((long)i);
+          valField.setValue((long)i);
           break;
         case FIXED_INTS_16:
-          valField.setInt((short)i);
+          valField.setValue((short)i);
           break;
         case FIXED_INTS_32:
-          valField.setInt(i);
+          valField.setValue(i);
           break;
         case FIXED_INTS_64:
-          valField.setInt((long)i);
+          valField.setValue((long)i);
           break;
         case FIXED_INTS_8:
-          valField.setInt((byte)(0xFF & (i % 128)));
+          valField.setValue((byte)(0xFF & (i % 128)));
           break;
         case FLOAT_32:
-          valField.setFloat(2.0f * i);
+          valField.setValue(2.0f * i);
           break;
         case FLOAT_64:
-          valField.setFloat(2.0d * i);
+          valField.setValue(2.0d * i);
           break;
-       
         default:
-          fail("unexpected value " + value);
+          fail("unexpected value " + valueType);
         }
       } else {
         for (int j = 0; j < b.length; j++) {
           b[j] = upto++;
         }
         if (bytesRef != null) {
-          valField.setBytes(bytesRef);
+          valField.setValue(bytesRef);
         }
       }
       doc.removeFields("id");
@@ -626,11 +652,11 @@ private FixedBitSet indexValues(IndexWriter w, int numValues, Type value,
       if (i % 7 == 0) {
         if (withDeletions && random.nextBoolean()) {
           Type val = valueVarList.get(random.nextInt(1 + valueVarList
-              .indexOf(value)));
-          final int randInt = val == value ? random.nextInt(1 + i) : random
+              .indexOf(valueType)));
+          final int randInt = val == valueType ? random.nextInt(1 + i) : random
               .nextInt(numValues);
           w.deleteDocuments(new Term("id", val.name() + "_" + randInt));
-          if (val == value) {
+          if (val == valueType) {
             deleted.set(randInt);
           }
         }
@@ -652,8 +678,7 @@ public void testMultiValuedDocValuesField() throws Exception {
     Directory d = newDirectory();
     RandomIndexWriter w = new RandomIndexWriter(random, d);
     Document doc = new Document();
-    DocValuesField f = new DocValuesField("field", Type.VAR_INTS);
-    f.setInt(17);
+    DocValuesField f = new DocValuesField("field", 17, Type.VAR_INTS);
     // Index doc values are single-valued so we should not
     // be able to add same field more than once:
     doc.add(f);
@@ -680,14 +705,11 @@ public void testDifferentTypedDocValuesField() throws Exception {
     Directory d = newDirectory();
     RandomIndexWriter w = new RandomIndexWriter(random, d);
     Document doc = new Document();
-    DocValuesField f = new DocValuesField("field", Type.VAR_INTS);
-    f.setInt(17);
     // Index doc values are single-valued so we should not
     // be able to add same field more than once:
-    doc.add(f);
-    DocValuesField f2 = new DocValuesField("field", Type.FLOAT_32);
-    f2.setFloat(22.0);
-    doc.add(f2);
+    Field f;
+    doc.add(f = new DocValuesField("field", 17, Type.VAR_INTS));
+    doc.add(new DocValuesField("field", 22.0, Type.FLOAT_32));
     try {
       w.addDocument(doc);
       fail("didn't hit expected exception");
@@ -714,8 +736,6 @@ public void testSortedBytes() throws IOException {
       IndexWriterConfig cfg = newIndexWriterConfig(TEST_VERSION_CURRENT,
           new MockAnalyzer(random));
       IndexWriter w = new IndexWriter(d, cfg);
-      // nocommit
-      Comparator<BytesRef> comp = BytesRef.getUTF8SortedAsUnicodeComparator();
       int numDocs = atLeast(100);
       BytesRefHash hash = new BytesRefHash();
       Map<String, String> docToString = new HashMap<String, String>();
@@ -723,14 +743,12 @@ public void testSortedBytes() throws IOException {
       for (int i = 0; i < numDocs; i++) {
         Document doc = new Document();
         doc.add(newField("id", "" + i, TextField.TYPE_STORED));
-        DocValuesField f = new DocValuesField("field", type);
         String string =fixed ? _TestUtil.randomFixedByteLengthUnicodeString(random,
             len) : _TestUtil.randomRealisticUnicodeString(random, 1, len);
-        hash.add(new BytesRef(string));
+        BytesRef br = new BytesRef(string);
+        doc.add(new DocValuesField("field", br, type));
+        hash.add(br);
         docToString.put("" + i, string);
-
-        f.setBytes(new BytesRef(string));
-        doc.add(f);
         w.addDocument(doc);
       }
       if (rarely()) {
@@ -753,13 +771,12 @@ public void testSortedBytes() throws IOException {
         Document doc = new Document();
         String id = "" + i + numDocs;
         doc.add(newField("id", id, TextField.TYPE_STORED));
-        DocValuesField f = new DocValuesField("field", type);
         String string = fixed ? _TestUtil.randomFixedByteLengthUnicodeString(random,
             len) : _TestUtil.randomRealisticUnicodeString(random, 1, len);
-        hash.add(new BytesRef(string));
+        BytesRef br = new BytesRef(string);
+        hash.add(br);
         docToString.put(id, string);
-        f.setBytes(new BytesRef(string));
-        doc.add(f);
+        doc.add( new DocValuesField("field", br, type));
         w.addDocument(doc);
       }
       w.commit();
@@ -767,7 +784,7 @@ public void testSortedBytes() throws IOException {
       DocValues docValues = MultiDocValues.getDocValues(reader, "field");
       Source source = getSource(docValues);
       SortedSource asSortedSource = source.asSortedSource();
-      int[] sort = hash.sort(comp);
+      int[] sort = hash.sort(BytesRef.getUTF8SortedAsUnicodeComparator());
       BytesRef expected = new BytesRef();
       BytesRef actual = new BytesRef();
       assertEquals(hash.size(), asSortedSource.getValueCount());
diff --git a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestFieldsReader.java b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestFieldsReader.java
index a21a38ae..23890599 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestFieldsReader.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestFieldsReader.java
@@ -244,37 +244,35 @@ public void testNumericField() throws Exception {
         // float/double
         if (random.nextBoolean()) {
           final float f = random.nextFloat();
-          nf = new NumericField("nf", NumericField.getFieldType(NumericField.DataType.FLOAT, true));
-          nf.setFloatValue(f);
           answer = Float.valueOf(f);
+          nf = new NumericField("nf", answer, NumericField.getFieldType(NumericField.DataType.FLOAT, true));
           typeAnswer = NumericField.DataType.FLOAT;
         } else {
           final double d = random.nextDouble();
-          nf = new NumericField("nf", NumericField.getFieldType(NumericField.DataType.DOUBLE, true));
-          nf.setDoubleValue(d);
           answer = Double.valueOf(d);
+          nf = new NumericField("nf", answer, NumericField.getFieldType(NumericField.DataType.DOUBLE, true));
           typeAnswer = NumericField.DataType.DOUBLE;
         }
       } else {
         // int/long
         if (random.nextBoolean()) {
           final int i = random.nextInt();
-          nf = new NumericField("nf", NumericField.getFieldType(NumericField.DataType.INT, true));
-          nf.setIntValue(i);
           answer = Integer.valueOf(i);
+          nf = new NumericField("nf", answer, NumericField.getFieldType(NumericField.DataType.INT, true));
           typeAnswer = NumericField.DataType.INT;
         } else {
           final long l = random.nextLong();
-          nf = new NumericField("nf", NumericField.getFieldType(NumericField.DataType.LONG, true));
-          nf.setLongValue(l);
           answer = Long.valueOf(l);
+          nf = new NumericField("nf", answer, NumericField.getFieldType(NumericField.DataType.LONG, true));
           typeAnswer = NumericField.DataType.LONG;
         }
       }
       doc.add(nf);
       answers[id] = answer;
       typeAnswers[id] = typeAnswer;
-      doc.add(new NumericField("id", Integer.MAX_VALUE, NumericField.DataType.INT).setIntValue(id));
+      FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.INT, false));
+      ft.setNumericPrecisionStep(Integer.MAX_VALUE);
+      doc.add(new NumericField("id", id, ft));
       w.addDocument(doc);
     }
     final IndexReader r = w.getReader();
diff --git a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestIndexWriter.java b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestIndexWriter.java
index 0f1b108d..f4e44a72 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestIndexWriter.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestIndexWriter.java
@@ -21,15 +21,10 @@
 import java.io.IOException;
 import java.io.Reader;
 import java.io.StringReader;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
-import java.util.Random;
 import java.util.Set;
 
 import org.apache.lucene.analysis.*;
@@ -51,7 +46,6 @@
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.AlreadyClosedException;
 import org.apache.lucene.store.Directory;
@@ -1185,9 +1179,9 @@ public void testIndexStoreCombos() throws Exception {
 
     FieldType customType = new FieldType(BinaryField.TYPE_STORED);
     customType.setTokenized(true);
-    customType.setIndexed(true);
     
     Field f = new Field("binary", b, 10, 17, customType);
+    customType.setIndexed(true);
     f.setTokenStream(new MockTokenizer(new StringReader("doc1field1"), MockTokenizer.WHITESPACE, false));
 
     FieldType customType2 = new FieldType(TextField.TYPE_STORED);
diff --git a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestIndexableField.java b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestIndexableField.java
index 4c7d93bb..324d37b4 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestIndexableField.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestIndexableField.java
@@ -37,6 +37,7 @@
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.NumericUtils;
 import org.apache.lucene.util._TestUtil;
 
 public class TestIndexableField extends LuceneTestCase {
@@ -94,6 +95,11 @@ public boolean omitNorms() {
       public NumericField.DataType numericType() {
         return counter%10 == 9 ? DataType.INT : null;
       }
+
+      @Override
+      public int numericPrecisionStep() {
+        return NumericUtils.PRECISION_STEP_DEFAULT;
+      }
     };
 
     public MyField(int counter) {
diff --git a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestTypePromotion.java b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestTypePromotion.java
index 93855348..07220cc7 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestTypePromotion.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/index/TestTypePromotion.java
@@ -168,7 +168,36 @@ private void assertValues(TestType type, Directory dir, long[] values)
   public void index(IndexWriter writer,
       Type valueType, long[] values, int offset, int num)
       throws CorruptIndexException, IOException {
-    DocValuesField valField =  new DocValuesField("promote", valueType);
+    final DocValuesField valField;
+    switch (valueType) {
+    case FIXED_INTS_8:
+    case FIXED_INTS_16:
+    case FIXED_INTS_32:
+      valField =  new DocValuesField("promote", 0, valueType);
+      break;
+    case VAR_INTS:
+    case FIXED_INTS_64:
+      valField =  new DocValuesField("promote", (long) 0, valueType);
+      break;
+    case FLOAT_64:
+      valField =  new DocValuesField("promote", (double) 0, valueType);
+      break;
+    case FLOAT_32:
+      valField =  new DocValuesField("promote", (float) 0, valueType);
+      break;
+    case BYTES_FIXED_DEREF:
+    case BYTES_FIXED_SORTED:
+    case BYTES_FIXED_STRAIGHT:
+    case BYTES_VAR_DEREF:
+    case BYTES_VAR_SORTED:
+    case BYTES_VAR_STRAIGHT:
+      valField =  new DocValuesField("promote", new BytesRef(), valueType);
+      break;
+    default:
+      fail("unexpected value " + valueType);
+      valField = null;
+    }
+
     BytesRef ref = new BytesRef(new byte[] { 1, 2, 3, 4 });
     for (int i = offset; i < offset + num; i++) {
       Document doc = new Document();
@@ -176,40 +205,40 @@ public void index(IndexWriter writer,
       switch (valueType) {
       case VAR_INTS:
         values[i] = random.nextInt();
-        valField.setInt(values[i]);
+        valField.setValue(values[i]);
         break;
       case FIXED_INTS_16:
         values[i] = random.nextInt(Short.MAX_VALUE);
-        valField.setInt((short) values[i]);
+        valField.setValue((short) values[i]);
         break;
       case FIXED_INTS_32:
         values[i] = random.nextInt();
-        valField.setInt((int) values[i]);
+        valField.setValue((int) values[i]);
         break;
       case FIXED_INTS_64:
         values[i] = random.nextLong();
-        valField.setInt(values[i]);
+        valField.setValue(values[i]);
         break;
       case FLOAT_64:
         double nextDouble = random.nextDouble();
         values[i] = Double.doubleToRawLongBits(nextDouble);
-        valField.setFloat(nextDouble);
+        valField.setValue(nextDouble);
         break;
       case FLOAT_32:
         final float nextFloat = random.nextFloat();
         values[i] = Double.doubleToRawLongBits(nextFloat);
-        valField.setFloat(nextFloat);
+        valField.setValue(nextFloat);
         break;
       case FIXED_INTS_8:
          values[i] = (byte) i;
-        valField.setInt((byte)values[i]);
+        valField.setValue((byte)values[i]);
         break;
       case BYTES_FIXED_DEREF:
       case BYTES_FIXED_SORTED:
       case BYTES_FIXED_STRAIGHT:
         values[i] = random.nextLong();
         BytesRefUtils.copyLong(ref, values[i]);
-        valField.setBytes(ref);
+        valField.setValue(ref);
         break;
       case BYTES_VAR_DEREF:
       case BYTES_VAR_SORTED:
@@ -221,7 +250,7 @@ public void index(IndexWriter writer,
           BytesRefUtils.copyLong(ref, random.nextLong());
           values[i] = BytesRefUtils.asLong(ref);
         }
-        valField.setBytes(ref);
+        valField.setValue(ref);
         break;
 
       default:
diff --git a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestDocValuesScoring.java b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestDocValuesScoring.java
index 0dc364b1..2e207cdb 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestDocValuesScoring.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestDocValuesScoring.java
@@ -55,18 +55,18 @@ public void testSimple() throws Exception {
     Document doc = new Document();
     Field field = newField("foo", "", TextField.TYPE_UNSTORED);
     doc.add(field);
-    DocValuesField dvField = new DocValuesField("foo_boost", DocValues.Type.FLOAT_32);
+    DocValuesField dvField = new DocValuesField("foo_boost", 0.0f, DocValues.Type.FLOAT_32);
     doc.add(dvField);
     Field field2 = newField("bar", "", TextField.TYPE_UNSTORED);
     doc.add(field2);
     
     field.setValue("quick brown fox");
     field2.setValue("quick brown fox");
-    dvField.setFloat(2f); // boost x2
+    dvField.setValue(2f); // boost x2
     iw.addDocument(doc);
     field.setValue("jumps over lazy brown dog");
     field2.setValue("jumps over lazy brown dog");
-    dvField.setFloat(4f); // boost x4
+    dvField.setValue(4f); // boost x4
     iw.addDocument(doc);
     IndexReader ir = iw.getReader();
     iw.close();
diff --git a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
index ff8772a6..49c31486 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
@@ -19,9 +19,10 @@
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
+import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.NumericField;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.SlowMultiReaderWrapper;
@@ -59,15 +60,39 @@ public static void beforeClass() throws Exception {
         .setMaxBufferedDocs(_TestUtil.nextInt(random, 100, 1000))
         .setMergePolicy(newLogMergePolicy()));
   
+    final FieldType storedInt = NumericField.getFieldType(NumericField.DataType.INT, true);
+
+    final FieldType storedInt8 = new FieldType(storedInt);
+    storedInt8.setNumericPrecisionStep(8);
+
+    final FieldType storedInt4 = new FieldType(storedInt);
+    storedInt4.setNumericPrecisionStep(4);
+
+    final FieldType storedInt2 = new FieldType(storedInt);
+    storedInt2.setNumericPrecisionStep(2);
+
+    final FieldType storedIntNone = new FieldType(storedInt);
+    storedIntNone.setNumericPrecisionStep(Integer.MAX_VALUE);
+
+    final FieldType unstoredInt = NumericField.getFieldType(NumericField.DataType.INT, false);
+
+    final FieldType unstoredInt8 = new FieldType(unstoredInt);
+    unstoredInt8.setNumericPrecisionStep(8);
+
+    final FieldType unstoredInt4 = new FieldType(unstoredInt);
+    unstoredInt4.setNumericPrecisionStep(4);
+
+    final FieldType unstoredInt2 = new FieldType(unstoredInt);
+    unstoredInt2.setNumericPrecisionStep(2);
+
     NumericField
-	    field8 = new NumericField("field8", 8, NumericField.getFieldType(NumericField.DataType.INT, true)),
-	    field4 = new NumericField("field4", 4, NumericField.getFieldType(NumericField.DataType.INT, true)),
-	    field2 = new NumericField("field2", 2, NumericField.getFieldType(NumericField.DataType.INT, true)),
-	    fieldNoTrie = new NumericField("field"+Integer.MAX_VALUE, Integer.MAX_VALUE,
-                                           NumericField.getFieldType(NumericField.DataType.INT, rarely())),
-	    ascfield8 = new NumericField("ascfield8", 8, NumericField.DataType.INT),
-	    ascfield4 = new NumericField("ascfield4", 4, NumericField.DataType.INT),
-	    ascfield2 = new NumericField("ascfield2", 2, NumericField.DataType.INT);
+      field8 = new NumericField("field8", 0, storedInt8),
+      field4 = new NumericField("field4", 0, storedInt4),
+      field2 = new NumericField("field2", 0, storedInt2),
+      fieldNoTrie = new NumericField("field"+Integer.MAX_VALUE, 0, storedIntNone),
+      ascfield8 = new NumericField("ascfield8", 0, unstoredInt8),
+      ascfield4 = new NumericField("ascfield4", 0, unstoredInt4),
+      ascfield2 = new NumericField("ascfield2", 0, unstoredInt2);
     
     Document doc = new Document();
     // add fields, that have a distance to test general functionality
@@ -78,15 +103,15 @@ public static void beforeClass() throws Exception {
     // Add a series of noDocs docs with increasing int values
     for (int l=0; l<noDocs; l++) {
       int val=distance*l+startOffset;
-      field8.setIntValue(val);
-      field4.setIntValue(val);
-      field2.setIntValue(val);
-      fieldNoTrie.setIntValue(val);
+      field8.setValue(val);
+      field4.setValue(val);
+      field2.setValue(val);
+      fieldNoTrie.setValue(val);
 
       val=l-(noDocs/2);
-      ascfield8.setIntValue(val);
-      ascfield4.setIntValue(val);
-      ascfield2.setIntValue(val);
+      ascfield8.setValue(val);
+      ascfield4.setValue(val);
+      ascfield2.setValue(val);
       writer.addDocument(doc);
     }
   
@@ -144,9 +169,9 @@ private void testRange(int precisionStep) throws Exception {
       assertNotNull(sd);
       assertEquals("Score doc count"+type, count, sd.length );
       Document doc=searcher.doc(sd[0].doc);
-      assertEquals("First doc"+type, 2*distance+startOffset, Integer.parseInt(doc.get(field)) );
+      assertEquals("First doc"+type, 2*distance+startOffset, doc.getField(field).numericValue().intValue());
       doc=searcher.doc(sd[sd.length-1].doc);
-      assertEquals("Last doc"+type, (1+count)*distance+startOffset, Integer.parseInt(doc.get(field)) );
+      assertEquals("Last doc"+type, (1+count)*distance+startOffset, doc.getField(field).numericValue().intValue());
     }
   }
 
@@ -198,9 +223,9 @@ private void testLeftOpenRange(int precisionStep) throws Exception {
     assertNotNull(sd);
     assertEquals("Score doc count", count, sd.length );
     Document doc=searcher.doc(sd[0].doc);
-    assertEquals("First doc", startOffset, Integer.parseInt(doc.get(field)) );
+    assertEquals("First doc", startOffset, doc.getField(field).numericValue().intValue());
     doc=searcher.doc(sd[sd.length-1].doc);
-    assertEquals("Last doc", (count-1)*distance+startOffset, Integer.parseInt(doc.get(field)) );
+    assertEquals("Last doc", (count-1)*distance+startOffset, doc.getField(field).numericValue().intValue());
     
     q=NumericRangeQuery.newIntRange(field, precisionStep, null, upper, false, true);
     topDocs = searcher.search(q, null, noDocs, Sort.INDEXORDER);
@@ -208,9 +233,9 @@ private void testLeftOpenRange(int precisionStep) throws Exception {
     assertNotNull(sd);
     assertEquals("Score doc count", count, sd.length );
     doc=searcher.doc(sd[0].doc);
-    assertEquals("First doc", startOffset, Integer.parseInt(doc.get(field)) );
+    assertEquals("First doc", startOffset, doc.getField(field).numericValue().intValue());
     doc=searcher.doc(sd[sd.length-1].doc);
-    assertEquals("Last doc", (count-1)*distance+startOffset, Integer.parseInt(doc.get(field)) );
+    assertEquals("Last doc", (count-1)*distance+startOffset, doc.getField(field).numericValue().intValue());
   }
   
   @Test
@@ -238,9 +263,9 @@ private void testRightOpenRange(int precisionStep) throws Exception {
     assertNotNull(sd);
     assertEquals("Score doc count", noDocs-count, sd.length );
     Document doc=searcher.doc(sd[0].doc);
-    assertEquals("First doc", count*distance+startOffset, Integer.parseInt(doc.get(field)) );
+    assertEquals("First doc", count*distance+startOffset, doc.getField(field).numericValue().intValue());
     doc=searcher.doc(sd[sd.length-1].doc);
-    assertEquals("Last doc", (noDocs-1)*distance+startOffset, Integer.parseInt(doc.get(field)) );
+    assertEquals("Last doc", (noDocs-1)*distance+startOffset, doc.getField(field).numericValue().intValue());
 
     q=NumericRangeQuery.newIntRange(field, precisionStep, lower, null, true, false);
     topDocs = searcher.search(q, null, noDocs, Sort.INDEXORDER);
@@ -248,9 +273,9 @@ private void testRightOpenRange(int precisionStep) throws Exception {
     assertNotNull(sd);
     assertEquals("Score doc count", noDocs-count, sd.length );
     doc=searcher.doc(sd[0].doc);
-    assertEquals("First doc", count*distance+startOffset, Integer.parseInt(doc.get(field)) );
+    assertEquals("First doc", count*distance+startOffset, doc.getField(field).numericValue().intValue() );
     doc=searcher.doc(sd[sd.length-1].doc);
-    assertEquals("Last doc", (noDocs-1)*distance+startOffset, Integer.parseInt(doc.get(field)) );
+    assertEquals("Last doc", (noDocs-1)*distance+startOffset, doc.getField(field).numericValue().intValue() );
   }
   
   @Test
@@ -553,9 +578,9 @@ private void testSorting(int precisionStep) throws Exception {
       if (topDocs.totalHits==0) continue;
       ScoreDoc[] sd = topDocs.scoreDocs;
       assertNotNull(sd);
-      int last=Integer.parseInt(searcher.doc(sd[0].doc).get(field));
+      int last = searcher.doc(sd[0].doc).getField(field).numericValue().intValue();
       for (int j=1; j<sd.length; j++) {
-        int act=Integer.parseInt(searcher.doc(sd[j].doc).get(field));
+        int act = searcher.doc(sd[j].doc).getField(field).numericValue().intValue();
         assertTrue("Docs should be sorted backwards", last>act );
         last=act;
       }
diff --git a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
index 17451559..dc25404a 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
@@ -19,14 +19,15 @@
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
+import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.NumericField;
+import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.SlowMultiReaderWrapper;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
@@ -59,18 +60,47 @@ public static void beforeClass() throws Exception {
         .setMaxBufferedDocs(_TestUtil.nextInt(random, 100, 1000))
         .setMergePolicy(newLogMergePolicy()));
     
-    NumericField
-      field8 = new NumericField("field8", 8, NumericField.getFieldType(NumericField.DataType.LONG, true)),
-      field6 = new NumericField("field6", 6, NumericField.getFieldType(NumericField.DataType.LONG, true)),
-      field4 = new NumericField("field4", 4, NumericField.getFieldType(NumericField.DataType.LONG, true)),
-      field2 = new NumericField("field2", 2, NumericField.getFieldType(NumericField.DataType.LONG, true)),
-      fieldNoTrie = new NumericField("field"+Integer.MAX_VALUE, Integer.MAX_VALUE,
-                                     NumericField.getFieldType(NumericField.DataType.LONG, rarely())),
+    final FieldType storedLong = NumericField.getFieldType(NumericField.DataType.LONG, true);
+
+    final FieldType storedLong8 = new FieldType(storedLong);
+    storedLong8.setNumericPrecisionStep(8);
+
+    final FieldType storedLong4 = new FieldType(storedLong);
+    storedLong4.setNumericPrecisionStep(4);
+
+    final FieldType storedLong6 = new FieldType(storedLong);
+    storedLong6.setNumericPrecisionStep(6);
+
+    final FieldType storedLong2 = new FieldType(storedLong);
+    storedLong2.setNumericPrecisionStep(2);
 
-      ascfield8 = new NumericField("ascfield8", 8, NumericField.DataType.LONG),
-      ascfield6 = new NumericField("ascfield6", 6, NumericField.DataType.LONG),
-      ascfield4 = new NumericField("ascfield4", 4, NumericField.DataType.LONG),
-      ascfield2 = new NumericField("ascfield2", 2, NumericField.DataType.LONG);
+    final FieldType storedLongNone = new FieldType(storedLong);
+    storedLongNone.setNumericPrecisionStep(Integer.MAX_VALUE);
+
+    final FieldType unstoredLong = NumericField.getFieldType(NumericField.DataType.LONG, false);
+
+    final FieldType unstoredLong8 = new FieldType(unstoredLong);
+    unstoredLong8.setNumericPrecisionStep(8);
+
+    final FieldType unstoredLong6 = new FieldType(unstoredLong);
+    unstoredLong6.setNumericPrecisionStep(6);
+
+    final FieldType unstoredLong4 = new FieldType(unstoredLong);
+    unstoredLong4.setNumericPrecisionStep(4);
+
+    final FieldType unstoredLong2 = new FieldType(unstoredLong);
+    unstoredLong2.setNumericPrecisionStep(2);
+
+    NumericField
+      field8 = new NumericField("field8", 0L, storedLong8),
+      field6 = new NumericField("field6", 0L, storedLong6),
+      field4 = new NumericField("field4", 0L, storedLong4),
+      field2 = new NumericField("field2", 0L, storedLong2),
+      fieldNoTrie = new NumericField("field"+Integer.MAX_VALUE, 0L, storedLongNone),
+      ascfield8 = new NumericField("ascfield8", 0L, unstoredLong8),
+      ascfield6 = new NumericField("ascfield6", 0L, unstoredLong6),
+      ascfield4 = new NumericField("ascfield4", 0L, unstoredLong4),
+      ascfield2 = new NumericField("ascfield2", 0L, unstoredLong2);
     
     Document doc = new Document();
     // add fields, that have a distance to test general functionality
@@ -81,17 +111,17 @@ public static void beforeClass() throws Exception {
     // Add a series of noDocs docs with increasing long values, by updating the fields
     for (int l=0; l<noDocs; l++) {
       long val=distance*l+startOffset;
-      field8.setLongValue(val);
-      field6.setLongValue(val);
-      field4.setLongValue(val);
-      field2.setLongValue(val);
-      fieldNoTrie.setLongValue(val);
+      field8.setValue(val);
+      field6.setValue(val);
+      field4.setValue(val);
+      field2.setValue(val);
+      fieldNoTrie.setValue(val);
 
       val=l-(noDocs/2);
-      ascfield8.setLongValue(val);
-      ascfield6.setLongValue(val);
-      ascfield4.setLongValue(val);
-      ascfield2.setLongValue(val);
+      ascfield8.setValue(val);
+      ascfield6.setValue(val);
+      ascfield4.setValue(val);
+      ascfield2.setValue(val);
       writer.addDocument(doc);
     }
     reader = writer.getReader();
@@ -148,9 +178,9 @@ private void testRange(int precisionStep) throws Exception {
       assertNotNull(sd);
       assertEquals("Score doc count"+type, count, sd.length );
       Document doc=searcher.doc(sd[0].doc);
-      assertEquals("First doc"+type, 2*distance+startOffset, Long.parseLong(doc.get(field)) );
+      assertEquals("First doc"+type, 2*distance+startOffset, doc.getField(field).numericValue().longValue() );
       doc=searcher.doc(sd[sd.length-1].doc);
-      assertEquals("Last doc"+type, (1+count)*distance+startOffset, Long.parseLong(doc.get(field)) );
+      assertEquals("Last doc"+type, (1+count)*distance+startOffset, doc.getField(field).numericValue().longValue() );
     }
   }
 
@@ -208,9 +238,9 @@ private void testLeftOpenRange(int precisionStep) throws Exception {
     assertNotNull(sd);
     assertEquals("Score doc count", count, sd.length );
     Document doc=searcher.doc(sd[0].doc);
-    assertEquals("First doc", startOffset, Long.parseLong(doc.get(field)) );
+    assertEquals("First doc", startOffset, doc.getField(field).numericValue().longValue() );
     doc=searcher.doc(sd[sd.length-1].doc);
-    assertEquals("Last doc", (count-1)*distance+startOffset, Long.parseLong(doc.get(field)) );
+    assertEquals("Last doc", (count-1)*distance+startOffset, doc.getField(field).numericValue().longValue() );
 
     q=NumericRangeQuery.newLongRange(field, precisionStep, null, upper, false, true);
     topDocs = searcher.search(q, null, noDocs, Sort.INDEXORDER);
@@ -218,9 +248,9 @@ private void testLeftOpenRange(int precisionStep) throws Exception {
     assertNotNull(sd);
     assertEquals("Score doc count", count, sd.length );
     doc=searcher.doc(sd[0].doc);
-    assertEquals("First doc", startOffset, Long.parseLong(doc.get(field)) );
+    assertEquals("First doc", startOffset, doc.getField(field).numericValue().longValue() );
     doc=searcher.doc(sd[sd.length-1].doc);
-    assertEquals("Last doc", (count-1)*distance+startOffset, Long.parseLong(doc.get(field)) );
+    assertEquals("Last doc", (count-1)*distance+startOffset, doc.getField(field).numericValue().longValue() );
   }
   
   @Test
@@ -253,9 +283,9 @@ private void testRightOpenRange(int precisionStep) throws Exception {
     assertNotNull(sd);
     assertEquals("Score doc count", noDocs-count, sd.length );
     Document doc=searcher.doc(sd[0].doc);
-    assertEquals("First doc", count*distance+startOffset, Long.parseLong(doc.get(field)) );
+    assertEquals("First doc", count*distance+startOffset, doc.getField(field).numericValue().longValue() );
     doc=searcher.doc(sd[sd.length-1].doc);
-    assertEquals("Last doc", (noDocs-1)*distance+startOffset, Long.parseLong(doc.get(field)) );
+    assertEquals("Last doc", (noDocs-1)*distance+startOffset, doc.getField(field).numericValue().longValue() );
 
     q=NumericRangeQuery.newLongRange(field, precisionStep, lower, null, true, false);
     topDocs = searcher.search(q, null, noDocs, Sort.INDEXORDER);
@@ -263,9 +293,9 @@ private void testRightOpenRange(int precisionStep) throws Exception {
     assertNotNull(sd);
     assertEquals("Score doc count", noDocs-count, sd.length );
     doc=searcher.doc(sd[0].doc);
-    assertEquals("First doc", count*distance+startOffset, Long.parseLong(doc.get(field)) );
+    assertEquals("First doc", count*distance+startOffset, doc.getField(field).numericValue().longValue() );
     doc=searcher.doc(sd[sd.length-1].doc);
-    assertEquals("Last doc", (noDocs-1)*distance+startOffset, Long.parseLong(doc.get(field)) );
+    assertEquals("Last doc", (noDocs-1)*distance+startOffset, doc.getField(field).numericValue().longValue() );
   }
   
   @Test
@@ -588,9 +618,9 @@ private void testSorting(int precisionStep) throws Exception {
       if (topDocs.totalHits==0) continue;
       ScoreDoc[] sd = topDocs.scoreDocs;
       assertNotNull(sd);
-      long last=Long.parseLong(searcher.doc(sd[0].doc).get(field));
+      long last=searcher.doc(sd[0].doc).getField(field).numericValue().longValue();
       for (int j=1; j<sd.length; j++) {
-        long act=Long.parseLong(searcher.doc(sd[j].doc).get(field));
+        long act=searcher.doc(sd[j].doc).getField(field).numericValue().longValue();
         assertTrue("Docs should be sorted backwards", last>act );
         last=act;
       }
diff --git a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestSort.java b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestSort.java
index c04ab397..ea674c20 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestSort.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/test/org/apache/lucene/search/TestSort.java
@@ -146,25 +146,19 @@ private IndexSearcher getIndex (boolean even, boolean odd)
         if (data[i][2] != null) {
           doc.add(new StringField ("int", data[i][2]));
           if (supportsDocValues) {
-            DocValuesField dvf = new DocValuesField("int", DocValues.Type.VAR_INTS);
-            dvf.setInt(Integer.parseInt(data[i][2]));
-            doc.add(dvf);
+            doc.add(new DocValuesField("int", Integer.parseInt(data[i][2]), DocValues.Type.VAR_INTS));
           }
         }
         if (data[i][3] != null) {
           doc.add(new StringField ("float", data[i][3]));
           if (supportsDocValues) {
-            DocValuesField dvf = new DocValuesField("float", DocValues.Type.FLOAT_32);
-            dvf.setFloat(Float.parseFloat(data[i][3]));
-            doc.add(dvf);
+            doc.add(new DocValuesField("float", Float.parseFloat(data[i][3]), DocValues.Type.FLOAT_32));
           }
         }
         if (data[i][4] != null) {
           doc.add(new StringField ("string", data[i][4]));
           if (supportsDocValues) {
-            DocValuesField dvf = new DocValuesField("string", stringDVType);
-            dvf.setBytes(new BytesRef(data[i][4]));
-            doc.add(dvf);
+            doc.add(new DocValuesField("string", new BytesRef(data[i][4]), stringDVType));
           }
         }
         if (data[i][5] != null) doc.add (new StringField ("custom",   data[i][5]));
@@ -173,9 +167,7 @@ private IndexSearcher getIndex (boolean even, boolean odd)
         if (data[i][8] != null) {
           doc.add(new StringField ("double", data[i][8]));
           if (supportsDocValues) {
-            DocValuesField dvf = new DocValuesField("double", DocValues.Type.FLOAT_64);
-            dvf.setFloat(Double.parseDouble(data[i][8]));
-            doc.add(dvf);
+            doc.add(new DocValuesField("double", Double.parseDouble(data[i][8]), DocValues.Type.FLOAT_64));
           }
         }
         if (data[i][9] != null) doc.add (new StringField ("short",     data[i][9]));
@@ -220,16 +212,12 @@ private IndexSearcher getFullStrings() throws CorruptIndexException, LockObtainF
       //doc.add (new Field ("contents", Integer.toString(i), Field.Store.NO, Field.Index.ANALYZED));
       doc.add(new StringField("string", num));
       if (supportsDocValues) {
-        DocValuesField dvf = new DocValuesField("string", DocValues.Type.BYTES_VAR_SORTED);
-        dvf.setBytes(new BytesRef(num));
-        doc.add(dvf);
+        doc.add(new DocValuesField("string", new BytesRef(num), DocValues.Type.BYTES_VAR_SORTED));
       }
       String num2 = getRandomCharString(getRandomNumber(1, 4), 48, 50);
       doc.add(new StringField ("string2", num2));
       if (supportsDocValues) {
-        DocValuesField dvf = new DocValuesField("string2", DocValues.Type.BYTES_VAR_SORTED);
-        dvf.setBytes(new BytesRef(num2));
-        doc.add(dvf);
+        doc.add(new DocValuesField("string2", new BytesRef(num2), DocValues.Type.BYTES_VAR_SORTED));
       }
       doc.add (new Field ("tracer2", num2, onlyStored));
       for(IndexableField f2 : doc.getFields()) {
@@ -241,16 +229,12 @@ private IndexSearcher getFullStrings() throws CorruptIndexException, LockObtainF
       //doc.add (new Field ("contents", Integer.toString(i), Field.Store.NO, Field.Index.ANALYZED));
       doc.add(new StringField("string_fixed", numFixed));
       if (supportsDocValues) {
-        DocValuesField dvf = new DocValuesField("string_fixed", DocValues.Type.BYTES_FIXED_SORTED);
-        dvf.setBytes(new BytesRef(numFixed));
-        doc.add(dvf);
+        doc.add(new DocValuesField("string_fixed", new BytesRef(numFixed), DocValues.Type.BYTES_FIXED_SORTED));
       }
       String num2Fixed = getRandomCharString(fixedLen2, 48, 52);
       doc.add(new StringField ("string2_fixed", num2Fixed));
       if (supportsDocValues) {
-        DocValuesField dvf = new DocValuesField("string2_fixed", DocValues.Type.BYTES_FIXED_SORTED);
-        dvf.setBytes(new BytesRef(num2Fixed));
-        doc.add(dvf);
+        doc.add(new DocValuesField("string2_fixed", new BytesRef(num2Fixed), DocValues.Type.BYTES_FIXED_SORTED));
       }
       doc.add (new Field ("tracer2_fixed", num2Fixed, onlyStored));
 
diff --git a/lucene/dev/branches/lucene3453/lucene/src/test-framework/java/org/apache/lucene/index/RandomIndexWriter.java b/lucene/dev/branches/lucene3453/lucene/src/test-framework/java/org/apache/lucene/index/RandomIndexWriter.java
index 3f7d9189..dc24c5ff 100644
--- a/lucene/dev/branches/lucene3453/lucene/src/test-framework/java/org/apache/lucene/index/RandomIndexWriter.java
+++ b/lucene/dev/branches/lucene3453/lucene/src/test-framework/java/org/apache/lucene/index/RandomIndexWriter.java
@@ -27,6 +27,7 @@
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.document.DocValuesField;
 import org.apache.lucene.document.Document;
+import org.apache.lucene.document.FieldType;
 import org.apache.lucene.index.IndexWriter; // javadoc
 import org.apache.lucene.search.Query;
 import org.apache.lucene.store.Directory;
@@ -171,7 +172,7 @@ private void randomPerDocFieldValues(Random random, Document doc) {
     String name = "random_" + type.name() + "" + docValuesFieldPrefix;
     if ("Lucene3x".equals(codec.getName()) || doc.getField(name) != null)
         return;
-    DocValuesField docValuesField = new DocValuesField(name, type);
+    final Object value;
     switch (type) {
     case BYTES_FIXED_DEREF:
     case BYTES_FIXED_STRAIGHT:
@@ -185,40 +186,41 @@ private void randomPerDocFieldValues(Random random, Document doc) {
         fixedRef.grow(fixedBytesLength);
         fixedRef.length = fixedBytesLength;
       }
-      docValuesField.setBytes(fixedRef);
+      value = fixedRef;
       break;
     case BYTES_VAR_DEREF:
     case BYTES_VAR_STRAIGHT:
     case BYTES_VAR_SORTED:
-      BytesRef ref = new BytesRef(_TestUtil.randomUnicodeString(random, 200));
-      docValuesField.setBytes(ref);
+      value = new BytesRef(_TestUtil.randomUnicodeString(random, 200));
       break;
     case FLOAT_32:
-      docValuesField.setFloat(random.nextFloat());
+      value = random.nextFloat();
       break;
     case FLOAT_64:
-      docValuesField.setFloat(random.nextDouble());
+      value = random.nextDouble();
       break;
     case VAR_INTS:
-      docValuesField.setInt(random.nextLong());
+      value = random.nextLong();
       break;
     case FIXED_INTS_16:
-      docValuesField.setInt(random.nextInt(Short.MAX_VALUE));
+      value = random.nextInt(Short.MAX_VALUE);
       break;
     case FIXED_INTS_32:
-      docValuesField.setInt(random.nextInt());
+      value =random.nextInt();
       break;
     case FIXED_INTS_64:
-      docValuesField.setInt(random.nextLong());
+      value = random.nextLong();
       break;
     case FIXED_INTS_8:
-      docValuesField.setInt(random.nextInt(128));
+      value = random.nextInt(128);
       break;
     default:
       throw new IllegalArgumentException("no such type: " + type);
     }
-
-    doc.add(docValuesField);
+    FieldType ft = new FieldType();
+    ft.setDocValueType(type);
+    ft.freeze();
+    doc.add(new DocValuesField(name, value, ft));
   }
 
   private void maybeCommit() throws IOException {
diff --git a/lucene/dev/branches/lucene3453/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DocMaker.java b/lucene/dev/branches/lucene3453/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DocMaker.java
index baa8903b..96f98b47 100644
--- a/lucene/dev/branches/lucene3453/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DocMaker.java
+++ b/lucene/dev/branches/lucene3453/modules/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DocMaker.java
@@ -109,8 +109,8 @@ public DocState(boolean reuseFields, FieldType ft, FieldType bodyFt) {
         fields.put(ID_FIELD, new Field(ID_FIELD, "", StringField.TYPE_STORED));
         fields.put(NAME_FIELD, new Field(NAME_FIELD, "", ft));
 
-        numericFields.put(DATE_MSEC_FIELD, new NumericField(DATE_MSEC_FIELD, NumericField.DataType.LONG));
-        numericFields.put(TIME_SEC_FIELD, new NumericField(TIME_SEC_FIELD, NumericField.DataType.INT));
+        numericFields.put(DATE_MSEC_FIELD, new NumericField(DATE_MSEC_FIELD, 0L));
+        numericFields.put(TIME_SEC_FIELD, new NumericField(TIME_SEC_FIELD, 0));
         
         doc = new Document();
       } else {
@@ -139,15 +139,34 @@ Field getField(String name, FieldType ft) {
     }
 
     NumericField getNumericField(String name, NumericField.DataType type) {
-      if (!reuseFields) {
-        return new NumericField(name, type);
+      NumericField f;
+      if (reuseFields) {
+        f = numericFields.get(name);
+      } else {
+        f = null;
       }
 
-      NumericField f = numericFields.get(name);
       if (f == null) {
-        f = new NumericField(name, type);
+        switch(type) {
+        case INT:
+          f = new NumericField(name, 0);
+          break;
+        case LONG:
+          f = new NumericField(name, 0L);
+          break;
+        case FLOAT:
+          f = new NumericField(name, 0.0f);
+          break;
+        case DOUBLE:
+          f = new NumericField(name, 0.0);
+          break;
+        default:
+          assert false;
+        }
+        if (reuseFields) {
         numericFields.put(name, f);
       }
+      }
       return f;
     }
   }
@@ -250,14 +269,14 @@ private Document createDocument(DocData docData, int size, int cnt) throws Unsup
     }
 
     NumericField dateField = ds.getNumericField(DATE_MSEC_FIELD, NumericField.DataType.LONG);
-    dateField.setLongValue(date.getTime());
+    dateField.setValue(date.getTime());
     doc.add(dateField);
 
     util.cal.setTime(date);
     final int sec = util.cal.get(Calendar.HOUR_OF_DAY)*3600 + util.cal.get(Calendar.MINUTE)*60 + util.cal.get(Calendar.SECOND);
 
     NumericField timeSecField = ds.getNumericField(TIME_SEC_FIELD, NumericField.DataType.INT);
-    timeSecField.setIntValue(sec);
+    timeSecField.setValue(sec);
     doc.add(timeSecField);
     
     // Set TITLE_FIELD
diff --git a/lucene/dev/branches/lucene3453/modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java b/lucene/dev/branches/lucene3453/modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java
index ae314160..2558eff7 100644
--- a/lucene/dev/branches/lucene3453/modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java
+++ b/lucene/dev/branches/lucene3453/modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java
@@ -211,7 +211,7 @@ public void testRandom() throws Exception {
       doc.add(group);
       DocValuesField valuesField = null;
       if (canUseIDV) {
-        valuesField = new DocValuesField("group", valueType);
+        valuesField = new DocValuesField("group", new BytesRef(), valueType);
         doc.add(valuesField);
       }
       Field sort1 = newField("sort1", "", StringField.TYPE_UNSTORED);
@@ -226,7 +226,7 @@ public void testRandom() throws Exception {
       Field content = newField("content", "", TextField.TYPE_UNSTORED);
       doc.add(content);
       docNoGroup.add(content);
-      NumericField id = new NumericField("id", NumericField.DataType.INT);
+      NumericField id = new NumericField("id", 0);
       doc.add(id);
       docNoGroup.add(id);
       final GroupDoc[] groupDocs = new GroupDoc[numDocs];
@@ -257,14 +257,14 @@ public void testRandom() throws Exception {
         if (groupDoc.group != null) {
           group.setValue(groupDoc.group.utf8ToString());
           if (canUseIDV) {
-            valuesField.setBytes(new BytesRef(groupDoc.group.utf8ToString()));
+            valuesField.setValue(new BytesRef(groupDoc.group.utf8ToString()));
           }
         }
         sort1.setValue(groupDoc.sort1.utf8ToString());
         sort2.setValue(groupDoc.sort2.utf8ToString());
         sort3.setValue(groupDoc.sort3.utf8ToString());
         content.setValue(groupDoc.content);
-        id.setIntValue(groupDoc.id);
+        id.setValue(groupDoc.id);
         if (groupDoc.group == null) {
           w.addDocument(docNoGroup);
         } else {
@@ -527,9 +527,7 @@ private AbstractAllGroupHeadsCollector createRandomCollector(String groupField,
   private void addGroupField(Document doc, String groupField, String value, boolean canUseIDV, Type valueType) {
     doc.add(new Field(groupField, value, TextField.TYPE_STORED));
     if (canUseIDV) {
-      DocValuesField valuesField = new DocValuesField(groupField, valueType);
-      valuesField.setBytes(new BytesRef(value));
-      doc.add(valuesField);
+      doc.add(new DocValuesField(groupField, new BytesRef(value), valueType));
     }
   }
 
diff --git a/lucene/dev/branches/lucene3453/modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupsCollectorTest.java b/lucene/dev/branches/lucene3453/modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupsCollectorTest.java
index d9f9aacb..719fd662 100644
--- a/lucene/dev/branches/lucene3453/modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupsCollectorTest.java
+++ b/lucene/dev/branches/lucene3453/modules/grouping/src/test/org/apache/lucene/search/grouping/AllGroupsCollectorTest.java
@@ -123,9 +123,7 @@ public void testTotalGroupCount() throws Exception {
   private void addGroupField(Document doc, String groupField, String value, boolean canUseIDV) {
     doc.add(new Field(groupField, value, TextField.TYPE_STORED));
     if (canUseIDV) {
-      DocValuesField valuesField = new DocValuesField(groupField, Type.BYTES_VAR_SORTED);
-      valuesField.setBytes(new BytesRef(value));
-      doc.add(valuesField);
+      doc.add(new DocValuesField(groupField, new BytesRef(value), Type.BYTES_VAR_SORTED));
     }
   }
 
diff --git a/lucene/dev/branches/lucene3453/modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java b/lucene/dev/branches/lucene3453/modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
index c518f05b..8b622036 100644
--- a/lucene/dev/branches/lucene3453/modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
+++ b/lucene/dev/branches/lucene3453/modules/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
@@ -171,9 +171,7 @@ public void testBasic() throws Exception {
   private void addGroupField(Document doc, String groupField, String value, boolean canUseIDV) {
     doc.add(new Field(groupField, value, TextField.TYPE_STORED));
     if (canUseIDV) {
-      DocValuesField valuesField = new DocValuesField(groupField, Type.BYTES_VAR_SORTED);
-      valuesField.setBytes(new BytesRef(value));
-      doc.add(valuesField);
+      doc.add(new DocValuesField(groupField, new BytesRef(value), Type.BYTES_VAR_SORTED));
     }
   }
 
@@ -705,7 +703,7 @@ public void testRandom() throws Exception {
 
       Document doc = new Document();
       Document docNoGroup = new Document();
-      DocValuesField idvGroupField = new DocValuesField("group", Type.BYTES_VAR_SORTED);
+      DocValuesField idvGroupField = new DocValuesField("group", new BytesRef(), Type.BYTES_VAR_SORTED);
       if (canUseIDV) {
         doc.add(idvGroupField);
       }
@@ -721,7 +719,7 @@ public void testRandom() throws Exception {
       Field content = newField("content", "", TextField.TYPE_UNSTORED);
       doc.add(content);
       docNoGroup.add(content);
-      NumericField id = new NumericField("id", NumericField.DataType.INT);
+      NumericField id = new NumericField("id", 0);
       doc.add(id);
       docNoGroup.add(id);
       final GroupDoc[] groupDocs = new GroupDoc[numDocs];
@@ -747,13 +745,13 @@ public void testRandom() throws Exception {
         if (groupDoc.group != null) {
           group.setValue(groupDoc.group.utf8ToString());
           if (canUseIDV) {
-            idvGroupField.setBytes(BytesRef.deepCopyOf(groupDoc.group));
+            idvGroupField.setValue(BytesRef.deepCopyOf(groupDoc.group));
           }
         }
         sort1.setValue(groupDoc.sort1.utf8ToString());
         sort2.setValue(groupDoc.sort2.utf8ToString());
         content.setValue(groupDoc.content);
-        id.setIntValue(groupDoc.id);
+        id.setValue(groupDoc.id);
         if (groupDoc.group == null) {
           w.addDocument(docNoGroup);
         } else {
diff --git a/lucene/dev/branches/lucene3453/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser.java b/lucene/dev/branches/lucene3453/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser.java
index 5b1301a9..84c48c0b 100644
--- a/lucene/dev/branches/lucene3453/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser.java
+++ b/lucene/dev/branches/lucene3453/modules/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser.java
@@ -33,6 +33,7 @@
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
+import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.NumericField;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
@@ -193,16 +194,36 @@ public static void beforeClass() throws Exception {
       numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,
           NUMBER_FORMAT, type));
       
-      NumericField field = new NumericField(type.name(), PRECISION_STEP, NumericField.getFieldType(type, true));
-      
+      FieldType ft = new FieldType(NumericField.getFieldType(type, true));
+      ft.setNumericPrecisionStep(PRECISION_STEP);
+      final NumericField field;
+
+      switch(type) {
+      case INT:
+        field = new NumericField(type.name(), 0, ft);
+        break;
+      case FLOAT:
+        field = new NumericField(type.name(), 0.0f, ft);
+        break;
+      case LONG:
+        field = new NumericField(type.name(), 0l, ft);
+        break;
+      case DOUBLE:
+        field = new NumericField(type.name(), 0.0, ft);
+        break;
+      default:
+        assert false;
+        field = null;
+      }
       numericFieldMap.put(type.name(), field);
       doc.add(field);
-      
     }
     
     numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,
         DATE_FORMAT, NumericField.DataType.LONG));
-    NumericField dateField = new NumericField(DATE_FIELD_NAME, PRECISION_STEP, NumericField.getFieldType(NumericField.DataType.LONG, true));
+    FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.LONG, true));
+    ft.setNumericPrecisionStep(PRECISION_STEP);
+    NumericField dateField = new NumericField(DATE_FIELD_NAME, 0l, ft);
     numericFieldMap.put(DATE_FIELD_NAME, dateField);
     doc.add(dateField);
     
@@ -264,24 +285,23 @@ private static void setFieldValues(NumberType numberType,
     
     Number number = getNumberType(numberType, NumericField.DataType.DOUBLE
         .name());
-    numericFieldMap.get(NumericField.DataType.DOUBLE.name()).setDoubleValue(
+    numericFieldMap.get(NumericField.DataType.DOUBLE.name()).setValue(
         number.doubleValue());
     
     number = getNumberType(numberType, NumericField.DataType.INT.name());
-    numericFieldMap.get(NumericField.DataType.INT.name()).setIntValue(
+    numericFieldMap.get(NumericField.DataType.INT.name()).setValue(
         number.intValue());
     
     number = getNumberType(numberType, NumericField.DataType.LONG.name());
-    numericFieldMap.get(NumericField.DataType.LONG.name()).setLongValue(
+    numericFieldMap.get(NumericField.DataType.LONG.name()).setValue(
         number.longValue());
     
     number = getNumberType(numberType, NumericField.DataType.FLOAT.name());
-    numericFieldMap.get(NumericField.DataType.FLOAT.name()).setFloatValue(
+    numericFieldMap.get(NumericField.DataType.FLOAT.name()).setValue(
         number.floatValue());
     
     number = getNumberType(numberType, DATE_FIELD_NAME);
-    numericFieldMap.get(DATE_FIELD_NAME).setLongValue(number.longValue());
-    
+    numericFieldMap.get(DATE_FIELD_NAME).setValue(number.longValue());
   }
   
   private static int randomDateStyle(Random random) {
diff --git a/lucene/dev/branches/lucene3453/solr/core/src/java/org/apache/solr/response/transform/BaseEditorialTransformer.java b/lucene/dev/branches/lucene3453/solr/core/src/java/org/apache/solr/response/transform/BaseEditorialTransformer.java
index 6f36adef..3ed970e8 100644
--- a/lucene/dev/branches/lucene3453/solr/core/src/java/org/apache/solr/response/transform/BaseEditorialTransformer.java
+++ b/lucene/dev/branches/lucene3453/solr/core/src/java/org/apache/solr/response/transform/BaseEditorialTransformer.java
@@ -21,7 +21,6 @@
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.NumericField;
 import org.apache.solr.common.SolrDocument;
-import org.apache.solr.handler.component.QueryElevationComponent;
 import org.apache.solr.schema.FieldType;
 
 import java.util.Set;
@@ -67,7 +66,7 @@ protected String getKey(SolrDocument doc) {
     String key;
     Object field = doc.get(idFieldName);
     if (field instanceof NumericField){
-      key = ((Field)field).stringValue();
+      key = ((Field)field).numericValue().toString();
       key = ft.readableToIndexed(key);
     } else if (field instanceof Field){
       key = ((Field)field).stringValue();
diff --git a/lucene/dev/branches/lucene3453/solr/core/src/java/org/apache/solr/schema/TrieField.java b/lucene/dev/branches/lucene3453/solr/core/src/java/org/apache/solr/schema/TrieField.java
index 149a194e..973767d3 100644
--- a/lucene/dev/branches/lucene3453/solr/core/src/java/org/apache/solr/schema/TrieField.java
+++ b/lucene/dev/branches/lucene3453/solr/core/src/java/org/apache/solr/schema/TrieField.java
@@ -501,39 +501,40 @@ public IndexableField createField(SchemaField field, Object value, float boost)
       default:
         throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Unknown type for trie field: " + type);
     }
+    ft.setNumericPrecisionStep(precisionStep);
 
-    final org.apache.lucene.document.NumericField f = new org.apache.lucene.document.NumericField(field.getName(), precisionStep, ft);
+    final org.apache.lucene.document.NumericField f;
 
     switch (type) {
       case INTEGER:
         int i = (value instanceof Number)
           ? ((Number)value).intValue()
           : Integer.parseInt(value.toString());
-        f.setIntValue(i);
+        f = new org.apache.lucene.document.NumericField(field.getName(), i, ft);
         break;
       case FLOAT:
         float fl = (value instanceof Number)
           ? ((Number)value).floatValue()
           : Float.parseFloat(value.toString());
-        f.setFloatValue(fl);
+        f = new org.apache.lucene.document.NumericField(field.getName(), fl, ft);
         break;
       case LONG:
         long l = (value instanceof Number)
           ? ((Number)value).longValue()
           : Long.parseLong(value.toString());
-        f.setLongValue(l);
+        f = new org.apache.lucene.document.NumericField(field.getName(), l, ft);
         break;
       case DOUBLE:
         double d = (value instanceof Number)
           ? ((Number)value).doubleValue()
           : Double.parseDouble(value.toString());
-        f.setDoubleValue(d);
+        f = new org.apache.lucene.document.NumericField(field.getName(), d, ft);
         break;
       case DATE:
         Date date = (value instanceof Date)
           ? ((Date)value)
           : dateField.parseMath(null, value.toString());
-        f.setLongValue(date.getTime());
+        f = new org.apache.lucene.document.NumericField(field.getName(), date.getTime(), ft);
         break;
       default:
         throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Unknown type for trie field: " + type);
diff --git a/lucene/dev/branches/lucene3453/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java b/lucene/dev/branches/lucene3453/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
index 09866b96..2ecf57e3 100644
--- a/lucene/dev/branches/lucene3453/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
+++ b/lucene/dev/branches/lucene3453/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
@@ -436,28 +436,28 @@ public void stringField(FieldInfo fieldInfo, String value) throws IOException {
     public void intField(FieldInfo fieldInfo, int value) {
       FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.INT, true));
       ft.setIndexed(fieldInfo.isIndexed);
-      doc.add(new NumericField(fieldInfo.name, ft).setIntValue(value));
+      doc.add(new NumericField(fieldInfo.name, value, ft));
     }
 
     @Override
     public void longField(FieldInfo fieldInfo, long value) {
       FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.LONG, true));
       ft.setIndexed(fieldInfo.isIndexed);
-      doc.add(new NumericField(fieldInfo.name, ft).setLongValue(value));
+      doc.add(new NumericField(fieldInfo.name, value, ft));
     }
 
     @Override
     public void floatField(FieldInfo fieldInfo, float value) {
       FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.FLOAT, true));
       ft.setIndexed(fieldInfo.isIndexed);
-      doc.add(new NumericField(fieldInfo.name, ft).setFloatValue(value));
+      doc.add(new NumericField(fieldInfo.name, value, ft));
     }
 
     @Override
     public void doubleField(FieldInfo fieldInfo, double value) {
       FieldType ft = new FieldType(NumericField.getFieldType(NumericField.DataType.DOUBLE, true));
       ft.setIndexed(fieldInfo.isIndexed);
-      doc.add(new NumericField(fieldInfo.name, ft).setDoubleValue(value));
+      doc.add(new NumericField(fieldInfo.name, value, ft));
     }
   }
 
diff --git a/lucene/dev/branches/lucene3453/solr/core/src/test/org/apache/solr/schema/PolyFieldTest.java b/lucene/dev/branches/lucene3453/solr/core/src/test/org/apache/solr/schema/PolyFieldTest.java
index f493b0ee..77b37d32 100644
--- a/lucene/dev/branches/lucene3453/solr/core/src/test/org/apache/solr/schema/PolyFieldTest.java
+++ b/lucene/dev/branches/lucene3453/solr/core/src/test/org/apache/solr/schema/PolyFieldTest.java
@@ -88,7 +88,8 @@ public void testPointFieldType() throws Exception {
     //first two fields contain the values, third is just stored and contains the original
     for (int i = 0; i < 3; i++) {
       boolean hasValue = fields[i].binaryValue() != null
-          || fields[i].stringValue() != null;
+          || fields[i].stringValue() != null
+          || fields[i].numericValue() != null;
       assertTrue("Doesn't have a value: " + fields[i], hasValue);
     }
     /*assertTrue("first field " + fields[0].tokenStreamValue() +  " is not 35.0", pt.getSubType().toExternal(fields[0]).equals(String.valueOf(xy[0])));
