diff --git a/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/en/PorterStemFilter.java b/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/en/PorterStemFilter.java
index c52a942f..5b8f0b8d 100644
--- a/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/en/PorterStemFilter.java
+++ b/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/en/PorterStemFilter.java
@@ -34,10 +34,12 @@
     To use this with LowerCaseTokenizer, for example, you'd write an
     analyzer like this:
     <P>
-    <PRE>
+    <PRE class="prettyprint">
     class MyAnalyzer extends Analyzer {
-      public final TokenStream tokenStream(String fieldName, Reader reader) {
-        return new PorterStemFilter(new LowerCaseTokenizer(reader));
+      {@literal @Override}
+      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {
+        Tokenizer source = new LowerCaseTokenizer(version, reader);
+        return new TokenStreamComponents(source, new PorterStemFilter(source));
       }
     }
     </PRE>
diff --git a/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/HyphenatedWordsFilter.java b/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/HyphenatedWordsFilter.java
index 598d5ae1..ff598991 100644
--- a/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/HyphenatedWordsFilter.java
+++ b/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/HyphenatedWordsFilter.java
@@ -29,7 +29,7 @@
  * In order to increase search efficiency, this filter puts hyphenated words broken into two lines back together.
  * This filter should be used on indexing time only.
  * Example field definition in schema.xml:
- * <pre>
+ * <pre class="prettyprint">
  * &lt;fieldtype name="text" class="solr.TextField" positionIncrementGap="100"&gt;
  * 	&lt;analyzer type="index"&gt;
  * 		&lt;tokenizer class="solr.WhitespaceTokenizerFactory"/&gt;
diff --git a/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/PerFieldAnalyzerWrapper.java b/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/PerFieldAnalyzerWrapper.java
index 448acc5c..b52e9641 100644
--- a/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/PerFieldAnalyzerWrapper.java
+++ b/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/PerFieldAnalyzerWrapper.java
@@ -31,13 +31,15 @@
  * 
  * <p>Example usage:
  * 
- * <pre>
- *   Map analyzerPerField = new HashMap();
+ * <pre class="prettyprint">
+ * {@code
+ * Map<String,Analyzer> analyzerPerField = new HashMap<String,Analyzer>();
  *   analyzerPerField.put("firstname", new KeywordAnalyzer());
  *   analyzerPerField.put("lastname", new KeywordAnalyzer());
  *
  *   PerFieldAnalyzerWrapper aWrapper =
- *      new PerFieldAnalyzerWrapper(new StandardAnalyzer(), analyzerPerField);
+ *   new PerFieldAnalyzerWrapper(new StandardAnalyzer(version), analyzerPerField);
+ * }
  * </pre>
  * 
  * <p>In this example, StandardAnalyzer will be used for all fields except "firstname"
diff --git a/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/sinks/TeeSinkTokenFilter.java b/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/sinks/TeeSinkTokenFilter.java
index 418fe7a9..80a0ce22 100644
--- a/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/sinks/TeeSinkTokenFilter.java
+++ b/lucene/dev/trunk/lucene/analysis/common/src/java/org/apache/lucene/analysis/sinks/TeeSinkTokenFilter.java
@@ -36,24 +36,24 @@
  * It is also useful for doing things like entity extraction or proper noun analysis as
  * part of the analysis workflow and saving off those tokens for use in another field.
  *
- * <pre>
-TeeSinkTokenFilter source1 = new TeeSinkTokenFilter(new WhitespaceTokenizer(reader1));
+ * <pre class="prettyprint">
+TeeSinkTokenFilter source1 = new TeeSinkTokenFilter(new WhitespaceTokenizer(version, reader1));
 TeeSinkTokenFilter.SinkTokenStream sink1 = source1.newSinkTokenStream();
 TeeSinkTokenFilter.SinkTokenStream sink2 = source1.newSinkTokenStream();
 
-TeeSinkTokenFilter source2 = new TeeSinkTokenFilter(new WhitespaceTokenizer(reader2));
+TeeSinkTokenFilter source2 = new TeeSinkTokenFilter(new WhitespaceTokenizer(version, reader2));
 source2.addSinkTokenStream(sink1);
 source2.addSinkTokenStream(sink2);
 
-TokenStream final1 = new LowerCaseFilter(source1);
+TokenStream final1 = new LowerCaseFilter(version, source1);
 TokenStream final2 = source2;
 TokenStream final3 = new EntityDetect(sink1);
 TokenStream final4 = new URLDetect(sink2);
 
-d.add(new Field("f1", final1));
-d.add(new Field("f2", final2));
-d.add(new Field("f3", final3));
-d.add(new Field("f4", final4));
+d.add(new TextField("f1", final1, Field.Store.NO));
+d.add(new TextField("f2", final2, Field.Store.NO));
+d.add(new TextField("f3", final3, Field.Store.NO));
+d.add(new TextField("f4", final4, Field.Store.NO));
  * </pre>
  * In this example, <code>sink1</code> and <code>sink2</code> will both get tokens from both
  * <code>reader1</code> and <code>reader2</code> after whitespace tokenizer
@@ -63,9 +63,9 @@
  * add another sink and then pass all tokens to the sinks at once using {@link #consumeAllTokens}.
  * This TokenFilter is exhausted after this. In the above example, change
  * the example above to:
- * <pre>
+ * <pre class="prettyprint">
 ...
-TokenStream final1 = new LowerCaseFilter(source1.newSinkTokenStream());
+TokenStream final1 = new LowerCaseFilter(version, source1.newSinkTokenStream());
 TokenStream final2 = source2.newSinkTokenStream();
 sink1.consumeAllTokens();
 sink2.consumeAllTokens();
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/analysis/NumericTokenStream.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/analysis/NumericTokenStream.java
index e5ee6d0c..7edab6f0 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/analysis/NumericTokenStream.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/analysis/NumericTokenStream.java
@@ -47,21 +47,17 @@
  *
  * <p>Here's an example usage, for an <code>int</code> field:
  *
- * <pre>
- *  Field field = new Field(name, new NumericTokenStream(precisionStep).setIntValue(value));
- *  field.setOmitNorms(true);
- *  field.setIndexOptions(IndexOptions.DOCS_ONLY);
+ * <pre class="prettyprint">
+ *  Field field = new Field(name, new NumericTokenStream(precisionStep).setIntValue(value), IntField.TYPE_NOT_STORED);
  *  document.add(field);
  * </pre>
  *
  * <p>For optimal performance, re-use the TokenStream and Field instance
  * for more than one document:
  *
- * <pre>
+ * <pre class="prettyprint">
  *  NumericTokenStream stream = new NumericTokenStream(precisionStep);
- *  Field field = new Field(name, stream);
- *  field.setOmitNorms(true);
- *  field.setIndexOptions(IndexOptions.DOCS_ONLY);
+ *  Field field = new Field(name, stream, IntField.TYPE_NOT_STORED);
  *  Document document = new Document();
  *  document.add(field);
  *
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/analysis/Token.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/analysis/Token.java
index e1b9f3c4..6a2b71a0 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/analysis/Token.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/analysis/Token.java
@@ -79,28 +79,28 @@ A Token can optionally have metadata (a.k.a. payload) in the form of a variable
   <p>Typical Token reuse patterns:
   <ul>
   <li> Copying text from a string (type is reset to {@link #DEFAULT_TYPE} if not specified):<br/>
-  <pre>
+  <pre class="prettyprint">
     return reusableToken.reinit(string, startOffset, endOffset[, type]);
   </pre>
   </li>
   <li> Copying some text from a string (type is reset to {@link #DEFAULT_TYPE} if not specified):<br/>
-  <pre>
+  <pre class="prettyprint">
     return reusableToken.reinit(string, 0, string.length(), startOffset, endOffset[, type]);
   </pre>
   </li>
   </li>
   <li> Copying text from char[] buffer (type is reset to {@link #DEFAULT_TYPE} if not specified):<br/>
-  <pre>
+  <pre class="prettyprint">
     return reusableToken.reinit(buffer, 0, buffer.length, startOffset, endOffset[, type]);
   </pre>
   </li>
   <li> Copying some text from a char[] buffer (type is reset to {@link #DEFAULT_TYPE} if not specified):<br/>
-  <pre>
+  <pre class="prettyprint">
     return reusableToken.reinit(buffer, start, end - start, startOffset, endOffset[, type]);
   </pre>
   </li>
   <li> Copying from one one Token to another (type is reset to {@link #DEFAULT_TYPE} if not specified):<br/>
-  <pre>
+  <pre class="prettyprint">
     return reusableToken.reinit(source.buffer(), 0, source.length(), source.startOffset(), source.endOffset()[, source.type()]);
   </pre>
   </li>
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/ByteDocValuesField.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/ByteDocValuesField.java
index 74e2142d..5ebde130 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/ByteDocValuesField.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/ByteDocValuesField.java
@@ -25,7 +25,7 @@
  * of a per-document byte value for scoring, sorting or value retrieval. Here's an
  * example usage:
  * 
- * <pre>
+ * <pre class="prettyprint">
  *   document.add(new ByteDocValuesField(name, (byte) 22));
  * </pre>
  * 
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/DerefBytesDocValuesField.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/DerefBytesDocValuesField.java
index 98755d63..7feef252 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/DerefBytesDocValuesField.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/DerefBytesDocValuesField.java
@@ -30,7 +30,7 @@
  * are (mostly) unique it's better to use {@link
  * StraightBytesDocValuesField}.  Here's an example usage: 
  * 
- * <pre>
+ * <pre class="prettyprint">
  *   document.add(new DerefBytesDocValuesField(name, new BytesRef("hello")));
  * </pre>
  * 
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/DoubleDocValuesField.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/DoubleDocValuesField.java
index 6b21cf3d..9d741cbc 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/DoubleDocValuesField.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/DoubleDocValuesField.java
@@ -25,7 +25,7 @@
  * of a per-document double value for scoring, sorting or value retrieval. Here's an
  * example usage:
  * 
- * <pre>
+ * <pre class="prettyprint">
  *   document.add(new DoubleDocValuesField(name, 22.0));
  * </pre>
  * 
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/DoubleField.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/DoubleField.java
index 77ebdd51..6427e142 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/DoubleField.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/DoubleField.java
@@ -29,14 +29,14 @@
  * This class provides a {@link Field} that enables indexing of double values
  * for efficient range filtering and sorting. Here's an example usage:
  * 
- * <pre>
+ * <pre class="prettyprint">
  * document.add(new DoubleField(name, 6.0, Field.Store.NO));
  * </pre>
  * 
  * For optimal performance, re-use the <code>DoubleField</code> and
  * {@link Document} instance for more than one document:
  * 
- * <pre>
+ * <pre class="prettyprint">
  *  DoubleField field = new DoubleField(name, 0.0, Field.Store.NO);
  *  Document document = new Document();
  *  document.add(field);
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/FloatDocValuesField.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/FloatDocValuesField.java
index bf66370e..ae8be5fb 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/FloatDocValuesField.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/FloatDocValuesField.java
@@ -25,7 +25,7 @@
  * of a per-document float value for scoring, sorting or value retrieval. Here's an
  * example usage:
  * 
- * <pre>
+ * <pre class="prettyprint">
  *   document.add(new FloatDocValuesField(name, 22f));
  * </pre>
  * 
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/FloatField.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/FloatField.java
index c3239480..c1f07116 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/FloatField.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/FloatField.java
@@ -29,14 +29,14 @@
  * This class provides a {@link Field} that enables indexing of float values
  * for efficient range filtering and sorting. Here's an example usage:
  * 
- * <pre>
+ * <pre class="prettyprint">
  * document.add(new FloatField(name, 6.0F, Field.Store.NO));
  * </pre>
  * 
  * For optimal performance, re-use the <code>FloatField</code> and
  * {@link Document} instance for more than one document:
  * 
- * <pre>
+ * <pre class="prettyprint">
  *  FloatField field = new FloatField(name, 0.0F, Field.Store.NO);
  *  Document document = new Document();
  *  document.add(field);
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/IntDocValuesField.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/IntDocValuesField.java
index a06012cd..4b8b9200 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/IntDocValuesField.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/IntDocValuesField.java
@@ -25,7 +25,7 @@
  * of a per-document int value for scoring, sorting or value retrieval. Here's an
  * example usage:
  * 
- * <pre>
+ * <pre class="prettyprint">
  *   document.add(new IntDocValuesField(name, 22));
  * </pre>
  * 
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/IntField.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/IntField.java
index ac348f46..aa8227cb 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/IntField.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/IntField.java
@@ -29,14 +29,14 @@
  * This class provides a {@link Field} that enables indexing of integer values
  * for efficient range filtering and sorting. Here's an example usage:
  * 
- * <pre>
+ * <pre class="prettyprint">
  * document.add(new IntField(name, 6, Field.Store.NO));
  * </pre>
  * 
  * For optimal performance, re-use the <code>IntField</code> and
  * {@link Document} instance for more than one document:
  * 
- * <pre>
+ * <pre class="prettyprint">
  *  IntField field = new IntField(name, 6, Field.Store.NO);
  *  Document document = new Document();
  *  document.add(field);
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/LongDocValuesField.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/LongDocValuesField.java
index e0233318..75989bb8 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/LongDocValuesField.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/LongDocValuesField.java
@@ -25,7 +25,7 @@
  * of a per-document long value for scoring, sorting or value retrieval. Here's an
  * example usage:
  * 
- * <pre>
+ * <pre class="prettyprint">
  *   document.add(new LongDocValuesField(name, 22L));
  * </pre>
  * 
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/LongField.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/LongField.java
index 7535a53b..17af3acc 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/LongField.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/LongField.java
@@ -29,14 +29,14 @@
  * This class provides a {@link Field} that enables indexing of long values
  * for efficient range filtering and sorting. Here's an example usage:
  * 
- * <pre>
+ * <pre class="prettyprint">
  * document.add(new LongField(name, 6L, Field.Store.NO));
  * </pre>
  * 
  * For optimal performance, re-use the <code>LongField</code> and
  * {@link Document} instance for more than one document:
  * 
- * <pre>
+ * <pre class="prettyprint">
  *  LongField field = new LongField(name, 0L, Field.Store.NO);
  *  Document document = new Document();
  *  document.add(field);
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/PackedLongDocValuesField.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/PackedLongDocValuesField.java
index b1b8b4a6..afb8a8cb 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/PackedLongDocValuesField.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/PackedLongDocValuesField.java
@@ -28,7 +28,7 @@
  * in RAM (when loaded via {@link AtomicReader#docValues})
  * using packed ints. Here's an example usage:
  * 
- * <pre>
+ * <pre class="prettyprint">
  *   document.add(new PackedLongDocValuesField(name, 22L));
  * </pre>
  * 
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/ShortDocValuesField.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/ShortDocValuesField.java
index cb338766..60665616 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/ShortDocValuesField.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/ShortDocValuesField.java
@@ -25,7 +25,7 @@
  * of a per-document short value for scoring, sorting or value retrieval. Here's an
  * example usage:
  * 
- * <pre>
+ * <pre class="prettyprint">
  *   document.add(new ShortDocValuesField(name, (short) 22));
  * </pre>
  * 
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/SortedBytesDocValuesField.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/SortedBytesDocValuesField.java
index a5ec57bf..9cc0bebb 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/SortedBytesDocValuesField.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/SortedBytesDocValuesField.java
@@ -26,7 +26,7 @@
  * of a per-document {@link BytesRef} value, indexed for
  * sorting.  Here's an example usage:
  * 
- * <pre>
+ * <pre class="prettyprint">
  *   document.add(new SortedBytesDocValuesField(name, new BytesRef("hello")));
  * </pre>
  * 
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/StraightBytesDocValuesField.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/StraightBytesDocValuesField.java
index f93d6b3e..1b4a4552 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/StraightBytesDocValuesField.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/document/StraightBytesDocValuesField.java
@@ -29,7 +29,7 @@
  * field.  If values may be shared it's better to use {@link
  * DerefBytesDocValuesField}.  Here's an example usage:
  * 
- * <pre>
+ * <pre class="prettyprint">
  *   document.add(new StraightBytesDocValuesField(name, new BytesRef("hello")));
  * </pre>
  * 
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java
index 329104d9..b258f9e1 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java
@@ -210,7 +210,7 @@ protected synchronized void updateMergeThreads() {
    * Returns true if verbosing is enabled. This method is usually used in
    * conjunction with {@link #message(String)}, like that:
    * 
-   * <pre>
+   * <pre class="prettyprint">
    * if (verbose()) {
    *   message(&quot;your message&quot;);
    * }
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
index 20dbaf00..4290c05e 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
@@ -796,7 +796,7 @@ private void messageState() {
    * docs in the IndexWriter instance) then you can do
    * something like this:</p>
    *
-   * <pre>
+   * <pre class="prettyprint">
    * try {
    *   writer.close();
    * } finally {
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java
index 47023680..c773326f 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/index/IndexWriterConfig.java
@@ -39,7 +39,7 @@
  * All setter methods return {@link IndexWriterConfig} to allow chaining
  * settings conveniently, for example:
  * 
- * <pre>
+ * <pre class="prettyprint">
  * IndexWriterConfig conf = new IndexWriterConfig(analyzer);
  * conf.setter1().setter2();
  * </pre>
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
index a27e9475..414bb17a 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
@@ -156,7 +156,7 @@ public void add(BooleanClause clause) {
 
   /** Returns an iterator on the clauses in this query. It implements the {@link Iterable} interface to
    * make it possible to do:
-   * <pre>for (BooleanClause clause : booleanQuery) {}</pre>
+   * <pre class="prettyprint">for (BooleanClause clause : booleanQuery) {}</pre>
    */
   public final Iterator<BooleanClause> iterator() { return clauses().iterator(); }
 
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/Collector.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/Collector.java
index ffd30118..1d4121c1 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/Collector.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/Collector.java
@@ -80,8 +80,8 @@
  * a simple example showing how to collect docIDs into a
  * BitSet:</p>
  * 
- * <pre>
- * Searcher searcher = new IndexSearcher(indexReader);
+ * <pre class="prettyprint">
+ * IndexSearcher searcher = new IndexSearcher(indexReader);
  * final BitSet bits = new BitSet(indexReader.maxDoc());
  * searcher.search(query, new Collector() {
  *   private int docBase;
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java
index 900fc1e8..d5fc01b1 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java
@@ -72,7 +72,7 @@
    * <p>
    * When <code> target &gt; current</code> it behaves as if written:
    * 
-   * <pre>
+   * <pre class="prettyprint">
    * int advance(int target) {
    *   int doc;
    *   while ((doc = nextDoc()) &lt; target) {
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/HitQueue.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/HitQueue.java
index 3880bad5..bec8e0fc 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/HitQueue.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/HitQueue.java
@@ -30,8 +30,8 @@
    * <b>NOTE:</b> in case <code>prePopulate</code> is true, you should pop
    * elements from the queue using the following code example:
    * 
-   * <pre>
-   * PriorityQueue pq = new HitQueue(10, true); // pre-populate.
+   * <pre class="prettyprint">
+   * PriorityQueue&lt;ScoreDoc&gt; pq = new HitQueue(10, true); // pre-populate.
    * ScoreDoc top = pq.top();
    * 
    * // Add/Update one element.
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/NRTManagerReopenThread.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/NRTManagerReopenThread.java
index e21faf47..5317bd1c 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/NRTManagerReopenThread.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/NRTManagerReopenThread.java
@@ -29,7 +29,7 @@
  *
  * <p> Typical usage looks like this:
  *
- * <pre>
+ * <pre class="prettyprint">
  *   ... open your own writer ...
  * 
  *   NRTManager manager = new NRTManager(writer);
@@ -45,7 +45,7 @@
  *
  * Then, for each incoming query, do this:
  *
- * <pre>
+ * <pre class="prettyprint">
  *   // For each incoming query:
  *   IndexSearcher searcher = manager.get();
  *   try {
@@ -58,7 +58,7 @@
  * You should make changes using the <code>NRTManager</code>; if you later need to obtain
  * a searcher reflecting those changes:
  *
- * <pre>
+ * <pre class="prettyprint">
  *   // ... or updateDocument, deleteDocuments, etc:
  *   long gen = manager.addDocument(...);
  *   
@@ -73,7 +73,7 @@
  *
  *
  * When you are done be sure to close both the manager and the reopen thrad:
- * <pre> 
+ * <pre class="prettyprint"> 
  *   reopenThread.close();       
  *   manager.close();
  * </pre>
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/NumericRangeFilter.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/NumericRangeFilter.java
index 4c1090a7..7fd66998 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/NumericRangeFilter.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/NumericRangeFilter.java
@@ -34,7 +34,7 @@
  * <p>You create a new NumericRangeFilter with the static
  * factory methods, eg:
  *
- * <pre>
+ * <pre class="prettyprint">
  * Filter f = NumericRangeFilter.newFloatRange("weight", 0.03f, 0.10f, true, true);
  * </pre>
  *
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
index 5e351976..fc8da481 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
@@ -49,7 +49,7 @@
  * <p>You create a new NumericRangeQuery with the static
  * factory methods, eg:
  *
- * <pre>
+ * <pre class="prettyprint">
  * Query q = NumericRangeQuery.newFloatRange("weight", 0.03f, 0.10f, true, true);
  * </pre>
  *
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/SearcherLifetimeManager.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/SearcherLifetimeManager.java
index 6995682f..ce546767 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/SearcherLifetimeManager.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/SearcherLifetimeManager.java
@@ -35,7 +35,7 @@
  *
  * Use it like this:
  *
- * <pre>
+ * <pre class="prettyprint">
  *   SearcherLifetimeManager mgr = new SearcherLifetimeManager();
  * </pre>
  *
@@ -44,7 +44,7 @@
  * using {@link SearcherManager} or {@link NRTManager}), and
  * then record this searcher:
  *
- * <pre>
+ * <pre class="prettyprint">
  *   // Record the current searcher, and save the returend
  *   // token into user's search results (eg as a  hidden
  *   // HTML form field):
@@ -55,7 +55,7 @@
  * clicks next page, drills down/up, etc., take the token
  * that you saved from the previous search and:
  *
- * <pre>
+ * <pre class="prettyprint">
  *   // If possible, obtain the same searcher as the last
  *   // search:
  *   IndexSearcher searcher = mgr.acquire(token);
@@ -78,7 +78,7 @@
  * that's periodically reopening your searchers, you should
  * periodically prune old searchers:
  *
- * <pre>
+ * <pre class="prettyprint">
  *   mgr.prune(new PruneByAge(600.0));
  * </pre>
  *
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/TimeLimitingCollector.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/TimeLimitingCollector.java
index 1694789d..98bdd8b1 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/TimeLimitingCollector.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/TimeLimitingCollector.java
@@ -86,7 +86,7 @@ public TimeLimitingCollector(final Collector collector, Counter clock, final lon
    * set the baseline through this method in your prelude.
    * <p>
    * Example usage:
-   * <pre>
+   * <pre class="prettyprint">
    *   Counter clock = ...;
    *   long baseline = clock.get();
    *   // ... prepare search
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity.java
index cc6a1a58..637a4f05 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/similarities/TFIDFSimilarity.java
@@ -597,7 +597,7 @@ public float tf(int freq) {
    * <p>
    * The default implementation uses:
    * 
-   * <pre>
+   * <pre class="prettyprint">
    * idf(docFreq, searcher.maxDoc());
    * </pre>
    * 
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
index 5f99458d..f65ba56a 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
@@ -59,7 +59,7 @@
  * 
  * <p>a SpanNearQuery with a slop of 0 can be applied across two 
  * {@link SpanTermQuery} objects as follows:
- * <pre>
+ * <pre class="prettyprint">
  *    SpanQuery q1  = new SpanTermQuery(new Term("studentfirstname", "james"));
  *    SpanQuery q2  = new SpanTermQuery(new Term("studentsurname", "jones"));
  *    SpanQuery q2m = new FieldMaskingSpanQuery(q2, "studentfirstname");
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java
index 22bf5a20..0914803a 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java
@@ -39,7 +39,7 @@
  * the expanded terms, but this can be customized. 
  * <p>
  * Example:
- * <blockquote><pre>
+ * <blockquote><pre class="prettyprint">
  * {@code
  * WildcardQuery wildcard = new WildcardQuery(new Term("field", "bro?n"));
  * SpanQuery spanWildcard = new SpanMultiTermQueryWrapper<WildcardQuery>(wildcard);
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
index 4006b446..9c094d71 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
@@ -30,7 +30,7 @@
 
   /** Skips to the first match beyond the current, whose document number is
    * greater than or equal to <i>target</i>. <p>Returns true iff there is such
-   * a match.  <p>Behaves as if written: <pre>
+   * a match.  <p>Behaves as if written: <pre class="prettyprint">
    *   boolean skipTo(int target) {
    *     do {
    *       if (!next())
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/store/Directory.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/store/Directory.java
index 8313ef2c..8808eff3 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/store/Directory.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/store/Directory.java
@@ -180,7 +180,7 @@ public String toString() {
    * If you want to copy the entire source directory to the destination one, you
    * can do so like this:
    * 
-   * <pre>
+   * <pre class="prettyprint">
    * Directory to; // the directory to copy to
    * for (String file : dir.listAll()) {
    *   dir.copy(to, file, newFile); // newFile can be either file, or a new name
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/store/Lock.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/store/Lock.java
index e4608978..1d35f5df 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/store/Lock.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/store/Lock.java
@@ -21,7 +21,7 @@
 import java.io.IOException;
 
 /** An interprocess mutex lock.
- * <p>Typical use might look like:<pre>
+ * <p>Typical use might look like:<pre class="prettyprint">
  * new Lock.With(directory.makeLock("my.lock")) {
  *     public Object doBody() {
  *       <i>... code to execute while locked ...</i>
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory.java
index 86bc27ef..9025afd5 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory.java
@@ -47,7 +47,7 @@
  *
  * <p>Here's a simple example usage:
  *
- * <pre>
+ * <pre class="prettyprint">
  *   Directory fsDir = FSDirectory.open(new File("/path/to/index"));
  *   NRTCachingDirectory cachedFSDir = new NRTCachingDirectory(fsDir, 5.0, 60.0);
  *   IndexWriterConfig conf = new IndexWriterConfig(Version.LUCENE_32, analyzer);
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/AttributeImpl.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/AttributeImpl.java
index fac03874..2d64e966 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/AttributeImpl.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/AttributeImpl.java
@@ -75,7 +75,7 @@ public void reflect(Class<? extends Attribute> attClass, String key, Object valu
    * implementations.
    *
    * <p>Custom implementations look like this (e.g. for a combined attribute implementation):
-   * <pre>
+   * <pre class="prettyprint">
    *   public void reflectWith(AttributeReflector reflector) {
    *     reflector.reflect(CharTermAttribute.class, "term", term());
    *     reflector.reflect(PositionIncrementAttribute.class, "positionIncrement", getPositionIncrement());
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/BytesRef.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/BytesRef.java
index 8fe045fe..29ae3716 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/BytesRef.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/BytesRef.java
@@ -130,7 +130,7 @@ public BytesRef clone() {
   
   /** Calculates the hash code as required by TermsHash during indexing.
    * <p>It is defined as:
-   * <pre>
+   * <pre class="prettyprint">
    *  int hash = 0;
    *  for (int i = offset; i &lt; offset + length; i++) {
    *    hash = 31*hash + bytes[i];
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java
index 45385db1..6805fda7 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java
@@ -281,7 +281,7 @@ public int add(BytesRef bytes) {
    *          <p>
    *          Hashcode is defined as:
    * 
-   *          <pre>
+   *          <pre class="prettyprint">
    * int hash = 0;
    * for (int i = offset; i &lt; offset + length; i++) {
    *   hash = 31 * hash + bytes[i];
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/IOUtils.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/IOUtils.java
index 5770b80e..0e76c600 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/IOUtils.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/IOUtils.java
@@ -56,7 +56,7 @@ private IOUtils() {} // no instance
    * may be null, they are ignored. After everything is closed, method either throws <tt>priorException</tt>,
    * if one is supplied, or the first of suppressed exceptions, or completes normally.</p>
    * <p>Sample usage:<br/>
-   * <pre>
+   * <pre class="prettyprint">
    * Closeable resource1 = null, resource2 = null, resource3 = null;
    * ExpectedException priorE = null;
    * try {
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/PriorityQueue.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/PriorityQueue.java
index 477ea1bb..a06c8432 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/PriorityQueue.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/PriorityQueue.java
@@ -101,7 +101,7 @@ public PriorityQueue(int maxSize, boolean prepopulate) {
    * If this method is extended to return a non-null value, then the following
    * usage pattern is recommended:
    * 
-   * <pre>
+   * <pre class="prettyprint">
    * // extends getSentinelObject() to return a non-null value.
    * PriorityQueue&lt;MyObject&gt; pq = new MyQueue&lt;MyObject&gt;(numHits);
    * // save the 'top' element, which is guaranteed to not be null.
@@ -191,14 +191,14 @@ public final T pop() {
    * Should be called when the Object at top changes values. Still log(n) worst
    * case, but it's at least twice as fast to
    * 
-   * <pre>
+   * <pre class="prettyprint">
    * pq.top().change();
    * pq.updateTop();
    * </pre>
    * 
    * instead of
    * 
-   * <pre>
+   * <pre class="prettyprint">
    * o = pq.pop();
    * o.change();
    * pq.push(o);
diff --git a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/VirtualMethod.java b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/VirtualMethod.java
index ec55374f..02618a62 100644
--- a/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/VirtualMethod.java
+++ b/lucene/dev/trunk/lucene/core/src/java/org/apache/lucene/util/VirtualMethod.java
@@ -31,7 +31,7 @@
  * The cost of reflection is minimized by the following usage of this class:</p>
  * <p>Define <strong>static final</strong> fields in the base class ({@code BaseClass}),
  * where the old and new method are declared:</p>
- * <pre>
+ * <pre class="prettyprint">
  *  static final VirtualMethod&lt;BaseClass&gt; newMethod =
  *   new VirtualMethod&lt;BaseClass&gt;(BaseClass.class, "newName", parameters...);
  *  static final VirtualMethod&lt;BaseClass&gt; oldMethod =
@@ -41,7 +41,7 @@
  * If you try to create a second instance of for the same method/{@code baseClass} combination, an exception is thrown.
  * <p>To detect if e.g. the old method was overridden by a more far subclass on the inheritance path to the current
  * instance's class, use a <strong>non-static</strong> field:</p>
- * <pre>
+ * <pre class="prettyprint">
  *  final boolean isDeprecatedMethodOverridden =
  *   oldMethod.getImplementationDistance(this.getClass()) > newMethod.getImplementationDistance(this.getClass());
  *
diff --git a/lucene/dev/trunk/lucene/facet/src/java/org/apache/lucene/facet/search/PayloadIntDecodingIterator.java b/lucene/dev/trunk/lucene/facet/src/java/org/apache/lucene/facet/search/PayloadIntDecodingIterator.java
index 1dea8046..2c6c4e8d 100644
--- a/lucene/dev/trunk/lucene/facet/src/java/org/apache/lucene/facet/search/PayloadIntDecodingIterator.java
+++ b/lucene/dev/trunk/lucene/facet/src/java/org/apache/lucene/facet/search/PayloadIntDecodingIterator.java
@@ -31,7 +31,7 @@
  * The iterator then consumes the payload information of each document and
  * decodes it into categories. A typical use case of this class is:
  * 
- * <pre>
+ * <pre class="prettyprint">
  * IndexReader reader = [open your reader];
  * Term t = new Term(&quot;field&quot;, &quot;where-payload-exists&quot;);
  * CategoryListIterator cli = new PayloadIntDecodingIterator(reader, t);
diff --git a/lucene/dev/trunk/lucene/facet/src/java/org/apache/lucene/util/encoding/ChunksIntEncoder.java b/lucene/dev/trunk/lucene/facet/src/java/org/apache/lucene/util/encoding/ChunksIntEncoder.java
index 2038dc74..a9c10d92 100644
--- a/lucene/dev/trunk/lucene/facet/src/java/org/apache/lucene/util/encoding/ChunksIntEncoder.java
+++ b/lucene/dev/trunk/lucene/facet/src/java/org/apache/lucene/util/encoding/ChunksIntEncoder.java
@@ -44,7 +44,7 @@
  * <p>
  * For the reasons mentioned above, these encoders are usually chained with
  * {@link UniqueValuesIntEncoder} and {@link DGapIntEncoder} in the following
- * manner: <code><pre>
+ * manner: <code><pre class="prettyprint">
  * IntEncoder fourFlags = 
  *         new SortingEncoderFilter(new UniqueValuesIntEncoder(new DGapIntEncoder(new FlagsIntEncoderImpl())));
  * </code></pre>
diff --git a/lucene/dev/trunk/lucene/facet/src/java/org/apache/lucene/util/encoding/IntEncoderFilter.java b/lucene/dev/trunk/lucene/facet/src/java/org/apache/lucene/util/encoding/IntEncoderFilter.java
index 67879bda..6c7a4034 100644
--- a/lucene/dev/trunk/lucene/facet/src/java/org/apache/lucene/util/encoding/IntEncoderFilter.java
+++ b/lucene/dev/trunk/lucene/facet/src/java/org/apache/lucene/util/encoding/IntEncoderFilter.java
@@ -24,7 +24,7 @@
  * An abstract implementation of {@link IntEncoder} which is served as a filter
  * on the values to encode. An encoder filter wraps another {@link IntEncoder}
  * which does the actual encoding. This allows for chaining filters and
- * encoders, such as: <code><pre>
+ * encoders, such as: <code><pre class="prettyprint">
  * new UniqueValuesIntEncoder(new DGapIntEncoder(new VInt8IntEnoder()));
  * {@link UniqueValuesIntEncoder} followed by {@link DGapIntEncoder}
   </pre></code>
diff --git a/lucene/dev/trunk/lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SingleFragListBuilder.java b/lucene/dev/trunk/lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SingleFragListBuilder.java
index e8a2e17b..9aaeed04 100644
--- a/lucene/dev/trunk/lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SingleFragListBuilder.java
+++ b/lucene/dev/trunk/lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SingleFragListBuilder.java
@@ -28,7 +28,7 @@
  * An implementation class of {@link FragListBuilder} that generates one {@link WeightedFragInfo} object.
  * Typical use case of this class is that you can get an entire field contents
  * by using both of this class and {@link SimpleFragmentsBuilder}.<br/>
- * <pre>
+ * <pre class="prettyprint">
  * FastVectorHighlighter h = new FastVectorHighlighter( true, true,
  *   new SingleFragListBuilder(), new SimpleFragmentsBuilder() );
  * </pre>
diff --git a/lucene/dev/trunk/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java b/lucene/dev/trunk/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
index 08af8c9c..de10a046 100644
--- a/lucene/dev/trunk/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
+++ b/lucene/dev/trunk/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
@@ -78,7 +78,7 @@
  * numbers of queries over comparatively small transient realtime data (prospective 
  * search). 
  * For example as in 
- * <pre>
+ * <pre class="prettyprint">
  * float score = search(String text, Query query)
  * </pre>
  * <p>
@@ -114,13 +114,12 @@
  * 
  * <h4>Example Usage</h4> 
  * 
- * <pre>
- * Analyzer analyzer = PatternAnalyzer.DEFAULT_ANALYZER;
- * //Analyzer analyzer = new SimpleAnalyzer();
+ * <pre class="prettyprint">
+ * Analyzer analyzer = new SimpleAnalyzer(version);
  * MemoryIndex index = new MemoryIndex();
  * index.addField("content", "Readings about Salmons and other select Alaska fishing Manuals", analyzer);
  * index.addField("author", "Tales of James", analyzer);
- * QueryParser parser = new QueryParser("content", analyzer);
+ * QueryParser parser = new QueryParser(version, "content", analyzer);
  * float score = index.search(parser.parse("+author:james +salmon~ +fish* manual~"));
  * if (score &gt; 0.0f) {
  *     System.out.println("it's a match");
@@ -133,7 +132,7 @@
  * 
  * <h4>Example XQuery Usage</h4> 
  * 
- * <pre>
+ * <pre class="prettyprint">
  * (: An XQuery that finds all books authored by James that have something to do with "salmon fishing manuals", sorted by relevance :)
  * declare namespace lucene = "java:nux.xom.pool.FullTextUtil";
  * declare variable $query := "+salmon~ +fish* manual~"; (: any arbitrary Lucene query can go here :)
@@ -149,7 +148,7 @@
  * 
  * An instance can be queried multiple times with the same or different queries,
  * but an instance is not thread-safe. If desired use idioms such as:
- * <pre>
+ * <pre class="prettyprint">
  * MemoryIndex index = ...
  * synchronized (index) {
  *    // read and/or write index (i.e. add fields and/or query)
diff --git a/lucene/dev/trunk/lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter.java b/lucene/dev/trunk/lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter.java
index 2a2d00ec..85cdafd9 100644
--- a/lucene/dev/trunk/lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter.java
+++ b/lucene/dev/trunk/lucene/queries/src/java/org/apache/lucene/queries/BooleanFilter.java
@@ -129,7 +129,7 @@ public final void add(Filter filter, Occur occur) {
   
   /** Returns an iterator on the clauses in this query. It implements the {@link Iterable} interface to
    * make it possible to do:
-   * <pre>for (FilterClause clause : booleanFilter) {}</pre>
+   * <pre class="prettyprint">for (FilterClause clause : booleanFilter) {}</pre>
    */
   public final Iterator<FilterClause> iterator() {
     return clauses().iterator();
diff --git a/lucene/dev/trunk/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/MultiFieldQueryParser.java b/lucene/dev/trunk/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/MultiFieldQueryParser.java
index e4f01f08..fe1a859e 100644
--- a/lucene/dev/trunk/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/MultiFieldQueryParser.java
+++ b/lucene/dev/trunk/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/MultiFieldQueryParser.java
@@ -253,8 +253,9 @@ public static Query parse(Version matchVersion, String[] queries, String[] field
    * Parses a query, searching on the fields specified.
    * Use this if you need to specify certain fields as required,
    * and others as prohibited.
-   * <p><pre>
+   * <p>
    * Usage:
+   * <pre class="prettyprint">
    * <code>
    * String[] fields = {"filename", "contents", "description"};
    * BooleanClause.Occur[] flags = {BooleanClause.Occur.SHOULD,
@@ -300,8 +301,9 @@ public static Query parse(Version matchVersion, String query, String[] fields,
    * Parses a query, searching on the fields specified.
    * Use this if you need to specify certain fields as required,
    * and others as prohibited.
-   * <p><pre>
+   * <p>
    * Usage:
+   * <pre class="prettyprint">
    * <code>
    * String[] query = {"query1", "query2", "query3"};
    * String[] fields = {"filename", "contents", "description"};
diff --git a/lucene/dev/trunk/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/PathQueryNode.java b/lucene/dev/trunk/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/PathQueryNode.java
index 749c6400..297ea828 100644
--- a/lucene/dev/trunk/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/PathQueryNode.java
+++ b/lucene/dev/trunk/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/PathQueryNode.java
@@ -31,7 +31,7 @@
  * <p>
  * Example how the text parser creates these objects:
  * </p>
- * <pre>
+ * <pre class="prettyprint">
  * List values = ArrayList(); 
  * values.add(new PathQueryNode.QueryText("company", 1, 7)); 
  * values.add(new PathQueryNode.QueryText("USA", 9, 12)); 
diff --git a/lucene/dev/trunk/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/QueryParserUtil.java b/lucene/dev/trunk/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/QueryParserUtil.java
index a7318f47..b9a7fe60 100644
--- a/lucene/dev/trunk/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/QueryParserUtil.java
+++ b/lucene/dev/trunk/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/QueryParserUtil.java
@@ -35,9 +35,9 @@
    * If x fields are specified, this effectively constructs:
    * 
    * <pre>
-   * &lt;code&gt;
+   * <code>
    * (field1:query1) (field2:query2) (field3:query3)...(fieldx:queryx)
-   * &lt;/code&gt;
+   * </code>
    * </pre>
    * 
    * @param queries
@@ -75,23 +75,23 @@ public static Query parse(String[] queries, String[] fields, Analyzer analyzer)
    * specify certain fields as required, and others as prohibited.
    * <p>
    * 
-   * <pre>
    * Usage:
-   * &lt;code&gt;
+   * <pre class="prettyprint">
+   * <code>
    * String[] fields = {&quot;filename&quot;, &quot;contents&quot;, &quot;description&quot;};
    * BooleanClause.Occur[] flags = {BooleanClause.Occur.SHOULD,
    *                BooleanClause.Occur.MUST,
    *                BooleanClause.Occur.MUST_NOT};
    * MultiFieldQueryParser.parse(&quot;query&quot;, fields, flags, analyzer);
-   * &lt;/code&gt;
+   * </code>
    * </pre>
    *<p>
    * The code above would construct a query:
    * 
    * <pre>
-   * &lt;code&gt;
+   * <code>
    * (filename:query) +(contents:query) -(description:query)
-   * &lt;/code&gt;
+   * </code>
    * </pre>
    * 
    * @param query
@@ -131,24 +131,24 @@ public static Query parse(String query, String[] fields,
    * specify certain fields as required, and others as prohibited.
    * <p>
    * 
-   * <pre>
    * Usage:
-   * &lt;code&gt;
+   * <pre class="prettyprint">
+   * <code>
    * String[] query = {&quot;query1&quot;, &quot;query2&quot;, &quot;query3&quot;};
    * String[] fields = {&quot;filename&quot;, &quot;contents&quot;, &quot;description&quot;};
    * BooleanClause.Occur[] flags = {BooleanClause.Occur.SHOULD,
    *                BooleanClause.Occur.MUST,
    *                BooleanClause.Occur.MUST_NOT};
    * MultiFieldQueryParser.parse(query, fields, flags, analyzer);
-   * &lt;/code&gt;
+   * </code>
    * </pre>
    *<p>
    * The code above would construct a query:
    * 
    * <pre>
-   * &lt;code&gt;
+   * <code>
    * (filename:query1) +(contents:query2) -(description:query3)
-   * &lt;/code&gt;
+   * </code>
    * </pre>
    * 
    * @param queries
diff --git a/lucene/dev/trunk/lucene/suggest/src/java/org/apache/lucene/search/spell/SpellChecker.java b/lucene/dev/trunk/lucene/suggest/src/java/org/apache/lucene/search/spell/SpellChecker.java
index e0c7702b..476b1601 100644
--- a/lucene/dev/trunk/lucene/suggest/src/java/org/apache/lucene/search/spell/SpellChecker.java
+++ b/lucene/dev/trunk/lucene/suggest/src/java/org/apache/lucene/search/spell/SpellChecker.java
@@ -58,7 +58,7 @@
  *
  * <p>Example Usage:
  * 
- * <pre>
+ * <pre class="prettyprint">
  *  SpellChecker spellchecker = new SpellChecker(spellIndexDirectory);
  *  // To index a field of a user index:
  *  spellchecker.indexDictionary(new LuceneDictionary(my_lucene_reader, a_field));
