diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/SubsystemExportServiceHeader.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/SubsystemExportServiceHeader.java
index 616a0d19..96aff3eb 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/SubsystemExportServiceHeader.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/SubsystemExportServiceHeader.java
@@ -25,10 +25,15 @@
 import java.util.regex.Pattern;
 
 import org.osgi.framework.Constants;
+import org.osgi.framework.Filter;
+import org.osgi.framework.FrameworkUtil;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.namespace.service.ServiceNamespace;
+import org.osgi.resource.Capability;
 import org.osgi.resource.Resource;
 import org.osgi.service.subsystem.SubsystemConstants;
 
-public class SubsystemExportServiceHeader implements CapabilityHeader<SubsystemExportServiceHeader.Clause> {
+public class SubsystemExportServiceHeader implements Header<SubsystemExportServiceHeader.Clause> {
 	public static class Clause implements org.apache.aries.subsystem.core.archive.Clause {
 		public static final String DIRECTIVE_FILTER = Constants.FILTER_DIRECTIVE;
 		
@@ -116,8 +121,17 @@ public String getPath() {
 			return path;
 		}
 		
-		public SubsystemExportServiceCapability toCapability(Resource resource) {
-			return new SubsystemExportServiceCapability(this, resource);
+		public List<Capability> toCapabilities(Resource resource) throws InvalidSyntaxException {
+			List<Capability> capabilities = resource.getCapabilities(ServiceNamespace.SERVICE_NAMESPACE);
+			if (capabilities.isEmpty())
+				return capabilities;
+			Filter filter = computeFilter();
+			ArrayList<Capability> result = new ArrayList<Capability>(capabilities.size());
+			for (Capability capability : capabilities)
+				if (filter.matches(capability.getAttributes()))
+					result.add(capability);
+			result.trimToSize();
+			return result;
 		}
 		
 		@Override
@@ -129,6 +143,23 @@ public String toString() {
 			}
 			return builder.toString();
 		}
+		
+		private Filter computeFilter() throws InvalidSyntaxException {
+			return FrameworkUtil.createFilter(computeFilterString());
+		}
+		
+		private String computeFilterString() {
+			Directive directive = getDirective(DIRECTIVE_FILTER);
+			return new StringBuilder()
+					.append("(&(")
+					.append(ServiceNamespace.CAPABILITY_OBJECTCLASS_ATTRIBUTE)
+					.append('=')
+					.append(path)
+					.append(')')
+					.append(directive == null ? "" : directive.getValue())
+					.append(')')
+					.toString();
+		}
 	}
 	
 	public static final String NAME = SubsystemConstants.SUBSYSTEM_EXPORTSERVICE;
@@ -160,11 +191,10 @@ public String getValue() {
 		return toString();
 	}
 	
-	@Override
-	public List<SubsystemExportServiceCapability> toCapabilities(Resource resource) {
-		List<SubsystemExportServiceCapability> result = new ArrayList<SubsystemExportServiceCapability>();
+	public List<Capability> toCapabilities(Resource resource) throws InvalidSyntaxException {
+		List<Capability> result = new ArrayList<Capability>();
 		for (Clause clause : clauses)
-			result.add(clause.toCapability(resource));
+			result.addAll(clause.toCapabilities(resource));
 		return result;
 	}
 	
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/SubsystemImportServiceHeader.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/SubsystemImportServiceHeader.java
index ff3cdc75..73f96528 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/SubsystemImportServiceHeader.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/SubsystemImportServiceHeader.java
@@ -20,11 +20,13 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import org.osgi.framework.Constants;
+import org.osgi.resource.Requirement;
 import org.osgi.resource.Resource;
 import org.osgi.service.subsystem.SubsystemConstants;
 
@@ -62,6 +64,12 @@ public Clause(String clause) {
 			fillInDefaults(parameters);
 		}
 		
+		public Clause(Requirement requirement) {
+			path = requirement.getNamespace();
+			for (Entry<String, String> directive : requirement.getDirectives().entrySet())
+				parameters.put(directive.getKey(), DirectiveFactory.createDirective(directive.getKey(), directive.getValue()));
+		}
+		
 		@Override
 		public Attribute getAttribute(String name) {
 			Parameter result = parameters.get(name);
@@ -104,10 +112,6 @@ public Directive getDirective(String name) {
 			return directives;
 		}
 		
-		public String getObjectClass() {
-			return path;
-		}
-
 		@Override
 		public Parameter getParameter(String name) {
 			return parameters.get(name);
@@ -143,14 +147,24 @@ public String toString() {
 	// TODO Subsystem-ImportService currently does not have its own grammar, but it's similar to Require-Capability.
 	private static final Pattern PATTERN = Pattern.compile('(' + Grammar.REQUIREMENT + ")(?=,|\\z)");
 	
-	private final Set<Clause> clauses = new HashSet<Clause>();
-	
-	public SubsystemImportServiceHeader(String value) {
-		Matcher matcher = PATTERN.matcher(value);
+	private static Collection<Clause> processHeader(String header) {
+		Matcher matcher = PATTERN.matcher(header);
+		Set<Clause> clauses = new HashSet<Clause>();
 		while (matcher.find())
 			clauses.add(new Clause(matcher.group()));
+		return clauses;
+	}
+	
+	private final Set<Clause> clauses;
+	
+	public SubsystemImportServiceHeader(String value) {
+		this(processHeader(value));
+	}
+	
+	public SubsystemImportServiceHeader(Collection<Clause> clauses) {
 		if (clauses.isEmpty())
 			throw new IllegalArgumentException("A " + NAME + " header must have at least one clause");
+		this.clauses = new HashSet<Clause>(clauses);
 	}
 	
 	@Override
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/SubsystemImportServiceRequirement.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/SubsystemImportServiceRequirement.java
index 173917fd..2950c48e 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/SubsystemImportServiceRequirement.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/SubsystemImportServiceRequirement.java
@@ -18,7 +18,6 @@
 import java.util.Map;
 
 import org.apache.aries.subsystem.core.internal.AbstractRequirement;
-import org.osgi.framework.Constants;
 import org.osgi.resource.Namespace;
 import org.osgi.resource.Resource;
 
@@ -32,14 +31,10 @@
 	
 	public SubsystemImportServiceRequirement(
 			SubsystemImportServiceHeader.Clause clause, Resource resource) {
-		StringBuilder builder = new StringBuilder("(&(")
-				.append(Constants.OBJECTCLASS).append('=')
-				.append(clause.getObjectClass()).append(')');
 		Directive filter = clause
 				.getDirective(SubsystemImportServiceHeader.Clause.DIRECTIVE_FILTER);
 		if (filter != null)
-			builder.append(filter.getValue());
-		directives.put(DIRECTIVE_FILTER, builder.append(')').toString());
+			directives.put(DIRECTIVE_FILTER, filter.getValue());
 		this.resource = resource;
 	}
 
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/Activator.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/Activator.java
index cf24b2f0..f2ea5954 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/Activator.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/Activator.java
@@ -22,6 +22,7 @@
 import java.util.HashSet;
 import java.util.Hashtable;
 
+import org.apache.aries.application.modelling.ModelledResourceManager;
 import org.eclipse.equinox.region.RegionDigraph;
 import org.osgi.framework.BundleActivator;
 import org.osgi.framework.BundleContext;
@@ -66,6 +67,7 @@ private static synchronized void checkInstance() {
 	
 	private BundleContext bundleContext;
 	private volatile Coordinator coordinator;
+	private volatile ModelledResourceManager modelledResourceManager;
 	private volatile SubsystemServiceRegistrar registrar;
 	private volatile RegionDigraph regionDigraph;
 	private volatile Resolver resolver;
@@ -84,6 +86,10 @@ public Coordinator getCoordinator() {
 		return coordinator;
 	}
 	
+	public ModelledResourceManager getModelledResourceManager() {
+		return modelledResourceManager;
+	}
+	
 	public RegionDigraph getRegionDigraph() {
 		return regionDigraph;
 	}
@@ -196,13 +202,16 @@ private String generateServiceFilterString() {
 				.append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
 				.append(Resolver.class.getName()).append(")(")
 				.append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
-				.append(Repository.class.getName()).append("))").toString();
+				.append(Repository.class.getName()).append(")(")
+				.append(org.osgi.framework.Constants.OBJECTCLASS).append('=')
+				.append(ModelledResourceManager.class.getName()).append("))").toString();
 	}
 	
 	private boolean hasRequiredServices() {
 		return coordinator != null &&
 				regionDigraph != null &&
-				resolver != null;
+				resolver != null &&
+				modelledResourceManager != null;
 	}
 	
 	private boolean isActive() {
@@ -240,6 +249,12 @@ else if (service instanceof Resolver) {
 				activate();
 			}
 		}
+		else if (service instanceof ModelledResourceManager) {
+			if (modelledResourceManager == null) {
+				modelledResourceManager = (ModelledResourceManager)service;
+				activate();
+			}
+		}
 		else
 			repositories.add((Repository)service);
 		return service;
@@ -276,6 +291,14 @@ else if (service instanceof Resolver) {
 				this.resolver = resolver;
 			}
 		}
+		else if (service instanceof ModelledResourceManager) {
+			if (service.equals(modelledResourceManager)) {
+				ModelledResourceManager modelledResourceManager = (ModelledResourceManager)findAlternateServiceFor(this.modelledResourceManager);
+				if (resolver == null)
+					deactivate();
+				this.modelledResourceManager = modelledResourceManager;
+			}
+		}
 		else
 			repositories.remove(service);
 	}
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BasicCapability.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BasicCapability.java
index e0baa80b..908f824f 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BasicCapability.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BasicCapability.java
@@ -21,6 +21,47 @@
 import org.osgi.resource.Resource;
 
 public class BasicCapability extends AbstractCapability {
+	public static class Builder {
+		private final Map<String, Object> attributes = new HashMap<String, Object>();
+		private final Map<String, String> directives = new HashMap<String, String>();
+		private Resource resource;
+		private String namespace;
+		
+		public Builder attribute(String key, Object value) {
+			attributes.put(key, value);
+			return this;
+		}
+		
+		public Builder attributes(Map<String, Object> values) {
+			attributes.putAll(values);
+			return this;
+		}
+		
+		public BasicCapability build() {
+			return new BasicCapability(namespace, attributes, directives, resource);
+		}
+		
+		public Builder directive(String key, String value) {
+			directives.put(key, value);
+			return this;
+		}
+		
+		public Builder directives(Map<String, String> values) {
+			directives.putAll(values);
+			return this;
+		}
+		
+		public Builder namespace(String value) {
+			namespace = value;
+			return this;
+		}
+		
+		public Builder resource(Resource value) {
+			resource = value;
+			return this;
+		}
+	}
+	
 	private final Map<String, Object> attributes;
 	private final Map<String, String> directives;
 	private final Resource resource;
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BasicRequirement.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BasicRequirement.java
index 7cba2683..4dc1bbea 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BasicRequirement.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BasicRequirement.java
@@ -25,6 +25,47 @@
 import org.osgi.resource.Resource;
 
 public class BasicRequirement extends AbstractRequirement {
+	public static class Builder {
+		private final Map<String, Object> attributes = new HashMap<String, Object>();
+		private final Map<String, String> directives = new HashMap<String, String>();
+		private Resource resource;
+		private String namespace;
+		
+		public Builder attribute(String key, Object value) {
+			attributes.put(key, value);
+			return this;
+		}
+		
+		public Builder attributes(Map<String, Object> values) {
+			attributes.putAll(values);
+			return this;
+		}
+		
+		public BasicRequirement build() {
+			return new BasicRequirement(namespace, attributes, directives, resource);
+		}
+		
+		public Builder directive(String key, String value) {
+			directives.put(key, value);
+			return this;
+		}
+		
+		public Builder directives(Map<String, String> values) {
+			directives.putAll(values);
+			return this;
+		}
+		
+		public Builder namespace(String value) {
+			namespace = value;
+			return this;
+		}
+		
+		public Builder resource(Resource value) {
+			resource = value;
+			return this;
+		}
+	}
+	
 	private final Map<String, Object> attributes;
 	private final Map<String, String> directives;
 	private final String namespace;
@@ -52,6 +93,23 @@ public BasicRequirement(String namespace, Filter filter) {
 		resource = null;
 	}
 
+	private BasicRequirement(String namespace, Map<String, Object> attributes, Map<String, String> directives, Resource resource) {
+		if (namespace == null)
+			throw new NullPointerException();
+		this.namespace = namespace;
+		if (attributes == null)
+			this.attributes = Collections.emptyMap();
+		else
+			this.attributes = Collections.unmodifiableMap(new HashMap<String, Object>(attributes));
+		if (directives == null)
+			this.directives = Collections.emptyMap();
+		else
+			this.directives = Collections.unmodifiableMap(new HashMap<String, String>(directives));
+		if (resource == null)
+			throw new NullPointerException();
+		this.resource = resource;
+	}
+
 	@Override
 	public Map<String, Object> getAttributes() {
 		return attributes;
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleEventHook.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleEventHook.java
index 0be49e12..6b5fc302 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleEventHook.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleEventHook.java
@@ -18,6 +18,7 @@
 import java.util.HashMap;
 import java.util.Map;
 
+import org.apache.aries.subsystem.core.internal.BundleResourceInstaller.BundleConstituent;
 import org.eclipse.equinox.region.Region;
 import org.eclipse.equinox.region.RegionDigraph;
 import org.osgi.framework.Bundle;
@@ -97,7 +98,7 @@ private void handleUninstalledEvent(BundleEvent event) {
 		BundleRevision revision = bundleToRevision.remove(bundle);
 		if (ThreadLocalSubsystem.get() != null)
 			return;
-		for (AriesSubsystem subsystem : Activator.getInstance().getSubsystems().getSubsystemsByConstituent(revision))
+		for (AriesSubsystem subsystem : Activator.getInstance().getSubsystems().getSubsystemsByConstituent(new BundleConstituent(null, revision)))
 			ResourceUninstaller.newInstance(revision, subsystem).uninstall();
 	}
 }
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResource.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResource.java
index 0362f327..49426805 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResource.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResource.java
@@ -17,8 +17,15 @@
 import java.io.InputStream;
 import java.net.URL;
 import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
 import java.util.List;
 
+import org.apache.aries.application.modelling.ExportedService;
+import org.apache.aries.application.modelling.ImportedService;
+import org.apache.aries.application.modelling.ModelledResource;
+import org.apache.aries.application.modelling.ModelledResourceManager;
+import org.apache.aries.application.modelling.ModellerException;
 import org.apache.aries.subsystem.core.archive.BundleManifest;
 import org.apache.aries.subsystem.core.archive.BundleSymbolicNameHeader;
 import org.apache.aries.subsystem.core.archive.BundleVersionHeader;
@@ -35,18 +42,15 @@
 import org.apache.aries.util.filesystem.ICloseableDirectory;
 import org.apache.aries.util.filesystem.IDirectory;
 import org.apache.aries.util.io.IOUtils;
+import org.osgi.namespace.service.ServiceNamespace;
 import org.osgi.resource.Capability;
+import org.osgi.resource.Namespace;
 import org.osgi.resource.Requirement;
 import org.osgi.resource.Resource;
 import org.osgi.service.repository.RepositoryContent;
+import org.osgi.service.subsystem.SubsystemException;
 
 public class BundleResource implements Resource, RepositoryContent {
-	public static BundleResource newInstance(URL content) throws IOException {
-		BundleResource result = new BundleResource(content);
-		result.capabilities.add(new OsgiIdentityCapability(result, result.manifest));
-		return result;
-	}
-	
 	private static BundleManifest computeManifest(IDirectory directory) {
 		return new BundleManifest(org.apache.aries.util.manifest.BundleManifest
 				.fromBundle(directory)
@@ -58,15 +62,19 @@ private static BundleManifest computeManifest(IDirectory directory) {
 	private final BundleManifest manifest;
 	private final List<Requirement> requirements = new ArrayList<Requirement>();
 	
-	private BundleResource(URL content) throws IOException {
+	public BundleResource(URL content) throws IOException, ModellerException {
 		this.content = content;
 		InputStream is = content.openStream();
 		try {
 			ICloseableDirectory directory = FileSystem.getFSRoot(is);
 			try {
 				manifest = computeManifest(directory);
-				computeRequirements(directory);
-				computeCapabilities();
+				// TODO Could use ModelledResourceManager.getServiceElements
+				// instead. Only the service dependency info is being used
+				// right now.
+				ModelledResource resource = getModelledResourceManager().getModelledResource(directory);
+				computeRequirements(resource);
+				computeCapabilities(resource);
 			}
 			finally {
 				IOUtils.close(directory);
@@ -80,16 +88,19 @@ private BundleResource(URL content) throws IOException {
 		}
 	}
 	
-	private BundleResource(String content) throws IOException {
+	public BundleResource(String content) throws IOException, ModellerException {
 		this(new URL(content));
 	}
 
 	public List<Capability> getCapabilities(String namespace) {
+		if (namespace == null)
+			return Collections.unmodifiableList(capabilities);
 		ArrayList<Capability> result = new ArrayList<Capability>(capabilities.size());
 		for (Capability capability : capabilities)
-			if (namespace == null || namespace.equals(capability.getNamespace()))
+			if (namespace.equals(capability.getNamespace()))
 				result.add(capability);
-		return result;
+		result.trimToSize();
+		return Collections.unmodifiableList(result);
 	}
 	
 	@Override
@@ -97,17 +108,20 @@ public InputStream getContent() {
 		try {
 			return content.openStream();
 		}
-		catch (Exception e) {
-			throw new RuntimeException(e);
+		catch (IOException e) {
+			throw new SubsystemException(e);
 		}
 	}
 
 	public List<Requirement> getRequirements(String namespace) {
-		ArrayList<Requirement> result = new ArrayList<Requirement>();
+		if (namespace == null)
+			return Collections.unmodifiableList(requirements);
+		ArrayList<Requirement> result = new ArrayList<Requirement>(requirements.size());
 		for (Requirement requirement : requirements)
-			if (namespace == null || namespace.equals(requirement.getNamespace()))
+			if (namespace.equals(requirement.getNamespace()))
 				result.add(requirement);
-		return result;
+		result.trimToSize();
+		return Collections.unmodifiableList(result);
 	}
 	
 	@Override
@@ -115,56 +129,101 @@ public String toString() {
         return content.toExternalForm();
     }
 	
-	private void computeCapabilities() {
-		computeExportPackageCapabilities();
-		computeProvideBundleCapability();
-		computeProvideCapabilityCapabilities();
+	private void computeCapabilities(ModelledResource resource) {
+		computeOsgiIdentityCapability();
+		computeOsgiWiringPackageCapabilities();
+		computeOsgiWiringBundleCapability();
+		computeGenericCapabilities();
+		computeOsgiServiceCapabilities(resource);
 	}
 	
-	private void computeExportPackageCapabilities() {
-		ExportPackageHeader eph = (ExportPackageHeader)manifest.getHeader(ExportPackageHeader.NAME);
-		if (eph != null)
-			capabilities.addAll(eph.toCapabilities(this));
+	private void computeGenericCapabilities() {
+		ProvideCapabilityHeader pch = (ProvideCapabilityHeader)manifest.getHeader(ProvideCapabilityHeader.NAME);
+		if (pch != null)
+			for (ProvideCapabilityHeader.Clause clause : pch.getClauses())
+				capabilities.add(new ProvideCapabilityCapability(clause, this));
 	}
 	
-	private void computeImportPackageRequirements() {
-		ImportPackageHeader iph = (ImportPackageHeader)manifest.getHeader(ImportPackageHeader.NAME);
-		if (iph != null)
-			requirements.addAll(iph.toRequirements(this));
+	private void computeGenericRequirements() {
+		RequireCapabilityHeader rch = (RequireCapabilityHeader)manifest.getHeader(RequireCapabilityHeader.NAME);
+		if (rch != null)
+			for (RequireCapabilityHeader.Clause clause : rch.getClauses())
+				requirements.add(new RequireCapabilityRequirement(clause, this));
 	}
 	
-	private void computeProvideBundleCapability() {
+	private void computeOsgiIdentityCapability() {
+		capabilities.add(new OsgiIdentityCapability(this, manifest));
+	}
+	
+	private void computeOsgiServiceCapabilities(ModelledResource resource) {
+		Collection<? extends ExportedService> services = resource.getExportedServices();
+		for (ExportedService service : services)
+			capabilities.add(new BasicCapability.Builder()
+					.namespace(ServiceNamespace.SERVICE_NAMESPACE)
+					.attribute(ServiceNamespace.CAPABILITY_OBJECTCLASS_ATTRIBUTE, new ArrayList<String>(service.getInterfaces()))
+					.attributes(service.getServiceProperties())
+					.resource(this)
+					.build());
+	}
+	
+	private void computeOsgiServiceRequirements(ModelledResource resource) {
+		Collection<? extends ImportedService> services = resource.getImportedServices();
+		for (ImportedService service : services) {
+			StringBuilder builder = new StringBuilder("(&(")
+					.append(ServiceNamespace.CAPABILITY_OBJECTCLASS_ATTRIBUTE)
+					.append('=')
+					.append(service.getInterface())
+					.append(')');
+			String filter = service.getFilter();
+			if (filter != null)
+				builder.append('(').append(filter).append(')');
+			builder.append(')');
+			requirements.add(new BasicRequirement.Builder()
+					.namespace(ServiceNamespace.SERVICE_NAMESPACE)
+					.directive(Namespace.REQUIREMENT_FILTER_DIRECTIVE, builder.toString())
+					.directive(
+							Namespace.REQUIREMENT_RESOLUTION_DIRECTIVE, 
+							service.isOptional() ? Namespace.RESOLUTION_OPTIONAL : Namespace.RESOLUTION_MANDATORY)
+					.resource(this)
+					.build());
+		}
+	}
+	
+	private void computeOsgiWiringBundleCapability() {
 		// TODO The osgi.wiring.bundle capability should not be provided for fragments. Nor should the host capability.
 		BundleSymbolicNameHeader bsnh = (BundleSymbolicNameHeader)manifest.getHeader(BundleSymbolicNameHeader.NAME);
 		BundleVersionHeader bvh = (BundleVersionHeader)manifest.getHeader(BundleVersionHeader.NAME);
 		capabilities.add(new ProvideBundleCapability(bsnh, bvh, this));
 	}
 	
-	private void computeProvideCapabilityCapabilities() {
-		ProvideCapabilityHeader pch = (ProvideCapabilityHeader)manifest.getHeader(ProvideCapabilityHeader.NAME);
-		if (pch != null)
-			for (ProvideCapabilityHeader.Clause clause : pch.getClauses())
-				capabilities.add(new ProvideCapabilityCapability(clause, this));
-	}
-	
-	private void computeRequireBundleRequirements() {
+	private void computeOsgiWiringBundleRequirements() {
 		RequireBundleHeader rbh = (RequireBundleHeader)manifest.getHeader(RequireBundleHeader.NAME);
 		if (rbh != null)
 			for (RequireBundleHeader.Clause clause : rbh.getClauses())
 				requirements.add(new RequireBundleRequirement(clause, this));
 	}
 	
-	private void computeRequireCapabilityRequirements() {
-		RequireCapabilityHeader rch = (RequireCapabilityHeader)manifest.getHeader(RequireCapabilityHeader.NAME);
-		if (rch != null)
-			for (RequireCapabilityHeader.Clause clause : rch.getClauses())
-				requirements.add(new RequireCapabilityRequirement(clause, this));
+	private void computeOsgiWiringPackageCapabilities() {
+		ExportPackageHeader eph = (ExportPackageHeader)manifest.getHeader(ExportPackageHeader.NAME);
+		if (eph != null)
+			capabilities.addAll(eph.toCapabilities(this));
+	}
+	
+	private void computeOsgiWiringPackageRequirements() {
+		ImportPackageHeader iph = (ImportPackageHeader)manifest.getHeader(ImportPackageHeader.NAME);
+		if (iph != null)
+			requirements.addAll(iph.toRequirements(this));
 	}
 	
-	private void computeRequirements(IDirectory directory) {
-		computeImportPackageRequirements();
-		computeRequireCapabilityRequirements();
-		computeRequireBundleRequirements();
+	private void computeRequirements(ModelledResource resource) {
+		computeOsgiWiringPackageRequirements();
+		computeGenericRequirements();
+		computeOsgiWiringBundleRequirements();
+		computeOsgiServiceRequirements(resource);
 		// TODO Bundle-RequiredExecutionEnvironment
 	}
+	
+	private ModelledResourceManager getModelledResourceManager() {
+		return Activator.getInstance().getModelledResourceManager();
+	}
 }
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResourceInstaller.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResourceInstaller.java
index 8b151dec..1ab7d4ed 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResourceInstaller.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResourceInstaller.java
@@ -14,11 +14,21 @@
 package org.apache.aries.subsystem.core.internal;
 
 import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
 
 import org.apache.aries.util.io.IOUtils;
 import org.osgi.framework.Bundle;
 import org.osgi.framework.BundleException;
+import org.osgi.framework.Version;
+import org.osgi.framework.wiring.BundleCapability;
+import org.osgi.framework.wiring.BundleRequirement;
 import org.osgi.framework.wiring.BundleRevision;
+import org.osgi.framework.wiring.BundleWiring;
+import org.osgi.namespace.service.ServiceNamespace;
+import org.osgi.resource.Capability;
+import org.osgi.resource.Requirement;
 import org.osgi.resource.Resource;
 import org.osgi.service.coordinator.Coordination;
 import org.osgi.service.coordinator.Participant;
@@ -26,6 +36,114 @@
 import org.osgi.service.subsystem.SubsystemException;
 
 public class BundleResourceInstaller extends ResourceInstaller {
+	/*
+	 * Maps a BundleResource to a BundleRevision for the purpose of tracking
+	 * any service requirements or capabilities. The instance is given to the
+	 * Subsystems data structure as the constituent object.
+	 * 
+	 * The resource variable is allowed to be null so this class can be used
+	 * when removing constituents from the data structure; however, note that
+	 * service capabilities and requirements will not be available.
+	 */
+	static class BundleConstituent implements BundleRevision {
+		private final Resource resource;
+		private final BundleRevision revision;
+		
+		public BundleConstituent(Resource resource, BundleRevision revision) {
+			this.resource = resource;
+			this.revision = revision;
+		}
+
+		@Override
+		public List<Capability> getCapabilities(String namespace) {
+			List<Capability> result = new ArrayList<Capability>(revision.getCapabilities(namespace));
+			if (resource != null && (namespace == null || ServiceNamespace.SERVICE_NAMESPACE.equals(namespace)))
+				for (Capability capability : resource.getCapabilities(ServiceNamespace.SERVICE_NAMESPACE))
+					result.add(new BasicCapability.Builder()
+								.namespace(capability.getNamespace())
+								.attributes(capability.getAttributes())
+								.directives(capability.getDirectives())
+								// Use the BundleRevision as the resource so it can be identified as a
+								// runtime resource within the system repository.
+								.resource(revision)
+								.build());
+			return Collections.unmodifiableList(result);
+		}
+
+		@Override
+		public List<Requirement> getRequirements(String namespace) {
+			List<Requirement> result = new ArrayList<Requirement>(revision.getRequirements(namespace));
+			if (resource != null && (namespace == null || ServiceNamespace.SERVICE_NAMESPACE.equals(namespace)))
+				for (Requirement requiremnet : resource.getRequirements(ServiceNamespace.SERVICE_NAMESPACE))
+					result.add(new BasicRequirement.Builder()
+								.namespace(requiremnet.getNamespace())
+								.attributes(requiremnet.getAttributes())
+								.directives(requiremnet.getDirectives())
+								// Use the BundleRevision as the resource so it can be identified as a
+								// runtime resource within the system repository.
+								.resource(revision)
+								.build());
+			return Collections.unmodifiableList(result);
+		}
+		
+		@Override
+		public boolean equals(Object o) {
+			if (o == this)
+				return true;
+			if (!(o instanceof BundleConstituent))
+				return false;
+			BundleConstituent that = (BundleConstituent)o;
+			return revision.equals(that.revision);
+		}
+		
+		@Override
+		public int hashCode() {
+			int result = 17;
+			result = 31 * result + revision.hashCode();
+			return result;
+		}
+
+		@Override
+		public Bundle getBundle() {
+			return revision.getBundle();
+		}
+
+		@Override
+		public String getSymbolicName() {
+			return revision.getSymbolicName();
+		}
+
+		@Override
+		public Version getVersion() {
+			return revision.getVersion();
+		}
+
+		@Override
+		public List<BundleCapability> getDeclaredCapabilities(String namespace) {
+			return revision.getDeclaredCapabilities(namespace);
+		}
+
+		@Override
+		public List<BundleRequirement> getDeclaredRequirements(String namespace) {
+			return revision.getDeclaredRequirements(namespace);
+		}
+
+		@Override
+		public int getTypes() {
+			return revision.getTypes();
+		}
+
+		@Override
+		public BundleWiring getWiring() {
+			return revision.getWiring();
+		}
+		
+		@Override
+		public String toString() {
+			return revision.toString();
+		}
+	}
+	
 	public BundleResourceInstaller(Coordination coordination, Resource resource, AriesSubsystem subsystem) {
 		super(coordination, resource, subsystem);
 	}
@@ -39,7 +157,7 @@ public Resource install() {
 			revision = installBundle();
 		}
 		addReference(revision);
-		addConstituent(revision);
+		addConstituent(new BundleConstituent(resource, revision));
 		return revision;
 	}
 	
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResourceUninstaller.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResourceUninstaller.java
index 6c59e18b..0532b0db 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResourceUninstaller.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResourceUninstaller.java
@@ -13,6 +13,7 @@
  */
 package org.apache.aries.subsystem.core.internal;
 
+import org.apache.aries.subsystem.core.internal.BundleResourceInstaller.BundleConstituent;
 import org.osgi.framework.Bundle;
 import org.osgi.framework.BundleException;
 import org.osgi.framework.wiring.BundleRevision;
@@ -30,7 +31,7 @@ public void uninstall() {
 		// acted upon. The bundle may or may not actually be a constituent.
 		// This covers the case of unscoped subsystems with shared content
 		// where the resource may not be uninstallable.
-		removeConstituent(subsystem, resource);
+		removeConstituent(subsystem, new BundleConstituent(null, (BundleRevision)resource));
 		if (!isResourceUninstallable())
 			return;
 		// If the resource is uninstallable, remove it from the "provisioned to"
@@ -39,7 +40,7 @@ public void uninstall() {
 		// the case where a dependency of the subsystem being acted upon was 
 		// provisioned to another subsystem but is not content of the other
 		// subsystem.
-		removeConstituent(provisionTo, resource);
+		removeConstituent(provisionTo, new BundleConstituent(null, (BundleRevision)resource));
 		if (isBundleUninstallable())
 			uninstallBundle();
 	}
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/InstallAction.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/InstallAction.java
index 951e2c26..3da689fc 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/InstallAction.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/InstallAction.java
@@ -20,6 +20,7 @@
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
+import org.apache.aries.application.modelling.ModellerException;
 import org.osgi.framework.BundleException;
 import org.osgi.framework.InvalidSyntaxException;
 import org.osgi.service.coordinator.Coordination;
@@ -123,7 +124,7 @@ private AriesSubsystem createSubsystem(SubsystemResource resource) throws URISyn
 		
 	}
 	
-	private SubsystemResource createSubsystemResource(String location, InputStream content, AriesSubsystem parent) throws URISyntaxException, IOException, ResolutionException, UnsupportedOperationException, BundleException, InvalidSyntaxException {
+	private SubsystemResource createSubsystemResource(String location, InputStream content, AriesSubsystem parent) throws URISyntaxException, IOException, ResolutionException, BundleException, InvalidSyntaxException, ModellerException {
 		final SubsystemResource result = new SubsystemResource(location, content, parent);
 		return result;
 	}
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/RawSubsystemResource.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/RawSubsystemResource.java
index 24256f94..d959876c 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/RawSubsystemResource.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/RawSubsystemResource.java
@@ -26,12 +26,14 @@
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import org.apache.aries.application.modelling.ModellerException;
 import org.apache.aries.subsystem.core.archive.DeploymentManifest;
 import org.apache.aries.subsystem.core.archive.Header;
 import org.apache.aries.subsystem.core.archive.ImportPackageHeader;
 import org.apache.aries.subsystem.core.archive.RequireBundleHeader;
 import org.apache.aries.subsystem.core.archive.RequireCapabilityHeader;
 import org.apache.aries.subsystem.core.archive.SubsystemContentHeader;
+import org.apache.aries.subsystem.core.archive.SubsystemImportServiceHeader;
 import org.apache.aries.subsystem.core.archive.SubsystemManifest;
 import org.apache.aries.subsystem.core.archive.SubsystemSymbolicNameHeader;
 import org.apache.aries.subsystem.core.archive.SubsystemTypeHeader;
@@ -44,6 +46,7 @@
 import org.osgi.framework.Version;
 import org.osgi.framework.namespace.BundleNamespace;
 import org.osgi.framework.namespace.PackageNamespace;
+import org.osgi.namespace.service.ServiceNamespace;
 import org.osgi.resource.Capability;
 import org.osgi.resource.Requirement;
 import org.osgi.resource.Resource;
@@ -97,7 +100,7 @@ private static String convertFileNameToLocation(String fileName) {
 	private final Collection<Resource> resources;
 	private final SubsystemManifest subsystemManifest;
 	
-	public RawSubsystemResource(String location, InputStream content) throws URISyntaxException, IOException, UnsupportedOperationException, ResolutionException {
+	public RawSubsystemResource(String location, InputStream content) throws URISyntaxException, IOException, ResolutionException, ModellerException {
 		this.location = new Location(location);
 		IDirectory idir;
 		if (content == null)
@@ -213,10 +216,11 @@ private void addRequireCapabilityHeader(SubsystemManifest.Builder builder) {
 	}
 	
 	private void addSubsystemContentHeader(SubsystemManifest.Builder builder, SubsystemManifest manifest) {
-		SubsystemContentHeader header = computeSubsystemContentHeader(manifest);
-		if (header == null)
-			return;
-		addHeader(builder, header);
+		addHeader(builder, computeSubsystemContentHeader(manifest));
+	}
+	
+	private void addSubsystemImportServiceHeader(SubsystemManifest.Builder builder) {
+		addHeader(builder, computeSubsystemImportServiceHeader());
 	}
 	
 	private void addSubsystemSymbolicNameHeader(SubsystemManifest.Builder builder, SubsystemManifest manifest) {
@@ -312,7 +316,7 @@ private RequireCapabilityHeader computeRequireCapabilityHeader() {
 		return new DependencyCalculator(resources).calculateDependencies();
 	}
 	
-	private Collection<Resource> computeResources(IDirectory directory) throws IOException, URISyntaxException, ResolutionException {
+	private Collection<Resource> computeResources(IDirectory directory) throws IOException, URISyntaxException, ResolutionException, ModellerException {
 		List<IFile> files = directory.listFiles();
 		if (files.isEmpty())
 			return Collections.emptyList();
@@ -320,7 +324,7 @@ private RequireCapabilityHeader computeRequireCapabilityHeader() {
 		for (IFile file : directory.listFiles()) {
 			String name = file.getName();
 			if (name.endsWith(".jar"))
-				result.add(BundleResource.newInstance(file.toURL()));
+				result.add(new BundleResource(file.toURL()));
 			else if (name.endsWith(".esa"))
 				result.add(new RawSubsystemResource(convertFileToLocation(file), file.open()));
 		}
@@ -335,6 +339,21 @@ private SubsystemContentHeader computeSubsystemContentHeader(SubsystemManifest m
 		return header;
 	}
 	
+	private SubsystemImportServiceHeader computeSubsystemImportServiceHeader() {
+		if (requirements.isEmpty())
+			return null;
+		ArrayList<SubsystemImportServiceHeader.Clause> clauses = new ArrayList<SubsystemImportServiceHeader.Clause>(requirements.size());
+		for (Requirement requirement : requirements) {
+			if (!ServiceNamespace.SERVICE_NAMESPACE.equals(requirement.getNamespace()))
+				continue;
+			clauses.add(new SubsystemImportServiceHeader.Clause(requirement));
+		}
+		if (clauses.isEmpty())
+			return null;
+		clauses.trimToSize();
+		return new SubsystemImportServiceHeader(clauses);
+	}
+	
 	private SubsystemManifest computeSubsystemManifestAfterRequirements(SubsystemManifest manifest) {
 		if (isComposite(manifest))
 			return manifest;
@@ -342,6 +361,7 @@ private SubsystemManifest computeSubsystemManifestAfterRequirements(SubsystemMan
 		addImportPackageHeader(builder);
 		addRequireBundleHeader(builder);
 		addRequireCapabilityHeader(builder);
+		addSubsystemImportServiceHeader(builder);
 		return builder.build();
 	}
 	
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SharingPolicyValidator.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SharingPolicyValidator.java
index 28eb66a6..b6ed96d3 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SharingPolicyValidator.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SharingPolicyValidator.java
@@ -20,6 +20,7 @@
 import org.eclipse.equinox.region.Region;
 import org.eclipse.equinox.region.RegionDigraphVisitor;
 import org.eclipse.equinox.region.RegionFilter;
+import org.osgi.namespace.service.ServiceNamespace;
 import org.osgi.resource.Capability;
 
 public class SharingPolicyValidator {
@@ -64,7 +65,13 @@ public SharingPolicyValidator(Region from, Region to) {
 	}
 	
 	public boolean isValid(Capability capability) {
-		Visitor visitor = new Visitor(capability.getNamespace(), capability.getAttributes());
+		// The osgi.service namespace must be translated into the
+		// org.eclipse.equinox.allow.service namespace in order to validate
+		// service sharing policies.
+		Visitor visitor = new Visitor(
+				ServiceNamespace.SERVICE_NAMESPACE.equals(capability
+						.getNamespace()) ? RegionFilter.VISIBLE_SERVICE_NAMESPACE
+						: capability.getNamespace(), capability.getAttributes());
 		to.visitSubgraph(visitor);
 		return visitor.contains(from);
 	}
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemResource.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemResource.java
index c5974036..012d4dec 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemResource.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemResource.java
@@ -24,6 +24,7 @@
 import java.util.List;
 import java.util.Map;
 
+import org.apache.aries.application.modelling.ModellerException;
 import org.apache.aries.subsystem.core.archive.Attribute;
 import org.apache.aries.subsystem.core.archive.DeployedContentHeader;
 import org.apache.aries.subsystem.core.archive.DeploymentManifest;
@@ -36,6 +37,7 @@
 import org.apache.aries.subsystem.core.archive.RequireCapabilityHeader;
 import org.apache.aries.subsystem.core.archive.RequireCapabilityRequirement;
 import org.apache.aries.subsystem.core.archive.SubsystemContentHeader;
+import org.apache.aries.subsystem.core.archive.SubsystemExportServiceHeader;
 import org.apache.aries.subsystem.core.archive.SubsystemImportServiceHeader;
 import org.apache.aries.subsystem.core.archive.SubsystemImportServiceRequirement;
 import org.apache.aries.subsystem.core.archive.SubsystemManifest;
@@ -72,6 +74,7 @@
 public class SubsystemResource implements Resource {
 	private Region region;
 	
+	private final List<Capability> capabilities;
 	private final DeploymentManifest deploymentManifest;
 	private final long id;
 	private final Collection<Resource> installableContent = new HashSet<Resource>();
@@ -85,7 +88,7 @@
 	private final Collection<Resource> sharedContent = new HashSet<Resource>();
 	private final Collection<Resource> sharedDependencies = new HashSet<Resource>();
 	
-	public SubsystemResource(String location, InputStream content, AriesSubsystem parent) throws URISyntaxException, IOException, ResolutionException, UnsupportedOperationException, BundleException, InvalidSyntaxException {
+	public SubsystemResource(String location, InputStream content, AriesSubsystem parent) throws URISyntaxException, IOException, ResolutionException, BundleException, InvalidSyntaxException, ModellerException {
 		this(new RawSubsystemResource(location, content), parent);
 	}
 	
@@ -95,6 +98,7 @@ public SubsystemResource(RawSubsystemResource resource, AriesSubsystem parent) t
 		id = SubsystemIdentifier.getNextId();
 		preferredProviderRepository = new PreferredProviderRepository(this);
 		computeContentResources(resource.getDeploymentManifest());
+		capabilities = computeCapabilities();
 		computeDependencies(resource.getDeploymentManifest());
 		deploymentManifest = computeDeploymentManifest();
 	}
@@ -110,6 +114,7 @@ public SubsystemResource(IDirectory directory) throws IOException, URISyntaxExce
 		deploymentManifest = resource.getDeploymentManifest();
 		id = Long.parseLong(deploymentManifest.getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_ID).getValue());
 		computeContentResources(deploymentManifest);
+		capabilities = computeCapabilities();
 		computeDependencies(deploymentManifest);
 	}
 	
@@ -125,16 +130,35 @@ public boolean equals(Object o) {
 
 	@Override
 	public List<Capability> getCapabilities(String namespace) {
+		return Collections.unmodifiableList(capabilities);
+	}
+	
+	private List<Capability> computeCapabilities() throws InvalidSyntaxException {
+		List<Capability> capabilities = new ArrayList<Capability>();
 		if (isScoped())
-			return resource.getCapabilities(namespace);
-		else {
-			ArrayList<Capability> result = new ArrayList<Capability>();
-			result.addAll(resource.getCapabilities(namespace));
+			computeScopedCapabilities(capabilities);
+		else
+			computeUnscopedCapabilities(capabilities);
+		return capabilities;
+	}
+	
+	private void computeUnscopedCapabilities(List<Capability> capabilities) {
+		capabilities.addAll(resource.getCapabilities(null));
 			for (Resource r : getContentResources())
-				result.addAll(r.getCapabilities(namespace));
-			result.trimToSize();
-			return result;
+			capabilities.addAll(r.getCapabilities(null));
+	}
+	
+	private void computeScopedCapabilities(List<Capability> capabilities) throws InvalidSyntaxException {
+		capabilities.addAll(resource.getCapabilities(null));
+		computeOsgiServiceCapabilities(capabilities);
 		}
+	
+	public void computeOsgiServiceCapabilities(List<Capability> capabilities) throws InvalidSyntaxException {
+		SubsystemExportServiceHeader header = getSubsystemManifest().getSubsystemExportServiceHeader();
+		if (header == null)
+			return;
+		for (Resource resource : getContentResources())
+			capabilities.addAll(header.toCapabilities(resource));
 	}
 	
 	public DeploymentManifest getDeploymentManifest() {
@@ -170,10 +194,10 @@ public String getLocation() {
 			Header<?> header = getDeploymentManifest().getHeaders().get(DeploymentManifest.ARIESSUBSYSTEM_PARENTS);
 			if (header == null)
 				return Collections.emptyList();
-			String[] parents = header.getValue().split(",");
-			Collection<AriesSubsystem> result = new ArrayList<AriesSubsystem>(parents.length);
-			for (String parent : parents)
-				result.add(Activator.getInstance().getSubsystems().getSubsystemById(Long.valueOf(parent)));
+			String[] parentIds = header.getValue().split(",");
+			Collection<AriesSubsystem> result = new ArrayList<AriesSubsystem>(parentIds.length);
+			for (String parentId : parentIds)
+				result.add(Activator.getInstance().getSubsystems().getSubsystemById(Long.valueOf(parentId)));
 			return result;
 		}
 		return Collections.singleton(parent);
diff --git a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/ServiceDependencyTest.java b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/ServiceDependencyTest.java
index e69de29b..7e9bb2eb 100644
--- a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/ServiceDependencyTest.java
+++ b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/ServiceDependencyTest.java
@@ -0,0 +1,346 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.aries.subsystem.itests;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.aries.subsystem.itests.util.GenericMetadataWrapper;
+import org.apache.aries.unittest.fixture.ArchiveFixture;
+import org.apache.aries.util.manifest.ManifestHeaderProcessor;
+import org.apache.aries.util.manifest.ManifestHeaderProcessor.GenericMetadata;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.Version;
+import org.osgi.service.subsystem.Subsystem;
+import org.osgi.service.subsystem.SubsystemConstants;
+import org.osgi.service.subsystem.SubsystemException;
+
+@RunWith(JUnit4TestRunner.class)
+public class ServiceDependencyTest extends SubsystemTest {
+	/*
+	 * Subsystem-SymbolicName: application.a.esa
+	 * Subsystem-Content: bundle.a.jar
+	 */
+	private static final String APPLICATION_A = "application.a.esa";
+	/*
+	 * Subsystem-SymbolicName: application.b.esa
+	 * Subsystem-Content: bundle.b.jar
+	 */
+	private static final String APPLICATION_B = "application.b.esa";
+	/*
+	 * Subsystem-SymbolicName: application.b.esa
+	 * Subsystem-Content: bundle.a.jar, bundle.b.jar
+	 */
+	private static final String APPLICATION_C = "application.c.esa";
+	/*
+	 * Subsystem-SymbolicName: application.d.esa
+	 * Subsystem-Content: bundle.a.jar, composite.a.esa
+	 */
+	private static final String APPLICATION_D = "application.d.esa";
+	/*
+	 * Subsystem-SymbolicName: composite.a.esa
+	 * Subsystem-Content: bundle.b.jar
+	 */
+	private static final String COMPOSITE_A = "composite.a.esa";
+	/*
+	 * Bundle-SymbolicName: bundle.a.jar
+	 * Bundle-Blueprint: OSGI-INF/blueprint/*.xml
+	 * 
+	 * <blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0">
+	 * 		<reference interface="bundle.b"/>
+	 * 		<reference interface="bundle.b1" filter="(active=true)"/>
+	 * 		<service interface="bundle.a" ref="bundle.a"/>
+	 * </blueprint>
+	 */
+	private static final String BUNDLE_A = "bundle.a.jar";
+	/*
+	 * Bundle-SymbolicName: bundle.b.jar
+	 * Bundle-Blueprint: OSGI-INF/blueprint/*.xml
+	 * 
+	 * <blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0">
+	 * 		<reference interface="bundle.a" availability="optional"/>
+	 * 		<service ref="bundle.b">
+	 * 			<interfaces>
+	 * 				<value>bundle.b</value>
+	 * 				<value>bundle.b1</value>
+	 * 			</interfaces>
+	 * 			<service-properties>
+	 * 				<entry key="active">
+	 * 					<value type="java.lang.Boolean">true</value>
+	 * 				</entry>
+	 * 				<entry key="mode" value="shared"/>
+	 * 			</service-properties>
+	 * 		</service>
+	 * </blueprint>
+	 */
+	private static final String BUNDLE_B = "bundle.b.jar";
+	
+	private static void createApplicationA() throws IOException {
+		createApplicationAManifest();
+		createSubsystem(APPLICATION_A, BUNDLE_A);
+	}
+	
+	private static void createApplicationB() throws IOException {
+		createApplicationBManifest();
+		createSubsystem(APPLICATION_B, BUNDLE_B);
+	}
+	
+	private static void createApplicationC() throws IOException {
+		createApplicationCManifest();
+		createSubsystem(APPLICATION_C, BUNDLE_A, BUNDLE_B);
+	}
+	
+	private static void createApplicationD() throws IOException {
+		createApplicationDManifest();
+		createSubsystem(APPLICATION_D, BUNDLE_A, COMPOSITE_A);
+	}
+	
+	private static void createApplicationAManifest() throws IOException {
+		createBasicApplicationManifest(APPLICATION_A);
+	}
+	
+	private static void createApplicationBManifest() throws IOException {
+		createBasicApplicationManifest(APPLICATION_B);
+	}
+	
+	private static void createApplicationCManifest() throws IOException {
+		createBasicApplicationManifest(APPLICATION_C);
+	}
+	
+	private static void createApplicationDManifest() throws IOException {
+		createBasicApplicationManifest(APPLICATION_D);
+	}
+	
+	private static void createBasicApplicationManifest(String symbolicName) throws IOException {
+		createBasicSubsystemManifest(symbolicName, null, null);
+	}
+	
+	private static void createBasicSubsystemManifest(String symbolicName, Version version, String type) throws IOException {
+		Map<String, String> attributes = new HashMap<String, String>();
+		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, symbolicName);
+		if (version != null)
+			attributes.put(SubsystemConstants.SUBSYSTEM_VERSION, version.toString());
+		if (type != null)
+			attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, type);
+		createManifest(symbolicName + ".mf", attributes);
+	}
+	
+	private static void createBundle(String symbolicName, String blueprintXml)
+			throws IOException {
+		write(symbolicName,
+				ArchiveFixture.newJar().manifest().symbolicName(symbolicName)
+						.end().file("OSGI-INF/blueprint/blueprint.xml", blueprintXml));
+	}
+	
+	private static void createBundleA() throws IOException {
+		createBundle(
+				BUNDLE_A, 
+				new StringBuilder()
+					.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>")
+					.append("<blueprint ")
+					.append("xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\">")
+					.append("<reference ")
+					.append("interface=\"bundle.b\"")
+					.append("/>")
+					.append("<service ")
+					.append("interface=\"bundle.a\" ")
+					.append("ref=\"bundle.a\"")
+					.append("/>")
+					.append("</blueprint>")
+					.toString());
+	}
+	
+	private static void createBundleB() throws IOException {
+		createBundle(
+				BUNDLE_B, 
+				new StringBuilder()
+					.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>")
+					.append("<blueprint ")
+					.append("xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\">")
+					.append("<reference ")
+					.append("interface=\"bundle.a\" ")
+					.append("availability=\"optional\"")
+					.append("/>")
+					.append("<service ref=\"bundle.b\">")
+					.append("<interfaces>")
+					.append("<value>bundle.b</value>")
+					.append("<value>bundle.b1</value>")
+					.append("</interfaces>")
+					.append("<service-properties>")
+					.append("<entry key=\"active\">")
+					.append("<value type=\"java.lang.Boolean\">true</value>")
+					.append("</entry>")
+					.append("<entry key=\"mode\" value=\"shared\"/>")
+					.append("</service-properties>")
+					.append("</service>")
+					.append("</blueprint>")
+					.toString());
+	}
+	
+	private static void createCompositeA() throws IOException {
+		createCompositeAManifest();
+		createSubsystem(COMPOSITE_A, BUNDLE_B);
+	}
+	
+	private static void createCompositeAManifest() throws IOException {
+		Map<String, String> attributes = new HashMap<String, String>();
+		attributes.put(SubsystemConstants.SUBSYSTEM_SYMBOLICNAME, COMPOSITE_A);
+		attributes.put(SubsystemConstants.SUBSYSTEM_TYPE, SubsystemConstants.SUBSYSTEM_TYPE_COMPOSITE);
+		attributes.put(
+				SubsystemConstants.SUBSYSTEM_EXPORTSERVICE, 
+				"bundle.b;filter:=\"(&(active=true)(mode=shared))\"");
+		createManifest(COMPOSITE_A + ".mf", attributes);
+	}
+	
+	private static boolean createdTestFiles;
+	@Before
+	public static void createTestFiles() throws Exception {
+		if (createdTestFiles)
+			return;
+		createBundleA();
+		createBundleB();
+		createApplicationA();
+		createApplicationB();
+		createApplicationC();
+		createCompositeA();
+		createApplicationD();
+		createdTestFiles = true;
+	}
+	
+	//@Test
+	public void testImportServiceDependencySatisfiedByChild() throws Exception {
+		try {
+			Subsystem subsystem = installSubsystemFromFile(APPLICATION_D);
+			try {
+				assertNull(
+						"Generated application Subsystem-ImportService header when dependency satisfied by child",
+						subsystem.getSubsystemHeaders(null).get(SubsystemConstants.SUBSYSTEM_IMPORTSERVICE));
+				assertSubsystemExportServiceHeader(
+						subsystem.getChildren().iterator().next(), 
+						"bundle.b;filter:=\"(&(active=true)(mode=shared))\"");
+			}
+			finally {
+				uninstallSubsystemSilently(subsystem);
+			}
+		}
+		catch (SubsystemException e) {
+			e.printStackTrace();
+			fail("Installation must succeed if missing service dependency is satisfied");
+		}
+	}
+	
+	@Test
+	public void testImportServiceDependencySatisfiedByContent() throws Exception {
+		try {
+			Subsystem subsystem = installSubsystemFromFile(APPLICATION_C);
+			try {
+				assertNull(
+						"Generated application Subsystem-ImportService header when dependency satisfied by content",
+						subsystem.getSubsystemHeaders(null).get(SubsystemConstants.SUBSYSTEM_IMPORTSERVICE));
+			}
+			finally {
+				uninstallSubsystemSilently(subsystem);
+			}
+		}
+		catch (SubsystemException e) {
+			e.printStackTrace();
+			fail("Installation must succeed if service dependency is satisfied");
+		}
+	}
+	
+	@Test
+	public void testImportServiceDependencySatisfiedByParent() throws Exception {
+		try {
+			Subsystem parent = installSubsystemFromFile(APPLICATION_B);
+			try {
+				Subsystem child = installSubsystemFromFile(parent, APPLICATION_A);
+				try {
+					assertSubsystemImportServiceHeader(child, "osgi.service;filter:=\"(&(objectClass=bundle.b))\";resolution:=mandatory");
+				}
+				finally {
+					uninstallSubsystemSilently(child);
+				}
+			}
+			catch (SubsystemException e) {
+				e.printStackTrace();
+				fail("Installation must succeed if service dependency is satisfied");
+			}
+			finally {
+				uninstallSubsystemSilently(parent);
+			}
+		}
+		catch (SubsystemException e) {
+			e.printStackTrace();
+			fail("Installation must succeed if missing service dependency is optional");
+		}
+	}
+	
+	@Test
+	public void testMissingImportServiceDependencyMandatory() throws Exception {
+		try {
+			Subsystem subsystem = installSubsystemFromFile(APPLICATION_A);
+			uninstallSubsystemSilently(subsystem);
+			fail("Installation must fail due to missing service dependency");
+		}
+		catch (SubsystemException e) {
+			// Okay.
+		}
+	}
+	
+	@Test
+	public void testMissingImportServiceDependencyOptional() throws Exception {
+		try {
+			Subsystem subsystem = installSubsystemFromFile(APPLICATION_B);
+			try {
+				assertSubsystemImportServiceHeader(subsystem, "osgi.service;filter:=\"(&(objectClass=bundle.a))\";resolution:=optional");
+			}
+			finally {
+				uninstallSubsystemSilently(subsystem);
+			}
+		}
+		catch (SubsystemException e) {
+			e.printStackTrace();
+			fail("Installation must succeed if missing service dependency is optional");
+		}
+	}
+	
+	private void assertSubsystemExportServiceHeader(Subsystem subsystem, String value) throws InvalidSyntaxException {
+		String header = assertHeaderExists(subsystem, SubsystemConstants.SUBSYSTEM_EXPORTSERVICE);
+		List<GenericMetadata> actual = ManifestHeaderProcessor.parseRequirementString(header);
+		List<GenericMetadata> expected = ManifestHeaderProcessor.parseRequirementString(value);
+		Assert.assertEquals("Wrong number of clauses", expected.size(), actual.size());
+		for (int i = 0; i < expected.size(); i++)
+			assertEquals("Wrong clause", new GenericMetadataWrapper(expected.get(i)), new GenericMetadataWrapper(actual.get(i)));
+	}
+	
+	private void assertSubsystemImportServiceHeader(Subsystem subsystem, String value) throws InvalidSyntaxException {
+		String header = assertHeaderExists(subsystem, SubsystemConstants.SUBSYSTEM_IMPORTSERVICE);
+		List<GenericMetadata> actual = ManifestHeaderProcessor.parseRequirementString(header);
+		List<GenericMetadata> expected = ManifestHeaderProcessor.parseRequirementString(value);
+		Assert.assertEquals("Wrong number of clauses", expected.size(), actual.size());
+		for (int i = 0; i < expected.size(); i++)
+			assertEquals("Wrong clause", new GenericMetadataWrapper(expected.get(i)), new GenericMetadataWrapper(actual.get(i)));
+	}
+}
diff --git a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/SubsystemTest.java b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/SubsystemTest.java
index 909944c2..e2d45ff9 100644
--- a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/SubsystemTest.java
+++ b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/SubsystemTest.java
@@ -181,18 +181,21 @@ public int size() {
 				// Felix mvn url handler
 				mavenBundle("org.ops4j.pax.url", "pax-url-mvn"),
 				// Bundles
-				mavenBundle("org.osgi", "org.osgi.enterprise").version("5.0.0"),
-				mavenBundle("org.eclipse.equinox", "org.eclipse.equinox.region").version("1.1.0.v20120522-1841"),
-				mavenBundle("org.apache.aries.testsupport", "org.apache.aries.testsupport.unit"),
-				mavenBundle("org.apache.aries.application", "org.apache.aries.application.api"),
 				mavenBundle("org.apache.aries", "org.apache.aries.util").version("1.0.0"),
+				mavenBundle("org.apache.aries.application", "org.apache.aries.application.api"),
+				mavenBundle("org.apache.aries.application", "org.apache.aries.application.modeller").version("1.0.0"),
 				mavenBundle("org.apache.aries.application", "org.apache.aries.application.utils"),
-				mavenBundle("org.apache.felix", "org.apache.felix.resolver"),
-				mavenBundle("org.eclipse.equinox", "org.eclipse.equinox.coordinator").version("1.1.0.v20120522-1841"),
-				mavenBundle("org.eclipse.equinox", "org.eclipse.equinox.event").version("1.2.200.v20120522-2049"),
+				mavenBundle("org.apache.aries.blueprint",   "org.apache.aries.blueprint").version("1.0.0"),
+				mavenBundle("org.apache.aries.proxy",       "org.apache.aries.proxy").version("1.0.1-SNAPSHOT"),
 				mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.api"),
 				mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.core"),
 				mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.itest.interfaces"),
+				mavenBundle("org.apache.aries.testsupport", "org.apache.aries.testsupport.unit"),
+				mavenBundle("org.apache.felix",             "org.apache.felix.resolver"),
+				mavenBundle("org.eclipse.equinox",          "org.eclipse.equinox.coordinator").version("1.1.0.v20120522-1841"),
+				mavenBundle("org.eclipse.equinox",          "org.eclipse.equinox.event").version("1.2.200.v20120522-2049"),
+				mavenBundle("org.eclipse.equinox",          "org.eclipse.equinox.region").version("1.1.0.v20120522-1841"),
+				mavenBundle("org.osgi",                     "org.osgi.enterprise").version("5.0.0"),
 //				org.ops4j.pax.exam.container.def.PaxRunnerOptions.vmOption("-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005"),
 				PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),
 				equinox().version("3.8.0.V20120529-1548"));
@@ -266,9 +269,10 @@ protected void assertContituent(Subsystem subsystem, String symbolicName, String
 		assertConstituent(subsystem, symbolicName, Version.emptyVersion, type);
 	}
 	
-	protected void assertConstituent(Subsystem subsystem, String symbolicName, Version version, String type) {
+	protected Resource assertConstituent(Subsystem subsystem, String symbolicName, Version version, String type) {
 		Resource constituent = getConstituent(subsystem, symbolicName, version, type);
 		assertNotNull("Constituent not found: " + symbolicName + ';' + version + ';' + type, constituent);
+		return constituent;
 	}
 	
 	protected void assertConstituents(int size, Subsystem subsystem) {
@@ -314,8 +318,10 @@ protected void assertEvent(Subsystem subsystem, Subsystem.State state, Subsystem
 		assertEquals("Wrong event type", type, event.getEventType());
 	}
 	
-	protected void assertHeaderExists(Subsystem subsystem, String name) {
-		assertNotNull("Missing header: " + name, subsystem.getSubsystemHeaders(null).get(name));
+	protected String assertHeaderExists(Subsystem subsystem, String name) {
+		String header = subsystem.getSubsystemHeaders(null).get(name);
+		assertNotNull("Missing header: " + name, header);
+		return header;
 	}
 	
 	protected void assertId(Subsystem subsystem) {
@@ -509,7 +515,7 @@ protected RepositoryContent createBundleRepositoryContent(String file) throws Ex
 	}
 	
 	protected RepositoryContent createBundleRepositoryContent(File file) throws Exception {
-		return BundleResource.newInstance(file.toURI().toURL());
+		return new BundleResource(file.toURI().toURL());
 	}
 	
 	protected static void createManifest(String name, Map<String, String> headers) throws IOException {
diff --git a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/GenericMetadataWrapper.java b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/GenericMetadataWrapper.java
index e69de29b..de9ed78f 100644
--- a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/GenericMetadataWrapper.java
+++ b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/GenericMetadataWrapper.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.aries.subsystem.itests.util;
+
+import org.apache.aries.util.manifest.ManifestHeaderProcessor.GenericMetadata;
+
+public class GenericMetadataWrapper {
+	private final GenericMetadata metadata;
+	
+	public GenericMetadataWrapper(GenericMetadata metadata) {
+		if (metadata == null)
+			throw new NullPointerException();
+		this.metadata = metadata;
+	}
+	
+	public GenericMetadata getGenericMetadata() {
+		return metadata;
+	}
+	
+	@Override
+	public boolean equals(Object o) {
+		if (o == this)
+			return true;
+		if (!(o instanceof GenericMetadataWrapper))
+			return false;
+		GenericMetadataWrapper that = (GenericMetadataWrapper)o;
+		return metadata.getNamespace().equals(that.metadata.getNamespace())
+				&& metadata.getAttributes().equals(that.metadata.getAttributes())
+				&& metadata.getDirectives().equals(that.metadata.getDirectives());
+	}
+	
+	@Override
+	public int hashCode() {
+		int result = 17;
+		result = 31 * result + metadata.getNamespace().hashCode();
+		result = 31 * result + metadata.getAttributes().hashCode();
+		result = 31 * result + metadata.getDirectives().hashCode();
+		return result;
+	}
+}
