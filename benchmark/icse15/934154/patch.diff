diff --git a/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java b/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java
index fdf75ecf..6c5714a4 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java
@@ -45,6 +45,7 @@
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.db.marshal.MarshalException;
 import org.apache.cassandra.service.StorageProxy;
+import static org.apache.cassandra.utils.FBUtilities.UTF8;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import static org.apache.cassandra.avro.AvroRecordFactory.*;
@@ -87,7 +88,8 @@ public ColumnOrSuperColumn get(Utf8 keyspace, Utf8 key, ColumnPath columnPath, C
         for (String key: keys)
         {
             AvroValidation.validateKey(key);
-            commands.add(new SliceByNamesReadCommand(keyspace, key, path, nameAsList));
+            // FIXME: string key
+            commands.add(new SliceByNamesReadCommand(keyspace, key.getBytes(UTF8), path, nameAsList));
         }
         
         Map<String, ColumnOrSuperColumn> columnFamiliesMap = new HashMap<String, ColumnOrSuperColumn>();
@@ -120,7 +122,8 @@ public ColumnOrSuperColumn get(Utf8 keyspace, Utf8 key, ColumnPath columnPath, C
                 }
 
             }
-            columnFamiliesMap.put(command.key, columnorsupercolumn);
+            // FIXME: assuming string keys
+            columnFamiliesMap.put(new String(command.key, UTF8), columnorsupercolumn);
         }
 
         return columnFamiliesMap;
@@ -129,10 +132,10 @@ public ColumnOrSuperColumn get(Utf8 keyspace, Utf8 key, ColumnPath columnPath, C
     private Map<String, Collection<IColumn>> multigetColumns(List<ReadCommand> commands, ConsistencyLevel level)
     throws InvalidRequestException, UnavailableException, TimedOutException
     {
-        Map<String, ColumnFamily> cfamilies = readColumnFamily(commands, level);
+        Map<byte[], ColumnFamily> cfamilies = readColumnFamily(commands, level);
         Map<String, Collection<IColumn>> columnFamiliesMap = new HashMap<String, Collection<IColumn>>();
         
-        for (ReadCommand command: commands)
+        for (ReadCommand command : commands)
         {
             ColumnFamily cfamily = cfamilies.get(command.key);
             if (cfamily == null)
@@ -154,18 +157,19 @@ public ColumnOrSuperColumn get(Utf8 keyspace, Utf8 key, ColumnPath columnPath, C
 
             if (columns != null && columns.size() != 0)
             {
-                columnFamiliesMap.put(command.key, columns);
+                // FIXME: assuming string keys
+                columnFamiliesMap.put(new String(command.key, UTF8), columns);
             }
         }
         
         return columnFamiliesMap;
     }
     
-    protected Map<String, ColumnFamily> readColumnFamily(List<ReadCommand> commands, ConsistencyLevel consistency)
+    protected Map<byte[], ColumnFamily> readColumnFamily(List<ReadCommand> commands, ConsistencyLevel consistency)
     throws InvalidRequestException, UnavailableException, TimedOutException
     {
         // TODO - Support multiple column families per row, right now row only contains 1 column family
-        Map<String, ColumnFamily> columnFamilyKeyMap = new HashMap<String,ColumnFamily>();
+        Map<byte[], ColumnFamily> columnFamilyKeyMap = new HashMap<byte[],ColumnFamily>();
         
         if (consistency == ConsistencyLevel.ZERO)
             throw newInvalidRequestException("Consistency level zero may not be applied to read operations");
@@ -195,7 +199,7 @@ public ColumnOrSuperColumn get(Utf8 keyspace, Utf8 key, ColumnPath columnPath, C
 
         for (Row row: rows)
         {
-            columnFamilyKeyMap.put(row.key, row.cf);
+            columnFamilyKeyMap.put(row.key.key, row.cf);
         }
         
         return columnFamilyKeyMap;
@@ -238,7 +242,7 @@ public Void insert(Utf8 keyspace, Utf8 key, ColumnPath cp, ByteBuffer value, lon
         AvroValidation.validateKey(keyspace_string);
         AvroValidation.validateColumnPath(keyspace_string, cp);
 
-        RowMutation rm = new RowMutation(keyspace_string, key.toString());
+        RowMutation rm = new RowMutation(keyspace_string, key.getBytes());
         try
         {
             rm.add(new QueryPath(column_family, super_column, column), value.array(), timestamp);
@@ -282,10 +286,10 @@ public Void batch_insert(Utf8 keyspace, Utf8 key, Map<Utf8, GenericArray<ColumnO
         if (logger.isDebugEnabled())
             logger.debug("batch_insert");
 
-        String keyString = key.toString();
+        byte[] keyBytes = key.getBytes();
         String keyspaceString = keyspace.toString();
 
-        AvroValidation.validateKey(keyString);
+        AvroValidation.validateKey(key.toString());
 
         for (Utf8 cfName : cfmap.keySet())
         {
@@ -293,14 +297,14 @@ public Void batch_insert(Utf8 keyspace, Utf8 key, Map<Utf8, GenericArray<ColumnO
                 AvroValidation.validateColumnOrSuperColumn(keyspaceString, cfName.toString(), cosc);
         }
 
-        doInsert(consistency, getRowMutation(keyspaceString, keyString, cfmap));
+        doInsert(consistency, getRowMutation(keyspaceString, keyBytes, cfmap));
         return null;
     }
 
     // FIXME: This is copypasta from o.a.c.db.RowMutation, (RowMutation.getRowMutation uses Thrift types directly).
-    private static RowMutation getRowMutation(String keyspace, String key, Map<Utf8, GenericArray<ColumnOrSuperColumn>> cfmap)
+    private static RowMutation getRowMutation(String keyspace, byte[] key, Map<Utf8, GenericArray<ColumnOrSuperColumn>> cfmap)
     {
-        RowMutation rm = new RowMutation(keyspace, key.trim());
+        RowMutation rm = new RowMutation(keyspace, key);
         for (Map.Entry<Utf8, GenericArray<ColumnOrSuperColumn>> entry : cfmap.entrySet())
         {
             String cfName = entry.getKey().toString();
@@ -379,7 +383,8 @@ public Void batch_mutate(Utf8 keyspace, Map<Utf8, Map<Utf8, GenericArray<Mutatio
     // FIXME: This is copypasta from o.a.c.db.RowMutation, (RowMutation.getRowMutation uses Thrift types directly).
     private static RowMutation getRowMutationFromMutations(String keyspace, String key, Map<Utf8, GenericArray<Mutation>> cfMap)
     {
-        RowMutation rm = new RowMutation(keyspace, key.trim());
+        // FIXME: string key
+        RowMutation rm = new RowMutation(keyspace, key.trim().getBytes(UTF8));
         
         for (Map.Entry<Utf8, GenericArray<Mutation>> entry : cfMap.entrySet())
         {
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/client/RingCache.java b/cassandra/trunk/src/java/org/apache/cassandra/client/RingCache.java
index b6d29b5c..a71744b9 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/client/RingCache.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/client/RingCache.java
@@ -109,7 +109,7 @@ public void refreshEndPointMap()
         }
     }
 
-    public List<InetAddress> getEndPoint(String key)
+    public List<InetAddress> getEndPoint(byte[] key)
     {
         if (tokenMetadata == null)
             throw new RuntimeException("Must refresh endpoints before looking up a key.");
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/BinaryMemtable.java b/cassandra/trunk/src/java/org/apache/cassandra/db/BinaryMemtable.java
index a9da43e9..c8e8571e 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/BinaryMemtable.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/BinaryMemtable.java
@@ -68,7 +68,7 @@ boolean isThresholdViolated()
      * the memtable. This version will respect the threshold and flush
      * the memtable to disk when the size exceeds the threshold.
     */
-    void put(String key, byte[] buffer)
+    void put(DecoratedKey key, byte[] buffer)
     {
         if (isThresholdViolated())
         {
@@ -102,10 +102,10 @@ public boolean isClean()
         return columnFamilies.isEmpty();
     }
 
-    private void resolve(String key, byte[] buffer)
+    private void resolve(DecoratedKey key, byte[] buffer)
     {
-        columnFamilies.put(partitioner.decorateKey(key), buffer);
-        currentSize.addAndGet(buffer.length + key.length());
+        columnFamilies.put(key, buffer);
+        currentSize.addAndGet(buffer.length + key.key.length);
     }
 
     private List<DecoratedKey> getSortedKeys()
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 9462ba5e..886c2991 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -382,7 +382,7 @@ public void runMayThrow() throws InterruptedException, IOException
         }
     }
 
-    void switchBinaryMemtable(String key, byte[] buffer)
+    void switchBinaryMemtable(DecoratedKey key, byte[] buffer)
     {
         binaryMemtable_.set(new BinaryMemtable(this));
         binaryMemtable_.get().put(key, buffer);
@@ -424,7 +424,7 @@ public void forceFlushBinary()
      * param @ key - key for update/insert
      * param @ columnFamily - columnFamily changes
      */
-    Memtable apply(String key, ColumnFamily columnFamily)
+    Memtable apply(DecoratedKey key, ColumnFamily columnFamily)
     {
         long start = System.nanoTime();
 
@@ -440,7 +440,7 @@ Memtable apply(String key, ColumnFamily columnFamily)
      * needs to be used. param @ key - key for update/insert param @
      * columnFamily - columnFamily changes
      */
-    void applyBinary(String key, byte[] buffer)
+    void applyBinary(DecoratedKey key, byte[] buffer)
     {
         long start = System.nanoTime();
         binaryMemtable_.get().put(key, buffer);
@@ -686,12 +686,12 @@ public double getRecentWriteLatencyMicros()
         return writeStats_.getRecentLatencyMicros();
     }
 
-    public ColumnFamily getColumnFamily(String key, QueryPath path, byte[] start, byte[] finish, List<byte[]> bitmasks, boolean reversed, int limit)
+    public ColumnFamily getColumnFamily(DecoratedKey key, QueryPath path, byte[] start, byte[] finish, List<byte[]> bitmasks, boolean reversed, int limit)
     {
         return getColumnFamily(QueryFilter.getSliceFilter(key, path, start, finish, bitmasks, reversed, limit));
     }
 
-    public ColumnFamily getColumnFamily(String key, QueryPath path, byte[] start, byte[] finish, boolean reversed, int limit)
+    public ColumnFamily getColumnFamily(DecoratedKey key, QueryPath path, byte[] start, byte[] finish, boolean reversed, int limit)
     {
         return getColumnFamily(QueryFilter.getSliceFilter(key, path, start, finish, null, reversed, limit));
     }
@@ -701,7 +701,7 @@ public ColumnFamily getColumnFamily(QueryFilter filter)
         return getColumnFamily(filter, CompactionManager.getDefaultGCBefore());
     }
 
-    private ColumnFamily cacheRow(String key)
+    private ColumnFamily cacheRow(DecoratedKey key)
     {
         ColumnFamily cached;
         if ((cached = ssTables_.getRowCache().get(key)) == null)
@@ -867,8 +867,7 @@ private boolean getRangeRows(List<Row> rows, byte[] superColumn, final AbstractB
             while(iterator.hasNext())
             {
                 Row current = iterator.next();
-            	// TODO store decoratedkey in row?
-                DecoratedKey key = partitioner.decorateKey(current.key);
+                DecoratedKey key = current.key;
 
                 if (!stopAt.isEmpty() && stopAt.compareTo(key) < 0)
                     return true;
@@ -1010,12 +1009,12 @@ public int getLiveSSTableCount()
     }
 
     /** raw cached row -- does not fetch the row if it is not present.  not counted in cache statistics.  */
-    public ColumnFamily getRawCachedRow(String key)
+    public ColumnFamily getRawCachedRow(DecoratedKey key)
     {
         return ssTables_.getRowCache().getCapacity() == 0 ? null : ssTables_.getRowCache().getInternal(key);
     }
 
-    void invalidateCachedRow(String key)
+    void invalidateCachedRow(DecoratedKey key)
     {
         ssTables_.getRowCache().remove(key);
     }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/DefsTable.java b/cassandra/trunk/src/java/org/apache/cassandra/db/DefsTable.java
index 6c63ec69..546296cf 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/DefsTable.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/DefsTable.java
@@ -25,6 +25,9 @@
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.db.filter.SliceQueryFilter;
 import org.apache.cassandra.db.migration.Migration;
+import org.apache.cassandra.io.util.FileUtils;
+import org.apache.cassandra.service.StorageService;
+import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.utils.UUIDGen;
 
 import java.io.ByteArrayInputStream;
@@ -42,7 +45,7 @@
     /** dumps current keyspace definitions to storage */
     public static synchronized void dumpToStorage(UUID version) throws IOException
     {
-        String versionKey = version.toString();
+        byte[] versionKey = Migration.toBytes(version);
         long now = System.currentTimeMillis();
         RowMutation rm = new RowMutation(Table.DEFINITIONS, versionKey);
         for (String tableName : DatabaseDescriptor.getNonSystemTables())
@@ -53,16 +56,17 @@ public static synchronized void dumpToStorage(UUID version) throws IOException
         rm.apply();
         
         rm = new RowMutation(Table.DEFINITIONS, Migration.LAST_MIGRATION_KEY);
-        rm.add(new QueryPath(Migration.SCHEMA_CF, null, Migration.LAST_MIGRATION_KEY.getBytes()), UUIDGen.decompose(version), now);
+        rm.add(new QueryPath(Migration.SCHEMA_CF, null, Migration.LAST_MIGRATION_KEY), UUIDGen.decompose(version), now);
         rm.apply();
     }
 
     /** loads a version of keyspace definitions from storage */
     public static synchronized Collection<KSMetaData> loadFromStorage(UUID version) throws IOException
     {
+        DecoratedKey vkey = StorageService.getPartitioner().decorateKey(Migration.toBytes(version));
         Table defs = Table.open(Table.DEFINITIONS);
         ColumnFamilyStore cfStore = defs.getColumnFamilyStore(Migration.SCHEMA_CF);
-        QueryFilter filter = QueryFilter.getSliceFilter(version.toString(), new QueryPath(Migration.SCHEMA_CF), "".getBytes(), "".getBytes(), null, false, 1024);
+        QueryFilter filter = QueryFilter.getSliceFilter(vkey, new QueryPath(Migration.SCHEMA_CF), "".getBytes(), "".getBytes(), null, false, 1024);
         ColumnFamily cf = cfStore.getColumnFamily(filter);
         Collection<KSMetaData> tables = new ArrayList<KSMetaData>();
         for (IColumn col : cf.getSortedColumns())
@@ -90,5 +94,4 @@ public boolean accept(File pathname)
         }
         return found;
     }
-    
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/HintedHandOffManager.java b/cassandra/trunk/src/java/org/apache/cassandra/db/HintedHandOffManager.java
index 9c317ae9..922081af 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/HintedHandOffManager.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/HintedHandOffManager.java
@@ -42,6 +42,8 @@
 import org.apache.cassandra.service.*;
 import org.apache.cassandra.thrift.InvalidRequestException;
 import org.apache.cassandra.db.filter.QueryPath;
+import org.apache.cassandra.utils.FBUtilities;
+import static org.apache.cassandra.utils.FBUtilities.UTF8;
 import org.apache.cassandra.utils.WrappedRunnable;
 
 
@@ -102,7 +104,7 @@ public void runMayThrow() throws Exception
         }, "Hint delivery").start();
     }
 
-    private static boolean sendMessage(InetAddress endPoint, String tableName, String key) throws IOException
+    private static boolean sendMessage(InetAddress endPoint, String tableName, byte[] key) throws IOException
     {
         if (!Gossiper.instance.isKnownEndpoint(endPoint))
         {
@@ -116,9 +118,10 @@ private static boolean sendMessage(InetAddress endPoint, String tableName, Strin
 
         Table table = Table.open(tableName);
         RowMutation rm = new RowMutation(tableName, key);
+        DecoratedKey dkey = StorageService.getPartitioner().decorateKey(key);
         for (ColumnFamilyStore cfstore : table.getColumnFamilyStores())
         {
-            ColumnFamily cf = cfstore.getColumnFamily(QueryFilter.getIdentityFilter(key, new QueryPath(cfstore.getColumnFamilyName())));
+            ColumnFamily cf = cfstore.getColumnFamily(QueryFilter.getIdentityFilter(dkey, new QueryPath(cfstore.getColumnFamilyName())));
             if (cf != null)
                 rm.add(cf);
         }
@@ -139,14 +142,14 @@ private static boolean sendMessage(InetAddress endPoint, String tableName, Strin
 
     private static void deleteEndPoint(byte[] endpointAddress, String tableName, byte[] key, long timestamp) throws IOException
     {
-        RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, tableName);
+        RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, tableName.getBytes(UTF8));
         rm.delete(new QueryPath(HINTS_CF, key, endpointAddress), timestamp);
         rm.apply();
     }
 
     private static void deleteHintKey(String tableName, byte[] key) throws IOException
     {
-        RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, tableName);
+        RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, tableName.getBytes(UTF8));
         rm.delete(new QueryPath(HINTS_CF, key, null), System.currentTimeMillis());
         rm.apply();
     }
@@ -167,10 +170,11 @@ private static void deliverAllHints() throws DigestMismatchException, IOExceptio
         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
         for (String tableName : DatabaseDescriptor.getTables())
         {
+            DecoratedKey tableNameKey = StorageService.getPartitioner().decorateKey(tableName.getBytes(UTF8));
             byte[] startColumn = ArrayUtils.EMPTY_BYTE_ARRAY;
             while (true)
             {
-                QueryFilter filter = QueryFilter.getSliceFilter(tableName, new QueryPath(HINTS_CF), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, PAGE_SIZE);
+                QueryFilter filter = QueryFilter.getSliceFilter(tableNameKey, new QueryPath(HINTS_CF), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, PAGE_SIZE);
                 ColumnFamily hintColumnFamily = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter), Integer.MAX_VALUE);
                 if (pagingFinished(hintColumnFamily, startColumn))
                     break;
@@ -179,11 +183,11 @@ private static void deliverAllHints() throws DigestMismatchException, IOExceptio
                 for (IColumn keyColumn : keys)
                 {
                     Collection<IColumn> endpoints = keyColumn.getSubColumns();
-                    String keyStr = new String(keyColumn.name(), "UTF-8");
+                    byte[] keyBytes = keyColumn.name();
                     int deleted = 0;
                     for (IColumn endpoint : endpoints)
                     {
-                        if (sendMessage(InetAddress.getByAddress(endpoint.name()), tableName, keyStr))
+                        if (sendMessage(InetAddress.getByAddress(endpoint.name()), tableName, keyBytes))
                         {
                             deleteEndPoint(endpoint.name(), tableName, keyColumn.name(), System.currentTimeMillis());
                             deleted++;
@@ -231,10 +235,11 @@ private static void deliverHintsToEndpoint(InetAddress endPoint) throws IOExcept
         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
         for (String tableName : DatabaseDescriptor.getTables())
         {
+            DecoratedKey tableNameKey = StorageService.getPartitioner().decorateKey(tableName.getBytes(UTF8));
             byte[] startColumn = ArrayUtils.EMPTY_BYTE_ARRAY;
             while (true)
             {
-                QueryFilter filter = QueryFilter.getSliceFilter(tableName, new QueryPath(HINTS_CF), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, PAGE_SIZE);
+                QueryFilter filter = QueryFilter.getSliceFilter(tableNameKey, new QueryPath(HINTS_CF), startColumn, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, PAGE_SIZE);
                 ColumnFamily hintColumnFamily = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter), Integer.MAX_VALUE);
                 if (pagingFinished(hintColumnFamily, startColumn))
                     break;
@@ -242,11 +247,11 @@ private static void deliverHintsToEndpoint(InetAddress endPoint) throws IOExcept
 
                 for (IColumn keyColumn : keys)
                 {
-                    String keyStr = new String(keyColumn.name(), "UTF-8");
+                    byte[] keyBytes = keyColumn.name();
                     Collection<IColumn> endpoints = keyColumn.getSubColumns();
                     for (IColumn hintEndPoint : endpoints)
                     {
-                        if (Arrays.equals(hintEndPoint.name(), targetEPBytes) && sendMessage(endPoint, tableName, keyStr))
+                        if (Arrays.equals(hintEndPoint.name(), targetEPBytes) && sendMessage(endPoint, tableName, keyBytes))
                         {
                             if (endpoints.size() == 1)
                                 deleteHintKey(tableName, keyColumn.name());
@@ -268,6 +273,7 @@ private static void deliverHintsToEndpoint(InetAddress endPoint) throws IOExcept
     /** called when a keyspace is dropped or rename. newTable==null in the case of a drop. */
     public static void renameHints(String oldTable, String newTable) throws IOException
     {
+        DecoratedKey oldTableKey = StorageService.getPartitioner().decorateKey(oldTable.getBytes(UTF8));
         // we're basically going to fetch, drop and add the scf for the old and new table. we need to do it piecemeal 
         // though since there could be GB of data.
         ColumnFamilyStore hintStore = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(HINTS_CF);
@@ -275,17 +281,17 @@ public static void renameHints(String oldTable, String newTable) throws IOExcept
         long now = System.currentTimeMillis();
         while (true)
         {
-            QueryFilter filter = QueryFilter.getSliceFilter(oldTable, new QueryPath(HINTS_CF), startCol, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, PAGE_SIZE);
+            QueryFilter filter = QueryFilter.getSliceFilter(oldTableKey, new QueryPath(HINTS_CF), startCol, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, PAGE_SIZE);
             ColumnFamily cf = ColumnFamilyStore.removeDeleted(hintStore.getColumnFamily(filter), Integer.MAX_VALUE);
             if (pagingFinished(cf, startCol))
                 break;
             if (newTable != null)
             {
-                RowMutation insert = new RowMutation(Table.SYSTEM_TABLE, newTable);
+                RowMutation insert = new RowMutation(Table.SYSTEM_TABLE, newTable.getBytes(UTF8));
                 insert.add(cf);
                 insert.apply();
             }
-            RowMutation drop = new RowMutation(Table.SYSTEM_TABLE, oldTable);
+            RowMutation drop = new RowMutation(Table.SYSTEM_TABLE, oldTableKey.key);
             for (byte[] key : cf.getColumnNames())
             {
                 drop.delete(new QueryPath(HINTS_CF, key), now);
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/Memtable.java b/cassandra/trunk/src/java/org/apache/cassandra/db/Memtable.java
index 7f7dc64e..e4498d42 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/Memtable.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/Memtable.java
@@ -111,19 +111,18 @@ void freeze()
      * (CFS handles locking to avoid submitting an op
      *  to a flushing memtable.  Any other way is unsafe.)
     */
-    void put(String key, ColumnFamily columnFamily)
+    void put(DecoratedKey key, ColumnFamily columnFamily)
     {
         assert !isFrozen; // not 100% foolproof but hell, it's an assert
         resolve(key, columnFamily);
     }
 
-    private void resolve(String key, ColumnFamily cf)
+    private void resolve(DecoratedKey key, ColumnFamily cf)
     {
         currentThroughput.addAndGet(cf.size());
         currentOperations.addAndGet(cf.getColumnCount());
 
-        DecoratedKey decoratedKey = partitioner.decorateKey(key);
-        ColumnFamily oldCf = columnFamilies.putIfAbsent(decoratedKey, cf);
+        ColumnFamily oldCf = columnFamilies.putIfAbsent(key, cf);
         if (oldCf == null)
             return;
 
@@ -299,9 +298,9 @@ protected IColumn computeNext()
         };
     }
 
-    public ColumnFamily getColumnFamily(String key)
+    public ColumnFamily getColumnFamily(DecoratedKey key)
     {
-        return columnFamilies.get(partitioner.decorateKey(key));
+        return columnFamilies.get(key);
     }
 
     void clearUnsafe()
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/ReadCommand.java b/cassandra/trunk/src/java/org/apache/cassandra/db/ReadCommand.java
index 695a49ba..3362dcb4 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/ReadCommand.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/ReadCommand.java
@@ -59,11 +59,11 @@ public Message makeReadMessage() throws IOException
 
     public final QueryPath queryPath;
     public final String table;
-    public final String key;
+    public final byte[] key;
     private boolean isDigestQuery = false;    
     protected final byte commandType;
 
-    protected ReadCommand(String table, String key, QueryPath queryPath, byte cmdType)
+    protected ReadCommand(String table, byte[] key, QueryPath queryPath, byte cmdType)
     {
         this.table = table;
         this.key = key;
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/Row.java b/cassandra/trunk/src/java/org/apache/cassandra/db/Row.java
index a2ef14ec..abe9e6df 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/Row.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/Row.java
@@ -29,6 +29,8 @@
 import org.slf4j.LoggerFactory;
 
 import org.apache.cassandra.io.ICompactSerializer;
+import org.apache.cassandra.service.StorageService;
+import org.apache.cassandra.utils.FBUtilities;
 
 public class Row
 {
@@ -40,10 +42,10 @@ static RowSerializer serializer()
         return serializer;
     }
 
-    public final String key;
+    public final DecoratedKey key;
     public final ColumnFamily cf;
 
-    public Row(String key, ColumnFamily cf)
+    public Row(DecoratedKey key, ColumnFamily cf)
     {
         assert key != null;
         // cf may be null, indicating no data
@@ -55,7 +57,7 @@ public Row(String key, ColumnFamily cf)
     public String toString()
     {
         return "Row(" +
-               "key='" + key + '\'' +
+               "key=" + key +
                ", cf=" + cf +
                ')';
     }
@@ -65,12 +67,13 @@ public String toString()
 {
     public void serialize(Row row, DataOutputStream dos) throws IOException
     {
-        dos.writeUTF(row.key);
+        FBUtilities.writeShortByteArray(row.key.key, dos);
         ColumnFamily.serializer().serialize(row.cf, dos);
     }
 
     public Row deserialize(DataInputStream dis) throws IOException
     {
-        return new Row(dis.readUTF(), ColumnFamily.serializer().deserialize(dis));
+        return new Row(StorageService.getPartitioner().decorateKey(FBUtilities.readShortByteArray(dis)),
+                       ColumnFamily.serializer().deserialize(dis));
     }
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/RowIteratorFactory.java b/cassandra/trunk/src/java/org/apache/cassandra/db/RowIteratorFactory.java
index 698e7b1f..48ccb5e9 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/RowIteratorFactory.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/RowIteratorFactory.java
@@ -133,8 +133,7 @@ protected Row getReduced()
                 Comparator<IColumn> colComparator = QueryFilter.getColumnComparator(comparator);
                 Iterator<IColumn> colCollated = IteratorUtils.collatedIterator(colComparator, colIters);
 
-                // FIXME: string keys
-                ColumnFamily returnCF = current.getColumnFamily(new String(key.key));
+                ColumnFamily returnCF = current.getColumnFamily(key);
                 // TODO this is a little subtle: the Memtable ColumnIterator has to be a shallow clone of the source CF,
                 // with deletion times set correctly, so we can use it as the "base" CF to add query results to.
                 // (for sstable ColumnIterators we do not care if it is a shallow clone or not.)
@@ -150,8 +149,7 @@ protected Row getReduced()
                     returnCF = null;
                 }
 
-                // FIXME: string keys
-                Row rv = new Row(new String(key.key), returnCF);
+                Row rv = new Row(key, returnCF);
                 colIters.clear();
                 key = null;
                 return rv;
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutation.java b/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutation.java
index b868d996..0b52d94c 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutation.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutation.java
@@ -61,10 +61,10 @@
     }
 
     private String table_;
-    private String key_;
+    private byte[] key_;
     protected Map<String, ColumnFamily> modifications_ = new HashMap<String, ColumnFamily>();
 
-    public RowMutation(String table, String key)
+    public RowMutation(String table, byte[] key)
     {
         table_ = table;
         key_ = key;
@@ -73,11 +73,11 @@ public RowMutation(String table, String key)
     public RowMutation(String table, Row row)
     {
         table_ = table;
-        key_ = row.key;
+        key_ = row.key.key;
         add(row.cf);
     }
 
-    protected RowMutation(String table, String key, Map<String, ColumnFamily> modifications)
+    protected RowMutation(String table, byte[] key, Map<String, ColumnFamily> modifications)
     {
         table_ = table;
         key_ = key;
@@ -89,7 +89,7 @@ public String getTable()
         return table_;
     }
 
-    public String key()
+    public byte[] key()
     {
         return key_;
     }
@@ -104,9 +104,9 @@ public String key()
         return modifications_.values();
     }
 
-    void addHints(String key, byte[] host) throws IOException
+    void addHints(byte[] key, byte[] host) throws IOException
     {
-        QueryPath path = new QueryPath(HintedHandOffManager.HINTS_CF, key.getBytes("UTF-8"), host);
+        QueryPath path = new QueryPath(HintedHandOffManager.HINTS_CF, key, host);
         add(path, ArrayUtils.EMPTY_BYTE_ARRAY, System.currentTimeMillis());
     }
 
@@ -222,9 +222,9 @@ public Message makeRowMutationMessage(StorageService.Verb verb) throws IOExcepti
         return new Message(FBUtilities.getLocalAddress(), StageManager.MUTATION_STAGE, verb, bos.toByteArray());
     }
 
-    public static RowMutation getRowMutationFromMutations(String keyspace, String key, Map<String, List<Mutation>> cfmap)
+    public static RowMutation getRowMutationFromMutations(String keyspace, byte[] key, Map<String, List<Mutation>> cfmap)
     {
-        RowMutation rm = new RowMutation(keyspace, key.trim());
+        RowMutation rm = new RowMutation(keyspace, key);
         for (Map.Entry<String, List<Mutation>> entry : cfmap.entrySet())
         {
             String cfName = entry.getKey();
@@ -243,9 +243,9 @@ public static RowMutation getRowMutationFromMutations(String keyspace, String ke
         return rm;
     }
     
-    public static RowMutation getRowMutation(String table, String key, Map<String, List<ColumnOrSuperColumn>> cfmap)
+    public static RowMutation getRowMutation(String table, byte[] key, Map<String, List<ColumnOrSuperColumn>> cfmap)
     {
-        RowMutation rm = new RowMutation(table, key.trim());
+        RowMutation rm = new RowMutation(table, key);
         for (Map.Entry<String, List<ColumnOrSuperColumn>> entry : cfmap.entrySet())
         {
             String cfName = entry.getKey();
@@ -280,7 +280,7 @@ public String toString()
     {
         return "RowMutation(" +
                "table='" + table_ + '\'' +
-               ", key='" + key_ + '\'' +
+               ", key='" + FBUtilities.bytesToHex(key_) + '\'' +
                ", modifications=[" + StringUtils.join(modifications_.values(), ", ") + "]" +
                ')';
     }
@@ -327,15 +327,10 @@ private void freezeTheMaps(Map<String, ColumnFamily> map, DataOutputStream dos)
         dos.writeInt(size);
         if (size > 0)
         {
-            Set<String> keys = map.keySet();
-            for (String key : keys)
+            for (Map.Entry<String,ColumnFamily> entry : map.entrySet())
             {
-                dos.writeUTF(key);
-                ColumnFamily cf = map.get(key);
-                if (cf != null)
-                {
-                    ColumnFamily.serializer().serialize(cf, dos);
-                }
+                dos.writeUTF(entry.getKey());
+                ColumnFamily.serializer().serialize(entry.getValue(), dos);
             }
         }
     }
@@ -343,7 +338,7 @@ private void freezeTheMaps(Map<String, ColumnFamily> map, DataOutputStream dos)
     public void serialize(RowMutation rm, DataOutputStream dos) throws IOException
     {
         dos.writeUTF(rm.getTable());
-        dos.writeUTF(rm.key());
+        FBUtilities.writeShortByteArray(rm.key(), dos);
 
         /* serialize the modifications_ in the mutation */
         freezeTheMaps(rm.modifications_, dos);
@@ -365,10 +360,8 @@ public void serialize(RowMutation rm, DataOutputStream dos) throws IOException
     public RowMutation deserialize(DataInputStream dis) throws IOException
     {
         String table = dis.readUTF();
-        String key = dis.readUTF();
+        byte[] key = FBUtilities.readShortByteArray(dis);
         Map<String, ColumnFamily> modifications = defreezeTheMaps(dis);
         return new RowMutation(table, key, modifications);
     }
-
-  
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutationVerbHandler.java b/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutationVerbHandler.java
index 438b2bef..7c542002 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutationVerbHandler.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutationVerbHandler.java
@@ -60,7 +60,7 @@ public void doVerb(Message message)
                     InetAddress hint = InetAddress.getByAddress(addressBytes);
                     if (logger_.isDebugEnabled())
                         logger_.debug("Adding hint for " + hint);
-                    RowMutation hintedMutation = new RowMutation(Table.SYSTEM_TABLE, rm.getTable());
+                    RowMutation hintedMutation = new RowMutation(Table.SYSTEM_TABLE, rm.getTable().getBytes(FBUtilities.UTF8));
                     hintedMutation.addHints(rm.key(), addressBytes);
                     hintedMutation.apply();
                 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/SliceByNamesReadCommand.java b/cassandra/trunk/src/java/org/apache/cassandra/db/SliceByNamesReadCommand.java
index 031bf904..0035273b 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/SliceByNamesReadCommand.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/SliceByNamesReadCommand.java
@@ -23,20 +23,21 @@
 import java.util.*;
 
 import org.apache.cassandra.db.filter.QueryFilter;
+import org.apache.cassandra.db.filter.QueryPath;
+import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.thrift.ColumnParent;
 import org.apache.cassandra.utils.FBUtilities;
-import org.apache.cassandra.db.filter.QueryPath;
 
 public class SliceByNamesReadCommand extends ReadCommand
 {
     public final SortedSet<byte[]> columnNames;
 
-    public SliceByNamesReadCommand(String table, String key, ColumnParent column_parent, Collection<byte[]> columnNames)
+    public SliceByNamesReadCommand(String table, byte[] key, ColumnParent column_parent, Collection<byte[]> columnNames)
     {
         this(table, key, new QueryPath(column_parent), columnNames);
     }
 
-    public SliceByNamesReadCommand(String table, String key, QueryPath path, Collection<byte[]> columnNames)
+    public SliceByNamesReadCommand(String table, byte[] key, QueryPath path, Collection<byte[]> columnNames)
     {
         super(table, key, path, CMD_TYPE_GET_SLICE_BY_NAMES);
         this.columnNames = new TreeSet<byte[]>(getComparator());
@@ -54,7 +55,8 @@ public ReadCommand copy()
     @Override
     public Row getRow(Table table) throws IOException
     {        
-        return table.getRow(QueryFilter.getNamesFilter(key, queryPath, columnNames));
+        DecoratedKey dk = StorageService.getPartitioner().decorateKey(key);
+        return table.getRow(QueryFilter.getNamesFilter(dk, queryPath, columnNames));
     }
 
     @Override
@@ -62,7 +64,7 @@ public String toString()
     {
         return "SliceByNamesReadCommand(" +
                "table='" + table + '\'' +
-               ", key='" + key + '\'' +
+               ", key=" + FBUtilities.bytesToHex(key) +
                ", columnParent='" + queryPath + '\'' +
                ", columns=[" + getComparator().getString(columnNames) + "]" +
                ')';
@@ -78,7 +80,7 @@ public void serialize(ReadCommand rm, DataOutputStream dos) throws IOException
         SliceByNamesReadCommand realRM = (SliceByNamesReadCommand)rm;
         dos.writeBoolean(realRM.isDigestQuery());
         dos.writeUTF(realRM.table);
-        dos.writeUTF(realRM.key);
+        FBUtilities.writeShortByteArray(realRM.key, dos);
         realRM.queryPath.serialize(dos);
         dos.writeInt(realRM.columnNames.size());
         if (realRM.columnNames.size() > 0)
@@ -95,7 +97,7 @@ public ReadCommand deserialize(DataInputStream dis) throws IOException
     {
         boolean isDigest = dis.readBoolean();
         String table = dis.readUTF();
-        String key = dis.readUTF();
+        byte[] key = FBUtilities.readShortByteArray(dis);
         QueryPath columnParent = QueryPath.deserialize(dis);
 
         int size = dis.readInt();
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/SliceFromReadCommand.java b/cassandra/trunk/src/java/org/apache/cassandra/db/SliceFromReadCommand.java
index 6d77fc48..62a229f5 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/SliceFromReadCommand.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/SliceFromReadCommand.java
@@ -24,6 +24,7 @@
 
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
+import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.thrift.ColumnParent;
 import org.apache.cassandra.utils.ByteArrayListSerializer;
 import org.apache.cassandra.utils.FBUtilities;
@@ -35,17 +36,17 @@
     public final int count;
     public final List<byte[]> bitmasks;
 
-    public SliceFromReadCommand(String table, String key, ColumnParent column_parent, byte[] start, byte[] finish, boolean reversed, int count)
+    public SliceFromReadCommand(String table, byte[] key, ColumnParent column_parent, byte[] start, byte[] finish, boolean reversed, int count)
     {
         this(table, key, new QueryPath(column_parent), start, finish, null, reversed, count);
     }
 
-    public SliceFromReadCommand(String table, String key, QueryPath path, byte[] start, byte[] finish, boolean reversed, int count)
+    public SliceFromReadCommand(String table, byte[] key, QueryPath path, byte[] start, byte[] finish, boolean reversed, int count)
     {
         this(table, key, path, start, finish, null, reversed, count);
     }
 
-    public SliceFromReadCommand(String table, String key, QueryPath path, byte[] start, byte[] finish, List<byte[]> bitmasks, boolean reversed, int count)
+    public SliceFromReadCommand(String table, byte[] key, QueryPath path, byte[] start, byte[] finish, List<byte[]> bitmasks, boolean reversed, int count)
     {
         super(table, key, path, CMD_TYPE_GET_SLICE);
         this.start = start;
@@ -66,7 +67,8 @@ public ReadCommand copy()
     @Override
     public Row getRow(Table table) throws IOException
     {
-        return table.getRow(QueryFilter.getSliceFilter(key, queryPath, start, finish, bitmasks, reversed, count));
+        DecoratedKey dk = StorageService.getPartitioner().decorateKey(key);
+        return table.getRow(QueryFilter.getSliceFilter(dk, queryPath, start, finish, bitmasks, reversed, count));
     }
 
     @Override
@@ -76,7 +78,7 @@ public String toString()
 
         return "SliceFromReadCommand(" +
                "table='" + table + '\'' +
-               ", key='" + key + '\'' +
+               ", key='" + FBUtilities.bytesToHex(key) + '\'' +
                ", column_parent='" + queryPath + '\'' +
                ", start='" + getComparator().getString(start) + '\'' +
                ", finish='" + getComparator().getString(finish) + '\'' +
@@ -115,7 +117,7 @@ public void serialize(ReadCommand rm, DataOutputStream dos) throws IOException
         SliceFromReadCommand realRM = (SliceFromReadCommand)rm;
         dos.writeBoolean(realRM.isDigestQuery());
         dos.writeUTF(realRM.table);
-        dos.writeUTF(realRM.key);
+        FBUtilities.writeShortByteArray(realRM.key, dos);
         realRM.queryPath.serialize(dos);
         FBUtilities.writeShortByteArray(realRM.start, dos);
         FBUtilities.writeShortByteArray(realRM.finish, dos);
@@ -129,7 +131,7 @@ public ReadCommand deserialize(DataInputStream dis) throws IOException
     {
         boolean isDigest = dis.readBoolean();
         SliceFromReadCommand rm = new SliceFromReadCommand(dis.readUTF(),
-                                                           dis.readUTF(),
+                                                           FBUtilities.readShortByteArray(dis),
                                                            QueryPath.deserialize(dis),
                                                            FBUtilities.readShortByteArray(dis),
                                                            FBUtilities.readShortByteArray(dis),
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/SystemTable.java b/cassandra/trunk/src/java/org/apache/cassandra/db/SystemTable.java
index 687df851..396dc8f4 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/SystemTable.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/SystemTable.java
@@ -24,6 +24,7 @@
 
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.utils.FBUtilities;
+import static org.apache.cassandra.utils.FBUtilities.UTF8;
 
 import org.apache.commons.lang.ArrayUtils;
 import org.slf4j.Logger;
@@ -46,25 +47,18 @@
 {
     private static Logger logger = LoggerFactory.getLogger(SystemTable.class);
     public static final String STATUS_CF = "LocationInfo"; // keep the old CF string for backwards-compatibility
-    private static final String LOCATION_KEY = "L";
-    private static final String BOOTSTRAP_KEY = "Bootstrap";
-    private static final String GRAVEYARD_KEY = "Graveyard";
-    private static final byte[] BOOTSTRAP = utf8("B");
-    private static final byte[] TOKEN = utf8("Token");
-    private static final byte[] GENERATION = utf8("Generation");
-    private static final byte[] CLUSTERNAME = utf8("ClusterName");
+    private static final byte[] LOCATION_KEY = "L".getBytes(UTF8);
+    private static final byte[] BOOTSTRAP_KEY = "Bootstrap".getBytes(UTF8);
+    private static final byte[] GRAVEYARD_KEY = "Graveyard".getBytes(UTF8);
+    private static final byte[] BOOTSTRAP = "B".getBytes(UTF8);
+    private static final byte[] TOKEN = "Token".getBytes(UTF8);
+    private static final byte[] GENERATION = "Generation".getBytes(UTF8);
+    private static final byte[] CLUSTERNAME = "ClusterName".getBytes(UTF8);
     private static StorageMetadata metadata;
 
-    private static byte[] utf8(String str)
+    private static DecoratedKey decorate(byte[] key)
     {
-        try
-        {
-            return str.getBytes("UTF-8");
-        }
-        catch (UnsupportedEncodingException e)
-        {
-            throw new RuntimeException(e);
-        }
+        return StorageService.getPartitioner().decorateKey(key);
     }
 
     /**
@@ -123,15 +117,15 @@ public static synchronized StorageMetadata initMetadata() throws IOException
             return metadata;
 
         /* Read the system table to retrieve the storage ID and the generation */
+        IPartitioner p = StorageService.getPartitioner();
         Table table = Table.open(Table.SYSTEM_TABLE);
         SortedSet<byte[]> columns = new TreeSet<byte[]>(new BytesType());
         columns.add(TOKEN);
         columns.add(GENERATION);
         columns.add(CLUSTERNAME);
-        QueryFilter filter = QueryFilter.getNamesFilter(LOCATION_KEY, new QueryPath(STATUS_CF), columns);
+        QueryFilter filter = QueryFilter.getNamesFilter(decorate(LOCATION_KEY), new QueryPath(STATUS_CF), columns);
         ColumnFamily cf = table.getColumnFamilyStore(STATUS_CF).getColumnFamily(filter);
 
-        IPartitioner p = StorageService.getPartitioner();
         if (cf == null)
         {
             Token token;
@@ -199,9 +193,10 @@ public static synchronized StorageMetadata initMetadata() throws IOException
 
     public static boolean isBootstrapped()
     {
-        Table table = null;
-        table = Table.open(Table.SYSTEM_TABLE);
-        QueryFilter filter = QueryFilter.getNamesFilter(BOOTSTRAP_KEY, new QueryPath(STATUS_CF), BOOTSTRAP);
+        Table table = Table.open(Table.SYSTEM_TABLE);
+        QueryFilter filter = QueryFilter.getNamesFilter(decorate(BOOTSTRAP_KEY),
+                                                        new QueryPath(STATUS_CF),
+                                                        BOOTSTRAP);
         ColumnFamily cf = table.getColumnFamilyStore(STATUS_CF).getColumnFamily(filter);
         return cf != null && cf.getColumn(BOOTSTRAP).value()[0] == 1;
     }
@@ -225,7 +220,7 @@ public static void setBootstrapped(boolean isBootstrapped)
     public static ColumnFamily getDroppedCFs() throws IOException
     {
         ColumnFamilyStore cfs = Table.open(Table.SYSTEM_TABLE).getColumnFamilyStore(SystemTable.STATUS_CF);
-        return cfs.getColumnFamily(QueryFilter.getSliceFilter(SystemTable.GRAVEYARD_KEY, new QueryPath(STATUS_CF), "".getBytes(), "".getBytes(), null, false, 100));
+        return cfs.getColumnFamily(QueryFilter.getSliceFilter(decorate(GRAVEYARD_KEY), new QueryPath(STATUS_CF), "".getBytes(), "".getBytes(), null, false, 100));
     }
     
     public static void deleteDroppedCfMarkers(Collection<IColumn> cols) throws IOException
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/Table.java b/cassandra/trunk/src/java/org/apache/cassandra/db/Table.java
index e7a9e6c8..8ff98cd8 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/Table.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/Table.java
@@ -343,6 +343,7 @@ public void apply(RowMutation mutation, Object serializedMutation, boolean write
                 }
             }
         
+            DecoratedKey key = StorageService.getPartitioner().decorateKey(mutation.key());
             for (ColumnFamily columnFamily : mutation.getColumnFamilies())
             {
                 Memtable memtableToFlush;
@@ -353,10 +354,10 @@ public void apply(RowMutation mutation, Object serializedMutation, boolean write
                 }
                 else
                 {
-                    if ((memtableToFlush=cfs.apply(mutation.key(), columnFamily)) != null)
+                    if ((memtableToFlush=cfs.apply(key, columnFamily)) != null)
                         memtablesToFlush.put(cfs, memtableToFlush);
     
-                    ColumnFamily cachedRow = cfs.getRawCachedRow(mutation.key());
+                    ColumnFamily cachedRow = cfs.getRawCachedRow(key);
                     if (cachedRow != null)
                         cachedRow.addAll(columnFamily);
                 }
@@ -387,8 +388,7 @@ public void apply(RowMutation mutation, Object serializedMutation, boolean write
     // for binary load path.  skips commitlog.
     void load(RowMutation rowMutation) throws IOException
     {
-        String key = rowMutation.key();
-                
+        DecoratedKey key = StorageService.getPartitioner().decorateKey(rowMutation.key());
         for (ColumnFamily columnFamily : rowMutation.getColumnFamilies())
         {
             Collection<IColumn> columns = columnFamily.getSortedColumns();
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/WriteResponse.java b/cassandra/trunk/src/java/org/apache/cassandra/db/WriteResponse.java
index e4b9dee5..3f7c2db3 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/WriteResponse.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/WriteResponse.java
@@ -51,10 +51,10 @@ public static Message makeWriteResponseMessage(Message original, WriteResponse w
     }
 
 	private final String table_;
-	private final String key_;
+	private final byte[] key_;
 	private final boolean status_;
 
-	public WriteResponse(String table, String key, boolean bVal) {
+	public WriteResponse(String table, byte[] key, boolean bVal) {
 		table_ = table;
 		key_ = key;
 		status_ = bVal;
@@ -65,7 +65,7 @@ public String table()
 		return table_;
 	}
 
-	public String key()
+	public byte[] key()
 	{
 		return key_;
 	}
@@ -80,14 +80,14 @@ public boolean isSuccess()
         public void serialize(WriteResponse wm, DataOutputStream dos) throws IOException
         {
             dos.writeUTF(wm.table());
-            dos.writeUTF(wm.key());
+            FBUtilities.writeShortByteArray(wm.key(), dos);
             dos.writeBoolean(wm.isSuccess());
         }
 
         public WriteResponse deserialize(DataInputStream dis) throws IOException
         {
             String table = dis.readUTF();
-            String key = dis.readUTF();
+            byte[] key = FBUtilities.readShortByteArray(dis);
             boolean status = dis.readBoolean();
             return new WriteResponse(table, key, status);
         }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/IFilter.java b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/IFilter.java
index de17c989..9dbe228b 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/IFilter.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/IFilter.java
@@ -57,7 +57,7 @@
      * returns an iterator that returns columns from the given SSTable
      * matching the Filter criteria in sorted order.
      */
-    public abstract IColumnIterator getSSTableColumnIterator(SSTableReader sstable, String key);
+    public abstract IColumnIterator getSSTableColumnIterator(SSTableReader sstable, DecoratedKey key);
 
     /**
      * collects columns from reducedColumns into returnCF.  Termination is determined
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/IdentityQueryFilter.java b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/IdentityQueryFilter.java
index 6fcc5d9f..8185bfad 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/IdentityQueryFilter.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/IdentityQueryFilter.java
@@ -23,6 +23,7 @@
 
 import org.apache.commons.lang.ArrayUtils;
 
+import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.SuperColumn;
 
 class IdentityQueryFilter extends SliceQueryFilter
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
index 9f95393d..2d703a42 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/NamesQueryFilter.java
@@ -61,7 +61,7 @@ public IColumnIterator getMemtableColumnIterator(ColumnFamily cf, DecoratedKey k
         return Memtable.getNamesIterator(key, cf, this);
     }
 
-    public IColumnIterator getSSTableColumnIterator(SSTableReader sstable, String key)
+    public IColumnIterator getSSTableColumnIterator(SSTableReader sstable, DecoratedKey key)
     {
         return new SSTableNamesIterator(sstable, key, columns);
     }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/QueryFilter.java b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/QueryFilter.java
index 788a81ff..fa23ce80 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/QueryFilter.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/QueryFilter.java
@@ -32,12 +32,12 @@
 
 public class QueryFilter
 {
-    public final String key;
+    public final DecoratedKey key;
     public final QueryPath path;
     private final IFilter filter;
     private final IFilter superFilter;
 
-    protected QueryFilter(String key, QueryPath path, IFilter filter)
+    protected QueryFilter(DecoratedKey key, QueryPath path, IFilter filter)
     {
         this.key = key;
         this.path = path;
@@ -50,7 +50,7 @@ public IColumnIterator getMemtableColumnIterator(Memtable memtable, AbstractType
         ColumnFamily cf = memtable.getColumnFamily(key);
         if (cf == null)
             return null;
-        return getMemtableColumnIterator(cf, StorageService.getPartitioner().decorateKey(key), comparator);
+        return getMemtableColumnIterator(cf, key, comparator);
     }
 
     public IColumnIterator getMemtableColumnIterator(ColumnFamily cf, DecoratedKey key, AbstractType comparator)
@@ -153,7 +153,7 @@ public static boolean isRelevant(IColumn column, IColumnContainer container, int
      * @param reversed true to start with the largest column (as determined by configured sort order) instead of smallest
      * @param limit maximum number of non-deleted columns to return
      */
-    public static QueryFilter getSliceFilter(String key, QueryPath path, byte[] start, byte[] finish, List<byte[]> bitmasks, boolean reversed, int limit)
+    public static QueryFilter getSliceFilter(DecoratedKey key, QueryPath path, byte[] start, byte[] finish, List<byte[]> bitmasks, boolean reversed, int limit)
     {
         return new QueryFilter(key, path, new SliceQueryFilter(start, finish, bitmasks, reversed, limit));
     }
@@ -162,7 +162,7 @@ public static QueryFilter getSliceFilter(String key, QueryPath path, byte[] star
      * return a QueryFilter object that includes every column in the row.
      * This is dangerous on large rows; avoid except for test code.
      */
-    public static QueryFilter getIdentityFilter(String key, QueryPath path)
+    public static QueryFilter getIdentityFilter(DecoratedKey key, QueryPath path)
     {
         return new QueryFilter(key, path, new IdentityQueryFilter());
     }
@@ -173,7 +173,7 @@ public static QueryFilter getIdentityFilter(String key, QueryPath path)
      * @param path path to the level to slice at (CF or SuperColumn)
      * @param columns the column names to restrict the results to
      */
-    public static QueryFilter getNamesFilter(String key, QueryPath path, SortedSet<byte[]> columns)
+    public static QueryFilter getNamesFilter(DecoratedKey key, QueryPath path, SortedSet<byte[]> columns)
     {
         return new QueryFilter(key, path, new NamesQueryFilter(columns));
     }
@@ -181,7 +181,7 @@ public static QueryFilter getNamesFilter(String key, QueryPath path, SortedSet<b
     /**
      * convenience method for creating a name filter matching a single column
      */
-    public static QueryFilter getNamesFilter(String key, QueryPath path, byte[] column)
+    public static QueryFilter getNamesFilter(DecoratedKey key, QueryPath path, byte[] column)
     {
         return new QueryFilter(key, path, new NamesQueryFilter(column));
     }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SSTableNamesIterator.java b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SSTableNamesIterator.java
index ec8a2b49..544f90e7 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SSTableNamesIterator.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SSTableNamesIterator.java
@@ -46,11 +46,11 @@
     private ColumnFamily cf;
     private Iterator<IColumn> iter;
     public final SortedSet<byte[]> columns;
-    private DecoratedKey decoratedKey;
+    public final DecoratedKey decoratedKey;
     
-    public SSTableNamesIterator(SSTableReader ssTable, String key, SortedSet<byte[]> columnNames)
+    public SSTableNamesIterator(SSTableReader ssTable, DecoratedKey key, SortedSet<byte[]> columnNames)
     {
-        this (ssTable, null, ssTable.getPartitioner().decorateKey(key), columnNames);
+        this (ssTable, null, key, columnNames);
     }
 
     public SSTableNamesIterator(SSTableReader ssTable, FileDataInput file, DecoratedKey key, SortedSet<byte[]> columnNames)
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SSTableSliceIterator.java b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SSTableSliceIterator.java
index 931e47d0..3a1e5f49 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SSTableSliceIterator.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SSTableSliceIterator.java
@@ -52,9 +52,9 @@
     private boolean closeFileWhenDone = false;
     private DecoratedKey decoratedKey;
     
-    public SSTableSliceIterator(SSTableReader ssTable, String key, byte[] startColumn, byte[] finishColumn, Predicate<IColumn> predicate, boolean reversed)
+    public SSTableSliceIterator(SSTableReader ssTable, DecoratedKey key, byte[] startColumn, byte[] finishColumn, Predicate<IColumn> predicate, boolean reversed)
     {
-        this(ssTable, null, ssTable.getPartitioner().decorateKey(key), startColumn, finishColumn, predicate, reversed); 
+        this(ssTable, null, key, startColumn, finishColumn, predicate, reversed); 
     }
     
     public SSTableSliceIterator(SSTableReader ssTable, FileDataInput file, DecoratedKey key, byte[] startColumn, byte[] finishColumn, Predicate<IColumn> predicate, boolean reversed) 
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
index 96323da8..12df52b6 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
@@ -63,7 +63,7 @@ public IColumnIterator getMemtableColumnIterator(ColumnFamily cf, DecoratedKey k
         return Memtable.getSliceIterator(key, cf, this, comparator);
     }
 
-    public IColumnIterator getSSTableColumnIterator(SSTableReader sstable, String key)
+    public IColumnIterator getSSTableColumnIterator(SSTableReader sstable, DecoratedKey key)
     {
         return new SSTableSliceIterator(sstable, key, start, finish, getPredicate(), reversed);
     }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/Migration.java b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/Migration.java
index d6b315b1..1b160298 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/Migration.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/Migration.java
@@ -23,6 +23,7 @@
 import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.ColumnFamilyStore;
 import org.apache.cassandra.db.CompactionManager;
+import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.RowMutation;
 import org.apache.cassandra.db.Table;
@@ -34,7 +35,9 @@
 import org.apache.cassandra.gms.Gossiper;
 import org.apache.cassandra.io.ICompactSerializer;
 import org.apache.cassandra.service.MigrationManager;
+import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.UUIDGen;
+import static org.apache.cassandra.utils.FBUtilities.UTF8;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -75,8 +78,8 @@
     
     public static final String MIGRATIONS_CF = "Migrations";
     public static final String SCHEMA_CF = "Schema";
-    public static final String MIGRATIONS_KEY = "Migrations Key";
-    public static final String LAST_MIGRATION_KEY = "Last Migration";
+    public static final byte[] MIGRATIONS_KEY = "Migrations Key".getBytes(UTF8);
+    public static final byte[] LAST_MIGRATION_KEY = "Last Migration".getBytes(UTF8);
     
     protected RowMutation rm;
     protected final UUID newVersion;
@@ -108,7 +111,7 @@ public final void apply() throws IOException
         // note that we storing this in the system table, which is not replicated, instead of the definitions table, which is.
         logger.debug("Applying migration " + newVersion.toString());
         migration = new RowMutation(Table.DEFINITIONS, LAST_MIGRATION_KEY);
-        migration.add(new QueryPath(SCHEMA_CF, null, LAST_MIGRATION_KEY.getBytes()), UUIDGen.decompose(newVersion), now);
+        migration.add(new QueryPath(SCHEMA_CF, null, LAST_MIGRATION_KEY), UUIDGen.decompose(newVersion), now);
         migration.apply();
         
         // flush changes out of memtables so we don't need to rely on the commit log.
@@ -141,14 +144,15 @@ public final void announce()
     
     public static UUID getLastMigrationId()
     {
+        DecoratedKey dkey = StorageService.getPartitioner().decorateKey(LAST_MIGRATION_KEY);
         Table defs = Table.open(Table.DEFINITIONS);
         ColumnFamilyStore cfStore = defs.getColumnFamilyStore(SCHEMA_CF);
-        QueryFilter filter = QueryFilter.getNamesFilter(LAST_MIGRATION_KEY, new QueryPath(SCHEMA_CF), LAST_MIGRATION_KEY.getBytes());
+        QueryFilter filter = QueryFilter.getNamesFilter(dkey, new QueryPath(SCHEMA_CF), LAST_MIGRATION_KEY);
         ColumnFamily cf = cfStore.getColumnFamily(filter);
         if (cf == null || cf.getColumnNames().size() == 0)
             return null;
         else
-            return UUIDGen.makeType1UUID(cf.getColumn(LAST_MIGRATION_KEY.getBytes()).value());
+            return UUIDGen.makeType1UUID(cf.getColumn(LAST_MIGRATION_KEY).value());
     }
     
     /** keep in mind that applyLive might happen on another machine */
@@ -175,7 +179,7 @@ public UUID getVersion()
     static RowMutation makeDefinitionMutation(KSMetaData add, KSMetaData remove, UUID versionId) throws IOException
     {
         final long now = System.currentTimeMillis();
-        RowMutation rm = new RowMutation(Table.DEFINITIONS, versionId.toString());
+        RowMutation rm = new RowMutation(Table.DEFINITIONS, toBytes(versionId));
         if (remove != null)
             rm.delete(new QueryPath(SCHEMA_CF, null, remove.name.getBytes()), System.currentTimeMillis());
         if (add != null)
@@ -226,11 +230,16 @@ public static Migration deserialize(InputStream in) throws IOException
     /** load serialized migrations. */
     public static Collection<IColumn> getLocalMigrations(UUID start, UUID end)
     {
+        DecoratedKey dkey = StorageService.getPartitioner().decorateKey(MIGRATIONS_KEY);
         Table defs = Table.open(Table.DEFINITIONS);
         ColumnFamilyStore cfStore = defs.getColumnFamilyStore(Migration.MIGRATIONS_CF);
-        QueryFilter filter = QueryFilter.getSliceFilter(Migration.MIGRATIONS_KEY, new QueryPath(MIGRATIONS_CF), UUIDGen.decompose(start), UUIDGen.decompose(end), null, false, 1000);
+        QueryFilter filter = QueryFilter.getSliceFilter(dkey, new QueryPath(MIGRATIONS_CF), UUIDGen.decompose(start), UUIDGen.decompose(end), null, false, 1000);
         ColumnFamily cf = cfStore.getColumnFamily(filter);
         return cf.getSortedColumns();
     }
     
+    public static byte[] toBytes(UUID version)
+    {
+        return version.toString().getBytes(UTF8);
+    }
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/dht/CollatingOrderPreservingPartitioner.java b/cassandra/trunk/src/java/org/apache/cassandra/dht/CollatingOrderPreservingPartitioner.java
index 547d81d6..27d60330 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/dht/CollatingOrderPreservingPartitioner.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/dht/CollatingOrderPreservingPartitioner.java
@@ -39,15 +39,14 @@
     
     public static final BigInteger BYTE_MASK = new BigInteger("255");
 
-    public DecoratedKey<BytesToken> decorateKey(String key)
+    public DecoratedKey<BytesToken> decorateKey(byte[] key)
     {
         return new DecoratedKey<BytesToken>(getToken(key), key);
     }
     
-    public DecoratedKey<BytesToken> convertFromDiskFormat(byte[] fromdisk)
+    public DecoratedKey<BytesToken> convertFromDiskFormat(byte[] key)
     {
-        String key = new String(fromdisk, FBUtilities.UTF8);
-        return new DecoratedKey<BytesToken>(getToken(key), fromdisk);
+        return new DecoratedKey<BytesToken>(getToken(key), key);
     }
 
     public byte[] convertToDiskFormat(DecoratedKey<BytesToken> key)
@@ -147,10 +146,11 @@ public boolean preservesOrder()
         return true;
     }
 
-    public BytesToken getToken(String key)
+    public BytesToken getToken(byte[] key)
     {
-        if (key.isEmpty())
+        if (key.length == 0)
             return MINIMUM;
-        return new BytesToken(collator.getCollationKey(key).toByteArray());
+        String skey = new String(key, FBUtilities.UTF8);
+        return new BytesToken(collator.getCollationKey(skey).toByteArray());
     }
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/dht/IPartitioner.java b/cassandra/trunk/src/java/org/apache/cassandra/dht/IPartitioner.java
index acb521ef..d87b8e27 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/dht/IPartitioner.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/dht/IPartitioner.java
@@ -46,7 +46,7 @@
      * @return decorated version of key
      */
     @Deprecated
-    public DecoratedKey<T> decorateKey(String key);
+    public DecoratedKey<T> decorateKey(byte[] key);
 
     /**
      * Calculate a Token representing the approximate "middle" of the given
@@ -67,7 +67,7 @@
      * for that, use TokenFactory.fromString.)
      */
     @Deprecated
-    public T getToken(String key);
+    public T getToken(byte[] key);
 
     /**
      * @return a randomly generated token
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/dht/OrderPreservingPartitioner.java b/cassandra/trunk/src/java/org/apache/cassandra/dht/OrderPreservingPartitioner.java
index a599a434..9e1522e0 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/dht/OrderPreservingPartitioner.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/dht/OrderPreservingPartitioner.java
@@ -35,15 +35,14 @@
 
     public static final BigInteger CHAR_MASK = new BigInteger("65535");
 
-    public DecoratedKey<StringToken> decorateKey(String key)
+    public DecoratedKey<StringToken> decorateKey(byte[] key)
     {
-        return new DecoratedKey<StringToken>(new StringToken(key), key);
+        return new DecoratedKey<StringToken>(getToken(key), key);
     }
     
-    public DecoratedKey<StringToken> convertFromDiskFormat(byte[] fromdisk)
+    public DecoratedKey<StringToken> convertFromDiskFormat(byte[] key)
     {
-        String key = new String(fromdisk, FBUtilities.UTF8);
-        return new DecoratedKey<StringToken>(new StringToken(key), fromdisk);
+        return new DecoratedKey<StringToken>(getToken(key), key);
     }
 
     public byte[] convertToDiskFormat(DecoratedKey<StringToken> key)
@@ -162,8 +161,8 @@ public boolean preservesOrder()
         return true;
     }
 
-    public StringToken getToken(String key)
+    public StringToken getToken(byte[] key)
     {
-        return new StringToken(key);
+        return new StringToken(new String(key, FBUtilities.UTF8));
     }
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/dht/RandomPartitioner.java b/cassandra/trunk/src/java/org/apache/cassandra/dht/RandomPartitioner.java
index 36dad8c3..794c22a2 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/dht/RandomPartitioner.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/dht/RandomPartitioner.java
@@ -40,7 +40,7 @@
 
     private static final byte DELIMITER_BYTE = ":".getBytes()[0];
 
-    public DecoratedKey<BigIntegerToken> decorateKey(String key)
+    public DecoratedKey<BigIntegerToken> decorateKey(byte[] key)
     {
         return new DecoratedKey<BigIntegerToken>(getToken(key), key);
     }
@@ -94,8 +94,7 @@ public BigIntegerToken getMinimumToken()
 
     public BigIntegerToken getRandomToken()
     {
-        String guid = GuidGenerator.guid();
-        BigInteger token = FBUtilities.hash(guid);
+        BigInteger token = FBUtilities.md5hash(GuidGenerator.guid().getBytes());
         if ( token.signum() == -1 )
             token = token.multiply(BigInteger.valueOf(-1L));
         return new BigIntegerToken(token);
@@ -133,10 +132,10 @@ public boolean preservesOrder()
         return false;
     }
 
-    public BigIntegerToken getToken(String key)
+    public BigIntegerToken getToken(byte[] key)
     {
-        if (key.isEmpty())
+        if (key.length == 0)
             return MINIMUM;
-        return new BigIntegerToken(FBUtilities.hash(key));
+        return new BigIntegerToken(FBUtilities.md5hash(key));
     }
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java b/cassandra/trunk/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
index c18b17cd..c1b33e50 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
@@ -36,6 +36,7 @@
 import org.apache.cassandra.thrift.*;
 import org.apache.cassandra.thrift.Column;
 import org.apache.cassandra.thrift.SuperColumn;
+import static org.apache.cassandra.utils.FBUtilities.UTF8;
 import org.apache.cassandra.utils.Pair;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.mapreduce.InputSplit;
@@ -158,7 +159,9 @@ else if (startToken.equals(split.getEndToken()))
                 // prepare for the next slice to be read
                 KeySlice lastRow = rows.get(rows.size() - 1);
                 IPartitioner p = DatabaseDescriptor.getPartitioner();
-                startToken = p.getTokenFactory().toString(p.getToken(lastRow.getKey()));
+                // FIXME: thrift strings
+                byte[] rowkey = lastRow.getKey().getBytes(UTF8);
+                startToken = p.getTokenFactory().toString(p.getToken(rowkey));
             }
             catch (Exception e)
             {
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/io/sstable/SSTableTracker.java b/cassandra/trunk/src/java/org/apache/cassandra/io/sstable/SSTableTracker.java
index a74e5cea..892550bc 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/io/sstable/SSTableTracker.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/io/sstable/SSTableTracker.java
@@ -44,7 +44,7 @@
     private final String cfname;
 
     private final JMXInstrumentedCache<Pair<SSTable.Descriptor,DecoratedKey>,SSTable.PositionSize> keyCache;
-    private final JMXInstrumentedCache<String, ColumnFamily> rowCache;
+    private final JMXInstrumentedCache<DecoratedKey, ColumnFamily> rowCache;
 
     public SSTableTracker(String ksname, String cfname)
     {
@@ -52,7 +52,7 @@ public SSTableTracker(String ksname, String cfname)
         this.cfname = cfname;
         sstables = Collections.emptySet();
         keyCache = new JMXInstrumentedCache<Pair<SSTable.Descriptor,DecoratedKey>,SSTable.PositionSize>(ksname, cfname + "KeyCache", 0);
-        rowCache = new JMXInstrumentedCache<String, ColumnFamily>(ksname, cfname + "RowCache", 0);
+        rowCache = new JMXInstrumentedCache<DecoratedKey, ColumnFamily>(ksname, cfname + "RowCache", 0);
     }
 
     public synchronized void replace(Collection<SSTableReader> oldSSTables, Iterable<SSTableReader> replacements)
@@ -139,7 +139,7 @@ public synchronized void clearUnsafe()
         sstables = Collections.emptySet();
     }
 
-    public JMXInstrumentedCache<String, ColumnFamily> getRowCache()
+    public JMXInstrumentedCache<DecoratedKey, ColumnFamily> getRowCache()
     {
         return rowCache;
     }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/service/RangeSliceResponseResolver.java b/cassandra/trunk/src/java/org/apache/cassandra/service/RangeSliceResponseResolver.java
index 92af6a12..bcff069d 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/service/RangeSliceResponseResolver.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/service/RangeSliceResponseResolver.java
@@ -29,6 +29,7 @@
 
 import com.google.common.collect.AbstractIterator;
 import org.apache.cassandra.db.ColumnFamily;
+import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.RangeSliceReply;
 import org.apache.cassandra.db.Row;
 import org.apache.cassandra.net.Message;
@@ -75,7 +76,7 @@ public int compare(Pair<Row,InetAddress> o1, Pair<Row,InetAddress> o2)
         {
             List<ColumnFamily> versions = new ArrayList<ColumnFamily>(sources.size());
             List<InetAddress> versionSources = new ArrayList<InetAddress>(sources.size());
-            String key;
+            DecoratedKey key;
 
             @Override
             protected boolean isEqual(Pair<Row, InetAddress> o1, Pair<Row, InetAddress> o2)
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/service/ReadResponseResolver.java b/cassandra/trunk/src/java/org/apache/cassandra/service/ReadResponseResolver.java
index ea781328..138dd0c3 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/service/ReadResponseResolver.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/service/ReadResponseResolver.java
@@ -26,11 +26,7 @@
 import java.util.Collection;
 import java.util.List;
 
-import org.apache.cassandra.db.ColumnFamily;
-import org.apache.cassandra.db.ReadResponse;
-import org.apache.cassandra.db.Row;
-import org.apache.cassandra.db.RowMutation;
-import org.apache.cassandra.db.RowMutationMessage;
+import org.apache.cassandra.db.*;
 import java.net.InetAddress;
 import org.apache.cassandra.net.Message;
 import org.apache.cassandra.utils.FBUtilities;
@@ -70,7 +66,7 @@ public Row resolve(Collection<Message> responses) throws DigestMismatchException
         long startTime = System.currentTimeMillis();
 		List<ColumnFamily> versions = new ArrayList<ColumnFamily>();
 		List<InetAddress> endPoints = new ArrayList<InetAddress>();
-		String key = null;
+		DecoratedKey key = null;
 		byte[] digest = new byte[0];
 		boolean isDigestQuery = false;
         
@@ -124,7 +120,7 @@ public Row resolve(Collection<Message> responses) throws DigestMismatchException
      * For each row version, compare with resolved (the superset of all row versions);
      * if it is missing anything, send a mutation to the endpoint it come from.
      */
-    public static void maybeScheduleRepairs(ColumnFamily resolved, String table, String key, List<ColumnFamily> versions, List<InetAddress> endPoints)
+    public static void maybeScheduleRepairs(ColumnFamily resolved, String table, DecoratedKey key, List<ColumnFamily> versions, List<InetAddress> endPoints)
     {
         for (int i = 0; i < versions.size(); i++)
         {
@@ -133,7 +129,7 @@ public static void maybeScheduleRepairs(ColumnFamily resolved, String table, Str
                 continue;
 
             // create and send the row mutation message based on the diff
-            RowMutation rowMutation = new RowMutation(table, key);
+            RowMutation rowMutation = new RowMutation(table, key.key);
             rowMutation.add(diffCf);
             RowMutationMessage rowMutationMessage = new RowMutationMessage(rowMutation);
             ReadRepairManager.instance.schedule(endPoints.get(i), rowMutationMessage);
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/service/StorageProxy.java b/cassandra/trunk/src/java/org/apache/cassandra/service/StorageProxy.java
index 214a7896..251877cf 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/service/StorageProxy.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/service/StorageProxy.java
@@ -82,15 +82,6 @@ private StorageProxy() {}
         }
     }
 
-    private static final Comparator<String> keyComparator = new Comparator<String>()
-    {
-        public int compare(String o1, String o2)
-        {
-            IPartitioner<?> p = StorageService.getPartitioner();
-            return p.decorateKey(o1).compareTo(p.decorateKey(o2));
-        }
-    };
-
     /**
      * Use this method to have these RowMutations applied
      * across all replicas. This method will take care
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/service/StorageService.java b/cassandra/trunk/src/java/org/apache/cassandra/service/StorageService.java
index 3604bde9..324d120d 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/service/StorageService.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/service/StorageService.java
@@ -1170,7 +1170,7 @@ public Range getPrimaryRangeForEndPoint(InetAddress ep)
      * @param key - key for which we need to find the endpoint return value -
      * the endpoint responsible for this key
      */
-    public List<InetAddress> getNaturalEndpoints(String table, String key)
+    public List<InetAddress> getNaturalEndpoints(String table, byte[] key)
     {
         return getNaturalEndpoints(table, partitioner_.getToken(key));
     }
@@ -1194,7 +1194,7 @@ public Range getPrimaryRangeForEndPoint(InetAddress ep)
      * @param key - key for which we need to find the endpoint return value -
      * the endpoint responsible for this key
      */
-    public List<InetAddress> getLiveNaturalEndpoints(String table, String key)
+    public List<InetAddress> getLiveNaturalEndpoints(String table, byte[] key)
     {
         return getLiveNaturalEndpoints(table, partitioner_.getToken(key));
     }
@@ -1216,7 +1216,7 @@ public Range getPrimaryRangeForEndPoint(InetAddress ep)
     /**
      * This function finds the closest live endpoint that contains a given key.
      */
-    public InetAddress findSuitableEndPoint(String table, String key) throws IOException, UnavailableException
+    public InetAddress findSuitableEndPoint(String table, byte[] key) throws IOException, UnavailableException
     {
         List<InetAddress> endpoints = getNaturalEndpoints(table, key);
         DatabaseDescriptor.getEndPointSnitch(table).sortByProximity(FBUtilities.getLocalAddress(), endpoints);
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/service/StorageServiceMBean.java b/cassandra/trunk/src/java/org/apache/cassandra/service/StorageServiceMBean.java
index a4eb1c6c..f189dd1c 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/service/StorageServiceMBean.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/service/StorageServiceMBean.java
@@ -89,7 +89,7 @@
      * @param key - key for which we need to find the endpoint return value -
      * the endpoint responsible for this key
      */
-    public List<InetAddress> getNaturalEndpoints(String key, String table);
+    public List<InetAddress> getNaturalEndpoints(String table, byte[] key);
 
     /**
      * Forces major compaction (all sstable files compacted)
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java b/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
index ed16b4f5..b3b37bcc 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
@@ -52,6 +52,7 @@
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.service.StorageProxy;
 import org.apache.cassandra.service.StorageService;
+import static org.apache.cassandra.utils.FBUtilities.UTF8;
 import org.apache.thrift.TException;
 
 public class CassandraServer implements Cassandra.Iface
@@ -83,11 +84,11 @@ public CassandraServer()
         storageService = StorageService.instance;
     }
     
-    protected Map<String, ColumnFamily> readColumnFamily(List<ReadCommand> commands, ConsistencyLevel consistency_level)
+    protected Map<byte[], ColumnFamily> readColumnFamily(List<ReadCommand> commands, ConsistencyLevel consistency_level)
     throws InvalidRequestException, UnavailableException, TimedOutException
     {
         // TODO - Support multiple column families per row, right now row only contains 1 column family
-        Map<String, ColumnFamily> columnFamilyKeyMap = new HashMap<String,ColumnFamily>();
+        Map<byte[], ColumnFamily> columnFamilyKeyMap = new HashMap<byte[],ColumnFamily>();
 
         if (consistency_level == ConsistencyLevel.ZERO)
         {
@@ -118,7 +119,7 @@ public CassandraServer()
 
         for (Row row: rows)
         {
-            columnFamilyKeyMap.put(row.key, row.cf);
+            columnFamilyKeyMap.put(row.key.key, row.cf);
         }
         return columnFamilyKeyMap;
     }
@@ -188,14 +189,15 @@ public CassandraServer()
     private Map<String, List<ColumnOrSuperColumn>> getSlice(List<ReadCommand> commands, ConsistencyLevel consistency_level)
     throws InvalidRequestException, UnavailableException, TimedOutException
     {
-        Map<String, ColumnFamily> columnFamilies = readColumnFamily(commands, consistency_level);
+        Map<byte[], ColumnFamily> columnFamilies = readColumnFamily(commands, consistency_level);
         Map<String, List<ColumnOrSuperColumn>> columnFamiliesMap = new HashMap<String, List<ColumnOrSuperColumn>>();
         for (ReadCommand command: commands)
         {
             ColumnFamily cf = columnFamilies.get(command.key);
             boolean reverseOrder = command instanceof SliceFromReadCommand && ((SliceFromReadCommand)command).reversed;
             List<ColumnOrSuperColumn> thriftifiedColumns = thriftifyColumnFamily(cf, command.queryPath.superColumnName != null, reverseOrder);
-            columnFamiliesMap.put(command.key, thriftifiedColumns);
+            // FIXME: string keys
+            columnFamiliesMap.put(new String(command.key, UTF8), thriftifiedColumns);
         }
 
         return columnFamiliesMap;
@@ -253,7 +255,8 @@ public CassandraServer()
             for (String key: keys)
             {
                 ThriftValidation.validateKey(key);
-                commands.add(new SliceByNamesReadCommand(keyspace, key, column_parent, predicate.column_names));
+                // FIXME: string keys
+                commands.add(new SliceByNamesReadCommand(keyspace, key.getBytes(UTF8), column_parent, predicate.column_names));
             }
         }
         else
@@ -262,7 +265,8 @@ public CassandraServer()
             for (String key: keys)
             {
                 ThriftValidation.validateKey(key);
-                commands.add(new SliceFromReadCommand(keyspace, key, column_parent, range.start, range.finish, range.reversed, range.count));
+                // FIXME: string keys
+                commands.add(new SliceFromReadCommand(keyspace, key.getBytes(UTF8), column_parent, range.start, range.finish, range.reversed, range.count));
             }
         }
 
@@ -308,23 +312,27 @@ public ColumnOrSuperColumn get(String table, String key, ColumnPath column_path,
         for (String key: keys)
         {
             ThriftValidation.validateKey(key);
-            commands.add(new SliceByNamesReadCommand(table, key, path, nameAsList));
+            // FIXME: string keys
+            commands.add(new SliceByNamesReadCommand(table, key.getBytes(UTF8), path, nameAsList));
         }
 
         Map<String, ColumnOrSuperColumn> columnFamiliesMap = new HashMap<String, ColumnOrSuperColumn>();
-        Map<String, ColumnFamily> cfamilies = readColumnFamily(commands, consistency_level);
+        Map<byte[], ColumnFamily> cfamilies = readColumnFamily(commands, consistency_level);
+
 
         for (ReadCommand command: commands)
         {
             ColumnFamily cf = cfamilies.get(command.key);
+            // FIXME: string keys
+            String skey = new String(command.key, UTF8);
             if (cf == null)
             {
-                columnFamiliesMap.put(command.key, new ColumnOrSuperColumn());
+                columnFamiliesMap.put(skey, new ColumnOrSuperColumn());
             }
             else
             {
                 List<ColumnOrSuperColumn> tcolumns = thriftifyColumnFamily(cf, command.queryPath.superColumnName != null, false);
-                columnFamiliesMap.put(command.key, tcolumns.size() > 0 ? tcolumns.iterator().next() : new ColumnOrSuperColumn());
+                columnFamiliesMap.put(skey, tcolumns.size() > 0 ? tcolumns.iterator().next() : new ColumnOrSuperColumn());
             }
         }
 
@@ -355,7 +363,8 @@ public void insert(String table, String key, ColumnPath column_path, byte[] valu
         ThriftValidation.validateKey(key);
         ThriftValidation.validateColumnPath(table, column_path);
 
-        RowMutation rm = new RowMutation(table, key);
+        // FIXME: string keys
+        RowMutation rm = new RowMutation(table, key.getBytes(UTF8));
         try
         {
             rm.add(new QueryPath(column_path), value, timestamp);
@@ -385,7 +394,8 @@ public void batch_insert(String keyspace, String key, Map<String, List<ColumnOrS
             }
         }
 
-        doInsert(consistency_level, RowMutation.getRowMutation(keyspace, key, cfmap));
+        // FIXME: string keys
+        doInsert(consistency_level, RowMutation.getRowMutation(keyspace, key.getBytes(UTF8), cfmap));
     }
 
     public void batch_mutate(String keyspace, Map<String,Map<String,List<Mutation>>> mutation_map, ConsistencyLevel consistency_level)
@@ -430,7 +440,8 @@ public void batch_mutate(String keyspace, Map<String,Map<String,List<Mutation>>>
                     ThriftValidation.validateMutation(keyspace, cfName, mutation);
                 }
             }
-            rowMutations.add(RowMutation.getRowMutationFromMutations(keyspace, key, columnFamilyToMutations));
+            // FIXME: string keys
+            rowMutations.add(RowMutation.getRowMutationFromMutations(keyspace, key.getBytes(UTF8), columnFamilyToMutations));
         }
         if (consistency_level == ConsistencyLevel.ZERO)
         {
@@ -460,7 +471,8 @@ public void remove(String table, String key, ColumnPath column_path, long timest
         ThriftValidation.validateKey(key);
         ThriftValidation.validateColumnPathOrParent(table, column_path);
         
-        RowMutation rm = new RowMutation(table, key);
+        // FIXME: string keys
+        RowMutation rm = new RowMutation(table, key.getBytes(UTF8));
         rm.delete(new QueryPath(column_path), timestamp);
 
         doInsert(consistency_level, rm);
@@ -553,7 +565,8 @@ private void doInsert(ConsistencyLevel consistency_level, RowMutation rm) throws
             }
             else
             {
-                bounds = new Bounds(p.getToken(range.start_key), p.getToken(range.end_key));
+                // FIXME: string keys
+                bounds = new Bounds(p.getToken(range.start_key.getBytes(UTF8)), p.getToken(range.end_key.getBytes(UTF8)));
             }
             rows = StorageProxy.getRangeSlice(new RangeSliceCommand(keyspace, column_parent, predicate, bounds, range.count), consistency_level);
             assert rows != null;
@@ -572,7 +585,8 @@ private void doInsert(ConsistencyLevel consistency_level, RowMutation rm) throws
         for (Row row : rows)
         {
             List<ColumnOrSuperColumn> thriftifiedColumns = thriftifyColumnFamily(row.cf, column_parent.super_column != null, reversed);
-            keySlices.add(new KeySlice(row.key, thriftifiedColumns));
+            // FIXME: string keys
+            keySlices.add(new KeySlice(new String(row.key.key, UTF8), thriftifiedColumns));
         }
 
         return keySlices;
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/thrift/ThriftValidation.java b/cassandra/trunk/src/java/org/apache/cassandra/thrift/ThriftValidation.java
index eb31b295..6ac961d2 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/thrift/ThriftValidation.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/thrift/ThriftValidation.java
@@ -303,8 +303,9 @@ public static void validateKeyRange(KeyRange range) throws InvalidRequestExcepti
         if (range.start_key != null)
         {
             IPartitioner p = StorageService.getPartitioner();
-            Token startToken = p.decorateKey(range.start_key).token;
-            Token endToken = p.decorateKey(range.end_key).token;
+            // FIXME: string keys
+            Token startToken = p.getToken(range.start_key.getBytes(FBUtilities.UTF8));
+            Token endToken = p.getToken(range.end_key.getBytes(FBUtilities.UTF8));
             if (startToken.compareTo(endToken) > 0 && !endToken.equals(p.getMinimumToken()))
             {
                 if (p instanceof RandomPartitioner)
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeProbe.java b/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeProbe.java
index ac4cdfca..6f90992c 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeProbe.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeProbe.java
@@ -48,6 +48,7 @@
 import org.apache.cassandra.service.StorageServiceMBean;
 import org.apache.cassandra.streaming.StreamingService;
 import org.apache.cassandra.streaming.StreamingServiceMBean;
+import static org.apache.cassandra.utils.FBUtilities.UTF8;
 
 /**
  * JMX client operations for Cassandra.
@@ -402,7 +403,8 @@ public void setCacheCapacities(String tableName, String cfName, int keyCacheCapa
 
     public List<InetAddress> getEndPoints(String keyspace, String key)
     {
-        return ssProxy.getNaturalEndpoints(keyspace, key);
+        // FIXME: string key
+        return ssProxy.getNaturalEndpoints(keyspace, key.getBytes(UTF8));
     }
 
     public Set<InetAddress> getStreamDestinations()
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableExport.java b/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableExport.java
index e4ea24d7..42995643 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableExport.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableExport.java
@@ -38,6 +38,7 @@
 import org.apache.cassandra.utils.FBUtilities;
 
 import static org.apache.cassandra.utils.FBUtilities.bytesToHex;
+import static org.apache.cassandra.utils.FBUtilities.UTF8;
 import org.apache.commons.cli.*;
 
 /**
@@ -212,7 +213,8 @@ public static void export(String ssTableFile, PrintStream outs, String[] keys, S
         {
             if (excludeSet.contains(key))
                 continue;
-            DecoratedKey<?> dk = partitioner.decorateKey(key);
+            // FIXME: assuming string keys
+            DecoratedKey<?> dk = partitioner.decorateKey(key.getBytes(UTF8));
             scanner.seekTo(dk);
             
             i++;
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableImport.java b/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableImport.java
index a0aeec5a..357ff576 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableImport.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableImport.java
@@ -31,6 +31,7 @@
 import org.apache.cassandra.io.sstable.SSTableWriter;
 import org.apache.cassandra.utils.FBUtilities;
 import static org.apache.cassandra.utils.FBUtilities.hexToBytes;
+import static org.apache.cassandra.utils.FBUtilities.UTF8;
 import org.apache.commons.cli.*;
 import org.json.simple.JSONArray;
 import org.json.simple.JSONObject;
@@ -153,7 +154,8 @@ public static void importJson(String jsonFile, String keyspace, String cf, Strin
             List<DecoratedKey<?>> decoratedKeys = new ArrayList<DecoratedKey<?>>();
             
             for (String key : (Set<String>)json.keySet())
-                decoratedKeys.add(partitioner.decorateKey(key));
+                // FIXME: assuming string keys
+                decoratedKeys.add(partitioner.decorateKey(key.getBytes(UTF8)));
             Collections.sort(decoratedKeys);
 
             for (DecoratedKey<?> rowKey : decoratedKeys)
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/utils/FBUtilities.java b/cassandra/trunk/src/java/org/apache/cassandra/utils/FBUtilities.java
index b6df08d3..4a896f3e 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/utils/FBUtilities.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/utils/FBUtilities.java
@@ -236,9 +236,9 @@ public static int compareByteArrays(byte[] bytes1, byte[] bytes2){
         return out;
     }
 
-    public static BigInteger hash(String data)
+    public static BigInteger md5hash(byte[] data)
     {
-        byte[] result = hash("MD5", data.getBytes());
+        byte[] result = hash("MD5", data);
         BigInteger hash = new BigInteger(result);
         return hash.abs();        
     }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/Util.java b/cassandra/trunk/test/unit/org/apache/cassandra/Util.java
index eb3afef4..33711970 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/Util.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/Util.java
@@ -32,19 +32,28 @@
 
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.filter.QueryPath;
-import org.apache.cassandra.dht.Bounds;
-import org.apache.cassandra.dht.Range;
-import org.apache.cassandra.dht.Token;
+import org.apache.cassandra.dht.*;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.thrift.SliceRange;
+import static org.apache.cassandra.utils.FBUtilities.UTF8;
 
 public class Util
 {
+    public static DecoratedKey dk(String key)
+    {
+        return StorageService.getPartitioner().decorateKey(key.getBytes(UTF8));
+    }
+
     public static Column column(String name, String value, long timestamp)
     {
         return new Column(name.getBytes(), value.getBytes(), timestamp);
     }
 
+    public static Range range(IPartitioner p, String left, String right)
+    {
+        return new Range(p.getToken(left.getBytes()), p.getToken(right.getBytes()));
+    }
+
     public static void addMutation(RowMutation rm, String columnFamilyName, String superColumnName, long columnName, String value, long timestamp)
     {
         rm.add(new QueryPath(columnFamilyName, superColumnName.getBytes(), getBytes(columnName)), value.getBytes(), timestamp);
@@ -91,6 +100,11 @@ public static ColumnFamilyStore writeColumnFamily(List<RowMutation> rms) throws
     }
     
     public static ColumnFamily getColumnFamily(Table table, String key, String cfName) throws IOException
+    {
+        return getColumnFamily(table, dk(key), cfName);
+    }
+
+    public static ColumnFamily getColumnFamily(Table table, DecoratedKey key, String cfName) throws IOException
     {
         ColumnFamilyStore cfStore = table.getColumnFamilyStore(cfName);
         assert cfStore != null : "Column family " + cfName + " has not been defined";
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/client/TestRingCache.java b/cassandra/trunk/test/unit/org/apache/cassandra/client/TestRingCache.java
index 6de8291a..e338dea5 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/client/TestRingCache.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/client/TestRingCache.java
@@ -90,7 +90,7 @@ public static void main(String[] args) throws Throwable
             String row = rowPrefix + nRows;
             ColumnPath col = new ColumnPath("Standard1").setSuper_column(null).setColumn("col1".getBytes());
 
-            List<InetAddress> endPoints = tester.ringCache.getEndPoint(row);
+            List<InetAddress> endPoints = tester.ringCache.getEndPoint(row.getBytes());
             String hosts="";
             for (int i = 0; i < endPoints.size(); i++)
                 hosts = hosts + ((i > 0) ? "," : "") + endPoints.get(i);
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
index c0e2d77a..09aed14a 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
@@ -57,7 +57,7 @@ public void testGetColumnWithWrongBF() throws IOException, ExecutionException, I
     {
         List<RowMutation> rms = new LinkedList<RowMutation>();
         RowMutation rm;
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", "key1".getBytes());
         rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), 0);
         rm.add(new QueryPath("Standard1", null, "Column2".getBytes()), "asdf".getBytes(), 0);
         rms.add(rm);
@@ -67,7 +67,7 @@ public void testGetColumnWithWrongBF() throws IOException, ExecutionException, I
         List<SSTableReader> ssTables = table.getAllSSTablesOnDisk();
         assertEquals(1, ssTables.size());
         ssTables.get(0).forceFilterFailures();
-        ColumnFamily cf = store.getColumnFamily(QueryFilter.getIdentityFilter("key2", new QueryPath("Standard1", null, "Column1".getBytes())));
+        ColumnFamily cf = store.getColumnFamily(QueryFilter.getIdentityFilter(Util.dk("key2"), new QueryPath("Standard1", null, "Column1".getBytes())));
         assertNull(cf);
     }
 
@@ -78,7 +78,7 @@ public void testEmptyRow() throws Exception
         final ColumnFamilyStore store = table.getColumnFamilyStore("Standard2");
         RowMutation rm;
 
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", "key1".getBytes());
         rm.delete(new QueryPath("Standard2", null, null), System.currentTimeMillis());
         rm.apply();
 
@@ -86,9 +86,9 @@ public void testEmptyRow() throws Exception
         {
             public void runMayThrow() throws IOException
             {
-                QueryFilter sliceFilter = QueryFilter.getSliceFilter("key1", new QueryPath("Standard2", null, null), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, 1);
+                QueryFilter sliceFilter = QueryFilter.getSliceFilter(Util.dk("key1"), new QueryPath("Standard2", null, null), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, null, false, 1);
                 assertNull(store.getColumnFamily(sliceFilter));
-                QueryFilter namesFilter = QueryFilter.getNamesFilter("key1", new QueryPath("Standard2", null, null), "a".getBytes());
+                QueryFilter namesFilter = QueryFilter.getNamesFilter(Util.dk("key1"), new QueryPath("Standard2", null, null), "a".getBytes());
                 assertNull(store.getColumnFamily(namesFilter));
             }
         };
@@ -106,7 +106,7 @@ private void testAntiCompaction(String columnFamilyName, int insertsPerTable) th
         for (int j = 0; j < insertsPerTable; j++)
         {
             String key = String.valueOf(j);
-            RowMutation rm = new RowMutation("Keyspace1", key);
+            RowMutation rm = new RowMutation("Keyspace1", key.getBytes());
             rm.add(new QueryPath(columnFamilyName, null, "0".getBytes()), new byte[0], j);
             rms.add(rm);
         }
@@ -114,7 +114,7 @@ private void testAntiCompaction(String columnFamilyName, int insertsPerTable) th
 
         List<Range> ranges  = new ArrayList<Range>();
         IPartitioner partitioner = new CollatingOrderPreservingPartitioner();
-        Range r = new Range(partitioner.getToken("0"), partitioner.getToken("zzzzzzz"));
+        Range r = Util.range(partitioner, "0", "zzzzzzz");
         ranges.add(r);
 
         List<SSTableReader> fileList = CompactionManager.instance.submitAnticompaction(store, ranges, InetAddress.getByName("127.0.0.1")).get();
@@ -134,7 +134,7 @@ public void testWrappedRangeQuery() throws IOException, ExecutionException, Inte
 
         IPartitioner p = StorageService.getPartitioner();
         RangeSliceReply result = cfs.getRangeSlice(ArrayUtils.EMPTY_BYTE_ARRAY,
-                                                   new Range(p.getToken("key15"), p.getToken("key1")),
+                                                   Util.range(p, "key15", "key1"),
                                                    10,
                                                    null,
                                                    Arrays.asList("asdf".getBytes()));
@@ -148,24 +148,24 @@ public void testSkipStartKey() throws IOException, ExecutionException, Interrupt
 
         IPartitioner p = StorageService.getPartitioner();
         RangeSliceReply result = cfs.getRangeSlice(ArrayUtils.EMPTY_BYTE_ARRAY,
-                                                   new Range(p.getToken("key1"), p.getToken("key2")),
+                                                   Util.range(p, "key1", "key2"),
                                                    10,
                                                    null,
                                                    Arrays.asList("asdf".getBytes()));
         assertEquals(1, result.rows.size());
-        assert result.rows.get(0).key.equals("key2");
+        assert Arrays.equals(result.rows.get(0).key.key, "key2".getBytes());
     }
 
     private ColumnFamilyStore insertKey1Key2() throws IOException, ExecutionException, InterruptedException
     {
         List<RowMutation> rms = new LinkedList<RowMutation>();
         RowMutation rm;
-        rm = new RowMutation("Keyspace2", "key1");
+        rm = new RowMutation("Keyspace2", "key1".getBytes());
         rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), 0);
         rms.add(rm);
         Util.writeColumnFamily(rms);
 
-        rm = new RowMutation("Keyspace2", "key2");
+        rm = new RowMutation("Keyspace2", "key2".getBytes());
         rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), 0);
         rms.add(rm);
         return Util.writeColumnFamily(rms);
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/CommitLogTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/CommitLogTest.java
index dcff17d7..d5dd6062 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/CommitLogTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/CommitLogTest.java
@@ -44,7 +44,7 @@ public void testCleanup() throws IOException, ExecutionException, InterruptedExc
         // add data.  use relatively large values to force quick segment creation since we have a low flush threshold in the test config.
         for (int i = 0; i < 10; i++)
         {
-            rm = new RowMutation("Keyspace1", "key1");
+            rm = new RowMutation("Keyspace1", "key1".getBytes());
             rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), value, 0);
             rm.add(new QueryPath("Standard2", null, "Column1".getBytes()), value, 0);
             rm.apply();
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsPurgeTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsPurgeTest.java
index e57f5d95..433e5377 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsPurgeTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsPurgeTest.java
@@ -34,6 +34,7 @@
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.utils.FBUtilities;
+import org.apache.cassandra.Util;
 
 import static junit.framework.Assert.assertEquals;
 import static org.apache.cassandra.db.TableTest.assertColumns;
@@ -51,11 +52,11 @@ public void testCompactionPurge() throws IOException, ExecutionException, Interr
         String cfName = "Standard1";
         ColumnFamilyStore cfs = table.getColumnFamilyStore(cfName);
 
-        String key = "key1";
+        DecoratedKey key = Util.dk("key1");
         RowMutation rm;
 
         // inserts
-        rm = new RowMutation(TABLE1, key);
+        rm = new RowMutation(TABLE1, key.key);
         for (int i = 0; i < 10; i++)
         {
             rm.add(new QueryPath(cfName, null, String.valueOf(i).getBytes()), new byte[0], 0);
@@ -66,21 +67,21 @@ public void testCompactionPurge() throws IOException, ExecutionException, Interr
         // deletes
         for (int i = 0; i < 10; i++)
         {
-            rm = new RowMutation(TABLE1, key);
+            rm = new RowMutation(TABLE1, key.key);
             rm.delete(new QueryPath(cfName, null, String.valueOf(i).getBytes()), 1);
             rm.apply();
         }
         cfs.forceBlockingFlush();
 
         // resurrect one column
-        rm = new RowMutation(TABLE1, key);
+        rm = new RowMutation(TABLE1, key.key);
         rm.add(new QueryPath(cfName, null, String.valueOf(5).getBytes()), new byte[0], 2);
         rm.apply();
         cfs.forceBlockingFlush();
 
         // verify that non-major compaction does no GC to ensure correctness (see CASSANDRA-604)
         Collection<SSTableReader> sstablesIncomplete = cfs.getSSTables();
-        rm = new RowMutation(TABLE1, key + "x");
+        rm = new RowMutation(TABLE1, Util.dk("blah").key);
         rm.add(new QueryPath(cfName, null, "0".getBytes()), new byte[0], 0);
         rm.apply();
         cfs.forceBlockingFlush();
@@ -105,11 +106,11 @@ public void testCompactionPurgeOneFile() throws IOException, ExecutionException,
         String cfName = "Standard2";
         ColumnFamilyStore store = table.getColumnFamilyStore(cfName);
 
-        String key = "key1";
+        DecoratedKey key = Util.dk("key1");
         RowMutation rm;
 
         // inserts
-        rm = new RowMutation(TABLE1, key);
+        rm = new RowMutation(TABLE1, key.key);
         for (int i = 0; i < 5; i++)
         {
             rm.add(new QueryPath(cfName, null, String.valueOf(i).getBytes()), new byte[0], 0);
@@ -119,7 +120,7 @@ public void testCompactionPurgeOneFile() throws IOException, ExecutionException,
         // deletes
         for (int i = 0; i < 5; i++)
         {
-            rm = new RowMutation(TABLE1, key);
+            rm = new RowMutation(TABLE1, key.key);
             rm.delete(new QueryPath(cfName, null, String.valueOf(i).getBytes()), 1);
             rm.apply();
         }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsTest.java
index d6e5c657..01b94e59 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsTest.java
@@ -52,17 +52,17 @@ public void testCompactions() throws IOException, ExecutionException, Interrupte
         ColumnFamilyStore store = table.getColumnFamilyStore("Standard1");
 
         final int ROWS_PER_SSTABLE = 10;
-        Set<String> inserted = new HashSet<String>();
+        Set<DecoratedKey> inserted = new HashSet<DecoratedKey>();
         for (int j = 0; j < (SSTableReader.indexInterval() * 3) / ROWS_PER_SSTABLE; j++) {
             for (int i = 0; i < ROWS_PER_SSTABLE; i++) {
-                String key = String.valueOf(i % 2);
-                RowMutation rm = new RowMutation(TABLE1, key);
+                DecoratedKey key = Util.dk(String.valueOf(i % 2));
+                RowMutation rm = new RowMutation(TABLE1, key.key);
                 rm.add(new QueryPath("Standard1", null, String.valueOf(i / 2).getBytes()), new byte[0], j * ROWS_PER_SSTABLE + i);
                 rm.apply();
                 inserted.add(key);
             }
             store.forceBlockingFlush();
-            assertEquals(inserted.size(), Util.getRangeSlice(store).rows.size());
+            assertEquals(inserted.toString(), inserted.size(), Util.getRangeSlice(store).rows.size());
         }
         while (true)
         {
@@ -86,23 +86,19 @@ public void testCompactionReadonly() throws IOException, ExecutionException, Int
         ColumnFamilyStore store = table.getColumnFamilyStore("Standard1");
 
         final int ROWS_PER_SSTABLE = 10;
-        Set<String> inserted = new HashSet<String>();
         for (int j = 0; j < (SSTableReader.indexInterval() * 3) / ROWS_PER_SSTABLE; j++) {
             for (int i = 0; i < ROWS_PER_SSTABLE; i++) {
-                String key = String.valueOf(i % 2);
+                byte[] key = String.valueOf(i % 2).getBytes();
                 RowMutation rm = new RowMutation(TABLE2, key);
                 rm.add(new QueryPath("Standard1", null, String.valueOf(i / 2).getBytes()), new byte[0], j * ROWS_PER_SSTABLE + i);
                 rm.apply();
-                inserted.add(key);
             }
             store.forceBlockingFlush();
-            assertEquals(inserted.size(), Util.getRangeSlice(store).rows.size());
         }
 
         // perform readonly compaction and confirm that no sstables changed
         ArrayList<SSTableReader> oldsstables = new ArrayList<SSTableReader>(store.getSSTables());
         CompactionManager.instance.submitReadonly(store, LOCAL).get();
         assertEquals(oldsstables, new ArrayList<SSTableReader>(store.getSSTables()));
-        assertEquals(inserted.size(), Util.getRangeSlice(store).rows.size());
     }
 }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
index 1df2c790..f8dc326a 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
@@ -19,6 +19,8 @@
 package org.apache.cassandra.db;
 
 import org.apache.cassandra.CleanupHelper;
+import org.apache.cassandra.Util;
+
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
@@ -174,14 +176,15 @@ public void addNewCF() throws ConfigurationException, IOException, ExecutionExce
         assert DatabaseDescriptor.getTableDefinition(ks).cfMetaData().get(newCf.cfName).equals(newCf);
 
         // now read and write to it.
-        RowMutation rm = new RowMutation(ks, "key0");
+        DecoratedKey dk = Util.dk("key0");
+        RowMutation rm = new RowMutation(ks, dk.key);
         rm.add(new QueryPath(cf, null, "col0".getBytes()), "value0".getBytes(), 1L);
         rm.apply();
         ColumnFamilyStore store = Table.open(ks).getColumnFamilyStore(cf);
         assert store != null;
         store.forceBlockingFlush();
         
-        ColumnFamily cfam = store.getColumnFamily(QueryFilter.getNamesFilter("key0", new QueryPath(cf), "col0".getBytes()));
+        ColumnFamily cfam = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath(cf), "col0".getBytes()));
         assert cfam.getColumn("col0".getBytes()) != null;
         IColumn col = cfam.getColumn("col0".getBytes());
         assert Arrays.equals("value0".getBytes(), col.value());
@@ -190,6 +193,7 @@ public void addNewCF() throws ConfigurationException, IOException, ExecutionExce
     @Test
     public void dropCf() throws ConfigurationException, IOException, ExecutionException, InterruptedException
     {
+        DecoratedKey dk = Util.dk("dropCf");
         // sanity
         final KSMetaData ks = DatabaseDescriptor.getTableDefinition("Keyspace1");
         assert ks != null;
@@ -197,7 +201,7 @@ public void dropCf() throws ConfigurationException, IOException, ExecutionExcept
         assert cfm != null;
         
         // write some data, force a flush, then verify that files exist on disk.
-        RowMutation rm = new RowMutation(ks.name, "dropCf");
+        RowMutation rm = new RowMutation(ks.name, dk.key);
         for (int i = 0; i < 100; i++)
             rm.add(new QueryPath(cfm.cfName, null, ("col" + i).getBytes()), "anyvalue".getBytes(), 1L);
         rm.apply();
@@ -212,7 +216,7 @@ public void dropCf() throws ConfigurationException, IOException, ExecutionExcept
         assert !DatabaseDescriptor.getTableDefinition(ks.name).cfMetaData().containsKey(cfm.cfName);
         
         // any write should fail.
-        rm = new RowMutation(ks.name, "dropCf");
+        rm = new RowMutation(ks.name, dk.key);
         try
         {
             rm.add(new QueryPath("Standard1", null, "col0".getBytes()), "value0".getBytes(), 1L);
@@ -231,13 +235,14 @@ public void dropCf() throws ConfigurationException, IOException, ExecutionExcept
     @Test
     public void renameCf() throws ConfigurationException, IOException, ExecutionException, InterruptedException
     {
+        DecoratedKey dk = Util.dk("key0");
         final KSMetaData ks = DatabaseDescriptor.getTableDefinition("Keyspace2");
         assert ks != null;
         final CFMetaData oldCfm = ks.cfMetaData().get("Standard1");
         assert oldCfm != null;
         
         // write some data, force a flush, then verify that files exist on disk.
-        RowMutation rm = new RowMutation(ks.name, "key0");
+        RowMutation rm = new RowMutation(ks.name, dk.key);
         for (int i = 0; i < 100; i++)
             rm.add(new QueryPath(oldCfm.cfName, null, ("col" + i).getBytes()), "anyvalue".getBytes(), 1L);
         rm.apply();
@@ -259,16 +264,16 @@ public void renameCf() throws ConfigurationException, IOException, ExecutionExce
         // do some reads.
         store = Table.open(oldCfm.tableName).getColumnFamilyStore(cfName);
         assert store != null;
-        ColumnFamily cfam = store.getColumnFamily(QueryFilter.getSliceFilter("key0", new QueryPath(cfName), "".getBytes(), "".getBytes(), null, false, 1000));
+        ColumnFamily cfam = store.getColumnFamily(QueryFilter.getSliceFilter(dk, new QueryPath(cfName), "".getBytes(), "".getBytes(), null, false, 1000));
         assert cfam.getSortedColumns().size() == 100; // should be good enough?
         
         // do some writes
-        rm = new RowMutation(ks.name, "key0");
+        rm = new RowMutation(ks.name, dk.key);
         rm.add(new QueryPath(cfName, null, "col5".getBytes()), "updated".getBytes(), 2L);
         rm.apply();
         store.forceBlockingFlush();
         
-        cfam = store.getColumnFamily(QueryFilter.getNamesFilter("key0", new QueryPath(cfName), "col5".getBytes()));
+        cfam = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath(cfName), "col5".getBytes()));
         assert cfam.getColumnCount() == 1;
         assert Arrays.equals(cfam.getColumn("col5".getBytes()).value(), "updated".getBytes());
     }
@@ -276,6 +281,7 @@ public void renameCf() throws ConfigurationException, IOException, ExecutionExce
     @Test
     public void addNewKS() throws ConfigurationException, IOException, ExecutionException, InterruptedException
     {
+        DecoratedKey dk = Util.dk("key0");
         CFMetaData newCf = new CFMetaData("NewKeyspace1", "AddedStandard1", "Standard", new UTF8Type(), null, "A new cf for a new ks", 0, 0);
         KSMetaData newKs = new KSMetaData(newCf.tableName, RackAwareStrategy.class, 5, new EndPointSnitch(), newCf);
         
@@ -287,14 +293,14 @@ public void addNewKS() throws ConfigurationException, IOException, ExecutionExce
         assert DatabaseDescriptor.getTableDefinition(newCf.tableName) == newKs;
 
         // test reads and writes.
-        RowMutation rm = new RowMutation(newCf.tableName, "key0");
+        RowMutation rm = new RowMutation(newCf.tableName, dk.key);
         rm.add(new QueryPath(newCf.cfName, null, "col0".getBytes()), "value0".getBytes(), 1L);
         rm.apply();
         ColumnFamilyStore store = Table.open(newCf.tableName).getColumnFamilyStore(newCf.cfName);
         assert store != null;
         store.forceBlockingFlush();
         
-        ColumnFamily cfam = store.getColumnFamily(QueryFilter.getNamesFilter("key0", new QueryPath(newCf.cfName), "col0".getBytes()));
+        ColumnFamily cfam = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath(newCf.cfName), "col0".getBytes()));
         assert cfam.getColumn("col0".getBytes()) != null;
         IColumn col = cfam.getColumn("col0".getBytes());
         assert Arrays.equals("value0".getBytes(), col.value());
@@ -303,6 +309,7 @@ public void addNewKS() throws ConfigurationException, IOException, ExecutionExce
     @Test
     public void dropKS() throws ConfigurationException, IOException, ExecutionException, InterruptedException
     {
+        DecoratedKey dk = Util.dk("dropKs");
         // sanity
         final KSMetaData ks = DatabaseDescriptor.getTableDefinition("Keyspace1");
         assert ks != null;
@@ -310,7 +317,7 @@ public void dropKS() throws ConfigurationException, IOException, ExecutionExcept
         assert cfm != null;
         
         // write some data, force a flush, then verify that files exist on disk.
-        RowMutation rm = new RowMutation(ks.name, "dropKs");
+        RowMutation rm = new RowMutation(ks.name, dk.key);
         for (int i = 0; i < 100; i++)
             rm.add(new QueryPath(cfm.cfName, null, ("col" + i).getBytes()), "anyvalue".getBytes(), 1L);
         rm.apply();
@@ -324,7 +331,7 @@ public void dropKS() throws ConfigurationException, IOException, ExecutionExcept
         assert DatabaseDescriptor.getTableDefinition(ks.name) == null;
         
         // write should fail.
-        rm = new RowMutation(ks.name, "dropKs");
+        rm = new RowMutation(ks.name, dk.key);
         try
         {
             rm.add(new QueryPath("Standard1", null, "col0".getBytes()), "value0".getBytes(), 1L);
@@ -351,6 +358,7 @@ public void dropKS() throws ConfigurationException, IOException, ExecutionExcept
     @Test
     public void renameKs() throws ConfigurationException, IOException, ExecutionException, InterruptedException
     {
+        DecoratedKey dk = Util.dk("renameKs");
         final KSMetaData oldKs = DatabaseDescriptor.getTableDefinition("Keyspace2");
         assert oldKs != null;
         final String cfName = "Standard3";
@@ -358,7 +366,7 @@ public void renameKs() throws ConfigurationException, IOException, ExecutionExce
         assert oldKs.cfMetaData().get(cfName).tableName.equals(oldKs.name);
         
         // write some data that we hope to read back later.
-        RowMutation rm = new RowMutation(oldKs.name, "renameKs");
+        RowMutation rm = new RowMutation(oldKs.name, dk.key);
         for (int i = 0; i < 10; i++)
             rm.add(new QueryPath(cfName, null, ("col" + i).getBytes()), "value".getBytes(), 1L);
         rm.apply();
@@ -390,7 +398,7 @@ public void renameKs() throws ConfigurationException, IOException, ExecutionExce
         }
         
         // write on old should fail.
-        rm = new RowMutation(oldKs.name, "any key will do");
+        rm = new RowMutation(oldKs.name, "any key will do".getBytes());
         try
         {
             rm.add(new QueryPath(cfName, null, "col0".getBytes()), "value0".getBytes(), 1L);
@@ -403,7 +411,7 @@ public void renameKs() throws ConfigurationException, IOException, ExecutionExce
         }
         
         // write on new should work.
-        rm = new RowMutation(newKsName, "renameKs");
+        rm = new RowMutation(newKsName, dk.key);
         rm.add(new QueryPath(cfName, null, "col0".getBytes()), "newvalue".getBytes(), 2L);
         rm.apply();
         store = Table.open(newKs.name).getColumnFamilyStore(cfName);
@@ -414,7 +422,7 @@ public void renameKs() throws ConfigurationException, IOException, ExecutionExce
         SortedSet<byte[]> cols = new TreeSet<byte[]>(new BytesType());
         cols.add("col0".getBytes());
         cols.add("col1".getBytes());
-        ColumnFamily cfam = store.getColumnFamily(QueryFilter.getNamesFilter("renameKs", new QueryPath(cfName), cols));
+        ColumnFamily cfam = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath(cfName), cols));
         assert cfam.getColumnCount() == cols.size();
         // tests new write.
         assert Arrays.equals(cfam.getColumn("col0".getBytes()).value(), "newvalue".getBytes());
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/MultitableTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/MultitableTest.java
index 9093e66d..40bba6e9 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/MultitableTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/MultitableTest.java
@@ -29,6 +29,7 @@
 
 import static org.apache.cassandra.db.TableTest.assertColumns;
 import org.apache.cassandra.CleanupHelper;
+import org.apache.cassandra.Util;
 import static org.apache.cassandra.Util.column;
 
 public class MultitableTest extends CleanupHelper
@@ -40,15 +41,16 @@ public void testSameCFs() throws IOException, ExecutionException, InterruptedExc
         Table table2 = Table.open("Keyspace2");
 
         RowMutation rm;
+        DecoratedKey dk = Util.dk("keymulti");
         ColumnFamily cf;
 
-        rm = new RowMutation("Keyspace1", "keymulti");
+        rm = new RowMutation("Keyspace1", dk.key);
         cf = ColumnFamily.create("Keyspace1", "Standard1");
         cf.addColumn(column("col1", "val1", 1L));
         rm.add(cf);
         rm.apply();
 
-        rm = new RowMutation("Keyspace2", "keymulti");
+        rm = new RowMutation("Keyspace2", dk.key);
         cf = ColumnFamily.create("Keyspace2", "Standard1");
         cf.addColumn(column("col2", "val2", 1L));
         rm.add(cf);
@@ -57,7 +59,7 @@ public void testSameCFs() throws IOException, ExecutionException, InterruptedExc
         table1.getColumnFamilyStore("Standard1").forceBlockingFlush();
         table2.getColumnFamilyStore("Standard1").forceBlockingFlush();
 
-        assertColumns(Util.getColumnFamily(table1, "keymulti", "Standard1"), "col1");
-        assertColumns(Util.getColumnFamily(table2, "keymulti", "Standard1"), "col2");
+        assertColumns(Util.getColumnFamily(table1, dk, "Standard1"), "col1");
+        assertColumns(Util.getColumnFamily(table2, dk, "Standard1"), "col2");
     }
 }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/NameSortTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/NameSortTest.java
index 1ac0ccb9..3ef563c0 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/NameSortTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/NameSortTest.java
@@ -28,7 +28,9 @@
 import org.junit.Test;
 
 import org.apache.cassandra.CleanupHelper;
+import org.apache.cassandra.Util;
 import static org.apache.cassandra.Util.addMutation;
+
 import org.apache.cassandra.db.filter.QueryPath;
 
 import static junit.framework.Assert.assertEquals;
@@ -63,7 +65,7 @@ private void testNameSort(int N) throws IOException, ExecutionException, Interru
 
         for (int i = 0; i < N; ++i)
         {
-            String key = Integer.toString(i);
+            byte[] key = Integer.toString(i).getBytes();
             RowMutation rm;
 
             // standard
@@ -99,7 +101,7 @@ private void validateNameSort(Table table, int N) throws IOException
     {
         for (int i = 0; i < N; ++i)
         {
-            String key = Integer.toString(i);
+            DecoratedKey key = Util.dk(Integer.toString(i));
             ColumnFamily cf;
 
             cf = Util.getColumnFamily(table, key, "Standard1");
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/OneCompactionTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/OneCompactionTest.java
index 7a02abde..6d5683e9 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/OneCompactionTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/OneCompactionTest.java
@@ -40,10 +40,10 @@ private void testCompaction(String columnFamilyName, int insertsPerTable) throws
         Table table = Table.open("Keyspace1");
         ColumnFamilyStore store = table.getColumnFamilyStore(columnFamilyName);
 
-        Set<String> inserted = new HashSet<String>();
+        Set<DecoratedKey> inserted = new HashSet<DecoratedKey>();
         for (int j = 0; j < insertsPerTable; j++) {
-            String key = String.valueOf(j);
-            RowMutation rm = new RowMutation("Keyspace1", key);
+            DecoratedKey key = Util.dk(String.valueOf(j));
+            RowMutation rm = new RowMutation("Keyspace1", key.key);
             rm.add(new QueryPath(columnFamilyName, null, "0".getBytes()), new byte[0], j);
             rm.apply();
             inserted.add(key);
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/ReadMessageTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/ReadMessageTest.java
index 13ee6a9d..eb751302 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/ReadMessageTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/ReadMessageTest.java
@@ -33,6 +33,8 @@
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 
+import org.apache.cassandra.Util;
+
 public class ReadMessageTest extends SchemaLoader
 {
     @Test
@@ -43,24 +45,25 @@ public void testMakeReadMessage() throws IOException
         colList.add("col2".getBytes());
         
         ReadCommand rm, rm2;
+        DecoratedKey dk = Util.dk("row1");
         
-        rm = new SliceByNamesReadCommand("Keyspace1", "row1", new QueryPath("Standard1"), colList);
+        rm = new SliceByNamesReadCommand("Keyspace1", dk.key, new QueryPath("Standard1"), colList);
         rm2 = serializeAndDeserializeReadMessage(rm);
         assert rm2.toString().equals(rm.toString());
 
-        rm = new SliceFromReadCommand("Keyspace1", "row1", new QueryPath("Standard1"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, new ArrayList<byte[]>(0), true, 2);
+        rm = new SliceFromReadCommand("Keyspace1", dk.key, new QueryPath("Standard1"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, new ArrayList<byte[]>(0), true, 2);
         rm2 = serializeAndDeserializeReadMessage(rm);
         assert rm2.toString().equals(rm.toString());
         
-        rm = new SliceFromReadCommand("Keyspace1", "row1", new QueryPath("Standard1"), "a".getBytes(), "z".getBytes(), new ArrayList<byte[]>(0), true, 5);
+        rm = new SliceFromReadCommand("Keyspace1", dk.key, new QueryPath("Standard1"), "a".getBytes(), "z".getBytes(), new ArrayList<byte[]>(0), true, 5);
         rm2 = serializeAndDeserializeReadMessage(rm);
         assertEquals(rm2.toString(), rm.toString());
 
-        rm = new SliceFromReadCommand("Keyspace1", "row1", new QueryPath("Standard1"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, null, true, 2);
+        rm = new SliceFromReadCommand("Keyspace1", dk.key, new QueryPath("Standard1"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, null, true, 2);
         rm2 = serializeAndDeserializeReadMessage(rm);
         assert rm2.toString().equals(rm.toString());
 
-        rm = new SliceFromReadCommand("Keyspace1", "row1", new QueryPath("Standard1"), "a".getBytes(), "z".getBytes(), null, true, 5);
+        rm = new SliceFromReadCommand("Keyspace1", dk.key, new QueryPath("Standard1"), "a".getBytes(), "z".getBytes(), null, true, 5);
         rm2 = serializeAndDeserializeReadMessage(rm);
         assertEquals(rm2.toString(), rm.toString());
 
@@ -72,11 +75,11 @@ public void testMakeReadMessage() throws IOException
                 bitmasks.add(bitmaskTest.getBytes("UTF-8"));
             }
 
-            rm = new SliceFromReadCommand("Keyspace1", "row1", new QueryPath("Standard1"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, bitmasks, true, 2);
+            rm = new SliceFromReadCommand("Keyspace1", dk.key, new QueryPath("Standard1"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, bitmasks, true, 2);
             rm2 = serializeAndDeserializeReadMessage(rm);
             assert rm2.toString().equals(rm.toString());
 
-            rm = new SliceFromReadCommand("Keyspace1", "row1", new QueryPath("Standard1"), "a".getBytes(), "z".getBytes(), bitmasks, true, 5);
+            rm = new SliceFromReadCommand("Keyspace1", dk.key, new QueryPath("Standard1"), "a".getBytes(), "z".getBytes(), bitmasks, true, 5);
             rm2 = serializeAndDeserializeReadMessage(rm);
             assertEquals(rm2.toString(), rm.toString());
         }
@@ -98,13 +101,14 @@ public void testGetColumn() throws IOException, ColumnFamilyNotDefinedException
     {
         Table table = Table.open("Keyspace1");
         RowMutation rm;
+        DecoratedKey dk = Util.dk("key1");
 
         // add data
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "abcd".getBytes(), 0);
         rm.apply();
 
-        ReadCommand command = new SliceByNamesReadCommand("Keyspace1", "key1", new QueryPath("Standard1"), Arrays.asList("Column1".getBytes()));
+        ReadCommand command = new SliceByNamesReadCommand("Keyspace1", dk.key, new QueryPath("Standard1"), Arrays.asList("Column1".getBytes()));
         Row row = command.getRow(table);
         IColumn col = row.cf.getColumn("Column1".getBytes());
         assert Arrays.equals(col.value(), "abcd".getBytes());  
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
index 9d6c04f6..0c957e76 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
@@ -58,7 +58,7 @@ public void testWithFlush() throws IOException, ExecutionException, InterruptedE
 
     private void insertRow(String key) throws IOException
     {
-        RowMutation rm = new RowMutation("Keyspace1", key);
+        RowMutation rm = new RowMutation("Keyspace1", key.getBytes());
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
         cf.addColumn(column("col1", "val1", 1L));
         rm.add(cf);
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
index 112f23c7..4ca71435 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
@@ -27,6 +27,7 @@
 import org.apache.cassandra.CleanupHelper;
 import org.apache.cassandra.db.commitlog.CommitLog;
 
+import org.apache.cassandra.Util;
 import static org.apache.cassandra.Util.column;
 import static org.apache.cassandra.db.TableTest.assertColumns;
 
@@ -45,15 +46,16 @@ public void testOne() throws IOException, ExecutionException, InterruptedExcepti
         Table table2 = Table.open("Keyspace2");
 
         RowMutation rm;
+        DecoratedKey dk = Util.dk("keymulti");
         ColumnFamily cf;
 
-        rm = new RowMutation("Keyspace1", "keymulti");
+        rm = new RowMutation("Keyspace1", dk.key);
         cf = ColumnFamily.create("Keyspace1", "Standard1");
         cf.addColumn(column("col1", "val1", 1L));
         rm.add(cf);
         rm.apply();
 
-        rm = new RowMutation("Keyspace2", "keymulti");
+        rm = new RowMutation("Keyspace2", dk.key);
         cf = ColumnFamily.create("Keyspace2", "Standard3");
         cf.addColumn(column("col2", "val2", 1L));
         rm.add(cf);
@@ -64,7 +66,7 @@ public void testOne() throws IOException, ExecutionException, InterruptedExcepti
 
         CommitLog.recover();
 
-        assertColumns(Util.getColumnFamily(table1, "keymulti", "Standard1"), "col1");
-        assertColumns(Util.getColumnFamily(table2, "keymulti", "Standard3"), "col2");
+        assertColumns(Util.getColumnFamily(table1, dk, "Standard1"), "col1");
+        assertColumns(Util.getColumnFamily(table2, dk, "Standard3"), "col2");
     }
 }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyTest.java
index 127088d2..a57b36e0 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyTest.java
@@ -26,7 +26,9 @@
 import static junit.framework.Assert.assertNull;
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
+
 import org.apache.cassandra.CleanupHelper;
+import org.apache.cassandra.Util;
 
 public class RemoveColumnFamilyTest extends CleanupHelper
 {
@@ -36,18 +38,19 @@ public void testRemoveColumnFamily() throws IOException, ExecutionException, Int
         Table table = Table.open("Keyspace1");
         ColumnFamilyStore store = table.getColumnFamilyStore("Standard1");
         RowMutation rm;
+        DecoratedKey dk = Util.dk("key1");
 
         // add data
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), 0);
         rm.apply();
 
         // remove
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         rm.delete(new QueryPath("Standard1"), 1);
         rm.apply();
 
-        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter("key1", new QueryPath("Standard1", null, "Column1".getBytes())));
+        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Standard1", null, "Column1".getBytes())));
         assert retrieved.isMarkedForDelete();
         assertNull(retrieved.getColumn("Column1".getBytes()));
         assertNull(ColumnFamilyStore.removeDeleted(retrieved, Integer.MAX_VALUE));
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush1Test.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush1Test.java
index 19539a5e..6d96702f 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush1Test.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush1Test.java
@@ -26,7 +26,9 @@
 import static junit.framework.Assert.assertNull;
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
+
 import org.apache.cassandra.CleanupHelper;
+import org.apache.cassandra.Util;
 
 public class RemoveColumnFamilyWithFlush1Test extends CleanupHelper
 {
@@ -36,20 +38,21 @@ public void testRemoveColumnFamilyWithFlush1() throws IOException, ExecutionExce
         Table table = Table.open("Keyspace1");
         ColumnFamilyStore store = table.getColumnFamilyStore("Standard1");
         RowMutation rm;
+        DecoratedKey dk = Util.dk("key1");
 
         // add data
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), 0);
         rm.add(new QueryPath("Standard1", null, "Column2".getBytes()), "asdf".getBytes(), 0);
         rm.apply();
         store.forceBlockingFlush();
 
         // remove
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         rm.delete(new QueryPath("Standard1"), 1);
         rm.apply();
 
-        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter("key1", new QueryPath("Standard1")));
+        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Standard1")));
         assert retrieved.isMarkedForDelete();
         assertNull(retrieved.getColumn("Column1".getBytes()));
         assertNull(ColumnFamilyStore.removeDeleted(retrieved, Integer.MAX_VALUE));
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush2Test.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush2Test.java
index 2730abba..2f9fb8a9 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush2Test.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush2Test.java
@@ -26,7 +26,9 @@
 import static junit.framework.Assert.assertNull;
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
+
 import org.apache.cassandra.CleanupHelper;
+import org.apache.cassandra.Util;
 
 public class RemoveColumnFamilyWithFlush2Test extends CleanupHelper
 {
@@ -36,18 +38,19 @@ public void testRemoveColumnFamilyWithFlush2() throws IOException, ExecutionExce
         Table table = Table.open("Keyspace1");
         ColumnFamilyStore store = table.getColumnFamilyStore("Standard1");
         RowMutation rm;
+        DecoratedKey dk = Util.dk("key1");
 
         // add data
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), 0);
         rm.apply();
         // remove
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         rm.delete(new QueryPath("Standard1"), 1);
         rm.apply();
         store.forceBlockingFlush();
 
-        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter("key1", new QueryPath("Standard1", null, "Column1".getBytes())));
+        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Standard1", null, "Column1".getBytes())));
         assert retrieved.isMarkedForDelete();
         assertNull(retrieved.getColumn("Column1".getBytes()));
         assertNull(ColumnFamilyStore.removeDeleted(retrieved, Integer.MAX_VALUE));
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnTest.java
index 7b9fe17c..fcec2a5d 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnTest.java
@@ -27,7 +27,9 @@
 import org.apache.cassandra.db.filter.NamesQueryFilter;
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
+
 import org.apache.cassandra.CleanupHelper;
+import org.apache.cassandra.Util;
 
 public class RemoveColumnTest extends CleanupHelper
 {
@@ -37,21 +39,22 @@ public void testRemoveColumn() throws IOException, ExecutionException, Interrupt
         Table table = Table.open("Keyspace1");
         ColumnFamilyStore store = table.getColumnFamilyStore("Standard1");
         RowMutation rm;
+        DecoratedKey dk = Util.dk("key1");
 
         // add data
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), 0);
         rm.apply();
         store.forceBlockingFlush();
 
         // remove
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         rm.delete(new QueryPath("Standard1", null, "Column1".getBytes()), 1);
         rm.apply();
 
-        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getNamesFilter("key1", new QueryPath("Standard1"), "Column1".getBytes()));
+        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Standard1"), "Column1".getBytes()));
         assert retrieved.getColumn("Column1".getBytes()).isMarkedForDelete();
         assertNull(ColumnFamilyStore.removeDeleted(retrieved, Integer.MAX_VALUE));
-        assertNull(ColumnFamilyStore.removeDeleted(store.getColumnFamily(QueryFilter.getIdentityFilter("key1", new QueryPath("Standard1"))), Integer.MAX_VALUE));
+        assertNull(ColumnFamilyStore.removeDeleted(store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Standard1"))), Integer.MAX_VALUE));
     }
 }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSubColumnTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSubColumnTest.java
index 36478fcd..cace0790 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSubColumnTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSubColumnTest.java
@@ -26,8 +26,8 @@
 import static junit.framework.Assert.assertNull;
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
-import static org.apache.cassandra.Util.addMutation;
 import static org.apache.cassandra.Util.getBytes;
+import org.apache.cassandra.Util;
 import org.apache.cassandra.CleanupHelper;
 
 public class RemoveSubColumnTest extends CleanupHelper
@@ -38,19 +38,20 @@ public void testRemoveSubColumn() throws IOException, ExecutionException, Interr
         Table table = Table.open("Keyspace1");
         ColumnFamilyStore store = table.getColumnFamilyStore("Super1");
         RowMutation rm;
+        DecoratedKey dk = Util.dk("key1");
 
         // add data
-        rm = new RowMutation("Keyspace1", "key1");
-        addMutation(rm, "Super1", "SC1", 1, "asdf", 0);
+        rm = new RowMutation("Keyspace1", dk.key);
+        Util.addMutation(rm, "Super1", "SC1", 1, "asdf", 0);
         rm.apply();
         store.forceBlockingFlush();
 
         // remove
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         rm.delete(new QueryPath("Super1", "SC1".getBytes(), getBytes(1)), 1);
         rm.apply();
 
-        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter("key1", new QueryPath("Super1", "SC1".getBytes())));
+        ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Super1", "SC1".getBytes())));
         assert retrieved.getColumn("SC1".getBytes()).getSubColumn(getBytes(1)).isMarkedForDelete();
         assertNull(ColumnFamilyStore.removeDeleted(retrieved, Integer.MAX_VALUE));
     }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java
index f13067ec..9f6eae24 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java
@@ -42,26 +42,27 @@ public void testRemoveSuperColumn() throws IOException, ExecutionException, Inte
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super1");
         RowMutation rm;
+        DecoratedKey dk = Util.dk("key1");
 
         // add data
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         addMutation(rm, "Super1", "SC1", 1, "val1", 0);
         rm.apply();
         store.forceBlockingFlush();
 
         // remove
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         rm.delete(new QueryPath("Super1", "SC1".getBytes()), 1);
         rm.apply();
 
-        validateRemoveTwoSources();
+        validateRemoveTwoSources(dk);
 
         store.forceBlockingFlush();
-        validateRemoveTwoSources();
+        validateRemoveTwoSources(dk);
 
         CompactionManager.instance.submitMajor(store).get();
         assertEquals(1, store.getSSTables().size());
-        validateRemoveCompacted();
+        validateRemoveCompacted(dk);
     }
 
     @Test
@@ -69,48 +70,49 @@ public void testRemoveDeletedSubColumn() throws IOException, ExecutionException,
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super3");
         RowMutation rm;
+        DecoratedKey dk = Util.dk("key1");
 
         // add data
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         addMutation(rm, "Super3", "SC1", 1, "val1", 0);
         addMutation(rm, "Super3", "SC1", 2, "val1", 0);
         rm.apply();
         store.forceBlockingFlush();
 
         // remove
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         rm.delete(new QueryPath("Super3", "SC1".getBytes(), Util.getBytes(1)), 1);
         rm.apply();
 
-        validateRemoveSubColumn();
+        validateRemoveSubColumn(dk);
 
         store.forceBlockingFlush();
-        validateRemoveSubColumn();
+        validateRemoveSubColumn(dk);
     }
 
-    private void validateRemoveSubColumn() throws IOException
+    private void validateRemoveSubColumn(DecoratedKey dk) throws IOException
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super3");
-        assertNull(store.getColumnFamily(QueryFilter.getNamesFilter("key1", new QueryPath("Super3", "SC1".getBytes()), Util.getBytes(1)), Integer.MAX_VALUE));
-        assertNotNull(store.getColumnFamily(QueryFilter.getNamesFilter("key1", new QueryPath("Super3", "SC1".getBytes()), Util.getBytes(2)), Integer.MAX_VALUE));
+        assertNull(store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super3", "SC1".getBytes()), Util.getBytes(1)), Integer.MAX_VALUE));
+        assertNotNull(store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super3", "SC1".getBytes()), Util.getBytes(2)), Integer.MAX_VALUE));
     }
 
-    private void validateRemoveTwoSources() throws IOException
+    private void validateRemoveTwoSources(DecoratedKey dk) throws IOException
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super1");
-        ColumnFamily resolved = store.getColumnFamily(QueryFilter.getNamesFilter("key1", new QueryPath("Super1"), "SC1".getBytes()));
+        ColumnFamily resolved = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super1"), "SC1".getBytes()));
         assert resolved.getSortedColumns().iterator().next().getMarkedForDeleteAt() == 1 : resolved;
         assert resolved.getSortedColumns().iterator().next().getSubColumns().size() == 0 : resolved;
         assertNull(ColumnFamilyStore.removeDeleted(resolved, Integer.MAX_VALUE));
-        assertNull(store.getColumnFamily(QueryFilter.getNamesFilter("key1", new QueryPath("Super1"), "SC1".getBytes()), Integer.MAX_VALUE));
-        assertNull(store.getColumnFamily(QueryFilter.getIdentityFilter("key1", new QueryPath("Super1")), Integer.MAX_VALUE));
-        assertNull(ColumnFamilyStore.removeDeleted(store.getColumnFamily(QueryFilter.getIdentityFilter("key1", new QueryPath("Super1"))), Integer.MAX_VALUE));
+        assertNull(store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super1"), "SC1".getBytes()), Integer.MAX_VALUE));
+        assertNull(store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Super1")), Integer.MAX_VALUE));
+        assertNull(ColumnFamilyStore.removeDeleted(store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Super1"))), Integer.MAX_VALUE));
     }
 
-    private void validateRemoveCompacted() throws IOException
+    private void validateRemoveCompacted(DecoratedKey dk) throws IOException
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super1");
-        ColumnFamily resolved = store.getColumnFamily(QueryFilter.getNamesFilter("key1", new QueryPath("Super1"), "SC1".getBytes()));
+        ColumnFamily resolved = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super1"), "SC1".getBytes()));
         assert resolved.getSortedColumns().iterator().next().getMarkedForDeleteAt() == 1;
         Collection<IColumn> subColumns = resolved.getSortedColumns().iterator().next().getSubColumns();
         assert subColumns.size() == 0;
@@ -121,37 +123,38 @@ public void testRemoveSuperColumnWithNewData() throws IOException, ExecutionExce
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super2");
         RowMutation rm;
+        DecoratedKey dk = Util.dk("key1");
 
         // add data
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         addMutation(rm, "Super2", "SC1", 1, "val1", 0);
         rm.apply();
         store.forceBlockingFlush();
 
         // remove
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         rm.delete(new QueryPath("Super2", "SC1".getBytes()), 1);
         rm.apply();
 
         // new data
-        rm = new RowMutation("Keyspace1", "key1");
+        rm = new RowMutation("Keyspace1", dk.key);
         addMutation(rm, "Super2", "SC1", 2, "val2", 2);
         rm.apply();
 
-        validateRemoveWithNewData();
+        validateRemoveWithNewData(dk);
 
         store.forceBlockingFlush();
-        validateRemoveWithNewData();
+        validateRemoveWithNewData(dk);
 
         CompactionManager.instance.submitMajor(store).get();
         assertEquals(1, store.getSSTables().size());
-        validateRemoveWithNewData();
+        validateRemoveWithNewData(dk);
     }
 
-    private void validateRemoveWithNewData() throws IOException
+    private void validateRemoveWithNewData(DecoratedKey dk) throws IOException
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super2");
-        ColumnFamily resolved = store.getColumnFamily(QueryFilter.getNamesFilter("key1", new QueryPath("Super2", "SC1".getBytes()), getBytes(2)), Integer.MAX_VALUE);
+        ColumnFamily resolved = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super2", "SC1".getBytes()), getBytes(2)), Integer.MAX_VALUE);
         Collection<IColumn> subColumns = resolved.getSortedColumns().iterator().next().getSubColumns();
         assert subColumns.size() == 1;
         assert subColumns.iterator().next().timestamp() == 2;
@@ -162,21 +165,21 @@ public void testRemoveSuperColumnResurrection() throws IOException, ExecutionExc
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super2");
         RowMutation rm;
-        String key = "keyC";
+        DecoratedKey key = Util.dk("keyC");
 
         // add data
-        rm = new RowMutation("Keyspace1", key);
+        rm = new RowMutation("Keyspace1", key.key);
         addMutation(rm, "Super2", "SC1", 1, "val1", 0);
         rm.apply();
 
         // remove
-        rm = new RowMutation("Keyspace1", key);
+        rm = new RowMutation("Keyspace1", key.key);
         rm.delete(new QueryPath("Super2", "SC1".getBytes()), 1);
         rm.apply();
         assertNull(store.getColumnFamily(QueryFilter.getNamesFilter(key, new QueryPath("Super2"), "SC1".getBytes()), Integer.MAX_VALUE));
 
         // resurrect
-        rm = new RowMutation("Keyspace1", key);
+        rm = new RowMutation("Keyspace1", key.key);
         addMutation(rm, "Super2", "SC1", 1, "val2", 2);
         rm.apply();
 
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/SystemTableTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/SystemTableTest.java
index b68b803e..6859278c 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/SystemTableTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/SystemTableTest.java
@@ -41,7 +41,7 @@ public void testOnlyOnceCreationOfStorageMetadata() throws IOException
     public void testTokenGetsUpdated() throws IOException
     {
         SystemTable.StorageMetadata storageMetadata1 = SystemTable.initMetadata();
-        SystemTable.updateToken(StorageService.getPartitioner().getToken("503545744:0"));
+        SystemTable.updateToken(StorageService.getPartitioner().getToken("503545744:0".getBytes()));
         SystemTable.StorageMetadata storageMetadata2 = SystemTable.initMetadata();
         Assert.assertTrue("smd should still be a singleton after updateToken", storageMetadata1 == storageMetadata2);
     }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/TableTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/TableTest.java
index f0a1dac4..f075aceb 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/TableTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/TableTest.java
@@ -38,6 +38,7 @@
 import org.apache.cassandra.utils.WrappedRunnable;
 import static org.apache.cassandra.Util.column;
 import static org.apache.cassandra.Util.getBytes;
+import org.apache.cassandra.Util;
 import org.apache.cassandra.db.filter.NamesQueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.db.filter.SliceQueryFilter;
@@ -46,11 +47,13 @@
 import org.apache.cassandra.io.sstable.SSTable;
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.io.util.BufferedRandomAccessFile;
+import org.apache.cassandra.utils.FBUtilities;
 
 public class TableTest extends CleanupHelper
 {
-    private static final String KEY2 = "key2";
-    private static final String TEST_KEY = "key1";
+    private static final DecoratedKey KEY2 = Util.dk("key2");
+    private static final DecoratedKey TEST_KEY = Util.dk("key1");
+    private static final DecoratedKey TEST_SLICE_KEY = Util.dk("key1-slicerange");
 
     public static void reTest(ColumnFamilyStore cfs, Runnable verify) throws Exception
     {
@@ -65,7 +68,7 @@ public void testGetRowNoColumns() throws Throwable
         final Table table = Table.open("Keyspace2");
         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard3");
 
-        RowMutation rm = new RowMutation("Keyspace2", TEST_KEY);
+        RowMutation rm = new RowMutation("Keyspace2", TEST_KEY.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace2", "Standard3");
         cf.addColumn(column("col1","val1", 1L));
         rm.add(cf);
@@ -96,7 +99,7 @@ public void testGetRowSingleColumn() throws Throwable
         final Table table = Table.open("Keyspace1");
         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
 
-        RowMutation rm = new RowMutation("Keyspace1", TEST_KEY);
+        RowMutation rm = new RowMutation("Keyspace1", TEST_KEY.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
         cf.addColumn(column("col1","val1", 1L));
         cf.addColumn(column("col2","val2", 1L));
@@ -123,10 +126,10 @@ public void runMayThrow() throws Exception
     @Test
     public void testGetRowSliceByRange() throws Throwable
     {
-    	String key = TEST_KEY+"slicerow";
+    	DecoratedKey key = TEST_SLICE_KEY;
     	Table table = Table.open("Keyspace1");
         ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
-    	RowMutation rm = new RowMutation("Keyspace1", key);
+    	RowMutation rm = new RowMutation("Keyspace1", key.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
         // First write "a", "b", "c"
         cf.addColumn(column("a", "val1", 1L));
@@ -152,7 +155,7 @@ public void testGetRowSliceByRange() throws Throwable
     public void testGetSliceNoMatch() throws Throwable
     {
         Table table = Table.open("Keyspace1");
-        RowMutation rm = new RowMutation("Keyspace1", "row1000");
+        RowMutation rm = new RowMutation("Keyspace1", "row1000".getBytes());
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard2");
         cf.addColumn(column("col1", "val1", 1));
         rm.add(cf);
@@ -174,10 +177,10 @@ public void testGetSliceWithCutoff() throws Throwable
         // tests slicing against data from one row in a memtable and then flushed to an sstable
         final Table table = Table.open("Keyspace1");
         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
-        final String ROW = "row4";
+        final DecoratedKey ROW = Util.dk("row4");
         final NumberFormat fmt = new DecimalFormat("000");
 
-        RowMutation rm = new RowMutation("Keyspace1", ROW);
+        RowMutation rm = new RowMutation("Keyspace1", ROW.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
         // at this rate, we're getting 78-79 cos/block, assuming the blocks are set to be about 4k.
         // so if we go to 300, we'll get at least 4 blocks, which is plenty for testing.
@@ -233,10 +236,10 @@ public void testGetSliceWithBitmasks() throws Throwable
         // tests slicing against data from one row in a memtable and then flushed to an sstable
         final Table table = Table.open("Keyspace1");
         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
-        final String ROW = "row-bitmasktest";
+        final DecoratedKey ROW = Util.dk("row-bitmasktest");
         final NumberFormat fmt = new DecimalFormat("000");
 
-        RowMutation rm = new RowMutation("Keyspace1", ROW);
+        RowMutation rm = new RowMutation("Keyspace1", ROW.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
         // at this rate, we're getting 78-79 cos/block, assuming the blocks are set to be about 4k.
         // so if we go to 300, we'll get at least 4 blocks, which is plenty for testing.
@@ -297,11 +300,11 @@ private void validateGetSliceNoMatch(Table table) throws IOException
         ColumnFamily cf;
 
         // key before the rows that exists
-        cf = cfStore.getColumnFamily("a", new QueryPath("Standard2"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 1);
+        cf = cfStore.getColumnFamily(Util.dk("a"), new QueryPath("Standard2"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 1);
         assertColumns(cf);
 
         // key after the rows that exist
-        cf = cfStore.getColumnFamily("z", new QueryPath("Standard2"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 1);
+        cf = cfStore.getColumnFamily(Util.dk("z"), new QueryPath("Standard2"), ArrayUtils.EMPTY_BYTE_ARRAY, ArrayUtils.EMPTY_BYTE_ARRAY, false, 1);
         assertColumns(cf);
     }
 
@@ -311,9 +314,9 @@ public void testGetSliceFromBasic() throws Throwable
         // tests slicing against data from one row in a memtable and then flushed to an sstable
         final Table table = Table.open("Keyspace1");
         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
-        final String ROW = "row1";
+        final DecoratedKey ROW = Util.dk("row1");
 
-        RowMutation rm = new RowMutation("Keyspace1", ROW);
+        RowMutation rm = new RowMutation("Keyspace1", ROW.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
         cf.addColumn(column("col1", "val1", 1L));
         cf.addColumn(column("col3", "val3", 1L));
@@ -324,7 +327,7 @@ public void testGetSliceFromBasic() throws Throwable
         rm.add(cf);
         rm.apply();
 
-        rm = new RowMutation("Keyspace1", ROW);
+        rm = new RowMutation("Keyspace1", ROW.key);
         rm.delete(new QueryPath("Standard1", null, "col4".getBytes()), 2L);
         rm.apply();
 
@@ -367,9 +370,9 @@ public void testGetSliceFromAdvanced() throws Throwable
         // tests slicing against data from one row spread across two sstables
         final Table table = Table.open("Keyspace1");
         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
-        final String ROW = "row2";
+        final DecoratedKey ROW = Util.dk("row2");
 
-        RowMutation rm = new RowMutation("Keyspace1", ROW);
+        RowMutation rm = new RowMutation("Keyspace1", ROW.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
         cf.addColumn(column("col1", "val1", 1L));
         cf.addColumn(column("col2", "val2", 1L));
@@ -381,7 +384,7 @@ public void testGetSliceFromAdvanced() throws Throwable
         rm.apply();
         cfStore.forceBlockingFlush();
 
-        rm = new RowMutation("Keyspace1", ROW);
+        rm = new RowMutation("Keyspace1", ROW.key);
         cf = ColumnFamily.create("Keyspace1", "Standard1");
         cf.addColumn(column("col1", "valx", 2L));
         cf.addColumn(column("col2", "valx", 2L));
@@ -412,8 +415,8 @@ public void testGetSliceFromLarge() throws Throwable
         // tests slicing against 1000 columns in an sstable
         Table table = Table.open("Keyspace1");
         ColumnFamilyStore cfStore = table.getColumnFamilyStore("Standard1");
-        String key = "row3";
-        RowMutation rm = new RowMutation("Keyspace1", key);
+        DecoratedKey key = Util.dk("row3");
+        RowMutation rm = new RowMutation("Keyspace1", key.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
         for (int i = 1000; i < 2000; i++)
             cf.addColumn(column("col" + i, ("v" + i), 1L));
@@ -428,11 +431,10 @@ public void testGetSliceFromLarge() throws Throwable
             CompactionManager.instance.submitMajor(cfStore).get();
         }
         SSTableReader sstable = cfStore.getSSTables().iterator().next();
-        DecoratedKey decKey = sstable.getPartitioner().decorateKey(key);
-        SSTable.PositionSize info = sstable.getPosition(decKey);
+        SSTable.PositionSize info = sstable.getPosition(key);
         BufferedRandomAccessFile file = new BufferedRandomAccessFile(sstable.getFilename(), "r");
         file.seek(info.position);
-        assert file.readUTF().equals(key);
+        assert Arrays.equals(FBUtilities.readShortByteArray(file), key.key);
         file.readInt();
         IndexHelper.skipBloomFilter(file);
         ArrayList<IndexHelper.IndexInfo> indexes = IndexHelper.deserializeIndex(file);
@@ -442,7 +444,7 @@ public void testGetSliceFromLarge() throws Throwable
 
     private void validateSliceLarge(ColumnFamilyStore cfStore) throws IOException
     {
-        String key = "row3";
+        DecoratedKey key = Util.dk("row3");
         ColumnFamily cf;
         cf = cfStore.getColumnFamily(key, new QueryPath("Standard1"), "col1000".getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, false, 3);
         assertColumns(cf, "col1000", "col1001", "col1002");
@@ -491,9 +493,9 @@ public void testGetSliceFromSuperBasic() throws Throwable
         // tests slicing against data from one row spread across two sstables
         final Table table = Table.open("Keyspace1");
         final ColumnFamilyStore cfStore = table.getColumnFamilyStore("Super1");
-        final String ROW = "row2";
+        final DecoratedKey ROW = Util.dk("row2");
 
-        RowMutation rm = new RowMutation("Keyspace1", ROW);
+        RowMutation rm = new RowMutation("Keyspace1", ROW.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Super1");
         SuperColumn sc = new SuperColumn("sc1".getBytes(), new LongType());
         sc.addColumn(new Column(getBytes(1), "val1".getBytes(), 1L));
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/TimeSortTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/TimeSortTest.java
index ae0a9cf8..48d1a3d4 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/TimeSortTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/TimeSortTest.java
@@ -28,6 +28,7 @@
 
 import org.apache.cassandra.CleanupHelper;
 import static org.apache.cassandra.Util.getBytes;
+import org.apache.cassandra.Util;
 
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
@@ -42,17 +43,18 @@ public void testMixedSources() throws IOException, ExecutionException, Interrupt
         Table table = Table.open("Keyspace1");
         ColumnFamilyStore cfStore = table.getColumnFamilyStore("StandardLong1");
         RowMutation rm;
+        DecoratedKey key = Util.dk("key0");
 
-        rm = new RowMutation("Keyspace1", "key0");
+        rm = new RowMutation("Keyspace1", key.key);
         rm.add(new QueryPath("StandardLong1", null, getBytes(100)), "a".getBytes(), 100);
         rm.apply();
         cfStore.forceBlockingFlush();
 
-        rm = new RowMutation("Keyspace1", "key0");
+        rm = new RowMutation("Keyspace1", key.key);
         rm.add(new QueryPath("StandardLong1", null, getBytes(0)), "b".getBytes(), 0);
         rm.apply();
 
-        ColumnFamily cf = cfStore.getColumnFamily("key0", new QueryPath("StandardLong1"), getBytes(10), ArrayUtils.EMPTY_BYTE_ARRAY, false, 1000);
+        ColumnFamily cf = cfStore.getColumnFamily(key, new QueryPath("StandardLong1"), getBytes(10), ArrayUtils.EMPTY_BYTE_ARRAY, false, 1000);
         Collection<IColumn> columns = cf.getSortedColumns();
         assert columns.size() == 1;
     }
@@ -65,7 +67,7 @@ public void testTimeSort() throws IOException, ExecutionException, InterruptedEx
 
         for (int i = 900; i < 1000; ++i)
         {
-            RowMutation rm = new RowMutation("Keyspace1", Integer.toString(i));
+            RowMutation rm = new RowMutation("Keyspace1", Integer.toString(i).getBytes());
             for (int j = 0; j < 8; ++j)
             {
                 rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2)), "a".getBytes(), j * 2);
@@ -79,15 +81,15 @@ public void testTimeSort() throws IOException, ExecutionException, InterruptedEx
         validateTimeSort(table);
 
         // interleave some new data to test memtable + sstable
-        String key = "900";
-        RowMutation rm = new RowMutation("Keyspace1", key);
+        DecoratedKey key = Util.dk("900");
+        RowMutation rm = new RowMutation("Keyspace1", key.key);
         for (int j = 0; j < 4; ++j)
         {
             rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2 + 1)), "b".getBytes(), j * 2 + 1);
         }
         rm.apply();
         // and some overwrites
-        rm = new RowMutation("Keyspace1", key);
+        rm = new RowMutation("Keyspace1", key.key);
         rm.add(new QueryPath("StandardLong1", null, getBytes(0)), "c".getBytes(), 100);
         rm.add(new QueryPath("StandardLong1", null, getBytes(10)), "c".getBytes(), 100);
         rm.apply();
@@ -106,7 +108,7 @@ public void testTimeSort() throws IOException, ExecutionException, InterruptedEx
         TreeSet<byte[]> columnNames = new TreeSet<byte[]>(new LongType());
         columnNames.add(getBytes(10));
         columnNames.add(getBytes(0));
-        cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter("900", new QueryPath("StandardLong1"), columnNames));
+        cf = cfStore.getColumnFamily(QueryFilter.getNamesFilter(Util.dk("900"), new QueryPath("StandardLong1"), columnNames));
         assert "c".equals(new String(cf.getColumn(getBytes(0)).value()));
         assert "c".equals(new String(cf.getColumn(getBytes(10)).value()));
     }
@@ -115,7 +117,7 @@ private void validateTimeSort(Table table) throws IOException
     {
         for (int i = 900; i < 1000; ++i)
         {
-            String key = Integer.toString(i);
+            DecoratedKey key = Util.dk(Integer.toString(i));
             for (int j = 0; j < 8; j += 3)
             {
                 ColumnFamily cf = table.getColumnFamilyStore("StandardLong1").getColumnFamily(key, new QueryPath("StandardLong1"), getBytes(j * 2), ArrayUtils.EMPTY_BYTE_ARRAY, false, 1000);
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/dht/PartitionerTestCase.java b/cassandra/trunk/test/unit/org/apache/cassandra/dht/PartitionerTestCase.java
index d40d2db1..fdb1c270 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/dht/PartitionerTestCase.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/dht/PartitionerTestCase.java
@@ -40,7 +40,7 @@ public void clean()
 
     public T tok(String string)
     {
-        return partitioner.getToken(string);
+        return partitioner.getToken(string.getBytes());
     }
 
     /**
@@ -97,7 +97,7 @@ public void testMidpointWrapping()
     @Test
     public void testDiskFormat()
     {
-        String key = "key";
+        byte[] key = "key".getBytes();
         DecoratedKey<T> decKey = partitioner.decorateKey(key);
         DecoratedKey<T> result = partitioner.convertFromDiskFormat(partitioner.convertToDiskFormat(decKey));
         assertEquals(decKey, result);
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/io/StreamingTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/io/StreamingTest.java
index 448fe5b3..949464cf 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/io/StreamingTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/io/StreamingTest.java
@@ -57,6 +57,6 @@ public void testTransferTable() throws Exception
         ColumnFamilyStore cfstore = Table.open(tablename).getColumnFamilyStore(cfname);
         RangeSliceReply rr = Util.getRangeSlice(cfstore);
         assert rr.rows.size() == 1;
-        assert rr.rows.get(0).key.equals("key");
+        assert Arrays.equals(rr.rows.get(0).key.key, "key".getBytes());
     }
 }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java
index d37585c3..2505fd7a 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/LegacySSTableTest.java
@@ -30,6 +30,7 @@
 import org.apache.cassandra.CleanupHelper;
 import org.apache.cassandra.io.util.BufferedRandomAccessFile;
 import org.apache.cassandra.db.DecoratedKey;
+import org.apache.cassandra.utils.FBUtilities;
 
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
@@ -44,7 +45,7 @@
     public static final String KSNAME = "Keyspace1";
     public static final String CFNAME = "Standard1";
 
-    public static SortedMap<String, byte[]> TEST_DATA;
+    public static Map<byte[], byte[]> TEST_DATA;
     public static File LEGACY_SSTABLE_ROOT;
 
     @BeforeClass
@@ -55,10 +56,10 @@ public static void beforeClass()
         LEGACY_SSTABLE_ROOT = new File(scp);
         assert LEGACY_SSTABLE_ROOT.isDirectory();
 
-        TEST_DATA = new TreeMap<String,byte[]>();
-        for ( int i = 100; i < 1000; ++i )
+        TEST_DATA = new HashMap<byte[],byte[]>();
+        for (int i = 100; i < 1000; ++i)
         {
-            TEST_DATA.put(Integer.toString(i), ("Avinash Lakshman is a good man: " + i).getBytes());
+            TEST_DATA.put(Integer.toString(i).getBytes(), ("Avinash Lakshman is a good man: " + i).getBytes());
         }
     }
 
@@ -100,14 +101,14 @@ public void testVerB() throws IOException
     {
         SSTableReader reader = SSTableReader.open(getDescriptor("b"));
 
-        List<String> keys = new ArrayList<String>(TEST_DATA.keySet());
+        List<byte[]> keys = new ArrayList<byte[]>(TEST_DATA.keySet());
         Collections.shuffle(keys);
         BufferedRandomAccessFile file = new BufferedRandomAccessFile(reader.getFilename(), "r");
-        for (String key : keys)
+        for (byte[] key : keys)
         {
             // confirm that the bloom filter does not reject any keys
             file.seek(reader.getPosition(reader.partitioner.decorateKey(key)).position);
-            assert key.equals(file.readUTF());
+            assert Arrays.equals(key, FBUtilities.readShortByteArray(file));
         }
     }
 }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
index 11d335ff..37462cfe 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
@@ -15,6 +15,7 @@
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.utils.FBUtilities;
 
+import org.apache.cassandra.Util;
 
 public class SSTableReaderTest extends CleanupHelper
 {
@@ -30,7 +31,7 @@ public void testSpannedIndexPositions() throws IOException, ExecutionException,
         CompactionManager.instance.disableAutoCompaction();
         for (int j = 0; j < 100; j += 2)
         {
-            String key = String.valueOf(j);
+            byte[] key = String.valueOf(j).getBytes();
             RowMutation rm = new RowMutation("Keyspace1", key);
             rm.add(new QueryPath("Standard1", null, "0".getBytes()), new byte[0], j);
             rm.apply();
@@ -42,8 +43,7 @@ public void testSpannedIndexPositions() throws IOException, ExecutionException,
         SSTableReader sstable = store.getSSTables().iterator().next();
         for (int j = 0; j < 100; j += 2)
         {
-            String key = String.valueOf(j);
-            DecoratedKey dk = StorageService.getPartitioner().decorateKey(key);
+            DecoratedKey dk = Util.dk(String.valueOf(j));
             FileDataInput file = sstable.getFileDataInput(dk, DatabaseDescriptor.getIndexedReadBufferSizeInKB() * 1024);
             DecoratedKey keyInDisk = sstable.getPartitioner().convertFromDiskFormat(FBUtilities.readShortByteArray(file));
             assert keyInDisk.equals(dk) : String.format("%s != %s in %s", keyInDisk, dk, file.getPath());
@@ -52,8 +52,7 @@ public void testSpannedIndexPositions() throws IOException, ExecutionException,
         // check no false positives
         for (int j = 1; j < 110; j += 2)
         {
-            String key = String.valueOf(j);
-            DecoratedKey dk = StorageService.getPartitioner().decorateKey(key);
+            DecoratedKey dk = Util.dk(String.valueOf(j));
             assert sstable.getPosition(dk) == null;
         }
     }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableTest.java
index 80726f51..7bfd5f42 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableTest.java
@@ -29,6 +29,7 @@
 import org.apache.cassandra.CleanupHelper;
 import org.apache.cassandra.io.util.BufferedRandomAccessFile;
 import org.apache.cassandra.db.DecoratedKey;
+import org.apache.cassandra.utils.FBUtilities;
 
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
@@ -38,11 +39,11 @@
     @Test
     public void testSingleWrite() throws IOException {
         // write test data
-        String key = Integer.toString(1);
+        byte[] key = Integer.toString(1).getBytes();
         byte[] bytes = new byte[1024];
         new Random().nextBytes(bytes);
 
-        TreeMap<String, byte[]> map = new TreeMap<String,byte[]>();
+        Map<byte[], byte[]> map = new HashMap<byte[],byte[]>();
         map.put(key, bytes);
         SSTableReader ssTable = SSTableUtils.writeRawSSTable("Keyspace1", "Standard1", map);
 
@@ -52,11 +53,11 @@ public void testSingleWrite() throws IOException {
         verifySingle(ssTable, bytes, key);
     }
 
-    private void verifySingle(SSTableReader sstable, byte[] bytes, String key) throws IOException
+    private void verifySingle(SSTableReader sstable, byte[] bytes, byte[] key) throws IOException
     {
         BufferedRandomAccessFile file = new BufferedRandomAccessFile(sstable.getFilename(), "r");
         file.seek(sstable.getPosition(sstable.partitioner.decorateKey(key)).position);
-        assert key.equals(file.readUTF());
+        assert Arrays.equals(key, FBUtilities.readShortByteArray(file));
         int size = file.readInt();
         byte[] bytes2 = new byte[size];
         file.readFully(bytes2);
@@ -65,10 +66,10 @@ private void verifySingle(SSTableReader sstable, byte[] bytes, String key) throw
 
     @Test
     public void testManyWrites() throws IOException {
-        TreeMap<String, byte[]> map = new TreeMap<String,byte[]>();
-        for ( int i = 100; i < 1000; ++i )
+        Map<byte[], byte[]> map = new HashMap<byte[],byte[]>();
+        for (int i = 100; i < 1000; ++i)
         {
-            map.put(Integer.toString(i), ("Avinash Lakshman is a good man: " + i).getBytes());
+            map.put(Integer.toString(i).getBytes(), ("Avinash Lakshman is a good man: " + i).getBytes());
         }
 
         // write
@@ -80,15 +81,15 @@ public void testManyWrites() throws IOException {
         verifyMany(ssTable, map);
     }
 
-    private void verifyMany(SSTableReader sstable, TreeMap<String, byte[]> map) throws IOException
+    private void verifyMany(SSTableReader sstable, Map<byte[], byte[]> map) throws IOException
     {
-        List<String> keys = new ArrayList<String>(map.keySet());
+        List<byte[]> keys = new ArrayList<byte[]>(map.keySet());
         Collections.shuffle(keys);
         BufferedRandomAccessFile file = new BufferedRandomAccessFile(sstable.getFilename(), "r");
-        for (String key : keys)
+        for (byte[] key : keys)
         {
             file.seek(sstable.getPosition(sstable.partitioner.decorateKey(key)).position);
-            assert key.equals(file.readUTF());
+            assert Arrays.equals(key, FBUtilities.readShortByteArray(file));
             int size = file.readInt();
             byte[] bytes2 = new byte[size];
             file.readFully(bytes2);
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java b/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
index 8ed14e3a..a11b8de2 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
@@ -22,16 +22,10 @@
 import java.io.File;
 import java.io.IOException;
 
-import java.util.Map;
-import java.util.SortedMap;
-import java.util.Set;
-import java.util.TreeMap;
+import java.util.*;
 
 import org.apache.cassandra.config.DatabaseDescriptor;
-import org.apache.cassandra.db.Column;
-import org.apache.cassandra.db.IColumn;
-import org.apache.cassandra.db.ColumnFamily;
-import org.apache.cassandra.db.Table;
+import org.apache.cassandra.db.*;
 import org.apache.cassandra.service.StorageService;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 
@@ -68,7 +62,7 @@ public static File tempSSTableFile(String tablename, String cfname) throws IOExc
 
     public static SSTableReader writeSSTable(Set<String> keys) throws IOException
     {
-        TreeMap<String, ColumnFamily> map = new TreeMap<String, ColumnFamily>();
+        Map<String, ColumnFamily> map = new HashMap<String, ColumnFamily>();
         for (String key : keys)
         {
             ColumnFamily cf = ColumnFamily.create(TABLENAME, CFNAME);
@@ -78,24 +72,24 @@ public static SSTableReader writeSSTable(Set<String> keys) throws IOException
         return writeSSTable(map);
     }
 
-    public static SSTableReader writeSSTable(SortedMap<String, ColumnFamily> entries) throws IOException
+    public static SSTableReader writeSSTable(Map<String, ColumnFamily> entries) throws IOException
     {
-        TreeMap<String, byte[]> map = new TreeMap<String, byte[]>();
+        Map<byte[], byte[]> map = new HashMap<byte[], byte[]>();
         for (Map.Entry<String, ColumnFamily> entry : entries.entrySet())
         {
             DataOutputBuffer buffer = new DataOutputBuffer();
             ColumnFamily.serializer().serializeWithIndexes(entry.getValue(), buffer);
-            map.put(entry.getKey(), buffer.getData());
+            map.put(entry.getKey().getBytes(), buffer.getData());
         }
         return writeRawSSTable(TABLENAME, CFNAME, map);
     }
 
-    public static SSTableReader writeRawSSTable(String tablename, String cfname, SortedMap<String, byte[]> entries) throws IOException
+    public static SSTableReader writeRawSSTable(String tablename, String cfname, Map<byte[], byte[]> entries) throws IOException
     {
         return writeRawSSTable(null, tablename, cfname, entries);
     }
 
-    public static SSTableReader writeRawSSTable(File datafile, String tablename, String cfname, SortedMap<String, byte[]> entries) throws IOException
+    public static SSTableReader writeRawSSTable(File datafile, String tablename, String cfname, Map<byte[], byte[]> entries) throws IOException
     {
         boolean temporary = false;
         if (datafile == null)
@@ -104,9 +98,11 @@ public static SSTableReader writeRawSSTable(File datafile, String tablename, Str
             temporary = true;
         }
         SSTableWriter writer = new SSTableWriter(datafile.getAbsolutePath(), entries.size(), StorageService.getPartitioner());
-        for (Map.Entry<String, byte[]> entry : entries.entrySet())
-            writer.append(writer.partitioner.decorateKey(entry.getKey()),
-                          entry.getValue());
+        SortedMap<DecoratedKey, byte[]> sortedEntries = new TreeMap<DecoratedKey, byte[]>();
+        for (Map.Entry<byte[], byte[]> entry : entries.entrySet())
+            sortedEntries.put(writer.partitioner.decorateKey(entry.getKey()), entry.getValue());
+        for (Map.Entry<DecoratedKey, byte[]> entry : sortedEntries.entrySet())
+            writer.append(entry.getKey(), entry.getValue());
         if (temporary)
         {
             new File(writer.indexFilename()).deleteOnExit();
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/locator/RackUnawareStrategyTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/locator/RackUnawareStrategyTest.java
index 913351d2..d2bfdbab 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/locator/RackUnawareStrategyTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/locator/RackUnawareStrategyTest.java
@@ -86,7 +86,7 @@ public void testStringEndpoints() throws UnknownHostException
         List<Token> keyTokens = new ArrayList<Token>();
         for (int i = 0; i < 5; i++) {
             endPointTokens.add(new StringToken(String.valueOf((char)('a' + i * 2))));
-            keyTokens.add(partitioner.getToken(String.valueOf((char)('a' + i * 2 + 1))));
+            keyTokens.add(partitioner.getToken(String.valueOf((char)('a' + i * 2 + 1)).getBytes()));
         }
         for (String table : DatabaseDescriptor.getNonSystemTables())
             testGetEndpoints(tmd, strategy, endPointTokens.toArray(new Token[0]), keyTokens.toArray(new Token[0]), table);
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
index 79f6be5a..831e873d 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
@@ -107,7 +107,7 @@ public void testValidatorPrepare() throws Throwable
         // write
         List<RowMutation> rms = new LinkedList<RowMutation>();
         RowMutation rm;
-        rm = new RowMutation(tablename, "key1");
+        rm = new RowMutation(tablename, "key1".getBytes());
         rm.add(new QueryPath(cfname, null, "Column1".getBytes()), "asdf".getBytes(), 0);
         rms.add(rm);
         Util.writeColumnFamily(rms);
@@ -165,7 +165,7 @@ public void testTreeStore() throws Throwable
     {
         // populate column family
         List<RowMutation> rms = new LinkedList<RowMutation>();
-        RowMutation rm = new RowMutation(tablename, "key");
+        RowMutation rm = new RowMutation(tablename, "key".getBytes());
         rm.add(new QueryPath(cfname, null, "Column1".getBytes()), "asdf".getBytes(), 0);
         rms.add(rm);
         // with two SSTables
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/tools/SSTableExportTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/tools/SSTableExportTest.java
index 5054ebbb..f9e82baa 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/tools/SSTableExportTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/tools/SSTableExportTest.java
@@ -38,6 +38,8 @@
 import static org.apache.cassandra.utils.FBUtilities.hexToBytes;
 import static org.junit.Assert.assertTrue;
 
+import org.apache.cassandra.Util;
+
 import org.json.simple.JSONArray;
 import org.json.simple.JSONObject;
 import org.json.simple.JSONValue;
@@ -58,14 +60,14 @@ public void testEnumeratekeys() throws IOException
         // Add rowA
         cfamily.addColumn(new QueryPath("Standard1", null, "colA".getBytes()), "valA".getBytes(), 1, false);
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
-        writer.append(partitioner.decorateKey("rowA"), dob);
+        writer.append(Util.dk("rowA"), dob);
         dob.reset();
         cfamily.clear();
         
         // Add rowB
         cfamily.addColumn(new QueryPath("Standard1", null, "colB".getBytes()), "valB".getBytes(), 1, false);
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
-        writer.append(partitioner.decorateKey("rowB"), dob);
+        writer.append(Util.dk("rowB"), dob);
         dob.reset();
         cfamily.clear();
      
@@ -82,6 +84,7 @@ public void testEnumeratekeys() throws IOException
         String output = new String(buf);
 
         String sep = System.getProperty("line.separator");
+        // FIXME: string keys
         assert output.equals("rowA" + sep + "rowB" + sep) : output;
     }
 
@@ -96,21 +99,21 @@ public void testExportSimpleCf() throws IOException    {
         // Add rowA
         cfamily.addColumn(new QueryPath("Standard1", null, "colA".getBytes()), "valA".getBytes(), 1, false);
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
-        writer.append(partitioner.decorateKey("rowA"), dob);
+        writer.append(Util.dk("rowA"), dob);
         dob.reset();
         cfamily.clear();
         
         // Add rowB
         cfamily.addColumn(new QueryPath("Standard1", null, "colB".getBytes()), "valB".getBytes(), 1, false);
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
-        writer.append(partitioner.decorateKey("rowB"), dob);
+        writer.append(Util.dk("rowB"), dob);
         dob.reset();
         cfamily.clear();
 
         // Add rowExclude
         cfamily.addColumn(new QueryPath("Standard1", null, "colX".getBytes()), "valX".getBytes(), 1, false);
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
-        writer.append(partitioner.decorateKey("rowExclude"), dob);
+        writer.append(Util.dk("rowExclude"), dob);
         dob.reset();
         cfamily.clear();
 
@@ -122,6 +125,7 @@ public void testExportSimpleCf() throws IOException    {
         
         JSONObject json = (JSONObject)JSONValue.parse(new FileReader(tempJson));
         
+        // FIXME: string keys
         JSONArray rowA = (JSONArray)json.get("rowA");
         JSONArray colA = (JSONArray)rowA.get(0);
         assert Arrays.equals(hexToBytes((String)colA.get(1)), "valA".getBytes());
@@ -146,21 +150,21 @@ public void testExportSuperCf() throws IOException
         // Add rowA
         cfamily.addColumn(new QueryPath("Super4", "superA".getBytes(), "colA".getBytes()), "valA".getBytes(), 1, false);
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
-        writer.append(partitioner.decorateKey("rowA"), dob);
+        writer.append(Util.dk("rowA"), dob);
         dob.reset();
         cfamily.clear();
         
         // Add rowB
         cfamily.addColumn(new QueryPath("Super4", "superB".getBytes(), "colB".getBytes()), "valB".getBytes(), 1, false);
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
-        writer.append(partitioner.decorateKey("rowB"), dob);
+        writer.append(Util.dk("rowB"), dob);
         dob.reset();
         cfamily.clear();
 
         // Add rowExclude
         cfamily.addColumn(new QueryPath("Super4", "superX".getBytes(), "colX".getBytes()), "valX".getBytes(), 1, false);
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
-        writer.append(partitioner.decorateKey("rowExclude"), dob);
+        writer.append(Util.dk("rowExclude"), dob);
         dob.reset();
         cfamily.clear();
 
@@ -194,14 +198,14 @@ public void testRoundTripStandardCf() throws IOException, ParseException
         // Add rowA
         cfamily.addColumn(new QueryPath("Standard1", null, "name".getBytes()), "val".getBytes(), 1, false);
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
-        writer.append(partitioner.decorateKey("rowA"), dob);
+        writer.append(Util.dk("rowA"), dob);
         dob.reset();
         cfamily.clear();
 
         // Add rowExclude
         cfamily.addColumn(new QueryPath("Standard1", null, "name".getBytes()), "val".getBytes(), 1, false);
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
-        writer.append(partitioner.decorateKey("rowExclude"), dob);
+        writer.append(Util.dk("rowExclude"), dob);
         dob.reset();
         cfamily.clear();
 
@@ -216,15 +220,13 @@ public void testRoundTripStandardCf() throws IOException, ParseException
         SSTableImport.importJson(tempJson.getPath(), "Keyspace1", "Standard1", tempSS2.getPath());        
         
         reader = SSTableReader.open(tempSS2.getPath(), DatabaseDescriptor.getPartitioner());
-        QueryFilter qf = QueryFilter.getNamesFilter("rowA", new QueryPath("Standard1", null, null), "name".getBytes());
+        QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), new QueryPath("Standard1", null, null), "name".getBytes());
         ColumnFamily cf = qf.getSSTableColumnIterator(reader).getColumnFamily();
         assertTrue(cf != null);
         assertTrue(Arrays.equals(cf.getColumn("name".getBytes()).value(), hexToBytes("76616c")));
 
-        qf = QueryFilter.getNamesFilter("rowExclude", new QueryPath("Standard1", null, null), "name".getBytes());
+        qf = QueryFilter.getNamesFilter(Util.dk("rowExclude"), new QueryPath("Standard1", null, null), "name".getBytes());
         cf = qf.getSSTableColumnIterator(reader).getColumnFamily();
         assert cf == null;
-
     }
-    
 }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/tools/SSTableImportTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/tools/SSTableImportTest.java
index c9619179..f19e9a5f 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/tools/SSTableImportTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/tools/SSTableImportTest.java
@@ -32,6 +32,9 @@
 import org.apache.cassandra.io.sstable.SSTableReader;
 import static org.apache.cassandra.utils.FBUtilities.hexToBytes;
 import static org.apache.cassandra.io.sstable.SSTableUtils.tempSSTableFile;
+
+import org.apache.cassandra.Util;
+
 import org.json.simple.parser.ParseException;
 import org.junit.Test;
 
@@ -47,7 +50,7 @@ public void testImportSimpleCf() throws IOException, ParseException
 
         // Verify results
         SSTableReader reader = SSTableReader.open(tempSS.getPath(), DatabaseDescriptor.getPartitioner());
-        QueryFilter qf = QueryFilter.getNamesFilter("rowA", new QueryPath("Standard1", null, null), "colAA".getBytes());
+        QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), new QueryPath("Standard1", null, null), "colAA".getBytes());
         ColumnFamily cf = qf.getSSTableColumnIterator(reader).getColumnFamily();
         assert Arrays.equals(cf.getColumn("colAA".getBytes()).value(), hexToBytes("76616c4141"));
     }
@@ -61,7 +64,7 @@ public void testImportSuperCf() throws IOException, ParseException
         
         // Verify results
         SSTableReader reader = SSTableReader.open(tempSS.getPath(), DatabaseDescriptor.getPartitioner());
-        QueryFilter qf = QueryFilter.getNamesFilter("rowA", new QueryPath("Super4", null, null), "superA".getBytes());
+        QueryFilter qf = QueryFilter.getNamesFilter(Util.dk("rowA"), new QueryPath("Super4", null, null), "superA".getBytes());
         ColumnFamily cf = qf.getSSTableColumnIterator(reader).getColumnFamily();
         IColumn superCol = cf.getColumn("superA".getBytes());
         assert Arrays.equals(superCol.getSubColumn("colAA".getBytes()).value(), hexToBytes("76616c75654141"));
