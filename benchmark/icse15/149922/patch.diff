diff --git a/lucene/java/trunk/src/java/org/apache/lucene/index/Term.java b/lucene/java/trunk/src/java/org/apache/lucene/index/Term.java
index 76b285c1..b68eb6a1 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/index/Term.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/index/Term.java
@@ -118,9 +118,7 @@ final void set(String fld, String txt) {
     text = txt;
   }
 
-  public final String toString() {
-    return "Term<" + field + ":" + text + ">";
-  }
+  public final String toString() { return field + ":" + text; }
   
   private void readObject(java.io.ObjectInputStream in) 
     throws java.io.IOException, ClassNotFoundException
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/BooleanClause.java b/lucene/java/trunk/src/java/org/apache/lucene/search/BooleanClause.java
index 8429b14f..c12f99fb 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/BooleanClause.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/BooleanClause.java
@@ -74,4 +74,20 @@ public BooleanClause(Query q, boolean r, boolean p) {
     required = r;
     prohibited = p;
   }
+
+  /** Returns true iff <code>o</code> is equal to this. */
+  public boolean equals(Object o) {
+    if (!(o instanceof BooleanClause))
+      return false;
+    BooleanClause other = (BooleanClause)o;
+    return this.query.equals(other.query)
+      && (this.required == other.required)
+      && (this.prohibited == other.prohibited);
+  }
+
+  /** Returns a hash code value for this object.*/
+  public int hashCode() {
+    return query.hashCode() ^ (this.required?1:0) ^ (this.prohibited?2:0);
+  }
+
 }
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/BooleanQuery.java b/lucene/java/trunk/src/java/org/apache/lucene/search/BooleanQuery.java
index 7ff38587..39c3f93e 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/BooleanQuery.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/BooleanQuery.java
@@ -90,48 +90,66 @@ public void add(BooleanClause clause) {
     clauses.addElement(clause);
   }
 
-  void prepare(IndexReader reader) {
+  /** Returns the set of clauses in this query. */
+  public BooleanClause[] getClauses() {
+    return (BooleanClause[])clauses.toArray(new BooleanClause[0]);
+  }
+
+  private class BooleanWeight implements Weight {
+    private Searcher searcher;
+    private float norm;
+    private Vector weights = new Vector();
+
+    public BooleanWeight(Searcher searcher) {
+      this.searcher = searcher;
     for (int i = 0 ; i < clauses.size(); i++) {
       BooleanClause c = (BooleanClause)clauses.elementAt(i);
-      c.query.prepare(reader);
+        weights.add(c.query.createWeight(searcher));
     }
   }
 
-  float sumOfSquaredWeights(Searcher searcher)
-       throws IOException {
-    float sum = 0.0f;
+    public Query getQuery() { return BooleanQuery.this; }
+    public float getValue() { return getBoost(); }
 
-    for (int i = 0 ; i < clauses.size(); i++) {
+    public float sumOfSquaredWeights() throws IOException {
+      float sum = 0.0f;
+      for (int i = 0 ; i < weights.size(); i++) {
       BooleanClause c = (BooleanClause)clauses.elementAt(i);
+        Weight w = (Weight)weights.elementAt(i);
       if (!c.prohibited)
-	sum += c.query.sumOfSquaredWeights(searcher); // sum sub-query weights
+          sum += w.sumOfSquaredWeights();         // sum sub weights
     }
 
-    return sum;
+      sum *= getBoost() * getBoost();             // boost each sub-weight
+
+      return sum ;
   }
 
-  void normalize(float norm) {
-    for (int i = 0 ; i < clauses.size(); i++) {
+
+    public void normalize(float norm) {
+      norm *= getBoost();                         // incorporate boost
+      for (int i = 0 ; i < weights.size(); i++) {
       BooleanClause c = (BooleanClause)clauses.elementAt(i);
+        Weight w = (Weight)weights.elementAt(i);
       if (!c.prohibited)
-	c.query.normalize(norm);
+          w.normalize(norm);
     }
   }
 
-  Scorer scorer(IndexReader reader, Similarity similarity)
-       throws IOException {
-
-    if (clauses.size() == 1) {			  // optimize 1-term queries
+    public Scorer scorer(IndexReader reader) throws IOException {
+      if (weights.size() == 1) {                  // optimize 1-clause queries
       BooleanClause c = (BooleanClause)clauses.elementAt(0);
-      if (!c.prohibited)			  // just return term scorer
-	return c.query.scorer(reader, similarity);
+        Weight w = (Weight)weights.elementAt(0);
+        if (!c.prohibited)			  // just return clause scorer
+          return w.scorer(reader);
     }
 
-    BooleanScorer result = new BooleanScorer(similarity);
+      BooleanScorer result = new BooleanScorer(searcher.getSimilarity());
 
-    for (int i = 0 ; i < clauses.size(); i++) {
-      BooleanClause c = (BooleanClause)clauses.elementAt(i);
-      Scorer subScorer = c.query.scorer(reader, similarity);
+      for (int i = 0 ; i < weights.size(); i++) {
+        BooleanClause c = (BooleanClause)clauses.elementAt(0);
+        Weight w = (Weight)weights.elementAt(i);
+        Scorer subScorer = w.scorer(reader);
       if (subScorer != null)
 	result.add(subScorer, c.required, c.prohibited);
       else if (c.required)
@@ -141,9 +159,26 @@ else if (c.required)
     return result;
   }
 
+    public Explanation explain() throws IOException {
+      Explanation result = new Explanation();
+      result.setDescription("boost(" + getQuery() + ")");
+      result.setValue(getBoost());
+      return result;
+    }
+
+  }
+
+  protected Weight createWeight(Searcher searcher) {
+    return new BooleanWeight(searcher);
+  }
+
   /** Prints a user-readable version of this query. */
   public String toString(String field) {
     StringBuffer buffer = new StringBuffer();
+    if (getBoost() > 1.0) {
+      buffer.append("(");
+    }
+
     for (int i = 0 ; i < clauses.size(); i++) {
       BooleanClause c = (BooleanClause)clauses.elementAt(i);
       if (c.prohibited)
@@ -162,7 +197,27 @@ else if (c.required)
       if (i != clauses.size()-1)
 	buffer.append(" ");
     }
+
+    if (getBoost() > 1.0) {
+      buffer.append(")^");
+      buffer.append(getBoost());
+    }
+
     return buffer.toString();
   }
 
+  /** Returns true iff <code>o</code> is equal to this. */
+  public boolean equals(Object o) {
+    if (!(o instanceof BooleanQuery))
+      return false;
+    BooleanQuery other = (BooleanQuery)o;
+    return (this.getBoost() == other.getBoost())
+      &&  this.clauses.equals(other.clauses);
+  }
+
+  /** Returns a hash code value for this object.*/
+  public int hashCode() {
+    return Float.floatToIntBits(getBoost()) ^ clauses.hashCode();
+  }
+
 }
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/BooleanScorer.java b/lucene/java/trunk/src/java/org/apache/lucene/search/BooleanScorer.java
index fcbcddea..8556414c 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/BooleanScorer.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/BooleanScorer.java
@@ -119,10 +119,11 @@ else if (required)
   private final void computeCoordFactors() throws IOException {
     coordFactors = new float[maxCoord];
     for (int i = 0; i < maxCoord; i++)
-      coordFactors[i] = getSimilarity().coord(i, maxCoord);
+      coordFactors[i] = getSimilarity().coord(i, maxCoord-1);
   }
 
-  final void score(HitCollector results, int maxDoc) throws IOException {
+  public final void score(HitCollector results, int maxDoc)
+    throws IOException {
     if (coordFactors == null)
       computeCoordFactors();
 
@@ -207,4 +208,43 @@ public final void collect(final int doc, final float score) {
       }
     }
   }
+
+  public Explanation explain(int doc) throws IOException {
+    Explanation sumExpl = new Explanation();
+    sumExpl.setDescription("sum of:");
+    int coord = 0;
+    float sum = 0.0f;
+    for (SubScorer s = scorers; s != null; s = s.next) {
+      Explanation e = s.scorer.explain(doc);
+      if (e.getValue() > 0) {
+        if (!s.prohibited) {
+          sumExpl.addDetail(e);
+          sum += e.getValue();
+          coord++;
+        } else {
+          return new Explanation(0.0f, "match prohibited");
+        }
+      } else if (s.required) {
+        return new Explanation(0.0f, "match required");
+      }
+    }
+    sumExpl.setValue(sum);
+
+    if (coord == 1)                               // only one clause matched
+      sumExpl = sumExpl.getDetails()[0];          // eliminate wrapper
+
+    float coordFactor = getSimilarity().coord(coord, maxCoord-1);
+    if (coordFactor == 1.0f)                      // coord is no-op
+      return sumExpl;                             // eliminate wrapper
+    else {
+      Explanation result = new Explanation();
+      result.setDescription("product of:");
+      result.addDetail(sumExpl);
+      result.addDetail(new Explanation(coordFactor,
+                                       "coord("+coord+"/"+(maxCoord-1)+")"));
+      result.setValue(sum*coordFactor);
+      return result;
+    }
+  }
+
 }
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/ExactPhraseScorer.java b/lucene/java/trunk/src/java/org/apache/lucene/search/ExactPhraseScorer.java
index 76785277..c3aee7ce 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/ExactPhraseScorer.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/ExactPhraseScorer.java
@@ -63,9 +63,9 @@
 
 final class ExactPhraseScorer extends PhraseScorer {
 
-  ExactPhraseScorer(TermPositions[] tps, Similarity similarity,
-                    byte[] norms, float weight) throws IOException {
-    super(tps, similarity, norms, weight);
+  ExactPhraseScorer(Weight weight, TermPositions[] tps, Similarity similarity,
+                    byte[] norms) throws IOException {
+    super(weight, tps, similarity, norms);
   }
 
   protected final float phraseFreq() throws IOException {
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/Explanation.java b/lucene/java/trunk/src/java/org/apache/lucene/search/Explanation.java
index b7b0a631..94373dd2 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/Explanation.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/Explanation.java
@@ -1,2 +1,147 @@
   - 1.22
   + 1.23
+package org.apache.lucene.search;
+
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2003 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" and
+ *    "Apache Lucene" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    "Apache Lucene", nor may "Apache" appear in their name, without
+ *    prior written permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ */
+
+import java.util.ArrayList;
+
+/** Expert: Describes the score computation for document and query. */
+public class Explanation implements java.io.Serializable {
+  private float value;                            // the value of this node
+  private String description;                     // what it represents
+  private ArrayList details;                      // sub-explanations
+
+  public Explanation() {}
+
+  public Explanation(float value, String description) {
+    this.value = value;
+    this.description = description;
+  }
+
+  /** The value assigned to this explanation node. */
+  public float getValue() { return value; }
+  /** Sets the value assigned to this explanation node. */
+  public void setValue(float value) { this.value = value; }
+
+  /** A description of this explanation node. */
+  public String getDescription() { return description; }
+  /** Sets the description of this explanation node. */
+  public void setDescription(String description) {
+    this.description = description;
+  }
+
+  /** The sub-nodes of this explanation node. */
+  public Explanation[] getDetails() {
+    if (details == null)
+      return null;
+    return (Explanation[])details.toArray(new Explanation[0]);
+  }
+
+  /** Adds a sub-node to this explanation node. */
+  public void addDetail(Explanation detail) {
+    if (details == null)
+      details = new ArrayList();
+    details.add(detail);
+  }
+
+  /** Render an explanation as HTML. */
+  public String toString() {
+    return toString(0);
+  }
+  private String toString(int depth) {
+    StringBuffer buffer = new StringBuffer();
+    for (int i = 0; i < depth; i++) {
+      buffer.append("  ");
+    }
+    buffer.append(getValue());
+    buffer.append(" = ");
+    buffer.append(getDescription());
+    buffer.append("\n");
+
+    Explanation[] details = getDetails();
+    if (details != null) {
+      for (int i = 0 ; i < details.length; i++) {
+        buffer.append(details[i].toString(depth+1));
+      }
+    }
+
+    return buffer.toString();
+  }
+
+
+  /** Render an explanation as HTML. */
+  public String toHtml() {
+    StringBuffer buffer = new StringBuffer();
+    buffer.append("<ul>\n");
+
+    buffer.append("<li>");
+    buffer.append(getValue());
+    buffer.append(" = ");
+    buffer.append(getDescription());
+    buffer.append("</li>\n");
+
+    Explanation[] details = getDetails();
+    if (details != null) {
+      for (int i = 0 ; i < details.length; i++) {
+        buffer.append(details[i].toHtml());
+      }
+    }
+
+    buffer.append("</ul>\n");
+
+    return buffer.toString();
+  }
+}
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/FuzzyQuery.java b/lucene/java/trunk/src/java/org/apache/lucene/search/FuzzyQuery.java
index de53d795..b907a808 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/FuzzyQuery.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/FuzzyQuery.java
@@ -62,17 +62,12 @@
 
 /** Implements the fuzzy search query */
 public final class FuzzyQuery extends MultiTermQuery {
-    private Term fuzzyTerm;
-    
     public FuzzyQuery(Term term) {
         super(term);
-        fuzzyTerm = term;
     }
     
-    final void prepare(IndexReader reader) {
-        try {
-            setEnum(new FuzzyTermEnum(reader, fuzzyTerm));
-        } catch (IOException e) {}
+  protected FilteredTermEnum getEnum(IndexReader reader) throws IOException {
+    return new FuzzyTermEnum(reader, getTerm());
     }
     
     public String toString(String field) {
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/Hits.java b/lucene/java/trunk/src/java/org/apache/lucene/search/Hits.java
index 27d4deb7..54290ced 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/Hits.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/Hits.java
@@ -95,8 +95,8 @@ private final void getMoreDocs(int min) throws IOException {
     ScoreDoc[] scoreDocs = topDocs.scoreDocs;
 
     float scoreNorm = 1.0f;
-    if (length > 0 && scoreDocs[0].score > 1.0f)
-      scoreNorm = 1.0f / scoreDocs[0].score;
+//     if (length > 0 && scoreDocs[0].score > 1.0f)
+//       scoreNorm = 1.0f / scoreDocs[0].score;
 
     int end = scoreDocs.length < length ? scoreDocs.length : length;
     for (int i = hitDocs.size(); i < end; i++)
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/IndexSearcher.java b/lucene/java/trunk/src/java/org/apache/lucene/search/IndexSearcher.java
index b6fcc403..e511f78c 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/IndexSearcher.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/IndexSearcher.java
@@ -124,7 +124,7 @@ public int maxDoc() throws IOException {
    */
   public TopDocs search(Query query, Filter filter, final int nDocs)
        throws IOException {
-    Scorer scorer = Query.scorer(query, this, reader);
+    Scorer scorer = query.weight(this).scorer(reader);
     if (scorer == null)
       return new TopDocs(0, new ScoreDoc[0]);
 
@@ -183,10 +183,25 @@ public final void collect(int doc, float score) {
 	};
     }
 
-    Scorer scorer = Query.scorer(query, this, reader);
+    Scorer scorer = query.weight(this).scorer(reader);
     if (scorer == null)
       return;
     scorer.score(collector, reader.maxDoc());
   }
 
+  /** */
+  public Query rewrite(Query original) throws IOException {
+    Query query = original;
+    for (Query rewrittenQuery = query.rewrite(reader); rewrittenQuery != query;
+         rewrittenQuery = query.rewrite(reader)) {
+      query = rewrittenQuery;
+    }
+    return query;
+  }
+
+  /** */
+  public Explanation explain(Query query, int doc) throws IOException {
+    return query.weight(this).scorer(reader).explain(doc);
+  }
+
 }
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/MultiSearcher.java b/lucene/java/trunk/src/java/org/apache/lucene/search/MultiSearcher.java
index f813940d..2039287c 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/MultiSearcher.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/MultiSearcher.java
@@ -205,4 +205,21 @@ public void collect(int doc, float score) {
 
     }
   }
+  
+  /** */
+  public Query rewrite(Query original) throws IOException {
+    Query[] queries = new Query[searchables.length];
+    for (int i = 0; i < searchables.length; i++) {
+      queries[i] = searchables[i].rewrite(original);
+    }
+    return original.combine(queries);
+  }
+
+
+  /** */
+  public Explanation explain(Query query, int doc) throws IOException {
+    int i = subSearcher(doc);			  // find searcher index
+    return searchables[i].explain(query,doc-starts[i]); // dispatch to searcher
+  }
+
 }
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/MultiTermQuery.java b/lucene/java/trunk/src/java/org/apache/lucene/search/MultiTermQuery.java
index 0959fedd..daefc414 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/MultiTermQuery.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/MultiTermQuery.java
@@ -75,81 +75,55 @@
  * <code>MultiTermQuery</code> to provide {@link WildcardTermEnum} and
  * {@link FuzzyTermEnum}, respectively.
  */
-public class MultiTermQuery extends Query {
+public abstract class MultiTermQuery extends Query {
     private Term term;
-    private FilteredTermEnum enum;
-    private BooleanQuery query;
-    
-    /** Enable or disable lucene style toString(field) format */
-    private static boolean LUCENE_STYLE_TOSTRING = false;
     
     /** Constructs a query for terms matching <code>term</code>. */
     public MultiTermQuery(Term term) {
         this.term = term;
     }
     
-    /** Set the TermEnum to be used */
-    protected void setEnum(FilteredTermEnum enum) {
-        this.enum = enum;
-    }
-    
-    final float sumOfSquaredWeights(Searcher searcher) throws IOException {
-        return getQuery().sumOfSquaredWeights(searcher);
-    }
-    
-    final void normalize(float norm) {
-        try {
-            getQuery().normalize(norm);
-        } catch (IOException e) {
-            throw new RuntimeException(e.toString());
-        }
-    }
+    /** Returns the pattern term. */
+    public Term getTerm() { return term; }
     
-    final Scorer scorer(IndexReader reader, Similarity similarity)
-      throws IOException {
-      return getQuery().scorer(reader, similarity);
-    }
+    /** Construct the enumeration to be used, expanding the pattern term. */
+    protected abstract FilteredTermEnum getEnum(IndexReader reader)
+      throws IOException;
     
-    private final BooleanQuery getQuery() throws IOException {
-        if (query == null) {
-            BooleanQuery q = new BooleanQuery();
+    public Query rewrite(IndexReader reader) throws IOException {
+      FilteredTermEnum enum = getEnum(reader);
+      BooleanQuery query = new BooleanQuery();
             try {
                 do {
                     Term t = enum.term();
                     if (t != null) {
                         TermQuery tq = new TermQuery(t);	// found a match
-                        tq.setBoost(boost * enum.difference()); // set the boost
-                        q.add(tq, false, false);		// add to q
+            tq.setBoost(getBoost() * enum.difference()); // set the boost
+            query.add(tq, false, false);          // add to query
                     }
                 } while (enum.next());
             } finally {
                 enum.close();
             }
-            query = q;
-        }
         return query;
     }
     
+    public Query combine(Query[] queries) {
+      return Query.mergeBooleanQueries(queries);
+    }
+
+
     /** Prints a user-readable version of this query. */
     public String toString(String field) {
-        if (!LUCENE_STYLE_TOSTRING) {
-            Query q = null;
-            try {
-                q = getQuery();
-            } catch (Exception e) {}
-            if (q != null) {
-                return "(" + q.toString(field) + ")";
-            }
-        }
         StringBuffer buffer = new StringBuffer();
         if (!term.field().equals(field)) {
             buffer.append(term.field());
             buffer.append(":");
         }
         buffer.append(term.text());
-        if (boost != 1.0f) {
+        if (getBoost() != 1.0f) {
             buffer.append("^");
-            buffer.append(Float.toString(boost));
+            buffer.append(Float.toString(getBoost()));
         }
         return buffer.toString();
     }
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/PhrasePrefixQuery.java b/lucene/java/trunk/src/java/org/apache/lucene/search/PhrasePrefixQuery.java
index 0cb54c72..7da6d27c 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/PhrasePrefixQuery.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/PhrasePrefixQuery.java
@@ -64,6 +64,7 @@
 import org.apache.lucene.index.MultipleTermPositions;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermPositions;
+import org.apache.lucene.index.TermDocs;
 import org.apache.lucene.search.Query;
 
 /**
@@ -77,99 +78,102 @@
  * @author Anders Nielsen
  * @version 1.0
  */
-public class PhrasePrefixQuery
-    extends Query
-{
-    private String _field;
-    private ArrayList _termArrays = new ArrayList();
+public class PhrasePrefixQuery extends Query {
+  private String field;
+  private ArrayList termArrays = new ArrayList();
 
-    private float _idf = 0.0f;
-    private float _weight = 0.0f;
+  private float idf = 0.0f;
+  private float weight = 0.0f;
 
-    private int _slop = 0;
+  private int slop = 0;
 
-    /**
-     * Creates a new <code>PhrasePrefixQuery</code> instance.
-     *
+  /* Sets the phrase slop for this query.
+   * @see PhraseQuery#setSlop(int)
      */
-    public PhrasePrefixQuery()
-    {
-    }
+  public void setSlop(int s) { slop = s; }
 
-    /**
-     * Describe <code>setSlop</code> method here.
-     *
-     * @param s an <code>int</code> value
+  /* Sets the phrase slop for this query.
+   * @see PhraseQuery#getSlop()
      */
-    public void setSlop(int s)
-    {
-	_slop = s;
-    }
+  public int getSlop() { return slop; }
 
-    /**
-     * Describe <code>getSlop</code> method here.
-     *
-     * @return an <code>int</code> value
+  /* Add a single term at the next position in the phrase.
+   * @see PhraseQuery#add(Term)
      */
-    public int getSlop()
-    {
-	return _slop;
-    }
+  public void add(Term term) { add(new Term[]{term}); }
 
-    /**
-     * Describe <code>add</code> method here.
+  /* Add multiple terms at the next position in the phrase.  Any of the terms
+   * may match.
      *
-     * @param term a <code>Term</code> value
+   * @see PhraseQuery#add(Term)
      */
-    public void add(Term term)
-    {
-	add(new Term[]{term});
+  public void add(Term[] terms) {
+    if (termArrays.size() == 0)
+      field = terms[0].field();
+    
+    for (int i=0; i<terms.length; i++) {
+      if (terms[i].field() != field) {
+        throw new IllegalArgumentException
+          ("All phrase terms must be in the same field (" + field + "): "
+           + terms[i]);
+      }
     }
 
-    /**
-     * Describe <code>add</code> method here.
-     *
-     * @param terms a <code>Term[]</code> value
-     */
-    public void add(Term[] terms)
-    {
-	if (_termArrays.size() == 0)
-	    _field = terms[0].field();
-
-      	for (int i=0; i<terms.length; i++)
-	{
-	    if (terms[i].field() != _field)
-	    {
-		throw new IllegalArgumentException(
-		    "All phrase terms must be in the same field (" + _field + "): "
-		    + terms[i]);
+    termArrays.add(terms);
+  }
+
+  private class PhrasePrefixWeight implements Weight {
+    private Searcher searcher;
+    private float value;
+    private float idf;
+    private float queryNorm;
+
+    public PhrasePrefixWeight(Searcher searcher) {
+      this.searcher = searcher;
 	    }
+
+    public Query getQuery() { return PhrasePrefixQuery.this; }
+    public float getValue() { return value; }
+
+    public float sumOfSquaredWeights() throws IOException {
+      Iterator i = termArrays.iterator();
+      while (i.hasNext()) {
+        Term[] terms = (Term[])i.next();
+        for (int j=0; j<terms.length; j++)
+          idf += searcher.getSimilarity().idf(terms[j], searcher);
+      }
+
+      value = idf * getBoost();
+      return value * value;
 	}
 
-	_termArrays.add(terms);
+    public void normalize(float norm) {
+      queryNorm = norm;
+      queryNorm *= idf;                           // factor from document
+      value *= queryNorm;                         // normalize for query
     }
 
-    Scorer scorer(IndexReader reader, Similarity similarity)
-	throws IOException
-    {
-    	if (_termArrays.size() == 0)  // optimize zero-term case
+    public Scorer scorer(IndexReader reader) throws IOException {
+      if (termArrays.size() == 0)                  // optimize zero-term case
 	    return null;
 
-	if (_termArrays.size() == 1)  // optimize one-term case
-	{
-	    Term[] terms = (Term[])_termArrays.get(0);
+      if (termArrays.size() == 1) {                // optimize one-term case
+        Term[] terms = (Term[])termArrays.get(0);
 
-	    BooleanQuery boq = new BooleanQuery();
-	    for (int i=0; i<terms.length; i++)
-		boq.add(new TermQuery(terms[i]), false, false);
+        BooleanScorer bos = new BooleanScorer(searcher.getSimilarity());
+        for (int i=0; i<terms.length; i++) {
+          TermDocs docs = reader.termDocs(terms[i]);
+          if (docs != null)
+            bos.add(new TermScorer(this, docs, searcher.getSimilarity(),
+                                   reader.norms(field)), false, false);
+        }
 
-	    return boq.scorer(reader, similarity);
+        return bos;
     	}
 
-    	TermPositions[] tps = new TermPositions[_termArrays.size()];
-	for (int i=0; i<tps.length; i++)
-	{
-	    Term[] terms = (Term[])_termArrays.get(i);
+      TermPositions[] tps = new TermPositions[termArrays.size()];
+      for (int i=0; i<tps.length; i++) {
+        Term[] terms = (Term[])termArrays.get(i);
 
 	    TermPositions p;
 	    if (terms.length > 1)
@@ -183,72 +187,66 @@ Scorer scorer(IndexReader reader, Similarity similarity)
 	    tps[i] = p;
 	}
 
-	if (_slop == 0)
-	    return new ExactPhraseScorer(tps, similarity,
-                                         reader.norms(_field), _weight);
+      if (slop == 0)
+        return new ExactPhraseScorer(this, tps, searcher.getSimilarity(),
+                                     reader.norms(field));
 	else
-	    return new SloppyPhraseScorer(tps, similarity, _slop,
-                                          reader.norms(_field), _weight);
+        return new SloppyPhraseScorer(this, tps, searcher.getSimilarity(),
+                                      slop, reader.norms(field));
     }
 
-    float sumOfSquaredWeights(Searcher searcher)
-	throws IOException
-    {
-	Iterator i = _termArrays.iterator();
-	while (i.hasNext())
-	{
-	    Term[] terms = (Term[])i.next();
-	    for (int j=0; j<terms.length; j++)
-		_idf += searcher.getSimilarity().idf(terms[j], searcher);
-	}
+    public Explanation explain() throws IOException {
+      Query q = getQuery();
+
+      Explanation result = new Explanation();
+      result.setDescription("weight(" + getQuery() + "), product of:");
+
+      Explanation boostExpl = new Explanation(getBoost(), "boost");
+      if (getBoost() != 1.0f)
+        result.addDetail(boostExpl);
+      
+      Explanation idfExpl = new Explanation(idf, "idf");
+      result.addDetail(idfExpl);
+      
+      Explanation normExpl = new Explanation(queryNorm, "queryNorm");
+      result.addDetail(normExpl);
 
-	_weight = _idf * boost;
-	return _weight * _weight;
+      result.setValue(boostExpl.getValue() *
+                      idfExpl.getValue() *
+                      normExpl.getValue());
+
+      return result;
+    }
     }
 
-    void normalize(float norm)
-    {
-	_weight *= norm;
-	_weight *= _idf;
+  protected Weight createWeight(Searcher searcher) {
+    return new PhrasePrefixWeight(searcher);
     }
 
-    /**
-     * Describe <code>toString</code> method here.
-     *
-     * This method assumes that the first term in a array of terms is the
-     * prefix for the whole array. That might not necessarily be so.
-     *
-     * @param f a <code>String</code> value
-     * @return a <code>String</code> value
-     */
-    public final String toString(String f)
-    {
+  /** Prints a user-readable version of this query. */
+  public final String toString(String f) {
 	StringBuffer buffer = new StringBuffer();
-	if (!_field.equals(f))
-	{
-	    buffer.append(_field);
+    if (!field.equals(f)) {
+      buffer.append(field);
 	    buffer.append(":");
 	}
 
 	buffer.append("\"");
-	Iterator i = _termArrays.iterator();
-	while (i.hasNext())
-	{
+    Iterator i = termArrays.iterator();
+    while (i.hasNext()) {
 	    Term[] terms = (Term[])i.next();
 	    buffer.append(terms[0].text() + (terms.length > 0 ? "*" : ""));
 	}
 	buffer.append("\"");
 
-	if (_slop != 0)
-	{
+    if (slop != 0) {
 	    buffer.append("~");
-	    buffer.append(_slop);
+      buffer.append(slop);
 	}
 
-	if (boost != 1.0f)
-	{
+    if (getBoost() != 1.0f) {
 	    buffer.append("^");
-	    buffer.append(Float.toString(boost));
+      buffer.append(Float.toString(getBoost()));
 	}
 
 	return buffer.toString();
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/PhraseQuery.java b/lucene/java/trunk/src/java/org/apache/lucene/search/PhraseQuery.java
index 4f671d19..165afc06 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/PhraseQuery.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/PhraseQuery.java
@@ -70,15 +70,10 @@
 public class PhraseQuery extends Query {
   private String field;
   private Vector terms = new Vector();
-  private float idf = 0.0f;
-  private float weight = 0.0f;
-
   private int slop = 0;
 
-
   /** Constructs an empty phrase query. */
-  public PhraseQuery() {
-  }
+  public PhraseQuery() {}
 
   /** Sets the number of other words permitted between words in query phrase.
     If zero, then this is an exact phrase search.  For larger values this works
@@ -109,19 +104,37 @@ else if (term.field() != field)
     terms.addElement(term);
   }
 
-  final float sumOfSquaredWeights(Searcher searcher) throws IOException {
+  /** Returns the set of terms in this phrase. */
+  public Term[] getTerms() {
+    return (Term[])terms.toArray(new Term[0]);
+  }
+
+  private class PhraseWeight implements Weight {
+    private Searcher searcher;
+    private float value;
+    private float idf;
+    private float queryNorm;
+
+    public PhraseWeight(Searcher searcher) {
+      this.searcher = searcher;
+    }
+
+    public Query getQuery() { return PhraseQuery.this; }
+    public float getValue() { return value; }
+
+    public float sumOfSquaredWeights() throws IOException {
     idf = searcher.getSimilarity().idf(terms, searcher);
-    weight = idf * boost;
-    return weight * weight;			  // square term weights
+      value = idf * getBoost();
+      return value * value;			  // square term weights
   }
 
-  final void normalize(float norm) {
-    weight *= norm;				  // normalize for query
-    weight *= idf;				  // factor from document
+    public void normalize(float norm) {
+      queryNorm = norm;
+      queryNorm *= idf;                           // factor from document
+      value *= queryNorm;                         // normalize for query
   }
 
-  final Scorer scorer(IndexReader reader, Similarity similarity)
-    throws IOException {
+    public Scorer scorer(IndexReader reader) throws IOException {
     if (terms.size() == 0)			  // optimize zero-term case
       return null;
     if (terms.size() == 1) {			  // optimize one-term case
@@ -129,8 +142,8 @@ final Scorer scorer(IndexReader reader, Similarity similarity)
       TermDocs docs = reader.termDocs(term);
       if (docs == null)
 	return null;
-      return new TermScorer(docs, similarity,
-                            reader.norms(term.field()), weight);
+        return new TermScorer(this, docs, searcher.getSimilarity(),
+                              reader.norms(term.field()));
     }
 
     TermPositions[] tps = new TermPositions[terms.size()];
@@ -142,15 +155,52 @@ final Scorer scorer(IndexReader reader, Similarity similarity)
     }
 
     if (slop == 0)				  // optimize exact case
-      return new ExactPhraseScorer(tps, similarity,
-                                   reader.norms(field), weight);
+        return new ExactPhraseScorer(this, tps, searcher.getSimilarity(),
+                                     reader.norms(field));
     else
       return
-	new SloppyPhraseScorer(tps, similarity, slop,
-                               reader.norms(field), weight);
+          new SloppyPhraseScorer(this, tps, searcher.getSimilarity(), slop,
+                                 reader.norms(field));
+      
+    }
 
+    public Explanation explain() throws IOException {
+      Query q = getQuery();
+
+      Explanation result = new Explanation();
+      result.setDescription("weight(" + getQuery() + "), product of:");
+
+      Explanation boostExpl = new Explanation(getBoost(), "boost");
+      if (getBoost() != 1.0f)
+        result.addDetail(boostExpl);
+
+      StringBuffer docFreqs = new StringBuffer();
+      for (int i = 0; i < terms.size(); i++) {
+        if (i != 0) docFreqs.append(" ");
+        docFreqs.append(((Term)terms.elementAt(i)).text());
+        docFreqs.append("=");
+        docFreqs.append(searcher.docFreq((Term)terms.elementAt(i)));
+      }
+      Explanation idfExpl =
+        new Explanation(idf, "idf(" + field + ": " + docFreqs + ")");
+      result.addDetail(idfExpl);
+      
+      Explanation normExpl = new Explanation(queryNorm, "queryNorm");
+      result.addDetail(normExpl);
+
+      result.setValue(boostExpl.getValue() *
+                      idfExpl.getValue() *
+                      normExpl.getValue());
+
+      return result;
+    }
+  }
+
+  protected Weight createWeight(Searcher searcher) {
+    return new PhraseWeight(searcher);
   }
 
+
   /** Prints a user-readable version of this query. */
   public String toString(String f) {
     StringBuffer buffer = new StringBuffer();
@@ -172,11 +222,29 @@ public String toString(String f) {
       buffer.append(slop);
     }
 
-    if (boost != 1.0f) {
+    if (getBoost() != 1.0f) {
       buffer.append("^");
-      buffer.append(Float.toString(boost));
+      buffer.append(Float.toString(getBoost()));
     }
 
     return buffer.toString();
   }
+
+  /** Returns true iff <code>o</code> is equal to this. */
+  public boolean equals(Object o) {
+    if (!(o instanceof PhraseQuery))
+      return false;
+    PhraseQuery other = (PhraseQuery)o;
+    return (this.getBoost() == other.getBoost())
+      && (this.slop == other.slop)
+      &&  this.terms.equals(other.terms);
+  }
+
+  /** Returns a hash code value for this object.*/
+  public int hashCode() {
+    return Float.floatToIntBits(getBoost())
+      ^ Float.floatToIntBits(slop)
+      ^ terms.hashCode();
+  }
+
 }
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/PhraseScorer.java b/lucene/java/trunk/src/java/org/apache/lucene/search/PhraseScorer.java
index 8a3d7de5..2b0b1515 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/PhraseScorer.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/PhraseScorer.java
@@ -62,17 +62,21 @@
 import org.apache.lucene.index.*;
 
 abstract class PhraseScorer extends Scorer {
+  private Weight weight;
   protected byte[] norms;
-  protected float weight;
+  protected float value;
 
   protected PhraseQueue pq;
   protected PhrasePositions first, last;
 
-  PhraseScorer(TermPositions[] tps, Similarity similarity,
-               byte[] norms, float weight) throws IOException {
+  private float freq;
+
+  PhraseScorer(Weight weight, TermPositions[] tps, Similarity similarity,
+               byte[] norms) throws IOException {
     super(similarity);
     this.norms = norms;
     this.weight = weight;
+    this.value = weight.getValue();
 
     // use PQ to build a sorted list of PhrasePositions
     pq = new PhraseQueue(tps.length);
@@ -81,7 +85,7 @@
     pqToList();
   }
 
-  final void score(HitCollector results, int end) throws IOException {
+  public final void score(HitCollector results, int end) throws IOException {
     Similarity similarity = getSimilarity();
     while (last.doc < end) {			  // find doc w/ all the terms
       while (first.doc < last.doc) {		  // scan forward in first
@@ -94,10 +98,10 @@ final void score(HitCollector results, int end) throws IOException {
       }
 
       // found doc with all terms
-      float freq = phraseFreq();		  // check for phrase
+      freq = phraseFreq();                        // check for phrase
 
       if (freq > 0.0) {
-	float score = similarity.tf(freq)*weight; // compute score
+	float score = similarity.tf(freq)*value;  // compute score
 	score *= Similarity.decodeNorm(norms[first.doc]); // normalize
 	results.collect(first.doc, score);	  // add to results
       }
@@ -126,4 +130,37 @@ protected final void firstToLast() {
     first = first.next;
     last.next = null;
   }
+
+  public Explanation explain(final int doc) throws IOException {
+    Explanation result = new Explanation();
+    PhraseQuery query = (PhraseQuery)weight.getQuery();
+
+    result.setDescription("phraseScore(" + query + "), product of:");
+    
+    Explanation weightExplanation = weight.explain();
+    result.addDetail(weightExplanation);
+
+    Explanation tfExplanation = new Explanation();
+    score(new HitCollector() {
+        public final void collect(int d, float score) {}
+      }, doc+1);
+
+    float phraseFreq = (first.doc == doc) ? freq : 0.0f;
+    tfExplanation.setValue(getSimilarity().tf(phraseFreq));
+    tfExplanation.setDescription("tf(phraseFreq=" + phraseFreq + ")");
+    result.addDetail(tfExplanation);
+    
+    Explanation normExplanation = new Explanation();
+    normExplanation.setValue(Similarity.decodeNorm(norms[doc]));
+    String field = query.getTerms()[0].field();
+    normExplanation.setDescription("norm(field="+field + ", doc="+doc + ")");
+    result.addDetail(normExplanation);
+
+    result.setValue(weightExplanation.getValue() *
+                    tfExplanation.getValue() *
+                    normExplanation.getValue());
+    
+    return result;
+  }
+
 }
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/PrefixQuery.java b/lucene/java/trunk/src/java/org/apache/lucene/search/PrefixQuery.java
index 2fc27de2..0b367283 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/PrefixQuery.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/PrefixQuery.java
@@ -65,40 +65,14 @@
 /** A Query that matches documents containing terms with a specified prefix. */
 public class PrefixQuery extends Query {
   private Term prefix;
-  private IndexReader reader;
-  private BooleanQuery query;
 
   /** Constructs a query for terms starting with <code>prefix</code>. */
   public PrefixQuery(Term prefix) {
     this.prefix = prefix;
-    this.reader = reader;
   }
 
-  final void prepare(IndexReader reader) {
-    this.query = null;
-    this.reader = reader;
-  }
-
-  final float sumOfSquaredWeights(Searcher searcher)
-    throws IOException {
-    return getQuery().sumOfSquaredWeights(searcher);
-  }
-
-  void normalize(float norm) {
-    try {
-      getQuery().normalize(norm);
-    } catch (IOException e) {
-      throw new RuntimeException(e.toString());
-    }
-  }
-
-  Scorer scorer(IndexReader reader, Similarity similarity) throws IOException {
-    return getQuery().scorer(reader, similarity);
-  }
-
-  private BooleanQuery getQuery() throws IOException {
-    if (query == null) {
-      BooleanQuery q = new BooleanQuery();
+  public Query rewrite(IndexReader reader) throws IOException {
+    BooleanQuery query = new BooleanQuery();
       TermEnum enum = reader.terms(prefix);
       try {
 	String prefixText = prefix.text();
@@ -109,8 +83,8 @@ private BooleanQuery getQuery() throws IOException {
 	      term.text().startsWith(prefixText) &&
 	      term.field() == prefixField) {
 	    TermQuery tq = new TermQuery(term);	  // found a match
-	    tq.setBoost(boost);			  // set the boost
-	    q.add(tq, false, false);		  // add to q
+          tq.setBoost(getBoost());                // set the boost
+          query.add(tq, false, false);		  // add to query
 	    //System.out.println("added " + term);
 	  } else {
 	    break;
@@ -119,11 +93,13 @@ private BooleanQuery getQuery() throws IOException {
       } finally {
 	enum.close();
       }
-      query = q;
-    }
     return query;
   }
 
+  public Query combine(Query[] queries) {
+    return Query.mergeBooleanQueries(queries);
+  }
+
   /** Prints a user-readable version of this query. */
   public String toString(String field) {
     StringBuffer buffer = new StringBuffer();
@@ -133,9 +109,9 @@ public String toString(String field) {
     }
     buffer.append(prefix.text());
     buffer.append('*');
-    if (boost != 1.0f) {
+    if (getBoost() != 1.0f) {
       buffer.append("^");
-      buffer.append(Float.toString(boost));
+      buffer.append(Float.toString(getBoost()));
     }
     return buffer.toString();
   }
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/Query.java b/lucene/java/trunk/src/java/org/apache/lucene/search/Query.java
index fae569f1..cc731f7d 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/Query.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/Query.java
@@ -57,8 +57,10 @@
  */
 
 import java.io.IOException;
-import java.util.Hashtable;
-import org.apache.lucene.document.Document;
+
+import java.util.HashSet;
+import java.util.Iterator;
+
 import org.apache.lucene.index.IndexReader;
 
 /** The abstract base class for queries.
@@ -78,52 +80,93 @@
     <li>{@link org.apache.lucene.queryParser.QueryParser QueryParser}
     </ul>
 */
-public abstract class Query implements java.io.Serializable
-{
-    // query boost factor
-    protected float boost = 1.0f;
-
-    // query weighting
-    abstract float sumOfSquaredWeights(Searcher searcher) throws IOException;
-    abstract void normalize(float norm);
-
-    // query evaluation
-    abstract Scorer scorer(IndexReader reader, Similarity similarity)
-      throws IOException;
-
-    void prepare(IndexReader reader) {}
-
-    static Scorer scorer(Query query, Searcher searcher, IndexReader reader)
-      throws IOException {
-      Similarity similarity = searcher.getSimilarity();
-      query.prepare(reader);
-      float sum = query.sumOfSquaredWeights(searcher);
-      float norm = similarity.queryNorm(sum);
-      query.normalize(norm);
-      return query.scorer(reader, similarity);
-    }
+public abstract class Query implements java.io.Serializable {
+  private float boost = 1.0f;                     // query boost factor
 
-    /**
-     * Sets the boost for this term to <code>b</code>.  Documents containing
-     * this term will (in addition to the normal weightings) have their score
-     * multiplied by <code>b</code>.
+  /** Sets the boost for this query clause to <code>b</code>.  Documents
+   * matching this clause will (in addition to the normal weightings) have
+   * their score multiplied by <code>b</code>.
      */
     public void setBoost(float b) { boost = b; }
 
-    /**
-     * Gets the boost for this term.  Documents containing
-     * this term will (in addition to the normal weightings) have their score
+  /** Gets the boost for this clause.  Documents matching
+   * this clause will (in addition to the normal weightings) have their score
      * multiplied by <code>b</code>.   The boost is 1.0 by default.
      */
     public float getBoost() { return boost; }
 
-    /**
-     * Prints a query to a string, with <code>field</code> as the default field
-     * for terms.
-     * <p>The representation used is one that is readable by
-     * {@link org.apache.lucene.queryParser.QueryParser QueryParser}
-     * (although, if the query was created by the parser, the printed
-     * representation may not be exactly what was parsed).
+  /** Prints a query to a string, with <code>field</code> as the default field
+   * for terms.  <p>The representation used is one that is readable by {@link
+   * org.apache.lucene.queryParser.QueryParser QueryParser} (although, if the
+   * query was created by the parser, the printed representation may not be
+   * exactly what was parsed).
      */
     public abstract String toString(String field);
+
+  /** Prints a query to a string. */
+  public String toString() {
+    return toString("");
+  }
+
+  /** Expert: Constructs an appropriate Weight implementation for this query.
+   *
+   * <p>Only implemented by primitive queries, which re-write to themselves.
+   */
+  protected Weight createWeight(Searcher searcher) {
+    throw new UnsupportedOperationException();
+  }
+  
+  /** Expert: Constructs an initializes a Weight for a top-level query. */
+  public Weight weight(Searcher searcher)
+    throws IOException {
+    Query query = searcher.rewrite(this);
+    Weight weight = query.createWeight(searcher);
+    float sum = weight.sumOfSquaredWeights();
+    float norm = searcher.getSimilarity().queryNorm(sum);
+    weight.normalize(norm);
+    return weight;
+  }
+
+  /** Expert: called to re-write queries into primitive queries.
+   *
+   * <p>Only implemented by derived queries, with no {@link
+   * #createWeight(Searcher)} implementatation..
+   */
+  public Query rewrite(IndexReader reader) throws IOException {
+    return this;
+  }
+
+  /** Expert: called when re-writing queries under MultiSearcher.
+   *
+   * <p>Only implemented by derived queries, with no {@link
+   * #createWeight(Searcher)} implementatation..
+   */
+  public Query combine(Query[] queries) {
+    throw new UnsupportedOperationException();
+  }
+
+
+  /** Expert: merges the clauses of a set of BooleanQuery's into a single
+   * BooleanQuery.
+   *
+   *<p>A utility for use by {@link #combine(Query[])} implementations.
+   */
+  public static Query mergeBooleanQueries(Query[] queries) {
+    HashSet allClauses = new HashSet();
+    for (int i = 0; i < queries.length; i++) {
+      BooleanClause[] clauses = ((BooleanQuery)queries[i]).getClauses();
+      for (int j = 0; j < clauses.length; j++) {
+        allClauses.add(clauses[j]);
+      }
+    }
+
+    BooleanQuery result = new BooleanQuery();
+    Iterator i = allClauses.iterator();
+    while (i.hasNext()) {
+      result.add((BooleanClause)i.next());
+    }
+    return result;
+  }
+
+
 }
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/RangeQuery.java b/lucene/java/trunk/src/java/org/apache/lucene/search/RangeQuery.java
index cfae1ebf..c2b76135 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/RangeQuery.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/RangeQuery.java
@@ -69,8 +69,6 @@
     private Term lowerTerm;
     private Term upperTerm;
     private boolean inclusive;
-    private IndexReader reader;
-    private BooleanQuery query;
     
     /** Constructs a query selecting all terms greater than 
      * <code>lowerTerm</code> but less than <code>upperTerm</code>.
@@ -93,98 +91,58 @@ public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive)
         this.inclusive = inclusive;
     }
     
-    final void prepare(IndexReader reader)
-    {
-        this.query = null;
-        this.reader = reader;
-    }
-    
-    final float sumOfSquaredWeights(Searcher searcher) throws IOException
-    {
-        return getQuery().sumOfSquaredWeights(searcher);
-    }
-    
-    void normalize(float norm)
-    {
-        try
-        {
-            getQuery().normalize(norm);
-        } 
-        catch (IOException e)
-        {
-            throw new RuntimeException(e.toString());
-        }
-    }
-    
-    Scorer scorer(IndexReader reader, Similarity similarity) throws IOException
-    {
-        return getQuery().scorer(reader, similarity);
-    }
-    
-    private BooleanQuery getQuery() throws IOException
-    {
-        if (query == null)
-        {
-            BooleanQuery q = new BooleanQuery();
+    public Query rewrite(IndexReader reader) throws IOException {
+      BooleanQuery query = new BooleanQuery();
             // if we have a lowerTerm, start there. otherwise, start at beginning
             if (lowerTerm == null) lowerTerm = new Term(getField(), "");
             TermEnum enum = reader.terms(lowerTerm);
-            try
-            {
+      try {
                 String lowerText = null;
                 String field;
                 boolean checkLower = false;
-                if (!inclusive) // make adjustments to set to exclusive
-                {
-                    if (lowerTerm != null)
-                    {
+          if (!inclusive) {             // make adjustments to set to exclusive
+            if (lowerTerm != null) {
                         lowerText = lowerTerm.text();
                         checkLower = true;
                     }
-                    if (upperTerm != null)
-                    {
+            if (upperTerm != null) {
                         // set upperTerm to an actual term in the index
                         TermEnum uppEnum = reader.terms(upperTerm);
                         upperTerm = uppEnum.term();
                     }
                 }
                 String testField = getField();
-                do
-                {
+          do {
                     Term term = enum.term();
-                    if (term != null && term.field() == testField)
-                    {
-                        if (!checkLower || term.text().compareTo(lowerText) > 0) 
-                        {
+            if (term != null && term.field() == testField) {
+              if (!checkLower || term.text().compareTo(lowerText) > 0) {
                             checkLower = false;
-                            if (upperTerm != null)
-                            {
+                if (upperTerm != null) {
                                 int compare = upperTerm.compareTo(term);
                                 /* if beyond the upper term, or is exclusive and
                                  * this is equal to the upper term, break out */
                                 if ((compare < 0) || (!inclusive && compare == 0)) break;
                             }
                             TermQuery tq = new TermQuery(term);	  // found a match
-                            tq.setBoost(boost);               // set the boost
-                            q.add(tq, false, false);		  // add to q
+                tq.setBoost(getBoost());          // set the boost
+                query.add(tq, false, false); // add to query
                         }
                     } 
-                    else
-                    {
+            else {
                         break;
                     }
                 }
                 while (enum.next());
-            } 
-            finally
-            {
+      } finally {
                 enum.close();
             }
-            query = q;
-        }
         return query;
     }
     
+    public Query combine(Query[] queries) {
+      return Query.mergeBooleanQueries(queries);
+    }
+
     private String getField()
     {
         return (lowerTerm != null ? lowerTerm.field() : upperTerm.field());
@@ -204,10 +162,10 @@ public String toString(String field)
         buffer.append("-");
         buffer.append(upperTerm != null ? upperTerm.text() : "null");
         buffer.append(inclusive ? "]" : "}");
-        if (boost != 1.0f)
+        if (getBoost() != 1.0f)
         {
             buffer.append("^");
-            buffer.append(Float.toString(boost));
+            buffer.append(Float.toString(getBoost()));
         }
         return buffer.toString();
     }
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/RemoteSearchable.java b/lucene/java/trunk/src/java/org/apache/lucene/search/RemoteSearchable.java
index e1055826..9def4336 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/RemoteSearchable.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/RemoteSearchable.java
@@ -104,6 +104,14 @@ public Document doc(int i) throws IOException {
     return local.doc(i);
   }
 
+  public Query rewrite(Query original) throws IOException {
+    return local.rewrite(original);
+  }
+
+  public Explanation explain(Query query, int doc) throws IOException {
+    return local.explain(query, doc);
+  }
+
   /** Exports a searcher for the index in args[0] named
    * "//localhost/Searchable". */
   public static void main(String args[]) throws Exception {
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/Scorer.java b/lucene/java/trunk/src/java/org/apache/lucene/search/Scorer.java
index d4ae755b..f3075b19 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/Scorer.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/Scorer.java
@@ -58,16 +58,27 @@
 
 import java.io.IOException;
 
-abstract class Scorer {
+/** Expert: Implements scoring for a class of queries. */
+public abstract class Scorer {
   private Similarity similarity;
 
+  /** Constructs a Scorer. */
   protected Scorer(Similarity similarity) {
     this.similarity = similarity;
   }
 
+  /** Returns the Similarity implementation used by this scorer. */
   public Similarity getSimilarity() {
     return this.similarity;
   }
 
-  abstract void score(HitCollector hc, int maxDoc) throws IOException;
+  /** Scores hits and passes them to a collector.  Stops at the last document
+   * before <code>maxDoc</code>.  If called repeatedly, will restart at point
+   * where it last left off.
+   */
+  public abstract void score(HitCollector hc, int maxDoc) throws IOException;
+
+  /** Returns an explanation of the score for <code>doc</code>. */
+  public abstract Explanation explain(int doc) throws IOException;
+
 }
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/Searchable.java b/lucene/java/trunk/src/java/org/apache/lucene/search/Searchable.java
index a58567de..5dcd6011 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/Searchable.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/Searchable.java
@@ -115,4 +115,12 @@ void search(Query query, Filter filter, HitCollector results)
    * @see IndexReader#document(int).
    */
   Document doc(int i) throws IOException;
+
+  /** */
+  Query rewrite(Query query) throws IOException;
+
+  /** */
+  Explanation explain(Query query, int doc) throws IOException;
+
+
 }
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/SloppyPhraseScorer.java b/lucene/java/trunk/src/java/org/apache/lucene/search/SloppyPhraseScorer.java
index 2a070a11..e706c3a4 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/SloppyPhraseScorer.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/SloppyPhraseScorer.java
@@ -64,9 +64,9 @@
 final class SloppyPhraseScorer extends PhraseScorer {
   private int slop;
 
-  SloppyPhraseScorer(TermPositions[] tps, Similarity similarity,
-                     int slop, byte[] norms, float weight) throws IOException {
-    super(tps, similarity, norms, weight);
+  SloppyPhraseScorer(Weight weight, TermPositions[] tps, Similarity similarity,
+                     int slop, byte[] norms) throws IOException {
+    super(weight, tps, similarity, norms);
     this.slop = slop;
   }
 
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/TermQuery.java b/lucene/java/trunk/src/java/org/apache/lucene/search/TermQuery.java
index 480fbc9b..a80f8355 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/TermQuery.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/TermQuery.java
@@ -66,34 +66,77 @@
   */
 public class TermQuery extends Query {
   private Term term;
-  private float idf = 0.0f;
-  private float weight = 0.0f;
 
-  /** Constructs a query for the term <code>t</code>. */
-  public TermQuery(Term t) {
-    term = t;
+  private class TermWeight implements Weight {
+    private Searcher searcher;
+    private float value;
+    private float idf;
+    private float queryNorm;
+
+    public TermWeight(Searcher searcher) {
+      this.searcher = searcher;
   }
 
-  final float sumOfSquaredWeights(Searcher searcher) throws IOException {
+    public Query getQuery() { return TermQuery.this; }
+    public float getValue() { return value; }
+
+    public float sumOfSquaredWeights() throws IOException {
     idf = searcher.getSimilarity().idf(term, searcher);
-    weight = idf * boost;
-    return weight * weight;			  // square term weights
+      value = idf * getBoost();
+      return value * value;			  // square term weights
   }
 
-  final void normalize(float norm) {
-    weight *= norm;				  // normalize for query
-    weight *= idf;				  // factor from document
+    public void normalize(float norm) {
+      queryNorm = norm;
+      queryNorm *= idf;                           // factor from document
+      value *= queryNorm;                         // normalize for query
   }
 
-  Scorer scorer(IndexReader reader, Similarity similarity)
-       throws IOException {
+    public Scorer scorer(IndexReader reader) throws IOException {
     TermDocs termDocs = reader.termDocs(term);
 
     if (termDocs == null)
       return null;
     
-    return new TermScorer(termDocs, similarity,
-                          reader.norms(term.field()), weight);
+      return new TermScorer(this, termDocs, searcher.getSimilarity(),
+                            reader.norms(term.field()));
+    }
+
+    public Explanation explain() throws IOException {
+      Query q = getQuery();
+
+      Explanation result = new Explanation();
+      result.setDescription("weight(" + getQuery() + "), product of:");
+
+      Explanation boostExpl = new Explanation(getBoost(), "boost");
+      if (getBoost() != 1.0f)
+        result.addDetail(boostExpl);
+      
+      Explanation idfExpl =
+        new Explanation(idf, "idf(docFreq=" + searcher.docFreq(term) + ")");
+      result.addDetail(idfExpl);
+      
+      Explanation normExpl = new Explanation(queryNorm,"queryNorm");
+      result.addDetail(normExpl);
+
+      result.setValue(boostExpl.getValue() *
+                      idfExpl.getValue() *
+                      normExpl.getValue());
+
+      return result;
+    }
+  }
+
+  /** Constructs a query for the term <code>t</code>. */
+  public TermQuery(Term t) {
+    term = t;
+  }
+
+  /** Returns the term of this query. */
+  public Term getTerm() { return term; };
+
+  protected Weight createWeight(Searcher searcher) {
+    return new TermWeight(searcher);
   }
 
   /** Prints a user-readable version of this query. */
@@ -104,10 +147,25 @@ public String toString(String field) {
       buffer.append(":");
     }
     buffer.append(term.text());
-    if (boost != 1.0f) {
+    if (getBoost() != 1.0f) {
       buffer.append("^");
-      buffer.append(Float.toString(boost));
+      buffer.append(Float.toString(getBoost()));
     }
     return buffer.toString();
   }
+
+  /** Returns true iff <code>o</code> is equal to this. */
+  public boolean equals(Object o) {
+    if (!(o instanceof TermQuery))
+      return false;
+    TermQuery other = (TermQuery)o;
+    return (this.getBoost() == other.getBoost())
+      && this.term.equals(other.term);
+  }
+
+  /** Returns a hash code value for this object.*/
+  public int hashCode() {
+    return Float.floatToIntBits(getBoost()) ^ term.hashCode();
+  }
+
 }
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/TermScorer.java b/lucene/java/trunk/src/java/org/apache/lucene/search/TermScorer.java
index 6345e49c..55c7085e 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/TermScorer.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/TermScorer.java
@@ -57,12 +57,14 @@
  */
 
 import java.io.IOException;
+import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermDocs;
 
 final class TermScorer extends Scorer {
+  private Weight weight;
   private TermDocs termDocs;
   private byte[] norms;
-  private float weight;
+  private float weightValue;
   private int doc;
 
   private final int[] docs = new int[32];	  // buffered doc numbers
@@ -73,15 +75,16 @@
   private static final int SCORE_CACHE_SIZE = 32;
   private float[] scoreCache = new float[SCORE_CACHE_SIZE];
 
-  TermScorer(TermDocs td, Similarity similarity, byte[] norms, float weight)
-    throws IOException {
+  TermScorer(Weight weight, TermDocs td, Similarity similarity,
+             byte[] norms) throws IOException {
     super(similarity);
+    this.weight = weight;
     this.termDocs = td;
     this.norms = norms;
-    this.weight = weight;
+    this.weightValue = weight.getValue();
 
     for (int i = 0; i < SCORE_CACHE_SIZE; i++)
-      scoreCache[i] = getSimilarity().tf(i) * weight;
+      scoreCache[i] = getSimilarity().tf(i) * weightValue;
 
     pointerMax = termDocs.read(docs, freqs);	  // fill buffers
 
@@ -93,7 +96,7 @@
     }
   }
 
-  final void score(HitCollector c, final int end) throws IOException {
+  public final void score(HitCollector c, final int end) throws IOException {
     int d = doc;				  // cache doc in local
     Similarity similarity = getSimilarity();      // cache sim in local
     while (d < end) {				  // for docs in window
@@ -101,7 +104,7 @@ final void score(HitCollector c, final int end) throws IOException {
       float score =				  // compute tf(f)*weight
 	f < SCORE_CACHE_SIZE			  // check cache
 	 ? scoreCache[f]			  // cache hit
-	 : similarity.tf(f)*weight;		  // cache miss
+	 : similarity.tf(f)*weightValue;          // cache miss
 
       score *= Similarity.decodeNorm(norms[d]);	  // normalize for field
 
@@ -121,4 +124,45 @@ final void score(HitCollector c, final int end) throws IOException {
     }
     doc = d;					  // flush cache
   }
+
+  public Explanation explain(int doc) throws IOException {
+    Explanation result = new Explanation();
+    TermQuery query = (TermQuery)weight.getQuery();
+
+    result.setDescription("termScore(" + query + "), product of:");
+    
+    Explanation weightExplanation = weight.explain();
+    result.addDetail(weightExplanation);
+
+    Explanation tfExplanation = new Explanation();
+    int tf = 0;
+    while (pointer < pointerMax) {
+      if (docs[pointer] == doc)
+        tf = freqs[pointer];
+      pointer++;
+    }
+    if (tf == 0) {
+      while (termDocs.next()) {
+        if (termDocs.doc() == doc) {
+          tf = termDocs.freq();
+        }
+      }
+    }
+    termDocs.close();
+    tfExplanation.setValue(getSimilarity().tf(tf));
+    tfExplanation.setDescription("tf(termFreq("+query.getTerm()+")="+tf+")");
+    result.addDetail(tfExplanation);
+    
+    Explanation normExplanation = new Explanation();
+    normExplanation.setValue(Similarity.decodeNorm(norms[doc]));
+    String field = query.getTerm().field();
+    normExplanation.setDescription("norm(field="+field + ", doc="+doc + ")");
+    result.addDetail(normExplanation);
+
+    result.setValue(weightExplanation.getValue() *
+                    tfExplanation.getValue() *
+                    normExplanation.getValue());
+    
+    return result;
+  }
 }
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/Weight.java b/lucene/java/trunk/src/java/org/apache/lucene/search/Weight.java
index 5730aadf..db7ff222 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/Weight.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/Weight.java
@@ -1,2 +1,90 @@
   - 1.3
   + 1.4
+package org.apache.lucene.search;
+
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2003 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" and
+ *    "Apache Lucene" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    "Apache Lucene", nor may "Apache" appear in their name, without
+ *    prior written permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.IndexReader;
+
+/** Expert: Calculate query weights and build query scorers.
+ *
+ * <p>A Weight is constructed by a query, given a Searcher ({@link
+ * Query#createWeight(Searcher)}).  The {@link #sumOfSquaredWeights()} method
+ * is then called on the top-level query to compute the query normalization
+ * factor (@link Similarity#queryNorm(float)}).  This factor is then passed to
+ * {@link #normalize(float)}.  At this point the weighting is complete and a
+ * scorer may be constructed by calling {@link #scorer(IndexReader)}.
+ */
+public interface Weight extends java.io.Serializable {
+  /** The query that this concerns. */
+  Query getQuery();
+
+  /** The weight for this query. */
+  float getValue();
+
+  /** The sum of squared weights of contained query clauses. */
+  float sumOfSquaredWeights() throws IOException;
+
+  /** Assigns the query normalization factor to this. */
+  void normalize(float norm);
+
+  /** Constructs a scorer for this. */
+  Scorer scorer(IndexReader reader) throws IOException;
+
+  /** An explanation of this weight computation. */
+  Explanation explain() throws IOException;
+}
diff --git a/lucene/java/trunk/src/java/org/apache/lucene/search/WildcardQuery.java b/lucene/java/trunk/src/java/org/apache/lucene/search/WildcardQuery.java
index eceb9dcd..a1e13797 100644
--- a/lucene/java/trunk/src/java/org/apache/lucene/search/WildcardQuery.java
+++ b/lucene/java/trunk/src/java/org/apache/lucene/search/WildcardQuery.java
@@ -62,17 +62,12 @@
 
 /** Implements the wildcard search query */
 public class WildcardQuery extends MultiTermQuery {
-    private Term wildcardTerm;
-
     public WildcardQuery(Term term) {
         super(term);
-        wildcardTerm = term;
     }
 
-    final void prepare(IndexReader reader) {
-        try {
-            setEnum(new WildcardTermEnum(reader, wildcardTerm));
-        } catch (IOException e) {}
+  protected FilteredTermEnum getEnum(IndexReader reader) throws IOException {
+    return new WildcardTermEnum(reader, getTerm());
     }
     
 }
diff --git a/lucene/java/trunk/src/test/org/apache/lucene/queryParser/TestQueryParser.java b/lucene/java/trunk/src/test/org/apache/lucene/queryParser/TestQueryParser.java
index c00c501b..abdaaf16 100644
--- a/lucene/java/trunk/src/test/org/apache/lucene/queryParser/TestQueryParser.java
+++ b/lucene/java/trunk/src/test/org/apache/lucene/queryParser/TestQueryParser.java
@@ -192,6 +192,8 @@ public void testSimple() throws Exception {
 	assertTrue(getQuery("\"hello there\"", null) instanceof PhraseQuery);
 
 	assertQueryEquals("germ term^2.0", null, "germ term^2.0");
+	assertQueryEquals("(term)^2.0", null, "term^2.0");
+	assertQueryEquals("(germ term)^2.0", null, "(germ term)^2.0");
 	assertQueryEquals("term^2.0", null, "term^2.0");
 	assertQueryEquals("term^2", null, "term^2.0");
 	assertQueryEquals("\"germ term\"^2.0", null, "\"germ term\"^2.0");
