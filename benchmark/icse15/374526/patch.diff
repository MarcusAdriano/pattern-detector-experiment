diff --git a/incubator/solr/trunk/src/java/org/apache/solr/schema/BCDIntField.java b/incubator/solr/trunk/src/java/org/apache/solr/schema/BCDIntField.java
index f3a41029..b7a8bc6e 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/schema/BCDIntField.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/schema/BCDIntField.java
@@ -17,7 +17,7 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
+import org.apache.solr.search.function.ValueSource;
 import org.apache.lucene.document.Field;
 import org.apache.solr.util.BCDUtils;
 import org.apache.solr.request.XMLWriter;
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/schema/BoolField.java b/incubator/solr/trunk/src/java/org/apache/solr/schema/BoolField.java
index c4665ebb..08bb379b 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/schema/BoolField.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/schema/BoolField.java
@@ -17,8 +17,8 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.OrdFieldSource;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.OrdFieldSource;
 import org.apache.lucene.analysis.Token;
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.TokenStream;
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/schema/DateField.java b/incubator/solr/trunk/src/java/org/apache/solr/schema/DateField.java
index f7e38551..f9a9f2b7 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/schema/DateField.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/schema/DateField.java
@@ -20,8 +20,8 @@
 import org.apache.solr.request.XMLWriter;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.OrdFieldSource;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.OrdFieldSource;
 
 import java.util.Map;
 import java.io.IOException;
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/schema/DoubleField.java b/incubator/solr/trunk/src/java/org/apache/solr/schema/DoubleField.java
index b54cc289..f6af4381 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/schema/DoubleField.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/schema/DoubleField.java
@@ -17,8 +17,8 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.FloatFieldSource;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.FloatFieldSource;
 import org.apache.lucene.document.Field;
 import org.apache.solr.request.XMLWriter;
 
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/schema/FieldType.java b/incubator/solr/trunk/src/java/org/apache/solr/schema/FieldType.java
index 3fcc1434..ce8320e6 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/schema/FieldType.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/schema/FieldType.java
@@ -22,8 +22,8 @@
 import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.Token;
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.OrdFieldSource;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.OrdFieldSource;
 import org.apache.solr.search.Sorting;
 import org.apache.solr.request.XMLWriter;
 
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/schema/FloatField.java b/incubator/solr/trunk/src/java/org/apache/solr/schema/FloatField.java
index f8137d7b..75de65a3 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/schema/FloatField.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/schema/FloatField.java
@@ -17,8 +17,8 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.FloatFieldSource;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.FloatFieldSource;
 import org.apache.lucene.document.Field;
 import org.apache.solr.request.XMLWriter;
 
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/schema/IntField.java b/incubator/solr/trunk/src/java/org/apache/solr/schema/IntField.java
index 3a04f9c5..1b1d2761 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/schema/IntField.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/schema/IntField.java
@@ -17,8 +17,8 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.IntFieldSource;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.IntFieldSource;
 import org.apache.lucene.document.Field;
 import org.apache.solr.request.XMLWriter;
 
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/schema/LongField.java b/incubator/solr/trunk/src/java/org/apache/solr/schema/LongField.java
index 897431e0..1b4a331d 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/schema/LongField.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/schema/LongField.java
@@ -17,8 +17,8 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.IntFieldSource;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.IntFieldSource;
 import org.apache.lucene.document.Field;
 import org.apache.solr.request.XMLWriter;
 
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableDoubleField.java b/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableDoubleField.java
index 566d0ee4..d7f61fa6 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableDoubleField.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableDoubleField.java
@@ -18,9 +18,9 @@
 
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.FieldCacheSource;
-import org.apache.lucene.search.function.DocValues;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.FieldCacheSource;
+import org.apache.solr.search.function.DocValues;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
 import org.apache.solr.util.NumberUtils;
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableFloatField.java b/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableFloatField.java
index 6ce103c2..068dbdb1 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableFloatField.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableFloatField.java
@@ -18,9 +18,9 @@
 
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.FieldCacheSource;
-import org.apache.lucene.search.function.DocValues;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.FieldCacheSource;
+import org.apache.solr.search.function.DocValues;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
 import org.apache.solr.util.NumberUtils;
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableIntField.java b/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableIntField.java
index dd8ff865..a9fbb4e9 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableIntField.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableIntField.java
@@ -18,9 +18,9 @@
 
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.FieldCacheSource;
-import org.apache.lucene.search.function.DocValues;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.FieldCacheSource;
+import org.apache.solr.search.function.DocValues;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
 import org.apache.solr.util.NumberUtils;
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableLongField.java b/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableLongField.java
index 9bd8db1d..4fce602d 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableLongField.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/schema/SortableLongField.java
@@ -18,9 +18,9 @@
 
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.function.ValueSource;
-import org.apache.lucene.search.function.FieldCacheSource;
-import org.apache.lucene.search.function.DocValues;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.solr.search.function.FieldCacheSource;
+import org.apache.solr.search.function.DocValues;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
 import org.apache.solr.util.NumberUtils;
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/search/ConstantScorePrefixQuery.java b/incubator/solr/trunk/src/java/org/apache/solr/search/ConstantScorePrefixQuery.java
index e69de29b..edff0937 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/search/ConstantScorePrefixQuery.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/search/ConstantScorePrefixQuery.java
@@ -0,0 +1,81 @@
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.ConstantScoreQuery;
+
+import java.io.IOException;
+
+/**
+ * @author yonik
+ * @version $Id: ConstantScorePrefixQuery.java,v 1.2 2005/09/15 14:32:41 yonik Exp $
+ */
+public class ConstantScorePrefixQuery extends Query {
+  private final Term prefix;
+
+  public ConstantScorePrefixQuery(Term prefix) {
+    this.prefix = prefix;
+  }
+
+  /** Returns the prefix  for this query */
+  public Term getPrefix() { return prefix; }
+
+  public Query rewrite(IndexReader reader) throws IOException {
+    // TODO: if number of terms are low enough, rewrite to a BooleanQuery
+    // for potentially faster execution.
+    // TODO: cache the bitset somewhere instead of regenerating it
+    Query q = new ConstantScoreQuery(new PrefixFilter(prefix));
+    q.setBoost(getBoost());
+    return q;
+  }
+
+  /** Prints a user-readable version of this query. */
+  public String toString(String field)
+  {
+    StringBuffer buffer = new StringBuffer();
+    if (!prefix.field().equals(field)) {
+      buffer.append(prefix.field());
+      buffer.append(":");
+    }
+    buffer.append(prefix.text());
+    buffer.append('*');
+    if (getBoost() != 1.0f) {
+      buffer.append("^");
+      buffer.append(Float.toString(getBoost()));
+    }
+    return buffer.toString();
+  }
+
+    /** Returns true if <code>o</code> is equal to this. */
+    public boolean equals(Object o) {
+      if (this == o) return true;
+      if (!(o instanceof ConstantScorePrefixQuery)) return false;
+      ConstantScorePrefixQuery other = (ConstantScorePrefixQuery) o;
+      return this.prefix.equals(other.prefix) && this.getBoost()==other.getBoost();
+    }
+
+    /** Returns a hash code value for this object.*/
+    public int hashCode() {
+      int h = prefix.hashCode() ^ Float.floatToIntBits(getBoost());
+      h ^= (h << 14) | (h >>> 19);  // reversible (1 to 1) transformation unique to ConstantScorePrefixQuery
+      return h;
+    }
+
+}
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/search/PrefixFilter.java b/incubator/solr/trunk/src/java/org/apache/solr/search/PrefixFilter.java
index e69de29b..176c5d79 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/search/PrefixFilter.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/search/PrefixFilter.java
@@ -0,0 +1,79 @@
+package org.apache.solr.search;
+
+import org.apache.lucene.search.Filter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.TermEnum;
+import org.apache.lucene.index.TermDocs;
+
+import java.util.BitSet;
+import java.io.IOException;
+
+/**
+ * @author yonik
+ * @version $Id: PrefixFilter.java,v 1.1 2005/06/10 05:47:32 yonik Exp $
+ */
+public class PrefixFilter extends Filter {
+  protected final Term prefix;
+
+  PrefixFilter(Term prefix) {
+    this.prefix = prefix;
+  }
+
+  Term getPrefix() { return prefix; }
+
+  public BitSet bits(IndexReader reader) throws IOException {
+    final BitSet bitSet = new BitSet(reader.maxDoc());
+    new PrefixGenerator(prefix) {
+      public void handleDoc(int doc) {
+        bitSet.set(doc);
+      }
+    }.generate(reader);
+    return bitSet;
+  }
+}
+
+// keep this protected until I decide if it's a good way
+// to separate id generation from collection (or should
+// I just reuse hitcollector???)
+interface IdGenerator {
+  public void generate(IndexReader reader) throws IOException;
+  public void handleDoc(int doc);
+}
+
+
+abstract class PrefixGenerator implements IdGenerator {
+  protected final Term prefix;
+
+  PrefixGenerator(Term prefix) {
+    this.prefix = prefix;
+  }
+
+  public void generate(IndexReader reader) throws IOException {
+    TermEnum enumerator = reader.terms(prefix);
+    TermDocs termDocs = reader.termDocs();
+
+    try {
+
+      String prefixText = prefix.text();
+      String prefixField = prefix.field();
+      do {
+        Term term = enumerator.term();
+        if (term != null &&
+            term.text().startsWith(prefixText) &&
+            term.field() == prefixField)
+        {
+          termDocs.seek(term);
+          while (termDocs.next()) {
+            handleDoc(termDocs.doc());
+          }
+        } else {
+          break;
+        }
+      } while (enumerator.next());
+    } finally {
+      termDocs.close();
+      enumerator.close();
+    }
+  }
+}
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/search/QueryParsing.java b/incubator/solr/trunk/src/java/org/apache/solr/search/QueryParsing.java
index b8add309..3ee71f78 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/search/QueryParsing.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/search/QueryParsing.java
@@ -18,7 +18,7 @@
 package org.apache.solr.search;
 
 import org.apache.lucene.search.*;
-import org.apache.lucene.search.function.*;
+import org.apache.solr.search.function.*;
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.Term;
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/search/function/DocValues.java b/incubator/solr/trunk/src/java/org/apache/solr/search/function/DocValues.java
index 3f24d583..d537cdc3 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/search/function/DocValues.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/search/function/DocValues.java
@@ -1 +1,48 @@
   + native
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.search.Explanation;
+
+/**
+ * Represents field values as different types.
+ * Normally created via a {@link ValueSource} for a particular field and reader.
+ * <br>
+ * Often used by {@link FunctionFactory} implementations.
+ *
+ * @author yonik
+ * @version $Id: DocValues.java,v 1.1 2005/11/22 05:23:20 yonik Exp $
+ */
+
+// DocValues is distinct from ValueSource because
+// there needs to be an object created at query evaluation time that
+// is not referenced by the query itself because:
+// - Query objects should be MT safe
+// - For caching, Query objects are often used as keys... you don't
+//   want the Query carrying around big objects
+public abstract class DocValues {
+  public float floatVal(int doc) { throw new UnsupportedOperationException(); }
+  public int intVal(int doc) { throw new UnsupportedOperationException(); }
+  public long longVal(int doc) { throw new UnsupportedOperationException(); }
+  public double doubleVal(int doc) { throw new UnsupportedOperationException(); }
+  public String strVal(int doc) { throw new UnsupportedOperationException(); }
+  public abstract String toString(int doc);
+  public Explanation explain(int doc) {
+    return new Explanation(floatVal(doc), toString(doc));
+  }
+}
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/search/function/FieldCacheSource.java b/incubator/solr/trunk/src/java/org/apache/solr/search/function/FieldCacheSource.java
index 3f24d583..03e5b903 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/search/function/FieldCacheSource.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/search/function/FieldCacheSource.java
@@ -1 +1,60 @@
   + native
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.search.FieldCache;
+
+/**
+ * A base class for ValueSource implementations that retrieve values for
+ * a single field from the {@link org.apache.lucene.search.FieldCache}.
+ *
+ * @author yonik
+ * @version $Id: FieldCacheSource.java,v 1.1 2005/11/22 05:23:20 yonik Exp $
+ */
+public abstract class FieldCacheSource extends ValueSource {
+  protected String field;
+  protected FieldCache cache = FieldCache.DEFAULT;
+
+  public FieldCacheSource(String field) {
+    this.field=field;
+  }
+
+  public void setFieldCache(FieldCache cache) {
+    this.cache = cache;
+  }
+
+  public FieldCache getFieldCache() {
+    return cache;
+  }
+
+  public String description() {
+    return field;
+  }
+
+  public boolean equals(Object o) {
+    if (!(o instanceof FieldCacheSource)) return false;
+    FieldCacheSource other = (FieldCacheSource)o;
+    return this.field.equals(other.field)
+           && this.cache == other.cache;
+  }
+
+  public int hashCode() {
+    return cache.hashCode() + field.hashCode();
+  };
+
+}
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/search/function/FloatFieldSource.java b/incubator/solr/trunk/src/java/org/apache/solr/search/function/FloatFieldSource.java
index 3f24d583..adb161a1 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/search/function/FloatFieldSource.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/search/function/FloatFieldSource.java
@@ -1 +1,96 @@
   + native
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.solr.search.function.DocValues;
+import org.apache.lucene.search.FieldCache;
+
+import java.io.IOException;
+
+/**
+ * Obtains float field values from the {@link org.apache.lucene.search.FieldCache}
+ * using <code>getFloats()</code>
+ * and makes those values available as other numeric types, casting as needed.
+ *
+ * @author yonik
+ * @version $Id: FloatFieldSource.java,v 1.2 2005/11/22 05:23:20 yonik Exp $
+ */
+
+public class FloatFieldSource extends FieldCacheSource {
+  protected FieldCache.FloatParser parser;
+
+  public FloatFieldSource(String field) {
+    this(field, null);
+  }
+
+  public FloatFieldSource(String field, FieldCache.FloatParser parser) {
+    super(field);
+    this.parser = parser;
+  }
+
+  public String description() {
+    return "float(" + field + ')';
+  }
+
+  public DocValues getValues(IndexReader reader) throws IOException {
+    final float[] arr = (parser==null) ?
+            cache.getFloats(reader, field) :
+            cache.getFloats(reader, field, parser);
+    return new DocValues() {
+      public float floatVal(int doc) {
+        return arr[doc];
+      }
+
+      public int intVal(int doc) {
+        return (int)arr[doc];
+      }
+
+      public long longVal(int doc) {
+        return (long)arr[doc];
+      }
+
+      public double doubleVal(int doc) {
+        return (double)arr[doc];
+      }
+
+      public String strVal(int doc) {
+        return Float.toString(arr[doc]);
+      }
+
+      public String toString(int doc) {
+        return description() + '=' + floatVal(doc);
+      }
+    };
+  }
+
+  public boolean equals(Object o) {
+    if (o.getClass() !=  FloatFieldSource.class) return false;
+    FloatFieldSource other = (FloatFieldSource)o;
+    return super.equals(other)
+           && this.parser==null ? other.parser==null :
+              this.parser.getClass() == other.parser.getClass();
+  }
+
+  public int hashCode() {
+    int h = parser==null ? Float.class.hashCode() : parser.getClass().hashCode();
+    h += super.hashCode();
+    return h;
+  };
+
+}
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/search/function/FunctionQuery.java b/incubator/solr/trunk/src/java/org/apache/solr/search/function/FunctionQuery.java
index 3f24d583..62d0905a 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/search/function/FunctionQuery.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/search/function/FunctionQuery.java
@@ -1 +1,174 @@
   + native
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.*;
+import java.io.IOException;
+
+
+/**
+ * Returns a score for each document based on a ValueSource,
+ * often some function of the value of a field.
+ *
+ * @author yonik
+ * @version $Id: FunctionQuery.java,v 1.4 2005/11/23 04:22:20 yonik Exp $
+ */
+public class FunctionQuery extends Query {
+  ValueSource func;
+
+  /**
+   *
+   * @param func defines the function to be used for scoring
+   */
+  public FunctionQuery(ValueSource func) {
+    this.func=func;
+  }
+
+  public Query rewrite(IndexReader reader) throws IOException {
+    return this;
+  }
+
+  protected class FunctionWeight implements Weight {
+    Searcher searcher;
+    float queryNorm;
+    float queryWeight;
+
+    public FunctionWeight(Searcher searcher) {
+      this.searcher = searcher;
+    }
+
+    public Query getQuery() {
+      return FunctionQuery.this;
+    }
+
+    public float getValue() {
+      return queryWeight;
+    }
+
+    public float sumOfSquaredWeights() throws IOException {
+      queryWeight = getBoost();
+      return queryWeight * queryWeight;
+    }
+
+    public void normalize(float norm) {
+      this.queryNorm = norm;
+      queryWeight *= this.queryNorm;
+    }
+
+    public Scorer scorer(IndexReader reader) throws IOException {
+      return new AllScorer(getSimilarity(searcher), reader, this);
+    }
+
+    public Explanation explain(IndexReader reader, int doc) throws IOException {
+      return scorer(reader).explain(doc);
+    }
+  }
+
+  protected class AllScorer extends Scorer {
+    final IndexReader reader;
+    final FunctionWeight weight;
+    final int maxDoc;
+    final float qWeight;
+    int doc=-1;
+    final DocValues vals;
+
+    public AllScorer(Similarity similarity, IndexReader reader, FunctionWeight w) throws IOException {
+      super(similarity);
+      this.weight = w;
+      this.qWeight = w.getValue();
+      this.reader = reader;
+      this.maxDoc = reader.maxDoc();
+      vals = func.getValues(reader);
+    }
+
+    // instead of matching all docs, we could also embed a query.
+    // the score could either ignore the subscore, or boost it.
+    // Containment:  floatline(foo:myTerm, "myFloatField", 1.0, 0.0f)
+    // Boost:        foo:myTerm^floatline("myFloatField",1.0,0.0f)
+    public boolean next() throws IOException {
+      for(;;) {
+        ++doc;
+        if (doc>=maxDoc) {
+          return false;
+        }
+        if (reader.isDeleted(doc)) continue;
+        // todo: maybe allow score() to throw a specific exception
+        // and continue on to the next document if it is thrown...
+        // that may be useful, but exceptions aren't really good
+        // for flow control.
+        return true;
+      }
+    }
+
+    public int doc() {
+      return doc;
+    }
+
+    public float score() throws IOException {
+      return qWeight * vals.floatVal(doc);
+    }
+
+    public boolean skipTo(int target) throws IOException {
+      doc=target-1;
+      return next();
+    }
+
+    public Explanation explain(int doc) throws IOException {
+      float sc = qWeight * vals.floatVal(doc);
+
+      Explanation result = new Explanation();
+      result.setDescription("FunctionQuery(" + func
+        + "), product of:");
+      result.setValue(sc);
+      result.addDetail(vals.explain(doc));
+      result.addDetail(new Explanation(getBoost(), "boost"));
+      result.addDetail(new Explanation(weight.queryNorm,"queryNorm"));
+      return result;
+    }
+  }
+
+
+  protected Weight createWeight(Searcher searcher) {
+    return new FunctionQuery.FunctionWeight(searcher);
+  }
+
+
+  /** Prints a user-readable version of this query. */
+  public String toString(String field)
+  {
+    float boost = getBoost();
+    return (boost!=1.0?"(":"") + func.toString()
+            + (getBoost()==0 ? "" : ")^"+getBoost());
+  }
+
+
+  /** Returns true if <code>o</code> is equal to this. */
+  public boolean equals(Object o) {
+    if (FunctionQuery.class != o.getClass()) return false;
+    FunctionQuery other = (FunctionQuery)o;
+    return this.getBoost() == other.getBoost()
+            && this.func.equals(other.func);
+  }
+
+  /** Returns a hash code value for this object. */
+  public int hashCode() {
+    return func.hashCode() ^ Float.floatToIntBits(getBoost());
+  }
+
+}
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/search/function/IntFieldSource.java b/incubator/solr/trunk/src/java/org/apache/solr/search/function/IntFieldSource.java
index 3f24d583..cfb80400 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/search/function/IntFieldSource.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/search/function/IntFieldSource.java
@@ -1 +1,96 @@
   + native
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.solr.search.function.DocValues;
+import org.apache.lucene.search.FieldCache;
+
+import java.io.IOException;
+
+/**
+ * Obtains int field values from the {@link org.apache.lucene.search.FieldCache}
+ * using <code>getInts()</code>
+ * and makes those values available as other numeric types, casting as needed. *
+ * @author yonik
+ * @version $Id: IntFieldSource.java,v 1.2 2005/11/22 05:23:20 yonik Exp $
+ */
+
+public class IntFieldSource extends FieldCacheSource {
+  FieldCache.IntParser parser;
+
+  public IntFieldSource(String field) {
+    this(field, null);
+  }
+
+  public IntFieldSource(String field, FieldCache.IntParser parser) {
+    super(field);
+    this.parser = parser;
+  }
+
+  public String description() {
+    return "int(" + field + ')';
+  }
+
+  public DocValues getValues(IndexReader reader) throws IOException {
+    final int[] arr = (parser==null) ?
+            cache.getInts(reader, field) :
+            cache.getInts(reader, field, parser);
+    return new DocValues() {
+      public float floatVal(int doc) {
+        return (float)arr[doc];
+      }
+
+      public int intVal(int doc) {
+        return (int)arr[doc];
+      }
+
+      public long longVal(int doc) {
+        return (long)arr[doc];
+      }
+
+      public double doubleVal(int doc) {
+        return (double)arr[doc];
+      }
+
+      public String strVal(int doc) {
+        return Float.toString(arr[doc]);
+      }
+
+      public String toString(int doc) {
+        return description() + '=' + intVal(doc);
+      }
+
+    };
+  }
+
+  public boolean equals(Object o) {
+    if (o.getClass() !=  IntFieldSource.class) return false;
+    IntFieldSource other = (IntFieldSource)o;
+    return super.equals(other)
+           && this.parser==null ? other.parser==null :
+              this.parser.getClass() == other.parser.getClass();
+  }
+
+  public int hashCode() {
+    int h = parser==null ? Integer.class.hashCode() : parser.getClass().hashCode();
+    h += super.hashCode();
+    return h;
+  };
+
+}
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/search/function/LinearFloatFunction.java b/incubator/solr/trunk/src/java/org/apache/solr/search/function/LinearFloatFunction.java
index e69de29b..1b022a1d 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/search/function/LinearFloatFunction.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/search/function/LinearFloatFunction.java
@@ -0,0 +1,86 @@
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+
+import java.io.IOException;
+
+/**
+ * <code>LinearFloatFunction</code> implements a linear function over
+ * another {@link ValueSource}.
+ * <br>
+ * Normally Used as an argument to a {@link FunctionQuery}
+ *
+ * @author yonik
+ * @version $Id: LinearFloatFunction.java,v 1.2 2005/11/22 05:23:21 yonik Exp $
+ */
+public class LinearFloatFunction extends ValueSource {
+  protected final ValueSource source;
+  protected final float slope;
+  protected final float intercept;
+
+  public LinearFloatFunction(ValueSource source, float slope, float intercept) {
+    this.source = source;
+    this.slope = slope;
+    this.intercept = intercept;
+  }
+  
+  public String description() {
+    return slope + "*float(" + source.description() + ")+" + intercept;
+  }
+
+  public DocValues getValues(IndexReader reader) throws IOException {
+    final DocValues vals =  source.getValues(reader);
+    return new DocValues() {
+      public float floatVal(int doc) {
+        return vals.floatVal(doc) * slope + intercept;
+      }
+      public int intVal(int doc) {
+        return (int)floatVal(doc);
+      }
+      public long longVal(int doc) {
+        return (long)floatVal(doc);
+      }
+      public double doubleVal(int doc) {
+        return (double)floatVal(doc);
+      }
+      public String strVal(int doc) {
+        return Float.toString(floatVal(doc));
+      }
+      public String toString(int doc) {
+        return slope + "*float(" + vals.toString(doc) + ")+" + intercept;
+      }
+    };
+  }
+
+  public int hashCode() {
+    int h = Float.floatToIntBits(slope);
+    h = (h >>> 2) | (h << 30);
+    h += Float.floatToIntBits(intercept);
+    h ^= (h << 14) | (h >>> 19);
+    return h + source.hashCode();
+  }
+
+  public boolean equals(Object o) {
+    if (LinearFloatFunction.class != o.getClass()) return false;
+    LinearFloatFunction other = (LinearFloatFunction)o;
+    return  this.slope == other.slope
+         && this.intercept == other.intercept
+         && this.source.equals(other.source);
+  }
+}
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/search/function/OrdFieldSource.java b/incubator/solr/trunk/src/java/org/apache/solr/search/function/OrdFieldSource.java
index 3f24d583..56dbfbe4 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/search/function/OrdFieldSource.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/search/function/OrdFieldSource.java
@@ -1 +1,95 @@
   + native
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.solr.search.function.DocValues;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.lucene.search.FieldCache;
+
+import java.io.IOException;
+
+/**
+ * Obtains the ordinal of the field value from the default Lucene {@link org.apache.lucene.search.FieldCache} using getStringIndex().
+ * <br>
+ * The native lucene index order is used to assign an ordinal value for each field value.
+ * <br>Field values (terms) are lexicographically ordered by unicode value, and numbered starting at 1.
+ * <br>
+ * Example:<br>
+ *  If there were only three field values: "apple","banana","pear"
+ * <br>then ord("apple")=1, ord("banana")=2, ord("pear")=3
+ * <p>
+ * WARNING: ord() depends on the position in an index and can thus change when other documents are inserted or deleted,
+ *  or if a MultiSearcher is used.
+ * @author yonik
+ * @version $Id: OrdFieldSource.java,v 1.2 2005/11/22 05:23:21 yonik Exp $
+ */
+
+public class OrdFieldSource extends ValueSource {
+  protected String field;
+
+  public OrdFieldSource(String field) {
+    this.field = field;
+  }
+
+  public String description() {
+    return "ord(" + field + ')';
+  }
+
+  public DocValues getValues(IndexReader reader) throws IOException {
+    final int[] arr = FieldCache.DEFAULT.getStringIndex(reader, field).order;
+    return new DocValues() {
+      public float floatVal(int doc) {
+        return (float)arr[doc];
+      }
+
+      public int intVal(int doc) {
+        return (int)arr[doc];
+      }
+
+      public long longVal(int doc) {
+        return (long)arr[doc];
+      }
+
+      public double doubleVal(int doc) {
+        return (double)arr[doc];
+      }
+
+      public String strVal(int doc) {
+        // the string value of the ordinal, not the string itself
+        return Integer.toString(arr[doc]);
+      }
+
+      public String toString(int doc) {
+        return description() + '=' + intVal(doc);
+      }
+    };
+  }
+
+  public boolean equals(Object o) {
+    if (o.getClass() !=  OrdFieldSource.class) return false;
+    OrdFieldSource other = (OrdFieldSource)o;
+    return this.field.equals(field);
+  }
+
+  private static final int hcode = OrdFieldSource.class.hashCode();
+  public int hashCode() {
+    return hcode + field.hashCode();
+  };
+
+}
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/search/function/ReciprocalFloatFunction.java b/incubator/solr/trunk/src/java/org/apache/solr/search/function/ReciprocalFloatFunction.java
index 3f24d583..0090ddbe 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/search/function/ReciprocalFloatFunction.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/search/function/ReciprocalFloatFunction.java
@@ -1 +1,102 @@
   + native
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+
+import java.io.IOException;
+
+/**
+ * <code>ReciprocalFloatFunction</code> implements a reciprocal function f(x) = a/(mx+b), based on
+ * the float value of a field as exported by {@link org.apache.solr.search.function.ValueSource}.
+ * <br>
+ *
+ * When a and b are equal, and x>=0, this function has a maximum value of 1 that drops as x increases.
+ * Increasing the value of a and b together results in a movement of the entire function to a flatter part of the curve.
+ * <br>These properties make this an idea function for boosting more recent documents.
+ * <br>Example:<code>ReciprocalFloatFunction(new ReverseOrdFieldSource("my_date"),1,1000,1000)</code>
+ *
+ * @see FunctionQuery
+ *
+ *
+ * @author yonik
+ * @version $Id: ReciprocalFloatFunction.java,v 1.2 2005/11/22 05:23:21 yonik Exp $
+ */
+public class ReciprocalFloatFunction extends ValueSource {
+  protected final ValueSource source;
+  protected final float m;
+  protected final float a;
+  protected final float b;
+
+  /**
+   *  f(source) = a/(m*float(source)+b)
+   */
+  public ReciprocalFloatFunction(ValueSource source, float m, float a, float b) {
+    this.source=source;
+    this.m=m;
+    this.a=a;
+    this.b=b;
+  }
+
+  public DocValues getValues(IndexReader reader) throws IOException {
+    final DocValues vals = source.getValues(reader);
+    return new DocValues() {
+      public float floatVal(int doc) {
+        return a/(m*vals.floatVal(doc) + b);
+      }
+      public int intVal(int doc) {
+        return (int)floatVal(doc);
+      }
+      public long longVal(int doc) {
+        return (long)floatVal(doc);
+      }
+      public double doubleVal(int doc) {
+        return (double)floatVal(doc);
+      }
+      public String strVal(int doc) {
+        return Float.toString(floatVal(doc));
+      }
+      public String toString(int doc) {
+        return Float.toString(a) + "/("
+                + m + "*float(" + vals.toString(doc) + ')'
+                + '+' + b + ')';
+      }
+    };
+  }
+
+  public String description() {
+    return Float.toString(a) + "/("
+           + m + "*float(" + source.description() + ")"
+           + "+" + b + ')';
+  }
+
+  public int hashCode() {
+    int h = Float.floatToIntBits(a) + Float.floatToIntBits(m);
+    h ^= (h << 13) | (h >>> 20);
+    return h + (Float.floatToIntBits(b)) + source.hashCode();
+  }
+
+  public boolean equals(Object o) {
+    if (ReciprocalFloatFunction.class != o.getClass()) return false;
+    ReciprocalFloatFunction other = (ReciprocalFloatFunction)o;
+    return this.m == other.m
+            && this.a == other.a
+            && this.b == other.b
+            && this.source.equals(other.source);
+  }
+}
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/search/function/ReverseOrdFieldSource.java b/incubator/solr/trunk/src/java/org/apache/solr/search/function/ReverseOrdFieldSource.java
index 3f24d583..67f799d8 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/search/function/ReverseOrdFieldSource.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/search/function/ReverseOrdFieldSource.java
@@ -1 +1,100 @@
   + native
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.solr.search.function.DocValues;
+import org.apache.solr.search.function.ValueSource;
+import org.apache.lucene.search.FieldCache;
+
+import java.io.IOException;
+
+/**
+ * Obtains the ordinal of the field value from the default Lucene {@link org.apache.lucene.search.FieldCache} using getStringIndex()
+ * and reverses the order.
+ * <br>
+ * The native lucene index order is used to assign an ordinal value for each field value.
+ * <br>Field values (terms) are lexicographically ordered by unicode value, and numbered starting at 1.
+ * <br>
+ * Example of reverse ordinal (rord):<br>
+ *  If there were only three field values: "apple","banana","pear"
+ * <br>then rord("apple")=3, rord("banana")=2, ord("pear")=1
+ * <p>
+ *  WARNING: ord() depends on the position in an index and can thus change when other documents are inserted or deleted,
+ *  or if a MultiSearcher is used.
+ * @author yonik
+ * @version $Id: ReverseOrdFieldSource.java,v 1.2 2005/11/22 05:23:21 yonik Exp $
+ */
+
+public class ReverseOrdFieldSource extends ValueSource {
+  public String field;
+
+  public ReverseOrdFieldSource(String field) {
+    this.field = field;
+  }
+
+  public String description() {
+    return "rord("+field+')';
+  }
+
+  public DocValues getValues(IndexReader reader) throws IOException {
+    final FieldCache.StringIndex sindex = FieldCache.DEFAULT.getStringIndex(reader, field);
+
+    final int arr[] = sindex.order;
+    final int end = sindex.lookup.length;
+
+    return new DocValues() {
+      public float floatVal(int doc) {
+        return (float)(end - arr[doc]);
+      }
+
+      public int intVal(int doc) {
+        return (int)(end - arr[doc]);
+      }
+
+      public long longVal(int doc) {
+        return (long)(end - arr[doc]);
+      }
+
+      public double doubleVal(int doc) {
+        return (double)(end - arr[doc]);
+      }
+
+      public String strVal(int doc) {
+        // the string value of the ordinal, not the string itself
+        return Integer.toString((end - arr[doc]));
+      }
+
+      public String toString(int doc) {
+        return description() + '=' + strVal(doc);
+      }
+    };
+  }
+
+  public boolean equals(Object o) {
+    if (o.getClass() !=  ReverseOrdFieldSource.class) return false;
+    ReverseOrdFieldSource other = (ReverseOrdFieldSource)o;
+    return this.field.equals(field);
+  }
+
+  private static final int hcode = ReverseOrdFieldSource.class.hashCode();
+  public int hashCode() {
+    return hcode + field.hashCode();
+  };
+
+}
diff --git a/incubator/solr/trunk/src/java/org/apache/solr/search/function/ValueSource.java b/incubator/solr/trunk/src/java/org/apache/solr/search/function/ValueSource.java
index 3f24d583..db138fd9 100644
--- a/incubator/solr/trunk/src/java/org/apache/solr/search/function/ValueSource.java
+++ b/incubator/solr/trunk/src/java/org/apache/solr/search/function/ValueSource.java
@@ -1 +1,49 @@
   + native
+/**
+ * Copyright 2006 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.search.function;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.solr.search.function.DocValues;
+
+import java.io.IOException;
+import java.io.Serializable;
+
+/**
+ * Instantiates {@link org.apache.solr.search.function.DocValues} for a particular reader.
+ * <br>
+ * Often used when creating a {@link FunctionQuery}.
+ *
+ * @author yonik
+ * @version $Id: ValueSource.java,v 1.2 2005/11/30 19:31:01 yonik Exp $
+ */
+public abstract class ValueSource implements Serializable {
+
+  public abstract DocValues getValues(IndexReader reader) throws IOException;
+
+  public abstract boolean equals(Object o);
+
+  public abstract int hashCode();
+
+  /** description of field, used in explain() */
+  public abstract String description();
+
+  public String toString() {
+    return getClass().getName() + ":" + description();
+  }
+
+}
diff --git a/incubator/solr/trunk/src/lucene_extras/org/apache/lucene/search/ConstantScorePrefixQuery.java b/incubator/solr/trunk/src/lucene_extras/org/apache/lucene/search/ConstantScorePrefixQuery.java
index bc95d350..e69de29b 100644
--- a/incubator/solr/trunk/src/lucene_extras/org/apache/lucene/search/ConstantScorePrefixQuery.java
+++ b/incubator/solr/trunk/src/lucene_extras/org/apache/lucene/search/ConstantScorePrefixQuery.java
@@ -1,79 +0,0 @@
-/**
- * Copyright 2006 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.search;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-
-import java.io.IOException;
-
-/**
- * @author yonik
- * @version $Id: ConstantScorePrefixQuery.java,v 1.2 2005/09/15 14:32:41 yonik Exp $
- */
-public class ConstantScorePrefixQuery extends Query {
-  private final Term prefix;
-
-  public ConstantScorePrefixQuery(Term prefix) {
-    this.prefix = prefix;
-  }
-
-  /** Returns the prefix  for this query */
-  public Term getPrefix() { return prefix; }
-
-  public Query rewrite(IndexReader reader) throws IOException {
-    // TODO: if number of terms are low enough, rewrite to a BooleanQuery
-    // for potentially faster execution.
-    // TODO: cache the bitset somewhere instead of regenerating it
-    Query q = new ConstantScoreQuery(new PrefixFilter(prefix));
-    q.setBoost(getBoost());
-    return q;
-  }
-
-  /** Prints a user-readable version of this query. */
-  public String toString(String field)
-  {
-    StringBuffer buffer = new StringBuffer();
-    if (!prefix.field().equals(field)) {
-      buffer.append(prefix.field());
-      buffer.append(":");
-    }
-    buffer.append(prefix.text());
-    buffer.append('*');
-    if (getBoost() != 1.0f) {
-      buffer.append("^");
-      buffer.append(Float.toString(getBoost()));
-    }
-    return buffer.toString();
-  }
-
-    /** Returns true if <code>o</code> is equal to this. */
-    public boolean equals(Object o) {
-      if (this == o) return true;
-      if (!(o instanceof ConstantScorePrefixQuery)) return false;
-      ConstantScorePrefixQuery other = (ConstantScorePrefixQuery) o;
-      return this.prefix.equals(other.prefix) && this.getBoost()==other.getBoost();
-    }
-
-    /** Returns a hash code value for this object.*/
-    public int hashCode() {
-      int h = prefix.hashCode() ^ Float.floatToIntBits(getBoost());
-      h ^= (h << 14) | (h >>> 19);  // reversible (1 to 1) transformation unique to ConstantScorePrefixQuery
-      return h;
-    }
-
-}
diff --git a/incubator/solr/trunk/src/lucene_extras/org/apache/lucene/search/PrefixFilter.java b/incubator/solr/trunk/src/lucene_extras/org/apache/lucene/search/PrefixFilter.java
index 13d42f4f..3f24d583 100644
--- a/incubator/solr/trunk/src/lucene_extras/org/apache/lucene/search/PrefixFilter.java
+++ b/incubator/solr/trunk/src/lucene_extras/org/apache/lucene/search/PrefixFilter.java
@@ -1,96 +1 @@
   + native
-/**
- * Copyright 2006 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.search;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermDocs;
-import org.apache.lucene.index.TermEnum;
-
-import java.util.BitSet;
-import java.io.IOException;
-
-/**
- * @author yonik
- * @version $Id: PrefixFilter.java,v 1.1 2005/06/10 05:47:32 yonik Exp $
- */
-public class PrefixFilter extends Filter {
-  protected final Term prefix;
-
-  PrefixFilter(Term prefix) {
-    this.prefix = prefix;
-  }
-
-  Term getPrefix() { return prefix; }
-
-  public BitSet bits(IndexReader reader) throws IOException {
-    final BitSet bitSet = new BitSet(reader.maxDoc());
-    new PrefixGenerator(prefix) {
-      public void handleDoc(int doc) {
-        bitSet.set(doc);
-      }
-    }.generate(reader);
-    return bitSet;
-  }
-}
-
-
-// keep this protected until I decide if it's a good way
-// to separate id generation from collection (or should
-// I just reuse hitcollector???)
-interface IdGenerator {
-  public void generate(IndexReader reader) throws IOException;
-  public void handleDoc(int doc);
-}
-
-
-abstract class PrefixGenerator implements IdGenerator {
-  protected final Term prefix;
-
-  PrefixGenerator(Term prefix) {
-    this.prefix = prefix;
-  }
-
-  public void generate(IndexReader reader) throws IOException {
-    TermEnum enumerator = reader.terms(prefix);
-    TermDocs termDocs = reader.termDocs();
-
-    try {
-
-      String prefixText = prefix.text();
-      String prefixField = prefix.field();
-      do {
-        Term term = enumerator.term();
-        if (term != null &&
-            term.text().startsWith(prefixText) &&
-            term.field() == prefixField)
-        {
-          termDocs.seek(term);
-          while (termDocs.next()) {
-            handleDoc(termDocs.doc());
-          }
-        } else {
-          break;
-        }
-      } while (enumerator.next());
-    } finally {
-      termDocs.close();
-      enumerator.close();
-    }
-  }
-}
