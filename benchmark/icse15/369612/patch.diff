diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Connection.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Connection.java
index b23b869c..945dbd85 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Connection.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Connection.java
@@ -30,20 +30,21 @@
     public Agent agent_;
 
     public DatabaseMetaData databaseMetaData_;
-    // Since DERBY prepared statements must be re-prepared after a commit,
-    // then we must traverse this list after a commit and notify statements
-    // that they are now in an un-prepared state.
-    final java.util.LinkedList openStatements_ = new java.util.LinkedList();
 
-    // Some statuses of DERBY objects may be invalid on server either after only rollback
-    // or after both commit and rollback. For example,
+    // WeakHashMap is used to store references so that the objects added to 
+    // the map can get garbage-collected without waiting for the Connection object.
+    
+    // When Connection.close() is called, this list is traversed and markClosed() 
+    // is called on all statements in this list.    
+    final java.util.WeakHashMap openStatements_ = new java.util.WeakHashMap();
+
+    // Some statuses of DERBY objects may be invalid on server after both 
+    // commit and rollback. For example,
     // (1) prepared statements need to be re-prepared
     //     after both commit and rollback
     // (2) result set will be unpositioned on server after both commit and rollback.
-    // If they only depend on rollback, they need to get on RollbackOnlyListeners_.
     // If they depend on both commit and rollback, they need to get on CommitAndRollbackListeners_.
-    final java.util.LinkedList RollbackOnlyListeners_ = new java.util.LinkedList();
-    final java.util.LinkedList CommitAndRollbackListeners_ = new java.util.LinkedList();
+    final java.util.WeakHashMap CommitAndRollbackListeners_ = new java.util.WeakHashMap();
     private SqlWarning warnings_ = null;
 
     // ------------------------properties set for life of connection--------------
@@ -394,7 +395,7 @@ synchronized PreparedStatement prepareDynamicCatalogQuery(String sql) throws Sql
         PreparedStatement ps = newPreparedStatement_(sql, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, resultSetHoldability_, java.sql.Statement.NO_GENERATED_KEYS, null);
         ps.isCatalogQuery_ = true;
         ps.prepare();
-        openStatements_.add(ps);
+        openStatements_.put(ps,null);
         return ps;
     }
 
@@ -737,7 +738,6 @@ public void markClosed() // called by LogicalConnection.close()
         inUnitOfWork_ = false;
         markStatementsClosed();
         CommitAndRollbackListeners_.clear();
-        RollbackOnlyListeners_.clear();
         markClosed_();
     }
 
@@ -748,7 +748,8 @@ private void markClosedForReuse() {
     }
 
     private void markStatementsClosed() {
-        for (java.util.ListIterator i = openStatements_.listIterator(); i.hasNext();) {
+    	java.util.Set keySet = openStatements_.keySet();
+        for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
             Statement stmt = (Statement) i.next();
             stmt.markClosed();
             i.remove();
@@ -756,13 +757,15 @@ private void markStatementsClosed() {
     }
 
     private void writeCloseStatements() throws SqlException {
-        for (java.util.ListIterator i = openStatements_.listIterator(); i.hasNext();) {
+    	java.util.Set keySet = openStatements_.keySet();
+        for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
             ((Statement) i.next()).writeClose(false);  // false means don't permit auto-commits
         }
     }
 
     private void readCloseStatements() throws SqlException {
-        for (java.util.ListIterator i = openStatements_.listIterator(); i.hasNext();) {
+    	java.util.Set keySet = openStatements_.keySet();
+        for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
             ((Statement) i.next()).readClose(false);  // false means don't permit auto-commits
         }
     }
@@ -1220,7 +1223,7 @@ private Statement createStatementX(int resultSetType,
         resultSetConcurrency = downgradeResultSetConcurrency(resultSetConcurrency, resultSetType);
         Statement s = newStatement_(resultSetType, resultSetConcurrency, resultSetHoldability);
         s.cursorAttributesToSendOnPrepare_ = s.cacheCursorAttributesToSendOnPrepare();
-        openStatements_.add(s);
+        openStatements_.put(s,null);
         return s;
     }
 
@@ -1266,7 +1269,7 @@ PreparedStatement prepareStatementX(String sql,
         PreparedStatement ps = newPreparedStatement_(sql, resultSetType, resultSetConcurrency, resultSetHoldability, autoGeneratedKeys, columnNames);
         ps.cursorAttributesToSendOnPrepare_ = ps.cacheCursorAttributesToSendOnPrepare();
         ps.prepare();
-        openStatements_.add(ps);
+        openStatements_.put(ps,null);
         return ps;
     }
 
@@ -1304,7 +1307,7 @@ private CallableStatement prepareCallX(String sql,
         CallableStatement cs = newCallableStatement_(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
         cs.cursorAttributesToSendOnPrepare_ = cs.cacheCursorAttributesToSendOnPrepare();
         cs.prepare();
-        openStatements_.add(cs);
+        openStatements_.put(cs,null);
         return cs;
     }
 
@@ -1444,7 +1447,8 @@ public void completeConnect() throws SqlException {
     public abstract void readLocalCommit_() throws SqlException;
 
     public void completeLocalCommit() {
-        for (java.util.Iterator i = CommitAndRollbackListeners_.iterator(); i.hasNext();) {
+    	java.util.Set keySet = CommitAndRollbackListeners_.keySet();
+        for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
             UnitOfWorkListener listener = (UnitOfWorkListener) i.next();
             listener.completeLocalCommit(i);
         }
@@ -1459,11 +1463,8 @@ public void completeLocalCommit() {
     // This is a client-side only operation.
     // This method will only throw an exception on bug check.
     public void completeLocalRollback() {
-        for (java.util.Iterator i = CommitAndRollbackListeners_.iterator(); i.hasNext();) {
-            UnitOfWorkListener listener = (UnitOfWorkListener) i.next();
-            listener.completeLocalRollback(i);
-        }
-        for (java.util.Iterator i = RollbackOnlyListeners_.iterator(); i.hasNext();) {
+    	java.util.Set keySet = CommitAndRollbackListeners_.keySet();
+        for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
             UnitOfWorkListener listener = (UnitOfWorkListener) i.next();
             listener.completeLocalRollback(i);
         }
@@ -1565,7 +1566,8 @@ protected void completeReset(boolean isDeferredReset, boolean recomputeFromDataS
         // Notice that these physical statements may not belong to this logical connection.
         // Iterate through the physical statements and re-enable them for reuse.
 
-        for (java.util.Iterator i = openStatements_.iterator(); i.hasNext();) {
+        java.util.Set keySet = openStatements_.keySet();
+        for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
             Object o = i.next();
             ((Statement) o).reset(recomputeFromDataSource);
 
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Lob.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Lob.java
index e4a19cf3..ce8cba96 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Lob.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Lob.java
@@ -64,7 +64,7 @@ public long sqlLength() throws SqlException {
     //-----------------------event callback methods-------------------------------
 
     public void listenToUnitOfWork() {
-        agent_.connection_.CommitAndRollbackListeners_.add(this);
+        agent_.connection_.CommitAndRollbackListeners_.put(this,null);
     }
 
     public void completeLocalCommit(java.util.Iterator listenerIterator) {
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/PreparedStatement.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/PreparedStatement.java
index 40c23567..eef04726 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/PreparedStatement.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/PreparedStatement.java
@@ -1613,7 +1613,7 @@ void flowExecute(int executeType) throws SqlException {
     public void listenToUnitOfWork() {
         if (!listenToUnitOfWork_) {
             listenToUnitOfWork_ = true;
-            connection_.CommitAndRollbackListeners_.add(this);
+            connection_.CommitAndRollbackListeners_.put(this,null);
         }
     }
 
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/ResultSet.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/ResultSet.java
index a1b20b23..bca93276 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/ResultSet.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/ResultSet.java
@@ -3055,7 +3055,7 @@ public void readDeleteRow() throws DisconnectException, SqlException {
     public void listenToUnitOfWork() {
         if (!listenToUnitOfWork_) {
             listenToUnitOfWork_ = true;
-            connection_.CommitAndRollbackListeners_.add(this);
+            connection_.CommitAndRollbackListeners_.put(this,null);
         }
     }
 
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Statement.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Statement.java
index b88c8055..8ad43d52 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Statement.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Statement.java
@@ -2017,6 +2017,7 @@ public ConnectionCallbackInterface getConnectionCallbackInterface() {
     }
 
     // Only called on positioned upate statements
+    //Removing resultset from hashtable is called for all statements
     void resetCursorNameAndRemoveFromWhereCurrentOfMappings() {
         // Remove client/server cursorName -> ResultSet mapping from the hashtable.
         // If Statement.close() is called before ResultSet.close(), then statement_.section is null.
@@ -2024,6 +2025,11 @@ void resetCursorNameAndRemoveFromWhereCurrentOfMappings() {
             agent_.sectionManager_.removeCursorNameToResultSetMapping(cursorName_,
                     section_.getServerCursorNameForPositionedUpdate());
 
+            // remove resultset mapping for other cursors (other than positioned
+            // update statements)
+            agent_.sectionManager_.removeCursorNameToResultSetMapping(cursorName_,
+                    section_.getServerCursorName());
+
             // Remove client and server cursorName -> QuerySection mapping from the hashtable
             // if one exists
             agent_.sectionManager_.removeCursorNameToQuerySectionMapping(cursorName_,
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/derbyStress.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/derbyStress.java
index 3f24d583..ad923941 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/derbyStress.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/derbyStress.java
@@ -1 +1,121 @@
   + native
+/*
+
+Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.derbyStress
+
+Copyright 1999, 2005 The Apache Software Foundation or its licensors, as applicable.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+package org.apache.derbyTesting.functionTests.tests.jdbcapi;
+
+import java.sql.Connection;
+import java.sql.Statement;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+
+import org.apache.derby.tools.ij;
+import org.apache.derbyTesting.functionTests.util.TestUtil;
+
+public class derbyStress {
+	
+	private static String[] testObjects = {"table t1"};
+	
+	private static int numConn = 1;
+	private static int numRows = 100;
+	private static int numPreparedStmts = 5000; 
+
+	public static void main(String[] args) {
+		try {
+			System.out.println("Test derbyStress starting");
+
+			// use the ij utility to read the property file and
+			// make the initial connection.
+			ij.getPropertyArg(args);
+			Connection conn = null;
+			
+			for (int i = 0; i < numConn; i++) {
+				 conn = ij.startJBMS();
+				 System.out.println("Testing with " + numPreparedStmts + " prepared statements");
+				 prepStmtTest(conn, numRows, numPreparedStmts);
+				 System.out.println("PASS -- Prepared statement test");
+				 conn.close();
+			}
+			System.out.println("Test derbyStress finished.");
+		} catch (SQLException se) {
+			TestUtil.dumpSQLExceptions(se);
+		} catch (Throwable e) {
+			System.out.println("FAIL -- unexpected exception caught in main():\n");
+			System.out.println(e.getMessage());
+			e.printStackTrace();
+		}
+	}
+	
+	private static void createTables(Connection conn, int numRows) throws SQLException{
+		Statement stmt = conn.createStatement();
+		
+		TestUtil.cleanUpTest(stmt, testObjects);
+		
+		stmt.execute("create table t1 (lvc  LONG VARCHAR)");
+		stmt.close();
+		
+		String insertTabSql = "insert into t1 values(?)";
+		PreparedStatement ps = conn.prepareStatement(insertTabSql);
+		 for (int i = 0; i < numRows; i++)
+		 {
+			 ps.setString(1,"Hello" + i);
+			 ps.executeUpdate();
+		 }
+		 ps.close();
+	}
+	
+	// Tests prepared statements are not leaked if not explicitly closed by
+	// user (DERBY-210)
+	private static void prepStmtTest(Connection conn, int numRows, int numPreparedStmts) throws Exception
+	{
+		PreparedStatement ps = null;
+		ResultSet rs = null;
+		conn.setAutoCommit(false);
+		 
+		try {
+		
+			createTables(conn, numRows);
+			
+			String selTabSql = "select * from t1";
+			
+			for (int i = 0 ; i  < numPreparedStmts; i++)
+			{
+				ps = conn.prepareStatement(selTabSql);
+				rs = ps.executeQuery();
+
+				while (rs.next())
+				{
+					rs.getString(1);
+				}
+
+				rs.close();
+			
+				// Do not close the prepared statement
+				//ps.close();
+			}
+			conn.commit();
+		} 
+		catch (SQLException e) {
+			TestUtil.dumpSQLExceptions(e);
+			conn.rollback();
+		}
+	}
+}
