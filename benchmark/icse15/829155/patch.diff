diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/C_NodeTypes.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/C_NodeTypes.java
index 267bbd91..0160f57e 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/C_NodeTypes.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/C_NodeTypes.java
@@ -236,8 +236,15 @@ Licensed to the Apache Software Foundation (ASF) under one or more
     static final int CREATE_SEQUENCE_NODE = 224;
     static final int DROP_SEQUENCE_NODE = 225;
 
+	// Windowing
+	static final int AGGREGATE_WINDOW_FUNCTION_NODE = 226;
+	static final int ROW_NUMBER_FUNCTION_NODE = 227;
+	static final int WINDOW_DEFINITION_NODE = 228;
+	static final int WINDOW_REFERENCE_NODE = 229;
+	static final int WINDOW_RESULTSET_NODE = 230;
+
     // Final value in set, keep up to date!
-    static final int FINAL_VALUE = DROP_SEQUENCE_NODE;
+    static final int FINAL_VALUE = WINDOW_RESULTSET_NODE;
 
     /**
      * Extensions to this interface can use nodetypes > MAX_NODE_TYPE with out fear of collision
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/execute/ResultSetFactory.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/execute/ResultSetFactory.java
index 6c9f0449..5df054d5 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/execute/ResultSetFactory.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/execute/ResultSetFactory.java
@@ -1103,6 +1103,41 @@ public NoPutResultSet getIndexRowToBaseRowResultSet(
 								double optimizerEstimatedCost)
 			throws StandardException;
 
+
+
+	/**
+	   A OLAP window on top of a regular result set. It is used to realize
+	   window functions.
+	   <p>
+	   @param activation   Activation
+	   @param source       The result set input to this result set.
+	   @param rowAllocator A reference to a method in the activation
+			               that generates rows of the right size and
+						   shape for the source.
+	   @param resultSetNumber The resultSetNumber for the ResultSet
+	   @param erdNumber    Int for ResultDescription
+	                       (so it can be turned back into an object)
+	   @param restriction  The restriction, if any, to be applied to the
+	                       base row
+	   @param optimizerEstimatedRowCount
+                           Estimated total # of rows by optimizer
+	   @param optimizerEstimatedCost
+                           Estimated total cost by optimizer
+	   @throws StandardException
+	 */
+	public NoPutResultSet getWindowResultSet(
+								Activation activation,
+								NoPutResultSet source,
+								GeneratedMethod rowAllocator,
+								int resultSetNumber,
+								int erdNumber,
+								GeneratedMethod restriction,
+								double optimizerEstimatedRowCount,
+								double optimizerEstimatedCost)
+			throws StandardException;
+
+
+
 	/**
 		A nested loop left outer join result set forms a result set on top of
 		2 other result sets.
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/AggregateNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/AggregateNode.java
index 85e0d80c..31ac9c49 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/AggregateNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/AggregateNode.java
@@ -296,6 +296,10 @@ public ValueNode bindExpression(
 						aggregateName);
 			}
 
+			// Also forbid any window function inside an aggregate unless in
+			// subquery, cf. SQL 2003, section 10.9, SR 7 a).
+			SelectNode.checkNoWindowFunctions(operand, aggregateName);
+
 			/*
 			** Check the type of the operand.  Make sure that the user
 			** defined aggregate can handle the operand datatype.
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/AggregateWindowFunctionNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/AggregateWindowFunctionNode.java
index 3f24d583..6e6e0d60 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/AggregateWindowFunctionNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/AggregateWindowFunctionNode.java
@@ -1 +1,94 @@
   + native
+/*
+   Derby - Class org.apache.derby.impl.sql.compile.AggregateWindowFunctionNode
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.impl.sql.compile;
+
+import org.apache.derby.iapi.error.StandardException;
+import org.apache.derby.iapi.types.TypeId;
+import org.apache.derby.iapi.services.sanity.SanityManager;
+import org.apache.derby.iapi.reference.SQLState;
+
+import java.sql.Types;
+import java.util.Vector;
+
+/**
+ * Represents aggregate function calls on a window
+ */
+public final class AggregateWindowFunctionNode extends WindowFunctionNode
+{
+
+    private AggregateNode aggregateFunction;
+
+    /**
+     * Initializer. QueryTreeNode override.
+     *
+     * @param arg1 The window definition or reference
+     * @param arg2 aggregate function node
+     *
+     * @exception StandardException
+     */
+    public void init(Object arg1, Object arg2)
+        throws StandardException
+    {
+        super.init(null, "?", arg1);
+        aggregateFunction = (AggregateNode)arg2;
+
+        throw StandardException.newException(
+            SQLState.NOT_IMPLEMENTED,
+            "WINDOW/" + aggregateFunction.getAggregateName());
+    }
+
+
+    /**
+     * ValueNode override.
+     * @see ValueNode#bindExpression
+     */
+    public ValueNode bindExpression(
+                    FromList            fromList,
+                    SubqueryList        subqueryList,
+                    Vector              aggregateVector)
+            throws StandardException
+    {
+        aggregateFunction.bindExpression(
+            fromList, subqueryList, aggregateVector);
+        return this;
+    }
+
+
+
+    /**
+     * QueryTreeNode override. Prints the sub-nodes of this object.
+     * @see QueryTreeNode#printSubNodes
+     *
+     * @param depth     The depth of this node in the tree
+     */
+
+    public void printSubNodes(int depth)
+    {
+        if (SanityManager.DEBUG)
+        {
+            super.printSubNodes(depth);
+
+            printLabel(depth, "aggregate: ");
+            aggregateFunction.treePrint(depth + 1);
+        }
+    }
+}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/C_NodeNames.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/C_NodeNames.java
index fd500671..7cf9689c 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/C_NodeNames.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/C_NodeNames.java
@@ -43,7 +43,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
     // THEM TO tools/jar/DBMSnodes.properties
 
 	static final String AGGREGATE_NODE_NAME = "org.apache.derby.impl.sql.compile.AggregateNode";
-
 	static final String ALL_RESULT_COLUMN_NAME = "org.apache.derby.impl.sql.compile.AllResultColumn";
 
 	static final String ALTER_TABLE_NODE_NAME = "org.apache.derby.impl.sql.compile.AlterTableNode";
@@ -301,6 +300,11 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	static final String SAVEPOINT_NODE_NAME = "org.apache.derby.impl.sql.compile.SavepointNode";
 
 	static final String XML_CONSTANT_NODE_NAME = "org.apache.derby.impl.sql.compile.XMLConstantNode";
+	static final String AGGREGATE_WINDOW_FUNCTION_NAME = "org.apache.derby.impl.sql.compile.AggregateWindowFunctionNode";
+	static final String ROW_NUMBER_FUNCTION_NAME = "org.apache.derby.impl.sql.compile.RowNumberFunctionNode";
+	static final String WINDOW_DEFINITION_NAME = "org.apache.derby.impl.sql.compile.WindowDefinitionNode";
+	static final String WINDOW_REFERENCE_NAME = "org.apache.derby.impl.sql.compile.WindowReferenceNode";
+	static final String WINDOW_RESULTSET_NODE_NAME = "org.apache.derby.impl.sql.compile.WindowResultSetNode";
 
 	static final String ROW_COUNT_NODE_NAME = "org.apache.derby.impl.sql.compile.RowCountNode";
 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
index bc99d8a1..1b88cf80 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
@@ -76,6 +76,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	//Expression genResult;
 
 	private boolean		replacesAggregate;
+	private boolean		replacesWindowFunctionCall;
 
 	private int			nestingLevel = -1;
 	private int			sourceLevel = -1;
@@ -147,7 +148,11 @@ public String toString()
 				"tableNumber: " + tableNumber + "\n" +
 				"columnNumber: " + columnNumber + "\n" +
 				"replacesAggregate: " + replacesAggregate + "\n" +
-				"tableName: " + ( ( tableName != null) ? tableName.toString() : "null") + "\n" +
+				"replacesWindowFunctionCall: " +
+				    replacesWindowFunctionCall + "\n" +
+				"tableName: " + ( ( tableName != null) ?
+								  tableName.toString() :
+								  "null") + "\n" +
 				"nestingLevel: " + nestingLevel + "\n" +
 				"sourceLevel: " + sourceLevel + "\n" +
 				super.toString();
@@ -259,6 +264,15 @@ public void markGeneratedToReplaceAggregate()
 		replacesAggregate = true;
 	}
 
+
+	/**
+	 * Mark this node as being generated to replace a window function call.
+	 */
+	public void markGeneratedToReplaceWindowFunctionCall()
+	{
+		replacesWindowFunctionCall = true;
+	}
+
 	/**
 	 * Determine whether or not this node was generated to
 	 * replace an aggregate in the user's SELECT.
@@ -271,6 +285,19 @@ public boolean getGeneratedToReplaceAggregate()
 		return replacesAggregate;
 	}
 
+
+	/**
+	 * Determine whether or not this node was generated to
+	 * replace a window function call in the user's SELECT.
+	 *
+	 * @return boolean	Whether or not this node was generated to replace
+	 *					a window function call in the user's SELECT.
+	 */
+	public boolean getGeneratedToReplaceWindowFunctionCall()
+	{
+		return replacesWindowFunctionCall;
+	}
+
 	/**
 	 * Return a clone of this node.
 	 *
@@ -310,6 +337,8 @@ public void copyFields(ColumnReference oldCR)
 		nestingLevel = oldCR.getNestingLevel();
 		sourceLevel = oldCR.getSourceLevel();
 		replacesAggregate = oldCR.getGeneratedToReplaceAggregate();
+		replacesWindowFunctionCall =
+			oldCR.getGeneratedToReplaceWindowFunctionCall();
 		scoped = oldCR.isScoped();
 	}
 
@@ -593,6 +622,8 @@ public ValueNode putAndsOnTop()
 	 * pushing the predicate into the SelectNode that evaluates the aggregate,
 	 * which doesn't make sense, since the having clause is supposed to be
 	 * applied to the result of the SelectNode.
+	 * This also goes for column references that replaces a window function.
+	 *
 	 *
 	 * RESOLVE - revisit this issue once we have views.
 	 *
@@ -612,6 +643,7 @@ public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
 		referencedTabs.set(tableNumber);
 
 		return ( ! replacesAggregate ) &&
+			   ( ! replacesWindowFunctionCall ) &&
 			   ( (source.getExpression() instanceof ColumnReference) ||
 			     (source.getExpression() instanceof VirtualColumnNode) ||
 				 (source.getExpression() instanceof ConstantNode));
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/DeleteNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/DeleteNode.java
index 16fb36e4..1d627a41 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/DeleteNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/DeleteNode.java
@@ -788,6 +788,7 @@ private StatementNode getEmptyDeleteNode(String schemaName, String targetTableNa
                                                      whereClause, /* WHERE clause */
                                                      null, /* GROUP BY list */
                                                      null, /* having clause */
+													 null, /* windows */
                                                      getContextManager());
 
         return (StatementNode) nodeFactory.getNode(
@@ -838,6 +839,7 @@ private StatementNode getEmptyUpdateNode(String schemaName,
                                                      whereClause, /* WHERE clause */
                                                      null, /* GROUP BY list */
 						     null, /* having clause */
+													 null, /* windows */
                                                      getContextManager());
 
         return (StatementNode) nodeFactory.getNode(
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/FromList.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/FromList.java
index 69611dff..9802e7b8 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/FromList.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/FromList.java
@@ -74,6 +74,13 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	 */
 	private boolean isTransparent;
 
+	/**
+	 * Window definitions used for resolving window functions not containing
+	 * in-line window specifications, but referring window definitions
+	 */
+	private WindowList windows;
+
+
 	/** Initializer for a FromList */
 
 	public void init(Object optimizeJoinOrder)
@@ -1616,4 +1623,21 @@ public Visitable accept(Visitor v)
 
 		return this;
 	}
+
+
+	/**
+	 * Set windows field to the supplied value.
+	 * @param windows list of window definitions associated with a SELECT.
+	 */
+	public void setWindows(WindowList windows) {
+		this.windows = windows;
+	}
+
+
+	/**
+	 * @return list of window definitions associated with a SELECT.
+	 */
+	public WindowList getWindows() {
+		return windows;
+	}
 }
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/GroupByColumn.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/GroupByColumn.java
index 4d1169b2..340d97b9 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/GroupByColumn.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/GroupByColumn.java
@@ -25,6 +25,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.error.StandardException;
 
 import org.apache.derby.iapi.sql.dictionary.DataDictionary;
+import org.apache.derby.iapi.sql.compile.Visitor;
+import org.apache.derby.iapi.sql.compile.Visitable;
 
 import org.apache.derby.iapi.types.TypeId;
 
@@ -137,4 +139,28 @@ public void setColumnExpression(ValueNode cexpr)
 		this.columnExpression = cexpr;
 		
 	}
+
+	/**
+	 * Accept a visitor, and call v.visit()
+	 * on child nodes as necessary.
+	 *
+	 * @param v the visitor
+	 *
+	 * @exception StandardException on error
+	 */
+	public Visitable accept(Visitor v)
+		throws StandardException {
+
+		Visitable returnNode = v.visit(this);
+
+		if (v.skipChildren(this)) {
+			return returnNode;
+		}
+
+		if (columnExpression != null) {
+			columnExpression = (ValueNode)columnExpression.accept(v);
+		}
+
+		return returnNode;
+	}
 }
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/GroupByNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/GroupByNode.java
index ae9f1ee2..c261f573 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/GroupByNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/GroupByNode.java
@@ -580,12 +580,14 @@ private void addNewColumnsForAggregation()
 			CollectNodesVisitor collectNodesVisitor = 
 				new CollectNodesVisitor(ColumnReference.class, AggregateNode.class);
 			havingClause.accept(collectNodesVisitor);
+
 			for (Iterator it = collectNodesVisitor.getList().iterator();
 			     it.hasNext(); ) 
 			{
 				ColumnReference cr = (ColumnReference)it.next();
 				
-				if (!cr.getGeneratedToReplaceAggregate() && 
+				if ( ! (cr.getGeneratedToReplaceAggregate() ||
+						cr.getGeneratedToReplaceWindowFunctionCall()) &&
 						cr.getSourceLevel() == level) {
 					throw StandardException.newException(
 							SQLState.LANG_INVALID_COL_HAVING_CLAUSE, 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/JoinNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/JoinNode.java
index 06f54694..3fe93e9f 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/JoinNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/JoinNode.java
@@ -826,6 +826,10 @@ private void deferredBindExpressions(FromList fromListParam)
 				throw se;
 			}
 
+			// SQL 2003, section 7.7 SR 5
+			SelectNode.checkNoWindowFunctions(joinClause, "ON");
+
+
 			/* DB2 doesn't allow subquerries in the ON clause */
 			if (subqueryList.size() > 0)
 				throw StandardException.newException(SQLState.LANG_DB2_ON_CLAUSE_INVALID); 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NodeFactoryImpl.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NodeFactoryImpl.java
index 4c7197f6..859dafd3 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NodeFactoryImpl.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NodeFactoryImpl.java
@@ -614,6 +614,21 @@ protected String nodeName(int nodeType)
           case C_NodeTypes.TABLE_PRIVILEGES_NODE:
             return C_NodeNames.TABLE_PRIVILEGES_NAME;
 
+		  case C_NodeTypes.AGGREGATE_WINDOW_FUNCTION_NODE:
+			return C_NodeNames.AGGREGATE_WINDOW_FUNCTION_NAME;
+
+		  case C_NodeTypes.ROW_NUMBER_FUNCTION_NODE:
+			return C_NodeNames.ROW_NUMBER_FUNCTION_NAME;
+
+		  case C_NodeTypes.WINDOW_DEFINITION_NODE:
+			return C_NodeNames.WINDOW_DEFINITION_NAME;
+
+		  case C_NodeTypes.WINDOW_REFERENCE_NODE:
+			return C_NodeNames.WINDOW_REFERENCE_NAME;
+
+		  case C_NodeTypes.WINDOW_RESULTSET_NODE:
+			return C_NodeNames.WINDOW_RESULTSET_NODE_NAME;
+
           case C_NodeTypes.GENERATION_CLAUSE_NODE:
             return C_NodeNames.GENERATION_CLAUSE_NODE_NAME;
 		  	
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/OrderByColumn.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/OrderByColumn.java
index a34c2938..b9e6d9b3 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/OrderByColumn.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/OrderByColumn.java
@@ -32,6 +32,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.sql.compile.C_NodeTypes;
 
 import org.apache.derby.iapi.util.ReuseFactory;
+import org.apache.derby.iapi.sql.compile.Visitable;
+import org.apache.derby.iapi.sql.compile.Visitor;
 
 /**
  * An OrderByColumn is a column in the ORDER BY clause.  An OrderByColumn
@@ -84,7 +86,6 @@ public String toString() {
 		}
 	}
 
-
 	/**
 	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
 	 * how tree printing is supposed to work.
@@ -497,4 +498,31 @@ void collapseAddedColumnGap(int gap)
 		if (addedColumnOffset > gap)
 			addedColumnOffset--;
 	}
+
+
+	/**
+	 * Accept a visitor, and call v.visit()
+	 * on child nodes as necessary.
+	 *
+	 * @param v the visitor
+	 *
+	 * @exception StandardException on error
+	 */
+	public Visitable accept(Visitor v)
+		throws StandardException
+	{
+		Visitable returnNode = v.visit(this);
+
+		if (v.skipChildren(this))
+		{
+			return returnNode;
+		}
+
+		if (expression != null && !v.stopTraversal())
+		{
+			expression = (ValueNode)expression.accept(v);
+		}
+		return returnNode;
+	}
+
 }
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ProjectRestrictNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ProjectRestrictNode.java
index 8f9ca055..6fff50e3 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ProjectRestrictNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ProjectRestrictNode.java
@@ -1099,11 +1099,27 @@ public void pushExpressions(PredicateList predicateList)
 		 * if we can push any of the predicates which just got pushed
 		 * down to our level into the SelectNode.
 		 */
-		if (pushPList != null && (childResult instanceof SelectNode))
+		if (pushPList != null &&
+				(childResult instanceof SelectNode))
 		{
-			pushPList.pushExpressionsIntoSelect((SelectNode) childResult, false);
+			SelectNode childSelect = (SelectNode)childResult;
+
+			if ( (childSelect.hasWindows()  &&
+				  childSelect.orderByList != null) ) {
+				// We can't push down if there is an ORDER BY and a window
+				// function because that would make ROW_NUMBER give wrong
+				// result:
+				// E.g.
+				//     SELECT * from (SELECT ROW_NUMBER() OVER (), j FROM T
+				//                    ORDER BY j) WHERE j=5
+				//
+			} else {
+				pushPList.pushExpressionsIntoSelect((SelectNode) childResult,
+													false);
+			}
 		}
 
+
 		/* DERBY-649: Push simple predicates into Unions. It would be up to UnionNode
 		 * to decide if these predicates can be pushed further into underlying SelectNodes
 		 * or UnionNodes.  Note, we also keep the predicateList at this
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ReplaceWindowFuncCallsWithCRVisitor.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ReplaceWindowFuncCallsWithCRVisitor.java
index 3f24d583..3d105cbf 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ReplaceWindowFuncCallsWithCRVisitor.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ReplaceWindowFuncCallsWithCRVisitor.java
@@ -1 +1,107 @@
   + native
+/*
+   Derby - Class org.apache.derby.impl.sql.compile.ReplaceWindowFuncCallsWithCRVisitor
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+
+package	org.apache.derby.impl.sql.compile;
+
+import org.apache.derby.iapi.sql.compile.Visitable;
+import org.apache.derby.iapi.sql.compile.Visitor;
+
+import org.apache.derby.iapi.error.StandardException;
+
+/**
+ * Replace all window function calls with result columns.
+ *
+ */
+public class ReplaceWindowFuncCallsWithCRVisitor implements Visitor
+{
+	private ResultColumnList rcl;
+	private Class skipOverClass;
+	private int tableNumber;
+
+	/**
+	 * Replace all window function calls with column references.  Add
+	 * the reference to the RCL.  Delegates most work to
+	 * WindowFunctionNode.replaceCallsWithColumnReferences(rcl, tableNumber).
+	 *
+	 * @param rcl the result column list
+	 * @param tableNumber	The tableNumber for the new CRs
+	 * @param skipOverClass Don't go past this
+	 */
+	public ReplaceWindowFuncCallsWithCRVisitor(ResultColumnList rcl,
+											int tableNumber,
+											Class skipOverClass)
+	{
+		this.rcl = rcl;
+		this.tableNumber = tableNumber;
+		this.skipOverClass = skipOverClass;
+	}
+
+	////////////////////////////////////////////////
+	//
+	// VISITOR INTERFACE
+	//
+	////////////////////////////////////////////////
+
+	/**
+	 * Don't do anything unless we have a window function node
+	 * node. Vistor override.
+	 * @see Visitor#visit
+	 *
+	 */
+	public Visitable visit(Visitable node)
+		throws StandardException
+	{
+		if (node instanceof WindowFunctionNode)
+		{
+			/*
+			** Let windowFunctionNode replace itself.
+			*/
+			node = ((WindowFunctionNode)node).
+				replaceCallsWithColumnReferences(rcl, tableNumber);
+		}
+
+		return node;
+	}
+
+	/**
+	 * Don't visit childen under the skipOverClass
+	 * node, if it isn't null. Vistor override.
+	 * @see Visitor#skipChildren
+	 */
+	public boolean skipChildren(Visitable node)
+	{
+		return (skipOverClass == null) ?
+				false:
+				skipOverClass.isInstance(node);
+	}
+
+
+	/**
+	 * Vistor override.
+	 * @return false
+	 * @see Visitor#skipChildren
+	 */
+	public boolean stopTraversal()
+	{
+		return false;
+	}
+}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowNumberFunctionNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowNumberFunctionNode.java
index 3f24d583..e9026b25 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowNumberFunctionNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowNumberFunctionNode.java
@@ -1 +1,69 @@
   + native
+/*
+   Derby - Class org.apache.derby.impl.sql.compile.RowNumberFunctionNode
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.impl.sql.compile;
+
+import org.apache.derby.iapi.error.StandardException;
+import org.apache.derby.iapi.types.TypeId;
+import org.apache.derby.iapi.services.sanity.SanityManager;
+
+import java.sql.Types;
+import java.util.Vector;
+
+/**
+ * Class that represents a call to the ROW_NUMBER() window function.
+ */
+public final class RowNumberFunctionNode extends WindowFunctionNode
+{
+
+    /**
+     * Initializer. QueryTreeNode override.
+     *
+     * @param arg1 null (Operand)
+     * @param arg2 The window definition or reference
+     *
+     * @exception StandardException
+     */
+    public void init(Object arg1, Object arg2)
+        throws StandardException
+    {
+        super.init(arg1, "ROW_NUMBER", arg2);
+        setType( TypeId.getBuiltInTypeId( Types.BIGINT ),
+                 TypeId.LONGINT_PRECISION,
+                 TypeId.LONGINT_SCALE,
+                 false,
+                 TypeId.LONGINT_MAXWIDTH);
+    }
+
+    /**
+     * ValueNode override.
+     * @see ValueNode#bindExpression
+     */
+    public ValueNode bindExpression(
+                    FromList            fromList,
+                    SubqueryList        subqueryList,
+                    Vector              aggregateVector)
+            throws StandardException
+    {
+        super.bindExpression(fromList, subqueryList, aggregateVector);
+        return this;
+    }
+}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowResultSetNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowResultSetNode.java
index 31a1b125..08f53fef 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowResultSetNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowResultSetNode.java
@@ -244,6 +244,8 @@ public void bindExpressions(FromList fromListParam)
 		{
 			throw StandardException.newException(SQLState.LANG_NO_AGGREGATES_IN_WHERE_CLAUSE);
 		}
+
+		SelectNode.checkNoWindowFunctions(resultColumns, "VALUES");
 	}
 
 	/**
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
index 20806257..57a620ee 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
@@ -88,6 +88,16 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	 */
 	GroupByList	groupByList;
 
+	/**
+	 * List of windows.
+	 */
+	WindowList windows;
+
+	/**
+	 * List of window function calls (e.g. ROW_NUMBER, AVG(i), DENSE_RANK).
+	 */
+	Vector windowFuncCalls;
+
 	/** User specified a group by without aggregates and we turned 
 	 * it into a select distinct 
 	 */
@@ -125,7 +135,8 @@ public void init(Object selectList,
 			  Object fromList,
 			  Object whereClause,
 			  Object groupByList,
-			  Object havingClause)
+			  Object havingClause,
+			  Object windowDefinitionList)
 			throws StandardException
 	{
 		/* RESOLVE - remove aggregateList from constructor.
@@ -139,6 +150,15 @@ public void init(Object selectList,
 		this.originalWhereClause = (ValueNode) whereClause;
 		this.groupByList = (GroupByList) groupByList;
 		this.havingClause = (ValueNode)havingClause;
+
+		// This initially represents an explicit <window definition list>, as
+		// opposed to <in-line window specifications>, see 2003, 6.10 and 6.11.
+		// <in-line window specifications> are added later, see right below for
+		// in-line window specifications used in window functions in the SELECT
+		// column list and in genProjectRestrict for such window specifications
+		// used in window functions in ORDER BY.
+		this.windows = (WindowList)windowDefinitionList;
+
 		bindTargetListOnly = false;
 		
 		this.originalWhereClauseHadSubqueries = false;
@@ -150,6 +170,65 @@ public void init(Object selectList,
 				this.originalWhereClauseHadSubqueries = true;
 			}
 		}
+
+		if (resultColumns != null) {
+
+			// Collect window functions used in result columns, and check them
+			// for any <in-line window specification>s.
+
+			CollectNodesVisitor cnvw =
+				new CollectNodesVisitor(WindowFunctionNode.class);
+			resultColumns.accept(cnvw);
+			windowFuncCalls = cnvw.getList();
+
+			for (int i=0; i < windowFuncCalls.size(); i++) {
+				WindowFunctionNode wfn =
+					(WindowFunctionNode)windowFuncCalls.elementAt(i);
+
+				// Some window function, e.g. ROW_NUMBER() contains an inline
+				// window specification, so we add it to our list of window
+				// definitions.
+
+				if (wfn.getWindow() instanceof WindowDefinitionNode) {
+					// Window function call contains an inline definition, add
+					// it to our list of windows.
+					windows = addInlinedWindowDefinition(windows, wfn);
+				} else {
+					// a window reference, bind it later.
+
+					if (SanityManager.DEBUG) {
+						SanityManager.ASSERT(
+							wfn.getWindow() instanceof WindowReferenceNode);
+					}
+				}
+			}
+		}
+	}
+
+	private WindowList addInlinedWindowDefinition (WindowList wl,
+												   WindowFunctionNode wfn) {
+		WindowDefinitionNode wdn = (WindowDefinitionNode)wfn.getWindow();
+
+		if (wl == null) {
+			// This is the first window we see, so initialize list.
+			wl = new WindowList();
+			wl.setContextManager(getContextManager());
+		}
+
+		WindowDefinitionNode equiv = wdn.findEquivalentWindow(wl);
+
+		if (equiv != null) {
+			// If the window is equivalent an existing one, optimize
+			// it away.
+
+			wfn.setWindow(equiv);
+		} else {
+			// remember this window for posterity
+
+			wl.addWindow((WindowDefinitionNode)wfn.getWindow());
+		}
+
+		return wl;
 	}
 
 	/**
@@ -241,6 +320,11 @@ public void printSubNodes(int depth)
 				groupByList.treePrint(depth + 1);
 			}
 
+			if (havingClause != null) {
+				printLabel(depth, "havingClause:");
+				havingClause.treePrint(depth + 1);
+			}
+
 			if (orderByList != null) {
 				printLabel(depth, "orderByList:");
 				orderByList.treePrint(depth + 1);
@@ -252,6 +336,11 @@ public void printSubNodes(int depth)
 				preJoinFL.treePrint(depth + 1);
 			}
 
+			if (windows != null)
+			{
+				printLabel(depth, "windows: ");
+				windows.treePrint(depth + 1);
+			}
 		}
 	}
 
@@ -448,6 +537,18 @@ public void bindExpressions(FromList fromListParam)
 			fromListParam.insertElementAt(fromList.elementAt(index), index);
 		}
 
+		// In preparation for resolving window references in expressions, we
+		// make the FromList carry the set of explicit window definitions.
+		//
+		// E.g. "select row_number () from r, .. from t window r as ()"
+		//
+		// Here the expression "row_number () from r" needs to be bound to r's
+		// definition. Window functions can also in-line window specifications,
+		// no resolution is necessary. See also
+		// WindowFunctionNode.bindExpression.
+
+		fromListParam.setWindows(windows);
+
 		resultColumns.bindExpressions(fromListParam, 
 									  selectSubquerys,
 									  selectAggregates);
@@ -496,6 +597,8 @@ public void bindExpressions(FromList fromListParam)
 			
 			whereClause = whereClause.checkIsBoolean();
 			getCompilerContext().popCurrentPrivType();
+
+			checkNoWindowFunctions(whereClause, "WHERE");
 		}
 
 		if (havingClause != null) {
@@ -506,6 +609,7 @@ public void bindExpressions(FromList fromListParam)
 			havingClause.bindExpression(
 					fromListParam, havingSubquerys, havingAggregates);
 			havingClause = havingClause.checkIsBoolean();
+			checkNoWindowFunctions(havingClause, "HAVING");
 		}
 		
 		/* Restore fromList */
@@ -541,6 +645,8 @@ public void bindExpressions(FromList fromListParam)
 				SanityManager.ASSERT(gbAggregateVector.size() == 0,
 						"Unexpected Aggregate vector generated by Group By clause");
 			}
+
+			checkNoWindowFunctions(groupByList, "GROUP BY");
 		}
 		/* If ungrouped query with aggregates in SELECT list, verify
 		 * that all result columns are valid aggregate expressions -
@@ -637,7 +743,6 @@ public void bindResultColumns(FromList fromListParam)
 		 */
 		fromList.bindResultColumns(fromListParam);
 		super.bindResultColumns(fromListParam);
-
 		/* Only 1012 elements allowed in select list */
 		if (resultColumns.size() > Limits.DB2_MAX_ELEMENTS_IN_SELECT_LIST)
 		{
@@ -969,7 +1074,6 @@ public ResultSetNode preprocess(int numTables,
 				// columns are ones that have equality comparisons with
 				// constant expressions (e.g. x = 3)
 				orderByList.removeConstantColumns(wherePredicates);
-
 				/*
 				** It's possible for the order by list to shrink to nothing
 				** as a result of removing constant columns.  If this happens,
@@ -1099,6 +1203,42 @@ public ResultSetNode preprocess(int numTables,
 		{
 			newTop.setReferencedTableMap((JBitSet) referencedTableMap.clone());
 		}
+
+
+		if (orderByList != null) {
+
+			// Collect window function calls and in-lined window definitions
+			// contained in them from the orderByList.
+
+			CollectNodesVisitor cnvw =
+				new CollectNodesVisitor(WindowFunctionNode.class);
+			orderByList.accept(cnvw);
+			Vector wfcInOrderBy = cnvw.getList();
+
+			for (int i=0; i < wfcInOrderBy.size(); i++) {
+				WindowFunctionNode wfn =
+					(WindowFunctionNode)wfcInOrderBy.elementAt(i);
+				windowFuncCalls.add(wfn);
+
+
+				if (wfn.getWindow() instanceof WindowDefinitionNode) {
+					// Window function call contains an inline definition, add
+					// it to our list of windows.
+					windows = addInlinedWindowDefinition(windows, wfn);
+
+				} else {
+					// a window reference, should be bound already.
+
+					if (SanityManager.DEBUG) {
+						SanityManager.ASSERT(
+							false,
+							"a window reference, should be bound already");
+					}
+				}
+			}
+		}
+
+
 		return newTop;
 	}
 
@@ -1267,7 +1407,6 @@ public ResultSetNode genProjectRestrict(int origFromListSize)
 		ResultColumnList	prRCList;
 		ResultSetNode		prnRSN;
 
-
 		prnRSN = (ResultSetNode) getNodeFactory().getNode(
 								C_NodeTypes.PROJECT_RESTRICT_NODE,
 								fromList.elementAt(0),	/* Child ResultSet */
@@ -1315,6 +1454,33 @@ public ResultSetNode genProjectRestrict(int origFromListSize)
 			eliminateSort = eliminateSort || gbn.getIsInSortedOrder();
 		}
 
+
+		if (windows != null) {
+
+			// Now we add a window result set wrapped in a PRN on top of what
+			// we currently have.
+
+			if (windows.size() > 1) {
+				throw StandardException.newException(
+					SQLState.LANG_WINDOW_LIMIT_EXCEEDED);
+			}
+
+			WindowNode wn = (WindowNode)windows.elementAt(0);
+
+			WindowResultSetNode wrsn =
+				(WindowResultSetNode)getNodeFactory().getNode(
+					C_NodeTypes.WINDOW_RESULTSET_NODE,
+					prnRSN,
+					wn,
+					windowFuncCalls,
+					new Integer(nestingLevel),
+					getContextManager());
+
+			prnRSN = wrsn.getParent();
+			wrsn.assignCostEstimate(optimizer.getOptimizedCost());
+		}
+
+
 		// if it is distinct, that must also be taken care of.
 		if (isDistinct)
 		{
@@ -1386,6 +1552,7 @@ public ResultSetNode genProjectRestrict(int origFromListSize)
 		/* Generate the OrderByNode if a sort is still required for
 		 * the order by.
 		 */
+
 		if (orderByList != null)
 		{
 			if (orderByList.getSortNeeded())
@@ -1424,7 +1591,11 @@ public ResultSetNode genProjectRestrict(int origFromListSize)
 		}
 
 		
-		if (wasGroupBy && resultColumns.numGeneratedColumnsForGroupBy() > 0) {
+		if (wasGroupBy &&
+			resultColumns.numGeneratedColumnsForGroupBy() > 0 &&
+			windows == null) // windows handling already added a PRN which
+							 // obviates this.
+		{
 			// This case takes care of columns generated for group by's which 
 			// will need to be removed from the final projection. Note that the
 			// GroupByNode does remove generated columns but in certain cases
@@ -2224,4 +2395,35 @@ public boolean hasAggregatesInSelectList()
 	{
 		return !selectAggregates.isEmpty();
 	}
+
+	/**
+	 * Used by SubqueryNode to avoid flattening of a subquery if a window is
+	 * defined on it. Note that any inline window definitions should have been
+	 * collected from both the selectList and orderByList at the time this
+	 * method is called, so the windows list is complete. This is true after
+	 * preprocess is completed.
+	 *
+	 * @return true if this select node has any windows on it
+	 */
+	public boolean hasWindows()
+	{
+		return windows != null;
+	}
+
+
+	public static void checkNoWindowFunctions(QueryTreeNode clause,
+											   String clauseName)
+			throws StandardException {
+
+		// Clause cannot contain window functions except inside subqueries
+		HasNodeVisitor visitor = new HasNodeVisitor(WindowFunctionNode.class,
+													SubqueryNode.class);
+		clause.accept(visitor);
+
+		if (visitor.hasNode()) {
+			throw StandardException.newException(
+				SQLState.LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
+				clauseName);
+		}
+	}
 }
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SetOperatorNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SetOperatorNode.java
index a14f16b9..70ed1539 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SetOperatorNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SetOperatorNode.java
@@ -1028,6 +1028,7 @@ public ResultSetNode setResultToBooleanTrueNode(boolean onlyConvertAlls)
 				null,     // WHERE clause
 				null,     // GROUP BY list
 				null,     // having clause
+				null, /* window list */
 				getContextManager());
 
 		/* And finally, transform the "*" in the new SELECT node
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java
index b9d85986..f9bef002 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java
@@ -627,6 +627,7 @@ public ValueNode preprocess(int numTables,
 					  underTopAndNode && !havingSubquery &&
 					  !isWhereExistsAnyInWithWhereSubquery() &&
 					  parentComparisonOperator instanceof BinaryComparisonOperatorNode;
+
 		if (flattenable)
 		{
 			/* If we got this far and we are an expression subquery
@@ -680,6 +681,7 @@ public ValueNode preprocess(int numTables,
 		 *	  that the flattening of the subquery will not
 		 *	  introduce duplicates into the result set.
          *  o The subquery is not part of a having clause (DERBY-3257)
+		 *  o There are no windows defined on it
 		 *
 		 *	OR,
 		 *  o The subquery is NOT EXISTS, NOT IN, ALL (beetle 5173).
@@ -691,6 +693,7 @@ public ValueNode preprocess(int numTables,
 		boolean flattenableNotExists = (isNOT_EXISTS() || canAllBeFlattened());
 
 		flattenable = (resultSet instanceof SelectNode) &&
+ 			          !((SelectNode)resultSet).hasWindows() &&
 					  underTopAndNode && !havingSubquery &&
 					  !isWhereExistsAnyInWithWhereSubquery() &&
 					  (isIN() || isANY() || isEXISTS() || flattenableNotExists ||
@@ -728,6 +731,7 @@ public ValueNode preprocess(int numTables,
 				}
 				/* Never flatten to normal join for NOT EXISTS.
 				 */
+
 				if ((! flattenableNotExists) && select.uniqueSubquery(additionalEQ))
 				{
 					// Flatten the subquery
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowDefinitionNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowDefinitionNode.java
index e69de29b..ea8e7f6c 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowDefinitionNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowDefinitionNode.java
@@ -0,0 +1,155 @@
+/*
+
+   Derby - Class org.apache.derby.impl.sql.compile.WindowDefinitionNode
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.impl.sql.compile;
+
+import org.apache.derby.iapi.error.StandardException;
+import org.apache.derby.iapi.types.TypeId;
+import org.apache.derby.iapi.services.sanity.SanityManager;
+import org.apache.derby.iapi.reference.SQLState;
+
+import java.sql.Types;
+
+/**
+ * This class represents an OLAP window definition.
+ */
+public final class WindowDefinitionNode extends WindowNode
+{
+    /**
+     * True of the window definition was inlined.
+     */
+    private boolean inlined;
+
+    /**
+     * The order by list if the window definition contains a <window order
+     * clause>, else null.
+     */
+    private OrderByList orderByList;
+
+    /**
+     * Initializer.
+     *
+     * @param arg1 The window name, null if in-lined definition
+     * @param arg2 ORDER BY list
+     * @exception StandardException
+     */
+    public void init(Object arg1,
+                     Object arg2)
+        throws StandardException
+    {
+        String name = (String)arg1;
+
+        orderByList = (OrderByList)arg2;
+
+        if (name != null) {
+            super.init(arg1);
+            inlined = false;
+        } else {
+            super.init("IN-LINE");
+            inlined = true;
+        }
+
+        if (orderByList != null) {
+            throw StandardException.newException(SQLState.NOT_IMPLEMENTED,
+                                                 "WINDOW/ORDER BY");
+        }
+    }
+
+
+    /**
+     * java.lang.Object override.
+     * @see QueryTreeNode#toString
+     */
+    public String toString() {
+        return ("name: " + getName() + "\n" +
+                "inlined: " + inlined + "\n" +
+                "()\n");
+    }
+
+
+
+    /**
+     * QueryTreeNode override. Prints the sub-nodes of this object.
+     * @see QueryTreeNode#printSubNodes
+     *
+     * @param depth     The depth of this node in the tree
+     */
+
+    public void printSubNodes(int depth)
+    {
+        if (SanityManager.DEBUG)
+        {
+            super.printSubNodes(depth);
+
+            if (orderByList != null) {
+                printLabel(depth, "orderByList: "  + depth);
+                orderByList.treePrint(depth + 1);
+            }
+        }
+    }
+
+
+    /**
+     * Used to merge equivalent window definitions.
+     *
+     * @param wl list of window definitions
+     * @return an existing window definition from wl, if 'this' is equivalent
+     * to a window in wl.
+     */
+    public WindowDefinitionNode findEquivalentWindow(WindowList wl) {
+        for (int i = 0; i < wl.size(); i++) {
+            WindowDefinitionNode old = (WindowDefinitionNode)wl.elementAt(i);
+
+            if (isEquivalent(old)) {
+                return old;
+            }
+        }
+        return null;
+    }
+
+
+
+    /**
+     * @return true if the window specifications are equal; no need to create
+     * more than one window then.
+     */
+    private boolean isEquivalent(WindowDefinitionNode other) {
+        if (orderByList == null && other.getOrderByList() == null) {
+            return true;
+        }
+
+        if (SanityManager.DEBUG) {
+            SanityManager.ASSERT(
+                false,
+                "FIXME: ordering in windows not implemented yet");
+        }
+        return false;
+    }
+
+
+
+    /**
+     * @return the order by list of this window definition if any, else null.
+     */
+    public OrderByList getOrderByList() {
+        return orderByList;
+    }
+}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowFunctionNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowFunctionNode.java
index e69de29b..e55dda0b 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowFunctionNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowFunctionNode.java
@@ -0,0 +1,275 @@
+/*
+   Derby - Class org.apache.derby.impl.sql.compile.WindowFunctionNode
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.impl.sql.compile;
+
+import org.apache.derby.iapi.error.StandardException;
+import org.apache.derby.iapi.types.TypeId;
+import org.apache.derby.iapi.services.sanity.SanityManager;
+import org.apache.derby.iapi.sql.compile.CompilerContext;
+import org.apache.derby.iapi.sql.compile.C_NodeTypes;
+import org.apache.derby.iapi.reference.SQLState;
+
+import java.sql.Types;
+import java.util.Vector;
+
+
+/**
+ * Superclass of any window function call.
+ */
+public abstract class WindowFunctionNode extends UnaryOperatorNode
+{
+
+    private WindowNode window; // definition or reference
+
+    /*
+    ** We wind up pushing all window function calls into a different
+    ** resultColumnList.  When we do this (in replaceCallsWithColumnReference),
+    ** we return a column reference and create a new result column.  This is
+    ** used to store that result column.
+    */
+    private ResultColumn            generatedRC;
+    private ColumnReference         generatedRef;
+
+    /**
+     * Initializer for a WindowFunctionNode
+     * @param arg1 null (operand)
+     * @param arg2 function mame (operator)
+     * @param arg3 window node (definition or reference)
+     * @exception StandardException
+     */
+    public void init(Object arg1, Object arg2, Object arg3)
+    {
+        super.init(arg1, arg2, null);
+        this.window = (WindowNode)arg3;
+    }
+
+    /**
+     * ValueNode override.
+     * @see ValueNode#isConstantExpression
+     */
+    public boolean isConstantExpression()
+    {
+        return false;
+    }
+
+    /**
+     * ValueNode override.
+     * @see ValueNode#isConstantExpression
+     */
+    public boolean constantExpression(PredicateList whereClause)
+    {
+        // Without this, an ORDER by on ROW_NUMBER could get optimised away
+        // if there is a restriction, e.g.
+        //
+        // SELECT -ABS(i) a, ROW_NUMBER() OVER () c FROM t
+        //     WHERE i > 1 ORDER BY c DESC
+        return false;
+    }
+
+
+    /**
+     * @return window associated with this window function
+     */
+    public WindowNode getWindow() {
+        return window;
+    }
+
+
+    /**
+     * Set window associated with this window function call.
+     * @param wdn window definition
+     */
+    public void setWindow(WindowDefinitionNode wdn) {
+        this.window = wdn;
+    }
+
+
+    /**
+     * ValueNode override.
+     * @see ValueNode#bindExpression
+     */
+    public ValueNode bindExpression(
+            FromList fromList,
+            SubqueryList subqueryList,
+            Vector  aggregateVector)
+        throws StandardException
+    {
+        if (window instanceof WindowReferenceNode) {
+
+            WindowDefinitionNode found =
+                definedWindow(fromList.getWindows(), window.getName());
+
+            if (found != null) {
+                window = found;
+            } else {
+                throw StandardException.
+                    newException(SQLState.LANG_NO_SUCH_WINDOW,
+                                 window.getName());
+            }
+        }
+
+        return this;
+    }
+
+
+    /**
+     * @return if name matches a defined window (in windows), return the
+     * definition of that window, else null.
+     */
+    private WindowDefinitionNode definedWindow(WindowList windows,
+                                               String name) {
+        for (int i=0; i < windows.size(); i++) {
+            WindowDefinitionNode wdn =
+                (WindowDefinitionNode)windows.elementAt(i);
+
+            if (wdn.getName().equals(name)) {
+                return wdn;
+            }
+        }
+        return null;
+    }
+
+
+    /**
+     * QueryTreeNode override.
+     * @see QueryTreeNode#printSubNodes
+     */
+
+    public void printSubNodes(int depth)
+    {
+        if (SanityManager.DEBUG)
+        {
+            super.printSubNodes(depth);
+
+            printLabel(depth, "window: ");
+            window.treePrint(depth + 1);
+        }
+    }
+
+    /**
+     * Replace window function calls in the expression tree with a
+     * ColumnReference to that window function, append the aggregate to the
+     * supplied RCL (assumed to be from the child ResultSetNode) and return the
+     * ColumnReference.
+     *
+     * @param rcl   The RCL to append to.
+     * @param tableNumber   The tableNumber for the new ColumnReference
+     *
+     * @return ValueNode    The (potentially) modified tree.
+     *
+     * @exception StandardException         Thrown on error
+     */
+    public ValueNode replaceCallsWithColumnReferences(ResultColumnList rcl,
+                                                      int tableNumber)
+        throws StandardException
+    {
+        /*
+         * This call is idempotent.  Do the right thing if we have already
+         * replaced ourselves.
+         */
+        if (generatedRef == null)
+        {
+            String                  generatedColName;
+            CompilerContext         cc = getCompilerContext();
+            generatedColName ="SQLCol" + cc.getNextColumnNumber();
+            generatedRC = (ResultColumn) getNodeFactory().getNode(
+                                            C_NodeTypes.RESULT_COLUMN,
+                                            generatedColName,
+                                            this,
+                                            getContextManager());
+            generatedRC.markGenerated();
+
+            // Parse time.
+            //
+            generatedRef = (ColumnReference) getNodeFactory().getNode(
+                                                C_NodeTypes.COLUMN_REFERENCE,
+                                                generatedRC.getName(),
+                                                null,
+                                                getContextManager());
+
+            // RESOLVE - unknown nesting level, but not correlated, so nesting
+            // levels must be 0
+            generatedRef.setSource(generatedRC);
+            generatedRef.setNestingLevel(0);
+            generatedRef.setSourceLevel(0);
+
+            if (tableNumber != -1)
+            {
+                generatedRef.setTableNumber(tableNumber);
+            }
+
+            rcl.addResultColumn(generatedRC);
+
+
+            // Mark the ColumnReference as being generated to replace a call to
+            // a window function
+
+            generatedRef.markGeneratedToReplaceWindowFunctionCall();
+        }
+        else
+        {
+            rcl.addResultColumn(generatedRC);
+        }
+
+        return generatedRef;
+    }
+
+    /**
+     * Get the generated ColumnReference to this window function after the
+     * parent called replaceCallsWithColumnReferences().
+     * <p/>
+     * There are cases where this will not have been done because the tree has
+     * been re-written to eliminate the window function, e.g. for this query:
+     * <p/><pre>
+     *     {@code SELECT * FROM t WHERE EXISTS
+     *           (SELECT ROW_NUMBER() OVER () FROM t)}
+     * </pre><p/>
+     * in which case the top PRN of the subquery sitting over a
+     * WindowResultSetNode just contains a RC which is boolean constant {@code
+     * true}. This means that the replaceCallsWithColumnReferences will not
+     * have been called for {@code this}, so the returned {@code generatedRef}
+     * is null.
+     *
+     * @return the column reference
+     */
+    public ColumnReference getGeneratedRef()
+    {
+        return generatedRef;
+    }
+
+
+    /**
+     * Get the null result expression column.
+     *
+     * @return the value node
+     *
+     * @exception StandardException on error
+     */
+    public ValueNode    getNewNullResultExpression()
+        throws StandardException
+    {
+        //
+        // Create a result column with the aggregate operand
+        // it.
+        //
+        return getNullNode(getTypeServices());
+    }
+}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowList.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowList.java
index e69de29b..6c2a4546 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowList.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowList.java
@@ -0,0 +1,40 @@
+/*
+
+   Derby - Class org.apache.derby.impl.sql.compile.WindowList
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.impl.sql.compile;
+
+/**
+ * A WindowList represents the list of windows (definitions) for a table
+ * expression, either defined explicitly in a WINDOW clause, or inline in the
+ * SELECT list or ORDER BY clause.
+ *
+ */
+
+public class WindowList extends OrderedColumnList
+{
+    /**
+     * @param window the window definition to add to the list
+     */
+    public void addWindow(WindowDefinitionNode window)
+    {
+        addElement(window);
+    }
+}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowNode.java
index e69de29b..e771a872 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowNode.java
@@ -0,0 +1,68 @@
+/*
+
+   Derby - Class org.apache.derby.impl.sql.compile.WindowNode
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.impl.sql.compile;
+
+import org.apache.derby.iapi.error.StandardException;
+import org.apache.derby.iapi.types.TypeId;
+import org.apache.derby.iapi.services.sanity.SanityManager;
+
+import java.sql.Types;
+import java.util.Vector;
+
+/**
+ * Superclass of window definition and window reference.
+ */
+public abstract class WindowNode extends QueryTreeNode
+{
+    /**
+     * The provided name of the window if explicitly defined in a window
+     * clause. If the definition is inlined, currently the definition has
+     * windowName "IN_LINE".  The standard 2003 sec. 4.14.9 calls for a
+     * impl. defined one.
+     */
+    private String windowName;
+
+
+    /**
+     * Initializer
+     *
+     * @param arg1 The window name
+     *
+     * @exception StandardException
+     */
+    public void init(Object arg1)
+        throws StandardException
+    {
+        windowName = (String)arg1;
+    }
+
+
+    /**
+     * @return the name of this window
+     */
+    public String getName() {
+        return windowName;
+    }
+
+
+
+}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowReferenceNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowReferenceNode.java
index e69de29b..2c6f1b8e 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowReferenceNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowReferenceNode.java
@@ -0,0 +1,54 @@
+/*
+
+   Derby - Class org.apache.derby.impl.sql.compile.WindowReferenceNode
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.impl.sql.compile;
+
+import org.apache.derby.iapi.error.StandardException;
+import org.apache.derby.iapi.types.TypeId;
+import org.apache.derby.iapi.services.sanity.SanityManager;
+
+import java.sql.Types;
+import java.util.Vector;
+
+/**
+ * Represents a reference to an explicitly defined window
+ */
+public final class WindowReferenceNode extends WindowNode
+{
+    /**
+     * Initializer
+     *
+     * @param arg1 The window name referenced
+     *
+     * @exception StandardException
+     */
+    public void init(Object arg1)
+        throws StandardException
+    {
+        super.init(arg1);
+    }
+
+    // java.lang.Object override
+    public String toString() {
+        return "referenced window: " + getName() + "\n" +
+            super.toString();
+    }
+}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowResultSetNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowResultSetNode.java
index e69de29b..a1c0d4c7 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowResultSetNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowResultSetNode.java
@@ -0,0 +1,455 @@
+/*
+   Derby - Class org.apache.derby.impl.sql.compile.WindowResultSetNode
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.impl.sql.compile;
+
+import java.util.Iterator;
+import java.util.Vector;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.Collections;
+
+import org.apache.derby.catalog.IndexDescriptor;
+import org.apache.derby.iapi.error.StandardException;
+import org.apache.derby.iapi.reference.ClassName;
+import org.apache.derby.iapi.reference.SQLState;
+import org.apache.derby.iapi.services.classfile.VMOpcode;
+import org.apache.derby.iapi.services.compiler.MethodBuilder;
+import org.apache.derby.iapi.services.io.FormatableArrayHolder;
+import org.apache.derby.iapi.services.io.FormatableBitSet;
+import org.apache.derby.iapi.services.sanity.SanityManager;
+import org.apache.derby.iapi.sql.LanguageFactory;
+import org.apache.derby.iapi.sql.ResultColumnDescriptor;
+import org.apache.derby.iapi.sql.compile.AccessPath;
+import org.apache.derby.iapi.sql.compile.C_NodeTypes;
+import org.apache.derby.iapi.sql.compile.CostEstimate;
+import org.apache.derby.iapi.sql.compile.Optimizable;
+import org.apache.derby.iapi.sql.compile.OptimizablePredicate;
+import org.apache.derby.iapi.sql.compile.OptimizablePredicateList;
+import org.apache.derby.iapi.sql.compile.Optimizer;
+import org.apache.derby.iapi.sql.compile.RequiredRowOrdering;
+import org.apache.derby.iapi.sql.compile.RowOrdering;
+import org.apache.derby.iapi.sql.dictionary.ConglomerateDescriptor;
+import org.apache.derby.iapi.sql.dictionary.DataDictionary;
+import org.apache.derby.iapi.store.access.ColumnOrdering;
+import org.apache.derby.impl.sql.execute.AggregatorInfo;
+import org.apache.derby.impl.sql.execute.AggregatorInfoList;
+
+
+/**
+ * A WindowResultSetNode represents a result set for a window partitioning on a
+ * select. Modelled on the code in GroupByNode.
+ */
+public class WindowResultSetNode extends SingleChildResultSetNode
+{
+    /**
+     * The parent to the WindowResultSetNode.  We generate a ProjectRestrict
+     * over the windowing node and parent is set to that node.
+     */
+    FromTable   parent;
+    Vector windowFuncCalls;
+    WindowDefinitionNode wdn;
+
+    /**
+     * Intializer for a WindowResultSetNode.
+     * @param bottomPR The project restrict result set we want to wrap
+     * @param windowDef The window definition
+     * @param windowFuncCalls All window function calls in SELECT's select list
+     * and order by list.
+     * @param nestingLevel Nesting level
+     *
+     * @exception StandardException     Thrown on error
+     */
+    public void init(
+        Object bottomPR,
+        Object windowDef,
+        Object windowFuncCalls,
+        Object nestingLevel) throws StandardException
+    {
+        super.init(bottomPR, null);
+        this.wdn = (WindowDefinitionNode)windowDef;
+        this.windowFuncCalls = (Vector)windowFuncCalls;
+        setLevel(((Integer)nestingLevel).intValue());
+
+        ResultColumnList newBottomRCL;
+
+        this.parent = this;
+
+        /*
+        ** The first thing we do is put ourselves on top of the SELECT.  The
+        ** select becomes the childResult.  So our RCL becomes its RCL (so
+        ** nodes above it now point to us).  Map our RCL to its columns.
+        */
+        newBottomRCL = childResult.getResultColumns().copyListAndObjects();
+        resultColumns = childResult.getResultColumns();
+        childResult.setResultColumns(newBottomRCL);
+
+        // Wrao purselved int a project/restrict as per convention.
+        addNewPRNode();
+
+        // Add the extra result columns required
+        addNewColumns();
+    }
+
+    /**
+     * Add a new PR node.  Put the new PR under any sort.
+     *
+     * @exception standard exception
+     */
+    private void addNewPRNode()
+        throws StandardException
+    {
+        /*
+        ** Get the new PR, put above the WindowResultSetNode.
+        */
+        ResultColumnList rclNew = (ResultColumnList)getNodeFactory().
+            getNode(C_NodeTypes.RESULT_COLUMN_LIST,
+                    getContextManager());
+
+        int sz = resultColumns.size();
+        for (int i = 0; i < sz; i++)
+        {
+            ResultColumn rc = (ResultColumn) resultColumns.elementAt(i);
+            if (!rc.isGenerated()) {
+                rclNew.addElement(rc);
+            }
+        }
+
+        // if any columns in the source RCL were generated for an order by
+        // remember it in the new RCL as well. After the sort is done it will
+        // have to be projected out upstream.
+        rclNew.copyOrderBySelect(resultColumns);
+
+        parent = (FromTable) getNodeFactory().getNode(
+                                        C_NodeTypes.PROJECT_RESTRICT_NODE,
+                                        this, // child
+                                        rclNew,
+                                        null, // havingClause,
+                                        null, // restriction list
+                                        null, // project subqueries
+                                        null, // havingSubquerys,
+                                        null, // tableProperties,
+                                        getContextManager());
+
+
+        /*
+         * Reset the bottom RCL to be empty.
+         */
+        childResult.setResultColumns((ResultColumnList)
+                                            getNodeFactory().getNode(
+                                                C_NodeTypes.RESULT_COLUMN_LIST,
+                                                getContextManager()));
+
+        /*
+         * Set the Windowing RCL to be empty
+         */
+        resultColumns = (ResultColumnList) getNodeFactory().getNode(
+                                            C_NodeTypes.RESULT_COLUMN_LIST,
+                                            getContextManager());
+
+
+        // Add all referenced columns in select list to windowing node's RCL
+        // and substitute references in original node to point to the Windowing
+        // result set. (modelled on GroupByNode's action for addUnAggColumns)
+        CollectNodesVisitor getCRVisitor =
+            new CollectNodesVisitor(ColumnReference.class);
+
+        ResultColumnList prcl = parent.getResultColumns();
+
+        parent.getResultColumns().accept(getCRVisitor);
+
+        Vector colRefs = getCRVisitor.getList();
+
+        // Find all unique columns referenced and add those to windowing result
+        // set.
+        Vector uniqueCols = new Vector();
+        for (int i= 0; i< colRefs.size(); i++) {
+            ColumnReference cr = (ColumnReference)colRefs.elementAt(i);
+            if (!colRefAlreadySeen(uniqueCols, cr)) {
+                uniqueCols.add(cr);
+            }
+        }
+
+        // Add all virtual column select list to windowing node's RCL and
+        // substitute references in original node to point to the Windowing
+        // result set. Happens for example when we have a window over a group
+        // by.
+        CollectNodesVisitor getVCVisitor =
+            new CollectNodesVisitor(VirtualColumnNode.class);
+
+        parent.getResultColumns().accept(getVCVisitor);
+        Vector vcs = getVCVisitor.getList();
+
+        // Add any virtual columns to windowing result.
+        for (int i= 0; i< vcs.size(); i++) {
+            uniqueCols.add(vcs.elementAt(i));
+        }
+
+        ResultColumnList bottomRCL  = childResult.getResultColumns();
+        ResultColumnList windowingRCL = resultColumns;
+
+        for (int i= 0; i< uniqueCols.size(); i++) {
+            ValueNode crOrVcn = (ValueNode)uniqueCols.elementAt(i);
+
+            ResultColumn newRC = (ResultColumn) getNodeFactory().getNode(
+                    C_NodeTypes.RESULT_COLUMN,
+                    "##UnWindowingColumn",
+                    crOrVcn,
+                    getContextManager());
+
+            // add this result column to the bottom rcl
+            bottomRCL.addElement(newRC);
+            newRC.markGenerated();
+            newRC.bindResultColumnToExpression();
+            newRC.setVirtualColumnId(bottomRCL.size());
+
+            // now add this column to the windowing result column list
+            ResultColumn wRC = (ResultColumn) getNodeFactory().getNode(
+                    C_NodeTypes.RESULT_COLUMN,
+                    "##UnWindowingColumn",
+                    crOrVcn,
+                    getContextManager());
+            windowingRCL.addElement(wRC);
+            wRC.markGenerated();
+            wRC.bindResultColumnToExpression();
+            wRC.setVirtualColumnId(windowingRCL.size());
+
+            /*
+             ** Reset the original node to point to the
+             ** Windowing result set.
+             */
+            VirtualColumnNode vc = (VirtualColumnNode) getNodeFactory().getNode(
+                    C_NodeTypes.VIRTUAL_COLUMN_NODE,
+                    this, // source result set.
+                    wRC,
+                    new Integer(windowingRCL.size()),
+                    getContextManager());
+
+            SubstituteExpressionVisitor seVis =
+                new SubstituteExpressionVisitor(crOrVcn, vc, null);
+            parent.getResultColumns().accept(seVis);
+        }
+    }
+
+
+    /**
+     * @return true if an equivalent column reference to cand is already
+     * present in uniqueColRefs
+     */
+    private boolean colRefAlreadySeen(Vector uniqueColRefs,
+                                      ColumnReference cand)
+            throws StandardException {
+
+        for (int i= 0; i< uniqueColRefs.size(); i++) {
+            ColumnReference cr = (ColumnReference)uniqueColRefs.elementAt(i);
+
+            if (cr.isEquivalent(cand)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Substitute new result columns for window function calls and add the
+     * result columns to childResult's list of columns.
+     */
+    private void addNewColumns() throws StandardException {
+        /*
+         * Now process all of the window function calls.  Replace every
+         * call with an RC.  We toss out the list of RCs, we need to get
+         * each RC as we process its corresponding window function.
+         */
+        LanguageFactory lf =
+            getLanguageConnectionContext().getLanguageFactory();
+
+        ResultColumnList bottomRCL  = childResult.getResultColumns();
+        ResultColumnList windowingRCL = resultColumns;
+
+        ReplaceWindowFuncCallsWithCRVisitor replaceCallsVisitor =
+            new ReplaceWindowFuncCallsWithCRVisitor(
+                (ResultColumnList) getNodeFactory().getNode(
+                    C_NodeTypes.RESULT_COLUMN_LIST,
+                    getContextManager()),
+                ((FromTable) childResult).getTableNumber(),
+                ResultSetNode.class);
+        parent.getResultColumns().accept(replaceCallsVisitor);
+
+        for (int i=0; i < windowFuncCalls.size(); i++) {
+            WindowFunctionNode winFunc =
+                (WindowFunctionNode)windowFuncCalls.elementAt(i);
+
+            if (SanityManager.DEBUG) {
+                SanityManager.ASSERT(
+                    !(winFunc.getWindow() instanceof WindowReferenceNode),
+                    "unresolved window-reference: " +
+                    winFunc.getWindow().getName());
+            }
+
+            WindowDefinitionNode funcWindow =
+                (WindowDefinitionNode)winFunc.getWindow();
+
+            if (funcWindow == wdn) {
+                ResultColumn newRC = (ResultColumn) getNodeFactory().getNode(
+                    C_NodeTypes.RESULT_COLUMN,
+                    "##winFuncResult",
+                    winFunc.getNewNullResultExpression(),
+                    getContextManager());
+
+                newRC.markGenerated();
+                newRC.bindResultColumnToExpression();
+                bottomRCL.addElement(newRC);
+                newRC.setVirtualColumnId(bottomRCL.size());
+                int winFuncResultVColId = newRC.getVirtualColumnId();
+
+                /*
+                ** Set the WindowResultSetNode result column to point to this.
+                ** The Windowing Node result was created when we called
+                ** ReplaceWindowFuncCallsWithCRVisitor.
+                */
+                ColumnReference newColumnRef =
+                    (ColumnReference) getNodeFactory().getNode(
+                        C_NodeTypes.COLUMN_REFERENCE,
+                        newRC.getName(),
+                        null,
+                        getContextManager());
+
+                newColumnRef.setSource(newRC);
+                newColumnRef.setNestingLevel(this.getLevel());
+                newColumnRef.setSourceLevel(this.getLevel());
+                newColumnRef.markGeneratedToReplaceWindowFunctionCall();
+
+                ResultColumn tmpRC = (ResultColumn) getNodeFactory().getNode(
+                    C_NodeTypes.RESULT_COLUMN,
+                    newRC.getColumnName(),
+                    newColumnRef,
+                    getContextManager());
+
+                tmpRC.markGenerated();
+                tmpRC.bindResultColumnToExpression();
+                windowingRCL.addElement(tmpRC);
+                tmpRC.setVirtualColumnId(windowingRCL.size());
+
+                /*
+                ** Set the column reference to point to
+                ** this.
+                */
+                newColumnRef = winFunc.getGeneratedRef();
+
+                if (newColumnRef != null) {
+                    newColumnRef.setSource(tmpRC);
+                } // Not generated, meaning it's no longer in use
+            }
+        }
+    }
+
+
+    /**
+     * override
+     * @see QueryTreeNode#generate
+     */
+    public void generate(ActivationClassBuilder acb,
+                         MethodBuilder mb)
+            throws StandardException
+    {
+        // Get the next ResultSet#, so we can number this ResultSetNode, its
+        // ResultColumnList and ResultSet.
+
+        assignResultSetNumber();
+
+        // Get the final cost estimate from the child.
+        costEstimate = childResult.getFinalCostEstimate();
+
+
+        acb.pushGetResultSetFactoryExpression(mb);
+
+        int rclSize = resultColumns.size();
+        FormatableBitSet referencedCols = new FormatableBitSet(rclSize);
+
+        /*
+         * Build a FormatableBitSet for columns to copy from source.
+         */
+
+        for (int index = rclSize-1; index >= 0; index--) {
+            ResultColumn rc = (ResultColumn) resultColumns.elementAt(index);
+            ValueNode expr = rc.getExpression();
+
+            if (rc.isGenerated() &&
+                    (expr instanceof ColumnReference) &&
+                    ((ColumnReference)expr).
+                        getGeneratedToReplaceWindowFunctionCall()) {
+
+                // meaningless to copy these, they arise in this rs.
+            } else {
+                referencedCols.set(index);
+            }
+        }
+
+        int erdNumber = acb.addItem(referencedCols);
+
+        acb.pushThisAsActivation(mb); // arg 1
+
+        childResult.generate(acb, mb);    // arg 2
+        mb.upCast(ClassName.NoPutResultSet);
+
+        /* row allocator */
+        resultColumns.generateHolder(acb, mb); // arg 3
+
+        mb.push(resultSetNumber); //arg 4
+
+        /* Pass in the erdNumber for the referenced column FormatableBitSet */
+        mb.push(erdNumber); // arg 5
+
+        /* There is no restriction at this level, we just want to pass null. */
+        mb.pushNull(ClassName.GeneratedMethod); // arg 6
+
+        mb.push(costEstimate.rowCount()); //arg 7
+        mb.push(costEstimate.getEstimatedCost()); // arg 8
+
+        mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,
+            "getWindowResultSet", ClassName.NoPutResultSet, 8);
+
+    }
+
+
+
+    /**
+     * @return parent of this node, a PRN, used by SelectNode to retrieve new
+     * top result set node after window result set rewrite of result set tree.
+     */
+    public FromTable getParent() {
+        return parent;
+    }
+
+
+    /**
+     * QueryTreeNode override
+     * @see QueryTreeNode#printSubNodes
+     */
+    public void printSubNodes(int depth) {
+        if (SanityManager.DEBUG) {
+			super.printSubNodes(depth);
+
+            printLabel(depth, "wdn: ");
+            wdn.treePrint(depth + 1);
+        }
+    }
+
+}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/GenericResultSetFactory.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/GenericResultSetFactory.java
index 5e70f499..53055a99 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/GenericResultSetFactory.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/GenericResultSetFactory.java
@@ -828,6 +828,33 @@ public NoPutResultSet getIndexRowToBaseRowResultSet(
 								optimizerEstimatedCost);
 	}
 
+	/**
+		@see ResultSetFactory#getWindowResultSet
+		@exception StandardException	Thrown on error
+	 */
+	public NoPutResultSet getWindowResultSet(
+								Activation activation,
+								NoPutResultSet source,
+								GeneratedMethod rowAllocator,
+								int resultSetNumber,
+								int erdNumber,
+								GeneratedMethod restriction,
+								double optimizerEstimatedRowCount,
+								double optimizerEstimatedCost)
+		throws StandardException
+	{
+		return new WindowResultSet(
+								activation,
+								source,
+								rowAllocator,
+								resultSetNumber,
+								erdNumber,
+								restriction,
+								optimizerEstimatedRowCount,
+								optimizerEstimatedCost);
+	}
+
+
 	/**
 		@see ResultSetFactory#getNestedLoopJoinResultSet
 		@exception StandardException thrown on error
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/RealResultSetStatisticsFactory.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/RealResultSetStatisticsFactory.java
index 319b72a4..4ed0f719 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/RealResultSetStatisticsFactory.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/RealResultSetStatisticsFactory.java
@@ -71,6 +71,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.impl.sql.execute.UpdateResultSet;
 import org.apache.derby.impl.sql.execute.VTIResultSet;
 import org.apache.derby.impl.sql.execute.DependentResultSet;
+import org.apache.derby.impl.sql.execute.WindowResultSet;
 
 import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
 import org.apache.derby.impl.sql.execute.rts.RealAnyResultSetStatistics;
@@ -108,6 +109,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.impl.sql.execute.rts.RealRowCountStatistics;
 import org.apache.derby.impl.sql.execute.rts.ResultSetStatistics;
 import org.apache.derby.impl.sql.execute.rts.RunTimeStatisticsImpl;
+import org.apache.derby.impl.sql.execute.rts.RealWindowResultSetStatistics;
 
 import org.apache.derby.iapi.reference.SQLState;
 
@@ -837,6 +839,24 @@ else if (rs instanceof RowResultSet)
 											rrs.optimizerEstimatedRowCount,
 											rrs.optimizerEstimatedCost);
 		}
+		else if (rs instanceof WindowResultSet)
+		{
+			WindowResultSet wrs = (WindowResultSet) rs;
+
+			return new RealWindowResultSetStatistics(
+											wrs.numOpens,
+											wrs.rowsSeen,
+											wrs.rowsFiltered,
+											wrs.constructorTime,
+											wrs.openTime,
+											wrs.nextTime,
+											wrs.closeTime,
+											wrs.resultSetNumber,
+											wrs.optimizerEstimatedRowCount,
+											wrs.optimizerEstimatedCost,
+											getResultSetStatistics(wrs.source)
+											);
+		}
 		else if (rs instanceof SetOpResultSet)
 		{
 			SetOpResultSet srs = (SetOpResultSet) rs;
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/WindowResultSet.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/WindowResultSet.java
index e69de29b..7f4ccb39 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/WindowResultSet.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/WindowResultSet.java
@@ -0,0 +1,328 @@
+/*
+
+   Derby - Class org.apache.derby.impl.sql.execute.WindowResultSet
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+package org.apache.derby.impl.sql.execute;
+
+import org.apache.derby.iapi.services.sanity.SanityManager;
+import org.apache.derby.iapi.services.loader.GeneratedMethod;
+
+import org.apache.derby.iapi.sql.Activation;
+import org.apache.derby.iapi.sql.execute.ExecRow;
+import org.apache.derby.iapi.sql.execute.NoPutResultSet;
+
+import org.apache.derby.iapi.types.DataValueDescriptor;
+
+import org.apache.derby.iapi.reference.SQLState;
+import org.apache.derby.iapi.error.StandardException;
+import org.apache.derby.iapi.services.io.FormatableBitSet;
+
+/**
+ * WindowResultSet
+ *
+ * This ResultSet handles a window function ResultSet.
+ *
+ * The ResultSet is opened using openCore().  Each row is fetched and any
+ * restrictions evaluated for each row in a do-while loop in getNextRowCore().
+ * The ResultSet is closed using closeCore().
+ *
+ */
+class WindowResultSet extends NoPutResultSetImpl
+{
+    private GeneratedMethod restriction = null;
+    private GeneratedMethod row;
+
+
+    /**
+     * Source result set,
+     */
+    public NoPutResultSet source = null;
+
+
+    /**
+     * Cumulative time needed to evalute any restriction on this result set.
+     */
+    public long restrictionTime;
+
+    private FormatableBitSet referencedColumns;
+    private ExecRow allocatedRow;
+    private long rownumber;
+
+    /**
+     *  Constructor
+     *
+     *  @param  activation          The activation
+     *  @param  source              Source result set
+     *  @param  rowAllocator
+     *  @param  resultSetNumber     The resultSetNumber
+     *  @param  erdNumber           Int for ResultDescription
+	                                (so it can be turned back into an object)
+     *  @param  restriction         Restriction
+     *  @param  optimizerEstimatedRowCount  The optimizer's estimated number
+     *                                      of rows.
+     *  @param  optimizerEstimatedCost      The optimizer's estimated cost
+     */
+
+    WindowResultSet(Activation activation,
+        NoPutResultSet         source,
+        GeneratedMethod        rowAllocator,
+        int                    resultSetNumber,
+        int                    erdNumber,
+        GeneratedMethod        restriction,
+        double                 optimizerEstimatedRowCount,
+        double                 optimizerEstimatedCost)
+    {
+
+        super(activation,
+            resultSetNumber,
+            optimizerEstimatedRowCount,
+            optimizerEstimatedCost);
+
+        if (SanityManager.DEBUG) {
+            SanityManager.ASSERT(activation != null,
+                                 "activation expected to be non-null");
+            SanityManager.ASSERT(resultSetNumber >= 0,
+                                 "resultSetNumber expected to be >= 0");
+        }
+
+        this.restriction = restriction;
+        this.source = source;
+        this.row = rowAllocator;
+        this.allocatedRow = null;
+        this.rownumber = 0;
+
+        if (erdNumber != -1) {
+            this.referencedColumns =
+                (FormatableBitSet)(activation.getPreparedStatement().
+                                   getSavedObject(erdNumber));
+        }
+
+        recordConstructorTime();
+    }
+
+
+    /**
+     * Open this ResultSet.
+     *
+     * @exception StandardException thrown if cursor finished.
+     */
+    public void openCore() throws StandardException {
+        if (SanityManager.DEBUG) {
+            SanityManager.ASSERT(!isOpen,
+                "WindowResultSet already open");
+        }
+
+        beginTime = getCurrentTimeMillis();
+
+        /* Call into the source openCore() */
+        source.openCore();
+
+        isOpen = true;
+        rownumber = 0;
+        numOpens++;
+        openTime += getElapsedMillis(beginTime);
+    }
+
+    /**
+     * Reopen this ResultSet.
+     *
+     * @exception StandardException thrown if cursor finished.
+     */
+    public void reopenCore() throws StandardException {
+        if (SanityManager.DEBUG) {
+            SanityManager.ASSERT(isOpen, "WindowResultSet already open");
+        }
+
+        beginTime = getCurrentTimeMillis();
+
+        /* Reopen the source */
+        source.reopenCore();
+
+        rownumber = 0;
+        numOpens++;
+        openTime += getElapsedMillis(beginTime);
+    }
+
+    /**
+     * Return the requested values computed from the next row (if any) for which
+     * the restriction evaluates to true.
+     * <p>
+     * Restriction and projection parameters are evaluated for each row.
+     *
+     * @exception StandardException thrown on failure.
+     * @exception StandardException ResultSetNotOpen thrown if not yet open.
+     *
+     * @return the next row in the result
+     */
+    public ExecRow getNextRowCore() throws StandardException
+    {
+        ExecRow sourceRow = null;
+        ExecRow retval = null;
+        boolean restrict = false;
+        DataValueDescriptor restrictBoolean;
+        long beginRT = 0;
+
+        beginTime = getCurrentTimeMillis();
+
+        if (!isOpen) {
+            throw StandardException.newException(
+                SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
+        }
+
+        /*
+         * Loop until we get a row from the source that qualifies, or there are
+         * no more rows to qualify. For each iteration fetch a row from the
+         * source, and evaluate against the restriction if any.
+         */
+        ExecRow tmpRow = null;
+
+        do {
+            sourceRow = source.getNextRowCore();
+
+            if (sourceRow != null) {
+                this.rownumber++;
+                tmpRow = getAllocatedRow();
+                populateFromSourceRow(sourceRow, tmpRow);
+                setCurrentRow(tmpRow);
+
+                /* Evaluate any restrictions */
+                restrictBoolean = (DataValueDescriptor) ((restriction == null) ?
+                                    null : restriction.invoke(activation));
+
+                restrictionTime += getElapsedMillis(beginRT);
+
+                // if the result is null, we make it false --
+                // so the row won't be returned.
+                restrict = (restrictBoolean == null) ||
+                    ((!restrictBoolean.isNull()) &&
+                    restrictBoolean.getBoolean());
+
+                if (!restrict) {
+                    rowsFiltered++;
+                    clearCurrentRow();
+                }
+
+                /* Update the run time statistics */
+                rowsSeen++;
+                retval = currentRow;
+            } else {
+                clearCurrentRow();
+                retval = null;
+            }
+        } while ((sourceRow != null) && (!restrict));
+
+        nextTime += getElapsedMillis(beginTime);
+        return retval;
+    }
+
+    /**
+     * If the result set has been opened, close the open scan, else throw.
+     *
+     * @exception StandardException thrown on error
+     */
+    public void close() throws StandardException {
+        beginTime = getCurrentTimeMillis();
+
+        if (isOpen) {
+            clearCurrentRow();
+
+            /*
+             * Make sure to close the source
+             */
+            source.close();
+            super.close();
+
+        } else if (SanityManager.DEBUG) {
+            SanityManager.DEBUG("CloseRepeatInfo",
+                                "Close of WindowResultSet repeated");
+        }
+
+        closeTime += getElapsedMillis(beginTime);
+    }
+
+
+
+    /**
+     * Copy columns from srcrow into destrow, or insert ROW_NUMBER.
+     * <p/>
+     * <b>FIXME</b>
+     * This is temporary. Window function treatment needs to generalized to
+     * work for other window functions.
+     *
+     * @exception StandardException thrown on failure to open
+     */
+    public void populateFromSourceRow(ExecRow srcrow, ExecRow destrow)
+        throws StandardException
+    {
+        int srcindex = 1;
+
+        try {
+            DataValueDescriptor[] columns = destrow.getRowArray();
+            for (int index = 0; index < columns.length; index++) {
+
+                if (referencedColumns != null &&
+                        !referencedColumns.get(index)) {
+                    columns[index].setValue((long)this.rownumber);
+                } else {
+                    destrow.setColumn(index+1, srcrow.getColumn(srcindex));
+                    srcindex++;
+                }
+            }
+        } catch (StandardException se) {
+            throw se;
+        } catch (Throwable t) {
+            throw StandardException.unexpectedUserException(t);
+        }
+    }
+
+    /**
+     * Return the total amount of time spent in this ResultSet
+     *
+     * @param type  CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
+     *          ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
+     *
+     * @return long     The total amount of time spent (in milliseconds).
+     */
+    public long getTimeSpent(int type) {
+        long totTime = constructorTime + openTime + nextTime + closeTime;
+
+        if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY) {
+            return totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
+        } else {
+            return totTime;
+        }
+    }
+
+    /**
+     * Cache the ExecRow for this result set.
+     *
+     * @return The cached ExecRow for this ResultSet
+     *
+     * @exception StandardException thrown on failure.
+     */
+    private ExecRow getAllocatedRow()
+        throws StandardException {
+
+        if (allocatedRow == null) {
+            allocatedRow = (ExecRow) row.invoke(activation);
+        }
+
+        return allocatedRow;
+    }
+}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/rts/RealWindowResultSetStatistics.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/rts/RealWindowResultSetStatistics.java
index 3f24d583..d2c27061 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/rts/RealWindowResultSetStatistics.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/rts/RealWindowResultSetStatistics.java
@@ -1 +1,181 @@
   + native
+/*
+   Derby - Class org.apache.derby.impl.sql.execute.rts.RealWindowResultSetStatistics
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.impl.sql.execute.rts;
+
+import org.apache.derby.iapi.services.i18n.MessageService;
+import org.apache.derby.impl.sql.execute.xplain.XPLAINUtil;
+import org.apache.derby.iapi.sql.execute.xplain.XPLAINVisitor;
+import org.apache.derby.iapi.reference.SQLState;
+
+/**
+ * ResultSetStatistics implementation for WindowResultSet.
+ */
+public class RealWindowResultSetStatistics
+    extends RealNoPutResultSetStatistics
+{
+
+    private ResultSetStatistics childResultSetStatistics;
+
+    /**
+     * Constructor.
+     *
+     */
+    public  RealWindowResultSetStatistics(
+                                int numOpens,
+                                int rowsSeen,
+                                int rowsFiltered,
+                                long constructorTime,
+                                long openTime,
+                                long nextTime,
+                                long closeTime,
+                                int resultSetNumber,
+                                double optimizerEstimatedRowCount,
+                                double optimizerEstimatedCost,
+                                ResultSetStatistics childResultSetStatistics
+                                )
+    {
+        super(
+            numOpens,
+            rowsSeen,
+            rowsFiltered,
+            constructorTime,
+            openTime,
+            nextTime,
+            closeTime,
+            resultSetNumber,
+            optimizerEstimatedRowCount,
+            optimizerEstimatedCost
+            );
+        this.childResultSetStatistics = childResultSetStatistics;
+
+    }
+
+    // ResultSetStatistics interface
+
+    /**
+     * Return the statement execution plan as a String.
+     *
+     * @param depth Indentation level.
+     *
+     * @return String   The statement execution plan as a String.
+     */
+    public String getStatementExecutionPlanText(int depth)
+    {
+        initFormatInfo(depth);
+        String WINDOWSPECIFICATION = "()";
+
+        return
+            indent + MessageService.getTextMessage(
+                            SQLState.RTS_WINDOW_RS) +
+            WINDOWSPECIFICATION + "\n" +
+            indent + MessageService.getTextMessage(
+                            SQLState.RTS_NUM_OPENS) +
+                            " = " + numOpens + "\n" +
+            indent + MessageService.getTextMessage(
+                            SQLState.RTS_ROWS_SEEN) +
+                            " = " + rowsSeen + "\n" +
+            dumpTimeStats(indent, subIndent) + "\n" +
+            dumpEstimatedCosts(subIndent) + "\n" +
+            indent + MessageService.getTextMessage(
+                SQLState.RTS_SOURCE_RS) + ":\n" +
+            childResultSetStatistics.
+                getStatementExecutionPlanText(sourceDepth) + "\n";
+    }
+
+    /**
+     * Return information on the scan nodes from the statement execution
+     * plan as a String.
+     *
+     * @param depth Indentation level.
+     * @param tableName if not NULL then print information for this table only
+     *
+     * @return String   The information on the scan nodes from the
+     *                  statement execution plan as a String.
+     */
+    public String getScanStatisticsText(String tableName, int depth)
+    {
+        return getStatementExecutionPlanText(depth);
+    }
+
+
+    // java.lang.Object override
+    //
+    public String toString()
+    {
+        return getStatementExecutionPlanText(0);
+    }
+
+
+    /**
+     * RealBasicNoPutResultSetStatistics override.
+     * @see RealBasicNoPutResultSetStatistics#getChildren
+     */
+    public java.util.Vector getChildren()
+    {
+        java.util.Vector children = new java.util.Vector();
+        children.addElement(childResultSetStatistics);
+        return children;
+    }
+
+
+    /**
+     * RealBasicNoPutResultSetStatistics override.
+     * @see RealBasicNoPutResultSetStatistics#getNodeOn
+     */
+    public String getNodeOn(){
+        return MessageService.getTextMessage(
+                                    SQLState.RTS_FOR_TAB_NAME,
+                                    "<WINDOW FUNCTION>");
+    }
+
+
+    /**
+     * RealBasicNoPutResultSetStatistics override.
+     * @see RealBasicNoPutResultSetStatistics#getNodeName
+     */
+    public String getNodeName(){
+        return MessageService.getTextMessage(SQLState.RTS_IRTBR);
+    }
+
+
+
+    // -----------------------------------------------------
+    // XPLAINable Implementation
+    // -----------------------------------------------------
+
+    public void accept(XPLAINVisitor visitor) {
+
+        // I have only one child
+        visitor.setNumberOfChildren(1);
+
+        // pre-order, depth-first traversal me first
+        visitor.visit(this);
+
+        // then my child
+        childResultSetStatistics.accept(visitor);
+    }
+
+
+    public String getRSXplainType() {
+        return XPLAINUtil.OP_WINDOW;
+    }
+}
diff --git a/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java b/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java
index 7fdeb430..5a9c6782 100644
--- a/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java
+++ b/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java
@@ -1096,6 +1096,10 @@ The message identifier (ie. the value that matches a field in this class)
     String LANG_NO_COSTING_CONSTRUCTOR                              = "42ZB5";
     String LANG_TABLE_FUNCTION_NOT_ALLOWED                   = "42ZB6";
 
+	String LANG_NO_SUCH_WINDOW                                         = "42ZC0";
+	String LANG_WINDOW_LIMIT_EXCEEDED                                  = "42ZC1";
+	String LANG_WINDOW_FUNCTION_CONTEXT_ERROR                          = "42ZC2";
+
 	//following 3 matches the DB2 sql states
 	String LANG_DECLARED_GLOBAL_TEMP_TABLE_ONLY_IN_SESSION_SCHEMA = "428EK";
 	String LANG_NOT_ALLOWED_FOR_DECLARED_GLOBAL_TEMP_TABLE = "42995";
@@ -1213,6 +1217,7 @@ The message identifier (ie. the value that matches a field in this class)
 	String RTS_ROW_RS												   = "43X99.U";
 	String RTS_RC                                                      = "43X9A.U";
 	String RTS_RC_RS                                                   = "43X9B.U";
+	String RTS_WINDOW_RS                                               = "43X9C.U";
 
 	String RTS_SCALAR_AGG_RS										   = "43Y00.U";
 	String RTS_INDEX_KEY_OPT										   = "43Y01.U";
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/OLAPTest.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/OLAPTest.java
index a2ac9c73..2365fd03 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/OLAPTest.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/OLAPTest.java
@@ -25,12 +25,16 @@
 import java.sql.SQLException;
 import java.sql.PreparedStatement;
 import java.sql.Statement;
+import java.sql.ResultSetMetaData;
 
 import junit.framework.Test;
+import junit.framework.TestSuite;
+import junit.framework.Assert;
 
 import org.apache.derbyTesting.junit.BaseJDBCTestCase;
 import org.apache.derbyTesting.junit.JDBC;
 import org.apache.derbyTesting.junit.TestConfiguration;
+import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
 
 /**
  * OLAP functionality test.
@@ -39,10 +43,56 @@
  */ 
 public class OLAPTest extends BaseJDBCTestCase {
 
+	private final static String LANG_WINDOW_FUNCTION_CONTEXT_ERROR = "42ZC2";
+	private final static String NOT_IMPLEMENTED = "0A000";
+	private final static String LANG_SYNTAX_ERROR = "42X01";
+	private final static String LANG_COLUMN_NOT_FOUND =	"42X04";
+
 	public OLAPTest(String name) {
 		super(name);    
 	}
 
+	public static Test makeSuite() {
+        Test clean = new CleanDatabaseTestSetup(
+            new TestSuite(OLAPTest.class)) {
+                protected void decorateSQL(Statement s)
+                        throws SQLException
+                {
+                    getConnection().setAutoCommit(false);
+                    s.executeUpdate("create table t1 (a int, b int)");
+                    s.executeUpdate("create table t2 (x int)");
+                    s.executeUpdate("create table t3 (y int)");
+                    s.executeUpdate("create table t4 (a int, b int)");
+                    s.executeUpdate("create table t5 (a int, b int)");
+
+                    s.executeUpdate(
+                        "insert into t1 values (10,100),(20,200)," +
+                        "                      (30,300),(40,400)," +
+                        "                      (50,500)");
+                    s.executeUpdate(
+                        "insert into t2 values (1),(2),(3),(4),(5)");
+                    s.executeUpdate(
+                        "insert into t3 values (4),(5),(6),(7),(8)");
+                    s.executeUpdate(
+                        "insert into t4 values (10,100),(20,200)");
+                    s.executeUpdate(
+                        "insert into t5 values (1,1),(2,4),(3,4),(4,4),(5,9)");
+                    getConnection().commit();
+                }
+            };
+		return clean;
+	}
+
+
+	public static Test suite()
+    {
+		TestSuite suite = new TestSuite("OLAPTest");
+		suite.addTest(makeSuite());
+		suite.addTest(TestConfiguration.clientServerDecorator(makeSuite()));
+		return suite;
+    }
+
+
 	/**
 	 * Main test body
 	 * 
@@ -52,19 +102,13 @@ public void testBasicOperations()
 		throws SQLException {
 		Statement s = createStatement();
 
-		s.executeUpdate("create table t1 (a int, b int)");
-		s.executeUpdate("create table t2 (x int)");
-		s.executeUpdate("create table t3 (y int)");
-		s.executeUpdate("create table t4 (a int, b int)");
+		/*
+		 * Positive testing of Statements
+		 */
+
 
-		s.executeUpdate("insert into t1 values (10,100),(20,200),(30,300),(40,400),(50,500)");
-		s.executeUpdate("insert into t2 values (1),(2),(3),(4),(5)");
-		s.executeUpdate("insert into t3 values (4),(5),(6),(7),(8)");		
-		s.executeUpdate("insert into t4 values (10,100),(20,200)");
 
 		/*
-		 * Positive testing of Statements
-		 *
 		 * Simple queries
 		 */		
 		ResultSet rs = s.executeQuery("select row_number() over (), t1.* from t1");
@@ -98,14 +142,32 @@ public void testBasicOperations()
 		expectedRows = new String[][]{{"1", "4"}, {"2", "5"}};
 		JDBC.assertFullResultSet(rs, expectedRows);
 
+		// DERBY-4069: ORDER BY should be applied at the cursor level, that is
+		// *after* a windowing clause in the. So, with the original ordering
+		// here, the ROW_NUMBER should come backwards:
+
 		/* Ordering */
 		rs = s.executeQuery("select row_number() over () as r, t1.* from t1 order by b desc");
-		expectedRows = new String[][]{{"1", "50", "500"}, {"2", "40", "400"}, {"3", "30", "300"}, {"4", "20", "200"}, {"5", "10", "100"}};
+
+		expectedRows = new String[][]{{"5", "50", "500"},
+									  {"4", "40", "400"},
+									  {"3", "30", "300"},
+									  {"2", "20", "200"},
+									  {"1", "10", "100"}};
 		JDBC.assertFullResultSet(rs, expectedRows);
 
+        // DERBY-4069: ORDER BY should be applied at the cursor level, that is
+        // *after* a windowing clause in the. So, with the original ordering
+        // here, the ROW_NUMBER should come backwards:
+
 		/* Ordering on a column dropped in projection */
 		rs = s.executeQuery("select row_number() over () as r, t1.a from t1 order by b desc");
-		expectedRows = new String[][]{{"1", "50"}, {"2", "40"}, {"3", "30"}, {"4", "20"}, {"5", "10"}};
+
+		expectedRows = new String[][]{{"5", "50"},
+									  {"4", "40"},
+									  {"3", "30"},
+									  {"2", "20"},
+									  {"1", "10"}};
 		JDBC.assertFullResultSet(rs, expectedRows);
 
 		/* Only expressions in RCL */
@@ -113,8 +175,10 @@ public void testBasicOperations()
 		expectedRows = new String[][]{{"1", "1", "20"}, {"2", "2","40"}, {"3", "3","60"}, {"4", "4", "80"}, {"5", "5", "100"}};
 		JDBC.assertFullResultSet(rs, expectedRows);
 		
+
+
 		/*
-		 * Subquerys 
+		 * Subqueries
 		 */ 
 			
 		/* This query returned no rows at one time */
@@ -232,7 +296,19 @@ public void testBasicOperations()
 		expectedRows = new String[][]{{"100", "20", "200"}, {"200", "40", "400"}};
 		JDBC.assertFullResultSet(rs, expectedRows);
 
-		/* Group by and having */
+		// Check that flattening does not happen when a window is used in a
+		// subquery
+
+		rs = s.executeQuery("select * from t5 o where o.a in " +
+							"(select x + row_number() over () from t2)");
+		expectedRows = new String[][]{{"2", "4"},
+									  {"4", "4"}};
+		JDBC.assertFullResultSet(rs, expectedRows);
+
+
+		/*
+		 * Group by and having
+		 */
 		rs = s.executeQuery("select r from (select a, row_number() over() as r, b from t1) x group by r");
 		expectedRows = new String[][]{{"1"}, {"2"}, {"3"}, {"4"}, {"5"}};
 		JDBC.assertFullResultSet(rs, expectedRows);
@@ -301,7 +377,9 @@ public void testBasicOperations()
 										{"5", "ABC"}};
 		JDBC.assertFullResultSet(rs, expectedRows);
 		
-		rs = s.executeQuery("select * from (select distinct row_number() over (), 'ABC' from t1) tmp");
+		rs = s.executeQuery(
+			"select * from (select distinct row_number() over (), " +
+			"                               'ABC' from t1) tmp");
 		expectedRows = new String[][]{{"1", "ABC"},
 										{"2", "ABC"},
 										{"3", "ABC"},
@@ -309,29 +387,212 @@ public void testBasicOperations()
 										{"5", "ABC"}};
 		JDBC.assertFullResultSet(rs, expectedRows);
 		
+        // Test explicitly declared window
+        rs = s.executeQuery(
+            "select * from (select distinct row_number() over w, 'ABC' " +
+                            "from t1 window w as ()) tmp");
+        JDBC.assertFullResultSet(rs, expectedRows);
+
+        // DERBY-3634 Cannot use row_number() in ORDER BY clause
+        rs = s.executeQuery(
+            "select row_number() over () r, a from t1 order by r desc");
+        expectedRows = new String[][]{{"5", "50"},
+                                      {"4", "40"},
+                                      {"3", "30"},
+                                      {"2", "20"},
+                                      {"1", "10"}};
+        JDBC.assertFullResultSet(rs, expectedRows);
+
+        rs = s.executeQuery(
+            "select a from t1 order by row_number() over () desc");
+        expectedRows = new String[][]{{"50"},
+                                      {"40"},
+                                      {"30"},
+                                      {"20"},
+                                      {"10"}};
+        JDBC.assertFullResultSet(rs, expectedRows);
+
+        // Another case mentioned in DERBY-3634
+        rs = s.executeQuery("select a, row_number() over () from t1 except " +
+                            "select a, row_number() over () from t1");
+        JDBC.assertEmpty(rs);
+
+        // And yet another case mentioned in DERBY-3634 This actually also
+        // tests that ROW_NUMBER in an ORDER BY does not get optimized away if
+        // there is a restriction, see SelectNode's call to
+        // orderByList.removeConstantColumns(wherePredicates).
+        rs = s.executeQuery("select abs(a), row_number() over () c " +
+                            "from t1 where a > 30 and a <= 50 " +
+                            "order by c desc");
+        expectedRows = new String[][]{{"50", "2"},
+                                      {"40", "1"}};
+        JDBC.assertFullResultSet(rs, expectedRows);
+
+
+        // DERBY-3635 Cannot build SELECT LIST expressions involving
+        // ROW_NUMBER()
+        rs = s.executeQuery("select row_number() over () + 10, a from t1 " +
+                            "order by row_number() over () desc");
+        expectedRows = new String[][]{{"15", "50"},
+                                      {"14", "40"},
+                                      {"13", "30"},
+                                      {"12", "20"},
+                                      {"11", "10"}};
+        JDBC.assertFullResultSet(rs, expectedRows);
+
+
+        // Check that a non-used window doesn't cause problems
+        rs = s.executeQuery("select a from t1 window r as () order by a desc");
+        expectedRows = new String[][]{{"50"},
+                                      {"40"},
+                                      {"30"},
+                                      {"20"},
+                                      {"10"}};
+        JDBC.assertFullResultSet(rs, expectedRows);
+
+        // Check that a row_number combined with group by works. Good to test
+        // this since windowing uses a similar rewrite mechanism to group by
+        // and could interfere (seen during development).
+        rs = s.executeQuery("select row_number() over r, b, sum(a) from t5 " +
+                            "group by b window r as ()");
+        expectedRows = new String[][]{{"1", "1", "1"},
+                                      {"2", "4", "9"},
+                                      {"3", "9", "5"}};
+        JDBC.assertFullResultSet(rs, expectedRows);
+
+        // Check that a row_number combined with group by works. Good to test
+        // this since windowing uses a similar rewrite mechanism to group by
+        // and could interfere (seen during development).
+        rs = s.executeQuery("select row_number() over r, b, sum(a) from t5 " +
+                            "group by b window r as ()");
+        expectedRows = new String[][]{{"1", "1", "1"},
+                                      {"2", "4", "9"},
+                                      {"3", "9", "5"}};
+        JDBC.assertFullResultSet(rs, expectedRows);
+
+        rs = s.executeQuery("select b, sum(a) from t5 " +
+                            "group by b window r as ()");
+        expectedRows = new String[][]{{"1", "1"},
+                                      {"4", "9"},
+                                      {"9", "5"}};
+        JDBC.assertFullResultSet(rs, expectedRows);
+
+        // Check that row_number inside EXISTS works.
+        rs = s.executeQuery("SELECT * FROM t2 WHERE EXISTS " +
+                            "(SELECT ROW_NUMBER() OVER () FROM t5)");
+        expectedRows = new String[][]{{"1"},{"2"},{"3"},{"4"},{"5"}};
+        JDBC.assertFullResultSet(rs, expectedRows);
+
 		/*
 		 * Negative testing of Statements
 		 */
 
 		// Missing required OVER () 
-		assertStatementError("42X01", s, "select row_number() as r, * from t1 where t1.a > 2");
+        assertStatementError(
+            LANG_SYNTAX_ERROR, s,
+			"select row_number() as r, * from t1 where t1.a > 2");
 
 		// Illegal where clause, r not a named column of t1.        
-		assertStatementError("42X04", s, "select row_number() over () as r, a from t1 where r < 3");
+        assertStatementError(
+            LANG_COLUMN_NOT_FOUND, s,
+            "select row_number() over () as r, a from t1 where r < 3");
 
-		// Illegal use of asterix with another column identifier.        
-		assertStatementError("42X01", s, "select row_number() over () as r, * from t1 where t1.a > 2");
+        // Illegal use of asterisk with another column identifier.
+        assertStatementError(
+            LANG_SYNTAX_ERROR, s,
+            "select row_number() over () as r, * from t1 where t1.a > 2");
 
-		/*
-		 * Clean up the tables used.
-		 */
-		s.executeUpdate("drop table t1");
-		s.executeUpdate("drop table t2");
-		s.executeUpdate("drop table t3");
+        // Order by in window specification
+        assertStatementError(
+            NOT_IMPLEMENTED,
+            s,
+            "select row_number() over (order by i) as r from t1");
+
+        // Other window function than row_number:
+        assertStatementError(NOT_IMPLEMENTED,
+                             s,
+                             "select max(i) over () from t1");
+
+        // Illegal context: WHERE, cf. SQL 2003, section 7.8 SR 2
+        assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
+                             s,
+                             "select * from t4 where row_number() over () > 3");
+
+        // But nested inside a subquery it should work:
+        rs = s.executeQuery("select * from t2 where x in " +
+                            "     (select row_number() over () from t4)");
+        expectedRows = new String[][]{{"1"},{"2"}};
+        JDBC.assertFullResultSet(rs, expectedRows);
+
+        // Illegal context: GROUP BY
+        assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
+                             s,
+                             "select * from t4 group by row_number() over ()");
+
+        // But nested inside a subquery it should work.
+        // Fails: DERBY-4403, enable this test when that issue is fixed.
+        // rs = s.executeQuery("select * from t4 group by a + " +
+        //             "(select row_number() over () from t4 where a=10)");
+        // JDBC.assertEmpty(rs);
+
+
+        // Illegal context: HAVING, cf. SQL 2003, section 7.10 SR 4
+        assertStatementError(
+			LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
+			s,
+			"select * from t4 group by a having b = row_number() over ()");
+
+        // But nested inside a subquery it should work:
+        rs = s.executeQuery(
+            "select sum(a) from t5 group by b " +
+            "   having b = (select row_number() over () + 3 " +
+            "                   from t5 where a=1)");
+        expectedRows = new String[][]{{"9"}};
+
+
+        // Illegal context: VALUES
+        assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
+                             s,
+                             "values row_number() over ()");
+
+        // But nested inside a subquery it should work:
+        rs = s.executeQuery("values 3 + " +
+                            "(select row_number() over () from t2 where x=1)");
+        expectedRows = new String[][]{{"4"}};
+        JDBC.assertFullResultSet(rs, expectedRows);
+
+        // Illegal context: Aggregate function, cf. SQL 2003, section 10.9 SR 7
+        // a)
+        assertStatementError(LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
+                             s,
+                             "select sum(row_number() over ()) from t4");
+
+        // Illegal context: JOIN ON clause, cf. SQL 2003, section 7.7 SR 5
+        assertStatementError(
+            LANG_WINDOW_FUNCTION_CONTEXT_ERROR,
+            s,
+            "select * from t4 t_1 join t4 t_2 on " +
+            "                     t_1.a = row_number() over () + t_2.a");
+    }
+
+
+    public void testMetaData()
+        throws SQLException {
 
-		s.close();
+        if (JDBC.vmSupportsJSR169()) {
+            // does not support metadata
+            return;
 	}
 
+        Statement s = createStatement();
+        ResultSet rs = s.executeQuery(
+            "select row_number() over () from sys.systables");
+        ResultSetMetaData rsmd = rs.getMetaData();
+
+        assertEquals(ResultSetMetaData.columnNoNulls, rsmd.isNullable(1));
+    }
+
+
     private String makeString(int len)
     {
         StringBuffer buf = new StringBuffer(len);
@@ -679,7 +940,7 @@ public void testGroupByWithAndWithoutRollup()
                 {"DEF","2","350","1","20"},
                 {null,"8","1075","4","215"},
             });
-        // Show a usage of disinct shipping aggregate, similar to the
+        // Show a usage of distinct shipping aggregate, similar to the
         // distinct count aggregate:
         JDBC.assertUnorderedResultSet( s.executeQuery(
             "select o.Customer, count(*) as items_per_customer, " +
@@ -883,8 +1144,4 @@ public void testGroupByWithAndWithoutRollup()
 
         s.close();
     }
-
-	public static Test suite() {
-		return TestConfiguration.defaultSuite(OLAPTest.class);
-	}
 }
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java
index b0cbba50..d7d1dbe5 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java
@@ -202,6 +202,7 @@ public static Test suite() {
         suite.addTest(UserLobTest.suite());
         suite.addTest(OffsetFetchNextTest.suite());
         suite.addTest(SequenceTest.suite());
+        suite.addTest(OLAPTest.suite());
 
         return suite;
 	}
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/util/SQLStateConstants.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/util/SQLStateConstants.java
index 178eb1f3..e62e16d2 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/util/SQLStateConstants.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/util/SQLStateConstants.java
@@ -101,8 +101,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more
         = "22006";
     public static final String DATA_EXCEPTION_INVALID_PARAMETER_VALUE 
         = "22023";
-    public static final String DATA_EXCEPTION_INVALID_PRECEDING_OR_FOLLOWING_SIZE_IN_WINDOW_FUNCTION 
-        = "22013";
+
+
+    // Derby uses 22013 for something else, cf. SQLState.LANG_SQRT_OF_NEG_NUMBER
+    // public static final String DATA_EXCEPTION_INVALID_PRECEDING_OR_FOLLOWING_SIZE_IN_WINDOW_FUNCTION
+    //    = "22013";
+
     public static final String DATA_EXCEPTION_INVALID_REGULAR_EXPRESSION 
         = "2201B";
     public static final String DATA_EXCEPTION_INVALID_REPEAT_ARGUMENT_IN_A_SAMPLE_CLAUSE 
