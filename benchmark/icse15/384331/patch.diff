diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Connection.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Connection.java
index 4335e517..0858021c 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Connection.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Connection.java
@@ -34,10 +34,15 @@
     public Agent agent_;
 
     public DatabaseMetaData databaseMetaData_;
-    // Since DERBY prepared statements must be re-prepared after a commit,
-    // then we must traverse this list after a commit and notify statements
-    // that they are now in an un-prepared state.
-    final java.util.LinkedList openStatements_ = new java.util.LinkedList();
+    // DERBY-210 -  WeakHashMap is used to store references to objects to avoid
+    // memory leaks. When there are no other references to the keys in a 
+    // WeakHashMap, they will get removed from the map and can thus get 
+    // garbage-collected. They do not have to wait till the Connection object 
+    // is collected.
+        
+    // In Connection.markStatementsClosed() method, this list is traversed to get a
+    // list of open statements, which are marked closed and removed from the list.
+    final java.util.WeakHashMap openStatements_ = new java.util.WeakHashMap();
 
     // Some statuses of DERBY objects may be invalid on server
     // after both commit and rollback. For example,
@@ -45,7 +50,7 @@
     //     after both commit and rollback
     // (2) result set will be unpositioned on server after both commit and rollback.
     // If they depend on both commit and rollback, they need to get on CommitAndRollbackListeners_.
-    final java.util.LinkedList CommitAndRollbackListeners_ = new java.util.LinkedList();
+    final java.util.WeakHashMap CommitAndRollbackListeners_ = new java.util.WeakHashMap();
     private SqlWarning warnings_ = null;
 
     // ------------------------properties set for life of connection--------------
@@ -426,7 +431,7 @@ synchronized PreparedStatement prepareDynamicCatalogQuery(String sql) throws Sql
         PreparedStatement ps = newPreparedStatement_(sql, java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY, holdability(), java.sql.Statement.NO_GENERATED_KEYS, null);
         ps.isCatalogQuery_ = true;
         ps.prepare();
-        openStatements_.add(ps);
+        openStatements_.put(ps, null);
         return ps;
     }
 
@@ -825,7 +830,8 @@ private void markClosedForReuse() {
     }
 
     private void markStatementsClosed() {
-        for (java.util.ListIterator i = openStatements_.listIterator(); i.hasNext();) {
+    	java.util.Set keySet = openStatements_.keySet();
+        for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
             Statement stmt = (Statement) i.next();
             stmt.markClosed();
             i.remove();
@@ -833,13 +839,15 @@ private void markStatementsClosed() {
     }
 
     private void writeCloseStatements() throws SqlException {
-        for (java.util.ListIterator i = openStatements_.listIterator(); i.hasNext();) {
+    	java.util.Set keySet = openStatements_.keySet();
+        for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
             ((Statement) i.next()).writeClose(false);  // false means don't permit auto-commits
         }
     }
 
     private void readCloseStatements() throws SqlException {
-        for (java.util.ListIterator i = openStatements_.listIterator(); i.hasNext();) {
+    	java.util.Set keySet = openStatements_.keySet();
+        for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
             ((Statement) i.next()).readClose(false);  // false means don't permit auto-commits
         }
     }
@@ -1462,7 +1470,7 @@ private Statement createStatementX(int resultSetType,
         }
         Statement s = newStatement_(resultSetType, resultSetConcurrency, resultSetHoldability);
         s.cursorAttributesToSendOnPrepare_ = s.cacheCursorAttributesToSendOnPrepare();
-        openStatements_.add(s);
+        openStatements_.put(s, null);
         return s;
     }
 
@@ -1515,7 +1523,7 @@ PreparedStatement prepareStatementX(String sql,
         PreparedStatement ps = newPreparedStatement_(sql, resultSetType, resultSetConcurrency, resultSetHoldability, autoGeneratedKeys, columnNames);
         ps.cursorAttributesToSendOnPrepare_ = ps.cacheCursorAttributesToSendOnPrepare();
         ps.prepare();
-        openStatements_.add(ps);
+        openStatements_.put(ps,null);
         return ps;
     }
 
@@ -1560,7 +1568,7 @@ private CallableStatement prepareCallX(String sql,
         CallableStatement cs = newCallableStatement_(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
         cs.cursorAttributesToSendOnPrepare_ = cs.cacheCursorAttributesToSendOnPrepare();
         cs.prepare();
-        openStatements_.add(cs);
+        openStatements_.put(cs,null);
         return cs;
     }
 
@@ -1721,7 +1729,8 @@ public void completeConnect() throws SqlException {
     public abstract void readLocalCommit_() throws SqlException;
 
     public void completeLocalCommit() {
-        for (java.util.Iterator i = CommitAndRollbackListeners_.iterator(); i.hasNext();) {
+    	java.util.Set keySet = CommitAndRollbackListeners_.keySet();
+        for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
             UnitOfWorkListener listener = (UnitOfWorkListener) i.next();
             listener.completeLocalCommit(i);
         }
@@ -1736,7 +1745,8 @@ public void completeLocalCommit() {
     // This is a client-side only operation.
     // This method will only throw an exception on bug check.
     public void completeLocalRollback() {
-        for (java.util.Iterator i = CommitAndRollbackListeners_.iterator(); i.hasNext();) {
+    	java.util.Set keySet = CommitAndRollbackListeners_.keySet();
+    	for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
             UnitOfWorkListener listener = (UnitOfWorkListener) i.next();
             listener.completeLocalRollback(i);
         }
@@ -1838,7 +1848,8 @@ protected void completeReset(boolean isDeferredReset, boolean recomputeFromDataS
         // Notice that these physical statements may not belong to this logical connection.
         // Iterate through the physical statements and re-enable them for reuse.
 
-        for (java.util.Iterator i = openStatements_.iterator(); i.hasNext();) {
+        java.util.Set keySet = openStatements_.keySet();
+        for (java.util.Iterator i = keySet.iterator(); i.hasNext();) {
             Object o = i.next();
             ((Statement) o).reset(recomputeFromDataSource);
 
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Lob.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Lob.java
index e980126d..74f4785a 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Lob.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Lob.java
@@ -66,7 +66,7 @@ public long sqlLength() throws SqlException {
     //-----------------------event callback methods-------------------------------
 
     public void listenToUnitOfWork() {
-        agent_.connection_.CommitAndRollbackListeners_.add(this);
+        agent_.connection_.CommitAndRollbackListeners_.put(this,null);
     }
 
     public void completeLocalCommit(java.util.Iterator listenerIterator) {
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/PreparedStatement.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/PreparedStatement.java
index c877557a..b244c20e 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/PreparedStatement.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/PreparedStatement.java
@@ -1887,7 +1887,7 @@ void flowExecute(int executeType) throws SqlException {
     public void listenToUnitOfWork() {
         if (!listenToUnitOfWork_) {
             listenToUnitOfWork_ = true;
-            connection_.CommitAndRollbackListeners_.add(this);
+            connection_.CommitAndRollbackListeners_.put(this,null);
         }
     }
 
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/ResultSet.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/ResultSet.java
index ce0eca4b..93cefc14 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/ResultSet.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/ResultSet.java
@@ -4157,7 +4157,7 @@ public void readDeleteRow() throws DisconnectException, SqlException {
     public void listenToUnitOfWork() {
         if (!listenToUnitOfWork_) {
             listenToUnitOfWork_ = true;
-            connection_.CommitAndRollbackListeners_.add(this);
+            connection_.CommitAndRollbackListeners_.put(this, null);
         }
     }
 
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Statement.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Statement.java
index 5188f676..7bc2453f 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Statement.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Statement.java
@@ -2320,7 +2320,11 @@ public ConnectionCallbackInterface getConnectionCallbackInterface() {
         return connection_;
     }
 
-    // Only called on positioned upate statements
+    // This was being called only on positioned update statements. When working 
+    // on DERBY-210, it was found that result sets of all statements (not just
+    // positioned update statements) get added to the table. So, this is called
+    // for all statements. Otherwise, this will cause memory leaks when statements
+    // are not explicitly closed in the application. 
     void resetCursorNameAndRemoveFromWhereCurrentOfMappings() {
         // Remove client/server cursorName -> ResultSet mapping from the hashtable.
         // If Statement.close() is called before ResultSet.close(), then statement_.section is null.
@@ -2328,6 +2332,11 @@ void resetCursorNameAndRemoveFromWhereCurrentOfMappings() {
             agent_.sectionManager_.removeCursorNameToResultSetMapping(cursorName_,
                     section_.getServerCursorNameForPositionedUpdate());
 
+            // remove resultset mapping for other cursors (other than positioned
+            // update statements) - DERBY-210
+            agent_.sectionManager_.removeCursorNameToResultSetMapping(cursorName_,
+                    section_.getServerCursorName());
+
             // Remove client and server cursorName -> QuerySection mapping from the hashtable
             // if one exists
             agent_.sectionManager_.removeCursorNameToQuerySectionMapping(cursorName_,
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/derbyStress.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/derbyStress.java
index 53b5d220..f956200a 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/derbyStress.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/derbyStress.java
@@ -88,9 +88,6 @@ private static void createTables(Connection conn, int numRows) throws SQLExcepti
 	// user (DERBY-210)
 	private static void prepStmtTest(Connection conn, int numRows, int numPreparedStmts) throws Exception
 	{
-		// Don't run under DerbyNetClient until DERBY-210 is fixed
-		if (TestUtil.isDerbyNetClientFramework()) return;
-
 		PreparedStatement ps = null;
 		ResultSet rs = null;
 		conn.setAutoCommit(false);
