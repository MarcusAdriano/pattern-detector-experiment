diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/ColumnMetaData.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/ColumnMetaData.java
index ba7f18f5..52db30b6 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/ColumnMetaData.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/ColumnMetaData.java
@@ -67,6 +67,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
     public String[] sqlLabel_;  // column label
     public short[] sqlUnnamed_;
     public String[] sqlComment_;
+    public String[] sqlUDTname_;
+    public String[] sqlUDTclassName_;
 
     //Data from SQLDXGRP
     public short[] sqlxKeymem_;
@@ -148,6 +150,9 @@ public void initializeCache(int upperBound) {
 
         sqlName_ = new String[upperBound];
         sqlxParmmode_ = new short[upperBound];
+
+        sqlUDTname_ = new String[upperBound];
+        sqlUDTclassName_ = new String[upperBound];
     }
 
     protected void finalize() throws java.lang.Throwable {
@@ -312,6 +317,8 @@ public int getColumnDisplaySize(int column) throws SQLException {
                 return 8;
             case Types.TIMESTAMP:
                 return 26;
+            case Types.JAVA_OBJECT:
+                return JDBC30Translation.DEFAULT_COLUMN_DISPLAY_SIZE;
             case Types.BINARY:
             case Types.VARBINARY:
             case Types.LONGVARBINARY:
@@ -442,6 +449,8 @@ public int getPrecision(int column) throws SQLException {
                 return 8;
             case Types.TIMESTAMP:
                 return 26;
+            case Types.JAVA_OBJECT:
+                return JDBC30Translation.UNKNOWN_PRECISION;
             default:
                 throw new SqlException(logWriter_, 
                 		new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
@@ -603,6 +612,9 @@ public String getColumnTypeName(int column) throws SQLException {
             case DRDAConstants.DB2_SQLTYPE_NUMERIC:
             case DRDAConstants.DB2_SQLTYPE_NNUMERIC:
                 return "NUMERIC";
+            case DRDAConstants.DB2_SQLTYPE_FAKE_UDT:
+            case DRDAConstants.DB2_SQLTYPE_FAKE_NUDT:
+                return sqlUDTname_[ column - 1 ];
             default:
                 throw new SqlException(logWriter_, 
                 		new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
@@ -715,6 +727,8 @@ public String getColumnClassName(int column) throws SQLException {
                 return "java.sql.Clob";
             case java.sql.Types.REF:
                 return "java.sql.Ref";
+            case java.sql.Types.JAVA_OBJECT:
+                return sqlUDTclassName_[ column - 1 ];
             default:
                 throw new SqlException(logWriter_, 
                 		new ClientMessageId (SQLState.UNSUPPORTED_TYPE));
@@ -833,6 +847,8 @@ private int getInternalTypeForGuessedOrRegisteredJdbcType(int guessedOrRegistere
             return Types.BLOB;
         case java.sql.Types.CLOB:
             return Types.CLOB;
+        case java.sql.Types.JAVA_OBJECT:
+            return Types.JAVA_OBJECT;
         case java.sql.Types.NULL:
         case java.sql.Types.OTHER:
             throw new SqlException(logWriter_, 
@@ -863,6 +879,8 @@ private void nullDataForGC() {
         sqlLabel_ = null;
         sqlUnnamed_ = null;
         sqlComment_ = null;
+        sqlUDTname_ = null;
+        sqlUDTclassName_ = null;
         sqlxKeymem_ = null;
         sqlxGenerated_ = null;
         sqlxParmmode_ = null;
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Cursor.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Cursor.java
index 5b2661ee..201bb842 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Cursor.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Cursor.java
@@ -25,6 +25,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import java.sql.SQLException;
 import java.io.BufferedInputStream;
 import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.ObjectInputStream;
 import java.io.UnsupportedEncodingException;
 
 // When we calculate column offsets make sure we calculate the correct offsets for double byte charactr5er data
@@ -649,6 +651,34 @@ private final String getStringFromTIMESTAMP(int column) throws SqlException {
         return bytes;
     }
 
+    // Deserialize a UDT from a database java.sql.Types.JAVA_OBJECT field.
+    // This is used for user defined types.
+    private final Object get_UDT(int column) throws SqlException {
+        byte[] bytes;
+        int columnLength = 0;
+        columnLength = (maxFieldSize_ == 0) ? columnDataComputedLength_[column - 1] - 2 :
+                java.lang.Math.min(maxFieldSize_, columnDataComputedLength_[column - 1] - 2);
+        bytes = new byte[columnLength];
+        System.arraycopy(dataBuffer_, columnDataPosition_[column - 1] + 2, bytes, 0, bytes.length);
+
+        try {
+            ByteArrayInputStream bais = new ByteArrayInputStream( bytes );
+            ObjectInputStream ois = new ObjectInputStream( bais );
+
+            return ois.readObject();
+        }
+        catch (Exception e)
+        {
+            throw new SqlException
+                (
+                 agent_.logWriter_, 
+                 new ClientMessageId (SQLState.NET_MARSHALLING_UDT_ERROR),
+                 e.getMessage(),
+                 e
+                 );
+        }
+    }
+
     /**
      * Instantiate an instance of Calendar that can be re-used for getting
      * Time, Timestamp, and Date values from this cursor.  Assumption is
@@ -1030,6 +1060,10 @@ final String getString(int column) throws SqlException {
                         agent_.crossConverters_.getStringFromBytes(get_VARCHAR_FOR_BIT_DATA(column));
                 return (maxFieldSize_ == 0) ? tempString :
                         tempString.substring(0, java.lang.Math.min(maxFieldSize_, tempString.length()));
+            case java.sql.Types.JAVA_OBJECT:
+                Object obj = get_UDT( column );
+                if ( obj == null ) { return null; }
+                else { return obj.toString(); }
             case java.sql.Types.BLOB:
                 Blob b = getBlobColumn_(column, agent_, false);
                 tempString = agent_.crossConverters_.
@@ -1297,6 +1331,8 @@ public final Object getObject(int column) throws SqlException {
         case java.sql.Types.VARBINARY:
         case java.sql.Types.LONGVARBINARY:
             return get_VARCHAR_FOR_BIT_DATA(column);
+        case java.sql.Types.JAVA_OBJECT:
+            return get_UDT( column );
         case java.sql.Types.BLOB:
             return getBlobColumn_(column, agent_, true);
         case java.sql.Types.CLOB:
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/PreparedStatement.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/PreparedStatement.java
index 8a15ab3d..4d024937 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/PreparedStatement.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/PreparedStatement.java
@@ -1420,7 +1420,14 @@ public void setObject(int parameterIndex, Object x) throws SQLException {
                 if (agent_.loggingEnabled()) {
                     agent_.logWriter_.traceEntry(this, "setObject", parameterIndex, x);
                 }
-                if (x instanceof String) {
+
+                int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
+
+                if ( paramType == java.sql.Types.JAVA_OBJECT )
+                {
+                    setUDTX( parameterIndex, x );
+                }
+                else if (x instanceof String) {
                     setString(parameterIndex, (String) x);
                 } else if (x instanceof Integer) {
                     setInt(parameterIndex, ((Integer) x).intValue());
@@ -1468,6 +1475,53 @@ public void setObject(int parameterIndex, Object x) throws SQLException {
         }            
     }
 
+    /**
+     * Set a UDT parameter to an object value.
+     */
+    private void setUDTX(int parameterIndex, Object x) throws SqlException, SQLException
+    {
+        int paramType = getColumnMetaDataX().getColumnType(parameterIndex);
+        int expectedType = java.sql.Types.JAVA_OBJECT;
+        
+        if ( !( paramType == expectedType ) )
+        {
+            PossibleTypes.throw22005Exception
+                (agent_.logWriter_, expectedType, paramType );
+        }
+        
+        parameterMetaData_.clientParamtertype_[parameterIndex - 1] = expectedType;
+        if (x == null) {
+            setNullX(parameterIndex, expectedType );
+            return;
+        }
+
+        //
+        // Make sure that we are setting the parameter to an instance of the UDT.
+        //
+        
+        Throwable problem = null;
+        String sourceClassName = x.getClass().getName();
+        String targetClassName = getColumnMetaDataX().getColumnClassName(parameterIndex);
+
+        try {
+            Class targetClass = Class.forName( targetClassName );
+            if ( targetClass.isInstance( x ) )
+            {
+                setInput(parameterIndex, x);
+                return;
+            }
+        }
+        catch (ClassNotFoundException e) { problem = e; }
+
+        throw new SqlException
+            (
+             agent_.logWriter_,
+             new ClientMessageId( SQLState.NET_UDT_COERCION_ERROR ),
+             new Object[] { sourceClassName, targetClassName },
+             problem
+             );
+    }
+
     public void setObject(int parameterIndex, Object x, int targetJdbcType) throws SQLException {
         try
         {
@@ -3069,23 +3123,6 @@ boolean checkType(int type){
             
         }
         
-        /*
-        static SqlException throwLangDataTypeSetException( LogWriter logWriter, 
-                                                           int valType,
-                                                           int paramType)
-    
-            throws SqlException{
-            
-            throw new SqlException( logWriter,
-                                    new ClientMessageId(SQLState.LANG_DATA_TYPE_SET_MISMATCH) ,
-                                    new Object[]{ 
-                                        Types.getTypeString(valType),
-                                        Types.getTypeString(paramType) 
-                                    },
-                                    (Throwable) null);
-        }
-        */
-        
         static SqlException throw22005Exception( LogWriter logWriter, 
                                                  int valType,
                                                  int paramType)
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Types.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Types.java
index be78a8a2..d02a16ff 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Types.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Types.java
@@ -77,6 +77,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
     public final static int CLOB = java.sql.Types.CLOB;          // 2005;
 
+    public final static int JAVA_OBJECT = java.sql.Types.JAVA_OBJECT;          // 2000;
+
     // hide the default constructor
     private Types() {
    }
@@ -169,6 +171,8 @@ static public int mapDERBYTypeToDriverType(boolean isDescribed, int sqlType, lon
             return Types.CLOB;
         case DRDAConstants.DB2_SQLTYPE_BLOB:    // large object bytes
             return java.sql.Types.BLOB;
+        case DRDAConstants.DB2_SQLTYPE_FAKE_UDT:    // user defined types
+            return java.sql.Types.JAVA_OBJECT;
         default:
             return 0;
         }
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/net/DssConstants.java b/db/derby/code/trunk/java/client/org/apache/derby/client/net/DssConstants.java
index 75580aa1..a43d0b26 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/net/DssConstants.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/net/DssConstants.java
@@ -21,8 +21,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 package org.apache.derby.client.net;
 
+import org.apache.derby.iapi.reference.DRDAConstants;
+
 class DssConstants {
-    static final int MAX_DSS_LEN = 32767;
+    static final int MAX_DSS_LEN = DRDAConstants.DATA_STREAM_STRUCTURE_MAX_LENGTH;
 
     // Registered SNA GDS identifier indicating DDM data (xD0 for DDM data).
     static final int GDS_ID = 0xD0;
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetConnection.java b/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetConnection.java
index 9a528b62..08a7630d 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetConnection.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetConnection.java
@@ -1734,6 +1734,18 @@ protected final boolean supportsSessionDataCaching() {
         return metadata.serverSupportsSessionDataCaching();
     }
 
+    /**
+     * Check whether the server supports UDTs
+     * @return true if UDTs are supported
+     */
+    protected final boolean serverSupportsUDTs() {
+
+        NetDatabaseMetaData metadata =
+            (NetDatabaseMetaData) databaseMetaData_;
+
+        return metadata.serverSupportsUDTs();
+    }
+
     /**
      * Checks whether the server supports locators for large objects.
      *
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetDatabaseMetaData.java b/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetDatabaseMetaData.java
index 797ffd09..23659329 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetDatabaseMetaData.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetDatabaseMetaData.java
@@ -36,6 +36,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more
      */
     private boolean supportsSessionDataCaching_;
 
+    /** True if the server supports UDTs */
+    private boolean supportsUDTs_;
+    
     public NetDatabaseMetaData(NetAgent netAgent, NetConnection netConnection) {
         // Consider setting product level during parse
         super(netAgent, netConnection, new ProductLevel(netConnection.productID_,
@@ -94,6 +97,9 @@ protected void computeFeatureSet_() {
 
         supportsSessionDataCaching_ =
                 productLevel_.greaterThanOrEqualTo(10, 4, 0);
+
+        supportsUDTs_ =
+                productLevel_.greaterThanOrEqualTo(10, 6, 0);
     }
 
     /**
@@ -117,4 +123,12 @@ final boolean serverSupportsLayerBStreaming() {
     final boolean serverSupportsSessionDataCaching() {
         return supportsSessionDataCaching_;
     }
+
+    /**
+     * Check if server supports UDTs
+     * @return true if the server supports this
+     */
+    final boolean serverSupportsUDTs() {
+        return supportsSessionDataCaching_;
+    }
 }
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetStatementReply.java b/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetStatementReply.java
index c886f500..d6e64a15 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetStatementReply.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetStatementReply.java
@@ -2076,19 +2076,26 @@ private void parseSQLDAGRP(ColumnMetaData columnMetaData,
     // SQLUDTGRP : EARLY FDOCA GROUP
     // SQL User-Defined Data Group Description
     //
-    // FORMAT FOR SQLAM >= 7
-    //   SQLUDTXTYPE; PROTOCOL TYPE I4; ENVLID 0X02; Length Override 4
-    //   SQLUDTRDB; PROTOCOL TYPE VCS; ENVLID 0X32; Length Override 255
-    //   SQLUDTSCHEMA_m; PROTOCOL TYPE VCM; ENVLID 0X3E; Length Override 255
-    //   SQLUDTSCHEMA_s; PROTOCOL TYPE VCS; ENVLID 0X32; Length Override 255
-    //   SQLUDTNAME_m; PROTOCOL TYPE VCM; ENVLID 0X3E; Length Override 255
-    //   SQLUDTNAME_s; PROTOCOL TYPE VCS; ENVLID 0X32; Length Override 255
+    // For an explanation of the format, see the header comment on
+    // DRDAConnThread.writeSQLUDTGRP().
+    //
     private void parseSQLUDTGRP(ColumnMetaData columnMetaData,
-                                int columnNumber) throws DisconnectException {
-        if (readFastUnsignedByte() == CodePoint.NULLDATA) {
-            return;
+                                int columnNumber) throws DisconnectException
+    {
+        int jdbcType = columnMetaData.types_[columnNumber];
+
+        if ( !(jdbcType == Types.JAVA_OBJECT) || !netAgent_.netConnection_.serverSupportsUDTs() )
+        {
+            if (readFastUnsignedByte() == CodePoint.NULLDATA) { return; }
         }
+        else
+        {
+            String typeName = parseFastVCMorVCS();
+            String className = parseFastVCMorVCS();
 
+            columnMetaData.sqlUDTname_[columnNumber] = typeName;
+            columnMetaData.sqlUDTclassName_[columnNumber] = className;
+        }
     }
 
     // SQLDOPTGRP : EARLY FDOCA GROUP
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetStatementRequest.java b/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetStatementRequest.java
index a7902a31..b4c5ed0e 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetStatementRequest.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/net/NetStatementRequest.java
@@ -758,6 +758,9 @@ private void buildFDODTA(int numVars,
                                          i);
                         }
                         break;
+                    case DRDAConstants.DRDA_TYPE_NUDT:
+                        writeUDT( inputs[i] );
+                        break;
                     case DRDAConstants.DRDA_TYPE_NLOBCSBCS:
                     case DRDAConstants.DRDA_TYPE_NLOBCDBCS:
                         // check for a promoted Clob
@@ -1341,6 +1344,10 @@ private int calculateColumnsInSQLDTAGRPtriplet(int numVars) {
                         lidAndLengths[i][1] = buildPlaceholderLength(ba.length);
                     }
                     break;
+                case java.sql.Types.JAVA_OBJECT:
+                    lidAndLengths[i][0] = DRDAConstants.DRDA_TYPE_NUDT;
+                    lidAndLengths[i][1] = 32767;
+                    break;
                 case java.sql.Types.BLOB:
                     java.sql.Blob b = (java.sql.Blob) inputRow[i];
                     if (b == null) {
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/net/Request.java b/db/derby/code/trunk/java/client/org/apache/derby/client/net/Request.java
index 8bb24953..fdecb531 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/net/Request.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/net/Request.java
@@ -23,9 +23,13 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.client.am.DisconnectException;
 import org.apache.derby.client.am.ClientMessageId;
 import org.apache.derby.client.am.SqlException;
+import org.apache.derby.shared.common.io.DynamicByteArrayOutputStream;
 import org.apache.derby.shared.common.reference.SQLState;
+import org.apache.derby.shared.common.sanity.SanityManager;
+import org.apache.derby.iapi.reference.DRDAConstants;
 
 import java.io.BufferedInputStream;
+import java.io.ObjectOutputStream;
 import java.io.UnsupportedEncodingException;
 
 import java.io.IOException;
@@ -1604,10 +1608,63 @@ final void writeLDBytes(byte[] bytes) {
     // ldSize and bytes.length may not be the same.  this is true
     // when writing graphic ld strings.
     private final void writeLDBytesX(int ldSize, byte[] bytes) {
+        writeLDBytesXSubset( ldSize, bytes.length, bytes );
+    }
+
+    // private helper method for writing just a subset of a byte array
+    private final void writeLDBytesXSubset( int ldSize, int bytesToCopy, byte[] bytes )
+    {
         bytes_[offset_++] = (byte) ((ldSize >>> 8) & 0xff);
         bytes_[offset_++] = (byte) (ldSize & 0xff);
-        System.arraycopy(bytes, 0, bytes_, offset_, bytes.length);
-        offset_ += bytes.length;
+        System.arraycopy( bytes, 0, bytes_, offset_, bytesToCopy );
+        offset_ += bytesToCopy;
+    }
+
+    final void writeUDT( Object val ) throws SqlException
+    {
+        // should not be called if val is null
+        if ( val == null )
+        {
+            SanityManager.THROWASSERT( "UDT is null" );
+        }
+
+        byte[] buffer = null;
+        int length = 0;
+        
+        try
+        {
+            DynamicByteArrayOutputStream dbaos = new DynamicByteArrayOutputStream();
+            ObjectOutputStream oos = new ObjectOutputStream( dbaos );
+
+            oos.writeObject( val );
+
+            buffer = dbaos.getByteArray();
+            length = dbaos.getUsed();
+        }
+        catch (Exception e)
+        {
+            throw new SqlException
+                (
+                 netAgent_.logWriter_, 
+                 new ClientMessageId (SQLState.NET_MARSHALLING_UDT_ERROR),
+                 e.getMessage(),
+                 e
+                 );
+        }
+
+        if ( length > DRDAConstants.MAX_DRDA_UDT_SIZE )
+        {
+            throw new SqlException
+                (
+                 netAgent_.logWriter_, 
+                 new ClientMessageId(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE),
+                 Integer.toString( DRDAConstants.MAX_DRDA_UDT_SIZE ),
+                 val.getClass().getName()
+                 );
+        }
+
+        ensureLength( offset_ + length + 2 );
+        writeLDBytesXSubset( length, length, buffer );
     }
 
     // does it follows
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/net/Typdef.java b/db/derby/code/trunk/java/client/org/apache/derby/client/net/Typdef.java
index 44299d8a..3551323f 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/net/Typdef.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/net/Typdef.java
@@ -425,10 +425,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more
         new FdocaSimpleDataArray(0x4E, FdocaConstants.FDOCA_TYPE_VARCHAR, Cursor.VARIABLE_STRING, CCSIDMBC, 1, 1, 32767, TWOBYTELENGTH),
         /* 0x4F null  MBCS */
         new FdocaSimpleDataArray(0x4F, FdocaConstants.FDOCA_TYPE_NVARCHAR, Cursor.VARIABLE_STRING, CCSIDMBC, 1, 1, 32767, TWOBYTELENGTH),
-        /* 0x50 Empties */
-        null,
-        /* 0x51 Empties */
-        null,
+        /* 0x50 UDT */
+        new FdocaSimpleDataArray(0x50, FdocaConstants.FDOCA_TYPE_VARBYTES, Cursor.VARIABLE_BYTES, NOCCSID, 0, 1, 32767, TWOBYTELENGTH),
+        /* 0x51 null UDT */
+        new FdocaSimpleDataArray(0x51, FdocaConstants.FDOCA_TYPE_NVARBYTES, Cursor.VARIABLE_BYTES, NOCCSID, 0, 1, 32767, TWOBYTELENGTH),
         /* 0x52 Empties */
         null,
         /* 0x53 Empties */
@@ -765,8 +765,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
         java.sql.Types.VARCHAR, // 0x4D null SBCS
         java.sql.Types.VARCHAR, // 0x4E MBCS
         java.sql.Types.VARCHAR, // 0x4F null MBCS
-        0x00, // 0x50 Empties
-        0x00, // 0x51 Empties
+        java.sql.Types.JAVA_OBJECT, // 0x50 UDT
+        java.sql.Types.JAVA_OBJECT, // 0x51 null UDT
         0x00, // 0x52 Empties
         0x00, // 0x53 Empties
         0x00, // 0x54 Empties
diff --git a/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/AppRequester.java b/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/AppRequester.java
index 05d7a6b6..31022e43 100644
--- a/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/AppRequester.java
+++ b/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/AppRequester.java
@@ -298,4 +298,8 @@ protected  boolean isXARequester()
 	protected boolean supportsSessionDataCaching() {
 		return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 4, 0));
 	}
+
+	protected boolean supportsUDTs() {
+		return (clientType == DNC_CLIENT && greaterThanOrEqualTo(10, 6, 0));
+	}
 }
diff --git a/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/DDMWriter.java b/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/DDMWriter.java
index 0d607e64..83681de9 100644
--- a/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/DDMWriter.java
+++ b/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/DDMWriter.java
@@ -24,6 +24,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import java.io.BufferedOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.ObjectOutputStream;
 import java.io.OutputStream;
 import java.math.BigDecimal;
 import java.nio.ByteBuffer;
@@ -34,9 +35,11 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import java.sql.SQLException;
 import java.util.Arrays;
 
+import org.apache.derby.iapi.reference.DRDAConstants;
 import org.apache.derby.iapi.reference.Property;
 import org.apache.derby.iapi.services.property.PropertyUtil;
 import org.apache.derby.iapi.services.sanity.SanityManager;
+import org.apache.derby.iapi.services.io.DynamicByteArrayOutputStream;
 
 /**
 	The DDMWriter is used to write DRDA protocol.   The DRDA Protocol is
@@ -1090,6 +1093,51 @@ protected void writeLDString(String s) throws DRDAProtocolException
 		writeLDString(s,0);
 	}
 
+	/**
+	 * Write a value of a user defined type.
+	 *
+	 * @param val object to be written
+	 *
+	 * @exception DRDAProtocolException
+	 */
+	protected void writeUDT( Object val, int index ) throws DRDAProtocolException
+	{
+        // should not be called if val is null
+        if ( val == null )
+        {
+            SanityManager.THROWASSERT( "UDT is null" );
+        }
+
+        byte[] buffer = null;
+        int length = 0;
+
+        try {
+            DynamicByteArrayOutputStream dbaos = new DynamicByteArrayOutputStream();
+            ObjectOutputStream oos = new ObjectOutputStream( dbaos );
+
+            oos.writeObject( val );
+
+            buffer = dbaos.getByteArray();
+            length = dbaos.getUsed();
+            
+        } catch(IOException e)
+        {
+            agent.markCommunicationsFailure
+                ( e,"DDMWriter.writeUDT()", "", e.getMessage(), "" );
+        }
+
+        if ( length > DRDAConstants.MAX_DRDA_UDT_SIZE )
+        {
+            agent.markCommunicationsFailure
+                ( "DDMWriter.writeUDT()", "User defined type is longer than " + DRDAConstants.MAX_DRDA_UDT_SIZE + " bytes.", "", "" );
+        }
+        else
+        {
+            writeShort( length );
+            writeBytes( buffer, 0, length );
+        }
+	}
+
 	/**
 	 * Find the maximum number of bytes needed to represent the string in the
 	 * default encoding.
diff --git a/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/DRDAConnThread.java b/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/DRDAConnThread.java
index c48a5eaa..e55aa90c 100644
--- a/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/DRDAConnThread.java
+++ b/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/DRDAConnThread.java
@@ -23,6 +23,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.InputStream;
+import java.io.ObjectInputStream;
 import java.io.OutputStream;
 import java.io.InputStreamReader;
 import java.io.IOException;
@@ -4698,6 +4699,12 @@ private void readAndSetParams(int i,
 				ps.setBytes(i+1, paramVal);
 				break;
 			}
+			case DRDAConstants.DRDA_TYPE_NUDT:
+			{
+                Object paramVal = readUDT();
+				ps.setObject(i+1, paramVal);
+				break;
+			}
 			case DRDAConstants.DRDA_TYPE_NLOBBYTES:
 			case DRDAConstants.DRDA_TYPE_NLOBCMIXED:
 			case DRDAConstants.DRDA_TYPE_NLOBCSBCS:
@@ -4763,6 +4770,28 @@ private void readAndSetParams(int i,
 		}
 	}
 
+    /** Read a UDT from the stream */
+    private Object readUDT() throws DRDAProtocolException
+    {
+        int length = reader.readNetworkShort();	//protocol control data always follows big endian
+        if (SanityManager.DEBUG) { trace("===== udt param length is: " + length); }
+        byte[] bytes = reader.readBytes(length);
+        
+        try {
+            ByteArrayInputStream bais = new ByteArrayInputStream( bytes );
+            ObjectInputStream ois = new ObjectInputStream( bais );
+
+            return ois.readObject();
+        }
+        catch (Exception e)
+        {
+            markCommunicationsFailure
+                ( e,"DRDAConnThread.readUDT()", "", e.getMessage(), "*" );
+            return null;
+        }
+    }
+
+
 	private long readLobLength(int extLenIndicator) 
 		throws DRDAProtocolException
 	{
@@ -6597,7 +6626,7 @@ private void writeSQLDTAGRP(DRDAStatement stmt, ResultSetMetaData rsmeta,
 												 (pmeta.isNullable(i) == JDBC30Translation.PARAMETER_NULLABLE));
 			int colType = (hasRs ? rsmeta.getColumnType(i) : pmeta.getParameterType(i));
 			int[] outlen = {-1};
-			int drdaType = FdocaConstants.mapJdbcTypeToDrdaType(colType,nullable,outlen);
+			int drdaType = FdocaConstants.mapJdbcTypeToDrdaType( colType, nullable, appRequester, outlen );
 				
 
 			boolean isDecimal = ((drdaType | 1) == DRDAConstants.DRDA_TYPE_NDECIMAL);
@@ -7028,7 +7057,7 @@ private boolean writeFDODTA (DRDAStatement stmt)
 					
 					if (stmt.isOutputParam(i)) {
 						int[] outlen = new int[1];
-						drdaType = FdocaConstants.mapJdbcTypeToDrdaType(stmt.getOutputParamType(i),true,outlen);
+						drdaType = FdocaConstants.mapJdbcTypeToDrdaType( stmt.getOutputParamType(i), true, appRequester, outlen );
 						precision = stmt.getOutputParamPrecision(i);
 						scale = stmt.getOutputParamScale(i);
                                                 
@@ -7352,7 +7381,7 @@ private void writeSQLDAGRP(ResultSetMetaData rsmeta,
 			(pmeta.isNullable(jdbcElemNum) == JDBC30Translation.PARAMETER_NULLABLE);
 		
 		int sqlType = SQLTypes.mapJdbcTypeToDB2SqlType(elemType,
-													   nullable,
+													   nullable, appRequester,
 													   outlen);
 		
 		if (outlen[0] == -1) //some types not set
@@ -7461,13 +7490,68 @@ private void writeVCMorVCS(String s)
 	}
 
   
+	/**
+	 * Write SQLUDTGRP (SQL Descriptor User-Defined Type Group Descriptor)
+	 * 
+	 * This is the format from the DRDA spec, Volume 1, section 5.6.4.10.
+     * However, this format is not rich enough to carry the information needed
+     * by JDBC. This format does not have a subtype code for JAVA_OBJECT and
+     * this format does not convey the Java class name needed
+     * by ResultSetMetaData.getColumnClassName().
+	 *
+	 *   SQLUDXTYPE; DRDA TYPE I4; ENVLID 0x02; Length Override 4
+     *                        Constants which map to java.sql.Types constants DISTINCT, STRUCT, and REF.
+     *                        But DRDA does not define a constant which maps to java.sql.Types.JAVA_OBJECT.
+	 *   SQLUDTRDB; DRDA TYPE VCS; ENVLID 0x32; Length Override 255
+     *                       Database name.
+	 *   SQLUDTSCHEMA_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255
+	 *   SQLUDTSCHEMA_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255
+     *                         Schema name. One of the above.
+	 *   SQLUDTNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255
+	 *   SQLUDTNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255
+     *                         Unqualified UDT name. One of the above.
+	 *
+	 * Instead, we use the following format and only for communication between
+     * Derby servers and Derby clients which are both at version 10.6 or higher.
+     * For all other client/server combinations, we send null.
+	 *
+	 *   SQLUDTNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override 255
+	 *   SQLUDTNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override 255
+     *                         Fully qualified UDT name. One of the above.
+	 *   SQLUDTCLASSNAME_m; DRDA TYPE VCM; ENVLID 0x3E; Length Override FdocaConstants.LONGVARCHAR_MAX_LEN
+	 *   SQLUDTCLASSNAME_s; DRDA TYPE VCS; ENVLID 0x32; Length Override FdocaConstants.LONGVARCHAR_MAX_LEN
+     *                         Name of the Java class bound to the UDT. One of the above.
+	 *
+	 * @param rsmeta	resultset meta data
+	 * @param pmeta		parameter meta data
+	 * @param elemNum	column number we are returning (in case of result set), or,
+	 *					parameter number (in case of parameter)
+	 * @param rtnOutput	whether this is for a result set	
+	 *
+	 * @throws DRDAProtocolException
+     * @throws SQLException
+	 */
 	private void writeSQLUDTGRP(ResultSetMetaData rsmeta,
 								ParameterMetaData pmeta,
 								int jdbcElemNum, boolean rtnOutput)
 		throws DRDAProtocolException,SQLException
 	{
+        int jdbcType = rtnOutput ?
+            rsmeta.getColumnType( jdbcElemNum) : pmeta.getParameterType( jdbcElemNum );
+
+        if ( !(jdbcType == Types.JAVA_OBJECT) || !appRequester.supportsUDTs() )
+        {
 		writer.writeByte(CodePoint.NULLDATA);
+            return;
+        }
 
+		String typeName = rtnOutput ?
+            rsmeta.getColumnTypeName( jdbcElemNum ) : pmeta.getParameterTypeName( jdbcElemNum );
+        String className = rtnOutput ?
+            rsmeta.getColumnClassName( jdbcElemNum ) : pmeta.getParameterClassName( jdbcElemNum );
+        
+		writeVCMorVCS( typeName );
+		writeVCMorVCS( className );
 	}
 
 	private void writeSQLDOPTGRP(ResultSetMetaData rsmeta,
@@ -7674,6 +7758,9 @@ else if (tsLen > 26)
 				case DRDAConstants.DRDA_TYPE_NCLOBLOC:
 					writer.writeInt(((EngineLOB)val).getLocator());
 					break;
+				case DRDAConstants.DRDA_TYPE_NUDT:
+					writer.writeUDT( val, index );
+					break;
 				default:
 					if (SanityManager.DEBUG) 
 						trace("ndrdaType is: "+ndrdaType);
diff --git a/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/FdocaConstants.java b/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/FdocaConstants.java
index d6644bf1..a9a0c07d 100644
--- a/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/FdocaConstants.java
+++ b/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/FdocaConstants.java
@@ -129,10 +129,11 @@ protected static boolean isNullable(int fdocaType)
 	 * Map jdbctype to fdoca drda type
 	 * @param jdbcType - Jdbc type for mappingy
 	 * @param nullable - true if type is nullable
+	 * @param appRequester - state variable for the connection
 	 * @param outlen - output parameter with length of type.
 	 * @return standard drdaTypeLength. -1 if we don't know.
 	 **/
-	protected static int mapJdbcTypeToDrdaType(int jdbcType, boolean nullable,
+	protected static int mapJdbcTypeToDrdaType(int jdbcType, boolean nullable, AppRequester appRequester,
 											   int[] outlen)
 		throws SQLException
 	{
@@ -195,8 +196,18 @@ protected static int mapJdbcTypeToDrdaType(int jdbcType, boolean nullable,
 				// we will just convert a java object to a string
 				// since jcc doesn't support it.
 			case java.sql.Types.JAVA_OBJECT:
+                //boolean b = false;
+                //if ( b )
+                if ( appRequester.supportsUDTs() )
+                {
+                    drdaType = DRDAConstants.DRDA_TYPE_NUDT;
+                    outlen[0] = -1;
+                }
+                else
+                {
 				drdaType = DRDAConstants.DRDA_TYPE_NLONG;
 				outlen[0] = LONGVARCHAR_MAX_LEN;
+                }
 				break;
 			case java.sql.Types.LONGVARCHAR:
 					drdaType = DRDAConstants.DRDA_TYPE_NLONG;
diff --git a/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/SQLTypes.java b/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/SQLTypes.java
index 9bb422b2..f033712b 100644
--- a/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/SQLTypes.java
+++ b/db/derby/code/trunk/java/drda/org/apache/derby/impl/drda/SQLTypes.java
@@ -122,6 +122,7 @@ else if (length == 4)
  /**  Map JDBC Type to DB2 SqlType
   * @param jdbctype   JDBC Type from java.sql.Types
   * @param nullable   true if this is a nullable type
+	 * @param appRequester - state variable for the connection
   * @param outlen     output parameter with type length
   *
   * @return Corresponding DB2 SQL Type (See DRDA Manual FD:OCA Meta 
@@ -130,7 +131,7 @@ else if (length == 4)
   * @exception SQLException thrown for unrecognized SQLType
   */
 
- static protected int mapJdbcTypeToDB2SqlType (int jdbctype, boolean nullable,
+    static protected int mapJdbcTypeToDB2SqlType (int jdbctype, boolean nullable, AppRequester appRequester,
 											   int[] outlen)
 	 throws SQLException
   {
@@ -140,7 +141,7 @@ static protected int mapJdbcTypeToDB2SqlType (int jdbctype, boolean nullable,
 		  nullAddVal =1; 
 	  
 	  // Call FdocaConstants just to get the length
-	  FdocaConstants.mapJdbcTypeToDrdaType(jdbctype,nullable,outlen);
+	  FdocaConstants.mapJdbcTypeToDrdaType(jdbctype,nullable,appRequester,outlen);
 
 	  switch(jdbctype)
 	  {
@@ -176,7 +177,14 @@ static protected int mapJdbcTypeToDB2SqlType (int jdbctype, boolean nullable,
 		  case java.sql.Types.LONGVARBINARY:
 			  return DRDAConstants.DB2_SQLTYPE_LONG + nullAddVal;
 		  case java.sql.Types.JAVA_OBJECT:
+              if ( appRequester.supportsUDTs() )
+              {
+                  return DRDAConstants.DB2_SQLTYPE_FAKE_UDT + nullAddVal;
+              }
+              else
+              {
 			  return DRDAConstants.DB2_SQLTYPE_LONG + nullAddVal;
+              }
 		  case java.sql.Types.BLOB:
 			  return DRDAConstants.DB2_SQLTYPE_BLOB + nullAddVal;
 		  case java.sql.Types.CLOB:
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/BaseTypeIdImpl.java b/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/BaseTypeIdImpl.java
index 1ae099b6..ef61ecc5 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/BaseTypeIdImpl.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/BaseTypeIdImpl.java
@@ -39,6 +39,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.reference.SQLState;
 
 import org.apache.derby.iapi.services.info.JVMInfo;
+import org.apache.derby.iapi.util.IdUtil;
 
 import java.sql.Types;
 
@@ -137,7 +138,7 @@ public BaseTypeIdImpl(int formatId)
     public String   getSQLTypeName()
     {
         if ( schemaName == null ) { return unqualifiedName; }
-        else { return doubleQuote( schemaName ) + '.' + doubleQuote( unqualifiedName ); }
+        else { return IdUtil.mkQualifiedName( schemaName, unqualifiedName ); }
     }
 
     /** Get the schema name of this type. Non-null only for UDTs */
@@ -183,7 +184,7 @@ public String   toParsableString(TypeDescriptor td)
     {
         String retval = getSQLTypeName();
 
-        switch (formatId)
+        switch (getTypeFormatId())
         {
           case StoredFormatIds.BIT_TYPE_ID_IMPL:
           case StoredFormatIds.VARBIT_TYPE_ID_IMPL:
@@ -255,7 +256,39 @@ public int hashCode()
      */
     public int getTypeFormatId()
     {
-        return formatId;
+        if ( formatId != 0 ) { return formatId; }
+        else
+        {
+            //
+            // If you serialize this class outside the formatable machinery, you
+            // will lose the format id. This can happen if you pass one of these
+            // objects across the network. Here we recover the format id.
+            //
+            if ( "BOOLEAN".equals( unqualifiedName ) ) { return StoredFormatIds.BOOLEAN_TYPE_ID_IMPL; }
+            else if ( "BIGINT".equals( unqualifiedName ) ) { return StoredFormatIds.LONGINT_TYPE_ID_IMPL; }
+            else if ( "INTEGER".equals( unqualifiedName ) ) { return StoredFormatIds.INT_TYPE_ID_IMPL; }
+            else if ( "SMALLINT".equals( unqualifiedName ) ) { return StoredFormatIds.SMALLINT_TYPE_ID_IMPL; }
+            else if ( "TINYINT".equals( unqualifiedName ) ) { return StoredFormatIds.TINYINT_TYPE_ID_IMPL; }
+            else if ( "LONGINT".equals( unqualifiedName ) ) { return StoredFormatIds.LONGINT_TYPE_ID_IMPL; }
+            else if ( "DECIMAL".equals( unqualifiedName ) ) { return StoredFormatIds.DECIMAL_TYPE_ID_IMPL; }
+            else if ( "NUMERIC".equals( unqualifiedName ) ) { return StoredFormatIds.DECIMAL_TYPE_ID_IMPL; }
+            else if ( "DOUBLE".equals( unqualifiedName ) ) { return StoredFormatIds.DOUBLE_TYPE_ID_IMPL; }
+            else if ( "REAL".equals( unqualifiedName ) ) { return StoredFormatIds.REAL_TYPE_ID_IMPL; }
+            else if ( "REF".equals( unqualifiedName ) ) { return StoredFormatIds.REF_TYPE_ID_IMPL; }
+            else if ( "CHAR".equals( unqualifiedName ) ) { return StoredFormatIds.CHAR_TYPE_ID_IMPL; }
+            else if ( "VARCHAR".equals( unqualifiedName ) ) { return StoredFormatIds.VARCHAR_TYPE_ID_IMPL; }
+            else if ( "LONG VARCHAR".equals( unqualifiedName ) ) { return StoredFormatIds.LONGVARCHAR_TYPE_ID_IMPL; }
+            else if ( "CLOB".equals( unqualifiedName ) ) { return StoredFormatIds.CLOB_TYPE_ID_IMPL; }
+            else if ( "CHAR FOR BIT DATA".equals( unqualifiedName ) ) { return StoredFormatIds.BIT_TYPE_ID_IMPL; }
+            else if ( "VARCHAR FOR BIT DATA".equals( unqualifiedName ) ) { return StoredFormatIds.VARBIT_TYPE_ID_IMPL; }
+            else if ( "LONG VARCHAR FOR BIT DATA".equals( unqualifiedName ) ) { return StoredFormatIds.LONGVARBIT_TYPE_ID_IMPL; }
+            else if ( "BLOB".equals( unqualifiedName ) ) { return StoredFormatIds.BLOB_TYPE_ID_IMPL; }
+            else if ( "DATE".equals( unqualifiedName ) ) { return StoredFormatIds.DATE_TYPE_ID_IMPL; }
+            else if ( "TIME".equals( unqualifiedName ) ) { return StoredFormatIds.TIME_TYPE_ID_IMPL; }
+            else if ( "TIMESTAMP".equals( unqualifiedName ) ) { return StoredFormatIds.TIMESTAMP_TYPE_ID_IMPL; }
+            else if ( "XML".equals( unqualifiedName ) ) { return StoredFormatIds.XML_TYPE_ID_IMPL; }
+            else { return 0; }
+        }
     }
 
     /**
@@ -310,7 +343,7 @@ public void writeExternal( ObjectOutput out )
 
     private void setTypeIdSpecificInstanceVariables()
     {
-        switch (formatId)
+        switch (getTypeFormatId())
         {
           case StoredFormatIds.BOOLEAN_TYPE_ID_IMPL:
               schemaName = null;
@@ -441,7 +474,7 @@ private void setTypeIdSpecificInstanceVariables()
           default:
                 if (SanityManager.DEBUG)
                 {
-                        SanityManager.THROWASSERT("Unexpected formatId " + formatId);
+                    SanityManager.THROWASSERT("Unexpected formatId " + getTypeFormatId());
                 }
                 break;
         }
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/DecimalTypeIdImpl.java b/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/DecimalTypeIdImpl.java
index 1652329a..a11d4dd4 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/DecimalTypeIdImpl.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/DecimalTypeIdImpl.java
@@ -28,6 +28,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 public class DecimalTypeIdImpl extends BaseTypeIdImpl
 {
+	/**
+	 * Public niladic constructor. Needed for Serializable interface to work.
+	 *
+	 */
+	public	DecimalTypeIdImpl() { super(); }
+
 	/* this class is needed because writeexternal for this class stores
 	   extra information; when the object is sent over the wire the niladic
 	   constructor is first called and then we call the readExternal method. 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/TypeDescriptorImpl.java b/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/TypeDescriptorImpl.java
index 15148e53..ce007766 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/TypeDescriptorImpl.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/TypeDescriptorImpl.java
@@ -30,6 +30,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.services.io.Formatable;
 import org.apache.derby.iapi.services.io.StoredFormatIds;
 import org.apache.derby.iapi.types.StringDataValue;
+import org.apache.derby.shared.common.reference.JDBC30Translation;
                              
 public class TypeDescriptorImpl implements TypeDescriptor, Formatable
 {
@@ -135,6 +136,9 @@ public TypeDescriptorImpl(
 		this.typeId = typeId;
 		this.isNullable = isNullable;
 		this.maximumWidth = maximumWidth;
+
+        this.scale = JDBC30Translation.UNKNOWN_SCALE;
+        this.precision = JDBC30Translation.UNKNOWN_PRECISION;
 	}
 
 	/**
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/DRDAConstants.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/DRDAConstants.java
index a53785b1..d4d7f38c 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/DRDAConstants.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/DRDAConstants.java
@@ -42,6 +42,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	public	static	final	String	DERBY_DRDA_SERVER_ID = "CSS";
 	public	static	final	String	DERBY_DRDA_CLIENT_ID = "DNC";
 	
+    // Maximum size of a DDM block
+    public static final int DATA_STREAM_STRUCTURE_MAX_LENGTH = 32767;
+	
 	///////////////////////
 	//
 	// DRDA Type constants.
@@ -126,6 +129,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	public	static final int DRDA_TYPE_NMDATALINK = 0x4F;
 
 	// --- Override LIDs 0x50 - 0xAF
+
+    // this type is shown in the DRDA spec, volume 1, in the
+    // section on SQLUDTGRP
+	public	static final int DRDA_TYPE_UDT = 0x50;
+	public	static final int DRDA_TYPE_NUDT = 0x51;
+    
 	public	static final int DRDA_TYPE_LOBBYTES = 0xC8;
 	public	static final int DRDA_TYPE_NLOBBYTES = 0xC9;
 	public	static final int DRDA_TYPE_LOBCSBCS = 0xCA;
@@ -142,6 +151,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	// public	static final int DRDA_TYPE_BOOLEAN = 0xBE;
 	// public	static final int DRDA_TYPE_NBOOLEAN = 0xBF;
 	
+    // This is the maximum size which a udt can serialize to in order to
+    // be transported across DRDA
+    public static final int MAX_DRDA_UDT_SIZE = DATA_STREAM_STRUCTURE_MAX_LENGTH;
+    
 	///////////////////////
 	//
 	// DB2 datatypes
@@ -212,4 +225,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
     // public	static final  int DB2_SQLTYPE_BOOLEAN = 1000;     // BOOLEAN
     // public	static final  int DB2_SQLTYPE_NBOOLEAN = 1001;
 
+    // there is no DB2 type for UDTs. we invent one
+    public   static final int DB2_SQLTYPE_FAKE_UDT = 2000;
+    public   static final int DB2_SQLTYPE_FAKE_NUDT = 2001;
+
 }
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/DynamicByteArrayOutputStream.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/DynamicByteArrayOutputStream.java
index 426ba396..4140d6f7 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/DynamicByteArrayOutputStream.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/DynamicByteArrayOutputStream.java
@@ -33,217 +33,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	the user of this class to have more control over the position of the stream
 	and can get a direct reference of the array.
 */
-public class DynamicByteArrayOutputStream extends OutputStream {
-
-	private static int INITIAL_SIZE = 4096;
-
-	private byte[] buf;
-	private int		position;
-	private int		used;		// how many bytes are used
-	private int		beginPosition;
-
-	public DynamicByteArrayOutputStream() {
-		this(INITIAL_SIZE);
-	}
-
-	public DynamicByteArrayOutputStream(int size) {
-		super();
-
-		buf = new byte[size];
-	}
-
-	public DynamicByteArrayOutputStream(byte[] data) {
-		super();
-
-		buf = data;
-	}
-
-	public DynamicByteArrayOutputStream(DynamicByteArrayOutputStream toBeCloned) {
-
-		byte[] cbuf = toBeCloned.getByteArray();
-		buf = new byte[cbuf.length];
-
-		write(cbuf, 0, cbuf.length);
-		position = toBeCloned.getPosition();
-		used = toBeCloned.getUsed();
-		beginPosition = toBeCloned.getBeginPosition();
-	}
-
-	/*
-	 *	OutputStream methods
-	 */
-	public void write(int b) 
-	{
-		if (position >= buf.length)
-			expandBuffer(INITIAL_SIZE);
-
-		buf[position++] = (byte) b;
-
-		if (position > used)
-			used = position;
-	}
-	
-	public void write(byte[] b, int off, int len) 
-	{
-		if ((position+len) > buf.length)
-			expandBuffer(len);
-
-		System.arraycopy(b, off, buf, position, len);
-		position += len;
-
-		if (position > used)
-			used = position;
-	}
-
-	void writeCompleteStream(InputStream dataIn, int len) throws IOException
-	{
-		if ((position+len) > buf.length)
-			expandBuffer(len);
-
-		org.apache.derby.iapi.services.io.InputStreamUtil.readFully(dataIn, buf, position, len);
-		position += len;
-
-		if (position > used)
-			used = position;
-	}
-
-	public void close()
-	{
-		buf = null;
-		reset();
-	}
-
-	/*
-	 *	Specific methods
-	 */
-
-	/**
-		Reset the stream for reuse
-	*/
-	public void reset()
-	{
-		position = 0;
-		beginPosition = 0;
-		used = 0;
-	}
-
-	/**
-		Get a reference to the byte array stored in the byte array output
-		stream. Note that the byte array may be longer that getPosition().
-		Bytes beyond and including the current poistion are invalid.
-	*/
-	public byte[] getByteArray()
-	{
-		return buf;
-	}
-
-	/**
-		Get the number of bytes that was used.
-	*/
-	public int getUsed()
-	{
-		return used;
-	}
-
-	/**
-		Get the current position in the stream
-	*/
-	public int getPosition()
-	{
-		return position;
-	}
-
-	/**
-		Get the current position in the stream
-	*/
-	public int getBeginPosition()
-	{
-		return beginPosition;
-	}
-
-	/**
-		Set the position of the stream pointer.
-		It is up to the caller to make sure the stream has no gap of garbage in
-		it or useful information is not left out at the end because the stream
-		does not remember anything about the previous position.
-	*/
-	public void setPosition(int newPosition)
-	{
-		if (newPosition > position)
-		{
-			if (newPosition > buf.length)
-				expandBuffer(newPosition - buf.length);
-		}
-
-		position = newPosition;
-
-		if (position > used)
-			used = position;
-
-		return ;
-	}
-
-	/**
-		Set the begin position of the stream pointer.
-		If the newBeginPosition is larger than the stream itself,
-		then, the begin position is not set.
-	*/
-	public void setBeginPosition(int newBeginPosition)
-	{
-
-		if (newBeginPosition > buf.length)
-			return;
-
-		beginPosition = newBeginPosition;
-	}
-
-	/**
-		Shrink the buffer left by the amount given. Ie.
-		bytes from 0 to amountToShrinkBy are thrown away
-	*/
-	public void discardLeft(int amountToShrinkBy) {
-
-		System.arraycopy(buf, amountToShrinkBy, buf, 0,
-			used - amountToShrinkBy);
-
-		position -= amountToShrinkBy;
-		used -= amountToShrinkBy;
-	}
-
-	/**
-		Expand the buffer by at least the number of bytes requested in minExtension.
-
-		To optimize performance and reduce memory copies and allocation, we have a staged buffer
-		expansion.
-
-		<UL>
-		<LI> buf.length < 128k - increase by 4k
-		<LI> buf.length < 1Mb - increase by 128k
-		<LI> otherwise increase by 1Mb.
-		</UL>
-
-		In all cases, if minExpansion is greater than the value about then the buffer will
-		be increased by minExtension.
-	*/
-	private void expandBuffer(int minExtension)
-	{
-		if (buf.length < (128 * 1024)) {
-			if (minExtension < INITIAL_SIZE)
-				minExtension = INITIAL_SIZE;
-		} else if (buf.length < (1024 * 1024)) {
-
-			if (minExtension < (128 * 1024))
-				minExtension = (128 * 1024);
-		} else {
-			if (minExtension < (1024 * 1024))
-				minExtension = 1024 * 1024;
-		}
-
-		int newsize = buf.length + minExtension;
-
-		byte[] newbuf = new byte[newsize];
-		System.arraycopy(buf, 0, newbuf, 0, buf.length);
-		buf = newbuf;
-	}
-
+public class DynamicByteArrayOutputStream extends org.apache.derby.shared.common.io.DynamicByteArrayOutputStream
+{
+	public DynamicByteArrayOutputStream() { super(); }
+	public DynamicByteArrayOutputStream(int size) { super( size ); }
+	public DynamicByteArrayOutputStream(byte[] data) { super( data ); }
+	public DynamicByteArrayOutputStream(DynamicByteArrayOutputStream toBeCloned) { super( toBeCloned ); }
 }
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/InputStreamUtil.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/InputStreamUtil.java
index fa00cd71..bb05291d 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/InputStreamUtil.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/InputStreamUtil.java
@@ -28,156 +28,5 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	a small subset of DataInput methods. This avoids pushing
 	a DataInputStream just to get this functionality.
 */
-public final class InputStreamUtil {
-    private static final int SKIP_FRAGMENT_SIZE = Integer.MAX_VALUE;
-
-	/**
-		Read an unsigned byte from an InputStream, throwing an EOFException
-		if the end of the input is reached.
-
-		@exception IOException if an I/O error occurs.
-		@exception EOFException if the end of the stream is reached
-
-		@see DataInput#readUnsignedByte
-	
-	*/
-	public static int readUnsignedByte(InputStream in) throws IOException {
-		int b = in.read();
-		if (b < 0)
-			throw new EOFException();
-
-		return b;
-	}
-
-	/**
-		Read a number of bytes into an array.
-
-		@exception IOException if an I/O error occurs.
-		@exception EOFException if the end of the stream is reached
-
-		@see DataInput#readFully
-
-	*/
-	public static void readFully(InputStream in, byte b[],
-                                 int offset,
-                                 int len) throws IOException
-	{
-		do {
-			int bytesRead = in.read(b, offset, len);
-			if (bytesRead < 0)
-				throw new EOFException();
-			len -= bytesRead;
-			offset += bytesRead;
-		} while (len != 0);
-	}
-
-
-	/**
-		Read a number of bytes into an array.
-        Keep reading in a loop until len bytes are read or EOF is reached or
-        an exception is thrown. Return the number of bytes read.
-        (InputStream.read(byte[],int,int) does not guarantee to read len bytes
-         even if it can do so without reaching EOF or raising an exception.)
-
-		@exception IOException if an I/O error occurs.
-	*/
-	public static int readLoop(InputStream in,
-                                byte b[],
-                                int offset,
-                                int len)
-        throws IOException
-	{
-        int firstOffset = offset;
-		do {
-			int bytesRead = in.read(b, offset, len);
-			if (bytesRead <= 0)
-                break;
-			len -= bytesRead;
-			offset += bytesRead;
-		} while (len != 0);
-        return offset - firstOffset;
-	}
-
-    /**
-     * Skips until EOF, returns number of bytes skipped.
-     * @param is
-     *      InputStream to be skipped.
-     * @return
-     *      number of bytes skipped in fact.
-     * @throws IOException
-     *      if IOException occurs. It doesn't contain EOFException.
-     * @throws NullPointerException
-     *      if the param 'is' equals null.
-     */
-    public static long skipUntilEOF(InputStream is) throws IOException {
-        if(is == null)
-            throw new NullPointerException();
-
-        long bytes = 0;
-        while(true){
-            long r = skipPersistent(is, SKIP_FRAGMENT_SIZE);
-            bytes += r;
-            if(r < SKIP_FRAGMENT_SIZE)
-                return bytes;
-        }
-    }
-
-    /**
-     * Skips requested number of bytes,
-     * throws EOFException if there is too few bytes in the stream.
-     * @param is
-     *      InputStream to be skipped.
-     * @param skippedBytes
-     *      number of bytes to skip. if skippedBytes <= zero, do nothing.
-     * @throws EOFException
-     *      if EOF meets before requested number of bytes are skipped.
-     * @throws IOException
-     *      if IOException occurs. It doesn't contain EOFException.
-     * @throws NullPointerException
-     *      if the param 'is' equals null.
-     */
-    public static void skipFully(InputStream is, long skippedBytes)
-    throws IOException {
-        if(is == null)
-            throw new NullPointerException();
-
-        if(skippedBytes <= 0)
-            return;
-
-        long bytes = skipPersistent(is, skippedBytes);
-
-        if(bytes < skippedBytes)
-            throw new EOFException();
-    }
-
-    /**
-     * Tries harder to skip the requested number of bytes.
-     * <p>
-     * Note that even if the method fails to skip the requested number of bytes,
-     * it will not throw an exception. If this happens, the caller can be sure
-     * that end-of-stream has been reached.
-     *
-     * @param in byte stream
-     * @param bytesToSkip the number of bytes to skip
-     * @return The number of bytes skipped.
-     * @throws IOException if reading from the stream fails
-     */
-    public static final long skipPersistent(InputStream in, long bytesToSkip)
-    throws IOException {
-        long skipped = 0;
-        while (skipped < bytesToSkip) {
-            long skippedNow = in.skip(bytesToSkip - skipped);
-            if (skippedNow == 0) {
-                if (in.read() == -1) {
-                    // EOF, return what we have and leave it up to caller to
-                    // decide what to do about it.
-                    break;
-                } else {
-                    skippedNow = 1; // Added to count below.
-                }
-            }
-            skipped += skippedNow;
-        }
-        return skipped;
-    }
-}
+public final class InputStreamUtil extends org.apache.derby.shared.common.io.InputStreamUtil
+{}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataTypeUtilities.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataTypeUtilities.java
index 07397064..616fb356 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataTypeUtilities.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataTypeUtilities.java
@@ -23,6 +23,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 import org.apache.derby.iapi.error.StandardException;
 
+import org.apache.derby.iapi.reference.JDBC30Translation;
 import org.apache.derby.iapi.reference.JDBC40Translation;
 import org.apache.derby.iapi.services.io.StoredFormatIds;
 
@@ -201,7 +202,7 @@ public	static	int getColumnDisplaySize(int typeId, int storageLength)
 			default: 
 				// MaximumWidth is -1 when it is unknown.
 				int w = storageLength;
-				size = (w > 0 ? w : 15);
+				size = (w > 0 ? w : JDBC30Translation.DEFAULT_COLUMN_DISPLAY_SIZE);
 				break;
 		}
 		return size;
diff --git a/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/io/DynamicByteArrayOutputStream.java b/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/io/DynamicByteArrayOutputStream.java
index 3f24d583..16302168 100644
--- a/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/io/DynamicByteArrayOutputStream.java
+++ b/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/io/DynamicByteArrayOutputStream.java
@@ -1 +1,250 @@
   + native
+/*
+
+   Derby - Class org.apache.derby.shared.common.io.DynamicByteArrayOutputStream
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.shared.common.io;
+
+import org.apache.derby.shared.common.sanity.SanityManager;
+
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+	A DynamicByteArrayOutputStream allows writing to a dynamically resizable
+	array of bytes.   In addition to dynamic resizing, this extension allows
+	the user of this class to have more control over the position of the stream
+	and can get a direct reference of the array.
+*/
+public class DynamicByteArrayOutputStream extends OutputStream {
+
+	private static int INITIAL_SIZE = 4096;
+
+	private byte[] buf;
+	private int		position;
+	private int		used;		// how many bytes are used
+	private int		beginPosition;
+
+	public DynamicByteArrayOutputStream() {
+		this(INITIAL_SIZE);
+	}
+
+	public DynamicByteArrayOutputStream(int size) {
+		super();
+
+		buf = new byte[size];
+	}
+
+	public DynamicByteArrayOutputStream(byte[] data) {
+		super();
+
+		buf = data;
+	}
+
+	public DynamicByteArrayOutputStream(DynamicByteArrayOutputStream toBeCloned) {
+
+		byte[] cbuf = toBeCloned.getByteArray();
+		buf = new byte[cbuf.length];
+
+		write(cbuf, 0, cbuf.length);
+		position = toBeCloned.getPosition();
+		used = toBeCloned.getUsed();
+		beginPosition = toBeCloned.getBeginPosition();
+	}
+
+	/*
+	 *	OutputStream methods
+	 */
+	public void write(int b) 
+	{
+		if (position >= buf.length)
+			expandBuffer(INITIAL_SIZE);
+
+		buf[position++] = (byte) b;
+
+		if (position > used)
+			used = position;
+	}
+	
+	public void write(byte[] b, int off, int len) 
+	{
+		if ((position+len) > buf.length)
+			expandBuffer(len);
+
+		System.arraycopy(b, off, buf, position, len);
+		position += len;
+
+		if (position > used)
+			used = position;
+	}
+
+	void writeCompleteStream(InputStream dataIn, int len) throws IOException
+	{
+		if ((position+len) > buf.length)
+			expandBuffer(len);
+
+		InputStreamUtil.readFully(dataIn, buf, position, len);
+		position += len;
+
+		if (position > used)
+			used = position;
+	}
+
+	public void close()
+	{
+		buf = null;
+		reset();
+	}
+
+	/*
+	 *	Specific methods
+	 */
+
+	/**
+		Reset the stream for reuse
+	*/
+	public void reset()
+	{
+		position = 0;
+		beginPosition = 0;
+		used = 0;
+	}
+
+	/**
+		Get a reference to the byte array stored in the byte array output
+		stream. Note that the byte array may be longer that getPosition().
+		Bytes beyond and including the current poistion are invalid.
+	*/
+	public byte[] getByteArray()
+	{
+		return buf;
+	}
+
+	/**
+		Get the number of bytes that was used.
+	*/
+	public int getUsed()
+	{
+		return used;
+	}
+
+	/**
+		Get the current position in the stream
+	*/
+	public int getPosition()
+	{
+		return position;
+	}
+
+	/**
+		Get the current position in the stream
+	*/
+	public int getBeginPosition()
+	{
+		return beginPosition;
+	}
+
+	/**
+		Set the position of the stream pointer.
+		It is up to the caller to make sure the stream has no gap of garbage in
+		it or useful information is not left out at the end because the stream
+		does not remember anything about the previous position.
+	*/
+	public void setPosition(int newPosition)
+	{
+		if (newPosition > position)
+		{
+			if (newPosition > buf.length)
+				expandBuffer(newPosition - buf.length);
+		}
+
+		position = newPosition;
+
+		if (position > used)
+			used = position;
+
+		return ;
+	}
+
+	/**
+		Set the begin position of the stream pointer.
+		If the newBeginPosition is larger than the stream itself,
+		then, the begin position is not set.
+	*/
+	public void setBeginPosition(int newBeginPosition)
+	{
+
+		if (newBeginPosition > buf.length)
+			return;
+
+		beginPosition = newBeginPosition;
+	}
+
+	/**
+		Shrink the buffer left by the amount given. Ie.
+		bytes from 0 to amountToShrinkBy are thrown away
+	*/
+	public void discardLeft(int amountToShrinkBy) {
+
+		System.arraycopy(buf, amountToShrinkBy, buf, 0,
+			used - amountToShrinkBy);
+
+		position -= amountToShrinkBy;
+		used -= amountToShrinkBy;
+	}
+
+	/**
+		Expand the buffer by at least the number of bytes requested in minExtension.
+
+		To optimize performance and reduce memory copies and allocation, we have a staged buffer
+		expansion.
+
+		<UL>
+		<LI> buf.length < 128k - increase by 4k
+		<LI> buf.length < 1Mb - increase by 128k
+		<LI> otherwise increase by 1Mb.
+		</UL>
+
+		In all cases, if minExpansion is greater than the value about then the buffer will
+		be increased by minExtension.
+	*/
+	private void expandBuffer(int minExtension)
+	{
+		if (buf.length < (128 * 1024)) {
+			if (minExtension < INITIAL_SIZE)
+				minExtension = INITIAL_SIZE;
+		} else if (buf.length < (1024 * 1024)) {
+
+			if (minExtension < (128 * 1024))
+				minExtension = (128 * 1024);
+		} else {
+			if (minExtension < (1024 * 1024))
+				minExtension = 1024 * 1024;
+		}
+
+		int newsize = buf.length + minExtension;
+
+		byte[] newbuf = new byte[newsize];
+		System.arraycopy(buf, 0, newbuf, 0, buf.length);
+		buf = newbuf;
+	}
+
+}
diff --git a/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/io/InputStreamUtil.java b/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/io/InputStreamUtil.java
index e69de29b..69ff6d5b 100644
--- a/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/io/InputStreamUtil.java
+++ b/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/io/InputStreamUtil.java
@@ -0,0 +1,183 @@
+/*
+
+   Derby - Class org.apache.derby.shared.common.io.InputStreamUtil
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.shared.common.io;
+
+import java.io.*;
+
+/**
+	Utility methods for InputStream that are stand-ins for
+	a small subset of DataInput methods. This avoids pushing
+	a DataInputStream just to get this functionality.
+*/
+public class InputStreamUtil {
+    private static final int SKIP_FRAGMENT_SIZE = Integer.MAX_VALUE;
+
+	/**
+		Read an unsigned byte from an InputStream, throwing an EOFException
+		if the end of the input is reached.
+
+		@exception IOException if an I/O error occurs.
+		@exception EOFException if the end of the stream is reached
+
+		@see DataInput#readUnsignedByte
+	
+	*/
+	public static int readUnsignedByte(InputStream in) throws IOException {
+		int b = in.read();
+		if (b < 0)
+			throw new EOFException();
+
+		return b;
+	}
+
+	/**
+		Read a number of bytes into an array.
+
+		@exception IOException if an I/O error occurs.
+		@exception EOFException if the end of the stream is reached
+
+		@see DataInput#readFully
+
+	*/
+	public static void readFully(InputStream in, byte b[],
+                                 int offset,
+                                 int len) throws IOException
+	{
+		do {
+			int bytesRead = in.read(b, offset, len);
+			if (bytesRead < 0)
+				throw new EOFException();
+			len -= bytesRead;
+			offset += bytesRead;
+		} while (len != 0);
+	}
+
+
+	/**
+		Read a number of bytes into an array.
+        Keep reading in a loop until len bytes are read or EOF is reached or
+        an exception is thrown. Return the number of bytes read.
+        (InputStream.read(byte[],int,int) does not guarantee to read len bytes
+         even if it can do so without reaching EOF or raising an exception.)
+
+		@exception IOException if an I/O error occurs.
+	*/
+	public static int readLoop(InputStream in,
+                                byte b[],
+                                int offset,
+                                int len)
+        throws IOException
+	{
+        int firstOffset = offset;
+		do {
+			int bytesRead = in.read(b, offset, len);
+			if (bytesRead <= 0)
+                break;
+			len -= bytesRead;
+			offset += bytesRead;
+		} while (len != 0);
+        return offset - firstOffset;
+	}
+
+    /**
+     * Skips until EOF, returns number of bytes skipped.
+     * @param is
+     *      InputStream to be skipped.
+     * @return
+     *      number of bytes skipped in fact.
+     * @throws IOException
+     *      if IOException occurs. It doesn't contain EOFException.
+     * @throws NullPointerException
+     *      if the param 'is' equals null.
+     */
+    public static long skipUntilEOF(InputStream is) throws IOException {
+        if(is == null)
+            throw new NullPointerException();
+
+        long bytes = 0;
+        while(true){
+            long r = skipPersistent(is, SKIP_FRAGMENT_SIZE);
+            bytes += r;
+            if(r < SKIP_FRAGMENT_SIZE)
+                return bytes;
+        }
+    }
+
+    /**
+     * Skips requested number of bytes,
+     * throws EOFException if there is too few bytes in the stream.
+     * @param is
+     *      InputStream to be skipped.
+     * @param skippedBytes
+     *      number of bytes to skip. if skippedBytes <= zero, do nothing.
+     * @throws EOFException
+     *      if EOF meets before requested number of bytes are skipped.
+     * @throws IOException
+     *      if IOException occurs. It doesn't contain EOFException.
+     * @throws NullPointerException
+     *      if the param 'is' equals null.
+     */
+    public static void skipFully(InputStream is, long skippedBytes)
+    throws IOException {
+        if(is == null)
+            throw new NullPointerException();
+
+        if(skippedBytes <= 0)
+            return;
+
+        long bytes = skipPersistent(is, skippedBytes);
+
+        if(bytes < skippedBytes)
+            throw new EOFException();
+    }
+
+    /**
+     * Tries harder to skip the requested number of bytes.
+     * <p>
+     * Note that even if the method fails to skip the requested number of bytes,
+     * it will not throw an exception. If this happens, the caller can be sure
+     * that end-of-stream has been reached.
+     *
+     * @param in byte stream
+     * @param bytesToSkip the number of bytes to skip
+     * @return The number of bytes skipped.
+     * @throws IOException if reading from the stream fails
+     */
+    public static final long skipPersistent(InputStream in, long bytesToSkip)
+    throws IOException {
+        long skipped = 0;
+        while (skipped < bytesToSkip) {
+            long skippedNow = in.skip(bytesToSkip - skipped);
+            if (skippedNow == 0) {
+                if (in.read() == -1) {
+                    // EOF, return what we have and leave it up to caller to
+                    // decide what to do about it.
+                    break;
+                } else {
+                    skippedNow = 1; // Added to count below.
+                }
+            }
+            skipped += skippedNow;
+        }
+        return skipped;
+    }
+}
diff --git a/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/JDBC30Translation.java b/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/JDBC30Translation.java
index 1f5124d1..9a0ea6c3 100644
--- a/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/JDBC30Translation.java
+++ b/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/JDBC30Translation.java
@@ -22,19 +22,27 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 package org.apache.derby.shared.common.reference;
 import java.sql.ParameterMetaData;
 /**
+        <P>
         This class contains public statics that map directly
         to the new public statics in the jdbc 3.0 classes.
         By providing an intermediary class, we can use the
         same statics without having to import the jdbc 3.0 classes
         into other classes.
+        </P>
+
 
+        <P>
+        This class also contains some constants shared by the network server and client.
+        </P>
 
         <P>
         This class should not be shipped with the product.
+        </P>
 
         <P>
         This class has no methods, all it contains are constants
         are public, static and final since they are declared in an interface.
+        </P>
 */
 
 public interface JDBC30Translation {
@@ -49,4 +57,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more
         public static final int PARAMETER_MODE_IN = ParameterMetaData.parameterModeIn;
         public static final int PARAMETER_MODE_IN_OUT = ParameterMetaData.parameterModeInOut;
         public static final int PARAMETER_MODE_OUT = ParameterMetaData.parameterModeOut;
+
+    // Constants shared by network client and server
+    public static final int DEFAULT_COLUMN_DISPLAY_SIZE = 15;
+    public static final int UNKNOWN_SCALE = 0;
+    public static final int UNKNOWN_PRECISION = 0;
 }
diff --git a/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java b/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java
index d6faea94..18c0632b 100644
--- a/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java
+++ b/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java
@@ -1597,6 +1597,8 @@ The message identifier (ie. the value that matches a field in this class)
     String NET_PREMATURE_EOS                                        = "XN017.S";
     String NET_READER_LENGTH_TOO_SMALL                              = "XN018.S";
     String NET_XARETVAL_ERROR                                       = "XN019.S";
+    String NET_MARSHALLING_UDT_ERROR                     = "XN020.S";
+    String NET_UDT_COERCION_ERROR                               = "XN021.S";
     
     // XML - Derby-specific XML errors not covered by
     // SQL standard.
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/DatabaseMetaDataTest.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/DatabaseMetaDataTest.java
index 19e58b4c..3f8c9d00 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/DatabaseMetaDataTest.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/DatabaseMetaDataTest.java
@@ -14,7 +14,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
+   See the License for the specific language go1481
+   verning permissions and
    limitations under the License.
 
  */
@@ -1473,7 +1474,7 @@ private int createTablesForTest(boolean skipXML) throws SQLException
      * for a SELECT * from the table. All columns in
      * all tables are checked.
      */
-    public void testGetColumnsReadOnly() throws SQLException
+    public void testGetColumnsReadOnly() throws Exception
     {
         ResultSet[] rs = getColumns(null, null, null, null);
         for ( int j =0 ; j<2 ; j++) {
@@ -1487,7 +1488,7 @@ public void testGetColumnsReadOnly() throws SQLException
      * 
      * @throws SQLException
      */
-    public void testGetColumnsModify() throws SQLException {
+    public void testGetColumnsModify() throws Exception {
            
         // skip XML datatype as our cross check with
         // ResultSetMetaData will fail
@@ -1746,7 +1747,7 @@ else if (x == 5)
      */
     private void crossCheckGetColumnsAndResultSetMetaData(ResultSet rs,
             boolean partial, int odbc)
-    throws SQLException
+    throws Exception
     {
         Statement s = createStatement();
         while (rs.next())
@@ -1798,11 +1799,12 @@ private void crossCheckGetColumnsAndResultSetMetaData(ResultSet rs,
      *    in using BUFFER_LENGTH (ODBC) or no(JDBC).
      * @throws SQLException
      */
-    public static void crossCheckGetColumnRowAndResultSetMetaData(
+    public void crossCheckGetColumnRowAndResultSetMetaData(
             ResultSet rs, ResultSetMetaData rsmdt, int odbc)
-        throws SQLException
+        throws Exception
     {
         int col = rs.getInt("ORDINAL_POSITION");
+        Version dataVersion = getDataVersion( getConnection() );
         
         assertEquals("RSMD.getCatalogName",
                 rsmdt.getCatalogName(col), rs.getString("TABLE_CAT"));
@@ -1829,7 +1831,8 @@ public static void crossCheckGetColumnRowAndResultSetMetaData(
             assertEquals("DATA_TYPE",
                     Types.SMALLINT, rsmdt.getColumnType(col));
         }
-        else if (dmdColumnType == Types.JAVA_OBJECT && usingDerbyNetClient())
+        else if (dmdColumnType == Types.JAVA_OBJECT && usingDerbyNetClient()
+                 &&  ( dataVersion.compareTo( new Version( 10, 6, 0, 0 ) ) < 0 ) )
         {
             // DMD returns JAVA_OBJECT
             // RSMD returns LONGVARBINARY!                    
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/junitTests/compatibility/CompatibilityCombinations.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/junitTests/compatibility/CompatibilityCombinations.java
index 3cde2355..e256e1f0 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/junitTests/compatibility/CompatibilityCombinations.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/junitTests/compatibility/CompatibilityCombinations.java
@@ -1042,7 +1042,7 @@ public void run()
             );
             DEBUG("************** Do .start().");
             serverThread.start();
-            pingServer(5); // Wait for the server to come up in a reasonable time....
+            pingServer(1, envElements); // Wait for the server to come up in a reasonable time....
             serverThread.join();
             DEBUG("************** Done .join().");
         }
@@ -1173,27 +1173,32 @@ private void recreateDB(int serverVersion
      * come up in a reasonable amount of time, (re-)throw the
      * final exception.
      * </p>
-     * @param iterations How many times to try pinging the server to see if it is running.
-     * Sleeps <CODE>SLEEP_TIME_MILLIS</CODE> between tries.
+     * @param iterations How many times to try pinging the server to see if it is running. Sleeps <CODE>SLEEP_TIME_MILLIS</CODE> between tries.
+     * @param serverEnvironment Paths used in bringing up server
      * @throws java.lang.Exception .
      */
     // Copied from org.apache.derbyTesting.functionTests.tests.junitTests.compatibility.Pinger
-    private	void	pingServer( int iterations )
+    private	void	pingServer( int iterations, String[] serverEnvironment )
     throws Exception
     {
         DEBUG("+++ pingServer");
-        ping( new NetworkServerControl(), iterations );
+        ping( new NetworkServerControl(), iterations, serverEnvironment );
         DEBUG("--- pingServer");
     }
     
-    
-  private	void	ping( NetworkServerControl controller, int iterations )
+    /**
+     * It used to be possible to ping down-rev servers using an up-rev NetworkServerControl.
+     * This is no longer possible. So we will just take it on faith that the server comes up after
+     * a decent interval.
+     */
+    private	void	ping( NetworkServerControl controller, int iterations, String[] serverEnvironment )
     throws Exception
     {
         Exception	finalException = null;
         
         for ( int i = 0; i < iterations; i++ )
         {
+            /*
             try
             {
                 controller.ping();
@@ -1202,12 +1207,22 @@ private	void	ping( NetworkServerControl controller, int iterations )
             }
             catch (Exception e)
           { finalException = e; }
+            */
             
             Thread.sleep( SLEEP_TIME_MILLIS );
         }
         
-        System.out.println( "Server did not come up: " + finalException.getMessage() );
+        /*
+        StringBuffer buffer = new StringBuffer();
+        buffer.append( "Server did not come up: " + finalException.getMessage() );
+        int pathCount = serverEnvironment.length;
+        for ( int i = 0; i < pathCount; i++ )
+        {
+            buffer.append( "\n\t" + serverEnvironment[ i ] );
+        }
+        System.out.println( buffer.toString() );
         finalException.printStackTrace();
+        */
         
     }
     
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/junitTests/compatibility/CompatibilitySuite.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/junitTests/compatibility/CompatibilitySuite.java
index c98c9dea..e1c7482c 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/junitTests/compatibility/CompatibilitySuite.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/junitTests/compatibility/CompatibilitySuite.java
@@ -53,11 +53,16 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	public	static	final	Version	DRB_10_0 = new Version( 10, 0 );
 	public	static	final	Version	DRB_10_1 = new Version( 10, 1 );
 	public	static	final	Version	DRB_10_2 = new Version( 10, 2 );
+	public	static	final	Version	DRB_10_3 = new Version( 10, 3 );
+	public	static	final	Version	DRB_10_4 = new Version( 10, 4 );
+	public	static	final	Version	DRB_10_5 = new Version( 10, 5 );
+	public	static	final	Version	DRB_10_6 = new Version( 10, 6 );
 
 	// Supported VM versions.
 	public	static	final	Version	VM_1_3 = new Version( 1, 3 );
 	public	static	final	Version	VM_1_4 = new Version( 1, 4 );
 	public	static	final	Version	VM_1_5 = new Version( 1, 5 );
+	public	static	final	Version	VM_1_6 = new Version( 1, 6 );
 
 	public	static	final	String	SERVER_VERSION_FUNCTION = "getVMVersion";
 	
@@ -180,6 +185,16 @@ public static void main( String args[] )
 	 */
 	public	Version	getClientVMVersion() { return _clientVMLevel; }
 
+    /**
+     * <p>
+     *  Report whether the server supports ANSI UDTs.
+     * </p>
+     */
+    public boolean serverSupportsUDTs()
+    {
+        return getServerVersion().atLeast( DRB_10_6 );
+    }
+
 	/////////////////////////////////////////////////////////////
 	//
 	//	DATABASE-SIDE FUNCTIONS
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/junitTests/compatibility/JDBCDriverTest.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/junitTests/compatibility/JDBCDriverTest.java
index 18e9c7b8..b7c61733 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/junitTests/compatibility/JDBCDriverTest.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/junitTests/compatibility/JDBCDriverTest.java
@@ -1,4 +1,4 @@
-/*
+/**
 
    Derby - Class org.apache.derbyTesting.functionTests.tests.compatibility.JDBCDriverTest
 
@@ -255,10 +255,243 @@ public	void	testJDBCDriver()
 		createSchema( conn );
 
 		datatypesTest( conn );
+        udtTest( conn );
 
 		close( conn );
 	}
 	
+	/////////////////////////////////////////////////////////////
+	//
+	//	TEST UDTs
+	//
+	/////////////////////////////////////////////////////////////
+
+	//
+	// Verify the metadata for user defined types.
+	//
+	private	void	udtTest( Connection conn )
+		throws Exception
+	{
+        //
+        // We must expect the wrong metadata in a network configuration
+        // unless both the client and the server are at 10.6 or higher.
+        // See DERBY-4491.
+        //
+        boolean correctBehavior =
+            usingEmbeddedClient() ||
+            (
+             getServerVersion().atLeast( DRB_10_6 ) &&
+             getDriverVersion().atLeast( DRB_10_6 )
+             );
+
+        String query = "select aliasinfo from sys.sysaliases";
+        
+        if ( correctBehavior )
+        {
+            String aliasInfoClassName = "org.apache.derby.catalog.AliasInfo";
+            
+            checkRSMD
+                (
+                 conn,
+                 query,
+                 aliasInfoClassName,
+                 15,
+                 java.sql.Types.JAVA_OBJECT,
+                 aliasInfoClassName,
+                 0,
+                 0
+                 );
+        }
+        else
+        {
+            checkRSMD
+                (
+                 conn,
+                 query,
+                 "byte[]",
+                 65400,
+                 java.sql.Types.LONGVARBINARY,
+                 "LONG VARCHAR FOR BIT DATA",
+                 32700,
+                 0
+                 );
+        }
+
+
+        if ( serverSupportsUDTs() )
+        {
+            query = "select a from t_price";
+            PreparedStatement ps = conn.prepareStatement( query );
+            ResultSet rs = ps.executeQuery();
+            rs.next();
+            Object price = rs.getObject( 1 );
+            String actualClassName = price.getClass().getName();
+            rs.close();
+            ps.close();
+
+            if ( correctBehavior )
+            {
+                String priceClassName = "org.apache.derbyTesting.functionTests.tests.lang.Price";
+                checkRSMD
+                    (
+                     conn,
+                     query,
+                     priceClassName,
+                     15,
+                     java.sql.Types.JAVA_OBJECT,
+                     "\"APP\".\"PRICE\"",
+                     0,
+                     0
+                     );
+
+                assertEquals( priceClassName, actualClassName );
+            }
+            else
+            {
+                checkRSMD
+                    (
+                     conn,
+                     query,
+                     "byte[]",
+                     65400,
+                     java.sql.Types.LONGVARBINARY,
+                     "LONG VARCHAR FOR BIT DATA",
+                     32700,
+                     0
+                     );
+                
+                assertEquals( "java.lang.String", actualClassName );
+            }
+
+            query = "insert into t_price( a ) values ( ? )";
+            
+            if ( correctBehavior )
+            {
+                checkPMD
+                    (
+                     conn,
+                     query,
+                     "org.apache.derbyTesting.functionTests.tests.lang.Price",
+                     java.sql.Types.JAVA_OBJECT,
+                     "\"APP\".\"PRICE\"",
+                     0,
+                     0
+                     );
+            }
+            else
+            {
+                checkPMD
+                    (
+                     conn,
+                     query,
+                     "byte[]",
+                     java.sql.Types.LONGVARBINARY,
+                     "LONG VARCHAR FOR BIT DATA",
+                     32700,
+                     0
+                     );
+            }
+
+            //
+            // Should only be able to stuff an object into the column if both
+            // the client and server are at 10.6 or higher.
+            //
+            ps = conn.prepareStatement( query );
+            byte[] someBytes = new byte[] { (byte) 1, (byte) 2, (byte) 3 };
+            ByteArrayInputStream bais = new ByteArrayInputStream( someBytes );
+            
+            try {
+                ps.setObject( 1, org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice() );
+                ps.executeUpdate();
+
+                if ( !correctBehavior ) { fail( "setObject( Price ) unexpectedly worked." ); }
+            }
+            catch (SQLException se)
+            {
+                if ( correctBehavior ) { fail( "setObject( Price ) unexpectedly failed." ); }
+            }
+            try {
+                ps.setObject( 1, someBytes );
+                ps.executeUpdate();
+
+                fail( "setObject( byte[] ) unexpectedly worked." );
+            }
+            catch (SQLException se) {}
+            try {
+                ps.setBytes( 1, someBytes );
+                ps.executeUpdate();
+
+                fail( "setBytes( byte[] ) unexpectedly worked." );
+            }
+            catch (SQLException se) {}
+            try {
+                ps.setBinaryStream( 1, bais, 3 );
+                ps.executeUpdate();
+
+                fail( "setBinaryStream( InputStream ) unexpectedly worked." );
+            }
+            catch (SQLException se) {}
+
+            ps.close();
+        }
+    }
+    
+    /**
+     * Check the ResultSetMetaData for a query whose first column is a UDT.
+     */
+    private void checkRSMD
+        (
+         Connection conn,
+         String query,
+         String expectedClassName,
+         int expectedDisplaySize,
+         int expectedJDBCType,
+         String expectedSQLTypeName,
+         int expectedPrecision,
+         int expectedScale
+         ) throws Exception
+    {
+        PreparedStatement ps = conn.prepareStatement( query );
+        ResultSet rs = ps.executeQuery();
+        ResultSetMetaData rsmd = rs.getMetaData();
+
+        assertEquals( expectedClassName, rsmd.getColumnClassName( 1 ) );
+        assertEquals( expectedDisplaySize , rsmd.getColumnDisplaySize( 1 ));
+        assertEquals( expectedJDBCType, rsmd.getColumnType( 1 ) );
+        assertEquals( expectedSQLTypeName, rsmd.getColumnTypeName( 1 ) );
+        assertEquals( expectedPrecision, rsmd.getPrecision( 1 ) );
+        assertEquals( expectedScale, rsmd.getScale( 1 ) );
+
+        rs.close();
+        ps.close();
+    }
+    
+    /**
+     * Check the ParameterMetaData for a statement whose first parameter is a UDT.
+     */
+    private void checkPMD
+        (
+         Connection conn,
+         String query,
+         String expectedClassName,
+         int expectedJDBCType,
+         String expectedSQLTypeName,
+         int expectedPrecision,
+         int expectedScale
+         ) throws Exception
+    {
+        PreparedStatement ps = conn.prepareStatement( query );
+        ParameterMetaData pmd = ps.getParameterMetaData();
+
+        assertEquals( pmd.getParameterClassName( 1 ), expectedClassName );
+        assertEquals( pmd.getParameterType( 1 ), expectedJDBCType );
+        assertEquals( pmd.getParameterTypeName( 1 ), expectedSQLTypeName );
+        assertEquals( pmd.getPrecision( 1 ), expectedPrecision );
+        assertEquals( pmd.getScale( 1 ), expectedScale );
+
+        ps.close();
+    }
+
 	/////////////////////////////////////////////////////////////
 	//
 	//	TEST DATATYPES
@@ -799,6 +1032,8 @@ private	void	createSchema( Connection conn )
 		throws Exception
 	{
 		createTable( conn, ALL_TYPES_TABLE, ALL_TYPES );
+
+        createUDTObjects( conn );
 	}
 
 	//
@@ -838,6 +1073,33 @@ private	void	createTable( Connection conn, String tableName, TypeDescriptor[] ty
 		close( ps );
 	}
 
+    //
+    // Create an ANSI UDT and a table with that type of column--
+    // if the server is at 10.6 or higher.
+    //
+    private void createUDTObjects( Connection conn ) throws Exception
+    {
+        if ( !serverSupportsUDTs() ) { return; }
+
+        PreparedStatement ps;
+
+        ps = conn.prepareStatement( "create type price external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
+        ps.execute();
+        ps.close();
+
+        ps = conn.prepareStatement( "create function makePrice( ) returns price language java parameter style java no sql external name 'org.apache.derbyTesting.functionTests.tests.lang.Price.makePrice'\n" );
+        ps.execute();
+        ps.close();
+
+        ps = conn.prepareStatement( "create table t_price( a price )\n" );
+        ps.execute();
+        ps.close();
+
+        ps = conn.prepareStatement( "insert into t_price( a ) values ( makePrice() )\n" );
+        ps.execute();
+        ps.close();
+    }
+
 
 	//
 	// Helper methods for declaring a table.
@@ -864,6 +1126,20 @@ private	void	addColumn( StringBuffer buffer, int columnNumber, String text  )
 	private	void	dropSchema( Connection conn )
 	{
 		dropTable( conn, ALL_TYPES_TABLE );
+        dropUDTObjects( conn );
+	}
+
+    //
+    // Drop objects needed by UDT tests. We only do this if the server
+    // is at 10.6 or higher.
+    //
+    private void dropUDTObjects( Connection conn )
+    {
+        if ( !serverSupportsUDTs() ) { return; }
+
+        dropFunction( conn, "MAKEPRICE" );
+        dropTable( conn, "T_PRICE" );
+        dropUDT( conn, "PRICE" );
 	}
 
 	//
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/UDTTest.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/UDTTest.java
index e716824a..708a5143 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/UDTTest.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/UDTTest.java
@@ -23,8 +23,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 import java.math.BigDecimal;
 import java.sql.Connection;
+import java.sql.ParameterMetaData;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
+import java.sql.ResultSetMetaData;
 import java.sql.Timestamp;
 
 import junit.framework.Test;
@@ -88,7 +90,7 @@ public UDTTest(String name)
      */
     public static Test suite()
     {
-        TestSuite suite = (TestSuite) TestConfiguration.embeddedSuite(UDTTest.class);
+        TestSuite suite = (TestSuite) TestConfiguration.defaultSuite(UDTTest.class);
         Test        result = new CleanDatabaseTestSetup( suite );
 
         return result;
@@ -194,10 +196,10 @@ public void test_02_basicColumnRetvalParam() throws Exception
         assertResults
             (
              conn,
-             "select getCurrencyCode( totalPrice ), getAmount( totalPrice ), getTimeInstant( totalPrice ) from orders",
+             "select getCurrencyCode( totalPrice ), getTimeInstant( totalPrice ) from orders",
              new String[][]
              {
-                 { "USD" ,         "9.99000" ,        "2009-10-16 14:24:43.0" },
+                 { "USD" ,         "2009-10-16 14:24:43.0" },
              },
              false
              );
@@ -644,6 +646,79 @@ public void test_08_triggerDependencies() throws Exception
 
     }
     
+    /**
+     * <p>
+     * Check result set metadata for UDT columns.
+     * </p>
+     */
+    public void test_09_resultSetMetaData() throws Exception
+    {
+        Connection conn = getConnection();
+
+        goodStatement( conn, "create type price_09_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
+        goodStatement( conn, "create table t_09_a( a price_09_a )\n" );
+
+        // ANSI UDT
+        checkRSMD
+            (
+             conn,
+             "select a from t_09_a\n",
+             "org.apache.derbyTesting.functionTests.tests.lang.Price",
+             15,
+             java.sql.Types.JAVA_OBJECT,
+             "\"APP\".\"PRICE_09_A\"",
+             0,
+             0
+             );
+
+        // old-style objects in Derby system tables do not have
+        // schema-qualified type names
+        checkRSMD
+            (
+             conn,
+             "select aliasinfo from sys.sysaliases\n",
+             "org.apache.derby.catalog.AliasInfo",
+             15,
+             java.sql.Types.JAVA_OBJECT,
+             "org.apache.derby.catalog.AliasInfo",
+             0,
+             0
+             );
+    }
+
+    /**
+     * <p>
+     * Check parameter metadata for UDT parameters.
+     * </p>
+     */
+    public void test_10_parameterMetaData() throws Exception
+    {
+        Connection conn = getConnection();
+
+        goodStatement( conn, "create type price_10_a external name 'org.apache.derbyTesting.functionTests.tests.lang.Price' language java\n" );
+        goodStatement( conn, "create table t_10_a( a price_09_a )\n" );
+
+        // ANSI UDT
+        checkPMD
+            (
+             conn,
+             "insert into t_10_a( a ) values ( ? )\n",
+             "org.apache.derbyTesting.functionTests.tests.lang.Price",
+             java.sql.Types.JAVA_OBJECT,
+             "\"APP\".\"PRICE_09_A\"",
+             0,
+             0
+             );
+
+        //
+        // I don't know of any way to create a statement with a parameter
+        // whose type is an old-style object from Derby's system tables.
+        // If you figure out how to trick Derby into letting you do that,
+        // this would be a good place to assert the shape of the parameter
+        // meta data for that statement.
+        //
+    }
+
     ///////////////////////////////////////////////////////////////////////////////////
     //
     // PROCEDURES
@@ -653,6 +728,14 @@ public void test_08_triggerDependencies() throws Exception
     public static void oneArgPriceProc( Price price1 ) {}
     public static void twoArgPriceProc( Price price1, Price price2 ) {}
 
+    public static void changeCurrencyCode( String newCurrencyCode, Price[] price )
+    {
+        Price oldPrice = price[ 0 ];
+        Price newPrice = new Price( newCurrencyCode, oldPrice.amount, oldPrice.timeInstant );
+
+        price[ 0 ] = newPrice;
+    }
+
     ///////////////////////////////////////////////////////////////////////////////////
     //
     // MINIONS
@@ -703,4 +786,60 @@ private int getScalarInteger( PreparedStatement ps ) throws Exception
         return retval;
     }
 
+    /**
+     * Check the ResultSetMetaData for a query whose first column is a UDT.
+     */
+    private void checkRSMD
+        (
+         Connection conn,
+         String query,
+         String expectedClassName,
+         int expectedDisplaySize,
+         int expectedJDBCType,
+         String expectedSQLTypeName,
+         int expectedPrecision,
+         int expectedScale
+         ) throws Exception
+    {
+        PreparedStatement ps = conn.prepareStatement( query );
+        ResultSet rs = ps.executeQuery();
+        ResultSetMetaData rsmd = rs.getMetaData();
+
+        assertEquals( rsmd.getColumnClassName( 1 ), expectedClassName );
+        assertEquals( rsmd.getColumnDisplaySize( 1 ), expectedDisplaySize );
+        assertEquals( rsmd.getColumnType( 1 ), expectedJDBCType );
+        assertEquals( rsmd.getColumnTypeName( 1 ), expectedSQLTypeName );
+        assertEquals( rsmd.getPrecision( 1 ), expectedPrecision );
+        assertEquals( rsmd.getScale( 1 ), expectedScale );
+
+        rs.close();
+        ps.close();
+    }
+    
+    /**
+     * Check the ParameterMetaData for a statement whose first parameter is a UDT.
+     */
+    private void checkPMD
+        (
+         Connection conn,
+         String query,
+         String expectedClassName,
+         int expectedJDBCType,
+         String expectedSQLTypeName,
+         int expectedPrecision,
+         int expectedScale
+         ) throws Exception
+    {
+        PreparedStatement ps = conn.prepareStatement( query );
+        ParameterMetaData pmd = ps.getParameterMetaData();
+
+        assertEquals( pmd.getParameterClassName( 1 ), expectedClassName );
+        assertEquals( pmd.getParameterType( 1 ), expectedJDBCType );
+        assertEquals( pmd.getParameterTypeName( 1 ), expectedSQLTypeName );
+        assertEquals( pmd.getPrecision( 1 ), expectedPrecision );
+        assertEquals( pmd.getScale( 1 ), expectedScale );
+
+        ps.close();
+    }
+
 }
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/util/DerbyJUnitTest.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/util/DerbyJUnitTest.java
index 5943bf46..8918627d 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/util/DerbyJUnitTest.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/util/DerbyJUnitTest.java
@@ -65,6 +65,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	private	static	final	String	TABLE = "table";
 	private	static	final	String	FUNCTION = "function";
 	private	static	final	String	PROCEDURE = "procedure";
+	private	static	final	String	TYPE = "type";
 	
 	//
 	// These are properties for the Derby connection URL.
@@ -513,7 +514,7 @@ protected	static	void	truncateTable( Connection conn, String name )
 	 */
 	protected	static	void	dropTable( Connection conn, String name )
 	{
-		dropSchemaObject( conn, TABLE, name );
+		dropSchemaObject( conn, TABLE, name, false );
 	}
 
 	/**
@@ -527,7 +528,7 @@ protected	static	void	dropTable( Connection conn, String name )
 	 */
 	protected	static	void	dropFunction( Connection conn, String name )
 	{
-		dropSchemaObject( conn, FUNCTION, name );
+		dropSchemaObject( conn, FUNCTION, name, false );
 	}
 
 	/**
@@ -541,7 +542,21 @@ protected	static	void	dropFunction( Connection conn, String name )
 	 */
 	protected	static	void	dropProcedure( Connection conn, String name )
 	{
-		dropSchemaObject( conn, PROCEDURE, name );
+		dropSchemaObject( conn, PROCEDURE, name, false );
+	}
+
+	/**
+	 * <p>
+	 * Drop a UDT regardless of whether it exists. If the UDT does
+	 * not exist, don't log an error unless
+	 * running in debug mode. This method is to be used for reinitializing
+	 * a schema in case a previous test run failed to clean up after itself.
+	 * Do not use this method if you need to verify that the UDT really exists.
+	 * </p>
+	 */
+	protected	static	void	dropUDT( Connection conn, String name )
+	{
+		dropSchemaObject( conn, TYPE, name, true );
 	}
 
 	/**
@@ -553,12 +568,14 @@ protected	static	void	dropProcedure( Connection conn, String name )
 	 * Do not use this method if you need to verify that the object really exists.
 	 * </p>
 	 */
-	protected	static	void	dropSchemaObject( Connection conn, String genus, String objectName )
+	protected	static	void	dropSchemaObject( Connection conn, String genus, String objectName, boolean restrict )
 	{
 		PreparedStatement	ps = null;
 		
 		try {
-			ps = prepare( conn, "drop " + genus + " " + objectName );
+            String text = "drop " + genus + " " + objectName;
+            if ( restrict ) { text = text + " restrict"; }
+			ps = prepare( conn, text );
 
 			ps.execute();
 		}
