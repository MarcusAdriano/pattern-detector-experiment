diff --git a/mahout/trunk/core/src/main/java/org/apache/mahout/fpm/pfpgrowth/fpgrowth/FPGrowth.java b/mahout/trunk/core/src/main/java/org/apache/mahout/fpm/pfpgrowth/fpgrowth/FPGrowth.java
index 03b52315..b9b77867 100644
--- a/mahout/trunk/core/src/main/java/org/apache/mahout/fpm/pfpgrowth/fpgrowth/FPGrowth.java
+++ b/mahout/trunk/core/src/main/java/org/apache/mahout/fpm/pfpgrowth/fpgrowth/FPGrowth.java
@@ -50,18 +50,14 @@
 /**
  * Implementation of PFGrowth Algorithm with FP-Bonsai pruning
  *
- * Generic parameter A is the object type used as the cell items in a transaction list.
- *
- * @param <A>
- *          the type used
+ * @param <A> object type used as the cell items in a transaction list
  */
 public class FPGrowth<A extends Comparable<? super A>> {
 
   private static final Logger log = LoggerFactory.getLogger(FPGrowth.class);
 
-  public static List<Pair<String,TopKStringPatterns>> readFrequentPattern(FileSystem fs,
-    Configuration conf,
-    Path path) throws IOException {
+  public static List<Pair<String,TopKStringPatterns>> readFrequentPattern(FileSystem fs, Configuration conf, Path path)
+    throws IOException {
 
     List<Pair<String,TopKStringPatterns>> ret = new ArrayList<Pair<String,TopKStringPatterns>>();
     Writable key = new Text();
diff --git a/mahout/trunk/examples/src/main/java/org/apache/mahout/classifier/bayes/XmlInputFormat.java b/mahout/trunk/examples/src/main/java/org/apache/mahout/classifier/bayes/XmlInputFormat.java
index bfc2cf7c..6a3db647 100644
--- a/mahout/trunk/examples/src/main/java/org/apache/mahout/classifier/bayes/XmlInputFormat.java
+++ b/mahout/trunk/examples/src/main/java/org/apache/mahout/classifier/bayes/XmlInputFormat.java
@@ -18,6 +18,7 @@
 package org.apache.mahout.classifier.bayes;
 
 import java.io.IOException;
+import java.nio.charset.Charset;
 
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.FSDataInputStream;
@@ -31,22 +32,26 @@
 import org.apache.hadoop.mapreduce.TaskAttemptContext;
 import org.apache.hadoop.mapreduce.lib.input.FileSplit;
 import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * Reads records that are delimited by a specific begin/end tag.
  */
 public class XmlInputFormat extends TextInputFormat {
 
-  public static final String START_TAG_KEY = "xmlinput.start";
+  private static final Logger log = LoggerFactory.getLogger(XmlInputFormat.class);
 
+  public static final String START_TAG_KEY = "xmlinput.start";
   public static final String END_TAG_KEY = "xmlinput.end";
+  private static final Charset UTF8 = Charset.forName("UTF-8");
 
   @Override
-  public RecordReader<LongWritable, Text> createRecordReader(InputSplit split,
-      TaskAttemptContext context) {
+  public RecordReader<LongWritable, Text> createRecordReader(InputSplit split, TaskAttemptContext context) {
     try {
       return new XmlRecordReader((FileSplit) split, context.getConfiguration());
-    } catch (IOException e) {
+    } catch (IOException ioe) {
+      log.warn("Error while creating XmlRecordReader", ioe);
       return null;
     }
   }
@@ -57,25 +62,19 @@
    * 
    */
   public static class XmlRecordReader extends RecordReader<LongWritable, Text> {
-    private final byte[] startTag;
 
+    private final byte[] startTag;
     private final byte[] endTag;
-
     private final long start;
-
     private final long end;
-
     private final FSDataInputStream fsin;
-
     private final DataOutputBuffer buffer = new DataOutputBuffer();
-    
     private LongWritable currentKey;
-    
     private Text currentValue;
 
     public XmlRecordReader(FileSplit split, Configuration conf) throws IOException {
-      startTag = conf.get(START_TAG_KEY).getBytes("utf-8");
-      endTag = conf.get(END_TAG_KEY).getBytes("utf-8");
+      startTag = conf.get(START_TAG_KEY).getBytes(UTF8);
+      endTag = conf.get(END_TAG_KEY).getBytes(UTF8);
 
       // open the file and seek to the start of the split
       start = split.getStart();
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/common/DevURandomSeedGenerator.java b/mahout/trunk/math/src/main/java/org/apache/mahout/common/DevURandomSeedGenerator.java
index e197c0ff..f493f6d2 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/common/DevURandomSeedGenerator.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/common/DevURandomSeedGenerator.java
@@ -59,6 +59,7 @@
    * @return The requested number of random bytes, read directly from {@literal /dev/urandom}.
    * @throws SeedException If {@literal /dev/urandom} does not exist or is not accessible
    */
+  @Override
   public byte[] generateSeed(int length) throws SeedException {
     FileInputStream file = null;
     try {
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/common/FastRandomSeedGenerator.java b/mahout/trunk/math/src/main/java/org/apache/mahout/common/FastRandomSeedGenerator.java
index ef8c1e39..d3def281 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/common/FastRandomSeedGenerator.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/common/FastRandomSeedGenerator.java
@@ -40,6 +40,7 @@
    * @throws org.uncommons.maths.random.SeedException
    *          If a seed cannot be generated for any reason.
    */
+  @Override
   public byte[] generateSeed(int length) throws SeedException {
     SeedException savedException = null;
     for (SeedGenerator generator : generators) {
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractMatrix.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractMatrix.java
index 1d1ceafb..0da49789 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractMatrix.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractMatrix.java
@@ -40,30 +40,37 @@
 
   protected int[] cardinality = new int[2];
 
+  @Override
   public int columnSize() {
     return cardinality[COL];
   }
 
+  @Override
   public int rowSize() {
     return cardinality[ROW];
   }
 
+  @Override
   public int[] size() {
     return cardinality;
   }
 
+  @Override
   public Iterator<MatrixSlice> iterator() {
     return iterateAll();
   }
 
+  @Override
   public Iterator<MatrixSlice> iterateAll() {
     return new Iterator<MatrixSlice>() {
       private int slice;
 
+      @Override
       public boolean hasNext() {
         return slice < numSlices();
       }
 
+      @Override
       public MatrixSlice next() {
         if (slice >= numSlices()) {
           throw new NoSuchElementException();
@@ -72,6 +79,7 @@ public MatrixSlice next() {
         return new MatrixSlice(slice(i), i);
       }
 
+      @Override
       public void remove() {
         throw new UnsupportedOperationException("remove() not supported for Matrix iterator");
       }
@@ -91,10 +99,12 @@ protected Vector slice(int index) {
    * Abstracted out for the iterator
    * @return numRows() for row-based iterator, numColumns() for column-based.
    */
+  @Override
   public int numSlices() {
     return numRows();
   }
 
+  @Override
   public double get(String rowLabel, String columnLabel) {
     if (columnLabelBindings == null || rowLabelBindings == null) {
       throw new UnboundLabelException();
@@ -108,14 +118,17 @@ public double get(String rowLabel, String columnLabel) {
     return get(row, col);
   }
 
+  @Override
   public Map<String, Integer> getColumnLabelBindings() {
     return columnLabelBindings;
   }
 
+  @Override
   public Map<String, Integer> getRowLabelBindings() {
     return rowLabelBindings;
   }
 
+  @Override
   public void set(String rowLabel, double[] rowData) {
     if (columnLabelBindings == null) {
       throw new UnboundLabelException();
@@ -127,6 +140,7 @@ public void set(String rowLabel, double[] rowData) {
     set(row, rowData);
   }
 
+  @Override
   public void set(String rowLabel, int row, double[] rowData) {
     if (rowLabelBindings == null) {
       rowLabelBindings = new HashMap<String, Integer>();
@@ -135,6 +149,7 @@ public void set(String rowLabel, int row, double[] rowData) {
     set(row, rowData);
   }
 
+  @Override
   public void set(String rowLabel, String columnLabel, double value) {
     if (columnLabelBindings == null || rowLabelBindings == null) {
       throw new UnboundLabelException();
@@ -147,6 +162,7 @@ public void set(String rowLabel, String columnLabel, double value) {
     set(row, col, value);
   }
 
+  @Override
   public void set(String rowLabel, String columnLabel, int row, int column, double value) {
     if (rowLabelBindings == null) {
       rowLabelBindings = new HashMap<String, Integer>();
@@ -160,10 +176,12 @@ public void set(String rowLabel, String columnLabel, int row, int column, double
     set(row, column, value);
   }
 
+  @Override
   public void setColumnLabelBindings(Map<String, Integer> bindings) {
     columnLabelBindings = bindings;
   }
 
+  @Override
   public void setRowLabelBindings(Map<String, Integer> bindings) {
     rowLabelBindings = bindings;
   }
@@ -174,10 +192,12 @@ public void setRowLabelBindings(Map<String, Integer> bindings) {
   // index into int[2] for row value
   public static final int ROW = 0;
 
+  @Override
   public int numRows() {
     return size()[ROW];
   }
 
+  @Override
   public int numCols() {
     return size()[COL];
   }
@@ -186,6 +206,7 @@ public static Matrix decodeMatrix(String formatString) {
     return gson().fromJson(formatString, Matrix.class);
   }
 
+  @Override
   public String asFormatString() {
     return gson().toJson(this, Matrix.class);
   }
@@ -198,6 +219,7 @@ static Gson gson() {
     return builder.create();
   }
 
+  @Override
   public Matrix assign(double value) {
     int[] c = size();
     for (int row = 0; row < c[ROW]; row++) {
@@ -208,6 +230,7 @@ public Matrix assign(double value) {
     return this;
   }
 
+  @Override
   public Matrix assign(double[][] values) {
     int[] c = size();
     if (c[ROW] != values.length) {
@@ -225,6 +248,7 @@ public Matrix assign(double[][] values) {
     return this;
   }
 
+  @Override
   public Matrix assign(Matrix other, DoubleDoubleFunction function) {
     int[] c = size();
     int[] o = other.size();
@@ -243,6 +267,7 @@ public Matrix assign(Matrix other, DoubleDoubleFunction function) {
     return this;
   }
 
+  @Override
   public Matrix assign(Matrix other) {
     int[] c = size();
     int[] o = other.size();
@@ -260,6 +285,7 @@ public Matrix assign(Matrix other) {
     return this;
   }
 
+  @Override
   public Matrix assign(DoubleFunction function) {
     int[] c = size();
     for (int row = 0; row < c[ROW]; row++) {
@@ -276,6 +302,7 @@ public Matrix assign(DoubleFunction function) {
    * @param f The function to be applied to each row.
    * @return The vector of results.
    */
+  @Override
   public Vector aggregateRows(VectorFunction f) {
     Vector r = new DenseVector(numRows());
     int n = numRows();
@@ -290,6 +317,7 @@ public Vector aggregateRows(VectorFunction f) {
    * @param row  Which row to return.
    * @return A vector that references the desired row.
    */
+  @Override
   public Vector viewRow(int row) {
     return new MatrixVectorView(this, row, 0, 0, 1);
   }
@@ -300,6 +328,7 @@ public Vector viewRow(int row) {
    * @param column Which column to return.
    * @return A vector that references the desired column.
    */
+  @Override
   public Vector viewColumn(int column) {
     return new MatrixVectorView(this, 0, column, 1, 0);
   }
@@ -310,6 +339,7 @@ public Vector viewColumn(int column) {
    * @param f The function to be applied to each column.
    * @return The vector of results.
    */
+  @Override
   public Vector aggregateColumns(VectorFunction f) {
     Vector r = new DenseVector(numCols());
     for (int col = 0; col < numCols(); col++) {
@@ -325,14 +355,17 @@ public Vector aggregateColumns(VectorFunction f) {
    * @param mapper   A function to apply to each element.
    * @return The result.
    */
+  @Override
   public double aggregate(final DoubleDoubleFunction combiner, final DoubleFunction mapper) {
     return aggregateRows(new VectorFunction() {
+      @Override
       public double apply(Vector v) {
         return v.aggregate(combiner, mapper);
       }
     }).aggregate(combiner, Functions.IDENTITY);
   }
 
+  @Override
   public double determinant() {
     int[] card = size();
     int rowSize = card[ROW];
@@ -386,6 +419,7 @@ public Matrix clone() {
     return clone;
   }
 
+  @Override
   public Matrix divide(double x) {
     Matrix result = like();
     int[] c = size();
@@ -397,6 +431,7 @@ public Matrix divide(double x) {
     return result;
   }
 
+  @Override
   public double get(int row, int column) {
     int[] c = size();
     if (row < 0 || row >= c[ROW]) {
@@ -408,6 +443,7 @@ public double get(int row, int column) {
     return getQuick(row, column);
   }
 
+  @Override
   public Matrix minus(Matrix other) {
     int[] c = size();
     int[] o = other.size();
@@ -427,6 +463,7 @@ public Matrix minus(Matrix other) {
     return result;
   }
 
+  @Override
   public Matrix plus(double x) {
     Matrix result = like();
     int[] c = size();
@@ -438,6 +475,7 @@ public Matrix plus(double x) {
     return result;
   }
 
+  @Override
   public Matrix plus(Matrix other) {
     int[] c = size();
     int[] o = other.size();
@@ -457,6 +495,7 @@ public Matrix plus(Matrix other) {
     return result;
   }
 
+  @Override
   public void set(int row, int column, double value) {
     int[] c = size();
     if (row < 0 || row >= c[ROW]) {
@@ -468,6 +507,7 @@ public void set(int row, int column, double value) {
     setQuick(row, column, value);
   }
 
+  @Override
   public void set(int row, double[] data) {
     int[] c = size();
     if (c[COL] < data.length) {
@@ -482,6 +522,7 @@ public void set(int row, double[] data) {
     }
   }
 
+  @Override
   public Matrix times(double x) {
     Matrix result = like();
     int[] c = size();
@@ -493,6 +534,7 @@ public Matrix times(double x) {
     return result;
   }
 
+  @Override
   public Matrix times(Matrix other) {
     int[] c = size();
     int[] o = other.size();
@@ -512,6 +554,7 @@ public Matrix times(Matrix other) {
     return result;
   }
 
+  @Override
   public Vector times(Vector v) {
     int[] c = size();
     if (c[COL] != v.size()) {
@@ -524,6 +567,7 @@ public Vector times(Vector v) {
     return w;
   }
 
+  @Override
   public Vector timesSquared(Vector v) {
     int[] c = size();
     if (c[COL] != v.size()) {
@@ -541,6 +585,7 @@ public Vector timesSquared(Vector v) {
     return w;
   }
 
+  @Override
   public Matrix transpose() {
     int[] card = size();
     Matrix result = like(card[COL], card[ROW]);
@@ -552,10 +597,12 @@ public Matrix transpose() {
     return result;
   }
 
+  @Override
   public Matrix viewPart(int rowOffset, int rowsRequested, int columnOffset, int columnsRequested) {
     return viewPart(new int[]{rowOffset, columnOffset}, new int[]{rowsRequested, columnsRequested});
   }
 
+  @Override
   public double zSum() {
     double result = 0;
     int[] c = size();
@@ -593,10 +640,12 @@ public Vector clone() {
       return v;
     }
 
+    @Override
     public boolean isDense() {
       return true;
     }
 
+    @Override
     public boolean isSequentialAccess() {
       return true;
     }
@@ -606,13 +655,16 @@ protected Matrix matrixLike(int rows, int columns) {
       return matrix.like(rows, columns);
     }
 
+    @Override
     public Iterator<Element> iterator() {
       return new Iterator<Element>() {
         private int i;
+        @Override
         public boolean hasNext() {
           return i < size();
         }
 
+        @Override
         public Element next() {
           if (i >= size()) {
             throw new NoSuchElementException();
@@ -620,6 +672,7 @@ public Element next() {
           return getElement(i++);
         }
 
+        @Override
         public void remove() {
           throw new UnsupportedOperationException("Element removal not supported");
         }
@@ -631,6 +684,7 @@ public void remove() {
      * TODO: This could be optimized to at least skip empty rows if there are many of them.
      * @return an iterator (currently dense).
      */
+    @Override
     public Iterator<Element> iterateNonZero() {
       return iterator();
     }
@@ -638,25 +692,30 @@ public void remove() {
     @Override
     public Element getElement(final int i) {
       return new Element() {
+        @Override
         public double get() {
           return getQuick(i);
         }
 
+        @Override
         public int index() {
           return i;
         }
 
+        @Override
         public void set(double value) {
           setQuick(i, value);
         }
       };
     }
 
+    @Override
     public double getQuick(int index) {
       Vector v = rowToColumn ? matrix.getRow(index) : matrix.getColumn(index);
       return v == null ? 0 : v.getQuick(transposeOffset);
     }
 
+    @Override
     public void setQuick(int index, double value) {
       Vector v = rowToColumn ? matrix.getRow(index) : matrix.getColumn(index);
       if (v == null) {
@@ -670,6 +729,7 @@ protected Vector newVector(int cardinality) {
       return new DenseVector(cardinality);
     }
 
+    @Override
     public Vector like() {
       return new DenseVector(size());
     }
@@ -683,6 +743,7 @@ public Vector like(int cardinality) {
      *
      * @return the number of nonzero entries
      */
+    @Override
     public int getNumNondefaultElements() {
       return size();
     }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractVector.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractVector.java
index 57a3baa3..9b92ab23 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractVector.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractVector.java
@@ -35,6 +35,7 @@ protected AbstractVector(int size) {
     this.size = size;
   }
 
+  @Override
   public double aggregate(DoubleDoubleFunction aggregator, DoubleFunction map) {
     if (size < 1) {
       throw new IllegalArgumentException("Cannot aggregate empty vector");
@@ -46,6 +47,7 @@ public double aggregate(DoubleDoubleFunction aggregator, DoubleFunction map) {
     return result;
   }
 
+  @Override
   public double aggregate(Vector other, DoubleDoubleFunction aggregator, DoubleDoubleFunction combiner) {
     if (size < 1) {
       throw new IllegalArgumentException("Cannot aggregate empty vector");
@@ -66,6 +68,7 @@ public double aggregate(Vector other, DoubleDoubleFunction aggregator, DoubleDou
    */
   protected abstract Matrix matrixLike(int rows, int columns);
 
+  @Override
   public Vector viewPart(int offset, int length) {
     if (offset < 0) {
       throw new IndexException(offset, size);
@@ -88,6 +91,7 @@ public Vector clone() {
     }
   }
 
+  @Override
   public Vector divide(double x) {
     if (x == 1.0) {
       return like().assign(this);
@@ -101,6 +105,7 @@ public Vector divide(double x) {
     return result;
   }
 
+  @Override
   public double dot(Vector x) {
     if (size != x.size()) {
       throw new CardinalityException(size, x.size());
@@ -127,6 +132,7 @@ public double dotSelf() {
     return result;
   }
 
+  @Override
   public double get(int index) {
     if (index < 0 || index >= size) {
       throw new IndexException(index, size);
@@ -134,10 +140,12 @@ public double get(int index) {
     return getQuick(index);
   }
 
+  @Override
   public Element getElement(int index) {
     return new LocalElement(index);
   }
 
+  @Override
   public Vector minus(Vector that) {
     if (size != that.size()) {
       throw new CardinalityException(size, that.size());
@@ -154,18 +162,22 @@ public Vector minus(Vector that) {
     return result;
   }
 
+  @Override
   public Vector normalize() {
     return divide(Math.sqrt(dotSelf()));
   }
 
+  @Override
   public Vector normalize(double power) {
     return divide(norm(power));
   }
   
+  @Override
   public Vector logNormalize() {
     return logNormalize(2.0, Math.sqrt(dotSelf()));
   }
   
+  @Override
   public Vector logNormalize(double power) {
     return logNormalize(power, norm(power));
   }
@@ -186,6 +198,7 @@ public Vector logNormalize(double power, double normLength) {
     }
   }
 
+  @Override
   public double norm(double power) {
     if (power < 0.0) {
       throw new IllegalArgumentException("Power must be >= 0");
@@ -226,6 +239,7 @@ public double norm(double power) {
     }
   }
 
+  @Override
   public double getLengthSquared() {
     if (lengthSquared >= 0.0) {
       return lengthSquared;
@@ -233,6 +247,7 @@ public double getLengthSquared() {
     return lengthSquared = dotSelf();
   }
 
+  @Override
   public double getDistanceSquared(Vector v) {
     if (size != v.size()) {
       throw new CardinalityException(size, v.size());
@@ -262,6 +277,7 @@ public double getDistanceSquared(Vector v) {
     return Math.abs(d);
   }
 
+  @Override
   public double maxValue() {
     double result = Double.NEGATIVE_INFINITY;
     int nonZeroElements = 0;
@@ -277,6 +293,7 @@ public double maxValue() {
     return result;
   }
   
+  @Override
   public int maxValueIndex() {
     int result = -1;
     double max = Double.NEGATIVE_INFINITY;
@@ -304,6 +321,7 @@ public int maxValueIndex() {
     return result;
   }
 
+  @Override
   public double minValue() {
     double result = Double.POSITIVE_INFINITY;
     int nonZeroElements = 0;
@@ -319,6 +337,7 @@ public double minValue() {
     return result;
   }
 
+  @Override
   public int minValueIndex() {
     int result = -1;
     double min = Double.POSITIVE_INFINITY;
@@ -346,6 +365,7 @@ public int minValueIndex() {
     return result;
   }
 
+  @Override
   public Vector plus(double x) {
     Vector result = like().assign(this);
     if (x == 0.0) {
@@ -358,6 +378,7 @@ public Vector plus(double x) {
     return result;
   }
 
+  @Override
   public Vector plus(Vector x) {
     if (size != x.size()) {
       throw new CardinalityException(size, x.size());
@@ -378,6 +399,7 @@ public Vector plus(Vector x) {
     return result;
   }
 
+  @Override
   public void addTo(Vector v) {
     Iterator<Element> it = iterateNonZero();
     while (it.hasNext()) {
@@ -387,6 +409,7 @@ public void addTo(Vector v) {
     }
   }
 
+  @Override
   public void set(int index, double value) {
     if (index < 0 || index >= size) {
       throw new IndexException(index, size);
@@ -394,6 +417,7 @@ public void set(int index, double value) {
     setQuick(index, value);
   }
 
+  @Override
   public Vector times(double x) {
     Vector result = like().assign(this);
     if (x == 1.0) {
@@ -411,6 +435,7 @@ public Vector times(double x) {
     return result;
   }
 
+  @Override
   public Vector times(Vector x) {
     if (size != x.size()) {
       throw new CardinalityException(size, x.size());
@@ -434,6 +459,7 @@ public Vector times(Vector x) {
     return result;
   }
 
+  @Override
   public double zSum() {
     double result = 0.0;
     Iterator<Element> iter = iterateNonZero();
@@ -444,6 +470,7 @@ public double zSum() {
     return result;
   }
 
+  @Override
   public Vector assign(double value) {
     for (int i = 0; i < size; i++) {
       setQuick(i, value);
@@ -451,6 +478,7 @@ public Vector assign(double value) {
     return this;
   }
 
+  @Override
   public Vector assign(double[] values) {
     if (size != values.length) {
       throw new CardinalityException(size, values.length);
@@ -461,6 +489,7 @@ public Vector assign(double[] values) {
     return this;
   }
 
+  @Override
   public Vector assign(Vector other) {
     if (size != other.size()) {
       throw new CardinalityException(size, other.size());
@@ -471,6 +500,7 @@ public Vector assign(Vector other) {
     return this;
   }
 
+  @Override
   public Vector assign(DoubleDoubleFunction f, double y) {
     Iterator<Element> it = f.apply(0, y) == 0 ? iterateNonZero() : iterator();
     while (it.hasNext()) {
@@ -480,6 +510,7 @@ public Vector assign(DoubleDoubleFunction f, double y) {
     return this;
   }
 
+  @Override
   public Vector assign(DoubleFunction function) {
     Iterator<Element> it = function.apply(0) == 0 ? iterateNonZero() : iterator();
     while (it.hasNext()) {
@@ -489,6 +520,7 @@ public Vector assign(DoubleFunction function) {
     return this;
   }
 
+  @Override
   public Vector assign(Vector other, DoubleDoubleFunction function) {
     if (size != other.size()) {
       throw new CardinalityException(size, other.size());
@@ -499,6 +531,7 @@ public Vector assign(Vector other, DoubleDoubleFunction function) {
     return this;
   }
 
+  @Override
   public Matrix cross(Vector other) {
     Matrix result = matrixLike(size, other.size());
     for (int row = 0; row < size; row++) {
@@ -521,10 +554,12 @@ public static Vector decodeVector(String formattedString) {
     return gson.fromJson(formattedString, Vector.class);
   }
 
+  @Override
   public final int size() {
     return size;  
   }
 
+  @Override
   public String asFormatString() {
     GsonBuilder builder = new GsonBuilder();
     builder.registerTypeAdapter(Vector.class, new JsonVectorAdapter());
@@ -596,14 +631,17 @@ public String toString() {
       this.index = index;
     }
 
+    @Override
     public double get() {
       return getQuick(index);
     }
 
+    @Override
     public int index() {
       return index;
     }
 
+    @Override
     public void set(double value) {
       setQuick(index, value);
     }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/DenseMatrix.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/DenseMatrix.java
index 457fdad9..9e1f8f0f 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/DenseMatrix.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/DenseMatrix.java
@@ -68,26 +68,32 @@ public Matrix clone() {
     return clone;
   }
   
+  @Override
   public double getQuick(int row, int column) {
     return values[row][column];
   }
   
+  @Override
   public Matrix like() {
     return like(rowSize(), columnSize());
   }
   
+  @Override
   public Matrix like(int rows, int columns) {
     return new DenseMatrix(rows, columns);
   }
   
+  @Override
   public void setQuick(int row, int column, double value) {
     values[row][column] = value;
   }
   
+  @Override
   public int[] getNumNondefaultElements() {
     return size();
   }
   
+  @Override
   public Matrix viewPart(int[] offset, int[] size) {
     int rowOffset = offset[ROW];
     int rowsRequested = size[ROW];
@@ -134,6 +140,7 @@ public Matrix assign(DenseMatrix matrix) {
     return this;
   }
   
+  @Override
   public Matrix assignColumn(int column, Vector other) {
     if (rowSize() != other.size()) {
       throw new CardinalityException(rowSize(), other.size());
@@ -147,6 +154,7 @@ public Matrix assignColumn(int column, Vector other) {
     return this;
   }
   
+  @Override
   public Matrix assignRow(int row, Vector other) {
     if (columnSize() != other.size()) {
       throw new CardinalityException(columnSize(), other.size());
@@ -160,6 +168,7 @@ public Matrix assignRow(int row, Vector other) {
     return this;
   }
   
+  @Override
   public Vector getColumn(int column) {
     if (column < 0 || column >= columnSize()) {
       throw new IndexException(column, columnSize());
@@ -167,6 +176,7 @@ public Vector getColumn(int column) {
     return new TransposeViewVector(this, column);
   }
   
+  @Override
   public Vector getRow(int row) {
     if (row < 0 || row >= rowSize()) {
       throw new IndexException(row, rowSize());
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/DenseVector.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/DenseVector.java
index 6745af02..7aa46320 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/DenseVector.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/DenseVector.java
@@ -81,6 +81,7 @@ public DenseVector clone() {
   /**
    * @return true
    */
+  @Override
   public boolean isDense() {
     return true;
   }
@@ -88,6 +89,7 @@ public boolean isDense() {
   /**
    * @return true
    */
+  @Override
   public boolean isSequentialAccess() {
     return true;
   }
@@ -103,14 +105,17 @@ public double dotSelf() {
     return result;
   }
 
+  @Override
   public double getQuick(int index) {
     return values[index];
   }
 
+  @Override
   public DenseVector like() {
     return new DenseVector(size());
   }
 
+  @Override
   public void setQuick(int index, double value) {
     lengthSquared = -1.0;
     values[index] = value;
@@ -154,6 +159,7 @@ public Vector assign(DenseVector vector) {
     return this;
   }
 
+  @Override
   public int getNumNondefaultElements() {
     return values.length;
   }
@@ -172,10 +178,12 @@ public Vector viewPart(int offset, int length) {
   /**
    * Returns an iterator that traverses this Vector from 0 to cardinality-1, in that order.
    */
+  @Override
   public Iterator<Element> iterateNonZero() {
     return new NonDefaultIterator();
   }
 
+  @Override
   public Iterator<Element> iterator() {
     return new AllIterator();
   }
@@ -269,10 +277,12 @@ private void goToNext() {
       }
     }
 
+    @Override
     public boolean hasNext() {
       return index < size();
     }
 
+    @Override
     public Element next() {
       if (index >= size()) {
         throw new NoSuchElementException();
@@ -284,6 +294,7 @@ public Element next() {
       }
     }
 
+    @Override
     public void remove() {
       throw new UnsupportedOperationException();
     }
@@ -297,10 +308,12 @@ private AllIterator() {
       element.index = -1;
     }
 
+    @Override
     public boolean hasNext() {
       return element.index + 1 < size();
     }
 
+    @Override
     public Element next() {
       if (element.index + 1 >= size()) {
         throw new NoSuchElementException();
@@ -310,6 +323,7 @@ public Element next() {
       }
     }
 
+    @Override
     public void remove() {
       throw new UnsupportedOperationException();
     }
@@ -319,14 +333,17 @@ public void remove() {
 
     int index;
 
+    @Override
     public double get() {
       return values[index];
     }
 
+    @Override
     public int index() {
       return index;
     }
 
+    @Override
     public void set(double value) {
       lengthSquared = -1;
       values[index] = value;
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/JsonMatrixAdapter.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/JsonMatrixAdapter.java
index 422c2115..aff69bf0 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/JsonMatrixAdapter.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/JsonMatrixAdapter.java
@@ -33,6 +33,7 @@
   public static final String CLASS = "class";
   public static final String MATRIX = "matrix";
 
+  @Override
   public JsonElement serialize(Matrix src, Type typeOfSrc,
                                JsonSerializationContext context) {
     JsonObject obj = new JsonObject();
@@ -41,6 +42,7 @@ public JsonElement serialize(Matrix src, Type typeOfSrc,
     return obj;
   }
 
+  @Override
   public Matrix deserialize(JsonElement json, Type typeOfT,
                             JsonDeserializationContext context) {
     JsonObject obj = json.getAsJsonObject();
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/JsonVectorAdapter.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/JsonVectorAdapter.java
index 5d7cd67f..64a24692 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/JsonVectorAdapter.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/JsonVectorAdapter.java
@@ -34,6 +34,7 @@
 
   public static final String VECTOR = "vector";
 
+  @Override
   public JsonElement serialize(Vector src, Type typeOfSrc,
                                JsonSerializationContext context) {
     GsonBuilder builder = new GsonBuilder();
@@ -45,6 +46,7 @@ public JsonElement serialize(Vector src, Type typeOfSrc,
     return obj;
   }
 
+  @Override
   public Vector deserialize(JsonElement json, Type typeOfT,
                             JsonDeserializationContext context) {
     GsonBuilder builder = new GsonBuilder();
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/MatrixVectorView.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/MatrixVectorView.java
index b8b632df..ab2ec72c 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/MatrixVectorView.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/MatrixVectorView.java
@@ -55,6 +55,7 @@ private static int viewSize(Matrix matrix, int row, int column, int rowStride, i
    * @return true iff the {@link Vector} implementation should be considered
    *         dense -- that it explicitly represents every value
    */
+  @Override
   public boolean isDense() {
     return true;
   }
@@ -64,6 +65,7 @@ public boolean isDense() {
    *         index order in an efficient way. In particular this implies that {@link #iterator()} and
    *         {@link #iterateNonZero()} return elements in ascending order by index.
    */
+  @Override
   public boolean isSequentialAccess() {
     return true;
   }
@@ -75,15 +77,18 @@ public boolean isSequentialAccess() {
    *
    * @return An {@link java.util.Iterator} over all elements
    */
+  @Override
   public Iterator<Element> iterator() {
     final LocalElement r = new LocalElement(0);
     return new Iterator<Element>() {
       private int i;
 
+      @Override
       public boolean hasNext() {
         return i < size();
       }
 
+      @Override
       public Element next() {
         if (i >= size()) {
           throw new NoSuchElementException();
@@ -92,6 +97,7 @@ public Element next() {
         return r;
       }
 
+      @Override
       public void remove() {
         throw new UnsupportedOperationException("Can't remove from a view");
       }
@@ -105,6 +111,7 @@ public void remove() {
    *
    * @return An {@link java.util.Iterator} over all non-zero elements
    */
+  @Override
   public Iterator<Element> iterateNonZero() {
     return iterator();
   }
@@ -115,6 +122,7 @@ public void remove() {
    * @param index an int index
    * @return the double at the index
    */
+  @Override
   public double getQuick(int index) {
     return matrix.getQuick(row + rowStride * index, column + columnStride * index);
   }
@@ -124,6 +132,7 @@ public double getQuick(int index) {
    *
    * @return a Vector
    */
+  @Override
   public Vector like() {
     return matrix.like(size(), 1).viewColumn(0);
   }
@@ -134,6 +143,7 @@ public Vector like() {
    * @param index an int index into the receiver
    * @param value a double value to set
    */
+  @Override
   public void setQuick(int index, double value) {
     matrix.setQuick(row + rowStride * index, column + columnStride * index, value);
   }
@@ -143,6 +153,7 @@ public void setQuick(int index, double value) {
    *
    * @return an int
    */
+  @Override
   public int getNumNondefaultElements() {
     return size();
   }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/MatrixView.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/MatrixView.java
index 2073b9cb..780a1084 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/MatrixView.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/MatrixView.java
@@ -69,26 +69,32 @@ public Matrix clone() {
     return clone;
   }
 
+  @Override
   public double getQuick(int row, int column) {
     return matrix.getQuick(offset[ROW] + row, offset[COL] + column);
   }
 
+  @Override
   public Matrix like() {
     return matrix.like(rowSize(), columnSize());
   }
 
+  @Override
   public Matrix like(int rows, int columns) {
     return matrix.like(rows, columns);
   }
 
+  @Override
   public void setQuick(int row, int column, double value) {
     matrix.setQuick(offset[ROW] + row, offset[COL] + column, value);
   }
 
+  @Override
   public int[] getNumNondefaultElements() {
     return cardinality;
   }
 
+  @Override
   public Matrix viewPart(int[] offset, int[] size) {
     if (offset[ROW] < ROW) {
       throw new IndexException(offset[ROW], ROW);
@@ -108,6 +114,7 @@ public Matrix viewPart(int[] offset, int[] size) {
     return new MatrixView(matrix, origin, size);
   }
 
+  @Override
   public Matrix assignColumn(int column, Vector other) {
     if (rowSize() != other.size()) {
       throw new CardinalityException(rowSize(), other.size());
@@ -119,6 +126,7 @@ public Matrix assignColumn(int column, Vector other) {
     return this;
   }
 
+  @Override
   public Matrix assignRow(int row, Vector other) {
     if (columnSize() != other.size()) {
       throw new CardinalityException(columnSize(), other.size());
@@ -130,6 +138,7 @@ public Matrix assignRow(int row, Vector other) {
     return this;
   }
 
+  @Override
   public Vector getColumn(int column) {
     if (column < 0 || column >= columnSize()) {
       throw new IndexException(column, columnSize());
@@ -137,6 +146,7 @@ public Vector getColumn(int column) {
     return new VectorView(matrix.getColumn(column + offset[COL]), offset[ROW], rowSize());
   }
 
+  @Override
   public Vector getRow(int row) {
     if (row < 0 || row >= rowSize()) {
       throw new IndexException(row, rowSize());
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/NamedVector.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/NamedVector.java
index a85c1fb4..7003562c 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/NamedVector.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/NamedVector.java
@@ -70,6 +70,7 @@ public NamedVector clone() {
     return new NamedVector(delegate.clone(), name);
   }
 
+  @Override
   public String asFormatString() {
     GsonBuilder builder = new GsonBuilder();
     builder.registerTypeAdapter(Vector.class, new JsonVectorAdapter());
@@ -77,170 +78,212 @@ public String asFormatString() {
     return gson.toJson(this, Vector.class);
   }
 
+  @Override
   public Vector assign(double value) {
     return delegate.assign(value);
   }
 
+  @Override
   public Vector assign(double[] values) {
     return delegate.assign(values);
   }
 
+  @Override
   public Vector assign(Vector other) {
     return delegate.assign(other);
   }
 
+  @Override
   public Vector assign(DoubleFunction function) {
     return delegate.assign(function);
   }
 
+  @Override
   public Vector assign(Vector other, DoubleDoubleFunction function) {
     return delegate.assign(other, function);
   }
 
+  @Override
   public Vector assign(DoubleDoubleFunction f, double y) {
     return delegate.assign(f, y);
   }
 
+  @Override
   public int size() {
     return delegate.size();
   }
 
+  @Override
   public boolean isDense() {
     return delegate.isDense();
   }
 
+  @Override
   public boolean isSequentialAccess() {
     return delegate.isSequentialAccess();
   }
 
+  @Override
   public Iterator<Element> iterator() {
     return delegate.iterator();
   }
 
+  @Override
   public Iterator<Element> iterateNonZero() {
     return delegate.iterateNonZero();
   }
 
+  @Override
   public Element getElement(int index) {
     return delegate.getElement(index);
   }
 
+  @Override
   public Vector divide(double x) {
     return delegate.divide(x);
   }
 
+  @Override
   public double dot(Vector x) {
     return delegate.dot(x);
   }
 
+  @Override
   public double get(int index) {
     return delegate.get(index);
   }
 
+  @Override
   public double getQuick(int index) {
     return delegate.getQuick(index);
   }
 
+  @Override
   public NamedVector like() {
     return new NamedVector(delegate.like(), name);
   }
 
+  @Override
   public Vector minus(Vector x) {
     return delegate.minus(x);
   }
 
+  @Override
   public Vector normalize() {
     return delegate.normalize();
   }
 
+  @Override
   public Vector normalize(double power) {
     return delegate.normalize(power);
   }
 
+  @Override
   public Vector logNormalize() {
     return delegate.logNormalize();
   }
 
+  @Override
   public Vector logNormalize(double power) {
     return delegate.logNormalize(power);
   }
 
+  @Override
   public double norm(double power) {
     return delegate.norm(power);
   }
 
+  @Override
   public double maxValue() {
     return delegate.maxValue();
   }
 
+  @Override
   public int maxValueIndex() {
     return delegate.maxValueIndex();
   }
 
+  @Override
   public double minValue() {
     return delegate.minValue();
   }
 
+  @Override
   public int minValueIndex() {
     return delegate.minValueIndex();
   }
 
+  @Override
   public Vector plus(double x) {
     return delegate.plus(x);
   }
 
+  @Override
   public Vector plus(Vector x) {
     return delegate.plus(x);
   }
 
+  @Override
   public void set(int index, double value) {
     delegate.set(index, value);
   }
 
+  @Override
   public void setQuick(int index, double value) {
     delegate.setQuick(index, value);
   }
 
+  @Override
   public int getNumNondefaultElements() {
     return delegate.getNumNondefaultElements();
   }
 
+  @Override
   public Vector times(double x) {
     return delegate.times(x);
   }
 
+  @Override
   public Vector times(Vector x) {
     return delegate.times(x);
   }
 
+  @Override
   public Vector viewPart(int offset, int length) {
     return delegate.viewPart(offset, length);
   }
 
+  @Override
   public double zSum() {
     return delegate.zSum();
   }
 
+  @Override
   public Matrix cross(Vector other) {
     return delegate.cross(other);
   }
 
+  @Override
   public double aggregate(DoubleDoubleFunction aggregator, DoubleFunction map) {
     return delegate.aggregate(aggregator, map);
   }
 
+  @Override
   public double aggregate(Vector other, DoubleDoubleFunction aggregator, DoubleDoubleFunction combiner) {
     return delegate.aggregate(other, aggregator, combiner);
   }
 
+  @Override
   public double getLengthSquared() {
     return delegate.getLengthSquared();
   }
 
+  @Override
   public double getDistanceSquared(Vector v) {
     return delegate.getDistanceSquared(v);
   }
 
+  @Override
   public void addTo(Vector v) {
     delegate.addTo(v);
   }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/RandomAccessSparseVector.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/RandomAccessSparseVector.java
index d259de88..1fbfbbdd 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/RandomAccessSparseVector.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/RandomAccessSparseVector.java
@@ -111,6 +111,7 @@ public Vector assign(Vector other) {
   /**
    * @return false
    */
+  @Override
   public boolean isDense() {
     return false;
   }
@@ -118,14 +119,17 @@ public boolean isDense() {
   /**
    * @return false
    */
+  @Override
   public boolean isSequentialAccess() {
     return false;
   }
 
+  @Override
   public double getQuick(int index) {
     return values.get(index);
   }
 
+  @Override
   public void setQuick(int index, double value) {
     lengthSquared = -1.0;
     if (value == 0.0) {
@@ -135,10 +139,12 @@ public void setQuick(int index, double value) {
     }
   }
 
+  @Override
   public int getNumNondefaultElements() {
     return values.size();
   }
 
+  @Override
   public RandomAccessSparseVector like() {
     return new RandomAccessSparseVector(size(), values.size());
   }
@@ -150,10 +156,12 @@ public RandomAccessSparseVector like() {
    * @return an {@link Iterator} over the Elements.
    * @see #getElement(int)
    */
+  @Override
   public Iterator<Element> iterateNonZero() {
     return new NonDefaultIterator();
   }
   
+  @Override
   public Iterator<Element> iterator() {
     return new AllIterator();
   }
@@ -199,6 +207,7 @@ public double dot(Vector x) {
     private AddToVector(Vector v) {
       this.v = v;
     }
+    @Override
     public boolean apply(int key, double value) {
       v.set(key, value + v.get(key));
       return true;
@@ -215,10 +224,12 @@ private NonDefaultIterator() {
       values.keys(indices);
     }
 
+    @Override
     public boolean hasNext() {
       return offset < indices.size();
     }
 
+    @Override
     public Element next() {
       if (offset >= indices.size()) {
         throw new NoSuchElementException();
@@ -229,6 +240,7 @@ public Element next() {
       }
     }
 
+    @Override
     public void remove() {
       throw new UnsupportedOperationException();
     }
@@ -242,10 +254,12 @@ private AllIterator() {
       element.index = -1;
     }
 
+    @Override
     public boolean hasNext() {
       return element.index + 1 < size();
     }
 
+    @Override
     public Element next() {
       if (element.index + 1 >= size()) {
         throw new NoSuchElementException();
@@ -255,6 +269,7 @@ public Element next() {
       }
     }
 
+    @Override
     public void remove() {
       throw new UnsupportedOperationException();
     }
@@ -264,14 +279,17 @@ public void remove() {
 
     int index;
 
+    @Override
     public double get() {
       return values.get(index);
     }
 
+    @Override
     public int index() {
       return index;
     }
 
+    @Override
     public void set(double value) {
       lengthSquared = -1;
       if (value == 0.0) {
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/SequentialAccessSparseVector.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/SequentialAccessSparseVector.java
index 2c226a0c..0c9e59c9 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/SequentialAccessSparseVector.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/SequentialAccessSparseVector.java
@@ -136,6 +136,7 @@ public String toString() {
   /**
    * @return false
    */
+  @Override
   public boolean isDense() {
     return false;
   }
@@ -143,31 +144,38 @@ public boolean isDense() {
   /**
    * @return true
    */
+  @Override
   public boolean isSequentialAccess() {
     return true;
   }
 
+  @Override
   public double getQuick(int index) {
     return values.get(index);
   }
 
+  @Override
   public void setQuick(int index, double value) {
     lengthSquared = -1;
     values.set(index, value);
   }
 
+  @Override
   public int getNumNondefaultElements() {
     return values.getNumMappings();
   }
 
+  @Override
   public SequentialAccessSparseVector like() {
     return new SequentialAccessSparseVector(size(), values.getNumMappings());
   }
 
+  @Override
   public Iterator<Element> iterateNonZero() {
     return new NonDefaultIterator();
   }
 
+  @Override
   public Iterator<Element> iterator() {
     return new AllIterator();
   }
@@ -245,11 +253,13 @@ public Vector minus(Vector that) {
 
     private final NonDefaultElement element = new NonDefaultElement();
 
+    @Override
     public boolean hasNext() {
       int numMappings = values.getNumMappings();
       return numMappings > 0 && element.getNextOffset() < numMappings;
     }
 
+    @Override
     public Element next() {
       if (!hasNext()) {
         throw new NoSuchElementException();
@@ -258,6 +268,7 @@ public Element next() {
       return element;
     }
 
+    @Override
     public void remove() {
       throw new UnsupportedOperationException();
     }
@@ -267,11 +278,13 @@ public void remove() {
 
     private final AllElement element = new AllElement();
 
+    @Override
     public boolean hasNext() {
       int numMappings = values.getNumMappings();
       return numMappings > 0 && element.getNextIndex() <= values.getIndices()[numMappings - 1];
     }
 
+    @Override
     public Element next() {
       if (!hasNext()) {
         throw new NoSuchElementException();
@@ -280,6 +293,7 @@ public Element next() {
       return element;
     }
 
+    @Override
     public void remove() {
       throw new UnsupportedOperationException();
     }
@@ -297,14 +311,17 @@ int getNextOffset() {
       return offset + 1;
     }
 
+    @Override
     public double get() {
       return values.getValues()[offset];
     }
 
+    @Override
     public int index() {
       return values.getIndices()[offset];
     }
 
+    @Override
     public void set(double value) {
       lengthSquared = -1;      
       values.getValues()[offset] = value;
@@ -327,6 +344,7 @@ int getNextIndex() {
       return index + 1;
     }
 
+    @Override
     public double get() {
       if (index == values.getIndices()[nextOffset]) {
         return values.getValues()[nextOffset];
@@ -334,10 +352,12 @@ public double get() {
       return OrderedIntDoubleMapping.DEFAULT_VALUE;
     }
 
+    @Override
     public int index() {
       return index;
     }
 
+    @Override
     public void set(double value) {
       lengthSquared = -1;      
       if (index == values.getIndices()[nextOffset]) {
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/SparseColumnMatrix.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/SparseColumnMatrix.java
index 9a7284b6..ae9b73c7 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/SparseColumnMatrix.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/SparseColumnMatrix.java
@@ -84,14 +84,17 @@ public int numSlices() {
     return numCols();
   }
 
+  @Override
   public double getQuick(int row, int column) {
     return columns[column] == null ? 0.0 : columns[column].getQuick(row);
   }
 
+  @Override
   public Matrix like() {
     return new SparseColumnMatrix(cardinality);
   }
 
+  @Override
   public Matrix like(int rows, int columns) {
     int[] c = new int[2];
     c[ROW] = rows;
@@ -99,6 +102,7 @@ public Matrix like(int rows, int columns) {
     return new SparseColumnMatrix(c);
   }
 
+  @Override
   public void setQuick(int row, int column, double value) {
     if (columns[column] == null) {
       columns[column] = new RandomAccessSparseVector(cardinality[ROW]);
@@ -106,6 +110,7 @@ public void setQuick(int row, int column, double value) {
     columns[column].setQuick(row, value);
   }
 
+  @Override
   public int[] getNumNondefaultElements() {
     int[] result = new int[2];
     result[COL] = columns.length;
@@ -116,6 +121,7 @@ public void setQuick(int row, int column, double value) {
     return result;
   }
 
+  @Override
   public Matrix viewPart(int[] offset, int[] size) {
     if (offset[ROW] < 0) {
       throw new IndexException(offset[ROW], columns[COL].size());
@@ -132,6 +138,7 @@ public Matrix viewPart(int[] offset, int[] size) {
     return new MatrixView(this, offset, size);
   }
 
+  @Override
   public Matrix assignColumn(int column, Vector other) {
     if (cardinality[ROW] != other.size()) {
       throw new CardinalityException(cardinality[ROW], other.size());
@@ -143,6 +150,7 @@ public Matrix assignColumn(int column, Vector other) {
     return this;
   }
 
+  @Override
   public Matrix assignRow(int row, Vector other) {
     if (cardinality[COL] != other.size()) {
       throw new CardinalityException(cardinality[COL], other.size());
@@ -156,6 +164,7 @@ public Matrix assignRow(int row, Vector other) {
     return this;
   }
 
+  @Override
   public Vector getColumn(int column) {
     if (column < 0 || column >= cardinality[COL]) {
       throw new IndexException(column, cardinality[COL]);
@@ -163,6 +172,7 @@ public Vector getColumn(int column) {
     return columns[column];
   }
 
+  @Override
   public Vector getRow(int row) {
     if (row < 0 || row >= cardinality[ROW]) {
       throw new IndexException(row, cardinality[ROW]);
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/SparseMatrix.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/SparseMatrix.java
index 8a22c8bf..3ad64cae 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/SparseMatrix.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/SparseMatrix.java
@@ -71,19 +71,23 @@ public Matrix clone() {
     return clone;
   }
   
+  @Override
   public double getQuick(int row, int column) {
     Vector r = rows.get(row);
     return r == null ? 0.0 : r.getQuick(column);
   }
   
+  @Override
   public Matrix like() {
     return new SparseMatrix(cardinality);
   }
   
+  @Override
   public Matrix like(int rows, int columns) {
     return new SparseMatrix(new int[] {rows, columns});
   }
   
+  @Override
   public void setQuick(int row, int column, double value) {
     Vector r = rows.get(row);
     if (r == null) {
@@ -93,6 +97,7 @@ public void setQuick(int row, int column, double value) {
     r.setQuick(column, value);
   }
   
+  @Override
   public int[] getNumNondefaultElements() {
     int[] result = new int[2];
     result[ROW] = rows.size();
@@ -103,6 +108,7 @@ public void setQuick(int row, int column, double value) {
     return result;
   }
   
+  @Override
   public Matrix viewPart(int[] offset, int[] size) {
     if (offset[ROW] < 0) {
       throw new IndexException(offset[ROW], cardinality[ROW]);
@@ -119,6 +125,7 @@ public Matrix viewPart(int[] offset, int[] size) {
     return new MatrixView(this, offset, size);
   }
   
+  @Override
   public Matrix assignColumn(int column, Vector other) {
     if (cardinality[ROW] != other.size()) {
       throw new CardinalityException(cardinality[ROW], other.size());
@@ -140,6 +147,7 @@ public Matrix assignColumn(int column, Vector other) {
     return this;
   }
   
+  @Override
   public Matrix assignRow(int row, Vector other) {
     if (cardinality[COL] != other.size()) {
       throw new CardinalityException(cardinality[COL], other.size());
@@ -151,6 +159,7 @@ public Matrix assignRow(int row, Vector other) {
     return this;
   }
   
+  @Override
   public Vector getColumn(int column) {
     if (column < 0 || column >= cardinality[COL]) {
       throw new IndexException(column, cardinality[COL]);
@@ -162,6 +171,7 @@ public Vector getColumn(int column) {
     return new DenseVector(d);
   }
   
+  @Override
   public Vector getRow(int row) {
     if (row < 0 || row >= cardinality[ROW]) {
       throw new IndexException(row, cardinality[ROW]);
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/SparseRowMatrix.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/SparseRowMatrix.java
index 0dd56f2e..0b61df9c 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/SparseRowMatrix.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/SparseRowMatrix.java
@@ -81,14 +81,17 @@ public Matrix clone() {
     return clone;
   }
 
+  @Override
   public double getQuick(int row, int column) {
     return rows[row] == null ? 0.0 : rows[row].getQuick(column);
   }
 
+  @Override
   public Matrix like() {
     return new SparseRowMatrix(cardinality, randomAccessRows);
   }
 
+  @Override
   public Matrix like(int rows, int columns) {
     int[] c = new int[2];
     c[ROW] = rows;
@@ -96,10 +99,12 @@ public Matrix like(int rows, int columns) {
     return new SparseRowMatrix(c, randomAccessRows);
   }
 
+  @Override
   public void setQuick(int row, int column, double value) {
     rows[row].setQuick(column, value);
   }
 
+  @Override
   public int[] getNumNondefaultElements() {
     int[] result = new int[2];
     result[ROW] = rows.length;
@@ -109,6 +114,7 @@ public void setQuick(int row, int column, double value) {
     return result;
   }
 
+  @Override
   public Matrix viewPart(int[] offset, int[] size) {
     if (offset[ROW] < 0) {
       throw new IndexException(offset[ROW], rows.length);
@@ -125,6 +131,7 @@ public Matrix viewPart(int[] offset, int[] size) {
     return new MatrixView(this, offset, size);
   }
 
+  @Override
   public Matrix assignColumn(int column, Vector other) {
     if (cardinality[ROW] != other.size()) {
       throw new CardinalityException(cardinality[ROW], other.size());
@@ -138,6 +145,7 @@ public Matrix assignColumn(int column, Vector other) {
     return this;
   }
 
+  @Override
   public Matrix assignRow(int row, Vector other) {
     if (cardinality[COL] != other.size()) {
       throw new CardinalityException(cardinality[COL], other.size());
@@ -154,6 +162,7 @@ public Matrix assignRow(int row, Vector other) {
    * @param column an int column index
    * @return a shallow view of the column
    */
+  @Override
   public Vector getColumn(int column) {
     if (column < 0 || column >= cardinality[COL]) {
       throw new IndexException(column, cardinality[COL]);
@@ -173,6 +182,7 @@ protected Vector newVector(int cardinality) {
    * @param row an int row index
    * @return a shallow view of the Vector at specified row (ie you may mutate the original matrix using this row)
    */
+  @Override
   public Vector getRow(int row) {
     if (row < 0 || row >= cardinality[ROW]) {
       throw new IndexException(row, cardinality[ROW]);
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/Vector.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/Vector.java
index 151bb4da..fca30ab0 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/Vector.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/Vector.java
@@ -94,13 +94,13 @@
   int size();
 
   /**
-   * @return true iff the {@link Vector} implementation should be considered dense -- that it explicitly
+   * @return true iff this implementation should be considered dense -- that it explicitly
    *  represents every value
    */
   boolean isDense();
 
   /**
-   * @return true iff {@link Vector} should be considered to be iterable in index order in an efficient way.
+   * @return true iff this implementation should be considered to be iterable in index order in an efficient way.
    *  In particular this implies that {@link #iterator()} and {@link #iterateNonZero()} return elements
    *  in ascending order by index.
    */
@@ -119,6 +119,7 @@
    *
    * @return An {@link Iterator} over all elements
    */
+  @Override
   Iterator<Element> iterator();
 
   /**
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/VectorList.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/VectorList.java
index 96a8db16..c75f5b17 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/VectorList.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/VectorList.java
@@ -64,6 +64,7 @@ public int rowSize() {
     return cardinality;
   }
 
+  @Override
   public Matrix assignColumn(int column, Vector other) {
     if (other.size() != rowSize()) {
       throw new CardinalityException(rowSize(), other.size());
@@ -79,6 +80,7 @@ public Matrix assignColumn(int column, Vector other) {
     return this;
   }
 
+  @Override
   public Matrix assignRow(int row, Vector other) {
     if (other.size() != columns) {
       throw new CardinalityException(columns, other.size());
@@ -88,6 +90,7 @@ public Matrix assignRow(int row, Vector other) {
     return this;
   }
 
+  @Override
   public Vector getColumn(final int column) {
     if (column < 0 || column >= columnSize()) {
       throw new IndexException(column, columnSize());
@@ -98,14 +101,17 @@ protected Matrix matrixLike(int rows, int columns) {
         throw new UnsupportedOperationException("Can't get a matrix like a VectorList");
       }
 
+      @Override
       public boolean isDense() {
         return true;
       }
 
+      @Override
       public boolean isSequentialAccess() {
         return true;
       }
 
+      @Override
       public Iterator<Element> iterator() {
         return new AbstractIterator<Element>() {
           int i = 0;
@@ -118,14 +124,17 @@ protected Element computeNext() {
               return new Element() {
                 final int row = i++;
 
+                @Override
                 public double get() {
                   return VectorList.this.get(row, column);
                 }
 
+                @Override
                 public int index() {
                   return row;
                 }
 
+                @Override
                 public void set(double value) {
                   VectorList.this.setQuick(row, column, value);
                 }
@@ -135,22 +144,27 @@ public void set(double value) {
         };
       }
 
+      @Override
       public Iterator<Element> iterateNonZero() {
         return iterator();
       }
 
+      @Override
       public double getQuick(int index) {
         return VectorList.this.getQuick(index, column);
       }
 
+      @Override
       public Vector like() {
         return new DenseVector(rowSize());
       }
 
+      @Override
       public void setQuick(int index, double value) {
         VectorList.this.setQuick(index, column, value);
       }
 
+      @Override
       public int getNumNondefaultElements() {
         return data.size();
       }
@@ -164,6 +178,7 @@ public int getNumNondefaultElements() {
    * @return a Vector at the index
    * @throws IndexException if the index is out of bounds
    */
+  @Override
   public Vector getRow(int row) {
     if (row < 0 || row >= rowSize()) {
       throw new IndexException(row, rowSize());
@@ -178,6 +193,7 @@ public Vector getRow(int row) {
    * @param column an int column index
    * @return the double at the index
    */
+  @Override
   public double getQuick(int row, int column) {
     return data.get(row).getQuick(column);
   }
@@ -187,6 +203,7 @@ public double getQuick(int row, int column) {
    *
    * @return a Matrix
    */
+  @Override
   public Matrix like() {
     VectorList r = new VectorList(columns);
     //int i = 0;
@@ -203,6 +220,7 @@ public Matrix like() {
    * @param rows    the int number of rows
    * @param columns the int number of columns
    */
+  @Override
   public Matrix like(int rows, int columns) {
     VectorList r = new VectorList(rows, columns);
     for (int i = 0; i < rows; i++) {
@@ -218,6 +236,7 @@ public Matrix like(int rows, int columns) {
    * @param column an int column index into the receiver
    * @param value  a double value to set
    */
+  @Override
   public void setQuick(int row, int column, double value) {
     data.get(row).setQuick(column, value);
   }
@@ -227,6 +246,7 @@ public void setQuick(int row, int column, double value) {
    *
    * @return an int[2] containing [row, column] count
    */
+  @Override
   public int[] getNumNondefaultElements() {
     return new int[]{data.size(), columns};
   }
@@ -241,6 +261,7 @@ public void setQuick(int row, int column, double value) {
    * @throws IndexException       if the offset is negative or the offset+length is outside of the
    *                              receiver
    */
+  @Override
   public Matrix viewPart(int[] offset, int[] size) {
     cardinality[ROW] = data.size();
     return new MatrixView(this, offset, size);
@@ -268,6 +289,7 @@ public void adjoinRow(Matrix other) {
     private final Type collectionType = new TypeToken<List<Vector>>(){}.getType();
     private final Type labelType = new TypeToken<Map<String, Integer>>(){}.getType();
 
+    @Override
     public VectorList deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) {
       JsonObject jo = json.getAsJsonObject();
       VectorList r = new VectorList(jo.get("columns").getAsInt());
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/VectorView.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/VectorView.java
index 30f8acef..dd3dd27f 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/VectorView.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/VectorView.java
@@ -52,26 +52,32 @@ public Vector clone() {
     return r;
   }
 
+  @Override
   public boolean isDense() {
     return vector.isDense();
   }
 
+  @Override
   public boolean isSequentialAccess() {
     return vector.isSequentialAccess();
   }
 
+  @Override
   public VectorView like() {
     return new VectorView(vector.like(), offset, size());
   }
 
+  @Override
   public double getQuick(int index) {
     return vector.getQuick(offset + index);
   }
 
+  @Override
   public void setQuick(int index, double value) {
     vector.setQuick(offset + index, value);
   }
 
+  @Override
   public int getNumNondefaultElements() {
     return size();
   }
@@ -92,10 +98,12 @@ private boolean isInView(int index) {
     return index >= offset && index < offset + size();
   }
 
+  @Override
   public Iterator<Element> iterateNonZero() {
     return new NonZeroIterator();
   }
 
+  @Override
   public Iterator<Element> iterator() {
     return new AllIterator();
   }
@@ -117,14 +125,17 @@ private void buffer() {
         if (isInView(el.index()) && el.get() != 0) {
           final Element decorated = vector.getElement(el.index());
           el = new Element() {
+            @Override
             public double get() {
               return decorated.get();
             }
 
+            @Override
             public int index() {
               return decorated.index() - offset;
             }
 
+            @Override
             public void set(double value) {
               decorated.set(value);
             }
@@ -135,6 +146,7 @@ public void set(double value) {
       el = null; // No element was found
     }
 
+    @Override
     public Element next() {
       if (!hasNext()) {
         throw new NoSuchElementException();
@@ -144,11 +156,13 @@ public Element next() {
       return buffer;
     }
 
+    @Override
     public boolean hasNext() {
       return el != null;
     }
 
     /** @throws UnsupportedOperationException all the time. method not implemented. */
+    @Override
     public void remove() {
       throw new UnsupportedOperationException();
     }
@@ -171,14 +185,17 @@ private void buffer() {
         if (isInView(el.index())) {
           final Element decorated = vector.getElement(el.index());
           el = new Element() {
+            @Override
             public double get() {
               return decorated.get();
             }
 
+            @Override
             public int index() {
               return decorated.index() - offset;
             }
 
+            @Override
             public void set(double value) {
               decorated.set(value);
             }
@@ -189,6 +206,7 @@ public void set(double value) {
       el = null; // No element was found
     }
 
+    @Override
     public Element next() {
       if (!hasNext()) {
         throw new NoSuchElementException();
@@ -198,11 +216,13 @@ public Element next() {
       return buffer;
     }
 
+    @Override
     public boolean hasNext() {
       return el != null;
     }
 
     /** @throws UnsupportedOperationException all the time. method not implemented. */
+    @Override
     public void remove() {
       throw new UnsupportedOperationException();
     }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/AsyncEigenVerifier.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/AsyncEigenVerifier.java
index c2b21ebb..c984eb42 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/AsyncEigenVerifier.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/AsyncEigenVerifier.java
@@ -63,6 +63,7 @@ protected VerifierRunnable(VectorIterable corpus, Vector vector) {
       this.vector = vector;
     }
 
+    @Override
     public void run() {
       EigenStatus status = innerVerify(corpus, vector);
       synchronized (AsyncEigenVerifier.this) {
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/SimpleEigenVerifier.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/SimpleEigenVerifier.java
index 9d1baa05..dc95c581 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/SimpleEigenVerifier.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/SimpleEigenVerifier.java
@@ -21,6 +21,7 @@
 
 public class SimpleEigenVerifier implements SingularVectorVerifier {
 
+  @Override
   public EigenStatus verify(VectorIterable corpus, Vector vector) {
     Vector resultantVector = corpus.timesSquared(vector);
     double newNorm = resultantVector.norm(2);
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/hebbian/HebbianUpdater.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/hebbian/HebbianUpdater.java
index b628b0b0..cd80fbf0 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/hebbian/HebbianUpdater.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/hebbian/HebbianUpdater.java
@@ -23,6 +23,7 @@
 
 public class HebbianUpdater implements EigenUpdater {
 
+  @Override
   public void update(Vector pseudoEigen,
                      Vector trainingVector,
                      TrainingState currentState) {
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/lanczos/LanczosSolver.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/lanczos/LanczosSolver.java
index bf9b63af..81b123d3 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/lanczos/LanczosSolver.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/decomposer/lanczos/LanczosSolver.java
@@ -85,6 +85,7 @@ private Scale(double d) {
       this.d = d;
     }
 
+    @Override
     public double apply(double arg1) {
       return arg1 * d;
     }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/Functions.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/Functions.java
index 53b6d102..1941ae13 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/Functions.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/Functions.java
@@ -117,6 +117,7 @@
    */
   /** Function that returns <tt>Math.abs(a)</tt>. */
   public static final DoubleFunction ABS = new DoubleFunction() {
+    @Override
     public double apply(double a) {
       return Math.abs(a);
     }
@@ -124,6 +125,7 @@ public double apply(double a) {
 
   /** Function that returns <tt>Math.acos(a)</tt>. */
   public static final DoubleFunction ACOS = new DoubleFunction() {
+    @Override
     public double apply(double a) {
       return Math.acos(a);
     }
@@ -131,6 +133,7 @@ public double apply(double a) {
 
   /** Function that returns <tt>Math.asin(a)</tt>. */
   public static final DoubleFunction ASIN = new DoubleFunction() {
+    @Override
     public double apply(double a) {
       return Math.asin(a);
     }
@@ -138,6 +141,7 @@ public double apply(double a) {
 
   /** Function that returns <tt>Math.atan(a)</tt>. */
   public static final DoubleFunction ATAN = new DoubleFunction() {
+    @Override
     public double apply(double a) {
       return Math.atan(a);
     }
@@ -146,6 +150,7 @@ public double apply(double a) {
   /** Function that returns <tt>Math.ceil(a)</tt>. */
   public static final DoubleFunction CEIL = new DoubleFunction() {
 
+    @Override
     public double apply(double a) {
       return Math.ceil(a);
     }
@@ -154,6 +159,7 @@ public double apply(double a) {
   /** Function that returns <tt>Math.cos(a)</tt>. */
   public static final DoubleFunction COS = new DoubleFunction() {
 
+    @Override
     public double apply(double a) {
       return Math.cos(a);
     }
@@ -162,6 +168,7 @@ public double apply(double a) {
   /** Function that returns <tt>Math.exp(a)</tt>. */
   public static final DoubleFunction EXP = new DoubleFunction() {
 
+    @Override
     public double apply(double a) {
       return Math.exp(a);
     }
@@ -170,6 +177,7 @@ public double apply(double a) {
   /** Function that returns <tt>Math.floor(a)</tt>. */
   public static final DoubleFunction FLOOR = new DoubleFunction() {
 
+    @Override
     public double apply(double a) {
       return Math.floor(a);
     }
@@ -178,6 +186,7 @@ public double apply(double a) {
   /** Function that returns its argument. */
   public static final DoubleFunction IDENTITY = new DoubleFunction() {
 
+    @Override
     public double apply(double a) {
       return a;
     }
@@ -186,6 +195,7 @@ public double apply(double a) {
   /** Function that returns <tt>1.0 / a</tt>. */
   public static final DoubleFunction INV = new DoubleFunction() {
 
+    @Override
     public double apply(double a) {
       return 1.0 / a;
     }
@@ -194,6 +204,7 @@ public double apply(double a) {
   /** Function that returns <tt>Math.log(a)</tt>. */
   public static final DoubleFunction LOGARITHM = new DoubleFunction() {
 
+    @Override
     public double apply(double a) {
       return Math.log(a);
     }
@@ -202,6 +213,7 @@ public double apply(double a) {
   /** Function that returns <tt>Math.log(a) / Math.log(2)</tt>. */
   public static final DoubleFunction LOG2 = new DoubleFunction() {
 
+    @Override
     public double apply(double a) {
       return Math.log(a) * 1.4426950408889634;
     }
@@ -210,6 +222,7 @@ public double apply(double a) {
   /** Function that returns <tt>-a</tt>. */
   public static final DoubleFunction NEGATE = new DoubleFunction() {
 
+    @Override
     public double apply(double a) {
       return -a;
     }
@@ -218,6 +231,7 @@ public double apply(double a) {
   /** Function that returns <tt>Math.rint(a)</tt>. */
   public static final DoubleFunction RINT = new DoubleFunction() {
 
+    @Override
     public double apply(double a) {
       return Math.rint(a);
     }
@@ -226,6 +240,7 @@ public double apply(double a) {
   /** Function that returns <tt>a < 0 ? -1 : a > 0 ? 1 : 0</tt>. */
   public static final DoubleFunction SIGN = new DoubleFunction() {
 
+    @Override
     public double apply(double a) {
       return a < 0 ? -1 : a > 0 ? 1 : 0;
     }
@@ -234,6 +249,7 @@ public double apply(double a) {
   /** Function that returns <tt>Math.sin(a)</tt>. */
   public static final DoubleFunction SIN = new DoubleFunction() {
 
+    @Override
     public double apply(double a) {
       return Math.sin(a);
     }
@@ -242,6 +258,7 @@ public double apply(double a) {
   /** Function that returns <tt>Math.sqrt(a)</tt>. */
   public static final DoubleFunction SQRT = new DoubleFunction() {
 
+    @Override
     public double apply(double a) {
       return Math.sqrt(a);
     }
@@ -250,6 +267,7 @@ public double apply(double a) {
   /** Function that returns <tt>a * a</tt>. */
   public static final DoubleFunction SQUARE = new DoubleFunction() {
 
+    @Override
     public double apply(double a) {
       return a * a;
     }
@@ -258,6 +276,7 @@ public double apply(double a) {
   /** Function that returns <tt>Math.tan(a)</tt>. */
   public static final DoubleFunction TAN = new DoubleFunction() {
 
+    @Override
     public double apply(double a) {
       return Math.tan(a);
     }
@@ -271,6 +290,7 @@ public double apply(double a) {
   /** Function that returns <tt>Math.atan2(a,b)</tt>. */
   public static final DoubleDoubleFunction ATAN2 = new DoubleDoubleFunction() {
 
+    @Override
     public double apply(double a, double b) {
       return Math.atan2(a, b);
     }
@@ -279,6 +299,7 @@ public double apply(double a, double b) {
   /** Function that returns <tt>a < b ? -1 : a > b ? 1 : 0</tt>. */
   public static final DoubleDoubleFunction COMPARE = new DoubleDoubleFunction() {
 
+    @Override
     public double apply(double a, double b) {
       return a < b ? -1 : a > b ? 1 : 0;
     }
@@ -287,6 +308,7 @@ public double apply(double a, double b) {
   /** Function that returns <tt>a / b</tt>. */
   public static final DoubleDoubleFunction DIV = new DoubleDoubleFunction() {
 
+    @Override
     public double apply(double a, double b) {
       return a / b;
     }
@@ -295,6 +317,7 @@ public double apply(double a, double b) {
   /** Function that returns <tt>a == b ? 1 : 0</tt>. */
   public static final DoubleDoubleFunction EQUALS = new DoubleDoubleFunction() {
 
+    @Override
     public double apply(double a, double b) {
       return a == b ? 1 : 0;
     }
@@ -303,6 +326,7 @@ public double apply(double a, double b) {
   /** Function that returns <tt>a > b ? 1 : 0</tt>. */
   public static final DoubleDoubleFunction GREATER = new DoubleDoubleFunction() {
 
+    @Override
     public double apply(double a, double b) {
       return a > b ? 1 : 0;
     }
@@ -311,6 +335,7 @@ public double apply(double a, double b) {
   /** Function that returns <tt>Math.IEEEremainder(a,b)</tt>. */
   public static final DoubleDoubleFunction IEEE_REMAINDER = new DoubleDoubleFunction() {
 
+    @Override
     public double apply(double a, double b) {
       return Math.IEEEremainder(a, b);
     }
@@ -319,6 +344,7 @@ public double apply(double a, double b) {
   /** Function that returns <tt>a == b</tt>. */
   public static final DoubleDoubleProcedure IS_EQUAL = new DoubleDoubleProcedure() {
 
+    @Override
     public boolean apply(double a, double b) {
       return a == b;
     }
@@ -327,6 +353,7 @@ public boolean apply(double a, double b) {
   /** Function that returns <tt>a < b</tt>. */
   public static final DoubleDoubleProcedure IS_LESS = new DoubleDoubleProcedure() {
 
+    @Override
     public boolean apply(double a, double b) {
       return a < b;
     }
@@ -335,6 +362,7 @@ public boolean apply(double a, double b) {
   /** Function that returns <tt>a > b</tt>. */
   public static final DoubleDoubleProcedure IS_GREATER = new DoubleDoubleProcedure() {
 
+    @Override
     public boolean apply(double a, double b) {
       return a > b;
     }
@@ -343,6 +371,7 @@ public boolean apply(double a, double b) {
   /** Function that returns <tt>a < b ? 1 : 0</tt>. */
   public static final DoubleDoubleFunction LESS = new DoubleDoubleFunction() {
 
+    @Override
     public double apply(double a, double b) {
       return a < b ? 1 : 0;
     }
@@ -351,6 +380,7 @@ public double apply(double a, double b) {
   /** Function that returns <tt>Math.log(a) / Math.log(b)</tt>. */
   public static final DoubleDoubleFunction LG = new DoubleDoubleFunction() {
 
+    @Override
     public double apply(double a, double b) {
       return Math.log(a) / Math.log(b);
     }
@@ -359,6 +389,7 @@ public double apply(double a, double b) {
   /** Function that returns <tt>Math.max(a,b)</tt>. */
   public static final DoubleDoubleFunction MAX = new DoubleDoubleFunction() {
 
+    @Override
     public double apply(double a, double b) {
       return Math.max(a, b);
     }
@@ -367,6 +398,7 @@ public double apply(double a, double b) {
   /** Function that returns <tt>Math.min(a,b)</tt>. */
   public static final DoubleDoubleFunction MIN = new DoubleDoubleFunction() {
 
+    @Override
     public double apply(double a, double b) {
       return Math.min(a, b);
     }
@@ -383,6 +415,7 @@ public double apply(double a, double b) {
   /** Function that returns <tt>a % b</tt>. */
   public static final DoubleDoubleFunction MOD = new DoubleDoubleFunction() {
 
+    @Override
     public double apply(double a, double b) {
       return a % b;
     }
@@ -391,6 +424,7 @@ public double apply(double a, double b) {
   /** Function that returns <tt>a * b</tt>. */
   public static final DoubleDoubleFunction MULT = new DoubleDoubleFunction() {
 
+    @Override
     public double apply(double a, double b) {
       return a * b;
     }
@@ -399,6 +433,7 @@ public double apply(double a, double b) {
   /** Function that returns <tt>a + b</tt>. */
   public static final DoubleDoubleFunction PLUS = new DoubleDoubleFunction() {
     
+    @Override
     public double apply(double a, double b) {
       return a + b;
     }
@@ -407,6 +442,7 @@ public double apply(double a, double b) {
   /** Function that returns <tt>Math.abs(a) + Math.abs(b)</tt>. */
   public static final DoubleDoubleFunction PLUS_ABS = new DoubleDoubleFunction() {
 
+    @Override
     public double apply(double a, double b) {
       return Math.abs(a) + Math.abs(b);
     }
@@ -415,6 +451,7 @@ public double apply(double a, double b) {
   /** Function that returns <tt>Math.pow(a,b)</tt>. */
   public static final DoubleDoubleFunction POW = new DoubleDoubleFunction() {
 
+    @Override
     public double apply(double a, double b) {
       return Math.pow(a, b);
     }
@@ -430,6 +467,7 @@ private Functions() {
   public static DoubleFunction between(final double from, final double to) {
     return new DoubleFunction() {
 
+      @Override
       public double apply(double a) {
         return (from <= a && a <= to) ? 1 : 0;
       }
@@ -446,6 +484,7 @@ public double apply(double a) {
   public static DoubleFunction bindArg1(final DoubleDoubleFunction function, final double c) {
     return new DoubleFunction() {
 
+      @Override
       public double apply(double var) {
         return function.apply(c, var);
       }
@@ -462,6 +501,7 @@ public double apply(double var) {
   public static DoubleFunction bindArg2(final DoubleDoubleFunction function, final double c) {
     return new DoubleFunction() {
 
+      @Override
       public double apply(double var) {
         return function.apply(var, c);
       }
@@ -480,6 +520,7 @@ public static DoubleDoubleFunction chain(final DoubleDoubleFunction f, final Dou
                                            final DoubleFunction h) {
     return new DoubleDoubleFunction() {
 
+      @Override
       public double apply(double a, double b) {
         return f.apply(g.apply(a), h.apply(b));
       }
@@ -496,6 +537,7 @@ public double apply(double a, double b) {
   public static DoubleDoubleFunction chain(final DoubleFunction g, final DoubleDoubleFunction h) {
     return new DoubleDoubleFunction() {
 
+      @Override
       public double apply(double a, double b) {
         return g.apply(h.apply(a, b));
       }
@@ -512,6 +554,7 @@ public double apply(double a, double b) {
   public static DoubleFunction chain(final DoubleFunction g, final DoubleFunction h) {
     return new DoubleFunction() {
 
+      @Override
       public double apply(double a) {
         return g.apply(h.apply(a));
       }
@@ -525,6 +568,7 @@ public double apply(double a) {
   public static DoubleFunction compare(final double b) {
     return new DoubleFunction() {
 
+      @Override
       public double apply(double a) {
         return a < b ? -1 : a > b ? 1 : 0;
       }
@@ -535,6 +579,7 @@ public double apply(double a) {
   public static DoubleFunction constant(final double c) {
     return new DoubleFunction() {
 
+      @Override
       public double apply(double a) {
         return c;
       }
@@ -551,6 +596,7 @@ public static DoubleFunction div(double b) {
   public static DoubleFunction equals(final double b) {
     return new DoubleFunction() {
 
+      @Override
       public double apply(double a) {
         return a == b ? 1 : 0;
       }
@@ -561,6 +607,7 @@ public double apply(double a) {
   public static DoubleFunction greater(final double b) {
     return new DoubleFunction() {
 
+      @Override
       public double apply(double a) {
         return a > b ? 1 : 0;
       }
@@ -574,6 +621,7 @@ public double apply(double a) {
   public static DoubleFunction mathIEEEremainder(final double b) {
     return new DoubleFunction() {
 
+      @Override
       public double apply(double a) {
         return Math.IEEEremainder(a, b);
       }
@@ -587,6 +635,7 @@ public double apply(double a) {
   public static DoubleProcedure isBetween(final double from, final double to) {
     return new DoubleProcedure() {
 
+      @Override
       public boolean apply(double a) {
         return from <= a && a <= to;
       }
@@ -597,6 +646,7 @@ public boolean apply(double a) {
   public static DoubleProcedure isEqual(final double b) {
     return new DoubleProcedure() {
 
+      @Override
       public boolean apply(double a) {
         return a == b;
       }
@@ -607,6 +657,7 @@ public boolean apply(double a) {
   public static DoubleProcedure isGreater(final double b) {
     return new DoubleProcedure() {
 
+      @Override
       public boolean apply(double a) {
         return a > b;
       }
@@ -617,6 +668,7 @@ public boolean apply(double a) {
   public static DoubleProcedure isLess(final double b) {
     return new DoubleProcedure() {
 
+      @Override
       public boolean apply(double a) {
         return a < b;
       }
@@ -627,6 +679,7 @@ public boolean apply(double a) {
   public static DoubleFunction less(final double b) {
     return new DoubleFunction() {
 
+      @Override
       public double apply(double a) {
         return a < b ? 1 : 0;
       }
@@ -642,6 +695,7 @@ public static DoubleFunction lg(final double b) {
       private final double logInv = 1 / Math.log(b); // cached for speed
 
 
+      @Override
       public double apply(double a) {
         return Math.log(a) * logInv;
       }
@@ -652,6 +706,7 @@ public double apply(double a) {
   public static DoubleFunction max(final double b) {
     return new DoubleFunction() {
 
+      @Override
       public double apply(double a) {
         return Math.max(a, b);
       }
@@ -662,6 +717,7 @@ public double apply(double a) {
   public static DoubleFunction min(final double b) {
     return new DoubleFunction() {
 
+      @Override
       public double apply(double a) {
         return Math.min(a, b);
       }
@@ -685,6 +741,7 @@ public static DoubleDoubleFunction minusMult(double constant) {
   public static DoubleFunction mod(final double b) {
     return new DoubleFunction() {
 
+      @Override
       public double apply(double a) {
         return a % b;
       }
@@ -705,6 +762,7 @@ public static DoubleFunction mult(double b) {
   public static DoubleFunction plus(final double b) {
     return new DoubleFunction() {
 
+      @Override
       public double apply(double a) {
         return a + b;
       }
@@ -728,6 +786,7 @@ public static DoubleDoubleFunction plusMult(double constant) {
   public static DoubleFunction pow(final double b) {
     return new DoubleFunction() {
 
+      @Override
       public double apply(double a) {
         return Math.pow(a, b);
       }
@@ -757,6 +816,7 @@ public static DoubleFunction random() {
    */
   public static DoubleFunction round(final double precision) {
     return new DoubleFunction() {
+      @Override
       public double apply(double a) {
         return Math.rint(a / precision) * precision;
       }
@@ -772,6 +832,7 @@ public double apply(double a) {
    */
   public static DoubleDoubleFunction swapArgs(final DoubleDoubleFunction function) {
     return new DoubleDoubleFunction() {
+      @Override
       public double apply(double a, double b) {
         return function.apply(b, a);
       }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/Mult.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/Mult.java
index a031569e..6801a94a 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/Mult.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/Mult.java
@@ -46,6 +46,7 @@
   }
 
   /** Returns the result of the function evaluation. */
+  @Override
   public double apply(double a) {
     return a * multiplicator;
   }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/PlusMult.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/PlusMult.java
index b1114871..60587b13 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/PlusMult.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/PlusMult.java
@@ -48,6 +48,7 @@ public PlusMult(double multiplicator) {
   }
 
   /** Returns the result of the function evaluation. */
+  @Override
   public double apply(double a, double b) {
     return a + b * multiplicator;
   }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/SquareRootFunction.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/SquareRootFunction.java
index 89b8a4a7..0b6f4b00 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/SquareRootFunction.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/SquareRootFunction.java
@@ -19,6 +19,7 @@
 
 public final class SquareRootFunction implements DoubleFunction {
 
+  @Override
   public double apply(double arg1) {
     return Math.sqrt(arg1);
   }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/TimesFunction.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/TimesFunction.java
index 36eb3b4e..8ab0bb15 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/TimesFunction.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/function/TimesFunction.java
@@ -25,6 +25,7 @@
    * @param y second argument
    * @return the product
    */
+  @Override
   public double apply(double x, double y) {
     return x * y;
   }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/jet/random/AbstractDistribution.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/jet/random/AbstractDistribution.java
index 1d48532e..85b2c3aa 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/jet/random/AbstractDistribution.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/jet/random/AbstractDistribution.java
@@ -41,6 +41,7 @@ protected AbstractDistribution() {
    * Equivalent to <tt>nextDouble()</tt>. This has the effect that distributions can now be used as function objects,
    * returning a random number upon function evaluation.
    */
+  @Override
   public double apply(double dummy) {
     return nextDouble();
   }
@@ -49,6 +50,7 @@ public double apply(double dummy) {
    * Equivalent to <tt>nextInt()</tt>. This has the effect that distributions can now be used as function objects,
    * returning a random number upon function evaluation.
    */
+  @Override
   public int apply(int dummy) {
     return nextInt();
   }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/jet/random/engine/RandomEngine.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/jet/random/engine/RandomEngine.java
index e76543f8..0e567629 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/jet/random/engine/RandomEngine.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/jet/random/engine/RandomEngine.java
@@ -60,6 +60,7 @@
    * Equivalent to <tt>raw()</tt>. This has the effect that random engines can now be used as function objects,
    * returning a random number upon function evaluation.
    */
+  @Override
   public double apply(double dummy) {
     return raw();
   }
@@ -68,6 +69,7 @@ public double apply(double dummy) {
    * Equivalent to <tt>nextInt()</tt>. This has the effect that random engines can now be used as function objects,
    * returning a random number upon function evaluation.
    */
+  @Override
   public int apply(int dummy) {
     return nextInt();
   }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/impl/SparseDoubleMatrix2D.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/impl/SparseDoubleMatrix2D.java
index 2d5aaee6..5a4a7b16 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/impl/SparseDoubleMatrix2D.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/matrix/impl/SparseDoubleMatrix2D.java
@@ -164,6 +164,7 @@ public DoubleMatrix2D assign(final DoubleMatrix2D y,
       } // nothing to do
       y.forEachNonZero(
           new IntIntDoubleFunction() {
+            @Override
             public double apply(int i, int j, double value) {
               setQuick(i, j, getQuick(i, j) + alpha * value);
               return value;
@@ -176,6 +177,7 @@ public double apply(int i, int j, double value) {
     if (function == Functions.MULT) { // x[i] = x[i] * y[i]
       this.elements.forEachPair(
           new IntDoubleProcedure() {
+            @Override
             public boolean apply(int key, double value) {
               int i = key / columns;
               int j = key % columns;
@@ -192,6 +194,7 @@ public boolean apply(int key, double value) {
     if (function == Functions.DIV) { // x[i] = x[i] / y[i]
       this.elements.forEachPair(
           new IntDoubleProcedure() {
+            @Override
             public boolean apply(int key, double value) {
               int i = key / columns;
               int j = key % columns;
@@ -233,6 +236,7 @@ public void forEachNonZero(final org.apache.mahout.math.function.IntIntDoubleFun
     if (this.isNoView) {
       this.elements.forEachPair(
           new IntDoubleProcedure() {
+            @Override
             public boolean apply(int key, double value) {
               int i = key / columns;
               int j = key % columns;
@@ -426,6 +430,7 @@ public DoubleMatrix1D zMult(DoubleMatrix1D y, DoubleMatrix1D z, double alpha, do
 
     this.elements.forEachPair(
         new IntDoubleProcedure() {
+          @Override
           public boolean apply(int key, double value) {
             int i = key / columns;
             int j = key % columns;
@@ -495,6 +500,7 @@ public DoubleMatrix2D zMult(DoubleMatrix2D B, DoubleMatrix2D C, final double alp
 
     this.elements.forEachPair(
         new IntDoubleProcedure() {
+          @Override
           public boolean apply(int key, double value) {
             int i = key / columns;
             int j = key % columns;
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/stats/LogLikelihood.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/stats/LogLikelihood.java
index e4015d6d..ab8f5e49 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/stats/LogLikelihood.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/stats/LogLikelihood.java
@@ -135,6 +135,7 @@ public static double rootLogLikelihoodRatio(int k11, int k12, int k21, int k22)
     int totalB = b.size();
 
     Ordering<ScoredItem<T>> byScoreAscending = new Ordering<ScoredItem<T>>() {
+      @Override
       public int compare(ScoredItem<T> tScoredItem, ScoredItem<T> tScoredItem1) {
         return Double.compare(tScoredItem.score, tScoredItem1.score);
       }
