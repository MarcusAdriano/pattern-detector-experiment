diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Fetcher.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Fetcher.java
index 5f1be9e2..1f83f69e 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Fetcher.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Fetcher.java
@@ -108,10 +108,11 @@
      * @param storage      the storage where all documents are stored
      * @param hostManager  the host manager
      */
-    public Fetcher(int maxThreads, DocumentStorage storage, HostManager hostManager)
+    public Fetcher(int maxThreads, DocumentStorage docStorage, LinkStorage linkStorage, HostManager hostManager)
     {
         this.storage = storage;
-        FetcherTask.setStorage(storage);
+        FetcherTask.setDocStorage(docStorage);
+        FetcherTask.setLinkStorage(linkStorage);
         fetcherPool = new ThreadPool(maxThreads, new FetcherThreadFactory(hostManager));
         fetcherPool.setQueue(new FetcherTaskQueue());
         docsRead = 0;
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherMain.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherMain.java
index 480cc1e3..6b024f54 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherMain.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherMain.java
@@ -181,7 +181,14 @@ public FetcherMain(int nrThreads)
         // existing message pipeline
         SimpleLogger storeLog = new SimpleLogger("store", false);
         SimpleLogger linksLog = new SimpleLogger("links", false);
-        this.storage = new LogStorage(storeLog, true, "logs/pagefile");
+
+
+        StoragePipeline storage = new StoragePipeline();
+        storage.addDocStorage(new LogStorage(storeLog, /* save in page files? */ false, /* logfile prefix */ "logs/pagefile"));
+        storage.addLinkStorage(new LinkLogStorage(linksLog));
+        storage.addLinkStorage(messageHandler);
+        //storage.addStorage(new LuceneStorage(...));
+        //storage.addStorage(new JMSStorage(...));
 
         // a third example would be the NullStorage, which converts the documents into
         // heat, which evaporates above the processor
@@ -190,14 +197,14 @@ public FetcherMain(int nrThreads)
         // create the filters and add them to the message queue
         urlScopeFilter = new URLScopeFilter();
 
-        urlVisitedFilter = new URLVisitedFilter(100000, linksLog);
+        urlVisitedFilter = new URLVisitedFilter(100000);
 
         // dnsResolver = new DNSResolver();
         hostManager = new HostManager(1000);
 
         reFilter = new RobotExclusionFilter(hostManager);
 
-        fetcher = new Fetcher(nrThreads, storage, hostManager);
+        fetcher = new Fetcher(nrThreads, storage, storage, hostManager);
 
         knownPathsFilter = new KnownPathsFilter();
 
@@ -209,6 +216,8 @@ public FetcherMain(int nrThreads)
         // prevent GZipped files from being decoded
         HTTPConnection.removeDefaultModule(HTTPClient.ContentEncodingModule.class);
 
+
+
         // initialize the threads
         fetcher.init();
 
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask.java
index 3b180ba9..b1b7ccb6 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/FetcherTask.java
@@ -63,6 +63,8 @@
 import de.lanlab.larm.util.WebDocument;
 import de.lanlab.larm.util.SimpleCharArrayReader;
 import de.lanlab.larm.storage.DocumentStorage;
+import de.lanlab.larm.storage.LinkStorage;
+
 import de.lanlab.larm.util.State;
 import de.lanlab.larm.util.SimpleLogger;
 import de.lanlab.larm.net.HttpTimeoutFactory;
@@ -124,9 +126,16 @@
     private volatile long bytesRead = 0;
 
     /**
-     * the storage this task will put the document to
+     * the docStorage this task will put the document to
+     */
+    private static volatile DocumentStorage docStorage;
+
+    /**
+     * the docStorage this task will put the links to
      */
-    private static volatile DocumentStorage storage;
+    private static volatile LinkStorage linkStorage;
+
+
 
     /**
      * task state IDs. comparisons will be done by their references, so always
@@ -209,13 +218,23 @@ public URLMessage getActURLMessage()
 
 
     /**
-     * Sets the document storage
+     * Sets the document docStorage
+     *
+     * @param docStorage  The new docStorage
+     */
+    public static void setDocStorage(DocumentStorage docStorage)
+    {
+        FetcherTask.docStorage = docStorage;
+    }
+
+    /**
+     * Sets the document linkStorage
      *
-     * @param storage  The new storage
+     * @param linkStorage  The new linkStorage
      */
-    public static void setStorage(DocumentStorage storage)
+    public static void setLinkStorage(LinkStorage linkStorage)
     {
-        FetcherTask.storage = storage;
+        FetcherTask.linkStorage = linkStorage;
     }
 
 
@@ -384,8 +403,9 @@ public void run(ServerThread thread)
                     log.log("scanned");
                 }
                 taskState.setState(FT_STORING, ipURL);
-                messageHandler.putMessages(foundUrls);
-                storage.store(new WebDocument(contextUrl, contentType, fullBuffer, statusCode, actURLMessage.getReferer(), contentLength, title));
+                linkStorage.storeLinks(foundUrls);
+                //messageHandler.putMessages(foundUrls);
+                docStorage.store(new WebDocument(contextUrl, contentType, fullBuffer, statusCode, actURLMessage.getReferer(), contentLength, title));
                 log.log("stored");
             }
         }
@@ -521,8 +541,8 @@ public void interrupt()
 
 
     /**
-     * this is called whenever a links was found in the current document,
-     * Don't create too many objects here, this will be called
+     * this is called whenever a link was found in the current document,
+     * Don't create too many objects here, as this will be called
      * millions of times
      *
      * @param link  Description of the Parameter
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Filter.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Filter.java
index c34425de..e5e6c41e 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Filter.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/Filter.java
@@ -54,7 +54,7 @@
  * <http://www.apache.org/>.
  */
 
- package de.lanlab.larm.fetcher;
+package de.lanlab.larm.fetcher;
 
 
 /**
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/MessageHandler.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/MessageHandler.java
index d8484778..23bd9509 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/MessageHandler.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/MessageHandler.java
@@ -60,6 +60,7 @@
 import de.lanlab.larm.util.SimpleObservable;
 import de.lanlab.larm.util.CachingQueue;
 import de.lanlab.larm.util.UnderflowException;
+import de.lanlab.larm.storage.LinkStorage;
 
 /**
  *  this is a message handler that runs in its own thread.
@@ -73,7 +74,7 @@
  *  This implements a chain of responsibility-style message handling
  * @version $Id$
  */
-public class MessageHandler implements Runnable
+public class MessageHandler implements Runnable, LinkStorage
 {
 
     /**
@@ -120,7 +121,7 @@ public boolean isWorkingOnMessage()
     /**
      *  messageHandler-Thread erzeugen und starten
      */
-    MessageHandler()
+    public MessageHandler()
     {
         t = new Thread(this,"MessageHandler Thread");
         t.setPriority(5);   // higher priority to prevent starving when a lot of fetcher threads are used
@@ -177,7 +178,7 @@ public void addMessageProcessorObserver(Observer o)
 
 
     /**
-     *  einen Event in die Schlange schreiben
+     *  insert one message into the queue
      */
     public void putMessage(Message msg)
     {
@@ -210,6 +211,13 @@ public void putMessages(Collection msgs)
         }
     }
 
+    public Collection storeLinks(Collection links)
+    {
+        putMessages(links);
+        return links;
+    }
+
+
     /**
      *  the main messageHandler-Thread.
      */
@@ -253,22 +261,22 @@ public void run()
                     messageQueueObservable.setChanged();
                     messageQueueObservable.notifyObservers(new Integer(-1));      // Message processed
 
-                    // und verteilen. Die Listener erhalten die Message in ihrer
-                    // Eintragungsreihenfolge und können die Message auch verändern
+                    // now distribute them. The handlers get the messages in the order
+                    // of insertion and have the right to change them
 
                     Iterator i = listeners.iterator();
                     while(i.hasNext())
                     {
-                        //System.out.println("Verteile...");
                         try
                         {
                             MessageListener listener = (MessageListener)i.next();
                             m = (Message)listener.handleRequest(m);
                             if (m == null)
                             {
+                                // handler has consumed the message
                                 messageProcessorObservable.setChanged();
                                 messageProcessorObservable.notifyObservers(listener);
-                                break;     // Handler hat die Message konsumiert
+                                break;
                             }
                         }
                         catch(ClassCastException e)
@@ -287,7 +295,7 @@ public void run()
                 messagesWaiting = false;
                 // System.out.println("MessageHandler: messagesWaiting = true although nothing queued!");
                 // @FIXME: here is still a multi threading issue. I don't get it why this happens.
-                //         does someone want to draw a petri net of this?
+                //         does someone want to draw a petri net of this? ;-)
             }
             catch (Exception e)
             {
@@ -302,4 +310,8 @@ public int getQueued()
     {
         return messageQueue.size();
     }
+
+    public void openLinkStorage()
+    {
+    }
 }
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/URLVisitedFilter.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/URLVisitedFilter.java
index c99304b8..54524650 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/URLVisitedFilter.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/URLVisitedFilter.java
@@ -71,7 +71,7 @@
  * @created   3. Januar 2002
  * @version $Id$
  */
-class URLVisitedFilter extends Filter implements MessageListener
+public class URLVisitedFilter extends Filter implements MessageListener
 {
 
     /**
@@ -81,13 +81,10 @@
      */
     public void notifyAddedToMessageHandler(MessageHandler handler)
     {
-        this.messageHandler = handler;
     }
 
 
-    MessageHandler messageHandler;
-
-    SimpleLogger log;
+    //SimpleLogger log;
 
     HashSet urlHash;
 
@@ -100,10 +97,9 @@ public void notifyAddedToMessageHandler(MessageHandler handler)
      *
      * @param initialHashCapacity  Description of the Parameter
      */
-    public URLVisitedFilter(int initialHashCapacity, SimpleLogger log)
+    public URLVisitedFilter(int initialHashCapacity)
     {
         urlHash = new HashSet(initialHashCapacity);
-        this.log = log;
         //urlVector = new Vector(initialHashCapacity);
     }
 
@@ -134,10 +130,6 @@ public Message handleRequest(Message message)
             {
                 //System.out.println("URLVisitedFilter: " + urlString + " already present.");
                 filtered++;
-                if(log != null)
-                {
-                    log.log(urlMessage.getInfo());
-                }
                 return null;
             }
             else
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/EntityManager.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/EntityManager.java
index 11b3f537..8c378c97 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/EntityManager.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/EntityManager.java
@@ -1,2 +1,266 @@
   - 1.2
   + 1.3
+/*
+ *  ====================================================================
+ *  The Apache Software License, Version 1.1
+ *
+ *  Copyright (c) 2001 The Apache Software Foundation.  All rights
+ *  reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *  1. Redistributions of source code must retain the above copyright
+ *  notice, this list of conditions and the following disclaimer.
+ *
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *  notice, this list of conditions and the following disclaimer in
+ *  the documentation and/or other materials provided with the
+ *  distribution.
+ *
+ *  3. The end-user documentation included with the redistribution,
+ *  if any, must include the following acknowledgment:
+ *  "This product includes software developed by the
+ *  Apache Software Foundation (http://www.apache.org/)."
+ *  Alternately, this acknowledgment may appear in the software itself,
+ *  if and wherever such third-party acknowledgments normally appear.
+ *
+ *  4. The names "Apache" and "Apache Software Foundation" and
+ *  "Apache Lucene" must not be used to endorse or promote products
+ *  derived from this software without prior written permission. For
+ *  written permission, please contact apache@apache.org.
+ *
+ *  5. Products derived from this software may not be called "Apache",
+ *  "Apache Lucene", nor may "Apache" appear in their name, without
+ *  prior written permission of the Apache Software Foundation.
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ *  ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ *  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ *  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ *  SUCH DAMAGE.
+ *  ====================================================================
+ *
+ *  This software consists of voluntary contributions made by many
+ *  individuals on behalf of the Apache Software Foundation.  For more
+ *  information on the Apache Software Foundation, please see
+ *  <http://www.apache.org/>.
+ */
+package de.lanlab.larm.parser;
+
+import java.util.Hashtable;
+import java.io.*;
+
+/**
+ * A very simple entity manager. Based on HeX, the HTML enabled XML parser, by
+ * Anders Kristensen, HP Labs Bristol
+ *
+ * @author    Administrator
+ * @created   1. Juni 2002
+ */
+public class EntityManager
+{
+    /**
+     * Description of the Field
+     */
+    protected Hashtable entities = new Hashtable();
+
+    /**
+     * Description of the Field
+     */
+    private Tokenizer tok;
+
+
+    /**
+     * Constructor for the EntityManager object
+     *
+     * @param tok  Description of the Parameter
+     */
+    public EntityManager(Tokenizer tok)
+    {
+        this.tok = tok;
+        entities.put("amp", "&");
+        entities.put("lt", "<");
+        entities.put("gt", ">");
+        entities.put("apos", "'");
+        entities.put("quot", "\"");
+        entities.put("auml", "ä");
+        entities.put("ouml", "ö");
+        entities.put("uuml", "ü");
+        entities.put("Auml", "Ä");
+        entities.put("Ouml", "Ö");
+        entities.put("Uuml", "Ü");
+        entities.put("szlig", "ß");
+
+    }
+
+
+    /**
+     * Finds entitiy and character references in the provided char array and
+     * decodes them. The operation is destructive, i.e. the encoded string
+     * replaces the original - this is atrightforward since the new string can
+     * only get shorter.
+     *
+     * @param buffer         Description of the Parameter
+     * @return               Description of the Return Value
+     * @exception Exception  Description of the Exception
+     */
+    public final SimpleCharArrayWriter entityDecode(SimpleCharArrayWriter buffer)
+        throws Exception
+    {
+        char[] buf = buffer.getCharArray();
+        // avoids method calls
+        int len = buffer.size();
+
+        // not fastest but certainly simplest:
+        if (indexOf(buf, '&', 0, len) == -1)
+        {
+            return buffer;
+        }
+        SimpleCharArrayWriter newbuf = new SimpleCharArrayWriter(len);
+
+        for (int start = 0; ; )
+        {
+            int x = indexOf(buf, '&', start, len);
+            if (x == -1)
+            {
+                newbuf.write(buf, start, len - start);
+                return newbuf;
+            }
+            else
+            {
+                newbuf.write(buf, start, x - start);
+                start = x + 1;
+                x = indexOf(buf, ';', start, len);
+                if (x == -1)
+                {
+                    //tok.warning("Entity reference not semicolon terminated");
+                    newbuf.write('&');
+                    //break; //???????????
+                }
+                else
+                {
+                    try
+                    {
+                        writeEntityDef(buf, start, x - start, newbuf);
+                        start = x + 1;
+                    }
+                    catch (Exception ex)
+                    {
+                        //tok.warning("Bad entity reference");
+                    }
+                }
+            }
+        }
+    }
+
+
+    // character references are rare enough that we don't care about
+    // creating a String object for them unnecessarily...
+    /**
+     * Description of the Method
+     *
+     * @param buf                        Description of the Parameter
+     * @param off                        Description of the Parameter
+     * @param len                        Description of the Parameter
+     * @param out                        Description of the Parameter
+     * @exception Exception              Description of the Exception
+     * @exception IOException            Description of the Exception
+     * @exception NumberFormatException  Description of the Exception
+     */
+    public void writeEntityDef(char[] buf, int off, int len, Writer out)
+        throws Exception, IOException, NumberFormatException
+    {
+        Integer ch;
+        //System.out.println("Entity: " + new String(buf, off, len) +" "+off+" "+len);
+
+        if (buf[off] == '#')
+        {
+            // character reference
+            off++;
+            len--;
+            if (buf[off] == 'x' || buf[off] == 'X')
+            {
+                ch = Integer.valueOf(new String(buf, off + 1, len - 1), 16);
+            }
+            else
+            {
+                ch = Integer.valueOf(new String(buf, off, len));
+            }
+            out.write(ch.intValue());
+        }
+        else
+        {
+            String ent = new String(buf, off, len);
+            String val = (String) entities.get(ent);
+            if (val != null)
+            {
+                out.write(val);
+            }
+            else
+            {
+                out.write("&" + ent + ";");
+                //tok.warning("unknown entity reference: " + ent);
+            }
+        }
+    }
+
+
+    /**
+     * Description of the Method
+     *
+     * @param entity  Description of the Parameter
+     * @param value   Description of the Parameter
+     * @return        Description of the Return Value
+     */
+    public String defTextEntity(String entity, String value)
+    {
+        return (String) entities.put(entity, value);
+    }
+
+
+    /**
+     * Returns the index within this String of the first occurrence of the
+     * specified character, starting the search at fromIndex. This method
+     * returns -1 if the character is not found.
+     *
+     * @param buf                         Description of the Parameter
+     * @param ch                          Description of the Parameter
+     * @param from                        Description of the Parameter
+     * @param to                          Description of the Parameter
+     * @return                            Description of the Return Value
+     * @params                            buf the buffer to search
+     * @params                            ch the character to search for
+     * @params                            from the index to start the search
+     *      from
+     * @params                            to the highest possible index returned
+     *      plus 1
+     * @throws IndexOutOfBoundsException  if index out of bounds...
+     */
+    public final static int indexOf(char[] buf, int ch, int from, int to)
+    {
+        int i;
+        for (i = from; i < to && buf[i] != ch; i++)
+        {
+            ;
+        }
+        // do nothing
+        if (i < to)
+        {
+            return i;
+        }
+        else
+        {
+            return -1;
+        }
+    }
+
+}
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/SimpleCharArrayWriter.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/SimpleCharArrayWriter.java
index 11b3f537..fb9da1eb 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/SimpleCharArrayWriter.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/SimpleCharArrayWriter.java
@@ -1,2 +1,44 @@
   - 1.2
   + 1.3
+package de.lanlab.larm.parser;
+
+import java.io.CharArrayWriter;
+
+/**
+ * <p>Title: </p>
+ * <p>Description: </p>
+ * <p>Copyright: Copyright (c) 2002</p>
+ * <p>Company: </p>
+ * @author unascribed
+ * @version 1.0
+ */
+
+public final class SimpleCharArrayWriter extends java.io.CharArrayWriter {
+    public SimpleCharArrayWriter() {
+        super();
+    }
+
+    public SimpleCharArrayWriter(int size) {
+        super(size);
+    }
+
+    // use only to *decrement* size
+    public void setLength(int size) {
+       // synchronized (lock) {
+            if (size < count) count = size;
+       // }
+    }
+
+    public char[] getCharArray() {
+       // synchronized (lock) {
+            return buf;
+       // }
+    }
+
+    public int getLength()
+    {
+        return count;
+    }
+
+
+}
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/Tokenizer.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/Tokenizer.java
index e13757e7..1142d65b 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/Tokenizer.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/parser/Tokenizer.java
@@ -57,14 +57,9 @@
 
 package de.lanlab.larm.parser;
 
-import hplb.org.xml.sax.*;
-import hplb.xml.*;
-import hplb.xml.util.*;
-
 import java.util.Dictionary;
 import java.util.Hashtable;
 import java.io.*;
-import hplb.misc.ByteArray;
 import java.net.URL;
 
 /**
@@ -74,42 +69,37 @@
  * some bugs. And it's FAST, about 10 x faster than the original HEX parser.
  * Being some sort of SAX parser it calls the callback functions of the LinkHandler
  * when links are found.
- * @todo add handling of anchor texts
+ * Attention: This parser is not thread safe, as a lot of locks were removed
  *
  * @author    Clemens Marschner
  * $Id$
  */
 
-public class Tokenizer implements hplb.org.xml.sax.Parser
+public class Tokenizer
 {
     /**
      * Sets the entityHandler attribute of the Tokenizer object
      *
      * @param e  The new entityHandler value
+     *
+    public void setEntityHandler(EntityHandler e) { }
      */
-    public void setEntityHandler(hplb.org.xml.sax.EntityHandler e) { }
-
 
     /**
      * Sets the errorHandler attribute of the Tokenizer object
      *
      * @param e  The new errorHandler value
-     */
+     *
     public void setErrorHandler(hplb.org.xml.sax.ErrorHandler e) { }
-
+    */
 
     /**
      * Sets the documentHandler attribute of the Tokenizer object
      *
      * @param e  The new documentHandler value
-     */
+     *
     public void setDocumentHandler(hplb.org.xml.sax.DocumentHandler e) { }
-
-
-    /**
-     * The value of boolean attributes is this string.
      */
-    public final static String BOOLATTR = Atom.getAtom("BOOLATTR");
 
     // FSM states:
     final static int ST_START = 1;
@@ -176,17 +166,17 @@ public void setDocumentHandler(hplb.org.xml.sax.DocumentHandler e) { }
     private boolean keepPCData;
     private boolean isInTitleTag;
     private boolean isInAnchorTag;
-    CharBuffer buf = new CharBuffer();
+    SimpleCharArrayWriter buf = new SimpleCharArrayWriter();
     boolean isStartTag = true;
     /**
      * Signals whether a non-empty element has any children. If not we must
      * generate an artificial empty-string child [characters(buf, 0, 0)].
      */
     boolean noChildren;
-    CharBuffer tagname = new CharBuffer();
-    CharBuffer attrName = new CharBuffer();
-    CharBuffer attrValue = new CharBuffer(1000);
-    CharBuffer pcData = new CharBuffer(8000);
+    SimpleCharArrayWriter tagname = new SimpleCharArrayWriter();
+    SimpleCharArrayWriter attrName = new SimpleCharArrayWriter();
+    SimpleCharArrayWriter attrValue = new SimpleCharArrayWriter(1000);
+    SimpleCharArrayWriter pcData = new SimpleCharArrayWriter(8000);
     int pcDataLength;
 
     /**
@@ -725,7 +715,7 @@ else if (c == '[')
                      // the next end tag, at most 200 characters.
                      // (end tags are often ommited, i.e. <a ...>text</td>)
                      // regards other tags as text
-                     // todo: read until next </a> or a couple other tags
+                     // @todo: read until next </a> or a couple of other tags
                     try
                     {
                         short count = 0;
@@ -994,7 +984,7 @@ protected void gotTag()
      * Description of the Method
      *
      * @param attrs  Description of the Parameter
-     */
+     *
     public final void keysToLowerCase(SAXAttributeMap attrs)
     {
         for (int i = 0; i < attrs.n; i++)
@@ -1006,7 +996,7 @@ public final void keysToLowerCase(SAXAttributeMap attrs)
             }
         }
     }
-
+    */
 
     // toomuch true iff we read a '<' of the next token
     /**
@@ -1039,7 +1029,7 @@ else if(isInAnchorTag)
      *  if (toomuch) {
      *  buf.setLength(buf.size() - 1);
      *  }
-     *  CharBuffer buf1 = rcgnzEntities ? entMngr.entityDecode(buf) : buf;
+     *  SimpleCharArrayWriter buf1 = rcgnzEntities ? entMngr.entityDecode(buf) : buf;
      *  docHandler.characters(buf1.getCharArray(), 0, buf1.size());
      *  /handler.gotText(getBuffer());
      *  toStart();
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/DocumentStorage.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/DocumentStorage.java
index b97ab661..b253700d 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/DocumentStorage.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/DocumentStorage.java
@@ -75,6 +75,9 @@
      * called to store a web document
      *
      * @param doc  the document
+     * @return the document itself or a changed version. Only makes sense if
+     * storage pipeline is used; usually the storage would return the document
+     * as is.
      */
-    public void store(WebDocument doc);
+    public WebDocument store(WebDocument doc);
 }
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LinkLogStorage.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LinkLogStorage.java
index 11b3f537..9e97d925 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LinkLogStorage.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LinkLogStorage.java
@@ -1,2 +1,61 @@
   - 1.2
   + 1.3
+package de.lanlab.larm.storage;
+
+import de.lanlab.larm.storage.LinkStorage;
+import de.lanlab.larm.util.SimpleLogger;
+import de.lanlab.larm.fetcher.URLMessage;
+
+import java.util.Collection;
+import java.util.Iterator;
+
+/**
+ * Description of the Class
+ *
+ * @author    Administrator
+ * @created   1. Juni 2002
+ */
+public class LinkLogStorage implements LinkStorage
+{
+
+    SimpleLogger log;
+
+
+    /**
+     * Constructor for the LinkLogStorage object
+     *
+     * @param logFile  Description of the Parameter
+     */
+    public LinkLogStorage(SimpleLogger logFile)
+    {
+        this.log = logFile;
+    }
+
+
+    /**
+     * empty
+     */
+    public void openLinkStorage()
+    {
+    }
+
+
+    /**
+     * Description of the Method
+     *
+     * @param c  Description of the Parameter
+     * @return   Description of the Return Value
+     */
+    public Collection storeLinks(Collection c)
+    {
+        synchronized (log)
+        {
+            for (Iterator it = c.iterator(); it.hasNext(); )
+            {
+                log.log(((URLMessage) it.next()).getInfo());
+            }
+        }
+        return c;
+    }
+
+}
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LinkStorage.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LinkStorage.java
index 11b3f537..514f6abc 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LinkStorage.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LinkStorage.java
@@ -1,2 +1,76 @@
   - 1.2
   + 1.3
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2001 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" and
+ *    "Apache Lucene" must not be used to endorse or promote products
+ *    derived from this software without prior written permission. For
+ *    written permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    "Apache Lucene", nor may "Apache" appear in their name, without
+ *    prior written permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ */
+
+package de.lanlab.larm.storage;
+import java.util.Collection;
+
+public interface LinkStorage
+{
+
+    /**
+     * Description of the Method
+     */
+    public void openLinkStorage();
+
+
+    /**
+     * stores the extracted links may contain links of more than one document
+     *
+     * @param c  Description of the Parameter
+     * @return   the collection, may have been changed or set to null
+     */
+    public Collection storeLinks(Collection c);
+}
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LogStorage.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LogStorage.java
index ae98e45d..1b519c2e 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LogStorage.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/LogStorage.java
@@ -194,11 +194,14 @@ public void setLogger(SimpleLogger log)
 
 
     /**
-     * stores the document if storing is enabled
+     * writes file info to log file;
+     * stores the document if storing is enabled. in that case the log line contains
+     * the page file number and the index within that file
      *
      * @param doc  Description of the Parameter
+     * @return the unchanged document
      */
-    public void store(WebDocument doc)
+    public WebDocument store(WebDocument doc)
     {
         String docInfo = doc.getInfo();
         if (logContents && isValid && doc.getDocumentBytes() != null)
@@ -207,5 +210,6 @@ public void store(WebDocument doc)
             docInfo = docInfo + "\t" + pageFileCount + "\t" + offset;
         }
         log.logThreadSafe(docInfo);
+        return doc;
     }
 }
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/NullStorage.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/NullStorage.java
index 7fb9bbbd..404d0dc9 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/NullStorage.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/NullStorage.java
@@ -67,7 +67,13 @@ public NullStorage()
     {
     }
 
-    public void open() {}
-    public void store(WebDocument doc) {}
+    public void open()
+    {
+    }
+
+    public WebDocument store(WebDocument doc)
+    {
+        return doc;
+    }
 
 }
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/SQLServerStorage.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/SQLServerStorage.java
index 0d4cab00..7703261b 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/SQLServerStorage.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/SQLServerStorage.java
@@ -195,7 +195,12 @@ public void open()
         }
     }
 
-    public void store(WebDocument document)
+    /**
+     *
+     * @param document
+     * @return the unchanged document
+     */
+    public WebDocument store(WebDocument document)
     {
 
         PreparedStatement addDoc = null;
@@ -220,5 +225,6 @@ public void store(WebDocument document)
                 releaseStatement(addDoc);
             }
         }
+        return document;
     }
 }
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/StoragePipeline.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/StoragePipeline.java
index 11b3f537..cd5ce59d 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/StoragePipeline.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/storage/StoragePipeline.java
@@ -1,2 +1,179 @@
   - 1.2
   + 1.3
+/*
+ *  ====================================================================
+ *  The Apache Software License, Version 1.1
+ *
+ *  Copyright (c) 2001 The Apache Software Foundation.  All rights
+ *  reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *  1. Redistributions of source code must retain the above copyright
+ *  notice, this list of conditions and the following disclaimer.
+ *
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *  notice, this list of conditions and the following disclaimer in
+ *  the documentation and/or other materials provided with the
+ *  distribution.
+ *
+ *  3. The end-user documentation included with the redistribution,
+ *  if any, must include the following acknowledgment:
+ *  "This product includes software developed by the
+ *  Apache Software Foundation (http://www.apache.org/)."
+ *  Alternately, this acknowledgment may appear in the software itself,
+ *  if and wherever such third-party acknowledgments normally appear.
+ *
+ *  4. The names "Apache" and "Apache Software Foundation" and
+ *  "Apache Lucene" must not be used to endorse or promote products
+ *  derived from this software without prior written permission. For
+ *  written permission, please contact apache@apache.org.
+ *
+ *  5. Products derived from this software may not be called "Apache",
+ *  "Apache Lucene", nor may "Apache" appear in their name, without
+ *  prior written permission of the Apache Software Foundation.
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ *  ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ *  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ *  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ *  SUCH DAMAGE.
+ *  ====================================================================
+ *
+ *  This software consists of voluntary contributions made by many
+ *  individuals on behalf of the Apache Software Foundation.  For more
+ *  information on the Apache Software Foundation, please see
+ *  <http://www.apache.org/>.
+ */
+package de.lanlab.larm.storage;
+
+import de.lanlab.larm.util.WebDocument;
+import de.lanlab.larm.fetcher.URLMessage;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.Collection;
+
+/**
+ * @author    Clemens Marschner
+ * @created   1. Juni 2002
+ * @version   $ver: $
+ */
+
+public class StoragePipeline implements DocumentStorage, LinkStorage
+{
+
+    boolean isOpen;
+    boolean isLinkStorageOpen;
+    ArrayList docStorages;
+    ArrayList linkStorages;
+
+
+    /**
+     * Constructor for the StoragePipeline object
+     */
+    public StoragePipeline()
+    {
+        isOpen = false;
+        isLinkStorageOpen = false;
+        docStorages = new ArrayList();
+        linkStorages = new ArrayList();
+    }
+
+
+    /**
+     * open all docStorages
+     */
+    public void open()
+    {
+        for (Iterator it = docStorages.iterator(); it.hasNext(); )
+        {
+            ((DocumentStorage) it.next()).open();
+        }
+        isOpen = true;
+    }
+
+
+    /**
+     * store the doc into all docStorages
+     * document is discarded if a storage.store() returns null
+     *
+     * @see de.lanlab.larm.storage.WebDocument#store
+     * @param doc  Description of the Parameter
+     * @return     Description of the Return Value
+     */
+    public WebDocument store(WebDocument doc)
+    {
+        for(Iterator it = docStorages.iterator(); it.hasNext();)
+        {
+            doc = ((DocumentStorage)it.next()).store(doc);
+            if(doc == null)
+            {
+                break;
+            }
+        }
+        return doc;
+    }
+
+
+    /**
+     * Adds a feature to the Storage attribute of the StoragePipeline object
+     *
+     * @param storage  The feature to be added to the Storage attribute
+     */
+    public void addDocStorage(DocumentStorage storage)
+    {
+        if (isOpen)
+        {
+            throw new IllegalStateException("storage can't be added if pipeline is already open");
+        }
+        docStorages.add(storage);
+    }
+
+    /**
+     * Adds a feature to the Storage attribute of the StoragePipeline object
+     *
+     * @param storage  The feature to be added to the Storage attribute
+     */
+    public void addLinkStorage(LinkStorage storage)
+    {
+        if (isOpen)
+        {
+            throw new IllegalStateException("storage can't be added if pipeline is already open");
+        }
+        linkStorages.add(storage);
+    }
+
+
+    public void openLinkStorage()
+    {
+        for (Iterator it = linkStorages.iterator(); it.hasNext(); )
+        {
+            ((LinkStorage) it.next()).openLinkStorage();
+        }
+        isLinkStorageOpen = true;
+    }
+
+    public Collection storeLinks(Collection c)
+    {
+        for(Iterator it = linkStorages.iterator(); it.hasNext();)
+        {
+            c =  ((LinkStorage)it.next()).storeLinks(c);
+            if(c == null)
+            {
+                break;
+            }
+        }
+        return c;
+    }
+}
+
diff --git a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/util/WebDocument.java b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/util/WebDocument.java
index 49bdcad5..eec7fc73 100644
--- a/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/util/WebDocument.java
+++ b/lucene/java/trunk/sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/util/WebDocument.java
@@ -144,7 +144,7 @@ public String getInfo()
         this.resultCode + "\t" +
         this.mimeType + "\t" +
         this.size + "\t" +
-        "\"" + this.title.replace('\"', (char)0xff ).replace('\n',' ').replace('\r',' ') + "\"";
+        "\"" + this.title.replace('\t',' ').replace('\"', (char)0xff ).replace('\n',' ').replace('\r',' ') + "\"";
     }
 
 
