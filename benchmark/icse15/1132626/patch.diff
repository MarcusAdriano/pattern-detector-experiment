diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java
index 5366dd2f..d3e68d18 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java
@@ -526,7 +526,7 @@ The offset from the base format number (0 based) gives the offset in the array.
         /* 461 */   "org.apache.derby.impl.sql.catalog.CoreDDFinderClassInfo",
         /* 462 */   "org.apache.derby.impl.sql.catalog.CoreDDFinderClassInfo",
         /* 463 */   "org.apache.derby.impl.sql.catalog.CoreDDFinderClassInfo",
-        /* 464 */   "org.apache.derby.iapi.types.SqlXmlUtil",        
+        /* 464 */   null,
 		/* 465 */   "org.apache.derby.impl.store.raw.data.CompressSpacePageOperation",
         /* 466 */   "org.apache.derby.impl.store.access.btree.index.B2I_10_3",
         /* 467 */   "org.apache.derby.impl.store.access.heap.Heap",
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java
index 4bf4d6df..72e0bbe4 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java
@@ -505,12 +505,6 @@ and another may restore (read) the object. The implication of this
     static public final int XML_TYPE_ID =
             (MIN_ID_2 + 456);
     
-    /**
-        class org.apache.derby.iapi.types.SqlXmlUtil
-    */
-    static public final int SQL_XML_UTIL_V01_ID =
-            (MIN_ID_2 + 464);
-    
     /**
         class org.apache.derby.iapi.types.JSQLType
      */
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/SqlXmlUtil.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/SqlXmlUtil.java
index 84034251..6c624a11 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/SqlXmlUtil.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/SqlXmlUtil.java
@@ -23,8 +23,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 import org.apache.derby.iapi.error.StandardException;
 import org.apache.derby.iapi.reference.SQLState;
-import org.apache.derby.iapi.services.io.Formatable;
-import org.apache.derby.iapi.services.io.StoredFormatIds;
 import org.apache.derby.iapi.services.sanity.SanityManager;
 
 import java.util.Properties;
@@ -33,8 +31,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import java.util.List;
 
 import java.io.IOException;
-import java.io.ObjectOutput;
-import java.io.ObjectInput;
 import java.io.StringReader;
 
 import java.lang.reflect.InvocationTargetException;
@@ -84,10 +80,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
  *       query expression a single time per statement, instead of
  *       having to do it for every row against which the query
  *       is evaluated.  An instance of this class is created at
- *       compile time and then passed (using "saved objects")
- *       to the appropriate operator implementation method in
- *       XML.java; see SqlXmlExecutor.java for more about the
- *       role this class plays in "saved object" processing.
+ *       compile time and then passed to the appropriate operator
+ *       implementation method in XML.java.
  *
  *    2. By keeping all XML-specific references in this one class, 
  *       we have a single "point of entry" to the XML objects--namely,
@@ -113,7 +107,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
  *       _if_ s/he is trying to access or operate on XML values.
  */
 
-public class SqlXmlUtil implements Formatable
+public class SqlXmlUtil
 {
     // Used to parse a string into an XML value (DOM); checks
     // the well-formedness of the string while parsing.
@@ -803,58 +797,6 @@ private static String numberToString(double d)
         }
     }
 
-    /* ****
-     * Formatable interface implementation
-     * */
-
-    /** 
-     * @see java.io.Externalizable#writeExternal 
-     * 
-     * @exception IOException on error
-     */
-    public void writeExternal(ObjectOutput out) 
-        throws IOException
-    {
-        // query may be null
-        if (query == null)
-        {
-            out.writeBoolean(false);
-        }
-        else
-        {
-            out.writeBoolean(true);
-            out.writeObject(queryExpr);
-            out.writeObject(opName);
-        }
-    }
-
-    /** 
-     * @see java.io.Externalizable#readExternal 
-     *
-     * @exception IOException on error
-     * @exception ClassNotFoundException on error
-     */
-    public void readExternal(ObjectInput in) 
-        throws IOException, ClassNotFoundException
-    {
-        if (in.readBoolean())
-        {
-            queryExpr = (String)in.readObject();
-            opName = (String)in.readObject();
-            recompileQuery = true;
-	    }
-    }
-
-    /**
-     * Get the formatID which corresponds to this class.
-     *
-     * @return	the formatID of this class
-     */
-    public int getTypeFormatId()
-    { 
-        return StoredFormatIds.SQL_XML_UTIL_V01_ID;
-    }
-
     /*
      ** The XMLErrorHandler class is just a generic implementation
      ** of the ErrorHandler interface.  It allows us to catch
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XML.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XML.java
index 154f31f2..332d87de 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XML.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XML.java
@@ -598,7 +598,7 @@ public void loadStream() throws StandardException
      * store the _serialized_ version locally and then return
      * this XMLDataValue.
      *
-     * @param text The string value to check.
+     * @param stringValue The string value to check.
      * @param preserveWS Whether or not to preserve
      *  ignorable whitespace.
      * @param sqlxUtil Contains SQL/XML objects and util
@@ -609,9 +609,18 @@ public void loadStream() throws StandardException
      *  value is returned; otherwise, an exception is thrown. 
      * @exception StandardException Thrown on error.
      */
-    public XMLDataValue XMLParse(String text, boolean preserveWS,
-        SqlXmlUtil sqlxUtil) throws StandardException
+    public XMLDataValue XMLParse(
+            StringDataValue stringValue,
+            boolean preserveWS,
+            SqlXmlUtil sqlxUtil)
+        throws StandardException
     {
+        if (stringValue.isNull()) {
+            setToNull();
+            return this;
+        }
+
+        String text = stringValue.getString();
         try {
 
             if (preserveWS) {
@@ -834,10 +843,10 @@ public BooleanDataValue XMLExists(SqlXmlUtil sqlxUtil)
      * the received XMLDataValue "result" param (assuming "result" is
      * non-null; else create a new XMLDataValue).
      *
-     * @param result The result of a previous call to this method; null
-     *  if not called yet.
      * @param sqlxUtil Contains SQL/XML objects and util methods that
      *  facilitate execution of XML-related operations
+     * @param result The result of a previous call to this method; null
+     *  if not called yet.
      * @return An XMLDataValue whose content corresponds to the serialized
      *  version of the results from evaluation of the query expression.
      *  Note: this XMLDataValue may not be storable into Derby XML
@@ -845,8 +854,8 @@ public BooleanDataValue XMLExists(SqlXmlUtil sqlxUtil)
      * @exception Exception thrown on error (and turned into a
      *  StandardException by the caller).
      */
-    public XMLDataValue XMLQuery(XMLDataValue result,
-        SqlXmlUtil sqlxUtil) throws StandardException
+    public XMLDataValue XMLQuery(SqlXmlUtil sqlxUtil, XMLDataValue result)
+            throws StandardException
     {
         if (this.isNull()) {
         // if the context is null, we return null,
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XMLDataValue.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XMLDataValue.java
index 5ff48d14..890438b8 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XMLDataValue.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XMLDataValue.java
@@ -30,7 +30,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
      * store the _serialized_ version locally and then return
      * this XMLDataValue.
      *
-     * @param text The string value to check.
+     * @param stringValue The string value to check.
      * @param preserveWS Whether or not to preserve
      *  ignorable whitespace.
      * @param sqlxUtil Contains SQL/XML objects and util
@@ -41,8 +41,11 @@ Licensed to the Apache Software Foundation (ASF) under one or more
      *  value returned; otherwise, an exception is thrown. 
      * @exception StandardException Thrown on error.
      */
-	public XMLDataValue XMLParse(String text, boolean preserveWS,
-		SqlXmlUtil sqlxUtil) throws StandardException;
+    public XMLDataValue XMLParse(
+            StringDataValue stringValue,
+            boolean preserveWS,
+            SqlXmlUtil sqlxUtil)
+        throws StandardException;
 
     /**
      * The SQL/XML XMLSerialize operator.
@@ -90,10 +93,10 @@ public BooleanDataValue XMLExists(SqlXmlUtil sqlxUtil)
      * the received XMLDataValue "result" param (assuming "result" is
      * non-null; else create a new XMLDataValue).
      *
-     * @param result The result of a previous call to this method; null
-     *  if not called yet.
      * @param sqlxUtil Contains SQL/XML objects and util methods that
      *  facilitate execution of XML-related operations
+     * @param result The result of a previous call to this method; null
+     *  if not called yet.
      * @return An XMLDataValue whose content corresponds to the serialized
      *  version of the results from evaluation of the query expression.
      *  Note: this XMLDataValue may not be storable into Derby XML
@@ -101,7 +104,7 @@ public BooleanDataValue XMLExists(SqlXmlUtil sqlxUtil)
      * @exception Exception thrown on error (and turned into a
      *  StandardException by the caller).
      */
-    public XMLDataValue XMLQuery(XMLDataValue result, SqlXmlUtil sqlxUtil)
+    public XMLDataValue XMLQuery(SqlXmlUtil sqlxUtil, XMLDataValue result)
 		throws StandardException;
 
     /* ****
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java
index 2b3036b9..4adbb338 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java
@@ -4580,6 +4580,9 @@ public void	dropSPSDescriptor(SPSDescriptor descriptor,
 	/**
 	 * Get every statement in this database.
 	 * Return the SPSDescriptors in an list.
+     * The returned descriptors don't contain the compiled statement, so it
+     * it safe to call this method during upgrade when it isn't known if the
+     * saved statement can still be deserialized with the new version.
 	 *
 	 * @return the list of descriptors
 	 *
@@ -4592,7 +4595,23 @@ public List getAllSPSDescriptors()
 
 		List list = newSList();
 
+        // DERBY-3870: The compiled plan may not be possible to deserialize
+        // during upgrade. Skip the column that contains the compiled plan to
+        // prevent deserialization errors when reading the rows. We don't care
+        // about the value in that column, since this method is only called
+        // when we want to drop or invalidate rows in SYSSTATEMENTS.
+        FormatableBitSet cols = new FormatableBitSet(
+                ti.getCatalogRowFactory().getHeapColumnCount());
+        for (int i = 0; i < cols.size(); i++) {
+            if (i + 1 == SYSSTATEMENTSRowFactory.SYSSTATEMENTS_CONSTANTSTATE) {
+                cols.clear(i);
+            } else {
+                cols.set(i);
+            }
+        }
+
 		getDescriptorViaHeap(
+                        cols,
 						(ScanQualifier[][]) null,
 						ti,
 						(TupleDescriptor) null,
@@ -4647,6 +4666,7 @@ private GenericDescriptorList getAllTriggerDescriptors()
 		GenericDescriptorList list = new GenericDescriptorList();
 
 		getDescriptorViaHeap(
+                        null,
 						(ScanQualifier[][]) null,
 						ti,
 						(TupleDescriptor) null,
@@ -7035,10 +7055,7 @@ public ConglomerateDescriptor getConglomerateDescriptor(
   				false);
 
 		ConglomerateDescriptorList cdl = new ConglomerateDescriptorList();
-		getDescriptorViaHeap(scanQualifier,
-								 ti,
-								 null,
-								 cdl);
+		getDescriptorViaHeap(null, scanQualifier, ti, null, cdl);
 
 		int size = cdl.size();
 		ConglomerateDescriptor[] cda = new ConglomerateDescriptor[size];
@@ -9471,6 +9488,8 @@ private void debugGenerateInfo(StringBuffer strbuf,
 	 * Return a (single or list of) catalog row descriptor(s) from a
 	 * system table where the access a heap scan
 	 *
+     * @param columns                   which columns to fetch from the system
+     *                                  table, or null to fetch all columns
 	 * @param scanQualifiers			qualifiers
 	 * @param ti						The TabInfoImpl to use
 	 * @param parentTupleDescriptor		The parentDescriptor, if applicable.
@@ -9482,6 +9501,7 @@ private void debugGenerateInfo(StringBuffer strbuf,
 	 * @exception StandardException		Thrown on error
 	 */
 	protected TupleDescriptor getDescriptorViaHeap(
+                        FormatableBitSet columns,
 						ScanQualifier [][] scanQualifiers,
 						TabInfoImpl ti,
 						TupleDescriptor parentTupleDescriptor,
@@ -9509,7 +9529,7 @@ protected TupleDescriptor getDescriptorViaHeap(
 				0, 							// for read
 				TransactionController.MODE_TABLE,
                 TransactionController.ISOLATION_REPEATABLE_READ,
-				(FormatableBitSet) null,         // all fields as objects
+				columns,
 				(DataValueDescriptor[]) null,		// start position - first row
 				0,      				// startSearchOperation - none
 				scanQualifiers, 		// scanQualifier,
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java
index 356bb7d3..f160f445 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java
@@ -21,25 +21,16 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 package	org.apache.derby.impl.sql.compile;
 
-import org.apache.derby.iapi.sql.compile.Visitable;
 import org.apache.derby.iapi.sql.compile.Visitor;
-import org.apache.derby.iapi.sql.dictionary.DataDictionary;
 import org.apache.derby.iapi.error.StandardException;
 
 import org.apache.derby.iapi.services.sanity.SanityManager;
 import org.apache.derby.iapi.services.compiler.MethodBuilder;
 import org.apache.derby.iapi.services.compiler.LocalField;
-import org.apache.derby.iapi.services.io.StoredFormatIds;
 
 import java.lang.reflect.Modifier;
-import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
-import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
-import org.apache.derby.iapi.types.StringDataValue;
 import org.apache.derby.iapi.types.TypeId;
 import org.apache.derby.iapi.types.DataTypeDescriptor;
-import org.apache.derby.iapi.types.SqlXmlUtil;
-
-import org.apache.derby.iapi.store.access.Qualifier;
 
 import org.apache.derby.iapi.reference.ClassName;
 import org.apache.derby.iapi.reference.JDBC40Translation;
@@ -48,7 +39,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.util.JBitSet;
 import org.apache.derby.iapi.services.classfile.VMOpcode;
 
-import java.sql.Types;
 import java.util.Vector;
 
 /**
@@ -59,7 +49,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
  *
  */
 
-public class BinaryOperatorNode extends ValueNode
+public class BinaryOperatorNode extends OperatorNode
 {
 	String	operator;
 	String	methodName;
@@ -125,9 +115,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 		{ClassName.StringDataValue, ClassName.XMLDataValue}		// XMLQuery
 	};
 
-	// Class used to compile an XML query expression and/or load/process
-	// XML-specific objects.
-	private SqlXmlUtil sqlxUtil;
+    /** The query expression if the operator is XMLEXISTS or XMLQUERY. */
+    private String xmlQuery;
 
 	/**
 	 * Initializer for a BinaryOperatorNode
@@ -352,11 +341,7 @@ public ValueNode bindXMLQuery()
                 SQLState.LANG_INVALID_XML_QUERY_EXPRESSION);
         }
         else {
-        // compile the query expression.
-            sqlxUtil = new SqlXmlUtil();
-            sqlxUtil.compileXQExpr(
-                ((CharConstantNode)leftOperand).getString(),
-                (operatorType == XMLEXISTS_OP ? "XMLEXISTS" : "XMLQUERY"));
+            xmlQuery = ((CharConstantNode)leftOperand).getString();
         }
 
         // Right operand must be an XML data value.  NOTE: This
@@ -498,29 +483,15 @@ public void generateExpression(ExpressionClassBuilder acb,
 ** but how?
 */
 
+        // The number of arguments to pass to the method that implements the
+        // operator, depends on the type of the operator.
+        int numArgs;
+
 		// If we're dealing with XMLEXISTS or XMLQUERY, there is some
 		// additional work to be done.
 		boolean xmlGen =
 			(operatorType == XMLQUERY_OP) || (operatorType == XMLEXISTS_OP);
 
-		if (xmlGen) {
-		// We create an execution-time object so that we can retrieve
-		// saved objects (esp. our compiled query expression) from
-		// the activation.  We do this for two reasons: 1) this level
-		// of indirection allows us to separate the XML data type
-		// from the required XML implementation classes (esp. JAXP
-		// and Xalan classes)--for more on how this works, see the
-		// comments in SqlXmlUtil.java; and 2) we can take
-		// the XML query expression, which we've already compiled,
-		// and pass it to the execution-time object for each row,
-		// which means that we only have to compile the query
-		// expression once per SQL statement (instead of once per
-		// row); see SqlXmlExecutor.java for more.
-			mb.pushNewStart(
-				"org.apache.derby.impl.sql.execute.SqlXmlExecutor");
-			mb.pushNewComplete(addXmlOpMethodParams(acb, mb));
-		}
-
 		/*
 		** The receiver is the operand with the higher type precedence.
 		** Like always makes the left the receiver.
@@ -558,6 +529,9 @@ public void generateExpression(ExpressionClassBuilder acb,
 			rightOperand.generateExpression(acb, mb);
 			mb.cast(rightInterfaceType); // second arg with cast
 			// stack: left, left, right
+
+            // We've pushed two arguments
+            numArgs = 2;
 		}
 		else
 		{
@@ -581,21 +555,25 @@ public void generateExpression(ExpressionClassBuilder acb,
 			** UNLESS we're generating an XML operator such as XMLEXISTS.
 			** In that case we want to generate
 			** 
-			**  SqlXmlExecutor.method(left, right)"
-			**
-			** and we've already pushed the SqlXmlExecutor object to
-			** the stack.
+			**  <right expression>.method(sqlXmlUtil)
 			*/
 
 			rightOperand.generateExpression(acb, mb);			
 			mb.cast(receiverType); // cast the method instance
 			// stack: right
 			
-			if (!xmlGen) {
+            if (xmlGen) {
+                // Push one argument (the SqlXmlUtil instance)
+                numArgs = 1;
+                pushSqlXmlUtil(acb, mb, xmlQuery, operator);
+                // stack: right,sqlXmlUtil
+            } else {
+                // Push two arguments (left, right)
+                numArgs = 2;
+
 				mb.dup();
 				mb.cast(rightInterfaceType);
 				// stack: right,right
-			}
 			
 			leftOperand.generateExpression(acb, mb);
 			mb.cast(leftInterfaceType); // second arg with cast
@@ -604,21 +582,20 @@ public void generateExpression(ExpressionClassBuilder acb,
 			mb.swap();
 			// stack: right,left,right			
 		}
+		}
 
 		/* Figure out the result type name */
 		resultTypeName = (operatorType == -1)
 			? getTypeCompiler().interfaceName()
 			: resultInterfaceType;
 
-		// Boolean return types don't need a result field
-		boolean needField = !getTypeId().isBooleanTypeId();
-
-		if (needField) {
-
-			/* Allocate an object for re-use to hold the result of the operator */
-			LocalField resultField =
-				acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
+        // Boolean return types don't need a result field. For other types,
+        // allocate an object for re-use to hold the result of the operator.
+        LocalField resultField = getTypeId().isBooleanTypeId() ?
+            null : acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
 
+        // Push the result field onto the stack, if there is a result field.
+		if (resultField != null) {
 			/*
 			** Call the method for this operator.
 			*/
@@ -627,6 +604,9 @@ public void generateExpression(ExpressionClassBuilder acb,
 			//before generating code "field = method(p1, p2, field);"
 			initializeResultField(acb, mb, resultField);
 
+            // Adjust number of arguments for the result field
+            numArgs++;
+
 			/* pass statically calculated scale to decimal divide method to make
 			 * result set scale consistent, beetle 3901
 			 */
@@ -637,17 +617,15 @@ public void generateExpression(ExpressionClassBuilder acb,
 				operator.equals("/"))
 			{
 				mb.push(getTypeServices().getScale());		// 4th arg
-				mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultTypeName, 4);
+                numArgs++;
 			}
-			else if (xmlGen) {
-			// This is for an XMLQUERY operation, so invoke the method
-			// on our execution-time object.
-				mb.callMethod(VMOpcode.INVOKEVIRTUAL, null,
-					methodName, resultTypeName, 3);
 			}
-			else
-				mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultTypeName, 3);
 
+        mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType,
+                      methodName, resultTypeName, numArgs);
+
+        // Store the result of the method call, if there is a result field.
+        if (resultField != null) {
 			//the need for following if was realized while fixing bug 5704 where decimal*decimal was resulting an overflow value but we were not detecting it
 			if (getTypeId().variableLength())//since result type is numeric variable length, generate setWidth code.
 			{
@@ -670,17 +648,6 @@ else if (xmlGen) {
 			*/
 
 			mb.putField(resultField);
-		} else {
-			if (xmlGen) {
-			// This is for an XMLEXISTS operation, so invoke the method
-			// on our execution-time object.
-				mb.callMethod(VMOpcode.INVOKEVIRTUAL, null,
-					methodName, resultTypeName, 2);
-			}
-			else {
-				mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType,
-					methodName, resultTypeName, 2);
-			}
 		}
 	}
 
@@ -875,32 +842,4 @@ protected boolean isEquivalent(ValueNode o) throws StandardException
         	       && leftOperand.isEquivalent(other.leftOperand)
         	       && rightOperand.isEquivalent(other.rightOperand);
         }
-
-	/**
-	 * Push the fields necessary to generate an instance of
-	 * SqlXmlExecutor, which will then be used at execution
-	 * time to retrieve the compiled XML query expression,
-	 * along with any other XML-specific objects.
-	 *
-	 * @param acb The ExpressionClassBuilder for the class we're generating
-	 * @param mb  The method the code to place the code
-	 *
-	 * @return The number of items that this method pushed onto
-	 *  the mb's stack.
-	 */
-	private int addXmlOpMethodParams(ExpressionClassBuilder acb,
-		MethodBuilder mb) throws StandardException
-	{
-		// Push activation so that we can get our saved object
-		// (which will hold the compiled XML query expression)
-		// back at execute time.
-		acb.pushThisAsActivation(mb);
-
-		// Push our saved object (the compiled query and XML-specific
-		// objects).
-		mb.push(getCompilerContext().addSavedObject(sqlxUtil));
-
-		// We pushed 2 items to the stack.
-		return 2;
-	}
 }
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/OperatorNode.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/OperatorNode.java
index e69de29b..62913b26 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/OperatorNode.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/OperatorNode.java
@@ -0,0 +1,88 @@
+/*
+
+   Derby - Class org.apache.derby.impl.sql.compile.OperatorNode
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.impl.sql.compile;
+
+import java.lang.reflect.Modifier;
+import org.apache.derby.iapi.services.classfile.VMOpcode;
+import org.apache.derby.iapi.services.compiler.LocalField;
+import org.apache.derby.iapi.services.compiler.MethodBuilder;
+import org.apache.derby.iapi.types.SqlXmlUtil;
+
+/**
+ * Abstract base-class for the various operator nodes: UnaryOperatorNode,
+ * BinaryOperatorNode and TernarnyOperatorNode.
+ */
+abstract class OperatorNode extends ValueNode {
+
+    /**
+     * <p>
+     * Generate code that pushes an SqlXmlUtil instance onto the stack. The
+     * instance will be created and cached in the activation's constructor, so
+     * that we don't need to create a new instance for every row.
+     * </p>
+     *
+     * <p>
+     * If the {@code xmlQuery} parameter is non-null, there will also be code
+     * that compiles the query when the SqlXmlUtil instance is created.
+     * </p>
+     *
+     * @param acb builder for the class in which the generated code lives
+     * @param mb builder for the method that implements this operator
+     * @param xmlQuery the XML query to be executed by the operator, or
+     * {@code null} if this isn't an XMLEXISTS or XMLQUERY operator
+     * @param xmlOpName the name of the operator (ignored if {@code xmlQuery}
+     * is {@code null})
+     */
+    static void pushSqlXmlUtil(
+            ExpressionClassBuilder acb, MethodBuilder mb,
+            String xmlQuery, String xmlOpName) {
+
+        // Create a field in which the instance can be cached.
+        LocalField sqlXmlUtil = acb.newFieldDeclaration(
+                Modifier.PRIVATE | Modifier.FINAL, SqlXmlUtil.class.getName());
+
+        // Add code that creates the SqlXmlUtil instance in the constructor.
+        MethodBuilder constructor = acb.getConstructor();
+        constructor.pushNewStart(SqlXmlUtil.class.getName());
+        constructor.pushNewComplete(0);
+        constructor.putField(sqlXmlUtil);
+
+        // Compile the query, if one is specified.
+        if (xmlQuery == null) {
+            // No query. The SqlXmlUtil instance is still on the stack. Pop it
+            // to restore the initial state of the stack.
+            constructor.pop();
+        } else {
+            // Compile the query. This will consume the SqlXmlUtil instance
+            // and leave the stack in its initial state.
+            constructor.push(xmlQuery);
+            constructor.push(xmlOpName);
+            constructor.callMethod(
+                    VMOpcode.INVOKEVIRTUAL, SqlXmlUtil.class.getName(),
+                    "compileXQExpr", "void", 2);
+        }
+
+        // Read the cached value and push it onto the stack in the method
+        // generated for the operator.
+        mb.getField(sqlXmlUtil);
+    }
+}
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java
index f96fe0f6..2d61d2b8 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java
@@ -54,7 +54,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
  *
  */
 
-public class TernaryOperatorNode extends ValueNode
+public class TernaryOperatorNode extends OperatorNode
 {
 	String		operator;
 	String		methodName;
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java
index 11cba27c..42128caf 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java
@@ -23,11 +23,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 import org.apache.derby.iapi.store.access.Qualifier;
 
-import org.apache.derby.iapi.sql.compile.Visitable;
 import org.apache.derby.iapi.sql.compile.Visitor;
 
-import org.apache.derby.iapi.sql.dictionary.DataDictionary;
-
 import org.apache.derby.iapi.reference.JDBC40Translation;
 import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.reference.ClassName;
@@ -35,15 +32,11 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.services.sanity.SanityManager;
 import org.apache.derby.iapi.services.compiler.MethodBuilder;
 import org.apache.derby.iapi.services.compiler.LocalField;
-import org.apache.derby.iapi.services.io.StoredFormatIds;
 
-import org.apache.derby.iapi.types.StringDataValue;
 import org.apache.derby.iapi.types.TypeId;
 import org.apache.derby.iapi.types.DataTypeDescriptor;
-import org.apache.derby.iapi.types.SqlXmlUtil;
 
 import java.lang.reflect.Modifier;
-import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
 
 import org.apache.derby.iapi.util.JBitSet;
 import org.apache.derby.iapi.services.classfile.VMOpcode;
@@ -59,7 +52,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
  *
  */
 
-public class UnaryOperatorNode extends ValueNode
+public class UnaryOperatorNode extends OperatorNode
 {
 	String	operator;
 	String	methodName;
@@ -121,10 +114,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	// args required by the operator method call.
 	private Object [] additionalArgs;
 
-	// Class used to hold XML-specific objects required for
-	// parsing/serializing XML data.
-	private SqlXmlUtil sqlxUtil;
-
 	/**
 	 * Initializer for a UnaryOperatorNode.
 	 *
@@ -383,12 +372,6 @@ private void bindXMLParse() throws StandardException
             }
         }
 
-        // Create a new XML compiler object; the constructor
-        // here automatically creates the XML-specific objects 
-        // required for parsing/serializing XML, so all we
-        // have to do is create an instance.
-        sqlxUtil = new SqlXmlUtil();
-
         // The result type of XMLParse() is always an XML type.
         setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor(
                 JDBC40Translation.SQLXML));
@@ -624,26 +607,6 @@ public void generateExpression(ExpressionClassBuilder acb,
 											MethodBuilder mb)
 									throws StandardException
 	{
-		// For XML operator we do some extra work.
-		boolean xmlGen = (operatorType == XMLPARSE_OP) ||
-			(operatorType == XMLSERIALIZE_OP);
-
-		if (xmlGen) {
-		// We create an execution-time object from which we call
-		// the necessary methods.  We do this for two reasons: 1) this
-		// level of indirection allows us to separate the XML data type
-		// from the required XML implementation classes (esp. JAXP and
-		// Xalan classes)--for more on how this works, see the comments
-		// in SqlXmlUtil.java; and 2) this allows us to create the
-		// required XML objects a single time (which we did at bind time
-		// when we created a new SqlXmlUtil) and then reuse those objects
-		// for each row in the target result set, instead of creating
-		// new objects every time; see SqlXmlUtil.java for more.
-			mb.pushNewStart(
-				"org.apache.derby.impl.sql.execute.SqlXmlExecutor");
-			mb.pushNewComplete(addXmlOpMethodParams(acb, mb));
-		}
-
 		String resultTypeName = 
 			(operatorType == -1)
 				? getTypeCompiler().interfaceName()
@@ -664,25 +627,13 @@ public void generateExpression(ExpressionClassBuilder acb,
 			LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
 			mb.getField(field);
 
-			/* If we're calling a method on a class (SqlXmlExecutor) instead
-			 * of calling a method on the operand interface, then we invoke
-			 * VIRTUAL; we then have 2 args (the operand and the local field)
-			 * instead of one, i.e:
-			 *
-			 *  SqlXmlExecutor.method(operand, field)
-			 *
-			 * instead of
-			 *
-			 *  <operand>.method(field).
-			 */
-			if (xmlGen) {
-				mb.callMethod(VMOpcode.INVOKEVIRTUAL, null,
-					methodName, resultTypeName, 2);
-			}
-			else {
-				mb.callMethod(VMOpcode.INVOKEINTERFACE,
-					(String) null, methodName, resultTypeName, 1);
-			}
+            int numArgs = 1;
+
+            // XML operators take extra arguments.
+            numArgs += addXmlOpMethodParams(acb, mb, field);
+
+            mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
+                          methodName, resultTypeName, numArgs);
 
 			/*
 			** Store the result of the method call in the field, so we can re-use
@@ -763,11 +714,14 @@ void acceptChildren(Visitor v)
     /**
      * Add some additional arguments to our method call for
      * XML related operations like XMLPARSE and XMLSERIALIZE.
+     *
+     * @param acb the builder for the class in which the method lives
      * @param mb The MethodBuilder that will make the call.
+     * @param resultField the field that contains the previous result
      * @return Number of parameters added.
      */
     protected int addXmlOpMethodParams(ExpressionClassBuilder acb,
-		MethodBuilder mb) throws StandardException
+		MethodBuilder mb, LocalField resultField) throws StandardException
     {
         if ((operatorType != XMLPARSE_OP) && (operatorType != XMLSERIALIZE_OP))
         // nothing to do.
@@ -798,20 +752,26 @@ protected int addXmlOpMethodParams(ExpressionClassBuilder acb,
 
         /* Else we're here for XMLPARSE. */
 
-        // Push activation, which we use at execution time to
-        // get our saved object (which will hold objects used
-        // for parsing/serializing) back.
-        acb.pushThisAsActivation(mb);
+        // XMLPARSE is different from other unary operators in that the method
+        // must be called on the result object (the XML value) and not on the
+        // operand (the string value). We must therefore make sure the result
+        // object is not null.
+        MethodBuilder constructor = acb.getConstructor();
+        acb.generateNull(constructor, getTypeCompiler(),
+                         getTypeServices().getCollationType());
+        constructor.setField(resultField);
 
-        // Push our XML object (used for parsing/serializing) as
-        // a saved object, so that we can retrieve it at execution
-        // time.  This allows us to avoid having to re-create the
-        // objects for every row in a given result set.
-        mb.push(getCompilerContext().addSavedObject(sqlxUtil));
+        // Swap operand and result object so that the method will be called
+        // on the result object.
+        mb.swap();
 
         // Push whether or not we want to preserve whitespace.
         mb.push(((Boolean)additionalArgs[0]).booleanValue());
-        return 3;
+
+        // Push the SqlXmlUtil instance as the next argument.
+        pushSqlXmlUtil(acb, mb, null, null);
+
+        return 2;
     }
     
     /**
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/SqlXmlExecutor.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/SqlXmlExecutor.java
index 827504ae..e69de29b 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/SqlXmlExecutor.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/SqlXmlExecutor.java
@@ -1,275 +0,0 @@
-/*
-
-   Derby - Class org.apache.derby.impl.sql.execute.SqlXmlExecutor
-
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to You under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-
-package org.apache.derby.impl.sql.execute;
-
-import org.apache.derby.iapi.error.StandardException;
-import org.apache.derby.iapi.reference.SQLState;
-import org.apache.derby.iapi.sql.Activation;
-
-import org.apache.derby.iapi.types.BooleanDataValue;
-import org.apache.derby.iapi.types.StringDataValue;
-import org.apache.derby.iapi.types.XML;
-import org.apache.derby.iapi.types.XMLDataValue;
-import org.apache.derby.iapi.types.SqlXmlUtil;
-
-/**
- * This class is really just an execution time "utility" that
- * makes calls to methods on the XMLDataValue interface.  Instances
- * of this class are generated at execution time by the various
- * Derby XML operators--one instance for each row in the target
- * result set--and then the appropriate operator call is made on
- * that instance (see, for example, the generateExpression() methods
- * in UnaryOperatorNode and BinaryOperatorNode).  When an instance
- * of this class is instantiated, one of the arguments that can be
- * provided is an id that is used to retrieve an already-constructed
- * (from compilation time) instance of SqlXmlUtil from the current
- * Activation.  When it comes time to execute the operator, this class
- * just makes the appropriate call on the received XMLDataValue object
- * and passes in the SqlXmlUtil, from which the XMLDataValue can
- * retrieve compile-time objects.  The XMLDataValue can also make
- * calls to various XML-specific utilities on the SqlXmlUtil
- * object.
- *
- * Let's take an example.  Assume the statement that the user
- * wants to execute is:
- *
- *   select id from xtable
- *      where XMLEXISTS('/simple' PASSING BY REF xcol)
- *
- * At compilation time we will compile the expression "/simple"
- * and store the compiled version of the query into an instance
- * of SqlXmlUtil.  Then we will save that instance of SqlXmlUtil
- * as an object in the statement activation, from which we will
- * receive an id that can be used later to retrieve the object
- * (i.e. to retrieve the SqlXmlUtil).  Then, for *each* row
- * in xtable, we'll generate the following:
- *
- *  boolean result =
- *    (new SqlXmlExecutor(activation, compileTimeObjectId)).
- *      XMLExists("/simple", xcol);
- *
- * In other words, for each row we create a new instance of
- * this class and call "XMLExists" on that instance.  Then,
- * as seen below, we retrieve the SqlXmlUtil from the activation
- * and pass that into a call to "XMLExists" on the XML value
- * itself (i.e. xcol).  XMLDataValue.XMLExists() then uses the
- * methods and objects (which include the compiled query
- * expression for "/simple") defined on SqlXmlUtil to complete
- * the operation.
- * 
- * Okay, so why do we use this execution-time SqlXmlExecutor class
- * instead of just generating a call to XMLDataValue.XMLExists()
- * directly?  The reason is that we only want to compile the XML
- * query expression once per statement--and where possible we'd
- * also like to only generate re-usable XML-specific objects
- * once per statement, as well.  If instead we generated a call to
- * XMLDataValue.XMLExists() directly for each row, then we would
- * have to either pass in the expression string and have XMLDataValue
- * compile it, or we would have to compile the expression string
- * and then pass the compiled object into XMLDataValue--in either
- * case, we'd end up compiling the XML query expression (and creating
- * the corresponding XML-specific objects) once for each row in
- * the target result set.  By using the "saveObject" functionality
- * in Activation along with this SqlXmlExecutor class, we make
- * it so that we only have to compile the XML query expression and
- * create XML-specific objects once (at compile time), and then
- * we can re-use those objects for every row in the target
- * result set.  Yes, we're still creating an instance of this
- * class (SqlXmlExecutor) once per row, and yes we have to fetch
- * the appropriate SqlXmlUtil object once per row, but this is
- * still going to be cheaper than having to re-compile the query
- * expression and re-create XML objects for every row.
- * 
- * So in short, this class allows us to improve the execution-time
- * performance of XML operators by allowing us to create XML-
- * specific objects and compile XML query expressions once per
- * statement, instead of once per row.
- *
- * One final note: the reason this class is in this package
- * instead of the types package is that, in order to retrieve
- * the compile-time objects, we have to use the "getSavedObject()"
- * method on the Activation.  But the Activation class is part
- * of the SQL layer (org.apache.derby.iapi.sql.Activation) and
- * we want to keep the types layer independent of the SQL layer
- * because the types can be used during recovery before the SQL
- * system has booted.  So the next logical choices were the compile
- * package (impl.sql.compile) or the execution package; of those,
- * the execution package seems more appropriate since this
- * class is only instantiated and used during execution, not
- * during compilation.
- */
-
-public class SqlXmlExecutor {
-
-    // The activation from which we load the compile-time XML
-    // objects (including the compiled XML query expression in
-    // case of XMLEXISTS and XMLQUERY).
-    private Activation activation;
-    private int sqlXUtilId;
-
-    // Target type, target width and target collation type that 
-    // were specified for an XMLSERIALIZE operator.
-    private int targetTypeId;
-    private int targetMaxWidth;
-    private int targetCollationType;
-
-    // Whether or not to preserve whitespace for XMLPARSE
-    // operator.
-    private boolean preserveWS;
-
-    /**
-     * Constructor 1: Used for XMLPARSE op.
-     * @param activation Activation from which to retrieve saved objects
-     * @param utilId Id by which we find saved objects in activation
-     * @param preserveWS Whether or not to preserve whitespace
-     */
-    public SqlXmlExecutor(Activation activation, int utilId,
-        boolean preserveWS)
-    {
-        this.activation = activation;
-        this.sqlXUtilId = utilId;
-        this.preserveWS = preserveWS;
-    }
-
-    /**
-     * Constructor 2: Used for XMLSERIALIZE op.
-     * @param targetTypeId The string type to which we want to serialize.
-     * @param targetMaxWidth The max width of the target type.
-     * @param targetCollationType The collation type of the target type.
-     */
-    public SqlXmlExecutor(int targetTypeId, int targetMaxWidth, 
-    		int targetCollationType)
-    {
-        this.targetTypeId = targetTypeId;
-        this.targetMaxWidth = targetMaxWidth;
-        this.targetCollationType = targetCollationType;
-    }
-
-    /**
-     * Constructor 3: Used for XMLEXISTS/XMLQUERY ops.
-     * @param activation Activation from which to retrieve saved objects
-     * @param utilId Id by which we find saved objects in activation
-     */
-    public SqlXmlExecutor(Activation activation, int utilId)
-    {
-        this.activation = activation;
-        this.sqlXUtilId = utilId;
-    }
-
-    /**
-     * Make the call to perform an XMLPARSE operation on the
-     * received XML string and store the result in the received
-     * XMLDataValue (or if it's null, create a new one).
-     *
-     * @param xmlText String to parse
-     * @param result XMLDataValue in which to store the result
-     * @return The received XMLDataValue with its content set to
-     *  correspond to the received xmlText, if the text constitutes
-     *  a valid XML document.  If the received XMLDataValue is
-     *  null, then create a new one and set its content to
-     *  correspond to the received xmlText.
-     */
-    public XMLDataValue XMLParse(StringDataValue xmlText, XMLDataValue result)
-        throws StandardException
-    {
-        if (result == null)
-            result = new XML();
-
-        if (xmlText.isNull())
-        {
-            result.setToNull();
-            return result;
-        }
-
-        return result.XMLParse(
-            xmlText.getString(), preserveWS, getSqlXmlUtil());
-    }
-
-    /**
-     * Make the call to perform an XMLSERIALIZE operation on the
-     * received XML data value and store the result in the received
-     * StringDataValue (or if it's null, create a new one).
-     *
-     * @param xmlVal XML value to serialize
-     * @param result StringDataValue in which to store the result
-     * @return A serialized (to string) version of this XML object,
-     *  in the form of a StringDataValue object.  
-     */
-    public StringDataValue XMLSerialize(XMLDataValue xmlVal,
-        StringDataValue result) throws StandardException
-    {
-        return xmlVal.XMLSerialize(result, targetTypeId, targetMaxWidth, 
-        		targetCollationType);
-    }
-
-    /**
-     * Make the call to perform an XMLEXISTS operation on the
-     * received XML data value.
-     *
-     * @param xExpr Query expression to be evaluated
-     * @param xmlContext Context node against which to evaluate
-     *  the expression.
-     * @return True if evaluation of the query expression
-     *  against xmlContext returns at least one item; unknown if
-     *  either the xml value is NULL; false otherwise. 
-     */
-    public BooleanDataValue XMLExists(StringDataValue xExpr,
-        XMLDataValue xmlContext) throws StandardException
-    {
-        return xmlContext.XMLExists(getSqlXmlUtil());
-    }
-
-    /**
-     * Make the call to perform an XMLQUERY operation on the
-     * received XML data value and store the result in the
-     * received result holder (or, if it's null, create a
-     * new one).
-     *
-     * @param xExpr Query expression to be evaluated
-     * @param xmlContext Context node against which to evaluate
-     *  the expression.
-     * @param result XMLDataValue in which to store the result
-     * @return The received XMLDataValue with its content set to
-     *  result of evaulating the query expression against xmlContext.
-     *  If the received XMLDataValue is null, then create a new one
-     *  and set its content to correspond to the received xmlText.
-     */
-    public XMLDataValue XMLQuery(StringDataValue xExpr,
-        XMLDataValue xmlContext, XMLDataValue result)
-        throws StandardException
-    {
-        return xmlContext.XMLQuery(result, getSqlXmlUtil());
-    }
-
-    /**
-     * Return the saved object in this.activation that corresponds to
-     * this.sqlxUtilId.  Assumption is that those fields have been
-     * set by the time we get here.
-     */
-    private SqlXmlUtil getSqlXmlUtil()
-        throws StandardException
-    {
-        return (SqlXmlUtil)
-            activation.getPreparedStatement().getSavedObject(sqlXUtilId);
-    }
-
-}
diff --git a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/suites/XMLSuite.java b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/suites/XMLSuite.java
index 737bae12..a695069a 100644
--- a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/suites/XMLSuite.java
+++ b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/suites/XMLSuite.java
@@ -51,6 +51,7 @@ public static Test suite()
         suite.addTest(org.apache.derbyTesting.functionTests.tests.lang.XMLTypeAndOpsTest.suite());
         suite.addTest(org.apache.derbyTesting.functionTests.tests.lang.XMLBindingTest.suite());
         suite.addTest(org.apache.derbyTesting.functionTests.tests.lang.XMLMissingClassesTest.suite());
+        suite.addTest(org.apache.derbyTesting.functionTests.tests.lang.XMLConcurrencyTest.suite());
         
         return suite;
     }
diff --git a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/XMLConcurrencyTest.java b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/XMLConcurrencyTest.java
index e69de29b..f579de7e 100644
--- a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/XMLConcurrencyTest.java
+++ b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/XMLConcurrencyTest.java
@@ -0,0 +1,197 @@
+/*
+ *
+ * Derby - Class org.apache.derbyTesting.functionTests.tests.lang.XMLConcurrencyTest
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
+ * either express or implied. See the License for the specific
+ * language governing permissions and limitations under the License.
+ */
+package org.apache.derbyTesting.functionTests.tests.lang;
+
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
+import java.sql.Statement;
+import junit.framework.Test;
+import junit.framework.TestSuite;
+import org.apache.derbyTesting.junit.BaseJDBCTestCase;
+import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
+import org.apache.derbyTesting.junit.JDBC;
+import org.apache.derbyTesting.junit.TestConfiguration;
+import org.apache.derbyTesting.junit.XML;
+
+/**
+ * Test that XML operators can be invoked by multiple threads concurrently.
+ * Regression test case for DERBY-3870.
+ */
+public class XMLConcurrencyTest extends BaseJDBCTestCase {
+
+    /** Create an instance of this test case. */
+    public XMLConcurrencyTest(String name) {
+        super(name);
+    }
+
+    /** Create a suite of all test cases in this class. */
+    public static Test suite() {
+        // XML operators are engine functionality, so run this test in
+        // embedded mode only.
+        if (XML.classpathMeetsXMLReqs()) {
+            return new CleanDatabaseTestSetup(
+                TestConfiguration.embeddedSuite(XMLConcurrencyTest.class)) {
+                    protected void decorateSQL(Statement s)
+                            throws SQLException {
+                        createTestTable(s);
+                    }
+                };
+        } else {
+            return new TestSuite("XMLConcurrencyTest - empty");
+        }
+    }
+
+    /**
+     * Start four threads that execute queries that use all the XML operators.
+     * If each thread manages 100 iterations without failing, running
+     * concurrently with the other threads, the test case passes.
+     */
+    public void testConcurrency() throws Exception {
+        WorkerThread[] allThreads = new WorkerThread[4];
+        for (int i = 0; i < allThreads.length; i++) {
+            allThreads[i] = new WorkerThread(openDefaultConnection(), 100);
+            allThreads[i].start();
+        }
+
+        for (int i = 0; i < allThreads.length; i++) {
+            allThreads[i].join();
+            Throwable t = allThreads[i].throwable;
+            if (t != null) {
+                fail("Worker thread failed", t);
+            }
+        }
+    }
+
+    /**
+     * A thread class that does the actual work in the test.
+     */
+    private class WorkerThread extends Thread {
+        final Connection conn;
+        final int iterations;
+        Throwable throwable;
+
+        WorkerThread(Connection conn, int iterations) {
+            this.conn = conn;
+            this.iterations = iterations;
+        }
+
+        public void run() {
+            try {
+                runXMLTest(conn, iterations);
+            } catch (Throwable t) {
+                throwable = t;
+            }
+        }
+    }
+
+    /**
+     * <p>
+     * Create a table with test data. The table contains three columns:
+     * <p>
+     *
+     * <ol>
+     * <li>
+     * An ID column used to identify the rows and to give a stable ordering.
+     * </li>
+     * <li>
+     * A VARCHAR column holding the string representation of an XML document.
+     * </li>
+     * <li>
+     * An XML column holding the XML representation of the document in the
+     * VARCHAR column.
+     * </li>
+     * </ol>
+     */
+    private static void createTestTable(Statement s) throws SQLException {
+        s.executeUpdate("create table t (id int primary key " +
+                "generated always as identity, vc varchar(100), " +
+                "x generated always as " +
+                "(xmlparse(document vc preserve whitespace)))");
+
+        PreparedStatement ins = s.getConnection().prepareStatement(
+                "insert into t(vc) values ?");
+
+        String[] docs = {
+            "<doc><a x='1'>abc</a><b x='2'>def</b></doc>",
+            "<doc><a x='2'>abc</a><b x='3'>def</b></doc>",
+            "<doc/>",
+            "<a/>",
+            null,
+        };
+
+        for (int i = 0; i < docs.length; i++) {
+            ins.setString(1, docs[i]);
+            ins.executeUpdate();
+        }
+
+        ins.close();
+    }
+
+    /**
+     * Do the work for one of the worker threads. Perform queries that use
+     * all the XML operators. Repeat the queries the specified number of times.
+     *
+     * @param conn the connection on which to execute the queries
+     * @param iterations the number of times each query should be executed
+     */
+    private static void runXMLTest(Connection conn, int iterations)
+            throws SQLException {
+        // Query that tests XMLQUERY and XMLSERIALIZE. Count the number of
+        // nodes with an attribute named x with a value greater than 1.
+        PreparedStatement ps1 = conn.prepareStatement(
+            "select id, xmlserialize(" +
+            "xmlquery('count(//*[@x>1])' passing by ref x empty on empty) " +
+            "as varchar(100)) from t order by id");
+
+        String[][] expected1 = {
+            {"1", "1"}, {"2", "2"}, {"3", "0"}, {"4", "0"}, {"5", null}
+        };
+
+        // Query that tests XMLEXISTS. Find all documents containing a "doc"
+        // node with a nested "a" node whose x attribute is 2.
+        PreparedStatement ps2 = conn.prepareStatement(
+            "select id from t where " +
+            "xmlexists('/doc/a[@x=2]' passing by ref x) " +
+            "order by id");
+
+        String expected2 = "2";
+
+        // Query that tests XMLPARSE and XMLSERIALIZE.
+        PreparedStatement ps3 = conn.prepareStatement(
+            "select count(*) from t where " +
+            "xmlserialize(xmlparse(document vc preserve whitespace) " +
+            "as varchar(100)) = " +
+            "xmlserialize(x as varchar(100))");
+
+        String expected3 = "4";
+
+        for (int i = 0; i < iterations; i++) {
+            JDBC.assertFullResultSet(ps1.executeQuery(), expected1);
+            JDBC.assertSingleValueResultSet(ps2.executeQuery(), expected2);
+            JDBC.assertSingleValueResultSet(ps3.executeQuery(), expected3);
+        }
+
+        ps1.close();
+        ps2.close();
+        ps3.close();
+        conn.close();
+    }
+}
diff --git a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/BasicSetup.java b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/BasicSetup.java
index 003bc57d..c5062b1d 100644
--- a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/BasicSetup.java
+++ b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/BasicSetup.java
@@ -29,6 +29,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 import org.apache.derbyTesting.junit.JDBC;
 import org.apache.derbyTesting.junit.TestConfiguration;
+import org.apache.derbyTesting.junit.XML;
 
 import junit.framework.Test;
 import junit.framework.TestSuite;
@@ -44,6 +45,12 @@ public static Test suite() {
         
         suite.addTestSuite(BasicSetup.class);
         
+        if (XML.classpathMeetsXMLReqs()) {
+            // Only test XML operators if they are supported by the version
+            // we upgrade to.
+            suite.addTest(new BasicSetup("xmlTestTriggerWithXMLOperators"));
+        }
+
         return suite;
     }
 
@@ -718,4 +725,62 @@ private String  stringify( int[] array )
         return buffer.toString();
     }
     //End of helper methods for testExhuastivePermutationOfTriggerColumns
+
+    /**
+     * Test that triggers that use XML operators work after upgrade. The
+     * first fix for DERBY-3870 broke upgrade of such triggers because the
+     * old execution plans failed to deserialize on the new version.
+     */
+    public void xmlTestTriggerWithXMLOperators() throws SQLException {
+        if (!oldAtLeast(10, 3)) {
+            // Before 10.3, the CREATE TRIGGER statement used in the test
+            // failed with a syntax error. Skip the test for older versions.
+            return;
+        }
+
+        Statement s = createStatement();
+
+        if (getPhase() == PH_CREATE) {
+            // Create test tables and a trigger that uses XML operators with
+            // the old version.
+            s.execute("create table d3870_t1(i int, x varchar(100))");
+            s.execute("create table d3870_t2(i int)");
+            try {
+                s.execute("create trigger d3870_tr after insert on d3870_t1 " +
+                          "for each statement insert into d3870_t2 " +
+                          "select i from d3870_t1 where " +
+                          "xmlexists('//a' passing by ref " +
+                          "xmlparse(document x preserve whitespace))");
+            } catch (SQLException sqle) {
+                // The CREATE TRIGGER statement will fail if the XML classpath
+                // requirements aren't satisfied for the old version. That's
+                // OK, but we'll have to skip the test for this combination.
+                assertSQLState("XML00", sqle);
+                return;
+            }
+        } else {
+            // Delete the rows to start the test from a known state in each
+            // of the phases.
+            s.executeUpdate("delete from d3870_t1");
+            s.executeUpdate("delete from d3870_t2");
+        }
+
+        // Check if the trigger exists. It won't exist if the XML requirements
+        // weren't satisfied for the old version. If we don't have the trigger,
+        // we skip the rest of the test.
+        ResultSet rs = s.executeQuery(
+            "select 1 from sys.systriggers where triggername = 'D3870_TR'");
+        boolean hasTrigger = rs.next();
+        rs.close();
+
+        // Verify that the trigger works both before and after upgrade.
+        if (hasTrigger) {
+            s.execute("insert into d3870_t1 values " +
+                      "(1, '<a/>'), (2, '<b/>'), (3, '<c/>')");
+
+            JDBC.assertSingleValueResultSet(
+                    s.executeQuery("select * from d3870_t2"), "1");
+        }
+    }
+
 }
