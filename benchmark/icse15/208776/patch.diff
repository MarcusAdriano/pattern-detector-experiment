diff --git a/incubator/derby/code/branches/10.1/java/client/org/apache/derby/client/am/ResultSet.java b/incubator/derby/code/branches/10.1/java/client/org/apache/derby/client/am/ResultSet.java
index 35fb325c..47bbfd1b 100644
--- a/incubator/derby/code/branches/10.1/java/client/org/apache/derby/client/am/ResultSet.java
+++ b/incubator/derby/code/branches/10.1/java/client/org/apache/derby/client/am/ResultSet.java
@@ -1804,18 +1804,51 @@ private boolean relativeX(int rows) throws SqlException {
         // discard all previous updates when moving the cursor.
         resetUpdatedColumns();
 
-        // this method may only be called when the cursor on a valid row,
-        // not after the last row, before the first row, or on the insert row.
-        // throw exception if result set contains no rows, because there is no current row.
-        if (isBeforeFirstX() || isAfterLastX() || isOnInsertRow_ || resultSetContainsNoRows()) {
+        // this method may not be called when the cursor on the insert row
+        if (isOnInsertRow_) {
             throw new SqlException(agent_.logWriter_, "Cursor is Not on a Valid Row");
         }
 
+        // If the resultset is empty, relative(n) is a null operation
+        if (resultSetContainsNoRows()) {
+            isValidCursorPosition_ = false;
+            return isValidCursorPosition_;
+        }
+        
+        // relative(0) is a null-operation, but the retruned result is
+        // dependent on wether the cursorposition is on a row or not.
         if (rows == 0) {
+            if (isBeforeFirstX() || isAfterLastX()) {
+                isValidCursorPosition_ = false;
+            } else {
             isValidCursorPosition_ = true;
+            }
             return isValidCursorPosition_;
         }
 
+        // Handle special cases when the cursor is before first or
+        // after last, since the following code assumes we ar on a
+        // valid cursor
+        if (isBeforeFirstX()) {
+            if (rows > 0) {
+                nextX();
+                return relativeX(rows-1);
+            } else {
+                isValidCursorPosition_ = false;
+                return isValidCursorPosition_;
+            }
+        }
+        if (isAfterLastX()) {
+            if (rows < 0) {
+                previousX();
+                return relativeX(rows+1);
+            } else {
+                isValidCursorPosition_ = false;
+                return isValidCursorPosition_;
+            }
+        }
+        // Ok, now we are on a row and ready to do some real positioning.....
+
         resetRowsetFlags();
 
         // currentAbsoluteRowNumber is used for static cursors only.
diff --git a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/diag/ErrorMessages.java b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/diag/ErrorMessages.java
index 4643be0d..48b5b25e 100644
--- a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/diag/ErrorMessages.java
+++ b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/diag/ErrorMessages.java
@@ -47,12 +47,12 @@
 
 
 /** 
- * ErrorMessage is a VTI that shows all the SQLStates, locale-sensitive error
+ * ErrorMessage shows all the SQLStates, locale-sensitive error
  * messages, and exception severities for a database.
  * 
- * <p>To use it, query it as an external virtual table:</p>
- * <PRE> SELECT* FROM NEW ErrorMessages() AS EQ; </PRE>
- * <P>The ErrorMessages VTI has the following columns:
+ * <p>To use it, query it as follows:</p>
+ * <PRE> SELECT* FROM NEW org.apache.derby.diag.ErrorMessages() AS EQ; </PRE>
+ * <P>The following columns will be returned:
  * <UL><LI>SQL_STATE--VARCHAR(5) - nullable.  The SQLState of the SQLException.<br>
  * (The code returned by getSQLState() in SQLException.)</LI>
  * <LI>MESSAGE--VARCHAR(32672) - nullable.  The error message<br>
diff --git a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/jdbc/BrokeredConnection.java b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/jdbc/BrokeredConnection.java
index 0f05220d..9e24b95f 100644
--- a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/jdbc/BrokeredConnection.java
+++ b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/jdbc/BrokeredConnection.java
@@ -33,6 +33,12 @@
 import java.io.ObjectOutput;
 import java.io.ObjectInput;
 
+import java.lang.reflect.*;
+
+import org.apache.derby.iapi.reference.JDBC30Translation;
+import org.apache.derby.iapi.error.PublicAPI;
+import org.apache.derby.iapi.error.StandardException;
+
 /**
  * This is a rudimentary connection that delegates
  * EVERYTHING to Connection.
@@ -40,6 +46,9 @@
 public class BrokeredConnection implements Connection
 {
 
+	// default for Derby
+	protected int stateHoldability = JDBC30Translation.HOLD_CURSORS_OVER_COMMIT;
+
 	protected final BrokeredConnectionControl control;
 	private boolean isClosed;
 
@@ -383,6 +392,15 @@ public void syncState() throws SQLException {
 		stateIsolationLevel = conn.getTransactionIsolation();
 		stateReadOnly = conn.isReadOnly();
 		stateAutoCommit = conn.getAutoCommit();
+		// jdk13 does not have Connection.getHoldability method and hence using
+		// reflection to cover both jdk13 and higher jdks
+		try {
+			Method sh = conn.getClass().getMethod("getHoldability", null);
+			stateHoldability = ((Integer)sh.invoke(conn, null)).intValue();
+		} catch( Exception e)
+		{
+			throw PublicAPI.wrapStandardException( StandardException.plainWrapException( e));
+		}       
 	}
 
 	/**
@@ -396,6 +414,8 @@ public void syncState() throws SQLException {
 		
 	*/
 	public void setState(boolean complete) throws SQLException {
+		Class[] CONN_PARAM = { Integer.TYPE };
+		Object[] CONN_ARG = { new Integer(stateHoldability)};
 
 		Connection conn = getRealConnection();
 
@@ -403,6 +423,18 @@ public void setState(boolean complete) throws SQLException {
 			conn.setTransactionIsolation(stateIsolationLevel);
 			conn.setReadOnly(stateReadOnly);
 			conn.setAutoCommit(stateAutoCommit);
+			// make the underlying connection pick my holdability state
+			// since holdability is a state of the connection handle
+			// not the underlying transaction.
+			// jdk13 does not have Connection.setHoldability method and hence using
+			// reflection to cover both jdk13 and higher jdks
+			try {
+				Method sh = conn.getClass().getMethod("setHoldability", CONN_PARAM);
+				sh.invoke(conn, CONN_ARG);
+			} catch( Exception e)
+			{
+				throw PublicAPI.wrapStandardException( StandardException.plainWrapException( e));
+			}
 		}
 	}
 
diff --git a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/jdbc/BrokeredConnection30.java b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/jdbc/BrokeredConnection30.java
index ae044b62..3c2e1f1b 100644
--- a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/jdbc/BrokeredConnection30.java
+++ b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/iapi/jdbc/BrokeredConnection30.java
@@ -33,9 +33,6 @@
 public class BrokeredConnection30 extends BrokeredConnection
 {
 	
-	// default for Cloudscape
-	private int stateHoldability = java.sql.ResultSet.HOLD_CURSORS_OVER_COMMIT;
-
 	public	BrokeredConnection30(BrokeredConnectionControl control)
 	{
 		super(control);
@@ -216,19 +213,6 @@ public final PreparedStatement prepareStatement(
 			throw se;
 		}
 	}
-	public void syncState() throws SQLException {
-		super.syncState();
-		// make the underlying connection pick my holdability state
-		// since holdability is a state of the connection handle
-		// not the underlying transaction.
-		getRealConnection().setHoldability(stateHoldability);
-	}
-
-	public void setState(boolean complete) throws SQLException {
-		super.setState(complete);
-		if (complete) 
-			getRealConnection().setHoldability(stateHoldability);
-	}
 
 	public BrokeredPreparedStatement newBrokeredStatement(BrokeredStatementControl statementControl, String sql, Object generatedKeys) throws SQLException {
 		return new BrokeredPreparedStatement30(statementControl, getJDBCLevel(), sql, generatedKeys);
diff --git a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/load/ColumnInfo.java b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/load/ColumnInfo.java
index ff664aac..9eddb8a2 100644
--- a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/load/ColumnInfo.java
+++ b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/load/ColumnInfo.java
@@ -80,13 +80,14 @@ public ColumnInfo(Connection conn,
 		columnTypes = new ArrayList(1);
 		noOfColumns = 0;
 		this.conn = conn;
-		this.schemaName = (sName !=null ? sName.toUpperCase(java.util.Locale.ENGLISH):sName);
-		this.tableName =  (tName !=null ? tName.toUpperCase(java.util.Locale.ENGLISH):tName);
+
+		this.schemaName = sName;
+		this.tableName =  tName;
 
 		if(insertColumnList!=null)
 		{
 			//break the comma seperated column list and initialze column info
-			//eg: c2 , c1 , c3
+			//eg: C2 , C1 , C3
 			StringTokenizer st = new StringTokenizer(insertColumnList , ",");
 			while (st.hasMoreTokens()) 
 			{
@@ -152,7 +153,7 @@ private boolean initializeColumnInfo(String columnPattern)
 		ResultSet rs = dmd.getColumns(null, 
 									  schemaName,
 									  tableName,
-									  (columnPattern !=null ? columnPattern.toUpperCase(java.util.Locale.ENGLISH):columnPattern));
+									  columnPattern);
 		boolean foundTheColumn=false;
 		while (rs.next())
 		{
@@ -306,8 +307,9 @@ public String getColumnNamesWithCasts()
 			return sb.toString();
 	}
 
-	/* returns comma seperated column Names for insert statement
-	 * eg: c1, c2 , c3 , c4 
+	/* returns comma seperated column Names delimited by quotes for the insert 
+     * statement
+	 * eg: "C1", "C2" , "C3" , "C4" 
 	 */
 	public String getInsertColumnNames()
 	{
@@ -319,7 +321,11 @@ public String getInsertColumnNames()
 				sb.append(", ");
 			else
 				first = false;
+			// column names can be SQL reserved words, so it 
+			// is necessary delimit them using quotes for insert to work correctly. 
+			sb.append("\"");
 			sb.append(insertColumnNames.get(index));
+			sb.append("\"");
 		}
 	
 		//there is no column info available
@@ -359,6 +365,3 @@ private boolean tableExists() throws SQLException
 
 
 
-
-
-
diff --git a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/load/ExportResultSetForObject.java b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/load/ExportResultSetForObject.java
index 924dc7a9..eaa63926 100644
--- a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/load/ExportResultSetForObject.java
+++ b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/load/ExportResultSetForObject.java
@@ -24,6 +24,8 @@
 import java.sql.Statement;
 import java.sql.ResultSet;
 import java.sql.ResultSetMetaData;
+import java.sql.DatabaseMetaData;
+import java.sql.SQLException;
 
 //uses the passed connection and table/view name to make the resultset on
 //that entity. If the entity to be exported has non-sql types in it, an
@@ -31,8 +33,7 @@
 class ExportResultSetForObject {
 
   private Connection con;
-  private String entityName;
-  private String selectStatement;
+    private String selectQuery;
   private ResultSet rs;
   private int columnCount;
   private String columnNames[];
@@ -40,39 +41,48 @@
   private int columnLengths[];
 
 	private Statement expStmt = null; 
+    private String schemaName;
+    private String tableName;
 
-	//uses the passed connection and table/view name to make the resultset on
-	//that entity.
+	/* set up the connection and table/view name or the select query
+	 * to make the result set, whose data is exported. 
+	 **/
 	public ExportResultSetForObject(Connection con, String schemaName, 
-									String tableName, String selectStatement 
+									String tableName, String selectQuery 
 									) 
 	{
 		this.con = con;
-		if( selectStatement == null)
-			this.entityName = (schemaName == null ? tableName : schemaName + "." + tableName); 
-		this.selectStatement = selectStatement;
+		if( selectQuery == null)
+		{
+			this.schemaName = schemaName;
+			this.tableName = tableName;
+			
+			// delimit schema Name and table Name using quotes because
+			// they can be case-sensitive names or SQL reserved words. Export
+			// procedures are expected to be called with case-senisitive names. 
+			// undelimited names are passed in upper case, because that is
+			// the form database stores them. 
+			
+			this.selectQuery = "select * from " + 
+				(schemaName == null ? "\"" + tableName + "\"" : 
+				 "\"" + schemaName + "\"" + "." + "\"" + tableName + "\""); 
+		}
+        else
+		{
+			this.selectQuery = selectQuery;
+		}
 	}
 
 
-  public ResultSet getResultSet() throws Exception {
+    public ResultSet getResultSet() throws SQLException {
     rs = null;
-    String queryString = getQuery();
-    //execute select on passed enitity and keep it's meta data info ready
-    Statement expStmt = con.createStatement();
-    rs = expStmt.executeQuery(queryString);
+        //execute the select query and keep it's meta data info ready
+        expStmt = con.createStatement();
+        rs = expStmt.executeQuery(selectQuery);
     getMetaDataInfo();
     return rs;
   }
 
-  public String getQuery(){
-	  if(selectStatement != null)
-		  return selectStatement;
-	  else
-	  {
-		  selectStatement = "select * from " + entityName;
-		  return selectStatement;
-	  }
-  }
 
   public int getColumnCount() {
     return columnCount;
@@ -91,21 +101,22 @@ public int getColumnCount() {
   }
 
   //if the entity to be exported has non-sql types in it, an exception will be thrown
-  private void getMetaDataInfo() throws Exception {
+    private void getMetaDataInfo() throws SQLException {
     ResultSetMetaData metaData = rs.getMetaData();
     columnCount = metaData.getColumnCount();
 	  int numColumns = columnCount;
     columnNames = new String[numColumns];
 	columnTypes = new String[numColumns];
     columnLengths = new int[numColumns];
+
     for (int i=0; i<numColumns; i++) {
 	  int jdbcTypeId = metaData.getColumnType(i+1);
 	  columnNames[i] = metaData.getColumnName(i+1);
 	  columnTypes[i] = metaData.getColumnTypeName(i+1);
 	  if(!ColumnInfo.importExportSupportedType(jdbcTypeId))
 	  {
-		  throw LoadError.nonSupportedTypeColumn(columnNames[i],
-												 columnTypes[i]); 
+                throw LoadError.nonSupportedTypeColumn(
+                            columnNames[i], columnTypes[i]); 
       }
       	 
       columnLengths[i] = metaData.getColumnDisplaySize(i+1);
@@ -118,8 +129,3 @@ public void  close() throws Exception
 			expStmt.close();
 	}
 }
-
-
-
-
-
diff --git a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/load/Import.java b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/load/Import.java
index 9217b1c2..9be60cdb 100644
--- a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/load/Import.java
+++ b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/load/Import.java
@@ -160,9 +160,9 @@ private static void performImport(Connection connection, String schemaName,
 		if (connection == null)
 			throw LoadError.connectionNull();
 		
-		String entityName = (schemaName == null ? tableName : schemaName + "." + tableName); 
 		
-		if (entityName == null)
+		
+		if (tableName == null)
 			throw LoadError.entityNameMissing();
 		
 
@@ -197,6 +197,18 @@ private static void performImport(Connection connection, String schemaName,
 
 		String importvti = sb.toString();
 
+		// delimit the table and schema names with quotes.
+		// because they might have been  created as quoted
+		// identifiers(for example when reserved words are used, names are quoted)
+		
+		// Import procedures are to be called with case-senisitive names. 
+		// Incase of delimited table names, they need to be passed as defined
+		// and when they are not delimited, they need to be passed in upper
+		// case, because all undelimited names are stored in the upper case 
+		// in the database. 
+
+		String entityName = (schemaName == null ? "\""+ tableName + "\"" : 
+							 "\"" + schemaName + "\"" + "." + "\"" + tableName + "\""); 
 
 		String insertModeValue;
 		if(replace > 0)
diff --git a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/compile/CreateAliasNode.java b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/compile/CreateAliasNode.java
index 801d16c6..6f22bf79 100644
--- a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/compile/CreateAliasNode.java
+++ b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/compile/CreateAliasNode.java
@@ -251,6 +251,11 @@ public QueryTreeNode bind() throws StandardException
 		if (aliasType != AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR)
 			return this;
 
+		// Don't allow creating synonyms in SESSION schema. Causes confusion if
+		// a temporary table is created later with same name.
+		if (isSessionSchema(getSchemaDescriptor().getSchemaName()))
+			throw StandardException.newException(SQLState.LANG_OPERATION_NOT_ALLOWED_ON_SESSION_SCHEMA_TABLES);
+
 		String targetSchema = ((SynonymAliasInfo)aliasInfo).getSynonymSchema();
 		String targetTable = ((SynonymAliasInfo)aliasInfo).getSynonymTable();
 		if (this.getObjectName().equals(targetSchema, targetTable))
diff --git a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java
index 2afd0bf9..b42d3a03 100644
--- a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java
+++ b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/conn/GenericLanguageConnectionContext.java
@@ -766,11 +766,11 @@ public CursorActivation lookupCursorActivation(String cursorName) {
 	}
 
 	/**
-	 * This method will get called if the statement is referencing tables in SESSION schema.
-	 * We do not want to cache such statements because multiple connections can have
-	 * different definition of the same table name and hence compiled plan for one connection
-	 * may not make sense for some other connection. Because of this, remove the statement from the cache
+	*  This method will remove a statement from the  statement cache.
+	*  It will be called,  for example, if there is an exception preparing
+	*  the statement.
 	 *
+	*  @param statement Statement to remove
 	 * @exception StandardException thrown if lookup goes wrong.
 	 */
 	public void removeStatement(Statement statement)
@@ -779,13 +779,10 @@ public void removeStatement(Statement statement)
 		if (statementCache == null)
 			return;
 
-		synchronized (statementCache) {
-
 			Cacheable cachedItem = statementCache.findCached(statement);
 			if (cachedItem != null)
 				statementCache.remove(cachedItem);
 		}
-	}
 
 	/**
 	 * See if a given statement has already been compiled for this user, and
diff --git a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/ScrollInsensitiveResultSet.java b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/ScrollInsensitiveResultSet.java
index a7ae6e1f..a4153435 100644
--- a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/ScrollInsensitiveResultSet.java
+++ b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/sql/execute/ScrollInsensitiveResultSet.java
@@ -232,10 +232,11 @@ public ExecRow	getAbsoluteRow(int row) throws StandardException
 			}
 		}
 
-		// 0 is an invalid parameter
+                // Absolute 0 is defined to be before first!
 		if (row == 0)
 		{
-			throw StandardException.newException(SQLState.LANG_ZERO_INVALID_FOR_R_S_ABSOLUTE);
+                    setBeforeFirstRow();
+                    return null;
 		}
 
 		if (row > 0)
@@ -330,17 +331,16 @@ public ExecRow	getRelativeRow(int row) throws StandardException
 			}
 		}
 
-		/* Throw exception if before first or after last */
-		if (beforeFirst || afterLast)
-		{
-			throw StandardException.newException(SQLState.LANG_NO_CURRENT_ROW_FOR_RELATIVE);
-		}
-
 		// Return the current row for 0
 		if (row == 0)
 		{
+                    if ((beforeFirst || afterLast) ||
+                        (!beforeFirst && !afterLast)) {
+                        return null;
+                    } else {
 			return getRowFromHashTable(currentPosition);
 		}
+		}
 		else if (row > 0)
 		{
 			return getAbsoluteRow(currentPosition + row);
diff --git a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/AllocExtent.java b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/AllocExtent.java
index 3702c357..33bab8ec 100644
--- a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/AllocExtent.java
+++ b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/AllocExtent.java
@@ -587,6 +587,43 @@ protected void compressPages(
         return;
     }
 
+    /**
+     * Undo the compress space operation.
+     * <p>
+     * Undo of this operation doesn't really "undo" the operation, it just
+     * makes sure the data structures are ok after the undo.  We are 
+     * guaranteed at the point of the transaction doing the 
+     * Undo of the compress space operation fixes up the bit maps to
+     * only point at pages within the new_highest_page range.
+     * <p>
+     * Prior to logging the compress space operation all pages greater 
+     * than 
+     * There are only 2 possibilities at this point:
+     * 1) the truncate of pages greater than new_highest_page happened before
+     *    the abort took place.  W
+     * 2) 
+     *
+	 * @return The identifier to be used to open the conglomerate later.
+     *
+     * @param param1 param1 does this.
+     * @param param2 param2 does this.
+     *
+	 * @exception  StandardException  Standard exception policy.
+     **/
+    protected void undoCompressPages(
+    int        new_highest_page,
+    int        num_pages_truncated)
+    {
+        if (new_highest_page >= 0)
+        {
+            freePages.shrink(new_highest_page + 1);
+            unFilledPages.shrink(new_highest_page + 1);
+            preAllocLength = extentLength = (new_highest_page + 1);
+        }
+
+        return;
+    }
+
 	protected long getExtentEnd()
 	{
 		return extentEnd;
diff --git a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/AllocPage.java b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/AllocPage.java
index 08a4bc47..2e0eb8bc 100644
--- a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/AllocPage.java
+++ b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/AllocPage.java
@@ -916,6 +916,21 @@ protected void compressSpace(
         extent.compressPages(new_highest_page, num_pages_truncated);
 	}
 
+    /**
+     * Handle undo of compress space operation.
+     **/
+	protected void undoCompressSpace(
+    LogInstant  instant,
+    int         new_highest_page,
+    int         num_pages_truncated)
+		throws StandardException
+    {
+		logAction(instant);
+
+        extent.undoCompressPages(new_highest_page, num_pages_truncated);
+
+    }
+
 	public String toString()
 	{
 		if (SanityManager.DEBUG)
diff --git a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/BaseContainer.java b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/BaseContainer.java
index 6e58346a..8bb964ff 100644
--- a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/BaseContainer.java
+++ b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/BaseContainer.java
@@ -221,7 +221,7 @@ public void compressContainer(BaseContainerHandle handle)
 		}
 		finally
 		{
-            ntt.commitNoSync(Transaction.RELEASE_LOCKS);
+            ntt.commit();
 
 			ntt.close();
 		}
diff --git a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/CompressSpacePageOperation.java b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/CompressSpacePageOperation.java
index 4285bd63..0fb04801 100644
--- a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/CompressSpacePageOperation.java
+++ b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/CompressSpacePageOperation.java
@@ -182,7 +182,7 @@ public void undoMe(
 				"undo Page is not an allocPage");
 		}
 
-		((AllocPage)undoPage).compressSpace(
+		((AllocPage)undoPage).undoCompressSpace(
              CLRInstant, newHighestPage, num_pages_truncated);
 	}
 
diff --git a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java
index 8cc06c48..3121e703 100644
--- a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java
+++ b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/FileContainer.java
@@ -1351,6 +1351,12 @@ protected void compressContainer(
 			return;
         }
 
+        // make sure we don't execute redo recovery on any page
+        // which is getting truncated.  At this point we have an exclusive
+        // table lock on the table, so after checkpoint no page change
+        // can happen between checkpoint log record and compress of space.
+        dataFactory.getRawStoreFactory().checkpoint();
+
 		try
 		{
             synchronized(allocCache)
@@ -1389,6 +1395,7 @@ protected void compressContainer(
                 lastUnfilledPage    = ContainerHandle.INVALID_PAGE_NUMBER;
                 lastAllocatedPage   = ContainerHandle.INVALID_PAGE_NUMBER;
 
+
                 alloc_page.compress(ntt, this);
             }
 
diff --git a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/PhysicalUndoOperation.java b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/PhysicalUndoOperation.java
index c8c699a5..f6d3e8aa 100644
--- a/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/PhysicalUndoOperation.java
+++ b/incubator/derby/code/branches/10.1/java/engine/org/apache/derby/impl/store/raw/data/PhysicalUndoOperation.java
@@ -146,7 +146,19 @@ public final void doMe(Transaction xact, LogInstant instant, LimitObjectInput in
 		undoOp.undoMe(xact, this.page, instant, in);
 
 		if (SanityManager.DEBUG) {
-			SanityManager.ASSERT(oldversion < this.page.getPageVersion());
+
+            if (oldversion >= this.page.getPageVersion())
+            {
+                SanityManager.THROWASSERT(
+                    "oldversion = " + oldversion +
+                    ";page version = "  + this.page.getPageVersion() +
+                    "page = " + page + 
+                    "; my class name is " + getClass().getName() +
+                    " undoOp is " + undoOp.getClass().getName() );
+            }
+			SanityManager.ASSERT(
+                oldversion < this.page.getPageVersion());
+
 			if (instant != null &&
 				! instant.equals(this.page.getLastLogInstant()))
 				SanityManager.THROWASSERT(
diff --git a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/checkDataSource30.java b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/checkDataSource30.java
index d3aee026..5895ca68 100644
--- a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/checkDataSource30.java
+++ b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/checkDataSource30.java
@@ -177,8 +177,6 @@ private void checkXAHoldability() {
 			xid = getXid(27, (byte) 21, (byte) 01);
 			xr.start(xid, XAResource.TMNOFLAGS);
 			conn1 = xac.getConnection();
-			System.out.println("This is a bug. Connection's holdability should have been CLOSE_CURSORS_AT_COMMIT since it is in the global transaction");
-			System.out.println("Have reported this on Derby dev-list");
 			System.out.println("CONNECTION(in xa transaction) HOLDABILITY " + (conn1.getHoldability() == ResultSet.HOLD_CURSORS_OVER_COMMIT));
 			System.out.println("Autocommit on Connection inside global transaction has been set correctly to " + conn1.getAutoCommit());
 			xr.end(xid, XAResource.TMSUCCESS);
diff --git a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/lang/scrollCursors2.java b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/lang/scrollCursors2.java
index c2cd03ea..87abc1b0 100644
--- a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/lang/scrollCursors2.java
+++ b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/lang/scrollCursors2.java
@@ -613,6 +613,16 @@ static boolean scrollInsensitivePositive( Connection conn)
 			System.out.println("expected to be before the 1st row");
 			passed = false;
 		}
+                if (rs.absolute(0))
+                {
+			System.out.println("absolute(0) expected to return false");
+			passed = false;
+                }
+		if (! rs.isBeforeFirst())
+		{
+			System.out.println("still expected to be before the 1st row");
+			passed = false;
+		}
 		// go to first row
 		if (! rs.first())
 		{
@@ -899,7 +909,6 @@ static boolean scrollInsensitivePositive( Connection conn)
 		}
 		rs.close();
 		
-
 		return passed;
 	}
 
@@ -968,6 +977,11 @@ static boolean scrollInsensitiveNegative( Connection conn)
 			System.out.println("rs.next() expected to show result set is empty");
 			passed = false;
 		}
+		if (rs.previous())
+		{
+			System.out.println("rs.previous() expected to show result set is empty");
+			passed = false;
+		}
 		if (rs.isAfterLast())
 		{
 			System.out.println("isAfterLast() expected to return false on empty result set");
@@ -984,6 +998,42 @@ static boolean scrollInsensitiveNegative( Connection conn)
 			passed = false;
 		}
 
+		if (rs.relative(0))
+		{
+			System.out.println("relative(0) expected to return false on empty result set");
+			passed = false;
+		}
+
+		if (rs.relative(1))
+		{
+			System.out.println("relative(1) expected to return false on empty result set");
+			passed = false;
+		}
+
+		if (rs.relative(-1))
+		{
+			System.out.println("relative(-1) expected to return false on empty result set");
+			passed = false;
+		}
+
+		if (rs.absolute(0))
+		{
+			System.out.println("absolute(0) expected to return false on empty result set");
+			passed = false;
+		}
+		if (rs.absolute(1))
+		{
+			System.out.println("absolute(1) expected to return false on empty result set");
+			passed = false;
+		}
+
+		if (rs.absolute(-1))
+		{
+			System.out.println("absolute(-1) expected to return false on empty result set");
+			passed = false;
+		}
+
+
 		rs.close();
 		// End of empty result set tests
 
@@ -1002,19 +1052,6 @@ static boolean scrollInsensitiveNegative( Connection conn)
 			passed = passed && checkException(sqle, "XJ062");
 		}
 
-		// absolute(0)
-		try
-		{
-			rs.absolute(0);
-			System.out.println("absolute(0) expected to fail");
-			passed = false;
-		}
-		catch (SQLException sqle)
-		{
-			/* Check to be sure the exception is the one we expect */
-			passed = passed && checkException(sqle, "X0X86");
-		}
-
 		s_i_r.close();
 
 		return passed;
diff --git a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/BaseTest.java b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/BaseTest.java
index e878d3ad..05f3910e 100644
--- a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/BaseTest.java
+++ b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/BaseTest.java
@@ -106,6 +106,22 @@ protected void logError(String   str)
         System.out.println("ERROR: " + str);
     }
 
+    /**
+     * Simple wrapper to execute a sql string.
+     **/
+    public void executeQuery(
+    Connection  conn,
+    String      stmt_str,
+    boolean     commit_query)
+        throws SQLException
+    {
+        Statement stmt = conn.createStatement();
+        stmt.executeUpdate(stmt_str);
+        stmt.close();
+        if (commit_query)
+            conn.commit();
+    }
+
     /**
      * Call consistency checker on the table.
      * <p>
diff --git a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/OnlineCompressTest.java b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/OnlineCompressTest.java
index 80607c23..fbf65e56 100644
--- a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/OnlineCompressTest.java
+++ b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/OnlineCompressTest.java
@@ -48,7 +48,7 @@ public OnlineCompressTest()
      * Utility test function to call the system procedure.
      *
      **/
-    private void callCompress(
+    protected void callCompress(
     Connection  conn,
     String      schemaName,
     String      tableName,
@@ -173,11 +173,12 @@ private void callCompress(
      *
 	 * @exception  StandardException  Standard exception policy.
      **/
-    private void createAndLoadTable(
+    protected void createAndLoadTable(
     Connection  conn,
     boolean     create_table,
     String      tblname,
-    int         num_rows)
+    int         num_rows,
+    int         start_value)
         throws SQLException
     {
         if (create_table)
@@ -209,12 +210,12 @@ private void createAndLoadTable(
         int row_count = 0;
         try
         {
-            for (;row_count < num_rows; row_count++)
+            for (int i = start_value; row_count < num_rows; row_count++, i++)
             {
-                insert_stmt.setInt(1, row_count);               // keycol
-                insert_stmt.setInt(2, row_count * 10);          // indcol1
-                insert_stmt.setInt(3, row_count * 100);         // indcol2
-                insert_stmt.setInt(4, -row_count);              // indcol3
+                insert_stmt.setInt(1, i);               // keycol
+                insert_stmt.setInt(2, i * 10);          // indcol1
+                insert_stmt.setInt(3, i * 100);         // indcol2
+                insert_stmt.setInt(4, -i);              // indcol3
                 insert_stmt.setString(5, data1_str);            // data1_data
                 insert_stmt.setString(6, data2_str);            // data2_data
 
@@ -384,19 +385,6 @@ private void createAndLoadLongTable(
         conn.commit();
     }
 
-    private void executeQuery(
-    Connection  conn,
-    String      stmt_str,
-    boolean     commit_query)
-        throws SQLException
-    {
-        Statement stmt = conn.createStatement();
-        stmt.executeUpdate(stmt_str);
-        stmt.close();
-        if (commit_query)
-            conn.commit();
-    }
-
     private void log_wrong_count(
     String  error_msg,
     String  table_name,
@@ -442,7 +430,7 @@ private void deleteAllRows(
         if (long_table)
             createAndLoadLongTable(conn, create_table, table_name, num_rows);
         else
-            createAndLoadTable(conn, create_table, table_name, num_rows);
+            createAndLoadTable(conn, create_table, table_name, num_rows, 0);
 
         if (verbose)
             testProgress("Calling compress.");
@@ -525,7 +513,7 @@ private void simpleDeleteAllRows(
         if (long_table)
             createAndLoadLongTable(conn, create_table, table_name, num_rows);
         else
-            createAndLoadTable(conn, create_table, table_name, num_rows);
+            createAndLoadTable(conn, create_table, table_name, num_rows, 0);
 
         if (verbose)
             testProgress("Calling compress.");
@@ -601,7 +589,7 @@ private void checkPurgePhase(
         if (long_table)
             createAndLoadLongTable(conn, create_table, table_name, num_rows);
         else
-            createAndLoadTable(conn, create_table, table_name, num_rows);
+            createAndLoadTable(conn, create_table, table_name, num_rows, 0);
 
         // dump_table(conn, schemaName, table_name, false);
 
@@ -728,7 +716,7 @@ private void checkPurgePhase(
         if (long_table)
             createAndLoadLongTable(conn, create_table, table_name, num_rows);
         else
-            createAndLoadTable(conn, create_table, table_name, num_rows);
+            createAndLoadTable(conn, create_table, table_name, num_rows, 0);
         conn.commit();
 
         // delete all rows, and NO commit.
diff --git a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec1.java b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec1.java
index e69de29b..59935f28 100644
--- a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec1.java
+++ b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec1.java
@@ -0,0 +1,91 @@
+/*
+
+   Derby - Class org.apache.derbyTesting.functionTests.harness.procedure
+
+   Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derbyTesting.functionTests.tests.store;
+
+import org.apache.derby.iapi.db.OnlineCompress;
+
+import org.apache.derby.iapi.services.sanity.SanityManager;
+
+import java.sql.CallableStatement;
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+
+import org.apache.derby.tools.ij;
+
+
+public class oc_rec1 extends OnlineCompressTest
+{
+
+    public oc_rec1()
+    {
+    }
+
+    /**
+     * setup for restart recovery test.
+     * <p>
+     * Do setup to test restart recovery of online compress.  Real work
+     * is done in next test oc_rec2 which will run restart recovery on
+     * the work done in this test.
+     *
+     **/
+    private void test1(
+    Connection  conn,
+    String      test_name,
+    String      table_name)
+        throws SQLException
+    {
+        beginTest(conn, test_name);
+        createAndLoadTable(conn, true, table_name, 5000, 0);
+        executeQuery(conn, "delete from " + table_name, true);
+        callCompress(conn, "APP", table_name, true, true, true, true);
+        endTest(conn, test_name);
+    }
+
+    public void testList(Connection conn)
+        throws SQLException
+    {
+        test1(conn, "test1", "TEST1");
+    }
+
+    public static void main(String[] argv) 
+        throws Throwable
+    {
+        oc_rec1 test = new oc_rec1();
+
+   		ij.getPropertyArg(argv); 
+        Connection conn = ij.startJBMS();
+        conn.setAutoCommit(false);
+
+        try
+        {
+            test.testList(conn);
+        }
+        catch (SQLException sqle)
+        {
+			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(
+                System.out, sqle);
+			sqle.printStackTrace(System.out);
+		}
+    }
+}
diff --git a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec2.java b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec2.java
index e69de29b..fc8fa165 100644
--- a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec2.java
+++ b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec2.java
@@ -0,0 +1,107 @@
+/*
+
+   Derby - Class org.apache.derbyTesting.functionTests.harness.procedure
+
+   Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derbyTesting.functionTests.tests.store;
+
+import org.apache.derby.iapi.db.OnlineCompress;
+
+import org.apache.derby.iapi.services.sanity.SanityManager;
+
+import java.sql.CallableStatement;
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+
+import org.apache.derby.tools.ij;
+
+
+public class oc_rec2 extends OnlineCompressTest
+{
+
+    public oc_rec2()
+    {
+    }
+
+    /**
+     * setup for restart recovery test.
+     * <p>
+     * Do setup to test restart recovery of online compress.  Real work
+     * is done in next test oc_rec2 which will run restart recovery on
+     * the work done in this test.
+     *
+     **/
+    private void test1(
+    Connection  conn,
+    String      test_name,
+    String      table_name)
+        throws SQLException
+    {
+        beginTest(conn, test_name);
+        if (!checkConsistency(conn, "APP", table_name))
+        {
+            logError("conistency check failed.");
+        }
+        // make sure we can add data to the existing table after redo
+        // recovery.
+        createAndLoadTable(conn, false, table_name, 6000, 0);
+        if (!checkConsistency(conn, "APP", table_name))
+        {
+            logError("conistency check failed.");
+        }
+
+        // setup to test redo recovery on: 
+        //     create table, delete rows, compress, add rows, commit
+        String table_name_2 =  table_name + "_2";
+        createAndLoadTable(conn, true, table_name_2, 2000, 0);
+        executeQuery(conn, "delete from " + table_name, true);
+        callCompress(conn, "APP", table_name, true, true, true, true);
+
+        endTest(conn, test_name);
+    }
+
+    public void testList(Connection conn)
+        throws SQLException
+    {
+        test1(conn, "test1", "TEST1");
+    }
+
+    public static void main(String[] argv) 
+        throws Throwable
+    {
+        oc_rec2 test = new oc_rec2();
+
+   		ij.getPropertyArg(argv); 
+        Connection conn = ij.startJBMS();
+        conn.setAutoCommit(false);
+
+        try
+        {
+            test.testList(conn);
+        }
+        catch (SQLException sqle)
+        {
+			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(
+                System.out, sqle);
+			sqle.printStackTrace(System.out);
+		}
+    }
+}
diff --git a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec3.java b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec3.java
index e69de29b..c1d07d4d 100644
--- a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec3.java
+++ b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec3.java
@@ -0,0 +1,109 @@
+/*
+
+   Derby - Class org.apache.derbyTesting.functionTests.harness.procedure
+
+   Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derbyTesting.functionTests.tests.store;
+
+import org.apache.derby.iapi.db.OnlineCompress;
+
+import org.apache.derby.iapi.services.sanity.SanityManager;
+
+import java.sql.CallableStatement;
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+
+import org.apache.derby.tools.ij;
+
+
+public class oc_rec3 extends OnlineCompressTest
+{
+
+    public oc_rec3()
+    {
+    }
+
+    /**
+     * setup for restart recovery test.
+     * <p>
+     * Do setup to test restart recovery of online compress.  Real work
+     * is done in next test oc_rec3 which will run restart recovery on
+     * the work done in this test.
+     *
+     **/
+    private void test1(
+    Connection  conn,
+    String      test_name,
+    String      table_name)
+        throws SQLException
+    {
+        beginTest(conn, test_name);
+
+        String table_name_2 =  table_name + "_2";
+        if (!checkConsistency(conn, "APP", table_name_2))
+        {
+            logError("conistency check failed.");
+        }
+
+        // make sure we can add data to the existing table after redo
+        // recovery.
+        createAndLoadTable(conn, false, table_name, 2000, 0);
+        if (!checkConsistency(conn, "APP", table_name))
+        {
+            logError("conistency check failed.");
+        }
+
+        // setup to test redo recovery on: 
+        //     add more rows, delete rows, compress, add more, no commit
+        createAndLoadTable(conn, false, table_name_2, 4000, 2000);
+        executeQuery(conn, "delete from " + table_name_2, true);
+        callCompress(conn, "APP", table_name_2, true, true, true, false);
+
+        endTest(conn, test_name);
+    }
+
+    public void testList(Connection conn)
+        throws SQLException
+    {
+        test1(conn, "test1", "TEST1");
+    }
+
+    public static void main(String[] argv) 
+        throws Throwable
+    {
+        oc_rec3 test = new oc_rec3();
+
+   		ij.getPropertyArg(argv); 
+        Connection conn = ij.startJBMS();
+        conn.setAutoCommit(false);
+
+        try
+        {
+            test.testList(conn);
+        }
+        catch (SQLException sqle)
+        {
+			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(
+                System.out, sqle);
+			sqle.printStackTrace(System.out);
+		}
+    }
+}
diff --git a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec4.java b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec4.java
index e69de29b..9e1a269c 100644
--- a/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec4.java
+++ b/incubator/derby/code/branches/10.1/java/testing/org/apache/derbyTesting/functionTests/tests/store/oc_rec4.java
@@ -0,0 +1,104 @@
+/*
+
+   Derby - Class org.apache.derbyTesting.functionTests.harness.procedure
+
+   Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derbyTesting.functionTests.tests.store;
+
+import org.apache.derby.iapi.db.OnlineCompress;
+
+import org.apache.derby.iapi.services.sanity.SanityManager;
+
+import java.sql.CallableStatement;
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+
+import org.apache.derby.tools.ij;
+
+
+public class oc_rec4 extends OnlineCompressTest
+{
+
+    public oc_rec4()
+    {
+    }
+
+    /**
+     * setup for restart recovery test.
+     * <p>
+     * Do setup to test restart recovery of online compress.  Real work
+     * is done in next test oc_rec4 which will run restart recovery on
+     * the work done in this test.
+     *
+     **/
+    private void test1(
+    Connection  conn,
+    String      test_name,
+    String      table_name)
+        throws SQLException
+    {
+        beginTest(conn, test_name);
+
+        // oc_rec3 left the table  with no rows, but compress command
+        // did not commit.
+        String table_name_2 =  table_name + "_2";
+        if (!checkConsistency(conn, "APP", table_name_2))
+        {
+            logError("conistency check failed.");
+        }
+
+        // make sure we can add data to the existing table after redo
+        // recovery.
+        createAndLoadTable(conn, false, table_name_2, 6000, 0);
+        if (!checkConsistency(conn, "APP", table_name_2))
+        {
+            logError("conistency check failed.");
+        }
+        endTest(conn, test_name);
+    }
+
+    public void testList(Connection conn)
+        throws SQLException
+    {
+        test1(conn, "test1", "TEST1");
+    }
+
+    public static void main(String[] argv) 
+        throws Throwable
+    {
+        oc_rec4 test = new oc_rec4();
+
+   		ij.getPropertyArg(argv); 
+        Connection conn = ij.startJBMS();
+        conn.setAutoCommit(false);
+
+        try
+        {
+            test.testList(conn);
+        }
+        catch (SQLException sqle)
+        {
+			org.apache.derby.tools.JDBCDisplayUtil.ShowSQLException(
+                System.out, sqle);
+			sqle.printStackTrace(System.out);
+		}
+    }
+}
diff --git a/incubator/derby/code/branches/10.1/java/tools/org/apache/derby/impl/tools/ij/utilMain.java b/incubator/derby/code/branches/10.1/java/tools/org/apache/derby/impl/tools/ij/utilMain.java
index 103e67f9..46adde14 100644
--- a/incubator/derby/code/branches/10.1/java/tools/org/apache/derby/impl/tools/ij/utilMain.java
+++ b/incubator/derby/code/branches/10.1/java/tools/org/apache/derby/impl/tools/ij/utilMain.java
@@ -693,12 +693,7 @@ public ijResult absolute(ResultSet rs, int row)
 			throw ijException.forwardOnlyCursor("ABSOLUTE");
 		}
 
-		// 0 is an invalid value for row
-		if (row == 0)
-		{
-			throw ijException.zeroInvalidForAbsolute();
-		}
-
+		// 0 is an *VALID* value for row
 		return new ijRowResult(rs, rs.absolute(row));
 	}
 
