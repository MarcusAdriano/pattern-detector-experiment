diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/catalog/SequencePreallocator.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/catalog/SequencePreallocator.java
index 7f7c03d5..e69de29b 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/catalog/SequencePreallocator.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/catalog/SequencePreallocator.java
@@ -1,73 +0,0 @@
-/*
-
-   Derby - Class org.apache.derby.catalog.SequencePreallocator
-
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to You under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-
-package org.apache.derby.catalog;
-
-import java.sql.SQLException;
-
-/**
- * <p>
- * Logic to determine how many values to pre-allocate for an identity column or sequence.
- * By default, Derby boosts concurrency by pre-allocating ranges of numbers for identity columns and sequences.
- * During orderly database shutdown, the unused numbers are reclaimed so that shutdown will
- * not create holes in the sequences.  However, holes may appear if the application fails to shut
- * down its databases before the JVM exits.
- * </p>
- *
- * <p>
- * Logic in this class is called every time Derby needs to pre-allocate a new range of identity/sequence
- * values. Users can override Derby's default behavior by writing their own implementation of this
- * interface and then setting the following Derby property:
- * </p>
- *
- * <pre>
- *  -Dderby.language.sequence.preallocator=com.acme.MySequencePreallocator
- * </pre>
- *
- * <p>
- * Classes which implement this interface must also provide a public 0-arg constructor so
- * that Derby can instantiate them. Derby will instantiate a SequencePreallocator for each identity
- * column and sequence.
- * </p>
- *
- */
-public  interface   SequencePreallocator
-{
-    /**
-     * <p>
-     * This method returns the size of the next pre-allocated range for the specified
-     * identity column or sequence. Names are case-sensitive, as specified in CREATE SEQUENCE
-     * and CREATE TABLE statements.
-     * </p>
-     *
-     * @param schemaName Name of schema holding the sequence or identity-laden table.
-     * @param sequenceName Specific name of the sequence or identity-laden table.
-     */
-    public  int nextRangeSize
-        (
-         String schemaName,
-         String sequenceName
-         );
-    
-}
-
-
-
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/reference/Property.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/reference/Property.java
index 415290b4..9a8f8dbd 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/reference/Property.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/reference/Property.java
@@ -626,24 +626,6 @@ Default value for wait timeouts (60 seconds)
 	String	LANG_SEQGEN_CACHE_SIZE = "derby.language.sequenceGeneratorCacheSize";
 	int		LANG_SEQGEN_CACHE_SIZE_DEFAULT =32;
 
-	/**
-	 * The size of the identity generator cache 
-	 * used by the data dictionary.  Database.  Static.
-	 * <p>
-	 * Externally visible.
-	 */
-	String	LANG_IDGEN_CACHE_SIZE = "derby.language.identityGeneratorCacheSize";
-	int		LANG_IDGEN_CACHE_SIZE_DEFAULT =32;
-
-	/**
-	 * Name of the implementation of SequencePreallocator which is used
-     * to tune how many values Derby pre-allocates for identity columns
-     * and sequences. Database.  Static.
-	 * <p>
-	 * Externally visible.
-	 */
-	String	LANG_SEQUENCE_PREALLOCATOR = "derby.language.sequence.preallocator";
-    
 	/**
 	  derby.language.stalePlanCheckInterval
 
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/sql/dictionary/DataDictionary.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/sql/dictionary/DataDictionary.java
index 48937e9a..719774d9 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/sql/dictionary/DataDictionary.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/sql/dictionary/DataDictionary.java
@@ -213,13 +213,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	 */
 	public void clearCaches() throws StandardException;
 
-	/**
-	 * Clear all of the sequence number generators.
-	 *
-	 * @exception StandardException Standard Derby error policy
-	 */
-	public void clearSequenceCaches() throws StandardException;
-
 	/**
 	 * Inform this DataDictionary that we are about to start reading it.  This
 	 * means using the various get methods in the DataDictionary.
@@ -1721,6 +1714,29 @@ public void dropFileInfoDescriptor(FileInfoDescriptor fid)
 	public RowLocation getRowLocationTemplate( LanguageConnectionContext lcc, TableDescriptor td)
 		throws StandardException;
 
+	/**
+	 * getSetAutoincrementValue fetches the autoincrement value from 
+	 * SYSCOLUMNS given a row location. If doUpdate is true it updates
+	 * the autoincrement column with the new value.
+	 * the value returned by this routine is the new value and *NOT* the
+	 * value in the system catalogs.
+	 * 
+	 * @param rl		RowLocation of the entry in SYSCOLUMNS.
+	 * @param tc		TransactionController to use.
+	 * @param doUpdate  Write the new value to disk if TRUE.
+	 * @param newValue	A NumberDataValue to use to return incremented value. If
+	 * null, then the caller simply wants the current value fromd disk.
+	 * @param wait		If true, then the caller wants to wait for locks. When
+	 * using a nested user xaction we want to timeout right away if the parent
+	 * holds the lock.
+	 */
+	public NumberDataValue 	getSetAutoincrementValue(RowLocation rl,
+											 TransactionController tc,
+											 boolean doUpdate,
+											 NumberDataValue newValue,
+											 boolean wait)
+		throws StandardException;
+
 	/**
 	 * sets a new value in SYSCOLUMNS for a particular
 	 * autoincrement column.
@@ -1740,22 +1756,21 @@ public void setAutoincrementValue(TransactionController tc,
 		throws StandardException;
 	
 	/**
-	 * Get the next number from an identity or sequence generator
-     * which was created with the CREATE TABLE or CREATE SEQUENCE statement. May
-     * raise an exception if the generator was defined as NO CYCLE and
-     * the range of the generator is exhausted. May allocate a range of
-     * numbers and update the current column of the
-     * corresponding row in SYSCOLULMNS or SYSSEQUENCES. This work is done in the
+	 * Get the next number from an ANSI/ISO sequence generator
+     * which was created with the CREATE SEQUENCE statement. May
+     * raise an exception if the sequence was defined as NO CYCLE and
+     * the range of the sequence is exhausted. May allocate a range of
+     * sequence numbers and update the CURRENTVALUE column of the
+     * corresponding row in SYSSEQUENCES. This work is done in the
      * execution transaction of the current session.
 	 * 
-	 * @param catalogNumber Number of the catalog that manages the values (either SYSCOLUMNS_CATALOG_NUM or SYSSEQUENCES_CATALOG_NUM)
-	 * @param uuidString String value of the UUID which identifies the table or the sequence
-	 * @param returnValue This is a data value to be stuffed with the next number in the range.
+	 * @param sequenceUUIDstring String value of the UUID which identifies the sequence
+	 * @param returnValue This is a data value to be stuffed with the next sequence number.
      *
-     * @throws StandardException if the generator does not cycle and its range is exhausted
+     * @throws StandardException if the sequence does not cycle and its range is exhausted
 	 */
     public void getCurrentValueAndAdvance
-        ( int catalogNumber, String uuidString, NumberDataValue returnValue )
+        ( String sequenceUUIDstring, NumberDataValue returnValue )
         throws StandardException;
 
 	/**
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/sql/dictionary/SequenceDescriptor.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/sql/dictionary/SequenceDescriptor.java
index 09fa742a..8f9e7d4b 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/sql/dictionary/SequenceDescriptor.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/sql/dictionary/SequenceDescriptor.java
@@ -32,7 +32,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.sql.depend.Dependent;
 import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
 import org.apache.derby.iapi.types.DataTypeDescriptor;
-import org.apache.derby.iapi.types.TypeId;
 import org.apache.derby.iapi.store.access.TransactionController;
 import org.apache.derby.impl.sql.catalog.DDdependableFinder;
 
@@ -46,9 +45,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 public class SequenceDescriptor extends TupleDescriptor
         implements Provider, Dependent, PrivilegedSQLObject
 {
-    // indexes into array of computed min/max values
-    public  static  final   int MIN_VALUE = 0;
-    public  static  final   int MAX_VALUE = MIN_VALUE + 1;
 
     private UUID sequenceUUID;
     private String sequenceName;
@@ -95,35 +91,6 @@ public SequenceDescriptor(DataDictionary dataDictionary, SchemaDescriptor sd, UU
     }
 
     /**
-     * Compute the minimum and maximum values for a sequence range.
-     * Returns an array of two Longs. The first Long is the minimum value,
-     * The second is the maximum value.
-     */
-    public  static  Long[]  computeMinMax
-        (
-         DataTypeDescriptor dataType,
-         Object minValue,
-         Object maxValue
-         )
-    {
-        Long[]  retval = new Long[ 2 ];
-
-        if (dataType.getTypeId().equals(TypeId.SMALLINT_ID)) {
-            retval[ MIN_VALUE ] = (minValue != null ? (Long) minValue : new Long(Short.MIN_VALUE));
-            retval[ MAX_VALUE ] = (maxValue != null ? (Long) maxValue : new Long(Short.MAX_VALUE));
-        } else if (dataType.getTypeId().equals(TypeId.INTEGER_ID)) {
-            retval[ MIN_VALUE ]  = (minValue != null ? (Long) minValue : new Long(Integer.MIN_VALUE));
-            retval[ MAX_VALUE ]  = (maxValue != null ? (Long) maxValue : new Long(Integer.MAX_VALUE));
-        } else {
-            // Could only be BIGINT
-            retval[ MIN_VALUE ]  = (minValue != null ? (Long) minValue : new Long(Long.MIN_VALUE));
-            retval[ MAX_VALUE ]  = (maxValue != null ? (Long) maxValue : new Long(Long.MAX_VALUE));
-        }
-
-        return retval;
-    }
-
-   /**
 	 * @see UniqueTupleDescriptor#getUUID
 	 */
 	public UUID	getUUID()
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/db/BasicDatabase.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/db/BasicDatabase.java
index 1c87ce5d..942c2105 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/db/BasicDatabase.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/db/BasicDatabase.java
@@ -241,17 +241,6 @@ public void boot(boolean create, Properties startParams)
     }
 
 	public void stop() {
-        // The data dictionary is not available if this database has the
-        // role as an active replication slave database.
-        if (dd != null) {
-            try {
-                // on orderly shutdown, try not to leak unused numbers from
-                // the sequence generators.
-                dd.clearSequenceCaches();
-            } catch (StandardException se) {
-                se.printStackTrace(Monitor.getStream().getPrintWriter());
-            }
-        }
 		active = false;
 	}
 
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java
index fb492db4..16dcb06b 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/DataDictionaryImpl.java
@@ -385,13 +385,11 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	CacheManager	nameTdCache;
 	private CacheManager	spsNameCache;
     private CacheManager sequenceGeneratorCache;
-    private CacheManager idGeneratorCache;
 	private Hashtable		spsIdHash;
 	// private Hashtable       spsTextHash;
 	int				tdCacheSize;
 	int				stmtCacheSize;
     private int seqgenCacheSize;
-    private int idgenCacheSize;
 
     /* Cache of permissions data */
     CacheManager permissionsCache;
@@ -635,10 +633,6 @@ public void boot(boolean create, Properties startParams)
 		seqgenCacheSize = PropertyUtil.intPropertyValue(Property.LANG_SEQGEN_CACHE_SIZE, value,
 									   0, Integer.MAX_VALUE, Property.LANG_SEQGEN_CACHE_SIZE_DEFAULT);
 
-		value = startParams.getProperty(Property.LANG_IDGEN_CACHE_SIZE);
-		idgenCacheSize = PropertyUtil.intPropertyValue(Property.LANG_IDGEN_CACHE_SIZE, value,
-									   0, Integer.MAX_VALUE, Property.LANG_IDGEN_CACHE_SIZE_DEFAULT);
-
 		value = startParams.getProperty(Property.LANG_PERMISSIONS_CACHE_SIZE);
 		permissionsCacheSize = PropertyUtil.intPropertyValue(Property.LANG_PERMISSIONS_CACHE_SIZE, value,
 									   0, Integer.MAX_VALUE, Property.LANG_PERMISSIONS_CACHE_SIZE_DEFAULT);
@@ -694,9 +688,6 @@ public void boot(boolean create, Properties startParams)
 		sequenceGeneratorCache = cf.newCacheManager
             ( this, "SequenceGeneratorCache", seqgenCacheSize, seqgenCacheSize );
 
-		idGeneratorCache = cf.newCacheManager
-            ( this, "IdentityGeneratorCache", idgenCacheSize, idgenCacheSize );
-
 		/* Get the object to coordinate cache transitions */
 		cacheCoordinator = new ShExLockable();
 
@@ -988,7 +979,6 @@ public Cacheable newCacheable(CacheManager cm) {
 		else if ( cm == nameTdCache ) { return new NameTDCacheable( this ); }
         else if ( cm == permissionsCache ) { return new PermissionsCacheable( this ); }
         else if ( cm == sequenceGeneratorCache ) { return new SequenceUpdater.SyssequenceUpdater( this ); }
-        else if ( cm == idGeneratorCache ) { return new SequenceUpdater.SyscolumnsUpdater( this ); }
 		else { return new SPSNameCacheable( this ); }
 	}
 
@@ -8639,25 +8629,90 @@ private void bootStrapSystemIndexes(
 		return rla;
 	}
     
-	private RowLocation computeIdentityRowLocation(TransactionController tc,
- 													TableDescriptor td)
+
+	/**
+	 * @see DataDictionary#getSetAutoincrementValue
+	 */
+	public NumberDataValue getSetAutoincrementValue(
+											RowLocation rl, 
+											TransactionController tc,
+											boolean doUpdate,
+											NumberDataValue newValue,
+											boolean wait)
  				throws StandardException
  	{
- 		int size;
-		if (!(td.tableHasAutoincrement())) { return null; }
  
- 		size = td.getNumberOfColumns();
+		FormatableBitSet columnToUpdate = new 
+  			FormatableBitSet(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMN_COUNT);
+  		int columnNum = SYSCOLUMNSRowFactory.SYSCOLUMNS_AUTOINCREMENTVALUE;
+		TabInfoImpl ti = coreInfo[SYSCOLUMNS_CORE_NUM];
+  		ConglomerateController heapCC = null;
+		SYSCOLUMNSRowFactory	rf = (SYSCOLUMNSRowFactory) ti.getCatalogRowFactory();
+		ExecRow row = rf.makeEmptyRow();
  
- 		for (int i = 0; i < size; i++)
+  		FormatableBitSet  columnToRead = new
+  			FormatableBitSet(SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMN_COUNT);
+		
+		// FormatableBitSet is 0 based.
+  		columnToRead.set(columnNum - 1); // current value.
+		columnToRead.set(columnNum);     // start value.
+		columnToRead.set(columnNum + 1); // increment value.
+
+        try
  		{
- 			ColumnDescriptor cd = td.getColumnDescriptor(i + 1);
- 			if (cd.isAutoincrement())
+			/* if wait is true then we need to do a wait while trying to
+			   open/fetch from the conglomerate. note we use wait both to
+			   open as well as fetch from the conglomerate.
+			*/
+            heapCC = 
+                tc.openConglomerate(
+                    ti.getHeapConglomerate(), 
+                    false,
+                    (TransactionController.OPENMODE_FORUPDATE |
+                     ((wait) ? 0 : TransactionController.OPENMODE_LOCK_NOWAIT)),
+                    TransactionController.MODE_RECORD,
+                    TransactionController.ISOLATION_REPEATABLE_READ);
+
+            boolean baseRowExists = 
+                heapCC.fetch(rl, row.getRowArray(), columnToRead, wait);
+
+            columnToUpdate.set(columnNum - 1); // current value.
+
+            // while the Row interface is 1 based.
+            NumberDataValue currentAI = (NumberDataValue)row.getColumn(columnNum);
+            long currentAIValue = currentAI.getLong();
+            
+            if (doUpdate)
             {
-				return computeRowLocation(tc, td, cd.getColumnName());
+                // we increment and store the new value in SYSCOLUMNS
+                NumberDataValue increment = (NumberDataValue)row.getColumn(columnNum + 2);
+                currentAI = currentAI.plus(currentAI, increment, currentAI);
+                row.setColumn(columnNum, currentAI);
+                heapCC.replace(rl, row.getRowArray(), columnToUpdate);
             }
+                
+            // but we return the "currentAIValue"-- i.e the value before
+            // incrementing it. 
+            if (newValue != null)
+            {
+                // user has passed in an object; set the current value in there and
+                // return it.
+                newValue.setValue(currentAIValue);
+                return newValue;
  		}
         
-		return null;
+            else
+            {
+                // reuse the object read from row.
+                currentAI.setValue(currentAIValue);
+                return currentAI;
+            }
+        }
+        finally
+        {
+            if (heapCC != null)
+                heapCC.close();
+        }
  	}
 
 	private	ConglomerateDescriptor	bootstrapOneIndex
@@ -8825,12 +8880,10 @@ public void clearCaches() throws StandardException
 	{
 		nameTdCache.cleanAll();
 		nameTdCache.ageOut();
-
 		OIDTdCache.cleanAll();
 		OIDTdCache.ageOut();
-
-        clearSequenceCaches();
-
+		sequenceGeneratorCache.cleanAll();
+		sequenceGeneratorCache.ageOut();
 		if (spsNameCache != null)
 		{
 			//System.out.println("CLEARING SPS CACHE");
@@ -8842,19 +8895,6 @@ public void clearCaches() throws StandardException
 	}
 
     /**
-       Flush sequence caches to disk so that we don't leak unused, pre-allocated numbers.
-    */
-    public void    clearSequenceCaches() throws StandardException
-    {
-		sequenceGeneratorCache.cleanAll();
-		sequenceGeneratorCache.ageOut();
-
-		idGeneratorCache.cleanAll();
-		idGeneratorCache.ageOut();
-    }
-    
-
-	/**
 		Add the required entries to the data dictionary for a System table.
 	*/
 
@@ -9969,8 +10009,7 @@ private static String twoDigits(int val) {
 
 	/**
 	 * sets a new value in SYSCOLUMNS for a particular
-	 * autoincrement column. this throws away the sequence generator for the
-     * value so that it must be created from scratch.
+	 * autoincrement column.
 	 * 
 	 * @param tc		 Transaction Controller to use.
 	 * @param columnName Name of the column.
@@ -10020,24 +10059,10 @@ public void setAutoincrementValue(TransactionController tc,
 					 bArray, 
 					 colsToUpdate,
 					 tc);
-
-        // remove the generator for this identity column so that it will be reinitialized with the new value.
-        flushIdentityFromCache( tableUUID );
-        
 		return;
 	}
 
     /**
-     * Remove an id generator from the cache so that it will have to be recreated.
-     * This method is called after changing the generator on disk.
-     */
-    private void    flushIdentityFromCache( UUID tableID ) throws StandardException
-    {
-        Cacheable   idGenerator = idGeneratorCache.findCached( tableID.toString() );
-        if ( idGenerator != null ) { idGeneratorCache.remove( idGenerator ); }
-    }
-
-	/**
 	 * Computes the RowLocation in SYSCOLUMNS for a particular 
 	 * autoincrement column.
 	 * 
@@ -10064,108 +10089,6 @@ private RowLocation computeRowLocation(TransactionController tc,
 								 SYSCOLUMNSRowFactory.SYSCOLUMNS_INDEX1_ID);
 	}
 
-	/**
-	 * Computes the RowLocation in SYSCOLUMNS for the identity column of a table. Also
-     * constructs a sequence descriptor describing the current state of the identity sequence.
-	 * 
-	 * @param tc			Transaction Controller to use.
-	 * @param tableIDstring UUID of the table as a string
-	 * @param rowLocation OUTPUT param for returing the row location
-	 * @param sequenceDescriptor OUTPUT param for return the sequence descriptor
-     *
-	 * @exception StandardException thrown on failure.
-	 */ 
-	void computeIdentityRowLocation
-        ( TransactionController tc, String tableIDstring, RowLocation[] rowLocation, SequenceDescriptor[] sequenceDescriptor )
-		throws StandardException								  
-	{
-        UUID    tableID = getUUIDFactory().recreateUUID( tableIDstring );
-        TableDescriptor td = getTableDescriptor( tableID );
-
-        // there should only be 1 identity column per table
-        rowLocation[ 0 ] = computeIdentityRowLocation( tc, td );
-
-		TabInfoImpl ti = coreInfo[SYSCOLUMNS_CORE_NUM];
-  		ConglomerateController heapCC = null;
-		SYSCOLUMNSRowFactory	rf = (SYSCOLUMNSRowFactory) ti.getCatalogRowFactory();
-		ExecRow row = rf.makeEmptyRow();
-		FormatableBitSet columnsToFetch = new FormatableBitSet( SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMN_COUNT );
-
-        for ( int i = 0; i < SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMN_COUNT; i++ )
-        {
-            columnsToFetch.set( i );
-        }
-
-        try
-        {
-            heapCC = 
-                tc.openConglomerate(
-                    ti.getHeapConglomerate(), 
-                    false,
-                    0,
-                    TransactionController.MODE_RECORD,
-                    TransactionController.ISOLATION_REPEATABLE_READ);
-
-            heapCC.fetch( rowLocation[ 0 ], row.getRowArray(), columnsToFetch, true );
-
-            ColumnDescriptor    cd = (ColumnDescriptor) rf.buildDescriptor( row, td, this );
-            DataTypeDescriptor  dtd = cd.getType();
-            Long[]  minMax = SequenceDescriptor.computeMinMax( dtd, null, null );
-
-            sequenceDescriptor[ 0 ] = getDataDescriptorGenerator().newSequenceDescriptor
-                (
-                 td.getSchemaDescriptor(),
-                 td.getUUID(),
-                 td.getName(),
-                 dtd,
-                 new Long( cd.getAutoincValue() ),
-                 cd.getAutoincStart(),
-                 minMax[ SequenceDescriptor.MIN_VALUE ].longValue(),
-                 minMax[ SequenceDescriptor.MAX_VALUE ].longValue(),
-                 cd.getAutoincInc(),
-                 false
-                 );
-        }
-        finally
-        {
-            if (heapCC != null) { heapCC.close(); }
-        }
-	}
-
-	/**
-	 * Set the current value of an identity sequence. This method does not perform
-     * any sanity checking but assumes that the caller knows what they are doing. If the
-     * old value on disk is not what we expect it to be, then we are in a race with another
-     * session. They won and we don't update the value on disk. However, if the old value
-     * is null, that is a signal to us that we should update the value on disk anyway.
-	 * 
-	 * @param tc			Transaction Controller to use.
-	 * @param rowLocation Row in SYSCOLUMNS to update.
-     * @param wait True if we should wait for locks
-     * @param oldValue What we expect to find in the AUTOINCREMENTVALUE column.
-     * @param newValue What to stuff into the AUTOINCREMENTVALUE column.
-	 * 
-	 * @return Returns true if the value was successfully updated, false if we lost a race with another session.
-     *
-	 * @exception StandardException thrown on failure.
-	 */
-    boolean updateCurrentIdentityValue
-        ( TransactionController tc, RowLocation rowLocation, boolean wait, Long oldValue, Long newValue )
-        throws StandardException
-    {
-        return updateCurrentSeqValue
-            (
-             tc,
-             rowLocation,
-             wait,
-             oldValue,
-             newValue,
-             coreInfo[SYSCOLUMNS_CORE_NUM],
-             SYSCOLUMNSRowFactory.SYSCOLUMNS_COLUMN_COUNT,
-             SYSCOLUMNSRowFactory.SYSCOLUMNS_AUTOINCREMENTVALUE
-             );
-    }
-    
 	/**
 	 * Computes the RowLocation in SYSSEQUENCES for a particular sequence. Also
      * constructs the sequence descriptor.
@@ -10224,55 +10147,11 @@ private RowLocation computeRowLocation(TransactionController tc,
         ( TransactionController tc, RowLocation rowLocation, boolean wait, Long oldValue, Long newValue )
         throws StandardException
     {
-        return updateCurrentSeqValue
-            (
-             tc,
-             rowLocation,
-             wait,
-             oldValue,
-             newValue,
-             getNonCoreTI( SYSSEQUENCES_CATALOG_NUM ),
-             SYSSEQUENCESRowFactory.SYSSEQUENCES_COLUMN_COUNT,
-             SYSSEQUENCESRowFactory.SYSSEQUENCES_CURRENT_VALUE
-             );
-    }
-    
-	/**
-	 * Set the current value of an ANSI/ISO sequence or identity column. This method does not perform
-     * any sanity checking but assumes that the caller knows what they are doing. If the
-     * old value on disk is not what we expect it to be, then we are in a race with another
-     * session. They won and we don't update the value on disk. However, if the old value
-     * is null, that is a signal to us that we should update the value on disk anyway.
-	 * 
-	 * @param tc			Transaction Controller to use.
-	 * @param rowLocation Row in SYSSEQUENCES or SYSCOLUMNS to update.
-     * @param wait True if we should wait for locks
-     * @param oldValue What we expect to find in the currentvalue column.
-     * @param newValue What to stuff into the current value column.
-     * @param ti Table info for the catalog that is being updated.
-     * @param columnsInRow Number of columns in the catalog row.
-     * @param columnNum ID of the current value column
-	 * 
-	 * @return Returns true if the value was successfully updated, false if we lost a race with another session.
-     *
-	 * @exception StandardException thrown on failure.
-	 */
-    private boolean updateCurrentSeqValue
-        (
-         TransactionController tc,
-         RowLocation rowLocation,
-         boolean wait,
-         Long oldValue,
-         Long newValue,
-         TabInfoImpl    ti,
-         int    columnsInRow,
-         int    columnNum
-         )
-        throws StandardException
-    {
-		FormatableBitSet columnToUpdate = new FormatableBitSet( columnsInRow );
+  		int columnNum = SYSSEQUENCESRowFactory.SYSSEQUENCES_CURRENT_VALUE;
+		FormatableBitSet columnToUpdate = new FormatableBitSet( SYSSEQUENCESRowFactory.SYSSEQUENCES_COLUMN_COUNT );
+		TabInfoImpl ti = getNonCoreTI( SYSSEQUENCES_CATALOG_NUM );
   		ConglomerateController heapCC = null;
-		CatalogRowFactory	rf = ti.getCatalogRowFactory();
+		SYSSEQUENCESRowFactory	rf = (SYSSEQUENCESRowFactory) ti.getCatalogRowFactory();
 		ExecRow row = rf.makeEmptyRow();
         
 		// FormatableBitSet is 0 based.
@@ -10328,28 +10207,13 @@ private RowLocation computeRowLocation(TransactionController tc,
 	 * @see org.apache.derby.iapi.sql.dictionary.DataDictionary#getCurrentValueAndAdvance
 	 */
     public void getCurrentValueAndAdvance
-        ( int catalogNumber, String uuidString, NumberDataValue returnValue )
+        ( String sequenceUUIDstring, NumberDataValue returnValue )
         throws StandardException
     {
-        CacheManager    cm = null;
         SequenceUpdater sequenceUpdater = null;
 
         try {
-            switch( catalogNumber )
-            {
-            case SYSSEQUENCES_CATALOG_NUM:
-                cm = sequenceGeneratorCache;
-                break;
-
-            case SYSCOLUMNS_CATALOG_NUM:
-                cm = idGeneratorCache;
-                break;
-
-            default:
-                throw StandardException.newException( SQLState.BTREE_UNIMPLEMENTED_FEATURE );
-            }
-
-            sequenceUpdater = (SequenceUpdater) cm.find( uuidString );
+            sequenceUpdater = (SequenceUpdater) sequenceGeneratorCache.find( sequenceUUIDstring );
 
             sequenceUpdater.getCurrentValueAndAdvance( returnValue );
         }
@@ -10357,7 +10221,7 @@ private RowLocation computeRowLocation(TransactionController tc,
         {
             if ( sequenceUpdater != null )
             {
-                cm.release( sequenceUpdater );
+                sequenceGeneratorCache.release( sequenceUpdater );
             }
         }
     }
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/SequenceGenerator.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/SequenceGenerator.java
index e265d85c..66dae196 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/SequenceGenerator.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/SequenceGenerator.java
@@ -20,7 +20,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
  */
 package org.apache.derby.impl.sql.catalog;
 
-import org.apache.derby.catalog.SequencePreallocator;
 import org.apache.derby.iapi.error.StandardException;
 import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.services.cache.Cacheable;
@@ -112,6 +111,14 @@ Licensed to the Apache Software Foundation (ASF) under one or more
     //
     ///////////////////////////////////////////////////////////////////////////////////
 
+    /**
+     * Default number of values to pre-allocate. In the future, we may want to provide
+     * something more sophisticated. For instance, we might want to make Derby tune
+     * this number per sequence generator or give the user the power to override Derby's
+     * decision.
+     */
+    public static final int DEFAULT_PREALLOCATION_COUNT = 5;
+
     /** If pre-allocation drops below this level, then we need to grab another chunk of numbers */
     private static final int PREALLOCATION_THRESHHOLD = 1;
 
@@ -161,15 +168,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more
     // This is where we restart the sequence if we wrap around.
     private final long _RESTART_VALUE;
 
-    // Name of the schema that the sequence lives in.
-    private final String _SCHEMA_NAME;
-
-    // Name of the sequence.
+    // Name of the sequence (for error messages).
     private final String _SEQUENCE_NAME;
 
-    // Logic to determine how many values to pre-allocate
-    private final   SequencePreallocator    _PREALLOCATOR;
-
     ///////////////////////////////////////////////////////////////////////////////////
     //
     // VARIABLES
@@ -182,6 +183,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more
     // This is the next value which the generator will hand out.
     private long _currentValue;
 
+    // This is the number of values to pre-allocate per chunk. Right now this
+    // is a constant which we figure out when we initialize the generator.
+    // However, this number could change over time if, for instance, Derby
+    // tunes it on the fly.
+    private long _valuesPerAllocation;
+    
     // This is the remaining number of values which were pre-allocated on disk
     // by bumping the contents of SYSSEQUENCES.CURRENTVALUE.
     private long _remainingPreallocatedValues;
@@ -202,9 +209,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
          long maxValue,
          long minValue,
          long restartValue,
-         String schemaName,
-         String sequenceName,
-         SequencePreallocator   sequencePreallocator
+         String sequenceName
          )
     {
         if ( currentValue == null )
@@ -224,14 +229,14 @@ Licensed to the Apache Software Foundation (ASF) under one or more
         _MIN_VALUE = minValue;
         _RESTART_VALUE = restartValue;
         _STEP_INCREASES = ( _INCREMENT > 0 );
-        _SCHEMA_NAME = schemaName;
         _SEQUENCE_NAME = sequenceName;
-        _PREALLOCATOR = sequencePreallocator;
 
         //
         // Next call to getCurrentValueAndAdvance() will cause  us to ask our caller to allocate a new range of values.
         //
         _remainingPreallocatedValues = 1L;
+
+        _valuesPerAllocation = computePreAllocationCount();
     }
     
     ///////////////////////////////////////////////////////////////////////////////////
@@ -240,15 +245,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
     //
     ///////////////////////////////////////////////////////////////////////////////////
 
-    /**
-     * <p>
-     * Get the name of the schema of this sequence generator. Technically, this doesn't need to be
-     * synchronized. But it is simpler to just maintain a rule that all public methods
-     * should be synchronized.
-     * </p>
-     */
-    public synchronized String getSchemaName() { return _SCHEMA_NAME; }
-    
     /**
      * <p>
      * Get the name of this sequence generator. Technically, this doesn't need to be
@@ -303,7 +299,7 @@ public synchronized Long peekAtCurrentValue()
         if ( _isExhausted )
         {
             throw StandardException.newException
-                ( SQLState.LANG_SEQUENCE_GENERATOR_EXHAUSTED, _SCHEMA_NAME, _SEQUENCE_NAME );
+                ( SQLState.LANG_SEQUENCE_GENERATOR_EXHAUSTED, _SEQUENCE_NAME );
         }
 
         long retval[] = new long[ CVAA_LENGTH ];
@@ -407,8 +403,6 @@ private boolean overflowed( long originalValue, long incrementedValue )
      */
     private void computeNewAllocation( long oldCurrentValue, long[] retval ) throws StandardException
     {
-        int preferredValuesPerAllocation = computePreAllocationCount();
-        
         //
         // The values are growing toward one of the endpoints of the legal range,
         // either the largest legal value or the smallest legal value. First find out
@@ -420,10 +414,10 @@ private void computeNewAllocation( long oldCurrentValue, long[] retval ) throws
         long newValueOnDisk;
         long valuesToAllocate;
 
-        if ( remainingLegalValues >= preferredValuesPerAllocation )
+        if ( remainingLegalValues >= _valuesPerAllocation )
         {
-            newValueOnDisk = oldCurrentValue + ( preferredValuesPerAllocation * _INCREMENT );
-            valuesToAllocate = preferredValuesPerAllocation;
+            newValueOnDisk = oldCurrentValue + ( _valuesPerAllocation * _INCREMENT );
+            valuesToAllocate = _valuesPerAllocation;
         }
         else
         {
@@ -431,13 +425,13 @@ private void computeNewAllocation( long oldCurrentValue, long[] retval ) throws
 
             if ( _CAN_CYCLE )
             {
-                long spillOverValues = preferredValuesPerAllocation - remainingLegalValues;
+                long spillOverValues = _valuesPerAllocation - remainingLegalValues;
 
                 // account for the fact that the restart value itself is a legal value
                 spillOverValues--;
 
                 newValueOnDisk = _RESTART_VALUE + ( spillOverValues * _INCREMENT );
-                valuesToAllocate = preferredValuesPerAllocation;
+                valuesToAllocate = _valuesPerAllocation;
             }
             else
             {
@@ -496,11 +490,9 @@ private long computeRemainingValues( long oldCurrentValue )
      */
     private int computePreAllocationCount()
     {
-        int happyResult = _PREALLOCATOR.nextRangeSize(  _SCHEMA_NAME, _SEQUENCE_NAME );
+        int happyResult = DEFAULT_PREALLOCATION_COUNT;
         int unhappyResult = PREALLOCATION_THRESHHOLD;
 
-        if ( happyResult < unhappyResult ) { return unhappyResult; }
-
         double min = _MIN_VALUE;
         double max = _MAX_VALUE;
         double range = max - min;
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/SequenceRange.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/SequenceRange.java
index 1385a9f7..e69de29b 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/SequenceRange.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/SequenceRange.java
@@ -1,89 +0,0 @@
-/*
-
-   Derby - Class org.apache.derby.impl.sql.catalog.SequenceRange
-
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to you under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-
-package org.apache.derby.impl.sql.catalog;
-
-import org.apache.derby.catalog.SequencePreallocator;
-
-/**
- * <p>
- * Default Derby logic for determining how many values to pre-allocate for an
- * identity column or sequence.
- * </p>
- */
-public  class   SequenceRange   implements  SequencePreallocator
-{
-    ///////////////////////////////////////////////////////////////////////////////////
-    //
-    // CONSTANTS
-    //
-    ///////////////////////////////////////////////////////////////////////////////////
-
-    /**
-     * Default number of values to pre-allocate. This is the size of the preallocation range
-     * used by other databases. See DERBY-4437.
-     */
-    private static final int DEFAULT_PREALLOCATION_COUNT = 20;
-
-    ///////////////////////////////////////////////////////////////////////////////////
-    //
-    // STATE
-    //
-    ///////////////////////////////////////////////////////////////////////////////////
-
-    private int _rangeSize;
-
-    ///////////////////////////////////////////////////////////////////////////////////
-    //
-    // CONSTRUCTOR
-    //
-    ///////////////////////////////////////////////////////////////////////////////////
-
-    /** <p>0-arg constructore needed to satisfy the SequencePreallocator contract.</p> */
-    public  SequenceRange()
-    {
-        this( DEFAULT_PREALLOCATION_COUNT );
-    }
-
-    public  SequenceRange( int rangeSize )
-    {
-        if ( rangeSize <= 0 ) { rangeSize = DEFAULT_PREALLOCATION_COUNT; }
-        
-        _rangeSize = rangeSize;
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////
-    //
-    // SequencePreallocator BEHAVIOR
-    //
-    ///////////////////////////////////////////////////////////////////////////////////
-
-    public  int nextRangeSize
-        (
-         String schemaName,
-         String sequenceName
-         )
-    {
-        return _rangeSize;
-    }
-
-
-}
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java
index d08b6865..8034a54d 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/catalog/SequenceUpdater.java
@@ -20,10 +20,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
  */
 package org.apache.derby.impl.sql.catalog;
 
-import org.apache.derby.catalog.SequencePreallocator;
 import org.apache.derby.iapi.db.Database;
 import org.apache.derby.iapi.error.StandardException;
-import org.apache.derby.iapi.reference.Property;
 import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.services.cache.Cacheable;
 import org.apache.derby.iapi.services.cache.CacheManager;
@@ -155,7 +153,7 @@ public SequenceUpdater( DataDictionaryImpl dd )
     
     ///////////////////////////////////////////////////////////////////////////////////
     //
-    // ABSTRACT OR OVERRIDABLE BEHAVIOR TO BE IMPLEMENTED BY CHILDREN
+    // ABSTRACT BEHAVIOR TO BE IMPLEMENTED BY CHILDREN
     //
     ///////////////////////////////////////////////////////////////////////////////////
 
@@ -187,19 +185,6 @@ abstract protected SequenceGenerator createSequenceGenerator( TransactionControl
      */
     abstract protected boolean updateCurrentValueOnDisk( TransactionController tc, Long oldValue, Long newValue, boolean wait ) throws StandardException;
     
-    /**
-     * <p>
-     * Create an exception to state that there is too much contention on the generator.
-     * For backward compatibility reasons, different messages are needed by sequences
-     * and identities. See DERBY-5426.
-     * </p>
-     */
-    protected   StandardException   tooMuchContentionException()
-    {
-        return StandardException.newException
-            ( SQLState.LANG_TOO_MUCH_CONTENTION_ON_SEQUENCE, _sequenceGenerator.getName() );
-    }
-    
     ///////////////////////////////////////////////////////////////////////////////////
     //
     // Cacheable BEHAVIOR
@@ -223,7 +208,6 @@ public void clean(boolean forRemove) throws StandardException
                 String  errorMessage = MessageService.getTextMessage
                     (
                      SQLState.LANG_CANT_FLUSH_PREALLOCATOR,
-                     _sequenceGenerator.getSchemaName(),
                      _sequenceGenerator.getName()
                      );
 
@@ -337,8 +321,8 @@ public Cacheable setIdentity(Object key) throws StandardException
         Long startTime = null;
 
         //
-        // We try to get a sequence number. We try until we've exceeded the lock timeout
-        // in case we find ourselves in a race with another session which is draining numbers from
+        // We try to get a sequence number. We try a couple times in case we find
+        // ourselves in a race with another session which is draining numbers from
         // the same sequence generator.
         //
         while ( true )
@@ -390,16 +374,18 @@ public Cacheable setIdentity(Object key) throws StandardException
                 ( (System.currentTimeMillis() - startTime.longValue()) > _lockTimeoutInMillis )
                 )
             {
+                break;
+            }
+            
+        } // end of retry loop
+
                 //
                 // If we get here, then we exhausted our retry attempts. This might be a sign
                 // that we need to increase the number of sequence numbers which we
                 // allocate. There's an opportunity for Derby to tune itself here.
                 //
-                throw tooMuchContentionException();
-            }
-            
-        } // end of retry loop
-
+        throw StandardException.newException
+            ( SQLState.LANG_TOO_MUCH_CONTENTION_ON_SEQUENCE, _sequenceGenerator.getName() );
     }
 
     /**
@@ -494,47 +480,6 @@ public boolean updateCurrentValueOnDisk( Long oldValue, Long newValue ) throws S
     //
     ///////////////////////////////////////////////////////////////////////////////////
 
-    /** Make a new range allocator (called when the generator is instantiated) */
-    protected SequencePreallocator  makePreallocator( TransactionController tc )
-        throws StandardException
-    {
-        String  propertyName = Property.LANG_SEQUENCE_PREALLOCATOR;
-        String  className = PropertyUtil.getServiceProperty( tc, propertyName );
-
-        if ( className == null ) { return new SequenceRange(); }
-
-        try {
-            // If the property value was a number rather than a class name, then
-            // use that as the default size for preallocated ranges.
-            if ( isNumber( className ) )
-            {
-                return new SequenceRange( Integer.parseInt( className ) );
-            }
-            
-            return (SequencePreallocator) Class.forName( className ).newInstance();
-        }
-        catch (ClassNotFoundException e) { throw missingAllocator( propertyName, className, e ); }
-        catch (ClassCastException e) { throw missingAllocator( propertyName, className, e ); }
-        catch (InstantiationException e) { throw missingAllocator( propertyName, className, e ); }
-        catch (IllegalAccessException e) { throw missingAllocator( propertyName, className, e ); }
-        catch (NumberFormatException e) { throw missingAllocator( propertyName, className, e ); }
-    }
-    private StandardException   missingAllocator( String propertyName, String className, Exception e )
-    {
-        return StandardException.newException( SQLState.LANG_UNKNOWN_SEQUENCE_PREALLOCATOR, e, propertyName, className );
-    }
-    private boolean isNumber( String text )
-    {
-        int length = text.length();
-
-        for ( int i = 0; i < length; i++ )
-        {
-            if ( !Character.isDigit( text.charAt( i ) ) ) { return false; }
-        }
-
-        return true;
-    }
-    
     /** Get the time we wait for a lock, in milliseconds--overridden by unit tests */
     protected int getLockTimeout()
     {
@@ -555,70 +500,10 @@ private StandardException unimplementedFeature()
 
     ///////////////////////////////////////////////////////////////////////////////////
     //
-    // NESTED CLASSES
+    // INNER CLASSES
     //
     ///////////////////////////////////////////////////////////////////////////////////
 
-    /**
-     * <p>
-     * Specific implementation of SequenceUpdater for the sequences managed by
-     * SYSCOLUMNS.
-     * </p>
-     */
-    public static final class SyscolumnsUpdater extends SequenceUpdater
-    {
-        private RowLocation _sequenceRowLocation;
-
-        public SyscolumnsUpdater() { super(); }
-        public SyscolumnsUpdater( DataDictionaryImpl dd ) { super( dd ); }
-    
-        //
-        // SequenceUpdater BEHAVIOR
-        //
-
-        protected SequenceGenerator createSequenceGenerator( TransactionController readOnlyTC )
-            throws StandardException
-        {
-            RowLocation[] rowLocation = new RowLocation[ 1 ];
-            SequenceDescriptor[] sequenceDescriptor = new SequenceDescriptor[ 1 ];
-            
-            _dd.computeIdentityRowLocation( readOnlyTC, _uuidString, rowLocation, sequenceDescriptor );
-            
-            _sequenceRowLocation = rowLocation[ 0 ];
-            
-            SequenceDescriptor isd = sequenceDescriptor[ 0 ];
-            
-            return new SequenceGenerator
-                (
-                 isd.getCurrentValue(),
-                 isd.canCycle(),
-                 isd.getIncrement(),
-                 isd.getMaximumValue(),
-                 isd.getMinimumValue(),
-                 isd.getStartValue(),
-                 isd.getSchemaDescriptor().getSchemaName(),
-                 isd.getSequenceName(),
-                 makePreallocator( readOnlyTC )
-                 );
-        }
-
-        protected boolean updateCurrentValueOnDisk( TransactionController tc, Long oldValue, Long newValue, boolean wait ) throws StandardException
-        {
-            return _dd.updateCurrentIdentityValue( tc, _sequenceRowLocation, wait, oldValue, newValue );
-        }
-
-        /**
-         * Wrap the "too much contention" exception in a "lock timeout" exception in
-         * order to preserve the old error behavior of identity columns. See DERBY-5426.
-         */
-        protected   StandardException   tooMuchContentionException()
-        {
-            StandardException   tooMuchContention = super.tooMuchContentionException();
-
-            return StandardException.newException( SQLState.LOCK_TIMEOUT, tooMuchContention );
-        }
-    }
-
     /**
      * <p>
      * Specific implementation of SequenceUpdater for the sequences managed by
@@ -656,9 +541,7 @@ protected SequenceGenerator createSequenceGenerator( TransactionController readO
                  isd.getMaximumValue(),
                  isd.getMinimumValue(),
                  isd.getStartValue(),
-                 isd.getSchemaDescriptor().getSchemaName(),
-                 isd.getSequenceName(),
-                 makePreallocator( readOnlyTC )
+                 isd.getSequenceName()
                  );
         }
 
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/CreateSequenceNode.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/CreateSequenceNode.java
index d9147ccb..752a650d 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/CreateSequenceNode.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/CreateSequenceNode.java
@@ -26,7 +26,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.sql.compile.CompilerContext;
 import org.apache.derby.iapi.sql.execute.ConstantAction;
 import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
-import org.apache.derby.iapi.sql.dictionary.SequenceDescriptor;
 import org.apache.derby.iapi.types.DataTypeDescriptor;
 import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.types.TypeId;
@@ -84,9 +83,17 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
         _stepValue = (stepValue != null ? (Long) stepValue : new Long(1));
 
-        Long[]  minMax = SequenceDescriptor.computeMinMax( _dataType, minValue, maxValue );
-        _minValue = minMax[ SequenceDescriptor.MIN_VALUE ];
-        _maxValue = minMax[ SequenceDescriptor.MAX_VALUE ];
+        if (_dataType.getTypeId().equals(TypeId.SMALLINT_ID)) {
+            _minValue = (minValue != null ? (Long) minValue : new Long(Short.MIN_VALUE));
+            _maxValue = (maxValue != null ? (Long) maxValue : new Long(Short.MAX_VALUE));
+        } else if (_dataType.getTypeId().equals(TypeId.INTEGER_ID)) {
+            _minValue = (minValue != null ? (Long) minValue : new Long(Integer.MIN_VALUE));
+            _maxValue = (maxValue != null ? (Long) maxValue : new Long(Integer.MAX_VALUE));
+        } else {
+            // Could only be BIGINT
+            _minValue = (minValue != null ? (Long) minValue : new Long(Long.MIN_VALUE));
+            _maxValue = (maxValue != null ? (Long) maxValue : new Long(Long.MAX_VALUE));
+        }
 
         if (initialValue != null) {
             _initialValue = (Long) initialValue;
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/NextSequenceNode.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/NextSequenceNode.java
index 95471368..b1deccbb 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/NextSequenceNode.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/NextSequenceNode.java
@@ -28,7 +28,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.services.compiler.LocalField;
 import org.apache.derby.iapi.sql.compile.CompilerContext;
 import org.apache.derby.iapi.services.classfile.VMOpcode;
-import org.apache.derby.iapi.sql.dictionary.DataDictionary;
 import org.apache.derby.iapi.sql.dictionary.SequenceDescriptor;
 import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
 
@@ -134,7 +133,6 @@ public ValueNode bindExpression(
         int dataTypeFormatID = sequenceDescriptor.getDataType().getNull().getTypeFormatId();
         
 		mb.pushThis();
-		mb.push( DataDictionary.SYSSEQUENCES_CATALOG_NUM );
 		mb.push( sequenceUUIDstring );
 		mb.push( dataTypeFormatID );
 		mb.callMethod
@@ -143,7 +141,7 @@ public ValueNode bindExpression(
              ClassName.BaseActivation,
              "getCurrentValueAndAdvance",
              ClassName.NumberDataValue,
-             3
+             2
              );
     }
 
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/BaseActivation.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/BaseActivation.java
index 7cd38800..a9996c29 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/BaseActivation.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/BaseActivation.java
@@ -670,23 +670,22 @@ public CursorResultSet getTargetResultSet() {
 	}
 
 	/**
-	 * Called by generated code to get the next number in an identity or sequence generator
-     * and advance the generator. Raises an exception if the generator was declared
+	 * Called by generated code to get the next number in an ANSI/ISO sequence
+     * and advance the sequence. Raises an exception if the sequence was declared
      * NO CYCLE and its range is exhausted.
 	 *
-     * @param catalogNumber SYSCOLUMNS_CATALOG_NUM or SYSSEQUENCES_CATALOG_NUM, depending on the kind of generator
-     * @param uuidString The string value of the generator's uuid (table uuid for identity generators and sequence uuid for sequence generators)
+     * @param sequenceUUIDstring The string value of the sequence's UUID
      * @param typeFormatID The format id of the data type to be returned. E.g., StoredFormatIds.SQL_INTEGER_ID.
      *
 	 * @return The next number in the sequence
 	 */
 	protected NumberDataValue getCurrentValueAndAdvance
-        ( int catalogNumber, String uuidString, int typeFormatID )
+        ( String sequenceUUIDstring, int typeFormatID )
 	       throws StandardException
 	{
         NumberDataValue ndv = (NumberDataValue) getDataValueFactory().getNull( typeFormatID, StringDataValue.COLLATION_TYPE_UCS_BASIC );
 
-        lcc.getDataDictionary().getCurrentValueAndAdvance( catalogNumber, uuidString, ndv );
+        lcc.getDataDictionary().getCurrentValueAndAdvance( sequenceUUIDstring, ndv );
 
         return ndv;
 	}
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/InsertConstantAction.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/InsertConstantAction.java
index 13834bee..150240cf 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/InsertConstantAction.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/InsertConstantAction.java
@@ -250,6 +250,24 @@ public void writeExternal( ObjectOutput out )
 	 */
 	public long   getAutoincIncrement(int i) { return autoincIncrement[i]; }
 
+	/**
+	 * Does the target table has autoincrement columns.
+	 *
+	 * @return 	True if the table has ai columns
+	 */
+	public boolean hasAutoincrement()
+	{
+		return (autoincRowLocation != null);
+	}
+
+	/**
+	 * gets the row location 
+	 */
+	public RowLocation[] getAutoincRowLocation()
+	{
+		return autoincRowLocation;
+	}
+	
 	/**
 	 * Get the formatID which corresponds to this class.
 	 *
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java
index 48223468..1da60292 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/InsertResultSet.java
@@ -349,20 +349,21 @@ private	void	evaluateCheckConstraints()
 		// Is this a bulkInsert or regular insert?
 		String insertMode = constants.getProperty("insertMode");
 
-		if ( hasAutoincrement() )
+                RowLocation[] rla;
+
+		if ((rla = constants.getAutoincRowLocation()) != null)
 		{
-            int cacheLength = resultDescription.getColumnCount();
-			aiCache = new NumberDataValue[ cacheLength ];
-			for (int i = 0; i < cacheLength; i++)
+			aiCache = 
+				new NumberDataValue[rla.length];
+			for (int i = 0; i < resultDescription.getColumnCount(); i++)
 			{
+				if (rla[i] == null)
+					continue;
 				ResultColumnDescriptor rcd = 
 					resultDescription.getColumnDescriptor(i + 1);
-                if ( rcd.getType().getTypeId().isNumericTypeId() )
-                {
                     aiCache[i] = (NumberDataValue)rcd.getType().getNull();
                 }
 			}
-		}
 
 		if (insertMode != null)
 		{
@@ -392,18 +393,6 @@ else if (StringUtil.SQLEqualsIgnoreCase(insertMode,"REPLACE"))
 	}
 
     /**
-     * Return true if the table has an autoincrement column.
-     */
-    private boolean hasAutoincrement()  throws StandardException
-    {
-        // Global temporary tables don't have table descriptors but they
-        // don't have identity columns either
-        TableDescriptor tabdesc = getTableDescriptor();
-        if ( tabdesc == null ) { return false; }
-        else { return tabdesc.tableHasAutoincrement(); }
-    }
-	
-	/**
 		@exception StandardException Standard Derby error policy
 	*/
 	public void open() throws StandardException
@@ -593,28 +582,6 @@ private void verifyAutoGeneratedColumnsIndexes(int[] columnIndexes)
 	}
 
     /**
-     * Get the table descriptor if it hasn't already been looked up.
-     */
-    private TableDescriptor getTableDescriptor()
-        throws StandardException
-    {
-        if ( td == null ) { td = getDataDictionary().getTableDescriptor(constants.targetUUID); }
-
-        return td;
-    }
-    
-    /**
-     * Get the data dictionary if it hasn't already been looked up.
-     */
-    private DataDictionary getDataDictionary()
-        throws StandardException
-    {
-        if ( dd == null ) { dd = lcc.getDataDictionary(); }
-
-        return dd;
-    }
-    
-	/**
 	 * If user didn't provide columns list for auto-generated columns, then only include
 	 * columns with auto-generated values in the resultset. Those columns would be ones
 	 * with default value defined.
@@ -798,9 +765,9 @@ public ResultSet getAutoGeneratedKeysResultset()
 				}
 				else
 				{
-                    dvd = (NumberDataValue) aiCache[ index ].getNewNull();
-                    dd.getCurrentValueAndAdvance
-                        ( DataDictionary.SYSCOLUMNS_CATALOG_NUM, getTableDescriptor().getUUID().toString(), dvd );
+					dvd = dd.getSetAutoincrementValue(
+						    constants.autoincRowLocation[index],
+							tc, false, aiCache[index], true);
 					startValue = dvd.getLong();
 				}
 				lcc.autoincrementCreateCounter(td.getSchemaName(),
@@ -819,12 +786,77 @@ public ResultSet getAutoGeneratedKeysResultset()
 
 		else
 		{
-			NumberDataValue newValue = aiCache[ index ];
+			NumberDataValue newValue;
+			TransactionController nestedTC = null, tcToUse = tc;
 
-            dd.getCurrentValueAndAdvance
-                ( DataDictionary.SYSCOLUMNS_CATALOG_NUM, getTableDescriptor().getUUID().toString(), newValue );
+			try
+			{
+				nestedTC = tc.startNestedUserTransaction(false);
+				tcToUse = nestedTC;
+			}
 
-			if (setIdentity) { identityVal = newValue.getLong(); }
+			catch (StandardException se)
+			{
+				// If I cannot start a Nested User Transaction use the parent
+				// transaction to do all the work.
+				tcToUse = tc;
+			}
+
+			try 
+			{
+				/* If tcToUse == tc, then we are using parent xaction-- this
+				   can happen if for some reason we couldn't start a nested
+				   transaction
+				*/
+				newValue = dd.getSetAutoincrementValue(
+						   constants.autoincRowLocation[index],
+						   tcToUse, true, aiCache[index], (tcToUse == tc));
+			}
+
+			catch (StandardException se)
+			{
+				if (tcToUse == tc)
+				{
+					/* we've using the parent xaction and we've timed out; just
+					   throw an error and exit.
+					*/
+					throw se;
+				}
+
+				if (se.getMessageId().equals(SQLState.LOCK_TIMEOUT))
+				{
+					// if we couldn't do this with a nested xaction, retry with
+					// parent-- we need to wait this time!
+					newValue = dd.getSetAutoincrementValue(
+									constants.autoincRowLocation[index],
+									tc, true, aiCache[index], true);
+				}
+				else if (se.getMessageId().equals(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE))
+				{
+					// if we got an overflow error, throw a more meaningful
+					// error message
+					throw StandardException.newException(
+												 SQLState.LANG_AI_OVERFLOW,
+												 se,
+												 constants.getTableName(),
+												 constants.getColumnName(index));
+				}
+				else throw se;
+			}
+			finally 
+			{
+				// no matter what, commit the nested transaction; if something
+				// bad happened in the child xaction lets not abort the parent
+				// here.
+				if (nestedTC != null)
+				{
+					nestedTC.commit();
+					nestedTC.destroy();
+				}
+			}
+			aiCache[index] = newValue;
+			if (setIdentity)
+				identityVal = newValue.getLong();
 		}
 
 		return aiCache[index];
@@ -857,7 +889,7 @@ else if (sourceResultSet instanceof NormalizeResultSet)
 	private void normalInsertCore(LanguageConnectionContext lcc, boolean firstExecute)
 		throws StandardException
 	{
-		boolean setUserIdentity = hasAutoincrement() && isSingleRowResultSet();
+		boolean setUserIdentity = constants.hasAutoincrement() && isSingleRowResultSet();
 		boolean	firstDeferredRow = true;
 		ExecRow	deferredRowBuffer = null;
                 long user_autoinc=0;
diff --git a/db/derby/code/branches/10.8/java/shared/org/apache/derby/shared/common/reference/SQLState.java b/db/derby/code/branches/10.8/java/shared/org/apache/derby/shared/common/reference/SQLState.java
index 1dd6a633..f013ec6b 100644
--- a/db/derby/code/branches/10.8/java/shared/org/apache/derby/shared/common/reference/SQLState.java
+++ b/db/derby/code/branches/10.8/java/shared/org/apache/derby/shared/common/reference/SQLState.java
@@ -721,8 +721,8 @@ The message identifier (ie. the value that matches a field in this class)
 	String LANG_INVALID_TRIM_SET                                       = "22027";
     String LANG_STRING_TOO_LONG                                        = "22028";
 	String LANG_ESCAPE_IS_NULL                                  	   = "22501";
-	String LANG_INVALID_ROW_COUNT_FIRST                                = "2201W";
 	String LANG_INVALID_ROW_COUNT_OFFSET                               = "2201X";
+	String LANG_INVALID_ROW_COUNT_FIRST                                = "2201W";
 	String LANG_ROW_COUNT_OFFSET_FIRST_IS_NULL                         = "2201Z";
 
 	/*
@@ -1372,7 +1372,6 @@ The message identifier (ie. the value that matches a field in this class)
 	String LANG_NULL_DATA_IN_NON_NULL_COLUMN               	   	   	   = "X0Y80.S";
     String LANG_IGNORE_MISSING_INDEX_ROW_DURING_DELETE                 = "X0Y83.S";
     String LANG_TOO_MUCH_CONTENTION_ON_SEQUENCE                 = "X0Y84.S";
-	String LANG_UNKNOWN_SEQUENCE_PREALLOCATOR                                = "X0Y85.S";
 	String LANG_CANT_FLUSH_PREALLOCATOR                                = "X0Y86.S";
 
 
diff --git a/db/derby/code/branches/10.8/java/storeless/org/apache/derby/impl/storeless/EmptyDictionary.java b/db/derby/code/branches/10.8/java/storeless/org/apache/derby/impl/storeless/EmptyDictionary.java
index c3914f1d..4ab91930 100644
--- a/db/derby/code/branches/10.8/java/storeless/org/apache/derby/impl/storeless/EmptyDictionary.java
+++ b/db/derby/code/branches/10.8/java/storeless/org/apache/derby/impl/storeless/EmptyDictionary.java
@@ -1,6 +1,6 @@
 /*
 
-   Derby - Class org.apache.derby.impl.storeless.EmptyDictionary
+   Derby - Class org.apache.impl.storeless.EmptyDictionary
 
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
@@ -79,11 +79,6 @@ public void clearCaches() throws StandardException {
 
 	}
 
-	public void clearSequenceCaches() throws StandardException {
-		// TODO Auto-generated method stub
-
-	}
-
 	public int startReading(LanguageConnectionContext lcc)
 			throws StandardException {
 		// TODO Auto-generated method stub
@@ -707,7 +702,7 @@ public void dropFileInfoDescriptor(FileInfoDescriptor fid)
 	}
 
     public void getCurrentValueAndAdvance
-        ( int catalogNumber, String uuidString, NumberDataValue returnValue )
+        ( String sequenceUUIDstring, NumberDataValue returnValue )
         throws StandardException
     {
 		// TODO Auto-generated method stub
@@ -719,6 +714,13 @@ public RowLocation getRowLocationTemplate(LanguageConnectionContext lcc,
 		return null;
 	}
 
+	public NumberDataValue getSetAutoincrementValue(RowLocation rl,
+			TransactionController tc, boolean doUpdate,
+			NumberDataValue newValue, boolean wait) throws StandardException {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
 	public void setAutoincrementValue(TransactionController tc, UUID tableUUID,
 			String columnName, long aiValue, boolean incrementNeeded)
 			throws StandardException {
diff --git a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AlterTableTest.java b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AlterTableTest.java
index 3311f293..9d42e5a1 100644
--- a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AlterTableTest.java
+++ b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AlterTableTest.java
@@ -3204,7 +3204,7 @@ public void testJira3175()
                 "where c.referenceid = t.tableid and t.tablename='D3175'");
         JDBC.assertUnorderedResultSet(rs, new String[][]{
                     {"X", "1", "VARCHAR(12)", null, null, null, null, "D3175", "T", "R"},
-                    {"ID", "2", "INTEGER NOT NULL", "GENERATED_BY_DEFAULT", "22", "1", "1", "D3175", "T", "R"}
+                    {"ID", "2", "INTEGER NOT NULL", "GENERATED_BY_DEFAULT", "3", "1", "1", "D3175", "T", "R"}
                 });
     }
 
diff --git a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AutoIncrementTest.java b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AutoIncrementTest.java
index a70b1558..617960b9 100644
--- a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AutoIncrementTest.java
+++ b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/AutoIncrementTest.java
@@ -33,13 +33,8 @@
 import org.apache.derbyTesting.junit.BaseJDBCTestCase;
 import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
 import org.apache.derbyTesting.junit.JDBC;
-import org.apache.derbyTesting.junit.SupportFilesSetup;
 
 public class AutoIncrementTest extends BaseJDBCTestCase {
-
-    private static  final   String  SEQUENCE_OVERFLOW = "2200H";
-    private static  final   String  IMPORT_FILE_NAME = "t_4437_2.dat";
-    
 	public AutoIncrementTest(String name)
 	{
 		super (name);
@@ -226,7 +221,7 @@ public void testsimpleincrement() throws Exception
 		String[][]expectedRows=new String[][]{{"0","0"},{"1","2"},{"2","4"},{"33","6"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 		rs = s.executeQuery("select COLUMNNAME, AUTOINCREMENTVALUE, AUTOINCREMENTSTART, AUTOINCREMENTINC from sys.syscolumns where COLUMNNAME = 'AIS'");
-		expectedRows=new String[][]{{"AIS","40","0","2"}};
+		expectedRows=new String[][]{{"AIS","8","0","2"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 
 	}
@@ -383,7 +378,7 @@ public void testSchema() throws Exception
 		expectedRows=new String[][]{{"1","1"},{"2","2"},{"3","3"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 		rs=s.executeQuery("select b.tablename, a.autoincrementvalue, a.autoincrementstart, a.autoincrementinc from sys.syscolumns a, sys.systables b where a.referenceid=b.tableid and a.columnname ='S1' and b.tablename = 'TAB1'");
-		expectedRows=new String[][]{{"TAB1","21","1","1"}};
+		expectedRows=new String[][]{{"TAB1","4","1","1"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 		s.executeUpdate("create table tab2 (lvl int, s1  bigint generated always as identity)");
 		s.executeUpdate("create trigger tab1_after2 after insert on tab3 referencing new as newrow for each row insert into tab2 (lvl) values 1,2,3");
@@ -495,7 +490,7 @@ public void testsyslocks()throws Exception
 		JDBC.assertFullResultSet(rs,expectedRows);
 		s.execute("insert into lockt1 (x) values (3)");
 		rs=s.executeQuery("select * from lock_table order by tabname, type desc, mode, cnt");
-		expectedRows=new String[][]{{"APP     ","UserTran","TABLE   ","1  ","IX","LOCKT1      ","GRANT","ACTIVE"},{"APP     ","UserTran","ROW     ","1  ","X","LOCKT1      ","GRANT","ACTIVE"},{"APP     ","UserTran","TABLE   ","1  ","S","SYSCOLUMNS  ","GRANT","ACTIVE"}};
+		expectedRows=new String[][]{{"APP     ","UserTran","TABLE   ","1  ","IX","LOCKT1      ","GRANT","ACTIVE"},{"APP     ","UserTran","ROW     ","1  ","X","LOCKT1      ","GRANT","ACTIVE"},{"APP     ","UserTran","TABLE   ","1  ","IX","SYSCOLUMNS  ","GRANT","ACTIVE"},{"APP     ","UserTran","TABLE   ","1  ","S","SYSCOLUMNS  ","GRANT","ACTIVE"},{"APP     ","UserTran","ROW     ","2  ","X","SYSCOLUMNS  ","GRANT","ACTIVE"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 		commit();
 		
@@ -601,10 +596,10 @@ public  void testOverflow()throws Exception
 		ResultSet rs;
 		Statement pst=createStatement();
 		Statement s=createStatement();
-		assertStatementError(SEQUENCE_OVERFLOW, pst,"insert into ai_over1 (x) values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15),(16),(17),(18),(19)");
-		assertStatementError(SEQUENCE_OVERFLOW, pst,"insert into ai_over1 (x) values (1)");		
+		assertStatementError("22003", pst,"insert into ai_over1 (x) values (1),(2),(3),(4),(5),(6),(7),(8),(9),(10),(11),(12),(13),(14),(15),(16),(17),(18),(19)");
+		assertStatementError("22003", pst,"insert into ai_over1 (x) values (1)");		
 		s.executeUpdate("insert into ai_over2 (x) values (1),(2),(3),(4),(5),(6),(7),(8)");
-		assertStatementError(SEQUENCE_OVERFLOW, pst,"insert into ai_over2 (x) values (9),(10)");
+		assertStatementError("22003", pst,"insert into ai_over2 (x) values (9),(10)");
 		String[][]expectedRows=new String[][]{{"1","-32760"},{"2","-32761"},{"3","-32762"},{"4","-32763"},{"5","-32764"},{"6","-32765"},{"7","-32766"},{"8","-32767"}};
 		rs=s.executeQuery("select * from ai_over2");
 		JDBC.assertFullResultSet(rs,expectedRows);		
@@ -613,12 +608,12 @@ public  void testOverflow()throws Exception
 		rs=s.executeQuery("select * from ai_over3");
 		expectedRows=new String[][]{{"1","2147483646"},{"2","2147483647"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
-		assertStatementError(SEQUENCE_OVERFLOW, pst,"insert into ai_over3 (x) select x from ai_over3");			
+		assertStatementError("22003", pst,"insert into ai_over3 (x) select x from ai_over3");			
 		//bigint overflow check		
-		s.executeUpdate("insert into ai_over4 (x) values (1),(2),(3)");
-		assertStatementError(SEQUENCE_OVERFLOW, pst,"insert into ai_over4 (x) values (4)");
+		s.executeUpdate("insert into ai_over4 (x) values (1),(2)");
+		assertStatementError("22003", pst,"insert into ai_over4 (x) values (3)");
 		rs=s.executeQuery("select * from ai_over4");
-		expectedRows=new String[][]{{"1","9223372036854775805"},{"2","9223372036854775806"},{"3","9223372036854775807"}};
+		expectedRows=new String[][]{{"1","9223372036854775805"},{"2","9223372036854775806"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 
 	}
@@ -944,7 +939,7 @@ public void testrestart()throws Exception
 		expectedRows=new String[][]{{"2","2"},{"2","9999"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 		rs=s.executeQuery("select COLUMNNAME, AUTOINCREMENTVALUE, AUTOINCREMENTSTART, AUTOINCREMENTINC from sys.syscolumns where COLUMNNAME = 'REC11'");
-		expectedRows=new String[][]{{"REC11","42","2","2"}};
+		expectedRows=new String[][]{{"REC11","4","2","2"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 		assertStatementError("42837",s,"alter table restartt1 alter column c12 RESTART WITH 2");
 		assertStatementError("42X49",s,"alter table restartt1 alter column rec11 RESTART WITH 2.20");
@@ -979,7 +974,7 @@ public void testlock()throws Exception
 		assertStatementError("23505",s,"insert into t1lock(c12) values(3)");
 		rs=s.executeQuery("select COLUMNNAME, AUTOINCREMENTVALUE, AUTOINCREMENTSTART, AUTOINCREMENTINC from sys.syscolumns where COLUMNNAME = 'LOCKC11'");
 		//Utilities.showResultSet(rs);
-		expectedRows=new String[][]{{"LOCKC11","21","1","1"}};
+		expectedRows=new String[][]{{"LOCKC11","2","1","1"}};
 		JDBC.assertFullResultSet(rs,expectedRows);
 
 		rs=s.executeQuery("select * from t1lock");
@@ -1087,226 +1082,8 @@ public void testDerby2902()throws Exception
 
 	}
 
-    /**
-     * <p>
-     * Test that alter table interacts well with the sequence-generator-based identity generators.
-     * </p>
-     */
-    public  void    test_4437_01_alterTable()   throws Exception
-    {
-		Statement s = createStatement();
-        String[][] expectedResults;
-        
-		s.execute("create table t_4437_1( a int, b int generated always as identity )");
-		s.execute("insert into t_4437_1( a ) values (100), (101), (102), (103), (104), (105)");
-        expectedResults = new String[][]
-        {
-            { "100",        "1", },
-            { "101",        "2", },
-            { "102",        "3", },
-            { "103",        "4", },
-            { "104",        "5", },
-            { "105",        "6", },
-        };
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_1 order by a" ), expectedResults );
-
-		s.execute("alter table t_4437_1 alter column b restart with 22");
-		s.execute("insert into t_4437_1( a ) values (110), (111), (112), (113), (114), (115)");
-        expectedResults = addResults
-            (
-             expectedResults,
-             new String[][]
-             {
-                 { "110",        "22", },
-                 { "111",        "23", },
-                 { "112",        "24", },
-                 { "113",        "25", },
-                 { "114",        "26", },
-                 { "115",        "27", },
-             }
-             );
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_1 order by a" ), expectedResults );
-
-		s.execute("alter table t_4437_1 alter column b set increment by 3");
-		s.execute("insert into t_4437_1( a ) values (120), (121), (122), (123), (124)");
-        expectedResults = addResults
-            (
-             expectedResults,
-             new String[][]
-             {
-                 { "120",        "30", },
-                 { "121",        "33", },
-                 { "122",        "36", },
-                 { "123",        "39", },
-                 { "124",        "42", },
-             }
-             );
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_1 order by a" ), expectedResults );
-
-		s.execute("alter table t_4437_1 alter column b set increment by 4");
-		s.execute("insert into t_4437_1( a ) values (130), (131), (132), (133), (134), (135)");
-        expectedResults = addResults
-            (
-             expectedResults,
-             new String[][]
-             {
-                 { "130",        "46", },
-                 { "131",        "50", },
-                 { "132",        "54", },
-                 { "133",        "58", },
-                 { "134",        "62", },
-                 { "135",        "66", },
-             }
-             );
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_1 order by a" ), expectedResults );
-
-        s.execute( "drop table t_4437_1" );
-    }
-    private String[][]  addResults( String[][] original, String[][] extras )
-    {
-        int originalLength = original.length;
-        int extrasLength = extras.length;
-        String[][]  result = new String[ originalLength + extrasLength ][];
-
-        int idx = 0;
-        for ( int i = 0; i < originalLength; i++ ) { result[ idx++ ] = original[ i ]; }
-        for ( int i = 0; i < extrasLength; i++ ) { result[ idx++ ] = extras[ i ]; }
-
-        return result;
-    }
-	
-    /**
-     * <p>
-     * Test that bulk import interacts well with the sequence-generator-based identity generators.
-     * </p>
-     */
-    public  void    test_4437_02_bulkImport()   throws Exception
-    {
-		Statement s = createStatement();
-        String[][] expectedResults;
-
-		s.execute( "create table t_4437_2( a int, b int generated always as identity (start with -10, increment by -3) )" );
-		s.execute( "insert into t_4437_2( a ) values (110), (111), (112), (113), (114), (115)" );
-        expectedResults = new String[][]
-        {
-            { "110",        "-10", },
-            { "111",        "-13", },
-            { "112",        "-16", },
-            { "113",        "-19", },
-            { "114",        "-22", },
-            { "115",        "-25", },
-        };
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_2 order by a" ), expectedResults );
-
-        // import running in replace mode resets the sequence counter
-		s.execute( "call syscs_util.syscs_import_data( null, 'T_4437_2', 'A', null, 'extin/" + IMPORT_FILE_NAME + "', null, null, null, 1 )" );
-        expectedResults = new String[][]
-        {
-            { "100",        "-10", },
-            { "101",        "-13", },
-            { "102",        "-16", },
-            { "103",        "-19", },
-            { "104",        "-22", },
-            { "105",        "-25", },
-        };
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_2 order by a" ), expectedResults );
-
-        // truncate does not reset the counter
-		s.execute( "truncate table t_4437_2" );
-		s.execute( "insert into t_4437_2( a ) values (110), (111), (112), (113), (114), (115)" );
-        expectedResults = new String[][]
-        {
-            { "110",        "-28", },
-            { "111",        "-31", },
-            { "112",        "-34", },
-            { "113",        "-37", },
-            { "114",        "-40", },
-            { "115",        "-43", },
-        };
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_2 order by a" ), expectedResults );
-
-        // delete does not reset the counter either
-		s.execute( "delete from t_4437_2" );
-		s.execute( "insert into t_4437_2( a ) values (110), (111), (112), (113), (114), (115)" );
-        expectedResults = new String[][]
-        {
-            { "110",        "-46", },
-            { "111",        "-49", },
-            { "112",        "-52", },
-            { "113",        "-55", },
-            { "114",        "-58", },
-            { "115",        "-61", },
-        };
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_2 order by a" ), expectedResults );
-
-        // import running in insert mode does not reset the sequence counter
-		s.execute( "call syscs_util.syscs_import_data( null, 'T_4437_2', 'A', null, 'extin/" + IMPORT_FILE_NAME + "', null, null, null, 0 )" );
-        expectedResults = new String[][]
-        {
-            { "100",        "-64", },
-            { "101",        "-67", },
-            { "102",        "-70", },
-            { "103",        "-73", },
-            { "104",        "-76", },
-            { "105",        "-79", },
-            { "110",        "-46", },
-            { "111",        "-49", },
-            { "112",        "-52", },
-            { "113",        "-55", },
-            { "114",        "-58", },
-            { "115",        "-61", },
-        };
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_2 order by a" ), expectedResults );
-
-        s.execute( "drop table t_4437_2" );
-    }
-        
-    /**
-     * <p>
-     * Test that deferred inserts work well with the sequence-generator-based identity generators.
-     * </p>
-     */
-    public  void    test_4437_03_deferredInsert()   throws Exception
-    {
-		Statement s = createStatement();
-        String[][] expectedResults;
-
-		s.execute( "create table t_4437_3( a int, b smallint generated always as identity (start with 9990, increment by -10) )" );
-		s.execute( "insert into t_4437_3( a ) values (100), (101), (102), (103), (104), (105)" );
-        expectedResults = new String[][]
-        {
-            { "100",        "9990", },
-            { "101",        "9980", },
-            { "102",        "9970", },
-            { "103",        "9960", },
-            { "104",        "9950", },
-            { "105",        "9940", },
-        };
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_3 order by a" ), expectedResults );
-
-        // deferred inserts should continue the sequence where it left off
-		s.execute( "insert into t_4437_3( a ) select a + 10 from ( select a from t_4437_3 order by a ) s" );
-        expectedResults = addResults
-            (
-             expectedResults,
-             new String[][]
-             {
-                 { "110",        "9930", },
-                 { "111",        "9920", },
-                 { "112",        "9910", },
-                 { "113",        "9900", },
-                 { "114",        "9890", },
-                 { "115",        "9880", },
-             }
-             );
-		JDBC.assertFullResultSet( s.executeQuery( "select * from t_4437_3 order by a" ), expectedResults );
-
-        s.execute( "drop table t_4437_3" );
-    }
-
-	public static Test suite()
-    {
-		Test    cleanDatabaseSuite = new CleanDatabaseTestSetup(
+	public static Test suite() {
+		return new CleanDatabaseTestSetup(
 				new TestSuite(AutoIncrementTest.class, "AutoIncrementTest")) {
 			protected void decorateSQL(Statement s)
 			throws SQLException
@@ -1314,16 +1091,5 @@ protected void decorateSQL(Statement s)
 				createSchemaObjects(s);
 			}
 		};
-        
-        //
-        // Copies the data file to a location which can be read.
-        //
-        Test        result = new SupportFilesSetup
-            (
-             cleanDatabaseSuite,
-             new String [] { "functionTests/tests/lang/" + IMPORT_FILE_NAME }
-             );
-
-        return result;
 	}
 }
diff --git a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/SequenceGeneratorTest.java b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/SequenceGeneratorTest.java
index c9acee23..7e6a380a 100644
--- a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/SequenceGeneratorTest.java
+++ b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/SequenceGeneratorTest.java
@@ -41,9 +41,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derbyTesting.junit.JDBC;
 
 import org.apache.derby.impl.sql.catalog.SequenceGenerator;
-import org.apache.derby.impl.sql.catalog.SequenceRange;
 import org.apache.derby.impl.sql.catalog.SequenceUpdater;
-import org.apache.derby.catalog.SequencePreallocator;
 import org.apache.derby.iapi.types.SQLLongint;
 import org.apache.derby.iapi.store.access.TransactionController;
 
@@ -61,16 +59,13 @@ Licensed to the Apache Software Foundation (ASF) under one or more
     ///////////////////////////////////////////////////////////////////////////////////
 
     // number of pre-allocated values in a sequence generator
-    private static final long ALLOCATION_COUNT = 20L;
-    private static final int TWEAKED_ALLOCATION_COUNT = 7;
+    private static final long ALLOCATION_COUNT = 5L;
 
     private static  final   String      TEST_DBO = "TEST_DBO";
     private static  final   String      RUTH = "RUTH";
     private static  final   String      ALICE = "ALICE";
     private static  final   String[]    LEGAL_USERS = { TEST_DBO, ALICE, RUTH  };
 
-    private static  final   String      MISSING_ALLOCATOR = "X0Y85";
-
     ///////////////////////////////////////////////////////////////////////////////////
     //
     // STATE
@@ -190,16 +185,12 @@ public void test_02_boundary() throws Exception
 
         assertEquals( -2147483648L, updater.getValueOnDisk().longValue() );
 
-        long        initialValue = (long) Integer.MIN_VALUE;
-        long        expectedValueOnDisk = initialValue + ALLOCATION_COUNT;
-
-        for ( long i = 0; i < ALLOCATION_COUNT; i++ )
-        {
-            vetBumping( updater, initialValue + i, expectedValueOnDisk );
-        }
-        expectedValueOnDisk += ALLOCATION_COUNT;
-
-        vetBumping( updater, initialValue + ALLOCATION_COUNT, expectedValueOnDisk );
+        vetBumping( updater, -2147483648L, -2147483643L );
+        vetBumping( updater, -2147483647L, -2147483643L );
+        vetBumping( updater, -2147483646L, -2147483643L );
+        vetBumping( updater, -2147483645L, -2147483643L );
+        vetBumping( updater, -2147483644L, -2147483643L );
+        vetBumping( updater, -2147483643L, -2147483638L );
 
         vetBoundaries( Short.MAX_VALUE, Short.MIN_VALUE );
         vetBoundaries( Integer.MAX_VALUE, Integer.MIN_VALUE );
@@ -342,7 +333,7 @@ private void vetBumping( T_SequenceUpdater updater, long expectedValue, long exp
         long actualValueOnDisk = updater.getValueOnDisk().longValue();
         
         println( "Expected value = " + expectedValue + " vs actual value = " + actualValue );
-        println( "    Expected value on disk = " + expectedValueOnDisk + " vs actual value on disk = " + actualValueOnDisk );
+        println( "    Expected value on disk = " + expectedValue + " vs actual value on disk = " + actualValueOnDisk );
         
         assertEquals( expectedValue, actualValue );
         assertEquals( expectedValueOnDisk, actualValueOnDisk );
@@ -426,11 +417,13 @@ public void test_04_reboot() throws Exception
 
         getTestConfiguration().shutdownDatabase();
         conn = openUserConnection( TEST_DBO );
+        seq_04_value = (int) seq_04_upperBound;
         seq_04_upperBound = seq_04_value + ALLOCATION_COUNT;
         vetBumping( conn, TEST_DBO, "SEQ_04", seq_04_value++, seq_04_upperBound );
 
         getTestConfiguration().shutdownDatabase();
         conn = openUserConnection( TEST_DBO );
+        seq_04_value = (int) seq_04_upperBound;
         seq_04_upperBound = seq_04_value + ALLOCATION_COUNT;
         vetBumping( conn, TEST_DBO, "SEQ_04", seq_04_value++, seq_04_upperBound );
     }
@@ -545,121 +538,13 @@ public void test_07_dropSequence() throws Exception
         expectCompilationError( OBJECT_DOES_NOT_EXIST, "values ( next value for seq_07 )\n" );
     }
     
-    /**
-     * <p>
-     * Test user-written range allocators.
-     * </p>
-     */
-    public void test_08_userWrittenAllocators() throws Exception
-    {
-        Connection  conn = openUserConnection( TEST_DBO );
-        String  className;
-
-        goodStatement( conn, "create sequence seq_08\n" );
-
-        className = getClass().getName() + "$" + "UnknownClass";
-        goodStatement
-            (
-             conn,
-             "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + className + "')"
-             );
-        expectExecutionError( conn, MISSING_ALLOCATOR, "values ( next value for seq_08 )" );
-
-        className = getClass().getName() + "$" + "BadAllocator";
-        goodStatement
-            (
-             conn,
-             "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + className + "')"
-             );
-        expectExecutionError( conn, MISSING_ALLOCATOR, "values ( next value for seq_08 )" );
-
-        className = getClass().getName() + "$" + "LegalAllocator";
-        goodStatement
-            (
-             conn,
-             "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + className + "')"
-             );
-        vetBumping( conn, TEST_DBO, "SEQ_08", Integer.MIN_VALUE, Integer.MIN_VALUE + TWEAKED_ALLOCATION_COUNT );
-
-        goodStatement
-            (
-             conn,
-             "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', null )"
-             );
-    }
-        
-    /**
-     * <p>
-     * Test overriding the default length of sequence/identity ranges.
-     * </p>
-     */
-    public void test_09_defaultRangeSize() throws Exception
-    {
-        Connection  conn = openUserConnection( TEST_DBO );
-        long    number;
-
-        goodStatement( conn, "create sequence seq_09_01\n" );
-        number = 30L;
-        goodStatement
-            (
-             conn,
-             "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + number + "')"
-             );
-        vetBumping( conn, TEST_DBO, "SEQ_09_01", Integer.MIN_VALUE, Integer.MIN_VALUE + number );
-
-        // 0 results in the usual default
-        goodStatement( conn, "create sequence seq_09_02\n" );
-        number = 0L;
-        goodStatement
-            (
-             conn,
-             "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + number + "')"
-             );
-        vetBumping( conn, TEST_DBO, "SEQ_09_02", Integer.MIN_VALUE, Integer.MIN_VALUE + ALLOCATION_COUNT );
-
-        // negative numbers result in Missing Allocator exception
-        goodStatement( conn, "create sequence seq_09_03\n" );
-        number = -1L;
-        goodStatement
-            (
-             conn,
-             "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + number + "')"
-             );
-        expectExecutionError( conn, MISSING_ALLOCATOR, "values ( next value for seq_09_03 )" );
-
-        // If the value doesn't fit in an int, we also get a Missing Allocator exception
-        goodStatement( conn, "create sequence seq_09_04\n" );
-        number = Long.MAX_VALUE - 1L;
-        goodStatement
-            (
-             conn,
-             "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + number + "')"
-             );
-        expectExecutionError( conn, MISSING_ALLOCATOR, "values ( next value for seq_09_04 )" );
-        
-        // out of range values will stifle preallocation
-        goodStatement( conn, "create sequence seq_09_05 as smallint\n" );
-        number = ((long) 3 * Short.MAX_VALUE);
-        goodStatement
-            (
-             conn,
-             "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', '" + number + "')"
-             );
-        vetBumping( conn, TEST_DBO, "SEQ_09_05", Short.MIN_VALUE, Short.MIN_VALUE + 1 );
-
-        goodStatement
-            (
-             conn,
-             "call syscs_util.syscs_set_database_property( 'derby.language.sequence.preallocator', null )"
-             );
-    }
-    
     /**
      * <p>
      * Test that sequence values are not leaked during an orderly system shutdown.
-     * See DERBY-5398.
+     * See DERBY-5398. Backed out on the 10.8 branch
      * </p>
      */
+    /*
     public void test_10_5398() throws Exception
     {
         Connection  conn = openUserConnection( TEST_DBO );
@@ -680,6 +565,7 @@ public void test_10_5398() throws Exception
         seq_10_upperBound = seq_10_value + ALLOCATION_COUNT;
         vetBumping( conn, TEST_DBO, "SEQ_10", seq_10_value++, seq_10_upperBound );
     }
+    */
     
     ///////////////////////////////////////////////////////////////////////////////////
     //
@@ -734,7 +620,7 @@ private long getScalarLong( PreparedStatement ps ) throws Exception
 
     ///////////////////////////////////////////////////////////////////////////////////
     //
-    // NESTED CLASSES
+    // INNER CLASSES
     //
     ///////////////////////////////////////////////////////////////////////////////////
 
@@ -767,9 +653,7 @@ private long getScalarLong( PreparedStatement ps ) throws Exception
                  maxValue,
                  minValue,
                  restartValue,
-                 "DUMMY_SCHEMA",
-                 "DUMMY_SEQUENCE",
-                 new SequenceRange()
+                 "DUMMY_SEQUENCE"
                  );
         }
         
@@ -805,16 +689,5 @@ public boolean updateCurrentValueOnDisk( Long oldValue, Long newValue )
     
     }
 
-    // Illegal preallocator, which does not implement the correct interface
-    public  static  final   class   BadAllocator {}
-
-    // Legal preallocator, which preallocates a fixed size range
-    public  static final   class   LegalAllocator  implements  SequencePreallocator
-    {
-        public  LegalAllocator() {}
-        
-        public  int nextRangeSize( String s, String n ) { return TWEAKED_ALLOCATION_COUNT; }
-    }
-
 }
 
diff --git a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_8_2.java b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_8_2.java
index 34e2f057..e69de29b 100644
--- a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_8_2.java
+++ b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_8_2.java
@@ -1,240 +0,0 @@
-/*
-
-Derby - Class org.apache.derbyTesting.functionTests.tests.upgradeTests.Changes10_8_2
-
-Licensed to the Apache Software Foundation (ASF) under one or more
-contributor license agreements.  See the NOTICE file distributed with
-this work for additional information regarding copyright ownership.
-The ASF licenses this file to You under the Apache License, Version 2.0
-(the "License"); you may not use this file except in compliance with
-the License.  You may obtain a copy of the License at
-
-   http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
-
-*/
-package org.apache.derbyTesting.functionTests.tests.upgradeTests;
-
-import org.apache.derbyTesting.junit.SupportFilesSetup;
-
-import java.sql.Statement;
-import java.sql.ResultSet;
-
-import junit.framework.Test;
-import junit.framework.TestSuite;
-
-import org.apache.derbyTesting.junit.JDBC;
-
-
-/**
- * Upgrade test cases for 10.8.2.
- * If the old version is 10.8.2 or later then these tests
- * will not be run.
- * <BR>
-    10.8.2 Upgrade issues
-
-    <UL>
-    <LI>Performance/concurrency changes to identity columns and sequences (see DERBY-4437).</LI>
-    </UL>
-
- */
-public class Changes10_8_2 extends UpgradeChange
-{
-    ///////////////////////////////////////////////////////////////////////////////////
-    //
-    // CONSTANTS
-    //
-    ///////////////////////////////////////////////////////////////////////////////////
-
-    ///////////////////////////////////////////////////////////////////////////////////
-    //
-    // STATE
-    //
-    ///////////////////////////////////////////////////////////////////////////////////
-
-    ///////////////////////////////////////////////////////////////////////////////////
-    //
-    // CONSTRUCTOR
-    //
-    ///////////////////////////////////////////////////////////////////////////////////
-
-    public Changes10_8_2(String name)
-    {
-        super(name);
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////
-    //
-    // JUnit BEHAVIOR
-    //
-    ///////////////////////////////////////////////////////////////////////////////////
-
-    /**
-     * Return the suite of tests to test the changes made in 10.8.
-     * @param phase an integer that indicates the current phase in
-     *              the upgrade test.
-     * @return the test suite created.
-     */
-    public static Test suite(int phase) {
-        TestSuite suite = new TestSuite("Upgrade test for 10.8.2");
-
-        suite.addTestSuite(Changes10_8_2.class);
-        return new SupportFilesSetup((Test) suite);
-    }
-
-    ///////////////////////////////////////////////////////////////////////////////////
-    //
-    // TESTS
-    //
-    ///////////////////////////////////////////////////////////////////////////////////
-
-    /**
-     * Make sure that generator-based identity columns don't break upgrade/downgrade.
-     * See DERBY-4437.
-     */
-    public void testIdentity10_8_2() throws Exception
-    {
-        Statement s = createStatement();
-
-        boolean supportsSequences = oldAtLeast( 10, 6 );
-
-        switch ( getPhase() )
-        {
-        case PH_CREATE: // create with old version
-            s.execute( "create table t_identity1_4437( a int, b int generated always as identity )" );
-            s.execute( "insert into t_identity1_4437( a ) values ( 100 )" );
-            vetIdentityValues( s, "t_identity1_4437", 1, 2 );
-
-            if ( supportsSequences )
-            {
-                s.execute( "create sequence seq1_4437" );
-                vetSequenceValue( s, "seq1_4437", -2147483648, -2147483643 );
-            }
-            
-            break;
-            
-        case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
-            s.execute( "insert into t_identity1_4437( a ) values ( 200 )" );
-            vetIdentityValues( s, "t_identity1_4437", 2, 22 );
-
-            s.execute( "create table t_identity2_4437( a int, b int generated always as identity )" );
-            s.execute( "insert into t_identity2_4437( a ) values ( 100 )" );
-            vetIdentityValues( s, "t_identity2_4437", 1, 21 );
-
-            if ( supportsSequences )
-            {
-                vetSequenceValue( s, "seq1_4437", -2147483643, -2147483623 );
-            
-                s.execute( "create sequence seq2_4437" );
-                vetSequenceValue( s, "seq2_4437", -2147483648, -2147483628 );
-            }
-
-            break;
-            
-        case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
-            s.execute( "insert into t_identity1_4437( a ) values ( 300 )" );
-            vetIdentityValues( s, "t_identity1_4437", 3, 4 );
-
-            s.execute( "insert into t_identity2_4437( a ) values ( 200 )" );
-            vetIdentityValues( s, "t_identity2_4437", 2, 3 );
-
-            if ( supportsSequences )
-            {
-                vetSequenceValue( s, "seq1_4437", -2147483642, -2147483637 );
-                vetSequenceValue( s, "seq2_4437", -2147483647, -2147483642 );
-            }
-            
-            break;
-
-        case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
-            s.execute( "insert into t_identity1_4437( a ) values ( 400 )" );
-            vetIdentityValues( s, "t_identity1_4437", 4, 24 );
-
-            s.execute( "insert into t_identity2_4437( a ) values ( 300 )" );
-            vetIdentityValues( s, "t_identity2_4437", 3, 23 );
-
-            if ( supportsSequences )
-            {
-                vetSequenceValue( s, "seq1_4437", -2147483637, -2147483617 );
-                vetSequenceValue( s, "seq2_4437", -2147483642, -2147483622 );
-            }
-            
-            break;
-        }
-        
-        s.close();
-    }
-    private void    vetIdentityValues( Statement s, String tableName, int expectedRowCount, int expectedSyscolumnsValue ) throws Exception
-    {
-        vetTable( s, tableName, expectedRowCount );
-
-        ResultSet rs = s.executeQuery
-            (
-             "select c.autoincrementvalue\n" +
-             "from sys.syscolumns c, sys.systables t\n" +
-             "where t.tablename = '" + tableName.toUpperCase() + "'\n" +
-             "and t.tableid = c.referenceid\n" +
-             "and c.columnname = 'B'"
-             );
-        rs.next();
-        int    actualSyscolumnsValue = rs.getInt( 1 );
-        vetValues( expectedSyscolumnsValue, actualSyscolumnsValue );
-        rs.close();
-    }
-    private void    vetSequenceValue( Statement s, String sequenceName, int expectedSequenceValue, int expectedSyssequencesValue ) throws Exception
-    {
-        ResultSet   rs = s.executeQuery( "values ( next value for " + sequenceName + " )" );
-        rs.next();
-        int actualSequenceValue = rs.getInt( 1 );
-        vetValues( expectedSequenceValue, actualSequenceValue );
-        rs.close();
-
-        rs = s.executeQuery
-            (
-             "select currentvalue\n" +
-             "from sys.syssequences\n" +
-             "where sequencename = '" + sequenceName.toUpperCase() + "'\n"
-             );
-        rs.next();
-        int    actualSyssequencesValue = rs.getInt( 1 );
-        vetValues( expectedSyssequencesValue, actualSyssequencesValue );
-        rs.close();
-    }
-    private void    vetTable( Statement s, String tableName, int expectedRowCount ) throws Exception
-    {
-        int     actualRowCount = 0;
-        int     lastValue = 0;
-
-        ResultSet   rs = s.executeQuery( "select * from " + tableName + " order by a" );
-
-        while( rs.next() )
-        {
-            actualRowCount++;
-            
-            int currentValue = rs.getInt( 2 );
-            if ( actualRowCount > 1 )
-            {
-                assertTrue( currentValue > lastValue );
-            }
-            lastValue = currentValue;
-        }
-        rs.close();
-
-        vetValues( expectedRowCount, actualRowCount );
-    }
-    private void    vetValues( int expected, int actual )   throws Exception
-    {
-        assertEquals
-            (
-             getOldVersionString(),
-             expected,
-             actual
-             );
-    }
-    
-}
diff --git a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/UpgradeChange.java b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/UpgradeChange.java
index 7e931201..ae387113 100644
--- a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/UpgradeChange.java
+++ b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/UpgradeChange.java
@@ -179,20 +179,4 @@ boolean oldIs(int requiredMajor, int requiredMinor)
         return (getOldMajor() == requiredMajor)
           && (getOldMinor() == requiredMinor);
      }
-    
-    /**
-     * Pretty-print the phase.
-     */
-    String  getPhaseString()
-    {
-        return PHASES[ getPhase() ];
-    }
-
-    /**
-     * Pretty-print the original version number.
-     */
-    String  getOldVersionString()
-    {
-        return "( " + getOldMajor() + ", " + getOldMinor() + ", " + getOldFixPack() + ", " + getOldPoint() + " )";
-    }
 }
diff --git a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/UpgradeRun.java b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/UpgradeRun.java
index 5cf98aec..20ad9e66 100644
--- a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/UpgradeRun.java
+++ b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/UpgradeRun.java
@@ -195,8 +195,6 @@ private static Test baseSuite(String name, int phase, int[] version) {
                 	suite.addTest(Changes10_6.suite(phase));
                 if (oldMinor < 7)
                 	suite.addTest(Changes10_7.suite(phase));
-                if ( lessThan( version, new int[] { 10, 8, 1, 6 } ) )
-                { suite.addTest(Changes10_8_2.suite(phase)); }
             }
             
             // Add DatabaseMetaData tests. Since metadata
@@ -239,21 +237,6 @@ private static Test baseSuite(String name, int phase, int[] version) {
         return TestConfiguration.connectionDSDecorator(suite);
     }
     
-    /**
-     * Return true if and only if the left version is less than the
-     * right version.
-     */
-    private static boolean lessThan( int[] left, int[] right )
-    {
-        for (int i = 0; i < left.length; i++)
-        {
-            if ( left[ i ] < right[ i ] ) return true;
-            if ( left[ i ] > right[ i ] ) return false;
-        }
-
-        // Versions match exactly. That is, not less than.
-        return false;
-    } 
     
     /**
      * When running against certains old releases in Java SE 6
