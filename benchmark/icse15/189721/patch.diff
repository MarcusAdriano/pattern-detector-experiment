diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/catalog/types/BaseTypeIdImpl.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/catalog/types/BaseTypeIdImpl.java
index 6ef6309a..3e61468e 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/catalog/types/BaseTypeIdImpl.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/catalog/types/BaseTypeIdImpl.java
@@ -415,6 +415,17 @@ private void setTypeIdSpecificInstanceVariables()
                 JDBCTypeId = Types.TIMESTAMP;
                 wrapperTypeFormatId = StoredFormatIds.TIMESTAMP_TYPE_ID;
                 break;
+
+          case StoredFormatIds.XML_TYPE_ID_IMPL:
+                SQLTypeName = TypeId.XML_NAME;
+                // RESOLVE: There isn't a JDBC type for XML, so we
+                // just use our internal type.  Is it okay to do this,
+                // or should "JDBCTypeId" be renamed since it no longer
+                // just holds JDBC types?
+                JDBCTypeId = StoredFormatIds.XML_TYPE_ID;
+                wrapperTypeFormatId = StoredFormatIds.XML_TYPE_ID;
+                break;
+
           default:
                 if (SanityManager.DEBUG)
                 {
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/catalog/types/TypesImplInstanceGetter.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/catalog/types/TypesImplInstanceGetter.java
index 809e58df..2ff5c405 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/catalog/types/TypesImplInstanceGetter.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/catalog/types/TypesImplInstanceGetter.java
@@ -51,6 +51,7 @@ public Object getNewInstance() {
                   case StoredFormatIds.BLOB_TYPE_ID_IMPL:
                   case StoredFormatIds.CLOB_TYPE_ID_IMPL:
                   case StoredFormatIds.NCLOB_TYPE_ID_IMPL:
+                  case StoredFormatIds.XML_TYPE_ID_IMPL:
                           return new BaseTypeIdImpl(fmtId);
                   case StoredFormatIds.DECIMAL_TYPE_ID_IMPL:
                           return new DecimalTypeIdImpl();
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/ClassName.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/ClassName.java
index d5ad5e91..f0f90d7a 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/ClassName.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/ClassName.java
@@ -54,6 +54,7 @@
 	String RefDataValue = "org.apache.derby.iapi.types.RefDataValue";
 	String UserDataValue = "org.apache.derby.iapi.types.UserDataValue";
 	String ConcatableDataValue  = "org.apache.derby.iapi.types.ConcatableDataValue";
+	String XMLDataValue  = "org.apache.derby.iapi.types.XMLDataValue";
 
 	String FormatableBitSet = "org.apache.derby.iapi.services.io.FormatableBitSet";
 
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/SQLState.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/SQLState.java
index 5026c523..c89e8fd7 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/SQLState.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/reference/SQLState.java
@@ -118,6 +118,7 @@ The message identifier (ie. the value that matches a field in this class)
 
 	<LI>Language
 	  <UL>
+		<LI> 2200J-2200R for SQL/XML errors (based on SQL/XML[2003]) </LI>
 		<LI> 42800-? for compatible DB2 errors
 		<LI> 42X00-42Zxx for compilation errors </LI>
 		<LI> 43X00-43Yxx  for org.apache.derby.impl.sql.execute.rts
@@ -571,6 +572,7 @@ The message identifier (ie. the value that matches a field in this class)
 	** to the appropriate group. Language errors are divided into 3 groups:
 	** A group for standard SQLExceptions.
 	**
+	** 2200J-00R - For SQL/XML errors (based on SQL/XML[2003]).
 	** 428?? - adding some DB2 compatible errors
 	** 42X00-42Zxx for compilation errors 
 	** 46000  for SQLJ errors (for now, leave this range empty)
@@ -671,6 +673,11 @@ The message identifier (ie. the value that matches a field in this class)
 	String LANG_FK_VIOLATION                                           = "23503";
 	String LANG_CHECK_CONSTRAINT_VIOLATED                              = "23513";
 
+	// From SQL/XML[2003] spec; there are others, but
+	// these are the ones we actually use with our
+	// current XML support.
+	String LANG_NOT_AN_XML_DOCUMENT                                    = "2200L";
+
 	String LANG_INVALID_TRANSACTION_STATE                              = "25000";
 
 	String LANG_UNEXPECTED_USER_EXCEPTION                              = "38000";
@@ -1184,6 +1191,16 @@ The message identifier (ie. the value that matches a field in this class)
 	String LANG_COLUMN_NAME_NOT_FOUND                                  = "X0X0F.S";
 
 	String LANG_INDEX_NOT_FOUND_DURING_EXECUTION                       = "X0X99.S";
+
+	// For Derby-specific XML errors (not defined by
+	// SQL/XML standard).
+	String LANG_ATTEMPT_TO_BIND_XML                                    = "X0X14.S";
+	String LANG_ATTEMPT_TO_SELECT_XML                                  = "X0X15.S";
+	String LANG_XML_KEYWORD_MISSING                                    = "X0X16.S";
+	String LANG_INVALID_XMLSERIALIZE_TYPE                              = "X0X17.S";
+	String LANG_UNSUPPORTED_XML_FEATURE                                = "X0X18.S";
+	String LANG_UNEXPECTED_XML_EXCEPTION                               = "X0XML.S";
+
 	// X0Y01 used to be DUPLICATE_KEY_CONSTRAINT
 	String LANG_DROP_VIEW_ON_NON_VIEW                                  = "X0Y16.S";
 	// String LANG_DROP_SYSTEM_TABLE_ATTEMPTED_DURING_EXECUTION           = "X0Y17.S";
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java
index 2bdfaedd..cdd898dd 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java
@@ -511,11 +511,13 @@ The offset from the base format number (0 based) gives the offset in the array.
         /* 449 */       "org.apache.derby.catalog.types.TypesImplInstanceGetter",
         /* 450 */       "org.apache.derby.iapi.types.DTSClassInfo", //InstanceGetter,
 
- 
         /* 451 */   "org.apache.derby.catalog.types.RoutineAliasInfo",
 		/* 452 */   null,
 		/* 453 */   "org.apache.derby.impl.store.raw.log.ChecksumOperation",
 		/* 454 */   "org.apache.derby.impl.store.raw.data.CompressSpacePageOperation",
-		/* 455 */   "org.apache.derby.catalog.types.SynonymAliasInfo"
+		/* 455 */   "org.apache.derby.catalog.types.SynonymAliasInfo",
+        /* 456 */   "org.apache.derby.iapi.types.DTSClassInfo", //InstanceGetter, XML_TYPE_ID
+        /* 457 */   "org.apache.derby.catalog.types.TypesImplInstanceGetter", // XML_TYPE_ID_IMPL
+        /* 458 */   "org.apache.derby.iapi.types.DTSClassInfo" //InstanceGetter, XML_ID
 };
 }
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java
index 2bb03485..49d41846 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java
@@ -465,6 +465,12 @@ and another may restore (read) the object. The implication of this
         static public final int BLOB_COMPILATION_TYPE_ID =
                 (MIN_ID_2 + 441);
 
+        /**
+                Instance of TypeId for XML data types.
+         */
+        static public final int XML_TYPE_ID =
+                (MIN_ID_2 + 456);
+        
         /**
             class org.apache.derby.iapi.types.JSQLType
          */
@@ -840,6 +846,12 @@ and another may restore (read) the object. The implication of this
         static public final int NCLOB_TYPE_ID_IMPL =
                 (MIN_ID_2 + 449);
         
+        /**
+            class org.apache.derby.iapi.types.XML (implementation of
+            org.apache.derby.iapi.types.XMLDataValue).
+         */
+        static public final int XML_TYPE_ID_IMPL =
+                (MIN_ID_2 + 457);
 
         /******************************************************************
         **
@@ -1507,6 +1519,10 @@ and another may restore (read) the object. The implication of this
         public static final int SQL_NCLOB_ID = 
                 (MIN_ID_2 + 450);
 
+        // Interface: org.apache.derby.iapi.types.XMLDataValue
+        public static final int XML_ID = 
+                (MIN_ID_2 + 458);
+
         /******************************************************************
         ** 
         ** Access ids.
@@ -1811,7 +1827,7 @@ and another may restore (read) the object. The implication of this
          * Make sure this is updated when a new module is added
          */
         public static final int MAX_ID_2 =
-                (MIN_ID_2 + 455);
+                (MIN_ID_2 + 458);
 
         // DO NOT USE 4 BYTE IDS ANYMORE
         static public final int MAX_ID_4 =
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/C_NodeTypes.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/C_NodeTypes.java
index 8e35a739..aa6a7c2a 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/C_NodeTypes.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/C_NodeTypes.java
@@ -209,6 +209,12 @@
     // for SAVEPOINT sql
     static final int SAVEPOINT_NODE = 198;
 
+    // XML
+    static final int XML_CONSTANT_NODE = 199;
+    static final int XML_PARSE_OPERATOR_NODE = 200;
+    static final int XML_SERIALIZE_OPERATOR_NODE = 201;
+    static final int XML_EXISTS_OPERATOR_NODE = 202;
+
     /**
      * Extensions to this interface can use nodetypes > MAX_NODE_TYPE with out fear of collision
      * with C_NodeTypes
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DTSClassInfo.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DTSClassInfo.java
index e1ca74b8..926e979b 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DTSClassInfo.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DTSClassInfo.java
@@ -58,6 +58,7 @@ public Object getNewInstance() {
                 case StoredFormatIds.SQL_BLOB_ID: return new SQLBlob();
                 case StoredFormatIds.SQL_CLOB_ID: return new SQLClob();
                 case StoredFormatIds.SQL_NCLOB_ID: return new SQLNClob();
+                case StoredFormatIds.XML_ID: return new XML();
 
                 /* Type ids */
                 case StoredFormatIds.BIT_TYPE_ID: 
@@ -85,6 +86,7 @@ public Object getNewInstance() {
                 case StoredFormatIds.BLOB_TYPE_ID:
                 case StoredFormatIds.CLOB_TYPE_ID:
                 case StoredFormatIds.NCLOB_TYPE_ID:
+                case StoredFormatIds.XML_TYPE_ID:
                         return new TypeId(fmtId);
                 default:
                         return null;
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataTypeUtilities.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataTypeUtilities.java
index 9236c2b2..afbbb338 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataTypeUtilities.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataTypeUtilities.java
@@ -24,6 +24,7 @@
 import org.apache.derby.iapi.error.StandardException;
 
 import org.apache.derby.iapi.reference.JDBC30Translation;
+import org.apache.derby.iapi.services.io.StoredFormatIds;
 
 import java.sql.Types;
 import java.sql.ResultSetMetaData;
@@ -51,6 +52,7 @@ public static int getPrecision(DataTypeDescriptor dtd) {
 		case Types.VARBINARY:
 		case Types.LONGVARBINARY:
 			case Types.BLOB:
+		case StoredFormatIds.XML_TYPE_ID:
 				return dtd.getMaximumWidth();
 			case Types.SMALLINT:
 				return 5;
@@ -103,7 +105,8 @@ public static boolean isCaseSensitive(DataTypeDescriptor dtd) {
 		return (typeId == Types.CHAR ||
 		          typeId == Types.VARCHAR ||
 		          typeId == Types.CLOB ||
-		          typeId == Types.LONGVARCHAR);
+		          typeId == Types.LONGVARCHAR ||
+		          typeId == StoredFormatIds.XML_TYPE_ID);
 	}
 	/**
 		Is the data type nullable.
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataValueFactory.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataValueFactory.java
index 78686242..b732b37d 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataValueFactory.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataValueFactory.java
@@ -452,6 +452,14 @@ DateTimeDataValue       getDataValue(Timestamp value,
          */
         public DateTimeDataValue getTimestampValue( String timestampStr, boolean isJdbcEscape) throws StandardException;
 
+        /**
+         * Get a null XML value. The second form re-uses the previous value,
+         * if non-null, as the data holder to return.
+         */
+        XMLDataValue getXMLDataValue();
+        XMLDataValue getXMLDataValue(XMLDataValue previous)
+			throws StandardException;
+
         /**
          * Get a SQL int with a SQL null value. If the supplied value
          * is null then get a new value, otherwise set it to null and return 
@@ -655,4 +663,11 @@ BitDataValue            getNullBlob(BitDataValue dataValue)
          * that value.
          */
         DateTimeDataValue       getNullTimestamp(DateTimeDataValue dataValue);
+
+        /**
+         * Get an XML with a SQL null value. If the supplied value is
+         * null then get a new value, otherwise set it to null and return 
+         * that value.
+         */
+        XMLDataValue            getNullXML(XMLDataValue dataValue);
 }
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataValueFactoryImpl.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataValueFactoryImpl.java
index 8875aac1..23524d66 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataValueFactoryImpl.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/DataValueFactoryImpl.java
@@ -1027,6 +1027,57 @@ public DateTimeDataValue getTimestampValue( String timestampStr, boolean isJdbcE
     } // end of getTimestampValue( String timestampStr)
 
 
+    /**
+     * getXMLDataValue:
+     * Get a SQL null value with XML type.
+     * @return An XMLDataValue instance corresponding to a
+     *  a NULL value.
+     */
+    public XMLDataValue getXMLDataValue()
+    {
+        return new XML();
+    }
+
+    /**
+     * getXMLDataValue:
+     * Get a null XML  value.  If a non-null XMLDataValue is
+     * received then re-use that instance, otherwise create
+	 * a new one.
+     * @param previous An XMLDataValue instance to re-use.
+     * @return An XMLDataValue instance corresponding to a
+     *  NULL value.  If an XMLDataValue was received, the
+     *  returned XMLDataValue is the same instance as the one
+     *  received, but the actual data has been set to a
+     *  SQL null value.
+     * @exception StandardException Thrown on error
+     */
+    public XMLDataValue getXMLDataValue(XMLDataValue previous)
+		throws StandardException
+    {
+		return getNullXML(previous);
+    }
+
+    /**
+     * getNullXML:
+     * Get an XML with a SQL null value. If the supplied value is
+     * null then get a new value, otherwise set it to null and return 
+     * that value.
+     * @param dataValue An XMLDataValue instance to re-use.
+     * @return An XMLDataValue instance corresponding to a
+     *  NULL value.  If an XMLDataValue was received, the
+     *  returned XMLDataValue is the same instance as the one
+     *  received, but the actual data has been set to null.
+     */
+    public XMLDataValue getNullXML(XMLDataValue dataValue)
+    {
+        if (dataValue == null)
+            return getXMLDataValue();
+        else {
+            dataValue.setToNull();
+            return dataValue;
+        }
+    }
+
         // RESOLVE: This is here to find the LocaleFinder (i.e. the Database)
         // on first access. This is necessary because the Monitor can't find
         // the Database at boot time, because the Database is not done booting.
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/SQLChar.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/SQLChar.java
index aa18c820..c94859cc 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/SQLChar.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/SQLChar.java
@@ -2732,4 +2732,46 @@ protected void copyState(SQLChar other) {
 		this.intLength = intLength;
 		this.localeFinder = localeFinder;
 	}
+
+    /*
+     * Implementation of the XMLParse operator.
+     *
+     * NOTE: The XMLParse operator is implemented here (and
+     * defined on the StringDataValue interface) since it is
+     * called with a _String_ operand, not with an XML operand.
+     * That said, though, the bulk of the work is done by
+     * calling the "parseAndLoadXML" method that is defined on
+     * XMLDataValue.
+     * @param result The result of a previous call to this method,
+     *  null if not called yet.
+     * @return An XML value containing the result of XMLParse IF
+     *  the String data in this SQLChar constitutes valid XML.
+     *  Otherwise, an exception is thrown.
+     * @exception StandardException Thrown on error
+     */
+    public XMLDataValue XMLParse(XMLDataValue result, boolean preserveWS)
+        throws StandardException
+    {
+
+        if (result == null)
+        {
+            result = new XML();
+        }
+
+        if (this.isNull())
+        {
+            result.setToNull();
+            return result;
+        }
+
+        // First make sure that the string is valid, well-formed XML.
+        String str = getString();
+        result.parseAndLoadXML(str, preserveWS);
+
+        // If we get here, the character string is valid XML
+		// and was loaded, so we're done.
+        return result;
+
+    }
+
 }
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/StringDataValue.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/StringDataValue.java
index c0bdbbf3..600e5247 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/StringDataValue.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/StringDataValue.java
@@ -146,4 +146,24 @@ public NumberDataValue locate(  StringDataValue searchFrom,
 	 * @exception StandardException		Thrown on error
 	 */
 	public char[] getCharArray() throws StandardException;
+
+    /*
+     * Get an XML value from a string.
+     *
+     * NOTE: The XMLParse operator is defined here since it
+     * is called with a _String_ operand, not with an XML
+     * operand.  That said, though, the bulk of the work is
+     * is done by a corresponding method that is defined
+     * on the XMLDataValue interface (implementations
+     * of this method should just call the XMLDataValue
+     * method, passing in the correct String data).
+     *
+     * @param result The result (reusable - allocate if null).
+     * @return An XML value corresponding to the string, if
+     *  the string is valid XML.
+     * @exception StandardException Thrown on error
+     */
+    public XMLDataValue XMLParse(XMLDataValue result, boolean preserveWS)
+        throws StandardException;
+
 }
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/TypeId.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/TypeId.java
index 30ccef62..a6c8cce3 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/TypeId.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/TypeId.java
@@ -114,6 +114,7 @@
         public static final int BLOB_MAXWIDTH = Integer.MAX_VALUE; // to change long
         public static final int CLOB_MAXWIDTH = Integer.MAX_VALUE; // to change long
         public static final int NCLOB_MAXWIDTH = Integer.MAX_VALUE; // to change long
+        public static final int XML_MAXWIDTH = Integer.MAX_VALUE;
 
         // Max width for datetime values is the length of the
         // string returned from a call to "toString()" on the
@@ -169,11 +170,16 @@
         public static final String      CLOB_NAME = "CLOB";
         public static final String      NCLOB_NAME = "NCLOB";
         
+        // Following use of "XML" is per SQL/XML (2003) spec,
+        // section "10.2 Type name determination".
+        public static final String      XML_NAME = "XML";
+        
         /**
          * The following constants define the type precedence hierarchy.
          */
         public static final int USER_PRECEDENCE  = 1000;
 
+        public static final int XML_PRECEDENCE       = 180;
         public static final int BLOB_PRECEDENCE = 170;
         public static final int LONGVARBIT_PRECEDENCE = 160;
         public static final int VARBIT_PRECEDENCE        = 150;
@@ -239,6 +245,7 @@
         private static TypeId                   BLOB_ID;
         private static TypeId                   CLOB_ID;
         private static TypeId                   NCLOB_ID;
+        private static TypeId                   XML_ID;
 
         /**
          * Implementation of DECIMAL datatype for generating holders through getNull.
@@ -397,6 +404,15 @@ public static TypeId getBuiltInTypeId(int JDBCTypeId)
                           ret = CLOB_ID = new TypeId(StoredFormatIds.CLOB_TYPE_ID,
                                                      new BaseTypeIdImpl(StoredFormatIds.CLOB_TYPE_ID_IMPL));
                       break;
+
+                  // XML is not a JDBC type, so we have to check for our
+                  // internal XML type.
+                  case StoredFormatIds.XML_TYPE_ID:
+                      ret = XML_ID;
+                      if (ret == null)
+                          ret = XML_ID = new TypeId(StoredFormatIds.XML_TYPE_ID,
+                                                     new BaseTypeIdImpl(StoredFormatIds.XML_TYPE_ID_IMPL));
+                      break;
                 }
                 return ret;
         }
@@ -484,6 +500,10 @@ else if (javaTypeName.equals("java.sql.Clob"))
                 {
                         return getBuiltInTypeId(JDBC20Translation.SQL_TYPES_CLOB);
                 }
+                else if (javaTypeName.equals("org.apache.derby.iapi.types.XML"))
+                {
+                        return getBuiltInTypeId(StoredFormatIds.XML_TYPE_ID);
+                }
                 else
                 {
                         /*
@@ -571,6 +591,9 @@ public static TypeId getBuiltInTypeId(String SQLTypeName) {
                 if (SQLTypeName.equals(TypeId.CLOB_NAME)) {
                         return getBuiltInTypeId(JDBC20Translation.SQL_TYPES_CLOB);
                 }
+                if (SQLTypeName.equals(TypeId.XML_NAME)) {
+                        return getBuiltInTypeId(StoredFormatIds.XML_TYPE_ID);
+                }
 
                 TypeId ret = null;
 
@@ -931,6 +954,12 @@ private void setTypeIdSpecificInstanceVariables()
                               isLOBTypeId = true;
                               break;
 
+                      case StoredFormatIds.XML_TYPE_ID:
+                              typePrecedence = XML_PRECEDENCE;
+                              javaTypeName = "org.apache.derby.iapi.types.XML";
+                              maxMaxWidth = TypeId.XML_MAXWIDTH;
+                              break;
+
                 }
         }
         /**
@@ -1170,6 +1199,15 @@ public boolean isNationalStringTypeId()
                 }
         }
 
+        /**
+         *Is this an XML doc?
+         * @return true if this is XML
+         */
+        public boolean isXMLTypeId()
+        {
+               return (formatId == StoredFormatIds.XML_TYPE_ID);
+        }
+
         /**
          * Tell whether this is a built-in type.
          * NOTE: There are 3 "classes" of types:
@@ -1206,6 +1244,7 @@ public boolean orderable(ClassFactory cf)
                         case StoredFormatIds.NCLOB_TYPE_ID:
                         case StoredFormatIds.NATIONAL_LONGVARCHAR_TYPE_ID:
                         case StoredFormatIds.LONGVARCHAR_TYPE_ID:
+                        case StoredFormatIds.XML_TYPE_ID:
                                 return false;
 
                         case StoredFormatIds.USERDEFINED_TYPE_ID_V3:
@@ -1568,6 +1607,9 @@ public DataValueDescriptor getNull()
                         case StoredFormatIds.VARCHAR_TYPE_ID:
                                 return new SQLVarchar();
 
+                        case StoredFormatIds.XML_TYPE_ID:
+                                return new XML();
+
                         default:
                                 if (SanityManager.DEBUG)
                                 {
@@ -1628,6 +1670,8 @@ public int getApproximateLengthInBytes(DataTypeDescriptor dts)
                         case StoredFormatIds.BLOB_TYPE_ID:
                         case StoredFormatIds.CLOB_TYPE_ID:
                         case StoredFormatIds.NCLOB_TYPE_ID:
+                        // RESOLVE: Should XML be here?  What's this value mean, anyway?
+                        case StoredFormatIds.XML_TYPE_ID:
                                 return 10240;
 
                         case StoredFormatIds.REF_TYPE_ID:
@@ -1772,6 +1816,12 @@ public boolean variableLength()
 // none of the LONG_VARCHAR types are true here...????
 //                        case StoredFormatIds.CLOB_TYPE_ID:
 //                        case StoredFormatIds.NCLOB_TYPE_ID:
+                        // RESOLVE: does "variableLength" here mean simply
+                        // that the length is variable, or that the user
+                        // can specify a length, such as "char(20)"?  The
+                        // answer to that determines where XML is supposed
+                        // to be...
+                        case StoredFormatIds.XML_TYPE_ID:
                                 return true;
 
                         default:
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/XML.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/XML.java
index e69de29b..8ef5b0e3 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/XML.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/XML.java
@@ -0,0 +1,861 @@
+/*
+
+   Derby - Class org.apache.derby.iapi.types.XML
+
+   Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.iapi.types;
+
+import org.apache.derby.iapi.error.StandardException;
+
+import org.apache.derby.iapi.services.cache.ClassSize;
+import org.apache.derby.iapi.services.io.ArrayInputStream;
+import org.apache.derby.iapi.services.io.StoredFormatIds;
+import org.apache.derby.iapi.services.io.StreamStorable;
+import org.apache.derby.iapi.services.sanity.SanityManager;
+
+import org.apache.derby.iapi.types.DataValueDescriptor;
+import org.apache.derby.iapi.types.StringDataValue;
+import org.apache.derby.iapi.types.BooleanDataValue;
+
+import org.apache.derby.iapi.reference.SQLState;
+
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Types;
+
+import java.io.InputStream;
+import java.io.IOException;
+import java.io.ObjectOutput;
+import java.io.ObjectInput;
+import java.io.StringReader;
+
+import org.xml.sax.ErrorHandler;
+import org.xml.sax.XMLReader;
+import org.xml.sax.SAXException;
+import org.xml.sax.SAXParseException;
+import org.xml.sax.InputSource;
+
+import org.xml.sax.helpers.DefaultHandler;
+import org.xml.sax.helpers.XMLReaderFactory;
+
+import javax.xml.transform.Templates;
+import javax.xml.transform.TransformerFactory;
+
+import javax.xml.transform.sax.SAXResult;
+import javax.xml.transform.sax.TemplatesHandler;
+import javax.xml.transform.sax.TransformerHandler;
+
+// Note that even though the following has a Xalan
+// package name, it IS part of the JDK 1.4 API, and
+// thus we can compile it without having Xalan in
+// our classpath.
+import org.apache.xalan.processor.TransformerFactoryImpl;
+
+/**
+ * This type implements the XMLDataValue interface and thus is
+ * the type on which all XML related operations are executed.
+ *
+ * The first and simplest XML store implementation is a UTF-8
+ * based one--all XML data is stored on disk as a UTF-8 string,
+ * just like the other Derby string types.  In order to make
+ * it possible for smarter XML implementations to exist in
+ * the future, this class always writes an "XML implementation
+ * id" to disk before writing the rest of its data.  When
+ * reading the data, the impl id is read first and serves
+ * as an indicator of how the rest of the data should be
+ * read.
+ *
+ * So long as there's only one implementation (UTF-8)
+ * the impl id can be ignored; but when smarter implementations
+ * are written, the impl id will be the key to figuring out
+ * how an XML value should be read, written, and processed.
+ */
+public class XML
+    extends DataType implements XMLDataValue, StreamStorable
+{
+    // Id for this implementation.  Should be unique
+    // across all XML type implementations.
+    protected static final short UTF8_IMPL_ID = 0;
+
+    // Parser class to use for parsing XML.  We use the
+    // Xerces parser, so (for now) we require that Xerces
+    // be in the user's classpath.  Note that we load
+    // the Xerces class dynamically (using the class 
+    // name) so that Derby will build even if Xerces
+    // isn't in the build environment; i.e. Xerces is
+    // only required if XML is actually going to be used
+    // at runtime; it's not required for a successful
+    // build nor for non-XML database use.
+    protected static final String XML_PARSER_CLASS =
+        "org.apache.xerces.parsers.SAXParser";
+
+    // Guess at how much memory this type will take.
+    private static final int BASE_MEMORY_USAGE =
+        ClassSize.estimateBaseFromCatalog(XML.class);
+
+    // The actual XML data in this implementation is just a simple
+    // string, so this class really just wraps a SQLChar and
+    // defers most calls to the corresponding calls on that
+    // SQLChar.  Note that, even though a SQLChar is the
+    // underlying implementation, an XML value is nonetheless
+    // NOT considered comparable nor compatible with any of
+    // Derby string types.
+    private SQLChar xmlStringValue;
+
+    // An XML reader for reading and parsing SAX events.
+    protected XMLReader saxReader;
+
+    // XSLT objects used when performing an XSLT query, which
+    // is the query mechanism for this UTF8-based implementation.
+    private static final String XPATH_PLACEHOLDER = "XPATH_PLACEHOLDER";
+    private static final String QUERY_MATCH_STRING = "MATCH";
+    private static String xsltStylesheet;
+    private XMLReader xsltReader;
+    private TransformerFactoryImpl saxTFactory;
+
+    /**
+     * Default constructor.
+     */
+    public XML()
+    {
+        xmlStringValue = null;
+    }
+
+    /**
+     * Private constructor used for the getClone() method.
+     * Takes a SQLChar and clones it.
+     * @param val A SQLChar instance to clone and use for
+     *  this XML value.
+     */
+    private XML(SQLChar val)
+    {
+        xmlStringValue = (val == null ? null : (SQLChar)val.getClone());
+    }
+
+    /* ****
+     * DataValueDescriptor interface.
+     * */
+
+    /**
+     * @see DataValueDescriptor#getClone
+     */
+    public DataValueDescriptor getClone()
+    {
+        return new XML(xmlStringValue);
+    }
+
+    /**
+     * @see DataValueDescriptor#getNewNull
+     */
+    public DataValueDescriptor getNewNull()
+    {
+        return new XML();
+    }
+
+    /**
+     * @see DataValueDescriptor#getTypeName
+     */
+    public String getTypeName()
+    {
+        return TypeId.XML_NAME;
+    }
+
+    /**
+     * @see DataValueDescriptor#typePrecedence
+     */
+    public int typePrecedence()
+    {
+        return TypeId.XML_PRECEDENCE;
+    }
+
+    /**
+     * @see DataValueDescriptor#getString
+     */
+    public String getString() throws StandardException
+    {
+        return (xmlStringValue == null) ? null : xmlStringValue.getString();
+    }
+
+    /**
+     * @see DataValueDescriptor#getLength
+     */
+    public int    getLength() throws StandardException
+    {
+        return ((xmlStringValue == null) ? 0 : xmlStringValue.getLength());
+    }
+
+    /** 
+     * @see DataValueDescriptor#estimateMemoryUsage
+     */
+    public int estimateMemoryUsage()
+    {
+        int sz = BASE_MEMORY_USAGE;
+        if (xmlStringValue != null)
+            sz += xmlStringValue.estimateMemoryUsage();
+        return sz;
+    }
+
+    /**
+     * @see DataValueDescriptor#readExternalFromArray
+     */
+    public void readExternalFromArray(ArrayInputStream in)
+        throws IOException
+    {
+        if (xmlStringValue == null)
+            xmlStringValue = new SQLChar();
+
+        // Read the XML implementation id.  Right now there's
+        // only one implementation (UTF-8 based), so we don't
+        // use this value.  But if better implementations come
+        // up in the future, we'll have to use this impl id to
+        // figure out how to read the data.
+        in.readShort();
+
+        // Now just read the XML data as UTF-8.
+        xmlStringValue.readExternalFromArray(in);
+    }
+
+    /**
+     * @see DataValueDescriptor#setFrom
+     */
+    protected void setFrom(DataValueDescriptor theValue)
+        throws StandardException
+    {
+        if (xmlStringValue == null)
+            xmlStringValue = new SQLChar();
+        xmlStringValue.setValue(theValue.getString());
+    }
+
+    /** 
+     * @see DataValueDescriptor#setValueFromResultSet 
+     */
+    public final void setValueFromResultSet(
+        ResultSet resultSet, int colNumber, boolean isNullable)
+        throws SQLException
+    {
+        if (xmlStringValue == null)
+            xmlStringValue = new SQLChar();
+        xmlStringValue.setValue(resultSet.getString(colNumber));
+    }
+
+    /**
+     * Compare two XML DataValueDescriptors.  NOTE: This method
+     * should only be used by the database store for the purpose of
+     * index positioning--comparisons of XML type are not allowed
+     * from the language side of things.  That said, all store
+     * wants to do is order the NULLs, so we don't actually
+     * have to do a full comparison.  Just return an order
+     * value based on whether or not this XML value and the
+     * other XML value are null.  As mentioned in the "compare"
+     * method of DataValueDescriptor, nulls are considered
+     * equal to other nulls and less than all other values.
+     *
+     * An example of when this method might be used is if the
+     * user executed a query like:
+     *
+     * select i from x_table where x_col is not null
+     *
+     * @see DataValueDescriptor#compare
+     */
+    public int compare(DataValueDescriptor other)
+        throws StandardException
+    {
+        if (SanityManager.DEBUG) {
+            SanityManager.ASSERT(other instanceof XMLDataValue,
+                "Store should NOT have tried to compare an XML value " +
+                "with a non-XML value.");
+        }
+
+        if (isNull()) {
+            if (other.isNull())
+            // both null, so call them 'equal'.
+                return 0;
+            // This XML is 'less than' the other.
+            return -1;
+        }
+
+        if (other.isNull())
+        // This XML is 'greater than' the other.
+            return 1;
+
+        // Two non-null values: we shouldn't ever get here,
+        // since that would necessitate a comparsion of XML
+        // values, which isn't allowed.
+        if (SanityManager.DEBUG) {
+            SanityManager.THROWASSERT(
+                "Store tried to compare two non-null XML values, " +
+                "which isn't allowed.");
+        }
+        return 0;
+    }
+
+    /* ****
+     * Storable interface, implies Externalizable, TypedFormat
+     */
+
+    /**
+     * @see TypedFormat#getTypeFormatId
+     *
+     * From the engine's perspective, all XML implementations share
+     * the same format id.
+     */
+    public int getTypeFormatId() {
+        return StoredFormatIds.XML_ID;
+    }
+
+    /**
+     * @see Storable#isNull
+     */
+    public boolean isNull()
+    {
+        return ((xmlStringValue == null) || xmlStringValue.isNull());
+    }
+
+    /**
+     * @see Storable#restoreToNull
+     */
+    public void restoreToNull()
+    {
+        if (xmlStringValue != null)
+            xmlStringValue.restoreToNull();
+    }
+
+    /**
+     * Read an XML value from an input stream.
+     * @param in The stream from which we're reading.
+     */
+    public void readExternal(ObjectInput in) throws IOException
+    {
+        if (xmlStringValue == null)
+            xmlStringValue = new SQLChar();
+
+        // Read the XML implementation id.  Right now there's
+        // only one implementation (UTF-8 based), so we don't
+        // use this value.  But if better implementations come
+        // up in the future, we'll have to use this impl id to
+        // figure out how to read the data.
+        in.readShort();
+
+        // Now just read the XML data as UTF-8.
+        xmlStringValue.readExternal(in);
+    }
+
+    /**
+     * Write an XML value. 
+     * @param out The stream to which we're writing.
+     */
+    public void writeExternal(ObjectOutput out) throws IOException
+    {
+        // never called when value is null
+        if (SanityManager.DEBUG)
+            SanityManager.ASSERT(!isNull());
+
+        // Write out the XML store impl id.
+        out.writeShort(UTF8_IMPL_ID);
+
+        // Now write out the data.
+        xmlStringValue.writeExternal(out);
+    }
+
+    /* ****
+     * StreamStorable interface
+     * */
+
+    /**
+     * @see StreamStorable#returnStream
+     */
+    public InputStream returnStream()
+    {
+        return
+            (xmlStringValue == null) ? null : xmlStringValue.returnStream();
+    }
+
+    /**
+     * @see StreamStorable#setStream
+     */
+    public void setStream(InputStream newStream)
+    {
+        if (xmlStringValue == null)
+            xmlStringValue = new SQLChar();
+
+        // The stream that we receive is for an XML data value,
+        // which means it has an XML implementation id stored
+        // at the front (we put it there when we wrote it out).
+        // If we leave that there we'll get a failure when
+        // our underlying SQLChar tries to read from the
+        // stream, because the extra impl id will throw
+        // off the UTF format.  So we need to read in (and
+        // ignore) the impl id before using the stream.
+        try {
+            // 2 bytes equal a short, which is what an impl id is.
+            newStream.read();
+            newStream.read();
+        } catch (Exception e) {
+            if (SanityManager.DEBUG)
+                SanityManager.THROWASSERT("Failed to read impl id" +
+                    "bytes in setStream.");
+        }
+
+        // Now go ahead and use the stream.
+        xmlStringValue.setStream(newStream);
+    }
+
+    /**
+     * @see StreamStorable#loadStream
+     */
+    public void loadStream() throws StandardException
+    {
+        getString();
+    }
+
+    /* ****
+     * XMLDataValue interface.
+     * */
+
+    /**
+     * Method to parse an XML string and, if it's valid,
+     * store the _parsed_ version for subsequent use.
+     * @param text The string value to check.
+     * @param preserveWS Whether or not to preserve
+     *  ignorable whitespace.
+     * @return  If 'text' constitutes a valid XML document,
+     *  it has been stored in this XML value and nothing
+     *  is returned; otherwise, an exception is thrown.
+     * @exception StandardException Thrown on parse error.
+     */
+    public void parseAndLoadXML(String text, boolean preserveWS)
+        throws StandardException
+    {
+        try {
+
+            if (preserveWS) {
+            // We're just going to use the text exactly as it
+            // is, so we just need to see if it parses. 
+                loadSAXReader();
+                saxReader.parse(
+                    new InputSource(new StringReader(text)));
+            }
+            else {
+            // We don't support this yet, so we shouldn't
+            // get here.
+                if (SanityManager.DEBUG)
+                    SanityManager.THROWASSERT("Tried to STRIP whitespace " +
+                        "but we shouldn't have made it this far");
+            }
+
+        } catch (Exception xe) {
+        // The text isn't a valid XML document.  Throw a StandardException
+        // with the parse exception nested in it.
+            throw StandardException.newException(
+                SQLState.LANG_NOT_AN_XML_DOCUMENT, xe);
+        }
+
+        // If we get here, the text is valid XML so go ahead
+        // and load/store it.
+        if (xmlStringValue == null)
+            xmlStringValue = new SQLChar();
+        xmlStringValue.setValue(text);
+        return;
+    }
+
+    /**
+     * The SQL/XML XMLSerialize operator.
+     * Converts this XML value into a string with a user-specified
+     * type, and returns that string via the received StringDataValue
+     * (if the received StringDataValue is non-null; else a new
+     * StringDataValue is returned).
+     * @param result The result of a previous call to this method,
+     *    null if not called yet.
+     * @param targetType The string type to which we want to serialize.
+     * @param targetWidth The width of the target type.
+     * @return A serialized (to string) version of this XML object,
+     *  in the form of a StringDataValue object.
+     * @exception StandardException    Thrown on error
+     */
+    public StringDataValue XMLSerialize(StringDataValue result,
+        int targetType, int targetWidth) throws StandardException
+    {
+        if (result == null) {
+            switch (targetType)
+            {
+                case Types.CHAR:        result = new SQLChar(); break;
+                case Types.VARCHAR:     result = new SQLVarchar(); break;
+                case Types.LONGVARCHAR: result = new SQLLongvarchar(); break;
+                case Types.CLOB:        result = new SQLClob(); break;
+                default:
+                // Shouldn't ever get here, as this check was performed
+                // at bind time.
+
+                    if (SanityManager.DEBUG) {
+                        SanityManager.THROWASSERT(
+                            "Should NOT have made it to XMLSerialize " +
+                            "with a non-string target type.");
+                    }
+                    return null;
+            }
+        }
+
+        // Else we're reusing a StringDataValue.  We only reuse
+        // the result if we're executing the _same_ XMLSERIALIZE
+        // call on multiple rows.  That means that all rows
+        // must have the same result type (targetType) and thus
+        // we know that the StringDataValue already has the
+        // correct type.  So we're set.
+
+        if (this.isNull()) {
+        // Attempts to serialize a null XML value lead to a null
+        // result (SQL/XML[2003] section 10.13).
+            result.setToNull();
+            return result;
+        }
+
+        // Get the XML value as a string.  For this UTF-8 impl,
+        // we already have it as a string, so just use that.
+        result.setValue(xmlStringValue.getString());
+
+        // Seems wrong to trunc an XML document, as it then becomes non-
+        // well-formed and thus useless.  So we throw an error (that's
+        // what the "true" in the next line says).
+        result.setWidth(targetWidth, 0, true);
+        return result;
+    }
+
+    /**
+     * The SQL/XML XMLExists operator.
+     * Takes an XML query expression (as a string) and an XML
+     * value and checks if at least one node in the XML
+     * value matches the query expression.  NOTE: For now,
+     * the query expression must be XPath only (XQuery not
+     * supported).
+     * @param xExpr The query expression, as a string.
+     * @param xml The XML value being queried.
+     * @return True if the received query expression matches at
+     *  least one node in the received XML value; unknown if
+     *  either the query expression or the xml value is null;
+     *  false otherwise.
+     * @exception StandardException Thrown on error
+     */
+    public BooleanDataValue XMLExists(StringDataValue xExpr,
+        XMLDataValue xml) throws StandardException
+    {
+        if ((xExpr == null) || xExpr.isNull())
+        // If the query is null, we assume unknown.
+            return SQLBoolean.unknownTruthValue();
+
+        if ((xml == null) || xml.isNull())
+        // Then per SQL/XML spec 8.4, we return UNKNOWN.
+            return SQLBoolean.unknownTruthValue();
+
+        return new SQLBoolean(xml.exists(xExpr.getString()));
+    }
+
+    /**
+     * Helper method for XMLExists.
+     * See if the received XPath expression returns at least
+     * one node when evaluated against _this_ XML value.
+     * @param xExpr The XPath expression.
+     * @return True if at least one node in this XML value
+     *  matches the received xExpr; false otherwise.
+     */
+    public boolean exists(String xExpr) throws StandardException
+    {
+        // NOTE: At some point we'll probably need to implement some
+        // some kind of query cache so that we don't have to recompile
+        // the same query over and over for every single XML row
+        // in a table.  That's what we do right now...
+
+        try {
+
+            xExpr = replaceDoubleQuotes(xExpr);
+            loadXSLTObjects();
+
+            // Take our simple stylesheet and plug in the query.
+            int pos = xsltStylesheet.indexOf(XPATH_PLACEHOLDER);
+            StringBuffer stylesheet = new StringBuffer(xsltStylesheet);
+            stylesheet.replace(pos, pos + XPATH_PLACEHOLDER.length(), xExpr);
+
+            // Create a Templates ContentHandler to handle parsing of the 
+            // stylesheet.
+            TemplatesHandler templatesHandler = 
+                saxTFactory.newTemplatesHandler();
+            xsltReader.setContentHandler(templatesHandler);
+    
+            // Now parse the generic stylesheet we created.
+            xsltReader.parse(
+                new InputSource(new StringReader(stylesheet.toString())));
+
+            // Get the Templates object (generated during the parsing of
+            // the stylesheet) from the TemplatesHandler.
+            Templates compiledQuery = templatesHandler.getTemplates();
+
+            // Create a Transformer ContentHandler to handle parsing of 
+            // the XML Source.  
+            TransformerHandler transformerHandler 
+                = saxTFactory.newTransformerHandler(compiledQuery);
+
+            // Reset the XMLReader's ContentHandler to the TransformerHandler.
+            xsltReader.setContentHandler(transformerHandler);
+
+            // Create an ExistsHandler.  When the XSLT transformation
+            // occurs, a period (".") will be thrown to this handler
+            // (via a SAX 'characters' event) for every matching
+            // node that XSLT finds.  This is how we know if a
+            // match was found.
+            ExistsHandler eH = new ExistsHandler();
+            transformerHandler.setResult(new SAXResult(eH));
+
+            // This call to "parse" is what does the query, because we
+            // passed in an XSLT handler with the compiled query above.
+            try {
+                xsltReader.parse(
+                    new InputSource(new StringReader(getString())));
+            } catch (Throwable th) {
+                if (th.getMessage().indexOf(
+                    "SAXException: " + QUERY_MATCH_STRING) == -1)
+                { // then this isn't the exception that means we have
+                  // a match; so re-throw it.
+                    throw new Exception(th.getMessage());
+                }
+            }
+
+            // Did we have any matches?
+            return eH.exists();
+
+        } catch (Exception xe) {
+        // We don't expect to get here.  Turn it into a
+        // StandardException, then throw it.
+            throw StandardException.newException(
+                SQLState.LANG_UNEXPECTED_XML_EXCEPTION, xe);
+        }
+    }
+
+    /* ****
+     * Helper classes and methods.
+     * */
+
+    /**
+     * Load an XMLReader for SAX events that can be used
+     * for parsing XML data.
+     *
+     * This method is currently only used for XMLPARSE, and
+     * the SQL/XML[2003] spec says that XMLPARSE should NOT
+     * perform validation -- Seciont 6.11:
+     *
+     *    "Perform a non-validating parse of a character string to
+     *    produce an XML value."
+     *
+     * Thus, we make sure to disable validation on the XMLReader
+     * loaded here.  At some point in the future we will probably
+     * want to add support for the XMLVALIDATE function--but until
+     * then, user is unable to validate the XML values s/he inserts.
+     *
+     * Note that, even with validation turned off, XMLPARSE
+     * _will_ still check the well-formedness of the values,
+     * and it _will_ still process DTDs to get default values,
+     * etc--but that's it; no validation errors will be thrown.
+     *
+     * For future reference: the features needed to perform
+     * validation (with Xerces) are:
+     *
+     * http://apache.org/xml/features/validation/schema
+     * http://apache.org/xml/features/validation/dynamic
+     */
+    protected void loadSAXReader() throws Exception
+    {
+        if (saxReader != null)
+        // already loaded.
+            return;
+
+        // Get an instance of an XMLReader.
+        saxReader = XMLReaderFactory.createXMLReader(XML_PARSER_CLASS);
+
+        // Turn off validation, since it's not allowed by
+        // SQL/XML[2003] spec.
+        saxReader.setFeature(
+            "http://xml.org/sax/features/validation", false);
+
+        // Make the parser namespace aware.
+        saxReader.setFeature(
+            "http://xml.org/sax/features/namespaces", true);
+
+        // We have to set the error handler in order to properly
+        // receive the parse errors.
+        saxReader.setErrorHandler(new XMLErrorHandler());
+    }
+
+    /**
+     * Prepare for an XSLT query by loading the objects
+     * required for such a query.  We should only have
+     * to do this once per XML object.
+     */
+    private void loadXSLTObjects() throws SAXException
+    {
+        if (xsltReader != null)
+        // we already loaded everything.
+            return;
+
+        // Instantiate a TransformerFactory.
+        TransformerFactory tFactory = TransformerFactory.newInstance();
+
+        // Cast the TransformerFactory to SAXTransformerFactory.
+        saxTFactory = (TransformerFactoryImpl)tFactory;
+
+        // Get an XML reader.
+        xsltReader = XMLReaderFactory.createXMLReader(XML_PARSER_CLASS);
+
+        // Make the parser namespace aware.  Note that because we
+        // only support a small subset of SQL/XML, and because we
+        // only allow XPath (as opposed to XQuery) expressions,
+        // there is no way for a user to specify namespace
+        // bindings as part of the XMLEXISTS operator.  This means
+        // that in order to query for a node name, the user must
+        // use the XPath functions "name()" and "local-name()"
+        // in conjunction with XPath 1.0 'namespace' axis.  For
+        // example:
+        //
+        // To see if any elements exist that have a specific name
+        // with ANY namespace:
+        //     //child::*[local-name()="someName"]
+        //
+        // To see if any elements exist that have a specific name
+        // with NO namespace:
+        //     //child::*[name()="someName"]
+        //
+        // To see if any elements exist that have a specific name
+        // in a specific namespace:
+        //     //child::*[local-name()=''someName'' and
+        //        namespace::*[string()=''http://www.some.namespace'']]
+        //
+        xsltReader.setFeature(
+            "http://xml.org/sax/features/namespaces", true);
+
+        // Create a very simple XSLT stylesheet.  This stylesheet
+        // will execute the XPath expression and, for every match,
+        // write a period (".") to the ExistsHandler (see the exists()
+        // method above).  Then, in order to see if at least one
+        // node matches, we just check to see if the ExistsHandler
+        // caught at least one 'characters' event.  If it did, then
+        // we know we had a match.
+        if (xsltStylesheet == null) {
+            StringBuffer sb = new StringBuffer();
+            sb.append("<xsl:stylesheet version=\"1.0\"\n");
+            sb.append("xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n");
+            sb.append(" <xsl:template match=\"/\">\n"); // Search whole doc...
+            sb.append("  <xsl:for-each select=\"");     // For every match...
+            sb.append(XPATH_PLACEHOLDER);               // using XPath expr...
+            sb.append("\">.</xsl:for-each>\n");         // Write a "."
+            sb.append(" </xsl:template>\n");
+            sb.append("</xsl:stylesheet>\n");
+            xsltStylesheet = sb.toString();
+        }
+    }
+
+    /**
+     * Takes a string (which is an XPath query specified by
+     * the user) and replaces any double quotes with single
+     * quotes.  We have to do this because a double quote
+     * in the XSLT stylesheet (which is where the user's
+     * query ends up) will be parsed as a query terminator
+     * thus will cause XSLT execution errors.
+     * @param queryText Text in which we want to replace double
+     *  quotes.
+     * @return queryText with all double quotes replaced by
+     *  single quotes.
+     */
+    private String replaceDoubleQuotes(String queryText)
+    {
+        int pos = queryText.indexOf("\"");
+        if (pos == -1)
+        // nothing to do.
+            return queryText;
+
+        StringBuffer sBuf = new StringBuffer(queryText);
+        while (pos >= 0) {
+            sBuf.replace(pos, pos+1, "'");
+            pos = queryText.indexOf("\"", pos+1);
+        }
+        return sBuf.toString();
+    }
+
+    /*
+     ** The XMLErrorHandler class is just a generic implementation
+     ** of the ErrorHandler interface.  It allows us to catch
+     ** and process XML parsing errors in a graceful manner.
+     */
+    private class XMLErrorHandler implements ErrorHandler
+    {
+        public void error (SAXParseException exception)
+            throws SAXException
+        {
+            throw new SAXException (exception);
+        }
+
+        public void fatalError (SAXParseException exception)
+            throws SAXException
+        {
+            throw new SAXException (exception);
+        }
+
+        public void warning (SAXParseException exception)
+            throws SAXException
+        {
+            throw new SAXException (exception);
+        }
+    }
+
+    /*
+     ** The ExistsHandler is what we pass to the XSLT processor
+     ** when we query.  The generic xsltStylesheet that we defined
+     ** above will throw a 'characters' event for every matching
+     ** node that is found by the XSLT transformation.  This
+     ** handler is the one that catches the event, and thus
+     ** it tells us whether or not we had a match.
+     */
+    private class ExistsHandler extends DefaultHandler
+    {
+        // Did we catch at least one 'characters' event?
+        private boolean atLeastOneMatch;
+
+        public ExistsHandler() {
+            atLeastOneMatch = false;
+        }
+
+        /*
+         * Catch a SAX 'characters' event, which tells us that
+         * we had at least one matching node.
+         */
+        public void characters(char[] ch, int start, int length)
+            throws SAXException
+        {
+            // If we get here, we had at least one matching node.
+            // Since that's all we need to know, we don't have
+            // to continue querying--we can stop the XSLT
+            // transformation now by throwing a SAX exception.
+            atLeastOneMatch = true;
+            throw new SAXException(QUERY_MATCH_STRING);
+        }
+
+        /*
+         * Tell whether or not this handler caught a match.
+         */
+        public boolean exists()
+        {
+            return atLeastOneMatch;
+        }
+    }
+}
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/XMLDataValue.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/XMLDataValue.java
index e69de29b..c9d3a278 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/XMLDataValue.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/iapi/types/XMLDataValue.java
@@ -0,0 +1,106 @@
+/*
+
+   Derby - Class org.apache.derby.iapi.types.XMLDataValue
+
+   Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.iapi.types;
+
+import org.apache.derby.iapi.error.StandardException;
+
+public interface XMLDataValue extends DataValueDescriptor
+{
+    /*
+     ** NOTE: Officially speaking, the XMLParse operator
+     ** is not defined here; it is instead defined on the
+     ** StringDataValue interface (and implemented in
+     ** SQLChar.java) since it is called with a _String_
+     ** operand, not with an XML operand.  That said,
+     ** though, the implemention in SQLChar.java
+     ** really just calls the "parseAndLoadXML" method that's
+     ** defined on this interface, so it's this interface
+     ** that really does the work.
+     **
+     ** XMLSerialize and XMLExists, on the other hand,
+     ** are called with XML operands, and thus they
+     ** can just be defined in this interface.
+     */
+
+    /**
+     * Parse the received string value as XML.  If the
+     * parse succeeds, store the string value as the
+     * contents of this XML value.
+     *
+     * @param text The string value to check.
+     * @param preserveWS Whether or not to preserve
+     *  ignorable whitespace.
+     * @return  If 'text' constitutes a valid XML document,
+     *  it has been stored in this XML value and nothing
+     *  is returned; otherwise, an exception is thrown.
+     * @exception StandardException Thrown on parse error.
+     */
+    public void parseAndLoadXML(String xmlText, boolean preserveWS)
+        throws StandardException;
+
+    /**
+     * The SQL/XML XMLSerialize operator.
+     * Converts this XML value into a string with a user-specified
+     * type, and returns that string via the received StringDataValue.
+     * (if the received StringDataValue is non-null and of the
+     * correct type; else, a new StringDataValue is returned).
+     *
+     * @param result The result of a previous call to this method,
+     *  null if not called yet.
+     * @param targetType The string type to which we want to serialize.
+     * @param targetWidth The width of the target type.
+     * @return A serialized (to string) version of this XML object,
+     *  in the form of a StringDataValue object.
+     * @exception StandardException Thrown on error
+     */
+    public StringDataValue XMLSerialize(StringDataValue result,
+        int targetType, int targetWidth) throws StandardException;
+
+    /**
+     * The SQL/XML XMLExists operator.
+     * Takes an XML query expression (as a string) and an XML
+     * value and checks if at least one node in the XML
+     * value matches the query expression.  NOTE: For now,
+     * the query expression must be XPath only (XQuery not
+     * supported).
+     *
+     * @param xExpr The query expression, as a string.
+     * @param xml The XML value being queried.
+     * @return True if the received query expression matches at
+     *  least one node in the received XML value; unknown if
+     *  either the query expression or the xml value is null;
+     *  false otherwise.
+     * @exception StandardException Thrown on error
+     */
+    public BooleanDataValue XMLExists(StringDataValue xExpr,
+        XMLDataValue xml) throws StandardException;
+
+    /**
+     * Helper method for XMLExists.
+     * See if the received XPath expression returns at least
+     * one node when evaluated against _this_ XML value.
+     *
+     * @param xExpr The XPath expression.
+     * @return True if at least one node in this XML value
+     *  matches the received xExpr; false otherwise.
+     */
+    public boolean exists(String xExpr) throws StandardException;
+}
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/Util.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/Util.java
index 509d6701..5c3ae440 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/Util.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/Util.java
@@ -24,6 +24,7 @@
 import org.apache.derby.iapi.services.i18n.MessageService;
 
 import org.apache.derby.iapi.services.sanity.SanityManager;
+import org.apache.derby.iapi.services.io.StoredFormatIds;
 import org.apache.derby.iapi.types.TypeId;
 
 import org.apache.derby.iapi.error.ExceptionSeverity;
@@ -274,6 +275,7 @@ public static String typeName(int jdbcType) {
 
 			case Types.OTHER		:  return "OTHER";
 			case Types.JAVA_OBJECT	:  return "Types.JAVA_OBJECT";
+			case StoredFormatIds.XML_TYPE_ID :  return TypeId.XML_NAME;
 			default : return String.valueOf(jdbcType);
 		}
 	}
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java
index 28cf0998..29e3fef5 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java
@@ -33,6 +33,7 @@
 import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
 import org.apache.derby.iapi.types.StringDataValue;
 import org.apache.derby.iapi.types.TypeId;
+import org.apache.derby.iapi.types.DataTypeDescriptor;
 
 import org.apache.derby.iapi.store.access.Qualifier;
 
@@ -42,6 +43,7 @@
 import org.apache.derby.iapi.util.JBitSet;
 import org.apache.derby.iapi.services.classfile.VMOpcode;
 
+import java.sql.Types;
 import java.util.Vector;
 
 /**
@@ -82,6 +84,37 @@
 
 	String		leftInterfaceType;
 	String		rightInterfaceType;
+	String		resultInterfaceType;
+	int			operatorType;
+
+	// At the time of adding XML support, it was decided that
+	// we should avoid creating new OperatorNodes where possible.
+	// So for the XML-related binary operators we just add the
+	// necessary code to _this_ class, similar to what is done in
+	// TernarnyOperatorNode. Subsequent binary operators (whether
+	// XML-related or not) should follow this example when
+	// possible.
+
+	public final static int XMLEXISTS_OP = 0;
+
+	// NOTE: in the following 4 arrays, order
+	// IS important.
+
+	static final String[] BinaryOperators = {
+		"xmlexists",
+	};
+
+	static final String[] BinaryMethodNames = {
+		"XMLExists",
+	};
+
+	static final String[] BinaryResultTypes = {
+		ClassName.BooleanDataValue		// XMLExists
+	};
+
+	static final String[][] BinaryArgTypes = {
+		{ClassName.StringDataValue, ClassName.XMLDataValue}		// XMLExists
+	};
 
 	/**
 	 * Initializer for a BinaryOperatorNode
@@ -109,6 +142,7 @@ public void init(
 		this.methodName = (String) methodName;
 		this.leftInterfaceType = (String) leftInterfaceType;
 		this.rightInterfaceType = (String) rightInterfaceType;
+		this.operatorType = -1;
 	}
 
 	public void init(
@@ -121,6 +155,30 @@ public void init(
 		this.rightOperand = (ValueNode) rightOperand;
 		this.leftInterfaceType = (String) leftInterfaceType;
 		this.rightInterfaceType = (String) rightInterfaceType;
+		this.operatorType = -1;
+	}
+
+	/**
+	 * Initializer for a BinaryOperatorNode
+	 *
+	 * @param leftOperand	The left operand of the node
+	 * @param rightOperand	The right operand of the node
+	 * @param opType  An Integer holding the operatorType
+	 *  for this operator.
+	 */
+	public void init(
+			Object leftOperand,
+			Object rightOperand,
+			Object opType)
+	{
+		this.leftOperand = (ValueNode)leftOperand;
+		this.rightOperand = (ValueNode)rightOperand;
+		this.operatorType = ((Integer)opType).intValue();
+		this.operator = BinaryOperators[this.operatorType];
+		this.methodName = BinaryMethodNames[this.operatorType];
+		this.leftInterfaceType = BinaryArgTypes[this.operatorType][0];
+		this.rightInterfaceType = BinaryArgTypes[this.operatorType][1];
+		this.resultInterfaceType = BinaryResultTypes[this.operatorType];
 	}
 
 	/**
@@ -154,6 +212,7 @@ public String toString()
 	void setOperator(String operator)
 	{
 		this.operator = operator;
+		this.operatorType = -1;
 	}
 
 	/**
@@ -166,6 +225,7 @@ void setOperator(String operator)
 	void setMethodName(String methodName)
 	{
 		this.methodName = methodName;
+		this.operatorType = -1;
 	}
 
 	/**
@@ -179,6 +239,7 @@ public void setLeftRightInterfaceType(String iType)
 	{
 		leftInterfaceType = iType;
 		rightInterfaceType = iType;
+		this.operatorType = -1;
 	}
 
 	/**
@@ -248,6 +309,8 @@ public ValueNode bindExpression(
 		rightOperand = rightOperand.bindExpression(fromList, subqueryList, 
 			aggregateVector);
 
+		if (operatorType == XMLEXISTS_OP)
+			return bindXMLExists();
 
 		/* Is there a ? parameter on the left? */
 		if (leftOperand.isParameterNode())
@@ -275,6 +338,75 @@ public ValueNode bindExpression(
 		return genSQLJavaSQLTree();
 	}
 
+    /**
+     * Bind an XMLEXISTS operator.  Makes sure the operand type
+     * and target type are both correct, and sets the result type.
+     *
+     * @exception StandardException Thrown on error
+     */
+    public ValueNode bindXMLExists() throws StandardException
+    {
+        // Check operand types.
+        TypeId leftOperandType = leftOperand.getTypeId();
+        TypeId rightOperandType = rightOperand.getTypeId();
+
+        // Left operand is query expression, and must be a string.
+        if (leftOperandType != null) {
+            switch (leftOperandType.getJDBCTypeId())
+            {
+                case Types.CHAR:
+                case Types.VARCHAR:
+                case Types.LONGVARCHAR:
+                case Types.CLOB:
+                    break;
+                default:
+                {
+                    throw StandardException.newException(
+                        SQLState.LANG_BINARY_OPERATOR_NOT_SUPPORTED, 
+                        methodName,
+                        leftOperandType.getSQLTypeName(),
+                        rightOperandType.getSQLTypeName());
+                }
+            }
+        }
+
+        // Right operand is an XML data value.
+        if ((rightOperandType != null) &&
+            !rightOperandType.isXMLTypeId())
+        {
+            throw StandardException.newException(
+                SQLState.LANG_BINARY_OPERATOR_NOT_SUPPORTED, 
+                    methodName,
+                    leftOperandType.getSQLTypeName(),
+                    rightOperandType.getSQLTypeName());
+        }
+
+        // Is there a ? parameter on the left?
+        if (leftOperand.isParameterNode())
+        {
+            // Set the left operand to be a VARCHAR, which should be
+            // long enough to hold the XPath expression.
+            ((ParameterNode) leftOperand).setDescriptor(
+                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR));
+        }
+
+        // Is there a ? parameter on the right?
+        if (rightOperand.isParameterNode())
+        {
+            // For now, since JDBC has no type defined for XML, we
+            // don't allow binding to an XML parameter.
+            throw StandardException.newException(
+                SQLState.LANG_ATTEMPT_TO_BIND_XML);
+        }
+
+        // Set the result type of this XMLExists operator--it's always
+        // SQLBoolean.  The "true" in the next line says that the result
+        // can be nullable--which it can be if evaluation of the expression
+        // returns a null (this is per SQL/XML spec section 8.4).
+        setType(new DataTypeDescriptor(TypeId.BOOLEAN_ID, true));
+        return genSQLJavaSQLTree();
+    }
+
 	/** generate a SQL->Java->SQL conversion tree above the left and right
 	 * operand of this Binary Operator Node if needed. Subclasses can override
 	 * the default behavior.
@@ -364,7 +496,9 @@ public void generateExpression(ExpressionClassBuilder acb,
 			** a class, they can note that in the implementation
 			** of the node that uses the method.
 			*/
-		    receiverType = getReceiverInterfaceName();
+		    receiverType = (operatorType == -1)
+				? getReceiverInterfaceName()
+				: leftInterfaceType;
 
 			/*
 			** Generate (with <left expression> only being evaluated once)
@@ -394,7 +528,9 @@ public void generateExpression(ExpressionClassBuilder acb,
 			** a class, they can note that in the implementation
 			** of the node that uses the method.
 			*/
-		    receiverType = getReceiverInterfaceName();
+		    receiverType = (operatorType == -1)
+				? getReceiverInterfaceName()
+				: rightInterfaceType;
 
 			/*
 			** Generate (with <right expression> only being evaluated once)
@@ -419,7 +555,9 @@ public void generateExpression(ExpressionClassBuilder acb,
 		}
 
 		/* Figure out the result type name */
-		resultTypeName = getTypeCompiler().interfaceName();
+		resultTypeName = (operatorType == -1)
+			? getTypeCompiler().interfaceName()
+			: resultInterfaceType;
 
 		// Boolean return types don't need a result field
 		boolean needField = !getTypeId().isBooleanTypeId();
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/C_NodeNames.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/C_NodeNames.java
index e7fd95b3..50e73cd0 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/C_NodeNames.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/C_NodeNames.java
@@ -56,6 +56,8 @@
 
 	static final String BINARY_ARITHMETIC_OPERATOR_NODE_NAME = "org.apache.derby.impl.sql.compile.BinaryArithmeticOperatorNode";
 
+	static final String BINARY_OPERATOR_NODE_NAME = "org.apache.derby.impl.sql.compile.BinaryOperatorNode";
+
 	static final String BINARY_RELATIONAL_OPERATOR_NODE_NAME = "org.apache.derby.impl.sql.compile.BinaryRelationalOperatorNode";
 
 	static final String BIT_CONSTANT_NODE_NAME = "org.apache.derby.impl.sql.compile.BitConstantNode";
@@ -253,6 +255,8 @@
 	static final String UNARY_DATE_TIMESTAMP_OPERATOR_NODE_NAME
     = "org.apache.derby.impl.sql.compile.UnaryDateTimestampOperatorNode";
 
+	static final String UNARY_OPERATOR_NODE_NAME = "org.apache.derby.impl.sql.compile.UnaryOperatorNode";
+
 	static final String UNION_NODE_NAME = "org.apache.derby.impl.sql.compile.UnionNode";
 
 	static final String INTERSECT_OR_EXCEPT_NODE_NAME = "org.apache.derby.impl.sql.compile.IntersectOrExceptNode";
@@ -271,9 +275,11 @@
 
 	static final String SAVEPOINT_NODE_NAME = "org.apache.derby.impl.sql.compile.SavepointNode";
 
+	static final String XML_CONSTANT_NODE_NAME = "org.apache.derby.impl.sql.compile.XMLConstantNode";
+
 	// The names are in alphabetic order.
 	//
     // WARNING: WHEN ADDING NODE TYPES HERE, YOU MUST ALSO ADD
-    // THEM TO $WS/tools/release/config/dbms/cloudscapenodes.properties
+    // THEM TO tools/jar/DBMSnodes.properties
 
 }
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CharTypeCompiler.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CharTypeCompiler.java
index 09cad3b1..e0eaa53e 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CharTypeCompiler.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CharTypeCompiler.java
@@ -102,10 +102,10 @@ public boolean convertible(TypeId otherType, boolean forDataTypeFunction)
 				return (getTypeId().isStringTypeId());
 
 			// can't CAST to CHAR and VARCHAR from REAL or DOUBLE
-			// or binary types
+			// or binary types or XML
 			// all other types are ok.
 			if (otherType.isFloatingPointTypeId() || otherType.isBitTypeId() ||
-				otherType.isBlobTypeId())
+				otherType.isBlobTypeId() || otherType.isXMLTypeId())
 				return false;
 						
 			return true;
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/DB2LengthOperatorNode.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/DB2LengthOperatorNode.java
index cd957f45..44ac4207 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/DB2LengthOperatorNode.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/DB2LengthOperatorNode.java
@@ -83,6 +83,15 @@ public ValueNode bindExpression(
 			throws StandardException
 	{
         ValueNode boundExpression = super.bindExpression( fromList, subqueryList, aggregateVector);
+
+        // This operator is not allowed on XML types.
+        TypeId operandType = operand.getTypeId();
+        if (operandType.isXMLTypeId()) {
+            throw StandardException.newException(SQLState.LANG_UNARY_FUNCTION_BAD_TYPE,
+                                    getOperatorString(),
+                                    operandType.getSQLTypeName());
+        }
+
         setType( new DataTypeDescriptor( TypeId.getBuiltInTypeId( Types.INTEGER),
                                          operand.getTypeServices().isNullable()));
         return boundExpression;
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NodeFactoryImpl.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NodeFactoryImpl.java
index ede98131..f4a3d6fd 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NodeFactoryImpl.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NodeFactoryImpl.java
@@ -70,7 +70,7 @@
 	/* Do join order optimization by default */
 	private Boolean joinOrderOptimization = Boolean.TRUE;
 
-	private final ClassInfo[]	nodeCi = new ClassInfo[200];
+	private final ClassInfo[]	nodeCi = new ClassInfo[205];
 
 	//////////////////////////////////////////////////////////////////////
 	//
@@ -189,7 +189,7 @@ protected String nodeName(int nodeType)
 		switch (nodeType)
 		{
 		  // WARNING: WHEN ADDING NODE TYPES HERE, YOU MUST ALSO ADD
-		  // THEM TO $WS/tools/release/config/dbms/cloudscapenodes.properties
+		  // THEM TO tools/jar/DBMSnode.properties
 			// xxxRESOLVE: why not make this a giant array and simply index into
 			// it? manish Thu Feb 22 14:49:41 PST 2001  
 		  case C_NodeTypes.CURRENT_ROW_LOCATION_NODE:
@@ -319,6 +319,9 @@ protected String nodeName(int nodeType)
           case C_NodeTypes.CLOB_CONSTANT_NODE:
 			return C_NodeNames.CHAR_CONSTANT_NODE_NAME;
 
+          case C_NodeTypes.XML_CONSTANT_NODE:
+			return C_NodeNames.XML_CONSTANT_NODE_NAME;
+
 		  case C_NodeTypes.COLUMN_REFERENCE:
 		  	return C_NodeNames.COLUMN_REFERENCE_NAME;
 
@@ -566,6 +569,13 @@ protected String nodeName(int nodeType)
 		  case C_NodeTypes.DB2_LENGTH_OPERATOR_NODE:
             return C_NodeNames.DB2_LENGTH_OPERATOR_NODE_NAME;
 
+          case C_NodeTypes.XML_PARSE_OPERATOR_NODE:
+          case C_NodeTypes.XML_SERIALIZE_OPERATOR_NODE:
+            return C_NodeNames.UNARY_OPERATOR_NODE_NAME;
+
+          case C_NodeTypes.XML_EXISTS_OPERATOR_NODE:
+            return C_NodeNames.BINARY_OPERATOR_NODE_NAME;
+
 		  // WARNING: WHEN ADDING NODE TYPES HERE, YOU MUST ALSO ADD
 		  // THEM TO tools/jar/DBMSnodes.properties
 
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ParameterNode.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ParameterNode.java
index 6ab0e41f..d5c06a20 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ParameterNode.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ParameterNode.java
@@ -41,6 +41,7 @@
 import org.apache.derby.iapi.sql.ParameterValueSet;
 import org.apache.derby.iapi.sql.Activation;
 import org.apache.derby.iapi.reference.ClassName;
+import org.apache.derby.iapi.reference.SQLState;
 
 import org.apache.derby.iapi.sql.conn.LanguageConnectionContext;
 
@@ -379,6 +380,18 @@ public void generateExpression(ExpressionClassBuilder acb,
 											MethodBuilder mb)
 									throws StandardException
 	{
+		DataTypeDescriptor dtd = getTypeServices();
+		if ((dtd != null) && dtd.getTypeId().isXMLTypeId()) {
+		// We're a parameter that corresponds to an XML column/target,
+		// which we don't allow.  We throw the error here instead of
+		// in "bindExpression" because at the time of bindExpression,
+		// we don't know yet what the type is going to be (only when
+		// the node that points to this parameter calls
+		// "setDescriptor" do we figure out the type).
+			throw StandardException.newException(
+				SQLState.LANG_ATTEMPT_TO_BIND_XML);
+		}
+
 		// PUSHCOMPILE
 		/* Reuse code if possible */
 		//if (genRetval != null)
@@ -402,7 +415,6 @@ public void generateExpression(ExpressionClassBuilder acb,
 		// For some types perform host variable checking
 		// to match DB2/JCC where if a host variable is too
 		// big it is not accepted, regardless of any trailing padding.
-		DataTypeDescriptor dtd = getTypeServices();
 
 		switch (dtd.getJDBCTypeId()) {
 		case Types.BINARY:
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/QueryTreeNode.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/QueryTreeNode.java
index 9b2dc542..87ac5d02 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/QueryTreeNode.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/QueryTreeNode.java
@@ -33,6 +33,7 @@
 import org.apache.derby.iapi.services.compiler.MethodBuilder;
 import org.apache.derby.iapi.services.monitor.Monitor;
 import org.apache.derby.iapi.services.sanity.SanityManager;
+import org.apache.derby.iapi.services.io.StoredFormatIds;
 import org.apache.derby.iapi.error.StandardException;
 import org.apache.derby.iapi.sql.compile.CompilerContext;
 import org.apache.derby.iapi.sql.compile.NodeFactory;
@@ -980,6 +981,13 @@ public  ConstantNode getNullNode(TypeId typeId,
 										cm);
 			break;
 
+		  case StoredFormatIds.XML_TYPE_ID:
+			constantNode = nf.getNode(
+										C_NodeTypes.XML_CONSTANT_NODE,
+										typeId,
+										cm);
+			break;
+
 		  default:
 			if (typeId.getSQLTypeName().equals("BOOLEAN"))
 			{
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ReadCursorNode.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ReadCursorNode.java
index 4594a64e..e9e9eaf8 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ReadCursorNode.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ReadCursorNode.java
@@ -81,6 +81,10 @@
 		// types for this node
 		resultSet.bindUntypedNullsToResultColumns(null);
 
+		// Reject any XML values in the select list; JDBC doesn't
+		// define how we bind these out, so we don't allow it.
+		resultSet.rejectXMLValues();
+
 		/* Verify that all underlying ResultSets reclaimed their FromList */
 		if (SanityManager.DEBUG)
 		{
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
index e7edafe0..c9ba77d2 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
@@ -120,6 +120,10 @@
 	// Is a count mismatch allowed - see set/get methods for details.
 	private boolean countMismatchAllowed;
 
+	// Number of RCs in this RCL at "init" time, before additional
+	// ones were added internally.
+	private int initialListSize = 0;
+
 	public ResultColumnList()
 	{
 	}
@@ -1472,6 +1476,11 @@ public void expandAllsAndNameColumns(FromList fromList)
 				{
 					insertElementAt(allExpansion.elementAt(inner), index + inner);
 				}
+
+				// If the rc was a "*", we need to set the initial list size
+				// to the number of columns that are actually returned to
+				// the user.
+				markInitialSize();
 			}
 			else
 			{
@@ -1952,6 +1961,71 @@ void rejectParameters() throws StandardException
 		}
 	}
 
+	/**
+	 * Check for (and reject) XML values directly under the ResultColumns.
+	 * This is done for SELECT/VALUES statements.  We reject values
+	 * in this case because JDBC does not define an XML type/binding
+	 * and thus there's no standard way to pass such a type back
+	 * to a JDBC application.
+	 *
+	 * Note that we DO allow an XML column in a top-level RCL
+	 * IF that column was added to the RCL by _us_ instead of
+	 * by the user.  For example, if we have a table:
+	 *
+	 * create table t1 (i int, x xml)
+	 *
+	 * and the user query is:
+	 *
+	 * select i from t1 order by x
+	 *
+	 * the "x" column will be added (internally) to the RCL
+	 * as part of ORDER BY processing--and so we need to
+	 * allow that XML column to be bound without throwing
+	 * an error.  If, as in this case, the XML column reference
+	 * is invalid (we can't use ORDER BY on an XML column because
+	 * XML values aren't ordered), a more appropriate error
+	 * message should be returned to the user in later processing.
+	 * If we didn't allow for this, the user would get an
+	 * error saying that XML columns are not valid as part
+	 * of the result set--but as far as s/he knows, there
+	 * isn't such a column: only "i" is supposed to be returned
+	 * (the RC for "x" was added to the RCL by _us_ as part of
+	 * ORDER BY processing).
+	 *
+	 * ASSUMPTION: Any RCs that are generated internally and
+	 * added to this RCL (before this RCL is bound) are added
+	 * at the _end_ of the list.  If that's true, then any
+	 * RC with an index greater than the size of the initial
+	 * (user-specified) list must have been added internally
+	 * and will not be returned to the user.
+	 *
+	 * @return	Nothing
+	 *
+	 * @exception StandardException		Thrown if an XML value found
+	 *									directly under a ResultColumn
+	 */
+	void rejectXMLValues() throws StandardException
+	{
+		int sz = size();
+		ResultColumn rc = null;
+		for (int i = 1; i <= sz; i++) {
+
+			if (i > initialListSize)
+			// this RC was generated internally and will not
+			// be returned to the user, so don't throw error.
+				continue;
+
+			rc = getResultColumn(i);
+			if ((rc != null) && (rc.getType() != null) &&
+				rc.getType().getTypeId().isXMLTypeId())
+			{ // Disallow it.
+				throw StandardException.newException(
+					SQLState.LANG_ATTEMPT_TO_SELECT_XML);
+			}
+
+		}
+	}
+
 	/**
 	 * Set the resultSetNumber in all of the ResultColumns.
 	 *
@@ -3947,4 +4021,15 @@ public void copyOrderBySelect( ResultColumnList src)
     {
         orderBySelect = src.orderBySelect;
     }
+
+	/* ****
+	 * Take note of the size of this RCL _before_ we start
+	 * processing/binding it.  This is so that, at bind time,
+	 * we can tell if any columns in the RCL were added
+	 * internally by us (i.e. they were not specified by the
+	 * user and thus will not be returned to the user).
+	 */
+	protected void markInitialSize() {
+		initialListSize = size();
+	}
 }
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultSetNode.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultSetNode.java
index 69c13b4d..a553c9cb 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultSetNode.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultSetNode.java
@@ -990,6 +990,26 @@ public void rejectParameters() throws StandardException
 		}
 	}
 
+	/**
+	 * Check for (and reject) XML values directly under the ResultColumns.
+	 * This is done for SELECT/VALUES statements.  We reject values
+	 * in this case because JDBC does not define an XML type/binding
+	 * and thus there's no standard way to pass such a type back
+	 * to a JDBC application.
+	 *
+	 * @return	Nothing
+	 *
+	 * @exception StandardException		Thrown if an XML value found
+	 *									directly under a ResultColumn
+	 */
+	public void rejectXMLValues() throws StandardException
+	{
+		if (resultColumns != null)
+		{
+			resultColumns.rejectXMLValues();
+		}
+	}
+
 	/**
 	 * Rename generated result column names as '1', '2' etc... These will be the result
 	 * column names seen by JDBC clients.
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowResultSetNode.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowResultSetNode.java
index 4b182db1..589e8a73 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowResultSetNode.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowResultSetNode.java
@@ -80,6 +80,8 @@ public void init(Object valuesClause, Object tableProperties)
 	{
 		super.init(null, tableProperties);
 		resultColumns = (ResultColumnList) valuesClause;
+		if (resultColumns != null)
+			resultColumns.markInitialSize();
 	}
 
 	/**
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
index 4c3e1a95..4eb9837c 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
@@ -132,6 +132,8 @@ public void init(Object selectList,
 		 * Consider adding selectAggregates and whereAggregates 
 		 */
 		resultColumns = (ResultColumnList) selectList;
+		if (resultColumns != null)
+			resultColumns.markInitialSize();
 		this.fromList = (FromList) fromList;
 		this.whereClause = (ValueNode) whereClause;
 		this.originalWhereClause = (ValueNode) whereClause;
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/TypeCompilerFactoryImpl.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/TypeCompilerFactoryImpl.java
index 4226a5b7..3511f529 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/TypeCompilerFactoryImpl.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/TypeCompilerFactoryImpl.java
@@ -29,6 +29,7 @@
 import org.apache.derby.iapi.reference.JDBC20Translation;
 import org.apache.derby.iapi.reference.JDBC30Translation;
 
+import org.apache.derby.iapi.services.io.StoredFormatIds;
 import java.util.Properties;
 
 import java.sql.Types;
@@ -65,6 +66,7 @@
         static TypeCompiler blobTypeCompiler ;
         static TypeCompiler clobTypeCompiler ;
         static TypeCompiler nclobTypeCompiler ;
+        static TypeCompiler xmlTypeCompiler ;
 
         /**
          * Get a TypeCompiler corresponding to the given TypeId
@@ -256,6 +258,13 @@ static TypeCompiler staticGetTypeCompiler(TypeId typeId)
                                 btc.setTypeId(typeId);
                                 return btc;
                         }
+
+                  case StoredFormatIds.XML_TYPE_ID:
+                        return xmlTypeCompiler =
+                                getAnInstance(PACKAGE_NAME + "XMLTypeCompiler",
+                                                                xmlTypeCompiler,
+                                                                typeId);
+
                 }
 
                 if (SanityManager.DEBUG)
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java
index 2a0a3b06..c9da507c 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java
@@ -28,10 +28,15 @@
 import org.apache.derby.iapi.sql.dictionary.DataDictionary;
 
 import org.apache.derby.iapi.reference.SQLState;
+import org.apache.derby.iapi.reference.ClassName;
 import org.apache.derby.iapi.error.StandardException;
 import org.apache.derby.iapi.services.sanity.SanityManager;
 import org.apache.derby.iapi.services.compiler.MethodBuilder;
 import org.apache.derby.iapi.services.compiler.LocalField;
+import org.apache.derby.iapi.services.io.StoredFormatIds;
+
+import org.apache.derby.iapi.types.TypeId;
+import org.apache.derby.iapi.types.DataTypeDescriptor;
 
 import java.lang.reflect.Modifier;
 import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
@@ -39,6 +44,7 @@
 import org.apache.derby.iapi.util.JBitSet;
 import org.apache.derby.iapi.services.classfile.VMOpcode;
 
+import java.sql.Types;
 import java.util.Vector;
 
 /**
@@ -50,10 +56,14 @@
  * @author Jeff Lichtman
  */
 
-public abstract class UnaryOperatorNode extends ValueNode
+public class UnaryOperatorNode extends ValueNode
 {
 	String	operator;
 	String	methodName;
+	int operatorType;
+
+	String		resultInterfaceType;
+	String		receiverInterfaceType;
 
 	/**
 	 * WARNING: operand may be NULL for COUNT(*).  
@@ -65,22 +75,87 @@
 	public final static int NOT		= 3;
 	public final static int IS_NULL		= 4;
 
+	// At the time of adding XML support, it was decided that
+	// we should avoid creating new OperatorNodes where possible.
+	// So for the XML-related unary operators we just add the
+	// necessary code to _this_ class, similar to what is done in
+	// TernarnyOperatorNode. Subsequent unary operators (whether
+	// XML-related or not) should follow this example when
+	// possible.
+
+	public final static int XMLPARSE_OP = 0;
+	public final static int XMLSERIALIZE_OP = 1;
+
+	// NOTE: in the following 4 arrays, order
+	// IS important.
+
+	static final String[] UnaryOperators = {
+		"xmlparse",
+		"xmlserialize"
+	};
+
+	static final String[] UnaryMethodNames = {
+		"XMLParse",
+		"XMLSerialize"
+	};
+
+	static final String[] UnaryResultTypes = {
+		ClassName.XMLDataValue, 		// XMLParse
+		ClassName.StringDataValue		// XMLSerialize
+	};
+
+	static final String[] UnaryArgTypes = {
+		ClassName.StringDataValue,		// XMLParse
+		ClassName.XMLDataValue			// XMLSerialize
+	};
+
+	// Array to hold Objects that contain primitive
+	// args required by the operator method call.
+	private Object [] additionalArgs;
+
 	/**
 	 * Initializer for a UnaryOperatorNode
 	 *
 	 * @param operand	The operand of the node
-	 * @param operator	The name of the operator
-	 * @param methodName	The name of the method to call for this operator
+	 * @param operatorOrOpType	Either 1) the name of the operator,
+	 *  OR 2) an Integer holding the operatorType for this operator.
+	 * @param methodNameOrParams	Either 1) name of the method
+	 *  to call for this operator, or 2) an array of Objects
+	 *  from which primitive method parameters can be
+	 *  retrieved.
 	 */
 
 	public void init(
 					Object	operand,
-					Object		operator,
-					Object		methodName)
+					Object		operatorOrOpType,
+					Object		methodNameOrAddedArgs)
 	{
 		this.operand = (ValueNode) operand;
-		this.operator = (String) operator;
-		this.methodName = (String) methodName;
+		if (operatorOrOpType instanceof String) {
+		// then 2nd and 3rd params are operator and methodName,
+		// respectively.
+			this.operator = (String) operatorOrOpType;
+			this.methodName = (String) methodNameOrAddedArgs;
+			this.operatorType = -1;
+		}
+		else {
+		// 2nd and 3rd params are operatorType and additional args,
+		// respectively.
+			if (SanityManager.DEBUG) {
+				SanityManager.ASSERT(
+					((operatorOrOpType instanceof Integer) &&
+						((methodNameOrAddedArgs == null) ||
+						(methodNameOrAddedArgs instanceof Object[]))),
+					"Init params in UnaryOperator node have the " +
+					"wrong type.");
+			}
+			this.operatorType = ((Integer) operatorOrOpType).intValue();
+			this.operator = UnaryOperators[this.operatorType];
+			this.methodName = UnaryMethodNames[this.operatorType];
+			this.resultInterfaceType = UnaryResultTypes[this.operatorType];
+			this.receiverInterfaceType = UnaryArgTypes[this.operatorType];
+			this.additionalArgs = (Object[])methodNameOrAddedArgs;
+		}
 	}
 
 	/**
@@ -91,6 +166,7 @@ public void init(
 	public void init(Object	operand)
 	{
 		this.operand = (ValueNode) operand;
+		this.operatorType = -1;
 	}
 
 	/**
@@ -103,6 +179,7 @@ public void init(Object	operand)
 	void setOperator(String operator)
 	{
 		this.operator = operator;
+		this.operatorType = -1;
 	}
 
 	/**
@@ -125,6 +202,7 @@ String getOperatorString()
 	void setMethodName(String methodName)
 	{
 		this.methodName = methodName;
+		this.operatorType = -1;
 	}
 
 	/**
@@ -257,9 +335,103 @@ protected ValueNode bindUnaryOperator(
 			operand = operand.genSQLJavaSQLTree();
 		}
 
+		if (operatorType == XMLPARSE_OP)
+			bindXMLParse();
+		else if (operatorType == XMLSERIALIZE_OP)
+			bindXMLSerialize();
+
 		return this;
 	}
 
+	/**
+     * Bind an XMLPARSE operator.  Makes sure the operand type
+     * is correct, and sets the result type.
+     *
+     * @exception StandardException Thrown on error
+     */
+    public void bindXMLParse() throws StandardException
+    {
+        // Check the type of the operand - this function is allowed only on
+        // string value (char) types.
+        TypeId operandType = operand.getTypeId();
+        if (operandType != null) {
+            switch (operandType.getJDBCTypeId())
+            {
+                case Types.CHAR:
+                case Types.VARCHAR:
+                case Types.LONGVARCHAR:
+                case Types.CLOB:
+                    break;
+                default:
+                {
+                    throw StandardException.newException(
+                        SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
+                        methodName,
+                        operandType.getSQLTypeName());
+                }
+            }
+        }
+
+        // The result type of XMLParse() is always an XML type.
+        setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor(
+            StoredFormatIds.XML_TYPE_ID));
+    }
+
+    /**
+     * Bind an XMLSERIALIZE operator.  Makes sure the operand type
+     * and target type are both correct, and sets the result type.
+     *
+     * @exception StandardException Thrown on error
+     */
+    public void bindXMLSerialize() throws StandardException
+    {
+        TypeId operandType;
+
+        // Check the type of the operand - this function is allowed only on
+        // the XML type.
+        operandType = operand.getTypeId();
+        if ((operandType != null) && !operandType.isXMLTypeId())
+        {
+            throw StandardException.newException(
+                SQLState.LANG_UNARY_FUNCTION_BAD_TYPE, 
+                methodName,
+                operandType.getSQLTypeName());
+        }
+
+        // Check the target type.  We only allow string types to be used as
+        // the target type.  The targetType is stored as the first Object
+        // in our list of additional parameters, so we have to retrieve
+        // it from there.
+        if (SanityManager.DEBUG) {
+            SanityManager.ASSERT(
+                ((additionalArgs != null) && (additionalArgs.length > 0)),
+                "Failed to locate target type for XMLSERIALIZE operator");
+        }
+
+        DataTypeDescriptor targetType =
+            (DataTypeDescriptor)additionalArgs[0];
+
+        TypeId targetTypeId = targetType.getTypeId();
+        switch (targetTypeId.getJDBCTypeId())
+        {
+            case Types.CHAR:
+            case Types.VARCHAR:
+            case Types.LONGVARCHAR:
+            case Types.CLOB:
+                break;
+            default:
+            {
+                throw StandardException.newException(
+                    SQLState.LANG_INVALID_XMLSERIALIZE_TYPE,
+                    targetTypeId.getSQLTypeName());
+            }
+        }
+
+        // The result type of XMLSerialize() is always a string; which
+        // kind of string is determined by the targetType field.
+        setType(targetType);
+    }
+
 	/**
 	 * Preprocess an expression tree.  We do a number of transformations
 	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
@@ -376,7 +548,22 @@ public boolean constantExpression(PredicateList whereClause)
 
 	void bindParameter() throws StandardException
 	{
-		if (operand.getTypeServices() == null)
+		if (operatorType == XMLPARSE_OP) {
+        // According to the SQL/XML standard, the XMLParse parameter
+        // takes a string operand.  RESOLVE: We use CLOB here because
+        // an XML string can be arbitrarily long...is this okay?
+        // The SQL/XML spec doesn't state what the type of the param
+        // should be; only that it "shall be a character type".
+	        ((ParameterNode) operand).setDescriptor(
+ 	           DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CLOB));
+		}
+		else if (operatorType == XMLSERIALIZE_OP) {
+        // For now, since JDBC has no type defined for XML, we
+        // don't allow binding to an XML parameter.
+	        throw StandardException.newException(
+ 	           SQLState.LANG_ATTEMPT_TO_BIND_XML);
+		}
+		else if (operand.getTypeServices() == null)
 		{
 			throw StandardException.newException(SQLState.LANG_UNARY_OPERAND_PARM, operator);
 		}
@@ -399,7 +586,11 @@ public void generateExpression(ExpressionClassBuilder acb,
 		if (operand == null)
 			return;
 
-		String resultTypeName = getTypeCompiler().interfaceName();
+		String resultTypeName = 
+			(operatorType == -1)
+				? getTypeCompiler().interfaceName()
+				: resultInterfaceType;
+			
 		// System.out.println("resultTypeName " + resultTypeName + " method " + methodName);
 		// System.out.println("isBooleanTypeId() " + getTypeId().isBooleanTypeId());
 
@@ -414,7 +605,8 @@ public void generateExpression(ExpressionClassBuilder acb,
 			/* Allocate an object for re-use to hold the result of the operator */
 			LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
 			mb.getField(field);
-			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, methodName, resultTypeName, 1);
+			int numParams = 1 + addMethodParams(mb);
+			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, methodName, resultTypeName, numParams);
 
 			/*
 			** Store the result of the method call in the field, so we can re-use
@@ -422,7 +614,8 @@ public void generateExpression(ExpressionClassBuilder acb,
 			*/
 			mb.putField(field);
 		} else {
-			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, methodName, resultTypeName, 0);
+			int numParams = addMethodParams(mb);
+			mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null, methodName, resultTypeName, numParams);
 		}
 	}
 
@@ -442,6 +635,9 @@ public String getReceiverInterfaceName() throws StandardException {
 								"cannot get interface without operand");
 		}
 
+		if (operatorType != -1)
+			return receiverInterfaceType;
+		
 		return operand.getTypeCompiler().interfaceName();
 	}
 
@@ -495,4 +691,35 @@ public Visitable accept(Visitor v)
 
 		return returnNode;
 	}
+
+    /**
+     * This method allows different operators to add
+     * primitive arguments to the generated method call,
+     * if needed.
+     * @param mb The MethodBuilder that will make the call.
+     * @return Number of parameters added.
+     */
+    protected int addMethodParams(MethodBuilder mb)
+    {
+        if (operatorType == XMLPARSE_OP) {
+        // We push whether or not we want to preserve whitespace.
+            mb.push(((Boolean)additionalArgs[0]).booleanValue());
+            return 1;
+        }
+
+        if (operatorType == XMLSERIALIZE_OP) {
+        // We push the target type's JDBC type id as well as
+        // the maximum width, since both are required when
+        // we actually perform the operation, and both are
+        // primitive types.
+            DataTypeDescriptor targetType =
+                (DataTypeDescriptor)additionalArgs[0];
+            mb.push(targetType.getJDBCTypeId());
+            mb.push(targetType.getMaximumWidth());
+            return 2;
+        }
+
+        // Default is to add zero params.
+        return 0;
+    }
 }
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/XMLConstantNode.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/XMLConstantNode.java
index e69de29b..7f7422cb 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/XMLConstantNode.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/XMLConstantNode.java
@@ -0,0 +1,99 @@
+/*
+
+   Derby - Class org.apache.derby.impl.sql.compile.XMLConstantNode
+
+   Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package    org.apache.derby.impl.sql.compile;
+
+import org.apache.derby.iapi.error.StandardException;
+import org.apache.derby.iapi.services.compiler.MethodBuilder;
+import org.apache.derby.iapi.services.io.StoredFormatIds;
+import org.apache.derby.iapi.services.sanity.SanityManager;
+import org.apache.derby.iapi.types.TypeId;
+
+import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
+
+import org.apache.derby.iapi.util.ReuseFactory;
+
+public final class XMLConstantNode extends ConstantNode
+{
+    /**
+     * Initializer for an XMLConstantNode.
+     *
+     * @param arg1 The TypeId for the type of the node
+     *
+     * @exception StandardException
+     */
+    public void init(
+                    Object arg1)
+        throws StandardException
+    {
+        super.init(
+                    arg1,
+                    Boolean.TRUE,
+                    ReuseFactory.getInteger(0));
+    }
+
+    /**
+     * Return the value from this XMLConstantNode as a string.
+     *
+     * @return The value of this XMLConstantNode as a string.
+     *
+     * @exception StandardException Thrown on error
+     */
+    public String getString() throws StandardException
+    {
+        return value.getString();
+    }
+
+    /**
+     * Return an Object representing the bind time value of this
+     * expression tree.  If the expression tree does not evaluate to
+     * a constant at bind time then we return null.
+     *
+     * @return An Object representing the bind time value of this
+     *  expression tree (null if not a bind time constant).
+     *
+     * @exception StandardException        Thrown on error
+     */
+    Object getConstantValueAsObject() throws StandardException 
+    {
+        return value.getObject();
+    }
+
+    /**
+     * This generates the proper constant.  For an XML value,
+     * this constant value is simply the XML string (which is
+     * just null because null values are the only types of
+     * XML constants we can have).
+     *
+     * @param acb The ExpressionClassBuilder for the class being built
+     * @param mb The method the code to place the code
+     *
+     * @return The compiled Expression, 
+     *
+     * @exception StandardException        Thrown on error
+     */
+    void generateConstant(ExpressionClassBuilder acb, MethodBuilder mb)
+        throws StandardException
+    {
+        // The generated java is the expression:
+        // "#getString()"
+        mb.push(getString());
+    }
+}
diff --git a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/XMLTypeCompiler.java b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/XMLTypeCompiler.java
index e69de29b..0b3501a6 100644
--- a/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/XMLTypeCompiler.java
+++ b/incubator/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/XMLTypeCompiler.java
@@ -0,0 +1,179 @@
+/*
+
+   Derby - Class org.apache.derby.impl.sql.compile.XMLTypeCompiler
+
+   Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.impl.sql.compile;
+
+import org.apache.derby.iapi.services.loader.ClassFactory;
+import org.apache.derby.iapi.services.sanity.SanityManager;
+import org.apache.derby.iapi.services.io.StoredFormatIds;
+
+import org.apache.derby.iapi.error.StandardException;
+
+import org.apache.derby.iapi.types.TypeId;
+import org.apache.derby.iapi.types.DataTypeDescriptor;
+
+import org.apache.derby.iapi.reference.ClassName;
+
+/**
+ * This class implements TypeCompiler for the XML type.
+ */
+
+public class XMLTypeCompiler extends BaseTypeCompiler
+{
+    /**
+     * Tell whether this type (XML) can be compared to the given type.
+     * Says SQL/XML[2003] spec:
+     *
+     * 4.2.2 XML comparison and assignment
+     * "XML values are not comparable."
+     *
+     * @param otherType The TypeId of the other type.
+     */
+    public boolean comparable(TypeId otherType,
+                            boolean forEquals,
+                            ClassFactory cs)
+    {
+        // An XML value cannot be compared to any type--
+        // not even to other XML values.
+        return false;
+    }
+
+    /**
+     * Tell whether this type (XML) can be converted to the given type.
+     *
+     * An XML value can't be converted to any other type, per
+     * SQL/XML[2003] 6.3 <cast specification>
+     *
+     * @see TypeCompiler#convertible
+     */
+    public boolean convertible(TypeId otherType, 
+                            boolean forDataTypeFunction)
+    {
+        // An XML value cannot be converted to any non-XML type.  If
+        // user wants to convert an XML value to a string, then
+        // s/he must use the provided SQL/XML serialization operator
+        // (namely, XMLSERIALIZE).
+        return otherType.isXMLTypeId();
+    }
+
+    /**
+     * Tell whether this type (XML) is compatible with the given type.
+     *
+     * @param otherType The TypeId of the other type.
+     */
+    public boolean compatible(TypeId otherType)
+    {
+        // An XML value is not compatible (i.e. cannot be "coalesced")
+        // into any non-XML type.
+        return otherType.isXMLTypeId();
+    }
+
+    /**
+     * Tell whether this type (XML) can be stored into from the given type.
+     * Only XML values can be stored into an XML type, per SQL/XML spec:
+     *
+     * 4.2.2 XML comparison and assignment
+     * Values of XML type are assignable to sites of XML type.
+     *
+     * @param otherType The TypeId of the other type.
+     * @param cf A ClassFactory
+     */
+    public boolean storable(TypeId otherType, ClassFactory cf)
+    {
+        // The only type of value that can be stored as XML
+        // is an XML value.  Strings are not allowed.  If
+        // the user wants to store a string value as XML,
+        // s/he must use the provided XML parse operator
+        // (namely, XMLPARSE) to parse the string into
+        // XML.
+        return otherType.isXMLTypeId();
+    }
+
+    /**
+     * @see TypeCompiler#interfaceName
+     */
+    public String interfaceName() {
+        return ClassName.XMLDataValue;
+    }
+
+    /**
+     * @see TypeCompiler#getCorrespondingPrimitiveTypeName
+     */
+    public String getCorrespondingPrimitiveTypeName()
+    {
+        int formatId = getStoredFormatIdFromTypeId();
+        if (formatId == StoredFormatIds.XML_TYPE_ID)
+            return "org.apache.derby.iapi.types.XML";
+
+        if (SanityManager.DEBUG) {
+            SanityManager.THROWASSERT(
+                "unexpected formatId in getCorrespondingPrimitiveTypeName(): "
+                + formatId);
+        }
+
+        return null;
+    }
+
+    /**
+     * @see TypeCompiler#getCastToCharWidth
+     *
+     * While it is true XML values can't be cast to char, this method
+     * can get called before we finish type checking--so we return a dummy
+     * value here and let the type check throw the appropriate error.
+     */
+    public int getCastToCharWidth(DataTypeDescriptor dts)
+    {
+        return -1;
+    }
+
+    /**
+     * @see TypeCompiler#nullMethodName
+     */
+    protected String nullMethodName()
+    {
+        int formatId = getStoredFormatIdFromTypeId();
+        if (formatId == StoredFormatIds.XML_TYPE_ID)
+            return "getNullXML";
+
+        if (SanityManager.DEBUG) {
+            SanityManager.THROWASSERT(
+                "unexpected formatId in nullMethodName(): " + formatId);
+        }
+
+        return null;
+    }
+
+    /**
+     * @see TypeCompiler#dataValueMethodName
+     */
+    protected String dataValueMethodName()
+    {
+        int formatId = getStoredFormatIdFromTypeId();
+        if (formatId == StoredFormatIds.XML_TYPE_ID)
+            return "getXMLDataValue";
+
+        if (SanityManager.DEBUG) {
+            SanityManager.THROWASSERT(
+                "unexpected formatId in dataValueMethodName() - " + formatId);
+        }
+
+        return null;
+    }
+}
diff --git a/incubator/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/xmlBinding.java b/incubator/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/xmlBinding.java
index 3f24d583..a30aed36 100644
--- a/incubator/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/xmlBinding.java
+++ b/incubator/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/xmlBinding.java
@@ -1 +1,644 @@
   + native
+/*
+
+   Derby - Class org.apache.derbyTesting.functionTests.tests.lang.xmlBinding
+
+   Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derbyTesting.functionTests.tests.lang;
+
+import java.io.FileReader;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.Statement;
+import java.sql.SQLException;
+import java.sql.Types;
+
+import org.apache.derby.tools.ij;
+import org.apache.derby.tools.JDBCDisplayUtil;
+
+/**
+ * This class checks to make sure that the XML data type and
+ * the corresponding XML operations all work as expected
+ * from the JDBC side of things.  In particular, this test
+ * verifies that 1) it is NOT possible to bind to/from an XML
+ * datatype (because the JDBC specification doesn't indicate
+ * how that should be done), and 2) the correct behavior
+ * occurs when null values (both Java and SQL) are bound
+ * into the bindable parameters for the XML operators.
+ * This file also checks that insertion from XML files
+ * via a character stream works, which is important since
+ * XML files can be arbitrarily long and thus stream-based
+ * processing is a must.
+ */
+public class xmlBinding
+{
+    /**
+     * Create an instance of this class and do the test.
+     */
+    public static void main(String [] args)
+    {
+        new xmlBinding().go(args);
+    }
+
+    /**
+     * Create a JDBC connection using the arguments passed
+     * in from the harness, and then run the binding
+     * tests.
+     * @param args Arguments from the harness.
+     */
+    public void go(String [] args)
+    {
+        try {
+
+            // use the ij utility to read the property file and
+            // make the initial connection.
+            ij.getPropertyArg(args);
+            Connection conn = ij.startJBMS();
+
+            // Create our test table.
+            Statement st = conn.createStatement();
+            st.execute("create table xTable.t1 " +
+                "(i int generated always as identity, x xml)");
+
+            // Do the tests.
+            doBindTests(conn);
+            doXMLParseTests(conn);
+            doXMLSerializeTests(conn);
+            doXMLExistsTests(conn);
+
+            // Clean up.
+            st.close();
+            conn.close();
+
+            System.out.println("[ Done. ]\n");
+
+        } catch (Exception e) {
+
+            System.out.println("Unexpected error: ");
+            e.printStackTrace(System.out);
+
+        }
+    }
+
+    /**
+     * Performs a series of binding checks to make sure
+     * binding to an XML value never works.
+     * @param conn A connection to the test database.
+     */
+    private void doBindTests(Connection conn)
+    {
+        // Make sure that attempts to bind _to_ XML will fail.
+        System.out.println("\n[ Beginning XML binding tests. ]\n");
+
+        // Binding to an XML column.
+        PreparedStatement pSt = null;
+        try {
+
+            // If we're running in embedded mode or else with
+            // the Derby Client, then the next line will fail
+            // because there is NO deferred prepare.  If, however,
+            // we're running with JCC, the default is to defer
+            // the prepare until execution, so the next line will
+            // be fine, but the following four checks will fail.
+            // This difference in behavior okay--it requires two
+            // different masters, but ultimately it's a good way
+            // to check behavior in both cases.
+            pSt = conn.prepareStatement(
+                "insert into xTable.t1(x) values (?)");
+
+            System.out.print("XML column -- bind String to XML: ");
+            bindAndExecute(pSt, 1, Types.VARCHAR, "shouldn't work", "X0X14", false);
+
+            System.out.print("XML column -- bind Java null to XML: ");
+               bindAndExecute(pSt, 1, Types.VARCHAR, null, "X0X14", false);
+
+            System.out.print("XML column -- bind SQL NULL to XML: ");
+            bindAndExecute(pSt, 1, Types.VARCHAR, null, "X0X14", true);
+
+            System.out.print("XML column -- bind integer to XML: ");
+            bindAndExecute(pSt, 1, Types.INTEGER, new Integer(8), "X0X14", false);
+
+        } catch (SQLException se) {
+            // Must be running with embedded or Derby Network Client.
+            System.out.print("XML column -- insertion via parameter:  ");
+            checkException(se, "X0X14");
+        }
+
+        // Binding to an XML value in the XMLSERIALIZE operator.
+        // Should get compile-time error saying that 
+        // parameters aren't allowed for XML data values.
+        System.out.print("Trying to bind to XML in XMLSERIALIZE: ");
+        try {
+            pSt = conn.prepareStatement(
+                "select XMLSERIALIZE(? AS CLOB) FROM XTABLE.T1");
+            bindAndExecute(pSt, 1, Types.VARCHAR, null, "X0X14", true);
+        } catch (SQLException se) {
+            checkException(se, "X0X14");
+        }
+
+        // Binding to an XML value in the XMLEXISTS operator.
+        // Should get compile-time error saying that 
+        // parameters aren't allowed for XML data values.
+        System.out.print("Trying to bind to XML in XMLEXISTS: ");
+        try {
+            pSt = conn.prepareStatement(
+                "select i from xTable.t1 where " +
+                "XMLEXISTS('//*' PASSING BY VALUE ?)");
+            bindAndExecute(pSt, 1, Types.VARCHAR, null, "X0X14", true);
+        } catch (SQLException se) {
+            checkException(se, "X0X14");
+        }
+
+        // Make sure that attempts to bind _from_ XML will fail.
+        // We should fail at compile time, even before
+        // we get a chance to execute the query.
+        System.out.print("XML value in result set: ");
+        try {
+            pSt = conn.prepareStatement("select x from xTable.t1");
+            pSt.execute();
+        } catch (SQLException se) {
+            checkException(se, "X0X15");
+        }
+
+        System.out.println("\n[ End XML binding tests. ]\n");
+    }
+
+    /**
+     * Test insertion of documents larger than 32K (this
+     * will test stream processing of XML data), and
+     * test binding of null values in the XMLPARSE
+     * operator.
+     * @param conn A connection to the test database.
+     */
+    private void doXMLParseTests(Connection conn)
+    {
+        System.out.println("\n[ Beginning XMLPARSE tests. ]\n");
+
+        System.out.println("Test insertions from file: ");
+        try { 
+
+            // Test parsing of > 32K XML documents.
+            insertFiles(conn, "xTable.t1", "xmlTestFiles/wide40k.xml", 1);
+            insertFiles(conn, "xTable.t1", "xmlTestFiles/deep40k.xml", 1);
+
+            // Test parsing of docs that use schemas.  Since server
+            // and client tests run in a subdirectory, we have to modify
+            // the XML documents that use DTDs so that they can find
+            // the DTD files.
+
+            insertDocWithDTD(conn, "xTable.t1", "xmlTestFiles/dtdDoc.xml",
+                "personal.dtd", 1);
+            insertFiles(conn, "xTable.t1", "xmlTestFiles/xsdDoc.xml", 1);
+
+            // XMLPARSE is not supposed to validate, so the following
+            // inserts should SUCCEED, even though the documents
+            // don't adhere to their schemas.
+            insertDocWithDTD(conn, "xTable.t1",
+                "xmlTestFiles/dtdDoc_invalid.xml", "personal.dtd", 1);
+            insertFiles(conn, "xTable.t1",
+                "xmlTestFiles/xsdDoc_invalid.xml", 1);
+
+            System.out.println("--> Insertions all PASS.");
+
+        } catch (SQLException se) {
+            System.out.println("FAIL: Unexpected exception: ");
+            while (se != null) {
+                se.printStackTrace(System.out);
+                se = se.getNextException();
+            }
+        } catch (Exception e) {
+            System.out.println("FAIL: Unexpected exception: ");
+            e.printStackTrace(System.out);
+        }
+
+        // Test binding nulls to the XMLPARSE operand.
+
+        try {
+
+            PreparedStatement pSt = conn.prepareStatement(
+                "insert into xTable.t1(x) values " +
+                "(XMLPARSE (DOCUMENT ? PRESERVE WHITESPACE))");
+
+            // This should work.  Note we check binding to
+            // a character stream method in "insertFiles".
+            System.out.print("Binding string in XMLPARSE: ");
+            bindAndExecute(pSt, 1, Types.CHAR, "<simple> doc </simple>",
+                null, false);
+
+            // Null should work, too.
+            System.out.print("Binding Java null string in XMLPARSE: ");
+            bindAndExecute(pSt, 1, Types.CHAR, null, null, false);
+            System.out.print("Binding SQL NULL string in XMLPARSE: ");
+            bindAndExecute(pSt, 1, Types.CLOB, null, null, true);
+
+        } catch (Exception e) {
+            System.out.println("Unexpected exception: ");
+            e.printStackTrace(System.out);
+        }
+
+        System.out.println("\n[ End XMLPARSE tests. ]\n");
+    }
+
+    /**
+     * Test serialization of the XML values inserted by
+     * the doXMLParseTests() method above.  For the documents
+     * that are larger than 32K, this tests that they can
+     * be correctly read from disk as a stream (instead of
+     * just as as string).
+     * @param conn A connection to the test database.
+     */
+    private void doXMLSerializeTests(Connection conn)
+    {
+        System.out.println("\n[ Beginning XMLSERIALIZE tests. ]\n");
+
+        try {
+
+            PreparedStatement pSt = conn.prepareStatement(
+                "select i, XMLSERIALIZE(X AS CLOB) FROM xTable.t1");
+            ResultSet rs = pSt.executeQuery();
+
+            String xResult = null;
+            int rowCount = 0;
+            while (rs.next()) {
+                xResult = rs.getString(2);
+                if (!rs.wasNull()) {
+                    System.out.println(rs.getInt(1) + ", " +
+                        "[ roughly " + (xResult.length() / 1000) + "k ]");
+                }
+                else
+                    System.out.println(rs.getInt(1) + ", NULL");
+                rowCount++;
+            }
+
+        } catch (Exception e) {
+            System.out.println("Unexpected exception: ");
+            e.printStackTrace(System.out);
+        }
+
+        // Test binding to the XMLSERIALIZE operand.  Since
+        // the operand is an XML value, and since we don't
+        // allow binding to an XML value (see "doBindTests()"
+        // above), there's nothing more to do here.
+
+        System.out.println("\n[ End XMLSERIALIZE tests. ]\n");
+    }
+
+    /**
+     * Run some simple XPath queries against the documents
+     * inserted in doXMLParseTests() above, and then test
+     * binding of null values in the XMLEXISTS operator.
+     * @param conn A connection to the test database.
+     */
+    private void doXMLExistsTests(Connection conn)
+    {
+        System.out.println("\n[ Begin XMLEXISTS tests. ]\n");
+
+        // Run some sample queries.
+        try {
+
+            existsQuery(conn, "xTable.t1", "//abb");
+            existsQuery(conn, "xTable.t1", "//d50");
+            existsQuery(conn, "xTable.t1", "//person/email");
+            existsQuery(conn, "xTable.t1", "/personnel");
+            existsQuery(conn, "xTable.t1", "//person/@id");
+
+            // This next one is important because it verifies
+            // that implicit/default values which are defined
+            // in a DTD _are_ actually processed, even though
+            // we don't perform validation.  Thus this next
+            // query _should_ return a match.
+            int rowCount = existsQuery(conn, "xTable.t1", "//person/@noteTwo");
+            if (rowCount == 0) {
+                System.out.println("FAILED: Query on DTD default didn't " +
+                    "return any matches.");
+            }
+
+        } catch (Exception e) {
+            System.out.println("Unexpected exception: ");
+            e.printStackTrace(System.out);
+        }
+
+        // Test binding nulls to the XMLEXISTS operands.  Binding
+        // of the second (XML) operand is not allowed and was
+        // checked in "doBindTests()" above.  Here we just
+        // check binding of the first operand, which should be
+        // a string.
+        try {
+
+            PreparedStatement pSt = conn.prepareStatement(
+                "select i from xTable.t1 where " +
+                "XMLEXISTS (? PASSING BY VALUE x)");
+
+            System.out.print("Binding string in XMLEXISTS: ");
+            bindAndExecute(pSt, 1, Types.CHAR, "//d48", null, false);
+
+            // Null should work, too.
+            System.out.print("Binding Java null string in XMLEXISTS: ");
+            bindAndExecute(pSt, 1, Types.CHAR, null, null, false);
+            System.out.print("Binding SQL NULL string in XMLEXISTS: ");
+            bindAndExecute(pSt, 1, Types.VARCHAR, null, null, true);
+
+        } catch (Exception e) {
+            System.out.println("Unexpected exception: ");
+            e.printStackTrace(System.out);
+        }
+
+        System.out.println("\n[ End XMLEXISTS tests. ]\n");
+    }
+
+    /**
+     * Helper method.  Inserts the contents of a file into
+     * the received table using "setCharacterStream".
+     * @param conn A connection to the test database.
+     * @param tableName Name of the target table
+     * @param fName Name of the file whose content we
+     *  want to insert.
+     * @param numRows Number of times we should insert
+     *  the received file's content.
+     */
+    private void insertFiles(Connection conn, 
+        String tableName, String fName, int numRows)
+        throws Exception
+    {
+        // First we have to figure out many chars long the
+        // file is.
+        InputStream iS = this.getClass().getResourceAsStream(fName);
+        InputStreamReader reader = new InputStreamReader(iS);
+        char [] cA = new char[1024];
+        int charCount = 0;
+        for (int len = reader.read(cA, 0, cA.length); len != -1;
+            charCount += len, len = reader.read(cA, 0, cA.length));
+
+        reader.close();
+
+        // Now that we know the number of characters, we can
+        // insert using a stream.
+
+        PreparedStatement pSt = conn.prepareStatement(
+            "insert into xTable.t1(x) values (" +
+            "xmlparse(document ? preserve whitespace))");
+
+        for (int i = 0; i < numRows; i++) {
+
+            iS = this.getClass().getResourceAsStream(fName);
+            reader = new InputStreamReader(iS);
+            pSt.setCharacterStream(1, reader, charCount);
+            pSt.execute();
+            reader.close();
+            System.out.println("Inserted roughly " +
+                (charCount / 1000) + "k of data.");
+
+        }
+    }
+
+    /**
+     * Helper method.  Inserts an XML document into the
+     * received table using setString.  This method
+     * parallels "insertFiles" above, except that it
+     * should be used for documents that require a DTD
+     * in order to be complete.  In that case, the
+     * location of the DTD has to modified _in_ the
+     * document so that it can be found regardless of
+     * whether we're running in embedded mode or in
+     * server/client mode.
+     * @param conn A connection to the test database.
+     * @param tableName Name of the target table
+     * @param fName Name of the file whose content we
+     *  want to insert.
+     * @param dtdName Name of the DTD file that the
+     *  received file uses.
+     * @param numRows Number of times we should insert
+     *  the received file's content.
+     */
+    private void insertDocWithDTD(Connection conn, 
+        String tableName, String fName, String dtdName,
+        int numRows) throws Exception
+    {
+        boolean needsUpdate = true;
+        String currPath = System.getProperty("user.dir");
+        String fileSep = System.getProperty("file.separator");
+
+        String dtdPath = currPath;
+        boolean foundDTD = false;
+        while (!foundDTD) {
+
+            try {
+
+                FileReader fR = new FileReader(dtdPath +
+                    fileSep + dtdName);
+
+                // If we get here, then we found the DTD in
+                // the current path, so we're done.
+                foundDTD = true;
+                dtdPath = "file:///" + dtdPath + fileSep + dtdName;
+                break;
+
+            } catch (java.io.IOException ie) {
+
+                // Couldn't find the DTD in the current path.
+                // The harness uses a lot of subdirectories when
+                // running tests (for client, or server, or
+                // suites, or nested suites...etc.), so we
+                // back up one directory and try again.
+
+                int pos = dtdPath.lastIndexOf(fileSep);
+                if (pos == -1) {
+                // we're at the top of the path and haven't
+                // found the DTD yet.  This shouldn't happen.
+                    throw new Exception("Couldn't find DTD '" +
+                        dtdName + "' for insertion of file '" +
+                        fName + "'.");
+                }
+                dtdPath = dtdPath.substring(0, pos);
+
+            }
+        }
+
+        // Read the file into memory so we can update it.
+        InputStream iS = this.getClass().getResourceAsStream(fName);
+        InputStreamReader reader = new InputStreamReader(iS);
+        char [] cA = new char[1024];
+        StringBuffer sBuf = new StringBuffer();
+        int charCount = 0;
+        for (int len = reader.read(cA, 0, cA.length); len != -1;
+            charCount += len, len = reader.read(cA, 0, cA.length))
+        {
+            sBuf.append(cA, 0, len);
+        }
+
+        reader.close();
+
+        // Now replace the DTD location, if needed.
+        String docAsString = sBuf.toString();
+        int pos = docAsString.indexOf(dtdName);
+        if (pos != -1)
+            sBuf.replace(pos, pos + dtdName.length(), dtdPath);
+
+        // Now (finally) do the insert using the in-memory
+        // document with the correct DTD location.
+        docAsString = sBuf.toString();
+        PreparedStatement pSt = conn.prepareStatement(
+            "insert into xTable.t1(x) values (" +
+            "xmlparse(document ? preserve whitespace))");
+
+        charCount = docAsString.length();
+        for (int i = 0; i < numRows; i++) {
+
+            pSt.setString(1, docAsString);
+            pSt.execute();
+            System.out.println("Inserted roughly " +
+                (charCount / 1000) + "k of data.");
+
+        }
+    }
+
+    /**
+     * Helper method.  Selects all rows from the received
+     * table name that have at least one node matching
+     * the received XPath expression.  Does this query
+     * using the XMLEXISTS operator.
+     * @param conn A connection to the test database.
+     * @param tableName Table to query.
+     * @param xPath The XPath expression to evaluate.
+     * @return The number of rows that match the
+     *  XPath expression.
+     */
+    private int existsQuery(Connection conn,
+        String tableName, String xPath) throws Exception
+    {
+        PreparedStatement pSt = conn.prepareStatement(
+            "select i from " + tableName + " where " +
+            "xmlexists('" + xPath + "' passing by value x)");
+
+        System.out.println("Running XMLEXISTS with: " + xPath);
+        ResultSet rs = pSt.executeQuery();
+        String xResult = null;
+        int rowCount = 0;
+        while (rs.next()) {
+            rowCount++;
+        }
+
+        System.out.println("--> Matching rows: " + rowCount);
+        return rowCount;
+    }
+
+    /**
+     * Helper method.  Attempts to bind a parameter to a
+     * given value using the given type, and then prints
+     * the result of that attempt (PASS/FAIL).
+     * @param pSt The prepared statement holding the parameter
+     *  that we want to bind.
+     * @param paramNum Which parameter in pSt we want to bind.
+     * @param paramType The type of the value to be bound.
+     * @param bindValue The value to be used for binding.
+     * @param sqlState The expected SQLState for the binding
+     *  error, if one is expected.  Null if the bind is expected
+     *  to succeed.
+     * @param bindSqlNull True if we should bind using a SQL
+     *  NULL (i.e. "setNull()").
+     */
+    private void bindAndExecute(PreparedStatement pSt, int paramNum,
+        int paramType, Object bindValue, String sqlState,
+        boolean bindSqlNull)
+    {
+        SQLException actualException = null;
+        try {
+
+            // First try to bind.
+            if (bindSqlNull) {
+                pSt.setNull(paramNum, paramType);
+            }
+            else {
+                switch (paramType)
+                {
+                    case Types.CHAR:
+                    case Types.VARCHAR:
+
+                        pSt.setString(paramNum, (String)bindValue);
+                        break;
+
+                    case Types.INTEGER:
+
+                        pSt.setInt(paramNum, ((Integer)bindValue).intValue());
+                        break;
+
+                    default:
+
+                        System.out.println("ERROR: Unexpected bind type (" +
+                            paramType + ") in call to doBind.");
+                        break;
+                }
+            }
+
+            // Now try to execute.
+            pSt.execute();
+
+        } catch (SQLException e) {
+            actualException = e;
+        }
+
+        checkException(actualException, sqlState);
+    }
+
+    /**
+     * Helper method.  Checks to see if the received SQLException
+     * has a SQLState that matches the target/expected SQLState.
+     * Prints out a message saying the result of this check, and
+     * in the case where the actual error is NOT the expected
+     * error, prints a full stack trace to System.out.
+     * @param se The SQLException to be checked.
+     * @param targetState The expected SQLState; null if no
+     *  error was expected.
+     */
+    private void checkException(SQLException se,
+        String targetState)
+    {
+        if (targetState == null) {
+            if (se == null) {
+                System.out.println("PASS -- Completed without exception, " +
+                    "as expected.");
+            }
+            else {
+                System.out.println("FAIL -- Was expected to succeed, but " +
+                    "failed with error " + se.getSQLState() + ".");
+                se.printStackTrace(System.out);
+            }
+            return;
+        }
+
+        if (se == null) {
+            System.out.println("FAIL -- Completed without exception when " +
+                "error " + targetState + " was expected.");
+            return;
+        }
+
+        if (!targetState.equals(se.getSQLState())) {
+            System.out.println("FAIL: Caught error " + se.getSQLState() +
+                " when was expecting error " + targetState + ".");
+            se.printStackTrace(System.out);
+            return;
+        }
+
+        System.out.println("PASS -- caught expected error " +
+            targetState + ".");
+    }
+}
