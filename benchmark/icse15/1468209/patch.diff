diff --git a/mahout/trunk/core/src/main/java/org/apache/mahout/math/hadoop/similarity/cooccurrence/measures/PearsonCorrelationSimilarity.java b/mahout/trunk/core/src/main/java/org/apache/mahout/math/hadoop/similarity/cooccurrence/measures/PearsonCorrelationSimilarity.java
index 1b951dc1..d3e308a3 100644
--- a/mahout/trunk/core/src/main/java/org/apache/mahout/math/hadoop/similarity/cooccurrence/measures/PearsonCorrelationSimilarity.java
+++ b/mahout/trunk/core/src/main/java/org/apache/mahout/math/hadoop/similarity/cooccurrence/measures/PearsonCorrelationSimilarity.java
@@ -17,10 +17,10 @@
 
 package org.apache.mahout.math.hadoop.similarity.cooccurrence.measures;
 
-import org.apache.mahout.math.Vector;
-
 import java.util.Iterator;
 
+import org.apache.mahout.math.Vector;
+
 public class PearsonCorrelationSimilarity extends CosineSimilarity {
 
   @Override
@@ -28,12 +28,13 @@ public Vector normalize(Vector vector) {
     if (vector.getNumNondefaultElements() == 0) {
       return vector;
     }
+
     // center non-zero elements
-    double average = vector.norm(1) / vector.getNumNondefaultElements();
-    Iterator<Vector.Element> nonZeroElements = vector.iterateNonZero();
-    while (nonZeroElements.hasNext()) {
-      Vector.Element nonZeroElement = nonZeroElements.next();
-      vector.setQuick(nonZeroElement.index(), nonZeroElement.get() - average);
+    double average = vector.norm(1) / vector.getNumNonZeroElements();
+    Iterator<Vector.Element> it = vector.iterateNonZero();
+    while (it.hasNext()) {
+      Vector.Element e = it.next();
+      e.set(e.get() - average);
     }
     return super.normalize(vector);
   }
diff --git a/mahout/trunk/core/src/test/java/org/apache/mahout/clustering/classify/ClusterClassificationDriverTest.java b/mahout/trunk/core/src/test/java/org/apache/mahout/clustering/classify/ClusterClassificationDriverTest.java
index d95b5720..2d1ab94a 100644
--- a/mahout/trunk/core/src/test/java/org/apache/mahout/clustering/classify/ClusterClassificationDriverTest.java
+++ b/mahout/trunk/core/src/test/java/org/apache/mahout/clustering/classify/ClusterClassificationDriverTest.java
@@ -21,8 +21,6 @@
 import java.util.List;
 import java.util.Set;
 
-import com.google.common.collect.Sets;
-
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.FileStatus;
@@ -47,6 +45,7 @@
 import org.junit.Test;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
 
 public class ClusterClassificationDriverTest extends MahoutTestCase {
   
@@ -198,16 +197,16 @@ private void assertVectorsWithoutOutlierRemoval() {
   private void assertThirdClusterWithoutOutlierRemoval() {
     Assert.assertEquals(2, thirdCluster.size());
     for (Vector vector : thirdCluster) {
-      Assert.assertTrue(ArrayUtils.contains(new String[] {"{1:9.0,0:9.0}",
-          "{1:8.0,0:8.0}"}, vector.asFormatString()));
+      Assert.assertTrue(ArrayUtils.contains(new String[] {"{0:9.0,1:9.0}",
+          "{0:8.0,1:8.0}"}, vector.asFormatString()));
     }
   }
   
   private void assertSecondClusterWithoutOutlierRemoval() {
     Assert.assertEquals(4, secondCluster.size());
     for (Vector vector : secondCluster) {
-      Assert.assertTrue(ArrayUtils.contains(new String[] {"{1:4.0,0:4.0}",
-          "{1:4.0,0:5.0}", "{1:5.0,0:4.0}", "{1:5.0,0:5.0}"},
+      Assert.assertTrue(ArrayUtils.contains(new String[] {"{0:4.0,1:4.0}",
+          "{0:5.0,1:4.0}", "{0:4.0,1:5.0}", "{0:5.0,1:5.0}"},
           vector.asFormatString()));
     }
   }
@@ -215,13 +214,13 @@ private void assertSecondClusterWithoutOutlierRemoval() {
   private void assertFirstClusterWithoutOutlierRemoval() {
     Assert.assertEquals(3, firstCluster.size());
     for (Vector vector : firstCluster) {
-      Assert.assertTrue(ArrayUtils.contains(new String[] {"{1:1.0,0:1.0}",
-          "{1:1.0,0:2.0}", "{1:2.0,0:1.0}"}, vector.asFormatString()));
+      Assert.assertTrue(ArrayUtils.contains(new String[] {"{0:1.0,1:1.0}",
+          "{0:2.0,1:1.0}", "{0:1.0,1:2.0}"}, vector.asFormatString()));
     }
   }
 
   private void checkClustersWithOutlierRemoval() {
-    Set<String> reference = Sets.newHashSet("{1:9.0,0:9.0}", "{1:1.0,0:1.0}");
+    Set<String> reference = Sets.newHashSet("{0:9.0,1:9.0}", "{0:1.0,1:1.0}");
 
     List<List<Vector>> clusters = Lists.newArrayList();
     clusters.add(firstCluster);
diff --git a/mahout/trunk/core/src/test/java/org/apache/mahout/clustering/topdown/postprocessor/ClusterOutputPostProcessorTest.java b/mahout/trunk/core/src/test/java/org/apache/mahout/clustering/topdown/postprocessor/ClusterOutputPostProcessorTest.java
index da90b938..01159330 100644
--- a/mahout/trunk/core/src/test/java/org/apache/mahout/clustering/topdown/postprocessor/ClusterOutputPostProcessorTest.java
+++ b/mahout/trunk/core/src/test/java/org/apache/mahout/clustering/topdown/postprocessor/ClusterOutputPostProcessorTest.java
@@ -123,7 +123,7 @@ private void assertTopLevelCluster(Entry<String,Path> cluster) {
   private void assertPointsInFirstTopLevelCluster(Path clusterPath) throws IOException {
     List<Vector> vectorsInCluster = getVectorsInCluster(clusterPath);
     for (Vector vector : vectorsInCluster) {
-      Assert.assertTrue(ArrayUtils.contains(new String[] {"{1:1.0,0:1.0}", "{1:1.0,0:2.0}", "{1:2.0,0:1.0}"},
+      Assert.assertTrue(ArrayUtils.contains(new String[] {"{0:1.0,1:1.0}", "{0:2.0,1:1.0}", "{0:1.0,1:2.0}"},
         vector.asFormatString()));
     }
   }
@@ -131,8 +131,8 @@ private void assertPointsInFirstTopLevelCluster(Path clusterPath) throws IOExcep
   private void assertPointsInSecondTopLevelCluster(Path clusterPath) throws IOException {
     List<Vector> vectorsInCluster = getVectorsInCluster(clusterPath);
     for (Vector vector : vectorsInCluster) {
-      Assert.assertTrue(ArrayUtils.contains(new String[] {"{1:4.0,0:4.0}", "{1:4.0,0:5.0}", "{1:5.0,0:4.0}",
-                                                          "{1:5.0,0:5.0}"}, vector.asFormatString()));
+      Assert.assertTrue(ArrayUtils.contains(new String[] {"{0:4.0,1:4.0}", "{0:5.0,1:4.0}", "{0:4.0,1:5.0}",
+                                                          "{0:5.0,1:5.0}"}, vector.asFormatString()));
     }
   }
   
diff --git a/mahout/trunk/core/src/test/java/org/apache/mahout/math/hadoop/similarity/cooccurrence/measures/VectorSimilarityMeasuresTest.java b/mahout/trunk/core/src/test/java/org/apache/mahout/math/hadoop/similarity/cooccurrence/measures/VectorSimilarityMeasuresTest.java
index 3ca61e3e..c8869724 100644
--- a/mahout/trunk/core/src/test/java/org/apache/mahout/math/hadoop/similarity/cooccurrence/measures/VectorSimilarityMeasuresTest.java
+++ b/mahout/trunk/core/src/test/java/org/apache/mahout/math/hadoop/similarity/cooccurrence/measures/VectorSimilarityMeasuresTest.java
@@ -19,7 +19,9 @@
 
 import org.apache.mahout.common.ClassUtils;
 import org.apache.mahout.common.MahoutTestCase;
+import org.apache.mahout.math.DenseVector;
 import org.apache.mahout.math.RandomAccessSparseVector;
+import org.apache.mahout.math.SequentialAccessSparseVector;
 import org.apache.mahout.math.Vector;
 import org.junit.Test;
 
@@ -28,10 +30,22 @@
   static double distributedSimilarity(double[] one,
                                       double[] two,
                                       Class<? extends VectorSimilarityMeasure> similarityMeasureClass) {
+    double rand = computeSimilarity(one, two, similarityMeasureClass, new RandomAccessSparseVector(one.length));
+    double seq = computeSimilarity(one, two, similarityMeasureClass, new SequentialAccessSparseVector(one.length));
+    double dense = computeSimilarity(one, two, similarityMeasureClass, new DenseVector(one.length));
+    assertEquals(seq, rand, 1e-10);
+    assertEquals(seq, dense, 1e-10);
+    assertEquals(dense, rand, 1e-10);
+    return seq;
+  }
+
+  private static double computeSimilarity(double[] one, double[] two,
+      Class<? extends VectorSimilarityMeasure> similarityMeasureClass,
+      Vector like) {
     VectorSimilarityMeasure similarityMeasure = ClassUtils.instantiateAs(similarityMeasureClass,
         VectorSimilarityMeasure.class);
-    Vector oneNormalized = similarityMeasure.normalize(asSparseVector(one));
-    Vector twoNormalized = similarityMeasure.normalize(asSparseVector(two));
+    Vector oneNormalized = similarityMeasure.normalize(asVector(one, like));
+    Vector twoNormalized = similarityMeasure.normalize(asVector(two, like));
 
     double normOne = similarityMeasure.norm(oneNormalized);
     double normTwo = similarityMeasure.norm(twoNormalized);
@@ -42,15 +56,14 @@ static double distributedSimilarity(double[] one,
         dot += similarityMeasure.aggregate(oneNormalized.get(n), twoNormalized.get(n));
       }
     }
+
     return similarityMeasure.similarity(dot, normOne, normTwo, one.length);
   }
 
-  static Vector asSparseVector(double[] values) {
-    Vector vector = new RandomAccessSparseVector(Integer.MAX_VALUE);
+  static Vector asVector(double[] values, Vector like) {
+    Vector vector = like.like();
     for (int dim = 0; dim < values.length; dim++) {
-      if (values[dim] != 0) {
-        vector.setQuick(dim, values[dim]);
-      }
+      vector.set(dim, values[dim]);
     }
     return vector;
   }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractMatrix.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractMatrix.java
index f1ce081b..daeea293 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractMatrix.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractMatrix.java
@@ -17,16 +17,17 @@
 
 package org.apache.mahout.math;
 
-import com.google.common.collect.AbstractIterator;
-import com.google.common.collect.Maps;
+import java.util.Iterator;
+import java.util.Map;
+
 import org.apache.mahout.math.function.DoubleDoubleFunction;
+import org.apache.mahout.math.function.DoubleFunction;
 import org.apache.mahout.math.function.Functions;
 import org.apache.mahout.math.function.PlusMult;
-import org.apache.mahout.math.function.DoubleFunction;
 import org.apache.mahout.math.function.VectorFunction;
 
-import java.util.Iterator;
-import java.util.Map;
+import com.google.common.collect.AbstractIterator;
+import com.google.common.collect.Maps;
 
 /** A few universal implementations of convenience functions */
 public abstract class AbstractMatrix implements Matrix {
@@ -726,4 +727,15 @@ public int getNumNondefaultElements() {
     }
   }
 
+  @Override
+  public String toString() {
+    String s = "{\n";
+    Iterator<MatrixSlice> it = iterator();
+    while (it.hasNext()) {
+      MatrixSlice next = it.next();
+      s += "  " + next.index() + "  =>\t" + next.vector() + "\n";
+    }
+    s += "}";
+    return s;
+  }
 }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractVector.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractVector.java
index d5d242bb..a2747f46 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractVector.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/AbstractVector.java
@@ -17,14 +17,14 @@
 
 package org.apache.mahout.math;
 
+import java.util.Iterator;
+
 import org.apache.mahout.common.RandomUtils;
 import org.apache.mahout.math.function.DoubleDoubleFunction;
 import org.apache.mahout.math.function.DoubleFunction;
 import org.apache.mahout.math.function.Functions;
 import org.apache.mahout.math.set.OpenIntHashSet;
 
-import java.util.Iterator;
-
 /** Implementations of generic capabilities like sum of elements and dot products */
 public abstract class AbstractVector implements Vector, LengthCachingVector {
 
@@ -142,7 +142,44 @@ public double dot(Vector x) {
         }
         reverseDot = reverseDotCost < dotCost;
       }
+    } else if (this.isSequentialAccess()  && !this.isDense() && x.isSequentialAccess() && !x.isDense()) {
+      Element thisElement = null;
+      Element thatElement = null;
+      boolean advanceThis = true;
+      boolean advanceThat = true;
+
+      Iterator<Element> thisNonZero = this.iterateNonZero();
+      Iterator<Element> thatNonZero = x.iterateNonZero();
+
+      double result = 0.0;
+      while (true) {
+        if (advanceThis) {
+          if (!thisNonZero.hasNext()) {
+            break;
+          }
+          thisElement = thisNonZero.next();
+        }
+        if (advanceThat) {
+          if (!thatNonZero.hasNext()) {
+            break;
+          }
+          thatElement = thatNonZero.next();
+        }
+        if (thisElement.index() == thatElement.index()) {
+          result += thisElement.get() * thatElement.get();
+          advanceThis = true;
+          advanceThat = true;
+        } else if (thisElement.index() < thatElement.index()) {
+          advanceThis = true;
+          advanceThat = false;
+        } else {
+          advanceThis = false;
+          advanceThat = true;
+        }
     }
+      return result;
+    }
+
 
     if (reverseDot) {
       return x.dot(this);
@@ -648,7 +685,7 @@ public Vector times(Vector x) {
     Vector to = this;
     Vector from = x;
     // Clone and edit to the sparse one; if both are sparse, edit the more sparse one (more zeroes)
-    if (isDense() || (!x.isDense() && getNumNondefaultElements() > x.getNumNondefaultElements())) {
+    if (isDense() || !x.isDense() && getNumNondefaultElements() > x.getNumNondefaultElements()) {
       to = x;
       from = this;
     }
@@ -674,6 +711,18 @@ public double zSum() {
     return result;
   }
 
+  @Override
+  public int getNumNonZeroElements() {
+    int count = 0;
+    Iterator<Element> it = iterateNonZero();
+    while (it.hasNext()) {
+      if (it.next().get() != 0.0) {
+        count++;
+      }
+    }
+    return count;
+  }
+
   @Override
   public Vector assign(double value) {
     for (int i = 0; i < size; i++) {
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/DelegatingVector.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/DelegatingVector.java
index f2614fb9..9b836417 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/DelegatingVector.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/DelegatingVector.java
@@ -17,11 +17,11 @@
 
 package org.apache.mahout.math;
 
+import java.util.Iterator;
+
 import org.apache.mahout.math.function.DoubleDoubleFunction;
 import org.apache.mahout.math.function.DoubleFunction;
 
-import java.util.Iterator;
-
 /**
  * A delegating vector provides an easy way to decorate vectors with weights or id's and such while
  * keeping all of the Vector functionality.
@@ -284,6 +284,11 @@ public int getNumNondefaultElements() {
     return delegate.getNumNondefaultElements();
   }
 
+  @Override
+  public int getNumNonZeroElements() {
+    return delegate.getNumNonZeroElements();
+  }
+
   @Override
   public Iterator<Element> iterateNonZero() {
     return delegate.iterateNonZero();
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/DenseVector.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/DenseVector.java
index 07744996..7ced377d 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/DenseVector.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/DenseVector.java
@@ -19,11 +19,13 @@
 
 import java.util.Arrays;
 import java.util.Iterator;
+import java.util.NoSuchElementException;
 
-import com.google.common.collect.AbstractIterator;
 import org.apache.mahout.math.function.DoubleDoubleFunction;
 import org.apache.mahout.math.function.PlusMult;
 
+import com.google.common.base.Preconditions;
+
 /** Implements vector as an array of doubles */
 public class DenseVector extends AbstractVector {
 
@@ -146,6 +148,11 @@ public Vector assign(double value) {
     return this;
   }
   
+  @Override
+  public int getNumNondefaultElements() {
+    return values.length;
+  }
+
   @Override
   public Vector assign(Vector other, DoubleDoubleFunction function) {
     if (size() != other.size()) {
@@ -177,11 +184,6 @@ public Vector assign(DenseVector vector) {
     return this;
   }
 
-  @Override
-  public int getNumNondefaultElements() {
-    return values.length;
-  }
-
   @Override
   public Vector viewPart(int offset, int length) {
     if (offset < 0) {
@@ -227,29 +229,50 @@ public void addAll(Vector v) {
     }
   }
 
-  private final class NonDefaultIterator extends AbstractIterator<Element> {
-
+  private final class NonDefaultIterator implements Iterator<Element> {
     private final DenseElement element = new DenseElement();
-    private int index = 0;
+    private int index = -1;
+    private int lookAheadIndex = -1;
 
     @Override
-    protected Element computeNext() {
-      while (index < size() && values[index] == 0.0) {
-        index++;
+    public boolean hasNext() {
+      if (lookAheadIndex == index) {  // User calls hasNext() after a next()
+        lookAhead();
+      } // else user called hasNext() repeatedly.
+      return lookAheadIndex < size();
       }
-      if (index < size()) {
-        element.index = index;
-        index++;
-        return element;
-      } else {
-        return endOfData();
+
+    private void lookAhead() {
+      lookAheadIndex++;
+      while (lookAheadIndex < size() && values[lookAheadIndex] == 0.0) {
+        lookAheadIndex++;
       }
     }
 
+    @Override
+    public Element next() {
+      if (lookAheadIndex == index) { // If user called next() without checking hasNext().
+        lookAhead();
   }
 
-  private final class AllIterator extends AbstractIterator<Element> {
+      Preconditions.checkState(lookAheadIndex > index);
+      index = lookAheadIndex;
+
+      if (index >= size()) { // If the end is reached.
+        throw new NoSuchElementException();
+      }
+
+      element.index = index;
+      return element;
+    }
+
+    @Override
+    public void remove() {
+      throw new UnsupportedOperationException();
+    }
+  }
 
+  private final class AllIterator implements Iterator<Element> {
     private final DenseElement element = new DenseElement();
 
     private AllIterator() {
@@ -257,19 +280,26 @@ private AllIterator() {
     }
 
     @Override
-    protected Element computeNext() {
-      if (element.index + 1 < size()) {
+    public boolean hasNext() {
+      return element.index + 1 < size();
+    }
+
+    @Override
+    public Element next() {
+      if (element.index + 1 >= size()) { // If the end is reached.
+        throw new NoSuchElementException();
+      }
         element.index++;
         return element;
-      } else {
-        return endOfData();
-      }
     }
 
+    @Override
+    public void remove() {
+      throw new UnsupportedOperationException();
+    }
   }
 
   private final class DenseElement implements Element {
-
     int index;
 
     @Override
@@ -288,5 +318,4 @@ public void set(double value) {
       values[index] = value;
     }
   }
-
 }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/NamedVector.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/NamedVector.java
index 63bb33ed..2ad0cca1 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/NamedVector.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/NamedVector.java
@@ -17,11 +17,11 @@
 
 package org.apache.mahout.math;
 
+import java.util.Iterator;
+
 import org.apache.mahout.math.function.DoubleDoubleFunction;
 import org.apache.mahout.math.function.DoubleFunction;
 
-import java.util.Iterator;
-
 public class NamedVector implements Vector {
 
   private Vector delegate;
@@ -236,6 +236,11 @@ public void setQuick(int index, double value) {
     delegate.setQuick(index, value);
   }
 
+  @Override
+  public int getNumNonZeroElements() {
+    return delegate.getNumNonZeroElements();
+  }
+
   @Override
   public int getNumNondefaultElements() {
     return delegate.getNumNondefaultElements();
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/RandomAccessSparseVector.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/RandomAccessSparseVector.java
index f1091e98..be7ca826 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/RandomAccessSparseVector.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/RandomAccessSparseVector.java
@@ -18,10 +18,10 @@
 package org.apache.mahout.math;
 
 import java.util.Iterator;
+import java.util.NoSuchElementException;
 
-import com.google.common.collect.AbstractIterator;
-import org.apache.mahout.math.list.IntArrayList;
 import org.apache.mahout.math.map.OpenIntDoubleHashMap;
+import org.apache.mahout.math.map.OpenIntDoubleHashMap.MapElement;
 
 
 /** Implements vector that only stores non-zero doubles */
@@ -141,13 +141,13 @@ public void setQuick(int index, double value) {
   }
 
   @Override
-  public int getNumNondefaultElements() {
-    return values.size();
+  public RandomAccessSparseVector like() {
+    return new RandomAccessSparseVector(size(), values.size());
   }
 
   @Override
-  public RandomAccessSparseVector like() {
-    return new RandomAccessSparseVector(size(), values.size());
+  public int getNumNondefaultElements() {
+    return values.size();
   }
 
   /**
@@ -167,30 +167,53 @@ public RandomAccessSparseVector like() {
     return new AllIterator();
   }
 
-  private final class NonDefaultIterator extends AbstractIterator<Element> {
+  private final class NonDefaultIterator implements Iterator<Element> {
+    private final class NonDefaultElement implements Element {
+      @Override
+      public double get() {
+        return mapElement.get();
+      }
 
-    private final RandomAccessElement element = new RandomAccessElement();
-    private final IntArrayList indices = new IntArrayList();
-    private int offset;
+      @Override
+      public int index() {
+        return mapElement.index();
+      }
+
+      @Override
+      public void set(double value) {
+        invalidateCachedLength();
+        mapElement.set(value);
+      }
+    }
+
+
+    private MapElement mapElement;
+    private final NonDefaultElement element = new NonDefaultElement();
+
+    private final Iterator<MapElement> iterator;
 
     private NonDefaultIterator() {
-      values.keys(indices);
+      this.iterator = values.iterator();
     }
 
     @Override
-    protected Element computeNext() {
-      if (offset >= indices.size()) {
-        return endOfData();
+    public boolean hasNext() {
+      return iterator.hasNext();
       }
-      element.index = indices.get(offset);
-      offset++;
+
+    @Override
+    public Element next() {
+      mapElement = iterator.next(); // This will throw an exception at the end of ennumeration.
       return element;
     }
 
+    @Override
+    public void remove() {
+      throw new UnsupportedOperationException();
+    }
   }
 
-  private final class AllIterator extends AbstractIterator<Element> {
-
+  private final class AllIterator implements Iterator<Element> {
     private final RandomAccessElement element = new RandomAccessElement();
 
     private AllIterator() {
@@ -198,19 +221,26 @@ private AllIterator() {
     }
 
     @Override
-    protected Element computeNext() {
-      if (element.index + 1 < size()) {
+    public boolean hasNext() {
+      return element.index + 1 < size();
+    }
+
+    @Override
+    public Element next() {
+      if (!hasNext()) {
+        throw new NoSuchElementException();
+      }
         element.index++;
         return element;
-      } else {
-        return endOfData();
-      }
     }
 
+    @Override
+    public void remove() {
+      throw new UnsupportedOperationException();
+    }
   }
 
   private final class RandomAccessElement implements Element {
-
     int index;
 
     @Override
@@ -233,5 +263,4 @@ public void set(double value) {
       }
     }
   }
-  
 }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/SequentialAccessSparseVector.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/SequentialAccessSparseVector.java
index 24c1fa76..c1f11ece 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/SequentialAccessSparseVector.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/SequentialAccessSparseVector.java
@@ -17,12 +17,11 @@
 
 package org.apache.mahout.math;
 
-import com.google.common.collect.AbstractIterator;
-import com.google.common.primitives.Doubles;
-import org.apache.mahout.math.function.Functions;
-
 import java.util.Arrays;
 import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+import com.google.common.primitives.Doubles;
 
 /**
  * <p>
@@ -55,7 +54,8 @@ public SequentialAccessSparseVector() {
   }
 
   public SequentialAccessSparseVector(int cardinality) {
-    this(cardinality, cardinality / 8); // arbitrary estimate of 'sparseness'
+    this(cardinality, Math.min(100, cardinality / 1000 < 10 ? 10 : cardinality / 1000)); // arbitrary estimate of
+                                                                                           // 'sparseness'
   }
 
   public SequentialAccessSparseVector(int cardinality, int size) {
@@ -191,13 +191,13 @@ public void setQuick(int index, double value) {
   }
 
   @Override
-  public int getNumNondefaultElements() {
-    return values.getNumMappings();
+  public SequentialAccessSparseVector like() {
+    return new SequentialAccessSparseVector(size(), values.getNumMappings());
   }
 
   @Override
-  public SequentialAccessSparseVector like() {
-    return new SequentialAccessSparseVector(size(), values.getNumMappings());
+  public int getNumNondefaultElements() {
+    return values.getNumMappings();
   }
 
   @Override
@@ -210,65 +210,54 @@ public SequentialAccessSparseVector like() {
     return new AllIterator();
   }
 
+  private final class NonDefaultIterator implements Iterator<Element> {
+    private final NonDefaultElement element = new NonDefaultElement();
+
   @Override
-  public Vector minus(Vector that) {
-    if (size() != that.size()) {
-      throw new CardinalityException(size(), that.size());
-    }
-    // Here we compute "that - this" since it's not fast to randomly access "this"
-    // and then invert at the end
-    Vector result = that.clone();
-    Iterator<Element> iter = this.iterateNonZero();
-    while (iter.hasNext()) {
-      Element thisElement = iter.next();
-      int index = thisElement.index();
-      result.setQuick(index, that.getQuick(index) - thisElement.get());
+    public boolean hasNext() {
+      return element.getNextOffset() < values.getNumMappings();
     }
-    result.assign(Functions.NEGATE);
-    return result;
-  }
-
-
-  private final class NonDefaultIterator extends AbstractIterator<Element> {
-
-    private final NonDefaultElement element = new NonDefaultElement();
 
     @Override
-    protected Element computeNext() {
-      int numMappings = values.getNumMappings();
-      if (numMappings <= 0 || element.getNextOffset() >= numMappings) {
-        return endOfData();
+    public Element next() {
+      if (!hasNext()) {
+        throw new NoSuchElementException();
       }
       element.advanceOffset();
       return element;
     }
 
+    @Override
+    public void remove() {
+      throw new UnsupportedOperationException();
+    }
   }
 
-  private final class AllIterator extends AbstractIterator<Element> {
-
+  private final class AllIterator implements Iterator<Element> {
     private final AllElement element = new AllElement();
 
     @Override
-    protected Element computeNext() {
-      int numMappings = values.getNumMappings();
-      if (numMappings <= 0 || element.getNextIndex() > values.getIndices()[numMappings - 1]) {
-        if (element.index() >= SequentialAccessSparseVector.this.size() - 1) {
-          return endOfData();
-        } else {
-          element.advanceIndex();
-          return element;
+    public boolean hasNext() {
+      return element.getNextIndex() < SequentialAccessSparseVector.this.size();
         }
-      } else {
+
+    @Override
+    public Element next() {
+      if (!hasNext()) {
+        throw new NoSuchElementException();
+      }
+
         element.advanceIndex();
         return element;
       }
-    }
 
+    @Override
+    public void remove() {
+      throw new UnsupportedOperationException();
+    }
   }
 
   private final class NonDefaultElement implements Element {
-
     private int offset = -1;
 
     void advanceOffset() {
@@ -297,7 +286,6 @@ public void set(double value) {
   }
 
   private final class AllElement implements Element {
-
     private int index = -1;
     private int nextOffset;
 
@@ -368,7 +356,5 @@ public boolean equals(Object o) {
       OrderedElement other = (OrderedElement) o;
       return index == other.index && value == other.value;
     }
-
   }
-  
 }
diff --git a/mahout/trunk/math/src/main/java/org/apache/mahout/math/Vector.java b/mahout/trunk/math/src/main/java/org/apache/mahout/math/Vector.java
index 3ad6bf8f..d4196996 100644
--- a/mahout/trunk/math/src/main/java/org/apache/mahout/math/Vector.java
+++ b/mahout/trunk/math/src/main/java/org/apache/mahout/math/Vector.java
@@ -18,11 +18,11 @@
 package org.apache.mahout.math;
 
 
+import java.util.Iterator;
+
 import org.apache.mahout.math.function.DoubleDoubleFunction;
 import org.apache.mahout.math.function.DoubleFunction;
 
-import java.util.Iterator;
-
 /**
  * The basic interface including numerous convenience functions <p/> NOTE: All implementing classes must have a
  * constructor that takes an int for cardinality and a no-arg constructor that can be used for marshalling the Writable
@@ -305,6 +305,13 @@
    */
   int getNumNondefaultElements();
 
+  /**
+   * Return the number of non zero elements in the vector.
+   *
+   * @return an int
+   */
+  int getNumNonZeroElements();
+
   /**
    * Return a new vector containing the product of each value of the recipient and the argument
    *
diff --git a/mahout/trunk/math/src/main/java-templates/org/apache/mahout/math/map/AbstractKeyTypeObjectMap.java.t b/mahout/trunk/math/src/main/java-templates/org/apache/mahout/math/map/AbstractKeyTypeObjectMap.java.t
index e1551386..4ffbe3a0 100644
--- a/mahout/trunk/math/src/main/java-templates/org/apache/mahout/math/map/AbstractKeyTypeObjectMap.java.t
+++ b/mahout/trunk/math/src/main/java-templates/org/apache/mahout/math/map/AbstractKeyTypeObjectMap.java.t
@@ -306,14 +306,14 @@ public abstract class Abstract${keyTypeCap}ObjectMap<T> extends AbstractSet {
     keys(keyList);
     keyList.sort();
     // the following is straightforward if not the most space-efficient possibility
-    T[] tempValueList = (T[]) new Object[keyList.size()];
+    Object[] tempValueList = new Object[keyList.size()];
 
     for (int i = keyList.size(); --i >= 0;) {
       tempValueList[i] = get(keyList.getQuick(i));
     }
     valueList.clear();
-    for (T value : tempValueList) {
-      valueList.add(value);
+    for (Object value : tempValueList) {
+      valueList.add((T) value);
     }
     
   }
diff --git a/mahout/trunk/math/src/main/java-templates/org/apache/mahout/math/map/OpenKeyTypeValueTypeHashMap.java.t b/mahout/trunk/math/src/main/java-templates/org/apache/mahout/math/map/OpenKeyTypeValueTypeHashMap.java.t
index eec4aa4e..239c3a59 100644
--- a/mahout/trunk/math/src/main/java-templates/org/apache/mahout/math/map/OpenKeyTypeValueTypeHashMap.java.t
+++ b/mahout/trunk/math/src/main/java-templates/org/apache/mahout/math/map/OpenKeyTypeValueTypeHashMap.java.t
@@ -28,15 +28,20 @@ It is provided "as is" without expressed or implied warranty.
 package org.apache.mahout.math.map;
 
 import java.util.Arrays;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
 
+import org.apache.mahout.math.Vector.Element;
 import org.apache.mahout.math.function.${keyTypeCap}${valueTypeCap}Procedure;
 import org.apache.mahout.math.function.${keyTypeCap}Procedure;
+import org.apache.mahout.math.function.IntProcedure;
 import org.apache.mahout.math.list.${keyTypeCap}ArrayList;
 
 #if (${keyType} != ${valueType})
 import org.apache.mahout.math.list.${valueTypeCap}ArrayList;
 #end
 
+
 /**
   * Open hash map from ${keyType} keys to ${valueType} values.
  **/
@@ -336,6 +341,62 @@ public class Open${keyTypeCap}${valueTypeCap}HashMap extends Abstract${keyTypeCa
     }
   }
 
+  public Iterator<MapElement> iterator() {
+    return new MapIterator();
+  }
+
+  public final class MapElement {
+    private int offset = -1;
+    int seen = 0;
+
+    boolean advanceOffset() {
+      offset++;
+      while (offset < state.length && state[offset] != FULL) {
+        offset++;
+      }
+      if (offset < state.length) {
+        seen++;
+      }
+      return offset < state.length;
+    }
+    
+    public ${valueType} get() {
+      return values[offset];
+    }
+
+    public ${keyType} index() {
+      return table[offset];
+    }
+
+    public void set(${valueType} value) {
+      values[offset] = value;
+    }
+  }
+  
+  public final class MapIterator implements Iterator<MapElement> {
+    private final MapElement element = new MapElement();
+
+    private MapIterator() { }
+    
+    @Override
+    public boolean hasNext() {
+      return element.seen < distinct;
+    }
+
+    @Override
+    public MapElement next() {
+      if (element.advanceOffset()) {
+        return element;
+      }
+      throw new NoSuchElementException();
+    }
+
+    @Override
+    public void remove() {
+      throw new UnsupportedOperationException();
+    }
+  }
+  
   /**
    * Fills all pairs satisfying a given condition into the specified lists. Fills into the lists, starting at index 0.
    * After this call returns the specified lists both have a new size, the number of pairs satisfying the condition.
@@ -380,7 +441,7 @@ public class Open${keyTypeCap}${valueTypeCap}HashMap extends Abstract${keyTypeCa
   @Override
   public boolean put(${keyType} key, ${valueType} value) {
     int i = indexOfInsertion(key);
-    if (i < 0) { //already contained
+    if (i < 0) { // already contained
       i = -i - 1;
       this.values[i] = value;
       return false;
diff --git a/mahout/trunk/math/src/test/java/org/apache/mahout/math/AbstractVectorTest.java b/mahout/trunk/math/src/test/java/org/apache/mahout/math/AbstractVectorTest.java
index ad7c730d..2b11199d 100644
--- a/mahout/trunk/math/src/test/java/org/apache/mahout/math/AbstractVectorTest.java
+++ b/mahout/trunk/math/src/test/java/org/apache/mahout/math/AbstractVectorTest.java
@@ -1,5 +1,8 @@
 package org.apache.mahout.math;
 
+import java.util.Iterator;
+import java.util.Random;
+
 import org.apache.mahout.common.RandomUtils;
 import org.apache.mahout.math.function.Functions;
 import org.apache.mahout.math.jet.random.Normal;
@@ -7,9 +10,6 @@
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Iterator;
-import java.util.Random;
-
 /**
  * Makes sure that a vector under test acts the same as a DenseVector or RandomAccessSparseVector
  * (according to whether it is dense or sparse).  Most operations need to be done within a reasonable
@@ -180,7 +180,7 @@ public void setUp() throws Exception {
     super.setUp();
     test = generateTestVector(2 * values.length + 1);
     for (int i = 0; i < values.length; i++) {
-      test.set(2*i + 1, values[i]);
+      test.set(2 * i + 1, values[i]);
     }
   }
 
diff --git a/mahout/trunk/math/src/test/java/org/apache/mahout/math/CentroidTest.java b/mahout/trunk/math/src/test/java/org/apache/mahout/math/CentroidTest.java
index 70feb31d..3e7afb6c 100644
--- a/mahout/trunk/math/src/test/java/org/apache/mahout/math/CentroidTest.java
+++ b/mahout/trunk/math/src/test/java/org/apache/mahout/math/CentroidTest.java
@@ -62,12 +62,11 @@ public Centroid vectorToTest(int size) {
 
   @Override
   public void testSize() {
-    assertEquals("size", 7, getTestVector().getNumNondefaultElements());
+    assertEquals("size", 3, getTestVector().getNumNondefaultElements());
   }
 
   @Override
   Vector generateTestVector(int cardinality) {
     return new Centroid(new WeightedVector(new DenseVector(cardinality), 3.14, 53));
   }
-
 }
diff --git a/mahout/trunk/math/src/test/java/org/apache/mahout/math/MatrixTest.java b/mahout/trunk/math/src/test/java/org/apache/mahout/math/MatrixTest.java
index e025cc9b..dc3be8ad 100644
--- a/mahout/trunk/math/src/test/java/org/apache/mahout/math/MatrixTest.java
+++ b/mahout/trunk/math/src/test/java/org/apache/mahout/math/MatrixTest.java
@@ -17,16 +17,17 @@
 
 package org.apache.mahout.math;
 
-import com.google.common.collect.Maps;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Random;
+
 import org.apache.mahout.common.RandomUtils;
 import org.apache.mahout.math.function.Functions;
 import org.apache.mahout.math.function.VectorFunction;
 import org.junit.Before;
 import org.junit.Test;
 
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Random;
+import com.google.common.collect.Maps;
 
 public abstract class MatrixTest extends MahoutTestCase {
 
diff --git a/mahout/trunk/math/src/test/java/org/apache/mahout/math/TestDenseVector.java b/mahout/trunk/math/src/test/java/org/apache/mahout/math/TestDenseVector.java
index 99886f43..0bb53188 100644
--- a/mahout/trunk/math/src/test/java/org/apache/mahout/math/TestDenseVector.java
+++ b/mahout/trunk/math/src/test/java/org/apache/mahout/math/TestDenseVector.java
@@ -28,7 +28,7 @@ Vector generateTestVector(int cardinality) {
 
   @Override
   public void testSize() {
-    assertEquals("size", 7, getTestVector().getNumNondefaultElements());
+    assertEquals("size", 3, getTestVector().getNumNondefaultElements());
   }
 
   @Override
diff --git a/mahout/trunk/math/src/test/java/org/apache/mahout/math/VectorTest.java b/mahout/trunk/math/src/test/java/org/apache/mahout/math/VectorTest.java
index f734193a..1685aa20 100644
--- a/mahout/trunk/math/src/test/java/org/apache/mahout/math/VectorTest.java
+++ b/mahout/trunk/math/src/test/java/org/apache/mahout/math/VectorTest.java
@@ -17,12 +17,16 @@
 
 package org.apache.mahout.math;
 
-import com.google.common.collect.Sets;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import java.util.Set;
+
+import org.apache.mahout.math.Vector.Element;
 import org.apache.mahout.math.function.Functions;
 import org.junit.Test;
 
-import java.util.Collection;
-import java.util.Iterator;
+import com.google.common.collect.Sets;
 
 public final class VectorTest extends MahoutTestCase {
 
@@ -52,7 +56,7 @@ public void testSparseVectorFullIteration() {
     }
 
     int elements = 0;
-    for (Vector.Element ignore : vector) {
+    for (Element ignore : vector) {
       elements++;
     }
     assertEquals(n, elements);
@@ -79,7 +83,7 @@ public void testSparseVectorSparseIteration() {
     }
 
     int elements = 0;
-    Iterator<Vector.Element> it = vector.iterateNonZero();
+    Iterator<Element> it = vector.iterateNonZero();
     while (it.hasNext()) {
       it.next();
       elements++;
@@ -272,9 +276,9 @@ private static void doTestGetLengthSquared(Vector v) {
     expected = lengthSquaredSlowly(v);
     assertEquals("mutation via setQuick() fails to change lengthSquared", expected, v.getLengthSquared(), EPSILON);
 
-    Iterator<Vector.Element> it = v.iterator();
+    Iterator<Element> it = v.iterator();
     while (it.hasNext()) {
-      Vector.Element e = it.next();
+      Element e = it.next();
       if (e.index() == v.size() - 2) {
         e.set(e.get() - 5.0);
       }
@@ -287,7 +291,7 @@ private static void doTestGetLengthSquared(Vector v) {
     int i = 0;
     while (it.hasNext()) {
       i++;
-      Vector.Element e = it.next();
+      Element e = it.next();
       if (i == v.getNumNondefaultElements() - 1) {
         e.set(e.get() - 5.0);
       }
@@ -368,10 +372,10 @@ public void testIterator() {
 
   private static void doTestIterators(Vector vector, Collection<Integer> expectedIndices) {
     expectedIndices = Sets.newHashSet(expectedIndices);
-    Iterator<Vector.Element> allIterator = vector.iterator();
+    Iterator<Element> allIterator = vector.iterator();
     int index = 0;
     while (allIterator.hasNext()) {
-      Vector.Element element = allIterator.next();
+      Element element = allIterator.next();
       assertEquals(index, element.index());
       if (expectedIndices.contains(index)) {
         assertEquals((double) index * 2, element.get(), EPSILON);
@@ -381,9 +385,9 @@ private static void doTestIterators(Vector vector, Collection<Integer> expectedI
       index++;
     }
 
-    Iterator<Vector.Element> nonZeroIterator = vector.iterateNonZero();
+    Iterator<Element> nonZeroIterator = vector.iterateNonZero();
     while (nonZeroIterator.hasNext()) {
-      Vector.Element element = nonZeroIterator.next();
+      Element element = nonZeroIterator.next();
       index = element.index();
       assertTrue(expectedIndices.contains(index));
       assertEquals((double) index * 2, element.get(), EPSILON);
@@ -527,7 +531,7 @@ public void testLogNormalize() {
 
   private static void assertVectorEquals(Vector expected, Vector actual, double epsilon) {
     assertEquals(expected.size(), actual.size());
-    for (Vector.Element x : expected) {
+    for (Element x : expected) {
       assertEquals(x.get(), actual.get(x.index()), epsilon);
     }
   }
@@ -702,9 +706,9 @@ public void testVectorView()  {
   /** Asserts a vector using enumeration equals a given dense vector */
   private static void doTestEnumeration(double[] apriori, Vector vector) {
     double[] test = new double[apriori.length];
-    Iterator<Vector.Element> iter = vector.iterateNonZero();
+    Iterator<Element> iter = vector.iterateNonZero();
     while (iter.hasNext()) {
-      Vector.Element e = iter.next();
+      Element e = iter.next();
       test[e.index()] = e.get();
     }
 
@@ -919,4 +923,215 @@ public void testRandomScanDiff() {
 
     assertEquals(0.1 * 0.1 + 2.1 * 2.1 + 3.1 * 3.1, AbstractVector.randomScanDiff(left, right), 0);
   }
+
+  @Test
+  public void testIteratorRasv() {
+    testIterator(new RandomAccessSparseVector(99));
+    testEmptyAllIterator(new RandomAccessSparseVector(0));
+    testExample1NonZeroIterator(new RandomAccessSparseVector(13));
+  }
+
+  @Test
+  public void testIteratorSasv() {
+    testIterator(new SequentialAccessSparseVector(99));
+    testEmptyAllIterator(new SequentialAccessSparseVector(0));
+    testExample1NonZeroIterator(new SequentialAccessSparseVector(13));
+  }
+
+  @Test
+  public void testIteratorDense() {
+    testIterator(new DenseVector(99));
+    testEmptyAllIterator(new DenseVector(0));
+    testExample1NonZeroIterator(new DenseVector(13));
+  }
+
+  private void testIterator(Vector vector) {
+    testSkips(vector.like());
+    testSkipsLast(vector.like());
+    testEmptyNonZeroIterator(vector.like());
+    testSingleNonZeroIterator(vector.like());
+  }
+
+  private void testSkips(Vector vector) {
+    vector.set(0, 1);
+    vector.set(2, 2);
+    vector.set(4, 3);
+    vector.set(6, 4);
+
+    // Test non zero iterator.
+    Iterator<Element> it = vector.iterateNonZero();
+    Element element = null;
+    int i = 0;
+    while (it.hasNext()) {  // hasNext is called more often than next
+      if (i % 2 == 0) {
+        element = it.next();
+      }
+      assertEquals(element.index(), 2* (i/2));
+      assertEquals(element.get(), vector.get(2* (i/2)), 0);
+      ++i;
+    }
+    assertEquals(7, i);  // Last element is print only once.
+
+    // Test all iterator.
+    it = vector.iterator();
+    element = null;
+    i = 0;
+    while (it.hasNext()) { // hasNext is called more often than next
+      if (i % 2 == 0) {
+        element = it.next();
+      }
+      assertEquals(element.index(), i/2);
+      assertEquals(element.get(), vector.get(i/2), 0);
+      ++i;
+    }
+    assertEquals(197, i);  // Last element is print only once.
+  }
+
+  private void testSkipsLast(Vector vector) {
+    vector.set(1, 6);
+    vector.set(98, 6);
+
+    // Test non zero iterator.
+    Iterator<Element> it = vector.iterateNonZero();
+
+    int i = 0;
+    while (it.hasNext()) {  // hasNext is called more often than next
+      Element element = it.next();
+      ++i;
+    }
+    assertEquals(2, i);  // Last element is print only once.
+
+    // Test all iterator.
+    it = vector.iterator();
+    i = 0;
+    while (it.hasNext()) { // hasNext is called more often than next
+      Element element = it.next();
+      assertEquals(i, element.index());
+      ++i;
+    }
+    assertFalse(it.hasNext());
+    assertEquals(99, i);  // Last element is print only once.
+  }
+
+  // Test NonZeroIterator on an list with 0 elements
+  private void testEmptyNonZeroIterator(Vector vector) {
+    // Test non zero iterator.
+    Iterator<Element> it = vector.iterateNonZero();
+    int i = 0;
+    while (it.hasNext()) {
+      ++i;
+    }
+    assertEquals(0, i);
+
+    it = vector.iterateNonZero();
+    assertFalse(it.hasNext());
+    try {
+      it.next();
+      fail();
+    } catch (NoSuchElementException e) {
+      // expected;
+    }
+  }
+
+  // Test AllIterator on an list with 0 cardinality
+  private void testEmptyAllIterator(Vector vector) {
+    // Test non zero iterator.
+    Iterator<Element> it = vector.iterator();
+    int i = 0;
+    while (it.hasNext()) {
+      ++i;
+    }
+    assertEquals(0, i);
+
+    it = vector.iterateNonZero();
+    assertFalse(it.hasNext());
+    try {
+      it.next();
+      fail();
+    } catch (NoSuchElementException e) {
+      // expected;
+    }
+
+    it = vector.iterator();
+    assertFalse(it.hasNext());
+    try {
+      it.next();
+      fail();
+    } catch (NoSuchElementException e) {
+      // expected;
+    }
+  }
+
+  // Test NonZeroIterator on an list with 1 elements
+  private void testSingleNonZeroIterator(Vector vector) {
+    vector.set(1, 6);
+    // Test non zero iterator.
+    Iterator<Element> it = vector.iterateNonZero();
+    for (int i = 0; i < 10; ++i) {
+      assertTrue(it.hasNext());
+    }
+
+    it = vector.iterateNonZero();
+    it.next();
+    for (int i = 0; i < 10; ++i) {
+      assertFalse(it.hasNext());
+    }
+    try {
+      it.next();
+      fail();
+    } catch (NoSuchElementException e) {
+      // expected;
+    }
+  }
+
+  // Test NonZeroIterator on double[] { 0, 2, 0, 0, 8, 3, 0, 6, 0, 1, 1, 2, 1 }
+  private void testExample1NonZeroIterator(Vector vector) {
+    double[] val = new double[] { 0, 2, 0, 0, 8, 3, 0, 6, 0, 1, 1, 2, 1 };
+    for (int i = 0; i < val.length; ++i) {
+      vector.set(i, val[i]);
+    }
+
+    Set<Integer> expected = Sets.newHashSet(1, 4, 5, 7, 9, 10, 11, 12);
+    Set<Double> expectedValue = Sets.newHashSet(2.0, 8.0, 3.0, 6.0, 1.0);
+    // Test non zero iterator.
+    Iterator<Element> it = vector.iterateNonZero();
+    int i = 0;
+    while (it.hasNext()) {
+      Element e = it.next();
+      assertTrue(expected.contains(e.index()));
+      assertTrue(expectedValue.contains(e.get()));
+      ++i;
+    }
+    assertEquals(8, i);
+
+    // Check if the non zero elements are correct.
+    assertEquals(8, vector.getNumNonZeroElements());
+
+    // Set one element to 0.
+    it = vector.iterateNonZero();
+    i = 0;
+    while (it.hasNext()) {
+      Element e = it.next();
+      if (e.index() == 5) {
+        e.set(0.0);
+      }
+      ++i;
+    }
+    assertEquals(8, i);
+    assertEquals(7, vector.getNumNonZeroElements());
+
+    // Remove one element
+    it = vector.iterateNonZero();
+    i = 0;
+    while (it.hasNext()) {
+      Element e = it.next();
+      if (e.index() == 5) {
+        vector.set(5, 0.0);
+      }
+      ++i;
+    }
+    assertEquals(7, i); // This just got messed up.
+    // TODO: throw an exception if the underlying hashmap or array length is modified.
+    assertEquals(7, vector.getNumNonZeroElements());
+  }
 }
diff --git a/mahout/trunk/math/src/test/java/org/apache/mahout/math/WeightedVectorTest.java b/mahout/trunk/math/src/test/java/org/apache/mahout/math/WeightedVectorTest.java
index 73f34ee8..433fb4dd 100644
--- a/mahout/trunk/math/src/test/java/org/apache/mahout/math/WeightedVectorTest.java
+++ b/mahout/trunk/math/src/test/java/org/apache/mahout/math/WeightedVectorTest.java
@@ -78,7 +78,7 @@ public void testProjection() {
 
   @Override
   public void testSize() {
-    assertEquals("size", 7, getTestVector().getNumNondefaultElements());
+    assertEquals("size", 3, getTestVector().getNumNondefaultElements());
   }
 
   @Override
