diff --git a/lucene/dev/branches/docvalues/lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DocMaker.java b/lucene/dev/branches/docvalues/lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DocMaker.java
index b2830071..493745b1 100644
--- a/lucene/dev/branches/docvalues/lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DocMaker.java
+++ b/lucene/dev/branches/docvalues/lucene/contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/DocMaker.java
@@ -33,7 +33,7 @@
 import org.apache.lucene.document.Field.Index;
 import org.apache.lucene.document.Field.Store;
 import org.apache.lucene.document.Field.TermVector;
-import org.apache.lucene.index.values.Values;
+import org.apache.lucene.index.values.Type;
 
 /**
  * Creates {@link Document} objects. Uses a {@link ContentSource} to generate
@@ -160,13 +160,13 @@ Field getField(String name, Store store, Index index, TermVector termVector) {
   private long lastPrintedNumUniqueBytes = 0;
 
   private int printNum = 0;
-  private Map<String, Values> fieldVauleMap;
+  private Map<String, Type> fieldVauleMap;
 
   // create a doc
   // use only part of the body, modify it to keep the rest (or use all if size==0).
   // reset the docdata properties so they are not added more than once.
   private Document createDocument(DocData docData, int size, int cnt) throws UnsupportedEncodingException {
-    Values valueType;
+    Type valueType;
     final DocState ds = getDocState();
     final Document doc = reuseFields ? ds.doc : new Document();
     doc.getFields().clear();
@@ -252,7 +252,7 @@ private Document createDocument(DocData docData, int size, int cnt) throws Unsup
   }
   
   private void trySetIndexValues(Field field) {
-    final Values valueType;
+    final Type valueType;
     if((valueType = fieldVauleMap.get(field.name())) != null)
       ValuesField.set(field, valueType);
   }
@@ -385,18 +385,18 @@ public synchronized void resetInputs() throws IOException {
     resetLeftovers();
   }
   
-  private static final Map<String, Values> parseValueFields(String fields) {
+  private static final Map<String, Type> parseValueFields(String fields) {
     if(fields == null)
       return Collections.emptyMap();
     String[] split = fields.split(";");
-    Map<String, Values> result = new HashMap<String, Values>();
+    Map<String, Type> result = new HashMap<String, Type>();
     for (String tuple : split) {
       final String[] nameValue = tuple.split("=");
       if (nameValue.length != 2) {
         throw new IllegalArgumentException("illegal doc.stored.values format: "
             + fields + " expected fieldname=ValuesType;...;...;");
       }
-      result.put(nameValue[0].trim(), Values.valueOf(nameValue[1]));
+      result.put(nameValue[0].trim(), Type.valueOf(nameValue[1]));
     }
     return result;
   }
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/document/ValuesField.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/document/ValuesField.java
index 5acb6f27..105ac86a 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/document/ValuesField.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/document/ValuesField.java
@@ -24,7 +24,7 @@
 import org.apache.lucene.document.Field.Store;
 import org.apache.lucene.document.Field.TermVector;
 import org.apache.lucene.index.values.PerDocFieldValues;
-import org.apache.lucene.index.values.Values;
+import org.apache.lucene.index.values.Type;
 import org.apache.lucene.util.BytesRef;
 
 /**
@@ -36,7 +36,7 @@
   protected BytesRef bytes;
   protected double doubleValue;
   protected long longValue;
-  protected Values type;
+  protected Type type;
   protected Comparator<BytesRef> bytesComparator;
   
   public ValuesField(String name) {
@@ -49,26 +49,26 @@ public ValuesField(String name) {
   }
   
   public void setInt(long value) {
-    type = Values.PACKED_INTS;
+    type = Type.PACKED_INTS;
     longValue = value;
   }
 
   public void setFloat(float value) {
-    type = Values.SIMPLE_FLOAT_4BYTE;
+    type = Type.SIMPLE_FLOAT_4BYTE;
     doubleValue = value;
   }
 
   public void setFloat(double value) {
-    type = Values.SIMPLE_FLOAT_8BYTE;
+    type = Type.SIMPLE_FLOAT_8BYTE;
     doubleValue = value;
   }
 
-  public void setBytes(BytesRef value, Values type) {
+  public void setBytes(BytesRef value, Type type) {
     setBytes(value, type, null);
 
   }
 
-  public void setBytes(BytesRef value, Values type, Comparator<BytesRef> comp) {
+  public void setBytes(BytesRef value, Type type, Comparator<BytesRef> comp) {
     this.type = type;
     if (bytes == null) {
       this.bytes = new BytesRef();
@@ -97,11 +97,11 @@ public void setBytesComparator(Comparator<BytesRef> comp) {
     this.bytesComparator = comp;
   }
 
-  public void setType(Values type) {
+  public void setType(Type type) {
     this.type = type;
   }
 
-  public Values type() {
+  public Type type() {
     return type;
   }
 
@@ -122,7 +122,7 @@ public TokenStream tokenStreamValue() {
     return field;
   }
 
-  public static <T extends AbstractField> T set(T field, Values type) {
+  public static <T extends AbstractField> T set(T field, Type type) {
     if (field instanceof ValuesField)
       return field;
     final ValuesField valField = new ValuesField();
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FieldInfo.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FieldInfo.java
index e2fbf14f..96ace5f1 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FieldInfo.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FieldInfo.java
@@ -1,6 +1,6 @@
 package org.apache.lucene.index;
 
-import org.apache.lucene.index.values.Values;
+import org.apache.lucene.index.values.Type;
 
 /**
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -24,7 +24,7 @@
   public String name;
   public boolean isIndexed;
   public int number;
-  Values docValues;
+  Type docValues;
 
 
   // true if term vector for this field should be stored
@@ -94,7 +94,7 @@ void update(boolean isIndexed, boolean storeTermVector, boolean storePositionWit
     }
   }
 
-  void setDocValues(Values v) {
+  void setDocValues(Type v) {
     if (docValues != null) {
       if (docValues != v) {
         throw new IllegalArgumentException("indexValues is already set to " + docValues + "; cannot change to " + v);
@@ -108,7 +108,7 @@ public boolean hasDocValues() {
     return docValues != null;
   }
 
-  public Values getDocValues() {
+  public Type getDocValues() {
     return docValues;
   }
 }
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FieldInfos.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FieldInfos.java
index a6baae51..ea5d528c 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FieldInfos.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FieldInfos.java
@@ -19,7 +19,7 @@
 
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Fieldable;
-import org.apache.lucene.index.values.Values;
+import org.apache.lucene.index.values.Type;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
@@ -384,31 +384,31 @@ private void read(IndexInput input, String fileName) throws IOException {
           fi.docValues = null;
           break;
         case 1:
-          fi.docValues = Values.PACKED_INTS;
+          fi.docValues = Type.PACKED_INTS;
           break;
         case 2:
-          fi.docValues = Values.SIMPLE_FLOAT_4BYTE;
+          fi.docValues = Type.SIMPLE_FLOAT_4BYTE;
           break;
         case 3:
-          fi.docValues = Values.SIMPLE_FLOAT_8BYTE;
+          fi.docValues = Type.SIMPLE_FLOAT_8BYTE;
           break;
         case 4:
-          fi.docValues = Values.BYTES_FIXED_STRAIGHT;
+          fi.docValues = Type.BYTES_FIXED_STRAIGHT;
           break;
         case 5:
-          fi.docValues = Values.BYTES_FIXED_DEREF;
+          fi.docValues = Type.BYTES_FIXED_DEREF;
           break;
         case 6:
-          fi.docValues = Values.BYTES_FIXED_SORTED;
+          fi.docValues = Type.BYTES_FIXED_SORTED;
           break;
         case 7:
-          fi.docValues = Values.BYTES_VAR_STRAIGHT;
+          fi.docValues = Type.BYTES_VAR_STRAIGHT;
           break;
         case 8:
-          fi.docValues = Values.BYTES_VAR_DEREF;
+          fi.docValues = Type.BYTES_VAR_DEREF;
           break;
         case 9:
-          fi.docValues = Values.BYTES_VAR_SORTED;
+          fi.docValues = Type.BYTES_VAR_SORTED;
           break;
         default:
           throw new IllegalStateException("unhandled indexValues type " + b);
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FieldsEnum.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FieldsEnum.java
index e3112ca8..290cd107 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FieldsEnum.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FieldsEnum.java
@@ -20,7 +20,7 @@
 import java.io.IOException;
 
 import org.apache.lucene.index.values.DocValues;
-import org.apache.lucene.index.values.ValuesEnum;
+import org.apache.lucene.index.values.DocValuesEnum;
 import org.apache.lucene.util.AttributeSource;
 
 /** Enumerates indexed fields.  You must first call {@link
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FilterIndexReader.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FilterIndexReader.java
index f61e2bc5..8c2b450c 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FilterIndexReader.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/FilterIndexReader.java
@@ -20,7 +20,7 @@
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.FieldSelector;
 import org.apache.lucene.index.values.DocValues;
-import org.apache.lucene.index.values.ValuesEnum;
+import org.apache.lucene.index.values.DocValuesEnum;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.search.FieldCache; // not great (circular); used only to purge FieldCache entry on close
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/MultiFields.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/MultiFields.java
index 9137d607..a871ce87 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/MultiFields.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/MultiFields.java
@@ -25,7 +25,7 @@
 
 import org.apache.lucene.index.values.DocValues;
 import org.apache.lucene.index.values.MultiDocValues;
-import org.apache.lucene.index.values.Values;
+import org.apache.lucene.index.values.Type;
 import org.apache.lucene.index.values.MultiDocValues.DocValuesIndex;
 import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util.ReaderUtil.Gather;  // for javadocs
@@ -293,7 +293,7 @@ public DocValues docValues(String field) throws IOException {
       // create & add to docValues:
       final List<MultiDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiDocValues.DocValuesIndex>();
       int docsUpto = 0;
-      Values type = null;
+      Type type = null;
       // Gather all sub-readers that share this field
       for(int i=0;i<subs.length;i++) {
          DocValues values = subs[i].docValues(field);
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/MultiFieldsEnum.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/MultiFieldsEnum.java
index f5958710..3cc3db13 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/MultiFieldsEnum.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/MultiFieldsEnum.java
@@ -19,7 +19,7 @@
 
 import org.apache.lucene.index.values.DocValues;
 import org.apache.lucene.index.values.MultiDocValues;
-import org.apache.lucene.index.values.Values;
+import org.apache.lucene.index.values.Type;
 import org.apache.lucene.util.PriorityQueue;
 import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util.ReaderUtil.Slice;
@@ -157,7 +157,7 @@ protected final boolean lessThan(FieldsEnumWithSlice fieldsA, FieldsEnumWithSlic
   public DocValues docValues() throws IOException {
     final List<MultiDocValues.DocValuesIndex> docValuesIndex = new ArrayList<MultiDocValues.DocValuesIndex>();
     int docsUpto = 0;
-    Values type = null;
+    Type type = null;
     final int numEnums = enumWithSlices.length;
     for (int i = 0; i < numEnums; i++) {
       FieldsEnumWithSlice withSlice = enumWithSlices[i];
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/SegmentMerger.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/SegmentMerger.java
index 48f516b9..5535bbe7 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/SegmentMerger.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/SegmentMerger.java
@@ -32,7 +32,7 @@
 import org.apache.lucene.index.codecs.Codec;
 import org.apache.lucene.index.codecs.MergeState;
 import org.apache.lucene.index.codecs.FieldsConsumer;
-import org.apache.lucene.index.values.Values;
+import org.apache.lucene.index.values.Type;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
@@ -274,8 +274,8 @@ private final int mergeFields() throws CorruptIndexException, IOException {
                                             fi.storePositionWithTermVector, fi.storeOffsetWithTermVector,
                                             !reader.hasNorms(fi.name), fi.storePayloads,
                                             fi.omitTermFreqAndPositions);
-          final Values fiIndexValues = fi.docValues;
-          final Values mergedDocValues = merged.docValues;
+          final Type fiIndexValues = fi.docValues;
+          final Type mergedDocValues = merged.docValues;
           if (mergedDocValues == null) {
             merged.setDocValues(fiIndexValues);
           } else if (mergedDocValues != fiIndexValues) {
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/SegmentReader.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/SegmentReader.java
index 47446854..10974b45 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/SegmentReader.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/SegmentReader.java
@@ -45,7 +45,7 @@
 import org.apache.lucene.index.values.Ints;
 import org.apache.lucene.index.values.DocValues;
 import org.apache.lucene.index.values.Floats;
-import org.apache.lucene.index.values.Values;
+import org.apache.lucene.index.values.Type;
 import org.apache.lucene.search.FieldCache; // not great (circular); used only to purge FieldCache entry on close
 import org.apache.lucene.util.BytesRef;
 
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/codecs/docvalues/DocValuesProducerBase.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/codecs/docvalues/DocValuesProducerBase.java
index 08307d4d..4cf1d5a9 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/codecs/docvalues/DocValuesProducerBase.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/codecs/docvalues/DocValuesProducerBase.java
@@ -27,7 +27,7 @@
 import org.apache.lucene.index.values.DocValues;
 import org.apache.lucene.index.values.Floats;
 import org.apache.lucene.index.values.Ints;
-import org.apache.lucene.index.values.Values;
+import org.apache.lucene.index.values.Type;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.IntsRef;
 
@@ -65,7 +65,7 @@ protected void load(FieldInfos fieldInfos, String segment, int docCount,
   }
 
   protected DocValues loadDocValues(int docCount, Directory dir, String id,
-      Values v) throws IOException {
+      Type v) throws IOException {
     switch (v) {
     case PACKED_INTS:
       return Ints.getValues(dir, id, false);
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Bytes.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Bytes.java
index 0b51c7e2..92b9eedc 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Bytes.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Bytes.java
@@ -162,7 +162,7 @@ public long ramBytesUsed() {
     }
 
     @Override
-    public ValuesEnum getEnum(AttributeSource attrSource) throws IOException {
+    public DocValuesEnum getEnum(AttributeSource attrSource) throws IOException {
       final MissingValue missing = getMissing();
       return new SourceEnum(attrSource, type(), this, maxDoc()) {
         @Override
@@ -246,7 +246,7 @@ protected LookupResult binarySearch(BytesRef b, BytesRef bytesRef, int low,
     }
 
     @Override
-    public ValuesEnum getEnum(AttributeSource attrSource) throws IOException {
+    public DocValuesEnum getEnum(AttributeSource attrSource) throws IOException {
       final MissingValue missing = getMissing();
       return new SourceEnum(attrSource, type(), this, maxDoc()) {
 
@@ -340,7 +340,7 @@ public void add(int docID, PerDocFieldValues docValues) throws IOException {
     }
     
     @Override
-    protected void setNextEnum(ValuesEnum valuesEnum) {
+    protected void setNextEnum(DocValuesEnum valuesEnum) {
       bytesRef = valuesEnum.bytes();
     }
 
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/DocValues.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/DocValues.java
index 39d21ac4..4de684ce 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/DocValues.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/DocValues.java
@@ -31,11 +31,11 @@
   public static final DocValues[] EMPTY_ARRAY = new DocValues[0];
   private SourceCache cache = new SourceCache.DirectSourceCache();
 
-  public ValuesEnum getEnum() throws IOException {
+  public DocValuesEnum getEnum() throws IOException {
     return getEnum(null);
   }
 
-  public abstract ValuesEnum getEnum(AttributeSource attrSource)
+  public abstract DocValuesEnum getEnum(AttributeSource attrSource)
       throws IOException;
 
   public abstract Source load() throws IOException;
@@ -54,7 +54,7 @@ public SortedSource loadSorted(Comparator<BytesRef> comparator)
     throw new UnsupportedOperationException();
   }
 
-  public abstract Values type();
+  public abstract Type type();
 
   public void close() throws IOException {
     this.cache.close(this);
@@ -95,7 +95,7 @@ public int getValueCount() {
       throw new UnsupportedOperationException();
     }
 
-    public ValuesEnum getEnum() throws IOException {
+    public DocValuesEnum getEnum() throws IOException {
       return getEnum(null);
     }
     
@@ -103,19 +103,19 @@ public MissingValue getMissing() {
       return missingValue;
     }
     
-    public abstract Values type();
+    public abstract Type type();
 
-    public abstract ValuesEnum getEnum(AttributeSource attrSource)
+    public abstract DocValuesEnum getEnum(AttributeSource attrSource)
         throws IOException;
 
   }
 
-  abstract static class SourceEnum extends ValuesEnum {
+  abstract static class SourceEnum extends DocValuesEnum {
     protected final Source source;
     protected final int numDocs;
     protected int pos = -1;
 
-    SourceEnum(AttributeSource attrs, Values type, Source source, int numDocs) {
+    SourceEnum(AttributeSource attrs, Type type, Source source, int numDocs) {
       super(attrs, type);
       this.source = source;
       this.numDocs = numDocs;
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/DocValuesEnum.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/DocValuesEnum.java
index e69de29b..ecdeec8c 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/DocValuesEnum.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/DocValuesEnum.java
@@ -0,0 +1,130 @@
+package org.apache.lucene.index.values;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+import java.io.IOException;
+
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.util.Attribute;
+import org.apache.lucene.util.AttributeSource;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.FloatsRef;
+import org.apache.lucene.util.LongsRef;
+/**
+ * 
+ * @lucene.experimental
+ */
+public abstract class DocValuesEnum extends DocIdSetIterator {
+  private AttributeSource source;
+  private Type enumType;
+  protected BytesRef bytesRef;
+  protected FloatsRef floatsRef;
+  protected LongsRef intsRef;
+
+  protected DocValuesEnum(Type enumType) {
+    this(null, enumType);
+  }
+
+  protected DocValuesEnum(AttributeSource source, Type enumType) {
+    this.source = source;
+    this.enumType = enumType;
+    switch (enumType) {
+    case BYTES_FIXED_DEREF:
+    case BYTES_FIXED_SORTED:
+    case BYTES_FIXED_STRAIGHT:
+    case BYTES_VAR_DEREF:
+    case BYTES_VAR_SORTED:
+    case BYTES_VAR_STRAIGHT:
+      bytesRef = new BytesRef();
+      break;
+    case PACKED_INTS:
+      intsRef = new LongsRef(1);
+      break;
+    case SIMPLE_FLOAT_4BYTE:
+    case SIMPLE_FLOAT_8BYTE:
+      floatsRef = new FloatsRef(1);
+      break;  
+    }
+  }
+
+  public Type type() {
+    return enumType;
+  }
+
+  public BytesRef bytes() {
+    return bytesRef;
+  }
+
+  public FloatsRef getFloat() {
+    return floatsRef;
+  }
+
+  public LongsRef getInt() {
+    return intsRef;
+  }
+  
+  protected void copyReferences(DocValuesEnum valuesEnum) {
+    intsRef = valuesEnum.intsRef;
+    floatsRef = valuesEnum.floatsRef;
+    bytesRef = valuesEnum.bytesRef;
+  }
+
+  public AttributeSource attributes() {
+    if (source == null)
+      source = new AttributeSource();
+    return source;
+  }
+
+  public <T extends Attribute> T addAttribute(Class<T> attr) {
+    return attributes().addAttribute(attr);
+  }
+
+  public <T extends Attribute> T getAttribute(Class<T> attr) {
+    return attributes().getAttribute(attr);
+  }
+
+  public <T extends Attribute> boolean hasAttribute(Class<T> attr) {
+    return attributes().hasAttribute(attr);
+  }
+
+  public abstract void close() throws IOException;
+
+  public static DocValuesEnum emptyEnum(Type type) {
+    return new DocValuesEnum(type) {
+      @Override
+      public int nextDoc() throws IOException {
+        return NO_MORE_DOCS;
+      }
+      
+      @Override
+      public int docID() {
+        return NO_MORE_DOCS;
+      }
+      
+      @Override
+      public int advance(int target) throws IOException {
+        return NO_MORE_DOCS;
+      }
+      
+      @Override
+      public void close() throws IOException {
+        
+      }
+    };
+  }
+
+}
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/FixedDerefBytesImpl.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/FixedDerefBytesImpl.java
index c987ca37..e662de58 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/FixedDerefBytesImpl.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/FixedDerefBytesImpl.java
@@ -172,8 +172,8 @@ public int getValueCount() {
       }
 
       @Override
-      public Values type() {
-        return Values.BYTES_FIXED_DEREF;
+      public Type type() {
+        return Type.BYTES_FIXED_DEREF;
       }
 
       @Override
@@ -183,12 +183,12 @@ protected int maxDoc() {
     }
 
     @Override
-    public ValuesEnum getEnum(AttributeSource source) throws IOException {
+    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
       return new DerefBytesEnum(source, cloneData(), cloneIndex(),
           size);
     }
 
-    static class DerefBytesEnum extends ValuesEnum {
+    static class DerefBytesEnum extends DocValuesEnum {
       protected final IndexInput datIn;
       private final PackedInts.ReaderIterator idx;
       protected final long fp;
@@ -198,11 +198,11 @@ public ValuesEnum getEnum(AttributeSource source) throws IOException {
 
       public DerefBytesEnum(AttributeSource source, IndexInput datIn,
           IndexInput idxIn, int size) throws IOException {
-        this(source, datIn, idxIn, size, Values.BYTES_FIXED_DEREF);
+        this(source, datIn, idxIn, size, Type.BYTES_FIXED_DEREF);
       }
 
       protected DerefBytesEnum(AttributeSource source, IndexInput datIn,
-          IndexInput idxIn, int size, Values enumType)
+          IndexInput idxIn, int size, Type enumType)
           throws IOException {
         super(source, enumType);
         this.datIn = datIn;
@@ -217,7 +217,7 @@ protected DerefBytesEnum(AttributeSource source, IndexInput datIn,
       }
       
 
-      protected void copyReferences(ValuesEnum valuesEnum) {
+      protected void copyReferences(DocValuesEnum valuesEnum) {
         bytesRef = valuesEnum.bytesRef;
         if(bytesRef.bytes.length < size) {
           bytesRef.grow(size);
@@ -270,8 +270,8 @@ public int docID() {
     }
 
     @Override
-    public Values type() {
-      return Values.BYTES_FIXED_DEREF;
+    public Type type() {
+      return Type.BYTES_FIXED_DEREF;
     }
   }
 
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/FixedSortedBytesImpl.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/FixedSortedBytesImpl.java
index adf1c216..583d93b3 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/FixedSortedBytesImpl.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/FixedSortedBytesImpl.java
@@ -215,8 +215,8 @@ protected BytesRef deref(int ord, BytesRef bytesRef) {
       }
 
       @Override
-      public Values type() {
-        return Values.BYTES_FIXED_SORTED;
+      public Type type() {
+        return Type.BYTES_FIXED_SORTED;
       }
 
       @Override
@@ -226,15 +226,15 @@ protected int maxDoc() {
     }
 
     @Override
-    public ValuesEnum getEnum(AttributeSource source) throws IOException {
+    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
       // do unsorted
       return new DerefBytesEnum(source, cloneData(), cloneIndex(),
           size);
     }
 
     @Override
-    public Values type() {
-      return Values.BYTES_FIXED_SORTED;
+    public Type type() {
+      return Type.BYTES_FIXED_SORTED;
     }
   }
 }
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/FixedStraightBytesImpl.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/FixedStraightBytesImpl.java
index 9f804730..77d51a6f 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/FixedStraightBytesImpl.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/FixedStraightBytesImpl.java
@@ -156,8 +156,8 @@ public int getValueCount() {
       }
 
       @Override
-      public Values type() {
-        return Values.BYTES_FIXED_STRAIGHT;
+      public Type type() {
+        return Type.BYTES_FIXED_STRAIGHT;
       }
 
       @Override
@@ -167,11 +167,11 @@ protected int maxDoc() {
     }
 
     @Override
-    public ValuesEnum getEnum(AttributeSource source) throws IOException {
+    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
       return new FixedStraightBytesEnum(source, cloneData(), size, maxDoc);
     }
     
-    private static final class FixedStraightBytesEnum extends ValuesEnum {
+    private static final class FixedStraightBytesEnum extends DocValuesEnum {
       private final IndexInput datIn;
       private final int size;
       private final int maxDoc;
@@ -179,7 +179,7 @@ public ValuesEnum getEnum(AttributeSource source) throws IOException {
       private final long fp;
 
       public FixedStraightBytesEnum(AttributeSource source, IndexInput datIn, int size, int maxDoc) throws IOException{
-        super(source, Values.BYTES_FIXED_STRAIGHT);
+        super(source, Type.BYTES_FIXED_STRAIGHT);
         this.datIn = datIn;
         this.size = size;
         this.maxDoc = maxDoc;
@@ -189,7 +189,7 @@ public FixedStraightBytesEnum(AttributeSource source, IndexInput datIn, int size
         fp = datIn.getFilePointer();
       }
       
-      protected void copyReferences(ValuesEnum valuesEnum) {
+      protected void copyReferences(DocValuesEnum valuesEnum) {
         bytesRef = valuesEnum.bytesRef;
         if(bytesRef.bytes.length < size) {
           bytesRef.grow(size);
@@ -228,8 +228,8 @@ public int nextDoc() throws IOException {
     }
     
     @Override
-    public Values type() {
-      return Values.BYTES_FIXED_STRAIGHT;
+    public Type type() {
+      return Type.BYTES_FIXED_STRAIGHT;
     }
   }
 }
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Floats.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Floats.java
index 79beefdd..464311cc 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Floats.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Floats.java
@@ -102,7 +102,7 @@ public void add(int docID, PerDocFieldValues docValues) throws IOException {
     }
 
     @Override
-    protected void setNextEnum(ValuesEnum valuesEnum) {
+    protected void setNextEnum(DocValuesEnum valuesEnum) {
       floatsRef = valuesEnum.getFloat();
     }
 
@@ -288,9 +288,9 @@ public double getFloat(int docID) {
       }
 
       @Override
-      public ValuesEnum getEnum(AttributeSource attrSource) throws IOException {
+      public DocValuesEnum getEnum(AttributeSource attrSource) throws IOException {
         final MissingValue missing = getMissing();
-        return new SourceEnum(attrSource, Values.SIMPLE_FLOAT_4BYTE, this, maxDoc) {
+        return new SourceEnum(attrSource, Type.SIMPLE_FLOAT_4BYTE, this, maxDoc) {
           @Override
           public int advance(int target) throws IOException {
             if (target >= numDocs)
@@ -307,8 +307,8 @@ public int advance(int target) throws IOException {
       }
 
       @Override
-      public Values type() {
-        return Values.SIMPLE_FLOAT_4BYTE;
+      public Type type() {
+        return Type.SIMPLE_FLOAT_4BYTE;
       }
     }
 
@@ -327,7 +327,7 @@ public double getFloat(int docID) {
       }
 
       @Override
-      public ValuesEnum getEnum(AttributeSource attrSource) throws IOException {
+      public DocValuesEnum getEnum(AttributeSource attrSource) throws IOException {
         final MissingValue missing = getMissing();
         return new SourceEnum(attrSource, type(), this, maxDoc) {
           @Override
@@ -346,8 +346,8 @@ public int advance(int target) throws IOException {
       }
 
       @Override
-      public Values type() {
-        return Values.SIMPLE_FLOAT_8BYTE;
+      public Type type() {
+        return Type.SIMPLE_FLOAT_8BYTE;
       }
     }
 
@@ -358,7 +358,7 @@ public void close() throws IOException {
     }
 
     @Override
-    public ValuesEnum getEnum(AttributeSource source) throws IOException {
+    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
       IndexInput indexInput = (IndexInput) datIn.clone();
       indexInput.seek(CodecUtil.headerLength(CODEC_NAME));
       // skip precision:
@@ -368,9 +368,9 @@ public ValuesEnum getEnum(AttributeSource source) throws IOException {
     }
 
     @Override
-    public Values type() {
-      return precisionBytes == 4 ? Values.SIMPLE_FLOAT_4BYTE
-          : Values.SIMPLE_FLOAT_8BYTE;
+    public Type type() {
+      return precisionBytes == 4 ? Type.SIMPLE_FLOAT_4BYTE
+          : Type.SIMPLE_FLOAT_8BYTE;
     }
   }
 
@@ -378,7 +378,7 @@ public Values type() {
 
     Floats4Enum(AttributeSource source, IndexInput dataIn, int maxDoc)
         throws IOException {
-      super(source, dataIn, 4, maxDoc, Values.SIMPLE_FLOAT_4BYTE);
+      super(source, dataIn, 4, maxDoc, Type.SIMPLE_FLOAT_4BYTE);
     }
 
     @Override
@@ -414,7 +414,7 @@ public int nextDoc() throws IOException {
 
     Floats8EnumImpl(AttributeSource source, IndexInput dataIn, int maxDoc)
         throws IOException {
-      super(source, dataIn, 8, maxDoc, Values.SIMPLE_FLOAT_8BYTE);
+      super(source, dataIn, 8, maxDoc, Type.SIMPLE_FLOAT_8BYTE);
     }
 
     @Override
@@ -447,7 +447,7 @@ public int nextDoc() throws IOException {
     }
   }
 
-  static abstract class FloatsEnumImpl extends ValuesEnum {
+  static abstract class FloatsEnumImpl extends DocValuesEnum {
     protected final IndexInput dataIn;
     protected int pos = -1;
     protected final int precision;
@@ -455,9 +455,9 @@ public int nextDoc() throws IOException {
     protected final long fp;
 
     FloatsEnumImpl(AttributeSource source, IndexInput dataIn, int precision,
-        int maxDoc, Values type) throws IOException {
-      super(source, precision == 4 ? Values.SIMPLE_FLOAT_4BYTE
-          : Values.SIMPLE_FLOAT_8BYTE);
+        int maxDoc, Type type) throws IOException {
+      super(source, precision == 4 ? Type.SIMPLE_FLOAT_4BYTE
+          : Type.SIMPLE_FLOAT_8BYTE);
       this.dataIn = dataIn;
       this.precision = precision;
       this.maxDoc = maxDoc;
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/MultiDocValues.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/MultiDocValues.java
index dfd7478a..f0b6e7db 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/MultiDocValues.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/MultiDocValues.java
@@ -54,7 +54,7 @@ public MultiDocValues(DocValuesIndex[] docValuesIdx) {
   }
 
   @Override
-  public ValuesEnum getEnum(AttributeSource source) throws IOException {
+  public DocValuesEnum getEnum(AttributeSource source) throws IOException {
     return new MultiValuesEnum(docValuesIdx, starts);
   }
 
@@ -81,13 +81,13 @@ public DocValues reset(DocValuesIndex[] docValuesIdx) {
     final int maxDoc;
     final Source emptySoruce;
 
-    public DummyDocValues(int maxDoc, Values type) {
+    public DummyDocValues(int maxDoc, Type type) {
       this.maxDoc = maxDoc;
       this.emptySoruce = new EmptySource(type);
     }
 
     @Override
-    public ValuesEnum getEnum(AttributeSource attrSource) throws IOException {
+    public DocValuesEnum getEnum(AttributeSource attrSource) throws IOException {
       return emptySoruce.getEnum(attrSource);
     }
 
@@ -97,7 +97,7 @@ public Source load() throws IOException {
     }
 
     @Override
-    public Values type() {
+    public Type type() {
       return emptySoruce.type();
     }
 
@@ -107,13 +107,13 @@ public void close() throws IOException {
 
   }
 
-  private static class MultiValuesEnum extends ValuesEnum {
+  private static class MultiValuesEnum extends DocValuesEnum {
     private DocValuesIndex[] docValuesIdx;
     private final int maxDoc;
     private int currentStart;
     private int currentMax;
     private int currentDoc = -1;
-    private ValuesEnum currentEnum;
+    private DocValuesEnum currentEnum;
     private final int[] starts;
 
     public MultiValuesEnum(DocValuesIndex[] docValuesIdx, int[] starts)
@@ -222,21 +222,21 @@ public BytesRef getBytes(int docID, BytesRef bytesRef) {
     }
 
     @Override
-    public ValuesEnum getEnum(AttributeSource attrSource) throws IOException {
+    public DocValuesEnum getEnum(AttributeSource attrSource) throws IOException {
       throw new UnsupportedOperationException(); // TODO
     }
 
     @Override
-    public Values type() {
+    public Type type() {
       return docValuesIdx[0].docValues.type();
     }
 
   }
 
   private static class EmptySource extends Source {
-    private final Values type;
+    private final Type type;
 
-    public EmptySource(Values type) {
+    public EmptySource(Type type) {
       this.type = type;
     }
 
@@ -257,18 +257,18 @@ public long getInt(int docID) {
     }
 
     @Override
-    public ValuesEnum getEnum(AttributeSource attrSource) throws IOException {
-      return ValuesEnum.emptyEnum(type);
+    public DocValuesEnum getEnum(AttributeSource attrSource) throws IOException {
+      return DocValuesEnum.emptyEnum(type);
     }
 
     @Override
-    public Values type() {
+    public Type type() {
       return type;
     }
   }
 
   @Override
-  public Values type() {
+  public Type type() {
     return this.docValuesIdx[0].docValues.type();
   }
 }
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/PackedIntsImpl.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/PackedIntsImpl.java
index 4d2c62e5..b9a76f76 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/PackedIntsImpl.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/PackedIntsImpl.java
@@ -133,7 +133,7 @@ protected void add(int docID) throws IOException {
     }
 
     @Override
-    protected void setNextEnum(ValuesEnum valuesEnum) {
+    protected void setNextEnum(DocValuesEnum valuesEnum) {
       intsRef = valuesEnum.getInt();
     }
 
@@ -192,7 +192,7 @@ public long getInt(int docID) {
       }
 
       @Override
-      public ValuesEnum getEnum(AttributeSource attrSource) throws IOException {
+      public DocValuesEnum getEnum(AttributeSource attrSource) throws IOException {
         final MissingValue missing = getMissing();
         return new SourceEnum(attrSource, type(), this, values.size()) {
           @Override
@@ -211,8 +211,8 @@ public int advance(int target) throws IOException {
       }
 
       @Override
-      public Values type() {
-        return Values.PACKED_INTS;
+      public Type type() {
+        return Type.PACKED_INTS;
       }
     }
 
@@ -223,18 +223,18 @@ public void close() throws IOException {
     }
 
     @Override
-    public ValuesEnum getEnum(AttributeSource source) throws IOException {
+    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
       return new IntsEnumImpl(source, (IndexInput) datIn.clone());
     }
 
     @Override
-    public Values type() {
-      return Values.PACKED_INTS;
+    public Type type() {
+      return Type.PACKED_INTS;
     }
 
   }
 
-  private static final class IntsEnumImpl extends ValuesEnum {
+  private static final class IntsEnumImpl extends DocValuesEnum {
     private final PackedInts.ReaderIterator ints;
     private long minValue;
     private final IndexInput dataIn;
@@ -244,7 +244,7 @@ public Values type() {
 
     private IntsEnumImpl(AttributeSource source, IndexInput dataIn)
         throws IOException {
-      super(source, Values.PACKED_INTS);
+      super(source, Type.PACKED_INTS);
       intsRef.offset = 0;
       this.dataIn = dataIn;
       dataIn.seek(CodecUtil.headerLength(CODEC_NAME));
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/PerDocFieldValues.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/PerDocFieldValues.java
index 3e4d500a..bf70d5d8 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/PerDocFieldValues.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/PerDocFieldValues.java
@@ -32,9 +32,9 @@
 
   public void setFloat(double value);
 
-  public void setBytes(BytesRef value, Values type);
+  public void setBytes(BytesRef value, Type type);
 
-  public void setBytes(BytesRef value, Values type, Comparator<BytesRef> comp);
+  public void setBytes(BytesRef value, Type type, Comparator<BytesRef> comp);
 
   public BytesRef getBytes();
 
@@ -46,8 +46,8 @@
 
   public void setBytesComparator(Comparator<BytesRef> comp);
 
-  public void setType(Values type);
+  public void setType(Type type);
 
-  public Values type();
+  public Type type();
 
 }
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/SourceCache.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/SourceCache.java
index ef916c97..9bd81245 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/SourceCache.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/SourceCache.java
@@ -28,6 +28,7 @@
 
 /**
  * Per {@link DocValues} {@link Source} cache.
+ * @lucene.experimental
  */
 public abstract class SourceCache {
   public abstract Source load(DocValues values) throws IOException;
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Type.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Type.java
index e69de29b..717741ab 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Type.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Type.java
@@ -0,0 +1,47 @@
+package org.apache.lucene.index.values;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** Controls whether per-field values are stored into
+ *  index.  This storage is non-sparse, so it's best to
+ *  use this when all docs have the field, and loads all
+ *  values into RAM, exposing a random access API, when
+ *  loaded.
+ *
+ * @lucene.experimental 
+ */
+public enum Type {
+
+  /** Integral value is stored as packed ints.  The bit
+   *  precision is fixed across the segment, and
+   *  determined by the min/max values in the field. */
+  PACKED_INTS,
+  SIMPLE_FLOAT_4BYTE,
+  SIMPLE_FLOAT_8BYTE,
+
+  // TODO(simonw): -- shouldn't lucene decide/detect straight vs
+  // deref, as well fixed vs var?
+  BYTES_FIXED_STRAIGHT,
+  BYTES_FIXED_DEREF,
+  BYTES_FIXED_SORTED,
+
+  BYTES_VAR_STRAIGHT,
+  BYTES_VAR_DEREF,
+  BYTES_VAR_SORTED
+
+  // TODO(simonw): -- need STRING variants as well
+}
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Values.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Values.java
index 31adfd2a..e69de29b 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Values.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Values.java
@@ -1,47 +0,0 @@
-package org.apache.lucene.index.values;
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/** Controls whether per-field values are stored into
- *  index.  This storage is non-sparse, so it's best to
- *  use this when all docs have the field, and loads all
- *  values into RAM, exposing a random access API, when
- *  loaded.
- *
- * @lucene.experimental 
- */
-public enum Values {
-
-  /** Integral value is stored as packed ints.  The bit
-   *  precision is fixed across the segment, and
-   *  determined by the min/max values in the field. */
-  PACKED_INTS,
-  SIMPLE_FLOAT_4BYTE,
-  SIMPLE_FLOAT_8BYTE,
-
-  // TODO(simonw): -- shouldn't lucene decide/detect straight vs
-  // deref, as well fixed vs var?
-  BYTES_FIXED_STRAIGHT,
-  BYTES_FIXED_DEREF,
-  BYTES_FIXED_SORTED,
-
-  BYTES_VAR_STRAIGHT,
-  BYTES_VAR_DEREF,
-  BYTES_VAR_SORTED
-
-  // TODO(simonw): -- need STRING variants as well
-}
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/ValuesEnum.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/ValuesEnum.java
index 8008929d..e69de29b 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/ValuesEnum.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/ValuesEnum.java
@@ -1,130 +0,0 @@
-package org.apache.lucene.index.values;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-import java.io.IOException;
-
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.util.Attribute;
-import org.apache.lucene.util.AttributeSource;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.FloatsRef;
-import org.apache.lucene.util.LongsRef;
-/**
- * 
- * @lucene.experimental
- */
-public abstract class ValuesEnum extends DocIdSetIterator {
-  private AttributeSource source;
-  private Values enumType;
-  protected BytesRef bytesRef;
-  protected FloatsRef floatsRef;
-  protected LongsRef intsRef;
-
-  protected ValuesEnum(Values enumType) {
-    this(null, enumType);
-  }
-
-  protected ValuesEnum(AttributeSource source, Values enumType) {
-    this.source = source;
-    this.enumType = enumType;
-    switch (enumType) {
-    case BYTES_FIXED_DEREF:
-    case BYTES_FIXED_SORTED:
-    case BYTES_FIXED_STRAIGHT:
-    case BYTES_VAR_DEREF:
-    case BYTES_VAR_SORTED:
-    case BYTES_VAR_STRAIGHT:
-      bytesRef = new BytesRef();
-      break;
-    case PACKED_INTS:
-      intsRef = new LongsRef(1);
-      break;
-    case SIMPLE_FLOAT_4BYTE:
-    case SIMPLE_FLOAT_8BYTE:
-      floatsRef = new FloatsRef(1);
-      break;  
-    }
-  }
-
-  public Values type() {
-    return enumType;
-  }
-
-  public BytesRef bytes() {
-    return bytesRef;
-  }
-
-  public FloatsRef getFloat() {
-    return floatsRef;
-  }
-
-  public LongsRef getInt() {
-    return intsRef;
-  }
-  
-  protected void copyReferences(ValuesEnum valuesEnum) {
-    intsRef = valuesEnum.intsRef;
-    floatsRef = valuesEnum.floatsRef;
-    bytesRef = valuesEnum.bytesRef;
-  }
-
-  public AttributeSource attributes() {
-    if (source == null)
-      source = new AttributeSource();
-    return source;
-  }
-
-  public <T extends Attribute> T addAttribute(Class<T> attr) {
-    return attributes().addAttribute(attr);
-  }
-
-  public <T extends Attribute> T getAttribute(Class<T> attr) {
-    return attributes().getAttribute(attr);
-  }
-
-  public <T extends Attribute> boolean hasAttribute(Class<T> attr) {
-    return attributes().hasAttribute(attr);
-  }
-
-  public abstract void close() throws IOException;
-
-  public static ValuesEnum emptyEnum(Values type) {
-    return new ValuesEnum(type) {
-      @Override
-      public int nextDoc() throws IOException {
-        return NO_MORE_DOCS;
-      }
-      
-      @Override
-      public int docID() {
-        return NO_MORE_DOCS;
-      }
-      
-      @Override
-      public int advance(int target) throws IOException {
-        return NO_MORE_DOCS;
-      }
-      
-      @Override
-      public void close() throws IOException {
-        
-      }
-    };
-  }
-
-}
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/VarDerefBytesImpl.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/VarDerefBytesImpl.java
index 985b960c..c28e7e57 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/VarDerefBytesImpl.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/VarDerefBytesImpl.java
@@ -231,8 +231,8 @@ public int getValueCount() {
       }
 
       @Override
-      public Values type() {
-        return Values.BYTES_VAR_DEREF;
+      public Type type() {
+        return Type.BYTES_VAR_DEREF;
       }
 
       @Override
@@ -242,7 +242,7 @@ protected int maxDoc() {
     }
 
     @Override
-    public ValuesEnum getEnum(AttributeSource source) throws IOException {
+    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
       return new VarDerefBytesEnum(source, cloneData(), cloneIndex());
     }
 
@@ -250,7 +250,7 @@ public ValuesEnum getEnum(AttributeSource source) throws IOException {
 
       public VarDerefBytesEnum(AttributeSource source, IndexInput datIn,
           IndexInput idxIn) throws IOException {
-        super(source, datIn, idxIn, -1, Values.BYTES_VAR_DEREF);
+        super(source, datIn, idxIn, -1, Type.BYTES_VAR_DEREF);
       }
 
       @Override
@@ -273,8 +273,8 @@ protected void fill(long address, BytesRef ref) throws IOException {
     }
 
     @Override
-    public Values type() {
-      return Values.BYTES_VAR_DEREF;
+    public Type type() {
+      return Type.BYTES_VAR_DEREF;
     }
   }
 }
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/VarSortedBytesImpl.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/VarSortedBytesImpl.java
index 53dddf31..ab023a1f 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/VarSortedBytesImpl.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/VarSortedBytesImpl.java
@@ -220,8 +220,8 @@ protected BytesRef deref(int ord, BytesRef bytesRef) {
       }
 
       @Override
-      public Values type() {
-        return Values.BYTES_VAR_SORTED;
+      public Type type() {
+        return Type.BYTES_VAR_SORTED;
       }
 
       @Override
@@ -231,11 +231,11 @@ protected int maxDoc() {
     }
 
     @Override
-    public ValuesEnum getEnum(AttributeSource source) throws IOException {
+    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
       return new VarSortedBytesEnum(source, cloneData(), cloneIndex());
     }
 
-    private static class VarSortedBytesEnum extends ValuesEnum {
+    private static class VarSortedBytesEnum extends DocValuesEnum {
       private PackedInts.Reader docToOrdIndex;
       private PackedInts.Reader ordToOffsetIndex;
       private IndexInput idxIn;
@@ -248,7 +248,7 @@ public ValuesEnum getEnum(AttributeSource source) throws IOException {
 
       protected VarSortedBytesEnum(AttributeSource source, IndexInput datIn,
           IndexInput idxIn) throws IOException {
-        super(source, Values.BYTES_VAR_SORTED);
+        super(source, Type.BYTES_VAR_SORTED);
         totBytes = idxIn.readLong();
         // keep that in memory to prevent lots of disk seeks
         docToOrdIndex = PackedInts.getReader(idxIn);
@@ -309,8 +309,8 @@ public int nextDoc() throws IOException {
     }
     
     @Override
-    public Values type() {
-      return Values.BYTES_VAR_SORTED;
+    public Type type() {
+      return Type.BYTES_VAR_SORTED;
     }
   }
 }
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/VarStraightBytesImpl.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/VarStraightBytesImpl.java
index c259fe2c..18f0272a 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/VarStraightBytesImpl.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/VarStraightBytesImpl.java
@@ -147,8 +147,8 @@ public int getValueCount() {
       }
 
       @Override
-      public Values type() {
-        return Values.BYTES_VAR_STRAIGHT;
+      public Type type() {
+        return Type.BYTES_VAR_STRAIGHT;
       }
 
       @Override
@@ -158,11 +158,11 @@ protected int maxDoc() {
     }
 
     @Override
-    public ValuesEnum getEnum(AttributeSource source) throws IOException {
+    public DocValuesEnum getEnum(AttributeSource source) throws IOException {
       return new VarStraightBytesEnum(source, cloneData(), cloneIndex());
     }
 
-    private class VarStraightBytesEnum extends ValuesEnum {
+    private class VarStraightBytesEnum extends DocValuesEnum {
       private final PackedInts.Reader addresses;
       private final IndexInput datIn;
       private final IndexInput idxIn;
@@ -172,7 +172,7 @@ public ValuesEnum getEnum(AttributeSource source) throws IOException {
 
       protected VarStraightBytesEnum(AttributeSource source, IndexInput datIn,
           IndexInput idxIn) throws IOException {
-        super(source, Values.BYTES_VAR_STRAIGHT);
+        super(source, Type.BYTES_VAR_STRAIGHT);
         totBytes = idxIn.readVInt();
         fp = datIn.getFilePointer();
         addresses = PackedInts.getReader(idxIn);
@@ -220,8 +220,8 @@ public int nextDoc() throws IOException {
     }
 
     @Override
-    public Values type() {
-      return Values.BYTES_VAR_STRAIGHT;
+    public Type type() {
+      return Type.BYTES_VAR_STRAIGHT;
     }
   }
 }
diff --git a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Writer.java b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Writer.java
index 8d75c7d6..e92d1802 100644
--- a/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Writer.java
+++ b/lucene/dev/branches/docvalues/lucene/src/java/org/apache/lucene/index/values/Writer.java
@@ -57,7 +57,7 @@ public void add(int docID, BytesRef value) throws IOException {
   /** Records the specfied value for the docID */
   protected abstract void add(int docID) throws IOException;
   
-  protected abstract void setNextEnum(ValuesEnum valuesEnum);
+  protected abstract void setNextEnum(DocValuesEnum valuesEnum);
 
   /** Finish writing, close any files */
   public abstract void finish(int docCount) throws IOException;
@@ -65,7 +65,7 @@ public void add(int docID, BytesRef value) throws IOException {
   // enables bulk copies in subclasses per MergeState
   @Override
   protected void merge(MergeState state) throws IOException {
-    final ValuesEnum valEnum = state.reader.getEnum();
+    final DocValuesEnum valEnum = state.reader.getEnum();
     assert valEnum != null;
     try {
       setNextEnum(valEnum);
@@ -73,11 +73,11 @@ protected void merge(MergeState state) throws IOException {
       final Bits bits = state.bits;
       final int docCount = state.docCount;
       int currentDocId;
-      if ((currentDocId = valEnum.advance(0)) != ValuesEnum.NO_MORE_DOCS) {
+      if ((currentDocId = valEnum.advance(0)) != DocValuesEnum.NO_MORE_DOCS) {
         for (int i = 0; i < docCount; i++) {
           if (bits == null || !bits.get(i)) {
             if (currentDocId < i) {
-              if ((currentDocId = valEnum.advance(i)) == ValuesEnum.NO_MORE_DOCS) {
+              if ((currentDocId = valEnum.advance(i)) == DocValuesEnum.NO_MORE_DOCS) {
                 break; // advance can jump over default values
               }
             }
@@ -93,7 +93,7 @@ protected void merge(MergeState state) throws IOException {
     }
   }
 
-  public static Writer create(Values v, String id, Directory directory,
+  public static Writer create(Type v, String id, Directory directory,
       Comparator<BytesRef> comp, AtomicLong bytesUsed) throws IOException {
     switch (v) {
     case PACKED_INTS:
diff --git a/lucene/dev/branches/docvalues/lucene/src/test/org/apache/lucene/index/values/TestDocValues.java b/lucene/dev/branches/docvalues/lucene/src/test/org/apache/lucene/index/values/TestDocValues.java
index 94b247e3..694ed68d 100644
--- a/lucene/dev/branches/docvalues/lucene/src/test/org/apache/lucene/index/values/TestDocValues.java
+++ b/lucene/dev/branches/docvalues/lucene/src/test/org/apache/lucene/index/values/TestDocValues.java
@@ -89,7 +89,7 @@ public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)
 
     DocValues r = Bytes.getValues(dir, "test", mode, fixedSize, maxDoc);
     for (int iter = 0; iter < 2; iter++) {
-      ValuesEnum bytesEnum = r.getEnum();
+      DocValuesEnum bytesEnum = r.getEnum();
       assertNotNull("enum is null", bytesEnum);
       BytesRef ref = bytesEnum.bytes();
 
@@ -100,8 +100,8 @@ public void runTestBytes(final Bytes.Mode mode, final boolean fixedSize)
         assertEquals("doc: " + idx + " lenLeft: " + values[idx].length()
             + " lenRight: " + utf8String.length(), values[idx], utf8String);
       }
-      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));
-      assertEquals(ValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));
+      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc));
+      assertEquals(DocValuesEnum.NO_MORE_DOCS, bytesEnum.advance(maxDoc + 1));
 
       bytesEnum.close();
     }
@@ -207,7 +207,7 @@ public void testInts() throws IOException {
       }
 
       for (int iter = 0; iter < 2; iter++) {
-        ValuesEnum iEnum = r.getEnum();
+        DocValuesEnum iEnum = r.getEnum();
         LongsRef ints = iEnum.getInt();
         for (int i = 0; i < NUM_VALUES; i++) {
           assertEquals(i, iEnum.nextDoc());
@@ -217,14 +217,14 @@ public void testInts() throws IOException {
           assertEquals(NUM_VALUES - 1, iEnum.advance(NUM_VALUES - 1));
         }
         for (int i = NUM_VALUES; i < NUM_VALUES + additionalDocs; i++) {
-          assertEquals(ValuesEnum.NO_MORE_DOCS, iEnum.nextDoc());
+          assertEquals(DocValuesEnum.NO_MORE_DOCS, iEnum.nextDoc());
         }
 
         iEnum.close();
       }
 
       for (int iter = 0; iter < 2; iter++) {
-        ValuesEnum iEnum = r.getEnum();
+        DocValuesEnum iEnum = r.getEnum();
         LongsRef ints = iEnum.getInt();
         for (int i = 0; i < NUM_VALUES; i += 1 + random.nextInt(25)) {
           assertEquals(i, iEnum.advance(i));
@@ -234,7 +234,7 @@ public void testInts() throws IOException {
           assertEquals(NUM_VALUES - 1, iEnum.advance(NUM_VALUES - 1));
         }
         for (int i = NUM_VALUES; i < NUM_VALUES + additionalDocs; i++) {
-          assertEquals(ValuesEnum.NO_MORE_DOCS, iEnum.nextDoc());
+          assertEquals(DocValuesEnum.NO_MORE_DOCS, iEnum.nextDoc());
         }
 
         iEnum.close();
@@ -273,26 +273,26 @@ private void runTestFloats(int precision, double delta) throws IOException {
     }
 
     for (int iter = 0; iter < 2; iter++) {
-      ValuesEnum fEnum = r.getEnum();
+      DocValuesEnum fEnum = r.getEnum();
       FloatsRef floats = fEnum.getFloat();
       for (int i = 0; i < NUM_VALUES; i++) {
         assertEquals(i, fEnum.nextDoc());
         assertEquals(values[i], floats.get(), delta);
       }
       for (int i = NUM_VALUES; i < NUM_VALUES + additionalValues; i++) {
-        assertEquals(ValuesEnum.NO_MORE_DOCS, fEnum.nextDoc());
+        assertEquals(DocValuesEnum.NO_MORE_DOCS, fEnum.nextDoc());
       }
       fEnum.close();
     }
     for (int iter = 0; iter < 2; iter++) {
-      ValuesEnum fEnum = r.getEnum();
+      DocValuesEnum fEnum = r.getEnum();
       FloatsRef floats = fEnum.getFloat();
       for (int i = 0; i < NUM_VALUES; i += 1 + random.nextInt(25)) {
         assertEquals(i, fEnum.advance(i));
         assertEquals(values[i], floats.get(), delta);
       }
       for (int i = NUM_VALUES; i < NUM_VALUES + additionalValues; i++) {
-        assertEquals(ValuesEnum.NO_MORE_DOCS, fEnum.advance(i));
+        assertEquals(DocValuesEnum.NO_MORE_DOCS, fEnum.advance(i));
       }
       fEnum.close();
     }
diff --git a/lucene/dev/branches/docvalues/lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing.java b/lucene/dev/branches/docvalues/lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing.java
index 5600b005..334414b0 100644
--- a/lucene/dev/branches/docvalues/lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing.java
+++ b/lucene/dev/branches/docvalues/lucene/src/test/org/apache/lucene/index/values/TestDocValuesIndexing.java
@@ -80,9 +80,6 @@
    *   - add test for unoptimized case with deletes
    *   - add a test for addIndexes
    *   - split up existing testcases and give them meaningfull names
-   *   - use consistent naming throughout DocValues
-   *     - Values -> DocValueType
-   *     - PackedIntsImpl -> Ints
    *   - run RAT
    *   - add tests for FieldComparator FloatIndexValuesComparator vs. FloatValuesComparator etc.
    */
@@ -139,7 +136,7 @@ public void testDocValuesSimple() throws CorruptIndexException, IOException, Par
   }
 
   /**
-   * Tests complete indexing of {@link Values} including deletions, merging and
+   * Tests complete indexing of {@link Type} including deletions, merging and
    * sparse value fields on Compound-File
    */
   public void testIndexBytesNoDeletesCFS() throws IOException {
@@ -159,7 +156,7 @@ public void testIndexNumericsDeletesCFS() throws IOException {
   }
 
   /**
-   * Tests complete indexing of {@link Values} including deletions, merging and
+   * Tests complete indexing of {@link Type} including deletions, merging and
    * sparse value fields on None-Compound-File
    */
   public void testIndexBytesNoDeletes() throws IOException {
@@ -198,11 +195,11 @@ public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)
     Directory d = newDirectory();
     IndexWriter w = new IndexWriter(d, cfg);
     final int numValues = 179 + random.nextInt(151);
-    final List<Values> numVariantList = new ArrayList<Values>(NUMERICS);
+    final List<Type> numVariantList = new ArrayList<Type>(NUMERICS);
 
     // run in random order to test if fill works correctly during merges
     Collections.shuffle(numVariantList, random);
-    for (Values val : numVariantList) {
+    for (Type val : numVariantList) {
       OpenBitSet deleted = indexValues(w, numValues, val, numVariantList,
           withDeletions, 7);
       List<Closeable> closeables = new ArrayList<Closeable>();
@@ -222,7 +219,7 @@ public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)
           assertEquals("index " + i, missing.longValue, value);
         }
 
-        ValuesEnum intsEnum = getValuesEnum(intsReader);
+        DocValuesEnum intsEnum = getValuesEnum(intsReader);
         assertTrue(intsEnum.advance(0) >= base);
 
         intsEnum = getValuesEnum(intsReader);
@@ -253,7 +250,7 @@ public void runTestNumerics(IndexWriterConfig cfg, boolean withDeletions)
           assertEquals(" floats failed for doc: " + i + " base: " + base,
               missing.doubleValue, value, 0.0d);
         }
-        ValuesEnum floatEnum = getValuesEnum(floatReader);
+        DocValuesEnum floatEnum = getValuesEnum(floatReader);
         assertTrue(floatEnum.advance(0) >= base);
 
         floatEnum = getValuesEnum(floatReader);
@@ -288,11 +285,11 @@ public void runTestIndexBytes(IndexWriterConfig cfg, boolean withDeletions)
       throws CorruptIndexException, LockObtainFailedException, IOException {
     final Directory d = newDirectory();
     IndexWriter w = new IndexWriter(d, cfg);
-    final List<Values> byteVariantList = new ArrayList<Values>(BYTES);
+    final List<Type> byteVariantList = new ArrayList<Type>(BYTES);
     // run in random order to test if fill works correctly during merges
     Collections.shuffle(byteVariantList, random);
     final int numValues = 179 + random.nextInt(151);
-    for (Values byteIndexValue : byteVariantList) {
+    for (Type byteIndexValue : byteVariantList) {
       List<Closeable> closeables = new ArrayList<Closeable>();
 
       int bytesSize = 7 + random.nextInt(128);
@@ -341,7 +338,7 @@ public void runTestIndexBytes(IndexWriterConfig cfg, boolean withDeletions)
         default:
           assertNull("expected null - " + msg + " " + br, br);
           // make sure we advance at least until base
-          ValuesEnum bytesEnum = getValuesEnum(bytesReader);
+          DocValuesEnum bytesEnum = getValuesEnum(bytesReader);
           final int advancedTo = bytesEnum.advance(0);
           assertTrue(byteIndexValue.name() + " advanced failed base:" + base
               + " advancedTo: " + advancedTo, base <= advancedTo);
@@ -349,7 +346,7 @@ public void runTestIndexBytes(IndexWriterConfig cfg, boolean withDeletions)
         }
       }
 
-      ValuesEnum bytesEnum = getValuesEnum(bytesReader);
+      DocValuesEnum bytesEnum = getValuesEnum(bytesReader);
       final BytesRef enumRef = bytesEnum.bytes();
       // test the actual doc values added in this iteration
       assertEquals(base + numRemainingValues, r.numDocs());
@@ -427,8 +424,8 @@ private Source getSource(DocValues values) throws IOException {
     return source;
   }
 
-  private ValuesEnum getValuesEnum(DocValues values) throws IOException {
-    ValuesEnum valuesEnum;
+  private DocValuesEnum getValuesEnum(DocValues values) throws IOException {
+    DocValuesEnum valuesEnum;
     if (!(values instanceof MultiDocValues) && random.nextInt(10) == 0) {
       // TODO not supported by MultiDocValues yet!
       valuesEnum = getSource(values).getEnum();
@@ -440,20 +437,20 @@ private ValuesEnum getValuesEnum(DocValues values) throws IOException {
     return valuesEnum;
   }
 
-  private static EnumSet<Values> BYTES = EnumSet.of(Values.BYTES_FIXED_DEREF,
-      Values.BYTES_FIXED_SORTED, Values.BYTES_FIXED_STRAIGHT,
-      Values.BYTES_VAR_DEREF, Values.BYTES_VAR_SORTED,
-      Values.BYTES_VAR_STRAIGHT);
+  private static EnumSet<Type> BYTES = EnumSet.of(Type.BYTES_FIXED_DEREF,
+      Type.BYTES_FIXED_SORTED, Type.BYTES_FIXED_STRAIGHT,
+      Type.BYTES_VAR_DEREF, Type.BYTES_VAR_SORTED,
+      Type.BYTES_VAR_STRAIGHT);
 
-  private static EnumSet<Values> NUMERICS = EnumSet.of(Values.PACKED_INTS,
-      Values.SIMPLE_FLOAT_4BYTE, Values.SIMPLE_FLOAT_8BYTE);
+  private static EnumSet<Type> NUMERICS = EnumSet.of(Type.PACKED_INTS,
+      Type.SIMPLE_FLOAT_4BYTE, Type.SIMPLE_FLOAT_8BYTE);
 
   private static Index[] IDX_VALUES = new Index[] { Index.ANALYZED,
       Index.ANALYZED_NO_NORMS, Index.NOT_ANALYZED, Index.NOT_ANALYZED_NO_NORMS,
       Index.NO };
 
-  private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,
-      List<Values> valueVarList, boolean withDeletions, int multOfSeven)
+  private OpenBitSet indexValues(IndexWriter w, int numValues, Type value,
+      List<Type> valueVarList, boolean withDeletions, int multOfSeven)
       throws CorruptIndexException, IOException {
     final boolean isNumeric = NUMERICS.contains(value);
     OpenBitSet deleted = new OpenBitSet(numValues);
@@ -501,7 +498,7 @@ private OpenBitSet indexValues(IndexWriter w, int numValues, Values value,
 
       if (i % 7 == 0) {
         if (withDeletions && random.nextBoolean()) {
-          Values val = valueVarList.get(random.nextInt(1 + valueVarList
+          Type val = valueVarList.get(random.nextInt(1 + valueVarList
               .indexOf(value)));
           final int randInt = val == value ? random.nextInt(1 + i) : random
               .nextInt(numValues);
