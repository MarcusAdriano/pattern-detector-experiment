diff --git a/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/EmbeddedServiceBase.java b/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/EmbeddedServiceBase.java
index b88f238d..02daf59e 100644
--- a/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/EmbeddedServiceBase.java
+++ b/cassandra/trunk/drivers/java/test/org/apache/cassandra/cql/EmbeddedServiceBase.java
@@ -4,6 +4,7 @@
 import java.net.Socket;
 import java.net.UnknownHostException;
 
+import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.config.DatabaseDescriptor;
@@ -43,7 +44,7 @@ static void startCassandraServer() throws IOException, ConfigurationException
      */
     static void loadData() throws ConfigurationException
     {
-        for (KSMetaData table : DatabaseDescriptor.readTablesFromYaml())
+        for (KSMetaData table : SchemaLoader.schemaDefinition())
         {
             for (CFMetaData cfm : table.cfMetaData().values())
             {
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/CFMetaData.java b/cassandra/trunk/src/java/org/apache/cassandra/config/CFMetaData.java
index 8b7e55ed..80b95af8 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/CFMetaData.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/CFMetaData.java
@@ -46,7 +46,6 @@
 
 public final class CFMetaData
 {
-
     public final static double DEFAULT_ROW_CACHE_SIZE = 0.0;
     public final static double DEFAULT_KEY_CACHE_SIZE = 200000;
     public final static double DEFAULT_READ_REPAIR_CHANCE = 1.0;
@@ -63,43 +62,16 @@
     public final static double DEFAULT_MERGE_SHARDS_CHANCE = 0.1;
 
     private static final int MIN_CF_ID = 1000;
-
     private static final AtomicInteger idGen = new AtomicInteger(MIN_CF_ID);
     
     private static final BiMap<Pair<String, String>, Integer> cfIdMap = HashBiMap.create();
     
-    public static final CFMetaData StatusCf = newSystemTable(SystemTable.STATUS_CF, 0, "persistent metadata for the local node", BytesType.instance, null, DEFAULT_SYSTEM_MEMTABLE_THROUGHPUT_IN_MB);
-    public static final CFMetaData HintsCf = newSystemTable(HintedHandOffManager.HINTS_CF, 1, "hinted handoff data", BytesType.instance, BytesType.instance, Math.min(256, Math.max(32, DEFAULT_MEMTABLE_THROUGHPUT_IN_MB / 2)));
-    public static final CFMetaData MigrationsCf = newSystemTable(Migration.MIGRATIONS_CF, 2, "individual schema mutations", TimeUUIDType.instance, null, DEFAULT_SYSTEM_MEMTABLE_THROUGHPUT_IN_MB);
-    public static final CFMetaData SchemaCf = newSystemTable(Migration.SCHEMA_CF, 3, "current state of the schema", UTF8Type.instance, null, DEFAULT_SYSTEM_MEMTABLE_THROUGHPUT_IN_MB);
-    public static final CFMetaData IndexCf = newSystemTable(SystemTable.INDEX_CF, 5, "indexes that have been completed", UTF8Type.instance, null, DEFAULT_SYSTEM_MEMTABLE_THROUGHPUT_IN_MB);
-    public static final CFMetaData NodeIdCf = newSystemTable(SystemTable.NODE_ID_CF, 6, "nodeId and their metadata", TimeUUIDType.instance, null, DEFAULT_SYSTEM_MEMTABLE_THROUGHPUT_IN_MB);
-
-    private static CFMetaData newSystemTable(String cfName, int cfId, String comment, AbstractType comparator, AbstractType subComparator, int memtableThroughPutInMB)
-    {
-        return new CFMetaData(Table.SYSTEM_TABLE,
-                              cfName,
-                              subComparator == null ? ColumnFamilyType.Standard : ColumnFamilyType.Super,
-                              comparator,
-                              subComparator,
-                              comment,
-                              0,
-                              0.01,
-                              0,
-                              false,
-                              0,
-                              BytesType.instance,
-                              DEFAULT_MIN_COMPACTION_THRESHOLD,
-                              DEFAULT_MAX_COMPACTION_THRESHOLD,
-                              DEFAULT_ROW_CACHE_SAVE_PERIOD_IN_SECONDS,
-                              DEFAULT_KEY_CACHE_SAVE_PERIOD_IN_SECONDS,
-                              DEFAULT_MEMTABLE_LIFETIME_IN_MINS,
-                              memtableThroughPutInMB,
-                              sizeMemtableOperations(memtableThroughPutInMB),
-                              0,
-                              cfId,
-                              Collections.<ByteBuffer, ColumnDefinition>emptyMap());
-    }
+    public static final CFMetaData StatusCf = newSystemMetadata(SystemTable.STATUS_CF, 0, "persistent metadata for the local node", BytesType.instance, null, DEFAULT_SYSTEM_MEMTABLE_THROUGHPUT_IN_MB);
+    public static final CFMetaData HintsCf = newSystemMetadata(HintedHandOffManager.HINTS_CF, 1, "hinted handoff data", BytesType.instance, BytesType.instance, Math.min(256, Math.max(32, DEFAULT_MEMTABLE_THROUGHPUT_IN_MB / 2)));
+    public static final CFMetaData MigrationsCf = newSystemMetadata(Migration.MIGRATIONS_CF, 2, "individual schema mutations", TimeUUIDType.instance, null, DEFAULT_SYSTEM_MEMTABLE_THROUGHPUT_IN_MB);
+    public static final CFMetaData SchemaCf = newSystemMetadata(Migration.SCHEMA_CF, 3, "current state of the schema", UTF8Type.instance, null, DEFAULT_SYSTEM_MEMTABLE_THROUGHPUT_IN_MB);
+    public static final CFMetaData IndexCf = newSystemMetadata(SystemTable.INDEX_CF, 5, "indexes that have been completed", UTF8Type.instance, null, DEFAULT_SYSTEM_MEMTABLE_THROUGHPUT_IN_MB);
+    public static final CFMetaData NodeIdCf = newSystemMetadata(SystemTable.NODE_ID_CF, 6, "nodeId and their metadata", TimeUUIDType.instance, null, DEFAULT_SYSTEM_MEMTABLE_THROUGHPUT_IN_MB);
 
     /**
      * @return A calculated memtable throughput size for this machine.
@@ -128,9 +100,9 @@ public static double sizeMemtableOperations(int mem_throughput)
     /**
      * @return The id for the given (ksname,cfname) pair, or null if it has been dropped.
      */
-    public static Integer getId(String table, String cfName)
+    public static Integer getId(String ksName, String cfName)
     {
-        return cfIdMap.get(new Pair<String, String>(table, cfName));
+        return cfIdMap.get(new Pair<String, String>(ksName, cfName));
     }
     
     // this gets called after initialization to make sure that id generation happens properly.
@@ -140,9 +112,21 @@ public static void fixMaxId()
         idGen.set(cfIdMap.size() == 0 ? MIN_CF_ID : Math.max(Collections.max(cfIdMap.values()) + 1, MIN_CF_ID));
     }
 
+    /** adds this cfm to the map. */
+    public static void map(CFMetaData cfm) throws ConfigurationException
+    {
+        Pair<String, String> key = new Pair<String, String>(cfm.ksName, cfm.cfName);
+        if (cfIdMap.containsKey(key))
+            throw new ConfigurationException("Attempt to assign id to existing column family.");
+        else
+        {
+            cfIdMap.put(key, cfm.cfId);
+        }
+    }
+
     //REQUIRED
     public final Integer cfId;                        // internal id, never exposed to user
-    public final String tableName;                    // name of keyspace
+    public final String ksName;                    // name of keyspace
     public final String cfName;                       // name of this column family
     public final ColumnFamilyType cfType;             // standard, super
     public final AbstractType comparator;             // bytes, long, timeuuid, utf8, etc.
@@ -155,9 +139,9 @@ public static void fixMaxId()
     private double readRepairChance;                  // default 1.0 (always), chance [0.0,1.0] of read repair
     private boolean replicateOnWrite;                 // default false
     private int gcGraceSeconds;                       // default 864000 (ten days)
-    private AbstractType defaultValidator;            // default none, use comparator types
-    private Integer minCompactionThreshold;           // default 4
-    private Integer maxCompactionThreshold;           // default 32
+    private AbstractType defaultValidator;            // default BytesType (no-op), use comparator types
+    private int minCompactionThreshold;               // default 4
+    private int maxCompactionThreshold;               // default 32
     private int rowCacheSavePeriodInSeconds;          // default 0 (off)
     private int keyCacheSavePeriodInSeconds;          // default 3600 (1 hour)
     private int memtableFlushAfterMins;               // default 60 
@@ -166,208 +150,144 @@ public static void fixMaxId()
     private double mergeShardsChance;                 // default 0.1, chance [0.0, 1.0] of merging old shards during replication
     // NOTE: if you find yourself adding members to this class, make sure you keep the convert methods in lockstep.
 
-    private final Map<ByteBuffer, ColumnDefinition> column_metadata;
-
-    private CFMetaData(String tableName,
-                       String cfName,
-                       ColumnFamilyType cfType,
-                       AbstractType comparator,
-                       AbstractType subcolumnComparator,
-                       String comment,
-                       double rowCacheSize,
-                       double keyCacheSize,
-                       double readRepairChance,
-                       boolean replicateOnWrite,
-                       int gcGraceSeconds,
-                       AbstractType defaultValidator,
-                       int minCompactionThreshold,
-                       int maxCompactionThreshold,
-                       int rowCacheSavePeriodInSeconds,
-                       int keyCacheSavePeriodInSeconds,
-                       int memtableFlushAfterMins,
-                       Integer memtableThroughputInMb,
-                       Double memtableOperationsInMillions,
-                       double mergeShardsChance,
-                       Integer cfId,
-                       Map<ByteBuffer, ColumnDefinition> column_metadata)
-
-    {
-        assert column_metadata != null;
-        this.tableName = tableName;
-        this.cfName = cfName;
-        this.cfType = cfType;
-        this.comparator = comparator;
-        // the default subcolumncomparator is null per thrift spec, but only should be null if cfType == Standard. If
-        // cfType == Super, subcolumnComparator should default to BytesType if not set.
-        this.subcolumnComparator = subcolumnComparator == null && cfType == ColumnFamilyType.Super
-                                   ? BytesType.instance
-                                   : subcolumnComparator;
-        this.comment = comment == null ? "" : comment;
-        this.rowCacheSize = rowCacheSize;
-        this.keyCacheSize = keyCacheSize;
-        this.readRepairChance = readRepairChance;
-        this.replicateOnWrite = replicateOnWrite;
-        this.gcGraceSeconds = gcGraceSeconds;
-        this.defaultValidator = defaultValidator;
-        this.minCompactionThreshold = minCompactionThreshold;
-        this.maxCompactionThreshold = maxCompactionThreshold;
-        this.rowCacheSavePeriodInSeconds = rowCacheSavePeriodInSeconds;
-        this.keyCacheSavePeriodInSeconds = keyCacheSavePeriodInSeconds;
-        this.memtableFlushAfterMins = memtableFlushAfterMins;
-        this.memtableThroughputInMb = memtableThroughputInMb == null
-                                      ? DEFAULT_MEMTABLE_THROUGHPUT_IN_MB
-                                      : memtableThroughputInMb;
-
-        this.memtableOperationsInMillions = memtableOperationsInMillions == null
-                                            ? DEFAULT_MEMTABLE_OPERATIONS_IN_MILLIONS
-                                            : memtableOperationsInMillions;
-        this.mergeShardsChance = mergeShardsChance;
-        this.cfId = cfId;
-        this.column_metadata = new HashMap<ByteBuffer, ColumnDefinition>(column_metadata);
+    private Map<ByteBuffer, ColumnDefinition> column_metadata;
+
+    public CFMetaData comment(String prop) {comment = prop; return this;}
+    public CFMetaData rowCacheSize(double prop) {rowCacheSize = prop; return this;}
+    public CFMetaData keyCacheSize(double prop) {keyCacheSize = prop; return this;}
+    public CFMetaData readRepairChance(double prop) {readRepairChance = prop; return this;}
+    public CFMetaData replicateOnWrite(boolean prop) {replicateOnWrite = prop; return this;}
+    public CFMetaData gcGraceSeconds(int prop) {gcGraceSeconds = prop; return this;}
+    public CFMetaData defaultValidator(AbstractType prop) {defaultValidator = prop; return this;}
+    public CFMetaData minCompactionThreshold(int prop) {minCompactionThreshold = prop; return this;}
+    public CFMetaData maxCompactionThreshold(int prop) {maxCompactionThreshold = prop; return this;}
+    public CFMetaData rowCacheSavePeriod(int prop) {rowCacheSavePeriodInSeconds = prop; return this;}
+    public CFMetaData keyCacheSavePeriod(int prop) {keyCacheSavePeriodInSeconds = prop; return this;}
+    public CFMetaData memTime(int prop) {memtableFlushAfterMins = prop; return this;}
+    public CFMetaData memSize(int prop) {memtableThroughputInMb = prop; return this;}
+    public CFMetaData memOps(double prop) {memtableOperationsInMillions = prop; return this;}
+    public CFMetaData mergeShardsChance(double prop) {mergeShardsChance = prop; return this;}
+    public CFMetaData columnMetadata(Map<ByteBuffer,ColumnDefinition> prop) {column_metadata = prop; return this;}
+
+    public CFMetaData(String keyspace, String name, ColumnFamilyType type, AbstractType comp, AbstractType subcc)
+    {
+        // Final fields must be set in constructor
+        ksName = keyspace;
+        cfName = name;
+        cfType = type;
+        comparator = comp;
+        subcolumnComparator = enforceSubccDefault(type, subcc);
+
+        // Default new CFMDs get an id chosen for them
+        cfId = nextId();
+
+        this.init();
     }
-    
-    /** adds this cfm to the map. */
-    public static void map(CFMetaData cfm) throws ConfigurationException
+
+    private CFMetaData(String keyspace, String name, ColumnFamilyType type, AbstractType comp, AbstractType subcc, int id)
     {
-        Pair<String, String> key = new Pair<String, String>(cfm.tableName, cfm.cfName);
-        if (cfIdMap.containsKey(key))
-            throw new ConfigurationException("Attempt to assign id to existing column family.");
-        else
-        {
-            cfIdMap.put(key, cfm.cfId);
-        }
+        // Final fields must be set in constructor
+        ksName = keyspace;
+        cfName = name;
+        cfType = type;
+        comparator = comp;
+        subcolumnComparator = enforceSubccDefault(type, subcc);
+
+        // System cfs have specific ids, and copies of old CFMDs need
+        //  to copy over the old id.
+        cfId = id;
+
+        this.init();
     }
 
-    public CFMetaData(String tableName,
-                      String cfName,
-                      ColumnFamilyType cfType,
-                      AbstractType comparator,
-                      AbstractType subcolumnComparator,
-                      String comment,
-                      double rowCacheSize,
-                      double keyCacheSize,
-                      double readRepairChance,
-                      boolean replicateOnWrite,
-                      int gcGraceSeconds,
-                      AbstractType defaultValidator,
-                      int minCompactionThreshold,
-                      int maxCompactionThreshold,
-                      int rowCacheSavePeriodInSeconds,
-                      int keyCacheSavePeriodInSeconds,
-                      int memTime,
-                      Integer memSize,
-                      Double memOps,
-                      double mergeShardsChance,
-                      //This constructor generates the id!
-                      Map<ByteBuffer, ColumnDefinition> column_metadata)
-    {
-        this(tableName,
-             cfName,
-             cfType,
-             comparator,
-             subcolumnComparator,
-             comment,
-             rowCacheSize,
-             keyCacheSize,
-             readRepairChance,
-             replicateOnWrite,
-             gcGraceSeconds,
-             defaultValidator,
-             minCompactionThreshold,
-             maxCompactionThreshold,
-             rowCacheSavePeriodInSeconds,
-             keyCacheSavePeriodInSeconds,
-             memTime,
-             memSize,
-             memOps,
-             mergeShardsChance,
-             nextId(),
-             column_metadata);
+    private AbstractType enforceSubccDefault(ColumnFamilyType cftype, AbstractType subcc)
+    {
+        return (subcc == null) && (cftype == ColumnFamilyType.Super) ? BytesType.instance : subcc;
+    }
+
+    private void init()
+    {
+        // Set a bunch of defaults
+        rowCacheSize                 = DEFAULT_ROW_CACHE_SIZE;
+        keyCacheSize                 = DEFAULT_KEY_CACHE_SIZE;
+        readRepairChance             = DEFAULT_READ_REPAIR_CHANCE;
+        replicateOnWrite             = DEFAULT_REPLICATE_ON_WRITE;
+        gcGraceSeconds               = DEFAULT_GC_GRACE_SECONDS;
+        minCompactionThreshold       = DEFAULT_MIN_COMPACTION_THRESHOLD;
+        maxCompactionThreshold       = DEFAULT_MAX_COMPACTION_THRESHOLD;
+        memtableFlushAfterMins       = DEFAULT_MEMTABLE_LIFETIME_IN_MINS;
+        memtableThroughputInMb       = DEFAULT_MEMTABLE_THROUGHPUT_IN_MB;
+        memtableOperationsInMillions = DEFAULT_MEMTABLE_OPERATIONS_IN_MILLIONS;
+        mergeShardsChance            = DEFAULT_MERGE_SHARDS_CHANCE;
+
+        // Defaults strange or simple enough to not need a DEFAULT_T for
+        defaultValidator = BytesType.instance;
+        comment = "";
+        column_metadata = new HashMap<ByteBuffer,ColumnDefinition>();
+    }
+
+    private static CFMetaData newSystemMetadata(String cfName, int cfId, String comment, AbstractType comparator, AbstractType subcc, int memtableThroughPutInMB)
+    {
+        ColumnFamilyType type = subcc == null ? ColumnFamilyType.Standard : ColumnFamilyType.Super;
+        CFMetaData newCFMD = new CFMetaData(Table.SYSTEM_TABLE, cfName, type, comparator,  subcc, cfId);
+
+        return newCFMD.comment(comment)
+                      .keyCacheSize(0.01)
+                      .readRepairChance(0)
+                      .gcGraceSeconds(0)
+                      .memSize(memtableThroughPutInMB)
+                      .memOps(sizeMemtableOperations(memtableThroughPutInMB))
+                      .mergeShardsChance(0.0);
     }
     
     public static CFMetaData newIndexMetadata(CFMetaData parent, ColumnDefinition info, AbstractType columnComparator)
-    {
-        return new CFMetaData(parent.tableName,
-                              indexName(parent.cfName, info),
-                              ColumnFamilyType.Standard,
-                              columnComparator,
-                              null,
-                              "",
-                              0,
-                              0,
-                              0,
-                              false,
-                              parent.gcGraceSeconds,
-                              BytesType.instance,
-                              parent.minCompactionThreshold,
-                              parent.maxCompactionThreshold,
-                              0,
-                              0,
-                              parent.memtableFlushAfterMins,
-                              parent.memtableThroughputInMb,
-                              parent.memtableOperationsInMillions,
-                              0,
-                              Collections.<ByteBuffer, ColumnDefinition>emptyMap());
-    }
-
-    /** clones an existing CFMetaData using the same id. */
+        {
+        return new CFMetaData(parent.ksName, indexName(parent.cfName, info), ColumnFamilyType.Standard, columnComparator, null)
+                             .keyCacheSize(0.0)
+                             .readRepairChance(0.0)
+                             .gcGraceSeconds(parent.gcGraceSeconds)
+                             .minCompactionThreshold(parent.minCompactionThreshold)
+                             .maxCompactionThreshold(parent.maxCompactionThreshold)
+                             .memTime(parent.memtableFlushAfterMins)
+                             .memSize(parent.memtableThroughputInMb)
+                             .memOps(parent.memtableOperationsInMillions);
+    }
+
+    // Create a new CFMD by changing just the cfName
     public static CFMetaData rename(CFMetaData cfm, String newName)
     {
-        return new CFMetaData(cfm.tableName,
-                              newName,
-                              cfm.cfType,
-                              cfm.comparator,
-                              cfm.subcolumnComparator,
-                              cfm.comment,
-                              cfm.rowCacheSize,
-                              cfm.keyCacheSize,
-                              cfm.readRepairChance,
-                              cfm.replicateOnWrite,
-                              cfm.gcGraceSeconds,
-                              cfm.defaultValidator,
-                              cfm.minCompactionThreshold,
-                              cfm.maxCompactionThreshold,
-                              cfm.rowCacheSavePeriodInSeconds,
-                              cfm.keyCacheSavePeriodInSeconds,
-                              cfm.memtableFlushAfterMins,
-                              cfm.memtableThroughputInMb,
-                              cfm.memtableOperationsInMillions,
-                              cfm.mergeShardsChance,
-                              cfm.cfId,
-                              cfm.column_metadata);
+        return copyOpts(new CFMetaData(cfm.ksName, newName, cfm.cfType, cfm.comparator, cfm.subcolumnComparator, cfm.cfId), cfm);
     }
     
-    /** clones existing CFMetaData. keeps the id but changes the table name.*/
-    public static CFMetaData renameTable(CFMetaData cfm, String tableName)
-    {
-        return new CFMetaData(tableName,
-                              cfm.cfName,
-                              cfm.cfType,
-                              cfm.comparator,
-                              cfm.subcolumnComparator,
-                              cfm.comment,
-                              cfm.rowCacheSize,
-                              cfm.keyCacheSize,
-                              cfm.readRepairChance,
-                              cfm.replicateOnWrite,
-                              cfm.gcGraceSeconds,
-                              cfm.defaultValidator,
-                              cfm.minCompactionThreshold,
-                              cfm.maxCompactionThreshold,
-                              cfm.rowCacheSavePeriodInSeconds,
-                              cfm.keyCacheSavePeriodInSeconds,
-                              cfm.memtableFlushAfterMins,
-                              cfm.memtableThroughputInMb,
-                              cfm.memtableOperationsInMillions,
-                              cfm.mergeShardsChance,
-                              cfm.cfId,
-                              cfm.column_metadata);
+    // Create a new CFMD by changing just the ksName
+    public static CFMetaData renameTable(CFMetaData cfm, String ksName)
+    {
+        return copyOpts(new CFMetaData(ksName, cfm.cfName, cfm.cfType, cfm.comparator, cfm.subcolumnComparator, cfm.cfId), cfm);
+    }
+
+    private static CFMetaData copyOpts(CFMetaData newCFMD, CFMetaData oldCFMD)
+    {
+        return newCFMD.comment(oldCFMD.comment)
+                      .rowCacheSize(oldCFMD.rowCacheSize)
+                      .keyCacheSize(oldCFMD.keyCacheSize)
+                      .readRepairChance(oldCFMD.readRepairChance)
+                      .replicateOnWrite(oldCFMD.replicateOnWrite)
+                      .gcGraceSeconds(oldCFMD.gcGraceSeconds)
+                      .defaultValidator(oldCFMD.defaultValidator)
+                      .minCompactionThreshold(oldCFMD.minCompactionThreshold)
+                      .maxCompactionThreshold(oldCFMD.maxCompactionThreshold)
+                      .rowCacheSavePeriod(oldCFMD.rowCacheSavePeriodInSeconds)
+                      .keyCacheSavePeriod(oldCFMD.keyCacheSavePeriodInSeconds)
+                      .memTime(oldCFMD.memtableFlushAfterMins)
+                      .memSize(oldCFMD.memtableThroughputInMb)
+                      .memOps(oldCFMD.memtableOperationsInMillions)
+                      .columnMetadata(oldCFMD.column_metadata);
     }
     
     /** used for evicting cf data out of static tracking collections. */
     public static void purge(CFMetaData cfm)
     {
-        cfIdMap.remove(new Pair<String, String>(cfm.tableName, cfm.cfName));
+        cfIdMap.remove(new Pair<String, String>(cfm.ksName, cfm.cfName));
     }
     
     /** convention for nameing secondary indexes. */
@@ -380,7 +300,7 @@ public static String indexName(String parentCf, ColumnDefinition info)
     {
         org.apache.cassandra.db.migration.avro.CfDef cf = new org.apache.cassandra.db.migration.avro.CfDef();
         cf.id = cfId;
-        cf.keyspace = new Utf8(tableName);
+        cf.keyspace = new Utf8(ksName);
         cf.name = new Utf8(cfName);
         cf.column_type = new Utf8(cfType.name());
         cf.comparator_type = new Utf8(comparator.getClass().getName());
@@ -433,38 +353,34 @@ public static CFMetaData inflate(org.apache.cassandra.db.migration.avro.CfDef cf
             column_metadata.put(cd.name, cd);
         }
 
-        //isn't AVRO supposed to handle stuff like this?
-        Integer minct = cf.min_compaction_threshold == null ? DEFAULT_MIN_COMPACTION_THRESHOLD : cf.min_compaction_threshold;
-        Integer maxct = cf.max_compaction_threshold == null ? DEFAULT_MAX_COMPACTION_THRESHOLD : cf.max_compaction_threshold;
-        Integer row_cache_save_period_in_seconds = cf.row_cache_save_period_in_seconds == null ? DEFAULT_ROW_CACHE_SAVE_PERIOD_IN_SECONDS : cf.row_cache_save_period_in_seconds;
-        Integer key_cache_save_period_in_seconds = cf.key_cache_save_period_in_seconds == null ? DEFAULT_KEY_CACHE_SAVE_PERIOD_IN_SECONDS : cf.key_cache_save_period_in_seconds;
-        Integer memtable_flush_after_mins = cf.memtable_flush_after_mins == null ? DEFAULT_MEMTABLE_LIFETIME_IN_MINS : cf.memtable_flush_after_mins;
-        Integer memtable_throughput_in_mb = cf.memtable_throughput_in_mb == null ? DEFAULT_MEMTABLE_THROUGHPUT_IN_MB : cf.memtable_throughput_in_mb;
-        Double memtable_operations_in_millions = cf.memtable_operations_in_millions == null ? DEFAULT_MEMTABLE_OPERATIONS_IN_MILLIONS : cf.memtable_operations_in_millions;
-        double merge_shards_chance = cf.merge_shards_chance == null ? DEFAULT_MERGE_SHARDS_CHANCE : cf.merge_shards_chance;
-
-        return new CFMetaData(cf.keyspace.toString(),
+        CFMetaData newCFMD = new CFMetaData(cf.keyspace.toString(),
                               cf.name.toString(),
                               ColumnFamilyType.create(cf.column_type.toString()),
                               comparator,
                               subcolumnComparator,
-                              cf.comment.toString(),
-                              cf.row_cache_size,
-                              cf.key_cache_size,
-                              cf.read_repair_chance,
-                              cf.replicate_on_write,
-                              cf.gc_grace_seconds,
-                              validator,
-                              minct,
-                              maxct,
-                              row_cache_save_period_in_seconds,
-                              key_cache_save_period_in_seconds,
-                              memtable_flush_after_mins,
-                              memtable_throughput_in_mb,
-                              memtable_operations_in_millions,
-                              merge_shards_chance,
-                              cf.id,
-                              column_metadata);
+                                            cf.id);
+
+        // When we pull up an old avro CfDef which doesn't have these arguments,
+        //  it doesn't default them correctly. Without explicit defaulting,
+        //  grandfathered metadata becomes wrong or causes crashes.
+        //  Isn't AVRO supposed to handle stuff like this?
+        if (cf.min_compaction_threshold != null) { newCFMD.minCompactionThreshold(cf.min_compaction_threshold); }
+        if (cf.max_compaction_threshold != null) { newCFMD.maxCompactionThreshold(cf.max_compaction_threshold); }
+        if (cf.row_cache_save_period_in_seconds != null) { newCFMD.rowCacheSavePeriod(cf.row_cache_save_period_in_seconds); }
+        if (cf.key_cache_save_period_in_seconds != null) { newCFMD.keyCacheSavePeriod(cf.key_cache_save_period_in_seconds); }
+        if (cf.memtable_flush_after_mins != null) { newCFMD.memTime(cf.memtable_flush_after_mins); }
+        if (cf.memtable_throughput_in_mb != null) { newCFMD.memSize(cf.memtable_throughput_in_mb); }
+        if (cf.memtable_operations_in_millions != null) { newCFMD.memOps(cf.memtable_operations_in_millions); }
+        if (cf.merge_shards_chance != null) { newCFMD.mergeShardsChance(cf.merge_shards_chance); }
+
+        return newCFMD.comment(cf.comment.toString())
+                      .rowCacheSize(cf.row_cache_size)
+                      .keyCacheSize(cf.key_cache_size)
+                      .readRepairChance(cf.read_repair_chance)
+                      .replicateOnWrite(cf.replicate_on_write)
+                      .gcGraceSeconds(cf.gc_grace_seconds)
+                      .defaultValidator(validator)
+                      .columnMetadata(column_metadata);
     }
     
     public String getComment()
@@ -560,7 +476,7 @@ else if (obj == null || obj.getClass() != getClass())
 
         CFMetaData rhs = (CFMetaData) obj;
         return new EqualsBuilder()
-            .append(tableName, rhs.tableName)
+            .append(ksName, rhs.ksName)
             .append(cfName, rhs.cfName)
             .append(cfType, rhs.cfType)
             .append(comparator, rhs.comparator)
@@ -587,7 +503,7 @@ else if (obj == null || obj.getClass() != getClass())
     public int hashCode()
     {
         return new HashCodeBuilder(29, 1597)
-            .append(tableName)
+            .append(ksName)
             .append(cfName)
             .append(cfType)
             .append(comparator)
@@ -629,6 +545,8 @@ public AbstractType getValueValidator(ByteBuffer column)
     /** applies implicit defaults to cf definition. useful in updates */
     public static void applyImplicitDefaults(org.apache.cassandra.db.migration.avro.CfDef cf_def)
     {
+        if (cf_def.comment == null)
+            cf_def.comment = "";
         if (cf_def.min_compaction_threshold == null)
             cf_def.min_compaction_threshold = CFMetaData.DEFAULT_MIN_COMPACTION_THRESHOLD;
         if (cf_def.max_compaction_threshold == null)
@@ -650,6 +568,8 @@ public static void applyImplicitDefaults(org.apache.cassandra.db.migration.avro.
     /** applies implicit defaults to cf definition. useful in updates */
     public static void applyImplicitDefaults(org.apache.cassandra.thrift.CfDef cf_def) 
     {
+        if (!cf_def.isSetComment())
+            cf_def.setComment("");
         if (!cf_def.isSetMin_compaction_threshold())
             cf_def.setMin_compaction_threshold(CFMetaData.DEFAULT_MIN_COMPACTION_THRESHOLD);
         if (!cf_def.isSetMax_compaction_threshold())
@@ -674,7 +594,7 @@ public void apply(org.apache.cassandra.db.migration.avro.CfDef cf_def) throws Co
         // validate
         if (!cf_def.id.equals(cfId))
             throw new ConfigurationException("ids do not match.");
-        if (!cf_def.keyspace.toString().equals(tableName))
+        if (!cf_def.keyspace.toString().equals(ksName))
             throw new ConfigurationException("keyspaces do not match.");
         if (!cf_def.name.toString().equals(cfName))
             throw new ConfigurationException("names do not match.");
@@ -738,8 +658,9 @@ else if (subcolumnComparator != DatabaseDescriptor.getComparator(cf_def.subcompa
         // add the new ones coming in.
         for (org.apache.cassandra.db.migration.avro.ColumnDef def : toAdd)
         {
+            AbstractType dValidClass = DatabaseDescriptor.getComparator(def.validation_class);
             ColumnDefinition cd = new ColumnDefinition(def.name, 
-                                                       def.validation_class.toString(), 
+                                                       dValidClass,
                                                        def.index_type == null ? null : org.apache.cassandra.thrift.IndexType.valueOf(def.index_type.toString()), 
                                                        def.index_name == null ? null : def.index_name.toString());
             column_metadata.put(cd.name, cd);
@@ -749,7 +670,7 @@ else if (subcolumnComparator != DatabaseDescriptor.getComparator(cf_def.subcompa
     // converts CFM to thrift CfDef
     public static org.apache.cassandra.thrift.CfDef convertToThrift(CFMetaData cfm)
     {
-        org.apache.cassandra.thrift.CfDef def = new org.apache.cassandra.thrift.CfDef(cfm.tableName, cfm.cfName);
+        org.apache.cassandra.thrift.CfDef def = new org.apache.cassandra.thrift.CfDef(cfm.ksName, cfm.cfName);
         def.setId(cfm.cfId);
         def.setColumn_type(cfm.cfType.name());
         def.setComparator_type(cfm.comparator.getClass().getName());
@@ -792,7 +713,7 @@ else if (subcolumnComparator != DatabaseDescriptor.getComparator(cf_def.subcompa
     {
         org.apache.cassandra.db.migration.avro.CfDef def = new org.apache.cassandra.db.migration.avro.CfDef();
         def.name = cfm.cfName;
-        def.keyspace = cfm.tableName;
+        def.keyspace = cfm.ksName;
         def.id = cfm.cfId;
         def.column_type = cfm.cfType.name();
         def.comparator_type = cfm.comparator.getClass().getName();
@@ -957,7 +878,7 @@ public String toString()
     {
         return new ToStringBuilder(this)
             .append("cfId", cfId)
-            .append("tableName", tableName)
+            .append("ksName", ksName)
             .append("cfName", cfName)
             .append("cfType", cfType)
             .append("comparator", comparator)
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/ColumnDefinition.java b/cassandra/trunk/src/java/org/apache/cassandra/config/ColumnDefinition.java
index 1720eaf4..2bc4b370 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/ColumnDefinition.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/ColumnDefinition.java
@@ -22,10 +22,7 @@
 
 
 import java.nio.ByteBuffer;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.TreeMap;
+import java.util.*;
 
 import org.apache.avro.util.Utf8;
 import org.apache.cassandra.db.marshal.AbstractType;
@@ -42,12 +39,12 @@
     private IndexType index_type;
     private String index_name;
 
-    public ColumnDefinition(ByteBuffer name, String validation_class, IndexType index_type, String index_name) throws ConfigurationException
+    public ColumnDefinition(ByteBuffer name, AbstractType validator, IndexType index_type, String index_name)
     {
         this.name = name;
         this.index_type = index_type;
         this.index_name = index_name;
-        this.validator = DatabaseDescriptor.getComparator(validation_class);
+        this.validator = validator;
     }
 
     @Override
@@ -96,7 +93,8 @@ public static ColumnDefinition inflate(org.apache.cassandra.db.migration.avro.Co
         String index_name = cd.index_name == null ? null : cd.index_name.toString();
         try
         {
-            return new ColumnDefinition(cd.name, cd.validation_class.toString(), index_type, index_name);
+            AbstractType validatorType = DatabaseDescriptor.getComparator(cd.validation_class);
+            return new ColumnDefinition(cd.name, validatorType, index_type, index_name);
         }
         catch (ConfigurationException e)
         {
@@ -106,14 +104,16 @@ public static ColumnDefinition inflate(org.apache.cassandra.db.migration.avro.Co
 
     public static ColumnDefinition fromColumnDef(ColumnDef thriftColumnDef) throws ConfigurationException
     {
-        return new ColumnDefinition(ByteBufferUtil.clone(thriftColumnDef.name), thriftColumnDef.validation_class, thriftColumnDef.index_type, thriftColumnDef.index_name);
+        AbstractType validatorType = DatabaseDescriptor.getComparator(thriftColumnDef.validation_class);
+        return new ColumnDefinition(ByteBufferUtil.clone(thriftColumnDef.name), validatorType, thriftColumnDef.index_type, thriftColumnDef.index_name);
     }
     
     public static ColumnDefinition fromColumnDef(org.apache.cassandra.db.migration.avro.ColumnDef avroColumnDef) throws ConfigurationException
     {
         validateIndexType(avroColumnDef);
+        AbstractType validatorType = DatabaseDescriptor.getComparator(avroColumnDef.validation_class);
         return new ColumnDefinition(avroColumnDef.name,
-                avroColumnDef.validation_class.toString(),
+                validatorType,
                 IndexType.valueOf(avroColumnDef.index_type == null ? D_COLDEF_INDEXTYPE : avroColumnDef.index_type.name()),
                 avroColumnDef.index_name == null ? D_COLDEF_INDEXNAME : avroColumnDef.index_name.toString());
     }
@@ -121,13 +121,13 @@ public static ColumnDefinition fromColumnDef(org.apache.cassandra.db.migration.a
     public static Map<ByteBuffer, ColumnDefinition> fromColumnDef(List<ColumnDef> thriftDefs) throws ConfigurationException
     {
         if (thriftDefs == null)
-            return Collections.emptyMap();
+            return new HashMap<ByteBuffer,ColumnDefinition>();
 
         Map<ByteBuffer, ColumnDefinition> cds = new TreeMap<ByteBuffer, ColumnDefinition>();
         for (ColumnDef thriftColumnDef : thriftDefs)
             cds.put(ByteBufferUtil.clone(thriftColumnDef.name), fromColumnDef(thriftColumnDef));
 
-        return Collections.unmodifiableMap(cds);
+        return cds;
     }
     
     public static Map<ByteBuffer, ColumnDefinition> fromColumnDefs(Iterable<org.apache.cassandra.db.migration.avro.ColumnDef> avroDefs) throws ConfigurationException
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/Config.java b/cassandra/trunk/src/java/org/apache/cassandra/config/Config.java
index 5bbd89c5..f80ea8d8 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/Config.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/Config.java
@@ -107,7 +107,6 @@
 
     public Integer index_interval = 128;
 
-    public List<RawKeyspace> keyspaces;
     public Double flush_largest_memtables_at = 1.0;
     public Double reduce_cache_sizes_at = 1.0;
     public double reduce_cache_capacity_to = 0.6;
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java b/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
index 99b2163f..fec74941 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
@@ -131,17 +131,9 @@ static URL getStorageConfigURL() throws ConfigurationException
                 throw new AssertionError(e);
             }
             org.yaml.snakeyaml.constructor.Constructor constructor = new org.yaml.snakeyaml.constructor.Constructor(Config.class);
-            TypeDescription desc = new TypeDescription(Config.class);
-            desc.putListPropertyType("keyspaces", RawKeyspace.class);
-            TypeDescription ksDesc = new TypeDescription(RawKeyspace.class);
-            ksDesc.putListPropertyType("column_families", RawColumnFamily.class);
-            TypeDescription cfDesc = new TypeDescription(RawColumnFamily.class);
-            cfDesc.putListPropertyType("column_metadata", RawColumnDefinition.class);
             TypeDescription seedDesc = new TypeDescription(SeedProviderDef.class);
             seedDesc.putMapPropertyType("parameters", String.class, String.class);
-            constructor.addTypeDescription(desc);
-            constructor.addTypeDescription(ksDesc);
-            constructor.addTypeDescription(cfDesc);
+            constructor.addTypeDescription(seedDesc);
             Yaml yaml = new Yaml(new Loader(constructor));
             conf = (Config)yaml.load(input);
             
@@ -463,10 +455,9 @@ public boolean accept(File pathname)
             }
             
             if (hasExistingTables)
-                logger.info("Found table data in data directories. Consider using JMX to call org.apache.cassandra.service.StorageService.loadSchemaFromYaml().");
+                logger.info("Found table data in data directories. Consider using the CLI to define your schema.");
             else
-                logger.info("Consider using JMX to org.apache.cassandra.service.StorageService.loadSchemaFromYaml() or set up a schema using the system_* calls provided via thrift.");
-            
+                logger.info("To create keyspaces and column families, see 'help create keyspace' in the CLI, or set up a schema using the thrift system_* calls.");
         }
         else
         {
@@ -499,174 +490,10 @@ public boolean accept(File pathname)
                 // set defsVersion so that migrations leading up to emptiness aren't replayed.
                 defsVersion = uuid;
             }
-            
-            // since we loaded definitions from local storage, log a warning if definitions exist in yaml.
-            if (conf.keyspaces != null && conf.keyspaces.size() > 0)
-                logger.warn("Schema definitions were defined both locally and in " + DEFAULT_CONFIGURATION +
-                    ". Definitions in " + DEFAULT_CONFIGURATION + " were ignored.");
-            
         }
         CFMetaData.fixMaxId();
     }
 
-    /** reads xml. doesn't populate any internal structures. */
-    public static Collection<KSMetaData> readTablesFromYaml() throws ConfigurationException
-    {
-        List<KSMetaData> defs = new ArrayList<KSMetaData>();
-        if (conf.keyspaces == null)
-            return defs;
-        
-        /* Read the table related stuff from config */
-        for (RawKeyspace keyspace : conf.keyspaces)
-        {
-            /* parsing out the table name */
-            if (keyspace.name == null)
-            {
-                throw new ConfigurationException("Keyspace name attribute is required");
-            }
-            
-            if (keyspace.name.equalsIgnoreCase(Table.SYSTEM_TABLE))
-            {
-                throw new ConfigurationException("'system' is a reserved table name for Cassandra internals");
-            }
-            
-            /* See which replica placement strategy to use */
-            if (keyspace.replica_placement_strategy == null)
-            {
-                throw new ConfigurationException("Missing replica_placement_strategy directive for " + keyspace.name);
-            }
-            String strategyClassName = KSMetaData.convertOldStrategyName(keyspace.replica_placement_strategy);
-            Class<AbstractReplicationStrategy> strategyClass = FBUtilities.classForName(strategyClassName, "replication-strategy");
-            
-            /* Data replication factor */
-            if (keyspace.replication_factor == null)
-            {
-                throw new ConfigurationException("Missing replication_factor directory for keyspace " + keyspace.name);
-            }
-            
-            int size2 = keyspace.column_families.length;
-            CFMetaData[] cfDefs = new CFMetaData[size2];
-            int j = 0;
-            for (RawColumnFamily cf : keyspace.column_families)
-            {
-                if (cf.name == null)
-                {
-                    throw new ConfigurationException("ColumnFamily name attribute is required");
-                }
-                if (!cf.name.matches(Migration.NAME_VALIDATOR_REGEX))
-                {
-                    throw new ConfigurationException("ColumnFamily name contains invalid characters.");
-                }
-                
-                // Parse out the column comparators and validators
-                AbstractType comparator = getComparator(cf.compare_with);
-                AbstractType subcolumnComparator = null;
-                AbstractType default_validator = getComparator(cf.default_validation_class);
-
-                ColumnFamilyType cfType = cf.column_type == null ? ColumnFamilyType.Standard : cf.column_type;
-                if (cfType == ColumnFamilyType.Super)
-                {
-                    subcolumnComparator = getComparator(cf.compare_subcolumns_with);
-                }
-                else if (cf.compare_subcolumns_with != null)
-                {
-                    throw new ConfigurationException("compare_subcolumns_with is only a valid attribute on super columnfamilies (not regular columnfamily " + cf.name + ")");
-                }
-
-                if (cf.read_repair_chance < 0.0 || cf.read_repair_chance > 1.0)
-                {                        
-                    throw new ConfigurationException("read_repair_chance must be between 0.0 and 1.0 (0% and 100%)");
-                }
-
-                if (conf.dynamic_snitch_badness_threshold < 0.0 || conf.dynamic_snitch_badness_threshold > 1.0)
-                {
-                    throw new ConfigurationException("dynamic_snitch_badness_threshold must be between 0.0 and 1.0 (0% and 100%)");
-                }
-                
-                if (cf.min_compaction_threshold < 0 || cf.max_compaction_threshold < 0)
-                {
-                    throw new ConfigurationException("min/max_compaction_thresholds must be positive integers.");
-                }
-                if ((cf.min_compaction_threshold > cf.max_compaction_threshold) && cf.max_compaction_threshold != 0)
-                {
-                    throw new ConfigurationException("min_compaction_threshold must be smaller than max_compaction_threshold, or either must be 0 (disabled)");
-                }
-
-                if (cf.memtable_throughput_in_mb == null)
-                {
-                    cf.memtable_throughput_in_mb = CFMetaData.sizeMemtableThroughput();
-                    logger.info("memtable_throughput_in_mb not configured for " + cf.name + ", using " + cf.memtable_throughput_in_mb);
-                }
-                if (cf.memtable_operations_in_millions == null)
-                {
-                    cf.memtable_operations_in_millions = CFMetaData.sizeMemtableOperations(cf.memtable_throughput_in_mb);
-                    logger.info("memtable_operations_in_millions not configured for " + cf.name + ", using " + cf.memtable_operations_in_millions);
-                }
-
-                if (cf.memtable_operations_in_millions != null && cf.memtable_operations_in_millions <= 0)
-                {
-                    throw new ConfigurationException("memtable_operations_in_millions must be a positive double");
-                }
-
-                if (cf.merge_shards_chance < 0.0 || cf.merge_shards_chance > 1.0)
-                {
-                    throw new ConfigurationException("merge_shards_chance must be between 0.0 and 1.0 (0% and 100%)");
-                }
-
-                 Map<ByteBuffer, ColumnDefinition> metadata = new TreeMap<ByteBuffer, ColumnDefinition>();
-
-                for (RawColumnDefinition rcd : cf.column_metadata)
-                {
-                    if (rcd.name == null)
-                    {
-                        throw new ConfigurationException("name is required for column definitions.");
-                    }
-                    if (rcd.validator_class == null)
-                    {
-                        throw new ConfigurationException("validator is required for column definitions");
-                    }
-                    
-                    if ((rcd.index_type == null) && (rcd.index_name != null))
-                    {
-                        throw new ConfigurationException("index_name cannot be set if index_type is not also set");
-                    }
-
-                    ByteBuffer columnName = ByteBuffer.wrap(rcd.name.getBytes(Charsets.UTF_8));
-                    metadata.put(columnName, new ColumnDefinition(columnName, rcd.validator_class, rcd.index_type, rcd.index_name));
-                }
-
-                cfDefs[j++] = new CFMetaData(keyspace.name, 
-                                             cf.name, 
-                                             cfType,
-                                             comparator, 
-                                             subcolumnComparator, 
-                                             cf.comment, 
-                                             cf.rows_cached,
-                                             cf.keys_cached, 
-                                             cf.read_repair_chance,
-                                             cf.replicate_on_write,
-                                             cf.gc_grace_seconds,
-                                             default_validator,
-                                             cf.min_compaction_threshold,
-                                             cf.max_compaction_threshold,
-                                             cf.row_cache_save_period_in_seconds,
-                                             cf.key_cache_save_period_in_seconds,
-                                             cf.memtable_flush_after_mins,
-                                             cf.memtable_throughput_in_mb,
-                                             cf.memtable_operations_in_millions,
-                                             cf.merge_shards_chance,
-                                             metadata);
-            }
-            defs.add(new KSMetaData(keyspace.name,
-                                    strategyClass,
-                                    keyspace.strategy_options,
-                                    keyspace.replication_factor,
-                                    cfDefs));
-        }
-
-        return defs;
-    }
-
     public static IAuthenticator getAuthenticator()
     {
         return authenticator;
@@ -983,12 +810,12 @@ public static String getDataFileLocationForTable(String table, long expectedComp
         return dataFileDirectory;
     }
     
-    public static AbstractType getComparator(String tableName, String cfName)
+    public static AbstractType getComparator(String ksName, String cfName)
     {
-        assert tableName != null;
-        CFMetaData cfmd = getCFMetaData(tableName, cfName);
+        assert ksName != null;
+        CFMetaData cfmd = getCFMetaData(ksName, cfName);
         if (cfmd == null)
-            throw new IllegalArgumentException("Unknown ColumnFamily " + cfName + " in keyspace " + tableName);
+            throw new IllegalArgumentException("Unknown ColumnFamily " + cfName + " in keyspace " + ksName);
         return cfmd.comparator;
     }
 
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/RawColumnDefinition.java b/cassandra/trunk/src/java/org/apache/cassandra/config/RawColumnDefinition.java
index ce5a9a17..e69de29b 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/RawColumnDefinition.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/RawColumnDefinition.java
@@ -1,32 +0,0 @@
-package org.apache.cassandra.config;
-/*
- * 
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- * 
- */
-
-
-import org.apache.cassandra.thrift.IndexType;
-
-public class RawColumnDefinition
-{
-    public String name;
-    public String validator_class;
-    public IndexType index_type;
-    public String index_name;
-}
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/RawColumnFamily.java b/cassandra/trunk/src/java/org/apache/cassandra/config/RawColumnFamily.java
index b764decb..e69de29b 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/RawColumnFamily.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/RawColumnFamily.java
@@ -1,51 +0,0 @@
-package org.apache.cassandra.config;
-/*
- * 
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- * 
- */
-
-
-import org.apache.cassandra.db.ColumnFamilyType;
-
-/**
- * @deprecated Yaml configuration for Keyspaces and ColumnFamilies is deprecated in 0.7
- */
-public class RawColumnFamily
-{
-    public String name;            
-    public ColumnFamilyType column_type;
-    public String compare_with;
-    public String compare_subcolumns_with;
-    public String comment;
-    public double rows_cached = CFMetaData.DEFAULT_ROW_CACHE_SIZE; 
-    public double keys_cached = CFMetaData.DEFAULT_KEY_CACHE_SIZE; 
-    public double read_repair_chance = CFMetaData.DEFAULT_READ_REPAIR_CHANCE;
-    public boolean replicate_on_write = CFMetaData.DEFAULT_REPLICATE_ON_WRITE;
-    public int gc_grace_seconds = CFMetaData.DEFAULT_GC_GRACE_SECONDS;
-    public String default_validation_class;
-    public int min_compaction_threshold = CFMetaData.DEFAULT_MIN_COMPACTION_THRESHOLD;
-    public int max_compaction_threshold = CFMetaData.DEFAULT_MAX_COMPACTION_THRESHOLD;
-    public RawColumnDefinition[] column_metadata = new RawColumnDefinition[0];
-    public int row_cache_save_period_in_seconds = CFMetaData.DEFAULT_ROW_CACHE_SAVE_PERIOD_IN_SECONDS;
-    public int key_cache_save_period_in_seconds = CFMetaData.DEFAULT_KEY_CACHE_SAVE_PERIOD_IN_SECONDS;
-    public int memtable_flush_after_mins = CFMetaData.DEFAULT_MEMTABLE_LIFETIME_IN_MINS;
-    public Integer memtable_throughput_in_mb;
-    public Double memtable_operations_in_millions;
-    public double merge_shards_chance = CFMetaData.DEFAULT_MERGE_SHARDS_CHANCE;
-}
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/RawKeyspace.java b/cassandra/trunk/src/java/org/apache/cassandra/config/RawKeyspace.java
index 2677b3df..e69de29b 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/RawKeyspace.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/RawKeyspace.java
@@ -1,36 +0,0 @@
-package org.apache.cassandra.config;
-/*
- * 
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- * 
- */
-
-
-import java.util.Map;
-
-/**
- * @deprecated Yaml configuration for Keyspaces and ColumnFamilies is deprecated in 0.7
- */
-public class RawKeyspace
-{
-    public String name;
-    public String replica_placement_strategy;
-    public Map<String,String> strategy_options;
-    public Integer replication_factor;
-    public RawColumnFamily[] column_families;
-}
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java b/cassandra/trunk/src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
index cccaf2d1..d11adf90 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/cql/CreateColumnFamilyStatement.java
@@ -179,7 +179,8 @@ public String getName()
             try
             {
                 ByteBuffer columnName = col.getKey().getByteBuffer(comparator);
-                String validator = comparators.containsKey(col.getValue()) ? comparators.get(col.getValue()) : col.getValue();
+                String validatorClassName = comparators.containsKey(col.getValue()) ? comparators.get(col.getValue()) : col.getValue();
+                AbstractType validator = DatabaseDescriptor.getComparator(validatorClassName);
                 columnDefs.put(columnName, new ColumnDefinition(columnName, validator, null, null));
             }
             catch (ConfigurationException e)
@@ -205,38 +206,41 @@ public CFMetaData getCFMetaData(String keyspace) throws InvalidRequestException
     {
         validate();
         
+        CFMetaData newCFMD;
         try
         {
             // RPC uses BytesType as the default validator/comparator but BytesType expects hex for string terms, (not convenient).
             AbstractType<?> comparator = DatabaseDescriptor.getComparator(comparators.get(getPropertyString(KW_COMPARATOR, "ascii")));
             String validator = getPropertyString(KW_DEFAULTVALIDATION, "ascii");
             
-            return new CFMetaData(keyspace,
+            newCFMD = new CFMetaData(keyspace,
                                   name,
-                                  ColumnFamilyType.create("Standard"),
+                                     ColumnFamilyType.Standard,
                                   comparator,
-                                  null,
-                                  properties.get(KW_COMMENT),
-                                  getPropertyDouble(KW_ROWCACHESIZE, CFMetaData.DEFAULT_ROW_CACHE_SIZE),
-                                  getPropertyDouble(KW_KEYCACHESIZE, CFMetaData.DEFAULT_KEY_CACHE_SIZE),
-                                  getPropertyDouble(KW_READREPAIRCHANCE, CFMetaData.DEFAULT_READ_REPAIR_CHANCE),
-                                  getPropertyBoolean(KW_REPLICATEONWRITE, false),
-                                  getPropertyInt(KW_GCGRACESECONDS, CFMetaData.DEFAULT_GC_GRACE_SECONDS),
-                                  DatabaseDescriptor.getComparator(comparators.get(validator)),
-                                  getPropertyInt(KW_MINCOMPACTIONTHRESHOLD, CFMetaData.DEFAULT_MIN_COMPACTION_THRESHOLD),
-                                  getPropertyInt(KW_MAXCOMPACTIONTHRESHOLD, CFMetaData.DEFAULT_MAX_COMPACTION_THRESHOLD),
-                                  getPropertyInt(KW_ROWCACHESAVEPERIODSECS, CFMetaData.DEFAULT_ROW_CACHE_SAVE_PERIOD_IN_SECONDS),
-                                  getPropertyInt(KW_KEYCACHESAVEPERIODSECS, CFMetaData.DEFAULT_KEY_CACHE_SAVE_PERIOD_IN_SECONDS),
-                                  getPropertyInt(KW_MEMTABLEFLUSHINMINS, CFMetaData.DEFAULT_MEMTABLE_LIFETIME_IN_MINS),
-                                  getPropertyInt(KW_MEMTABLESIZEINMB, CFMetaData.DEFAULT_MEMTABLE_THROUGHPUT_IN_MB),
-                                  getPropertyDouble(KW_MEMTABLEOPSINMILLIONS, CFMetaData.DEFAULT_MEMTABLE_OPERATIONS_IN_MILLIONS),
-                                  0,
-                                  getColumns(comparator));
+                                     null);
+
+            newCFMD.comment(properties.get(KW_COMMENT))
+                   .rowCacheSize(getPropertyDouble(KW_ROWCACHESIZE, CFMetaData.DEFAULT_ROW_CACHE_SIZE))
+                   .keyCacheSize(getPropertyDouble(KW_KEYCACHESIZE, CFMetaData.DEFAULT_KEY_CACHE_SIZE))
+                   .readRepairChance(getPropertyDouble(KW_READREPAIRCHANCE, CFMetaData.DEFAULT_READ_REPAIR_CHANCE))
+                   .replicateOnWrite(getPropertyBoolean(KW_REPLICATEONWRITE, CFMetaData.DEFAULT_REPLICATE_ON_WRITE))
+                   .gcGraceSeconds(getPropertyInt(KW_GCGRACESECONDS, CFMetaData.DEFAULT_GC_GRACE_SECONDS))
+                   .defaultValidator(DatabaseDescriptor.getComparator(comparators.get(validator)))
+                   .minCompactionThreshold(getPropertyInt(KW_MINCOMPACTIONTHRESHOLD, CFMetaData.DEFAULT_MIN_COMPACTION_THRESHOLD))
+                   .maxCompactionThreshold(getPropertyInt(KW_MAXCOMPACTIONTHRESHOLD, CFMetaData.DEFAULT_MAX_COMPACTION_THRESHOLD))
+                   .rowCacheSavePeriod(getPropertyInt(KW_ROWCACHESAVEPERIODSECS, CFMetaData.DEFAULT_ROW_CACHE_SAVE_PERIOD_IN_SECONDS))
+                   .keyCacheSavePeriod(getPropertyInt(KW_KEYCACHESAVEPERIODSECS, CFMetaData.DEFAULT_KEY_CACHE_SAVE_PERIOD_IN_SECONDS))
+                   .memTime(getPropertyInt(KW_MEMTABLEFLUSHINMINS, CFMetaData.DEFAULT_MEMTABLE_LIFETIME_IN_MINS))
+                   .memSize(getPropertyInt(KW_MEMTABLESIZEINMB, CFMetaData.DEFAULT_MEMTABLE_THROUGHPUT_IN_MB))
+                   .memOps(getPropertyDouble(KW_MEMTABLEOPSINMILLIONS, CFMetaData.DEFAULT_MEMTABLE_OPERATIONS_IN_MILLIONS))
+                   .mergeShardsChance(0.0)
+                   .columnMetadata(getColumns(comparator));
         }
         catch (ConfigurationException e)
         {
             throw new InvalidRequestException(e.toString());
         }
+        return newCFMD;
     }
     
     private String getPropertyString(String key, String defaultValue)
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/cql/QueryProcessor.java b/cassandra/trunk/src/java/org/apache/cassandra/cql/QueryProcessor.java
index 3088d107..23df404a 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/cql/QueryProcessor.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/cql/QueryProcessor.java
@@ -684,19 +684,11 @@ public static CqlResult process(String queryString, ClientState clientState)
                 // No meta-data, create a new column definition from scratch.
                 else
                 {
-                    try
-                    {
                         columnDef = new ColumnDefinition(columnName,
                                                          null,
                                                          org.apache.cassandra.thrift.IndexType.KEYS,
                                                          createIdx.getIndexName());
                     }
-                    catch (ConfigurationException e)
-                    {
-                        // This should never happen
-                        throw new RuntimeException("Unexpected error creating ColumnDefinition", e);
-                    }
-                }
                 
                 CfDef cfamilyDef = CFMetaData.convertToAvro(oldCfm);
                 cfamilyDef.column_metadata.add(columnDef.deflate());
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index f5eda9f8..868976bd 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -215,7 +215,7 @@ void removeIndex(ByteBuffer indexedColumn)
             return;
         }
         indexCfs.unregisterMBean();
-        SystemTable.setIndexRemoved(metadata.tableName, indexCfs.columnFamily);
+        SystemTable.setIndexRemoved(metadata.ksName, indexCfs.columnFamily);
         indexCfs.removeAllSSTables();
     }
 
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
index 92fdca9b..bf8f0bab 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/AddColumnFamily.java
@@ -41,14 +41,14 @@ public AddColumnFamily(CFMetaData cfm) throws ConfigurationException, IOExceptio
     {
         super(UUIDGen.makeType1UUIDFromHost(FBUtilities.getLocalAddress()), DatabaseDescriptor.getDefsVersion());
         this.cfm = cfm;
-        KSMetaData ksm = DatabaseDescriptor.getTableDefinition(cfm.tableName);
+        KSMetaData ksm = DatabaseDescriptor.getTableDefinition(cfm.ksName);
         
         if (ksm == null)
-            throw new ConfigurationException("No such keyspace: " + cfm.tableName);
+            throw new ConfigurationException("No such keyspace: " + cfm.ksName);
         else if (ksm.cfMetaData().containsKey(cfm.cfName))
             throw new ConfigurationException(String.format("%s already exists in keyspace %s",
                                                            cfm.cfName,
-                                                           cfm.tableName));
+                                                           cfm.ksName));
         else if (!Migration.isLegalName(cfm.cfName))
             throw new ConfigurationException("Invalid column family name: " + cfm.cfName);
         for (Map.Entry<ByteBuffer, ColumnDefinition> entry : cfm.getColumn_metadata().entrySet())
@@ -74,7 +74,7 @@ private KSMetaData makeNewKeyspaceDefinition(KSMetaData ksm)
     public void applyModels() throws IOException
     {
         // reinitialize the table.
-        KSMetaData ksm = DatabaseDescriptor.getTableDefinition(cfm.tableName);
+        KSMetaData ksm = DatabaseDescriptor.getTableDefinition(cfm.ksName);
         ksm = makeNewKeyspaceDefinition(ksm);
         try
         {
@@ -84,7 +84,7 @@ public void applyModels() throws IOException
         {
             throw new IOException(ex);
         }
-        Table.open(cfm.tableName); // make sure it's init-ed w/ the old definitions first, since we're going to call initCf on the new one manually
+        Table.open(cfm.ksName); // make sure it's init-ed w/ the old definitions first, since we're going to call initCf on the new one manually
         DatabaseDescriptor.setTableDefinition(ksm, newVersion);
         // these definitions could have come from somewhere else.
         CFMetaData.fixMaxId();
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/UpdateColumnFamily.java b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/UpdateColumnFamily.java
index a665f334..6e617513 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/UpdateColumnFamily.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/UpdateColumnFamily.java
@@ -1,8 +1,6 @@
 package org.apache.cassandra.db.migration;
 
 import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.util.Map;
 
 import org.apache.cassandra.config.*;
 import org.apache.cassandra.db.ColumnFamilyStore;
@@ -70,7 +68,7 @@ public void beforeApplyModels()
     {
         if (clientMode)
             return;
-        ColumnFamilyStore cfs = Table.open(metadata.tableName).getColumnFamilyStore(metadata.cfName);
+        ColumnFamilyStore cfs = Table.open(metadata.ksName).getColumnFamilyStore(metadata.cfName);
         cfs.snapshot(Table.getTimestampedSnapshotName(null));
     }
 
@@ -90,7 +88,7 @@ void applyModels() throws IOException
 
         if (!clientMode)
         {
-            Table table = Table.open(metadata.tableName);
+            Table table = Table.open(metadata.ksName);
             ColumnFamilyStore oldCfs = table.getColumnFamilyStore(metadata.cfName);
             oldCfs.reload();
         }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/service/StorageService.java b/cassandra/trunk/src/java/org/apache/cassandra/service/StorageService.java
index df912320..42fd07ba 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/service/StorageService.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/service/StorageService.java
@@ -2100,156 +2100,6 @@ public synchronized void drain() throws IOException, InterruptedException, Execu
         setMode("Node is drained", true);
     }
 
-    /**
-     * load schema from yaml. This can only be done on a fresh system.
-     * @throws ConfigurationException
-     * @throws IOException
-     */
-    public void loadSchemaFromYAML() throws ConfigurationException, IOException
-    { 
-        // validate
-        final Collection<KSMetaData> tables = DatabaseDescriptor.readTablesFromYaml();
-        if (tables.isEmpty())
-            return;
-
-        for (KSMetaData table : tables)
-        {
-            if (!table.name.matches(Migration.NAME_VALIDATOR_REGEX))
-                throw new ConfigurationException("Invalid table name: " + table.name);
-            for (CFMetaData cfm : table.cfMetaData().values())
-                if (!Migration.isLegalName(cfm.cfName))
-                    throw new ConfigurationException("Invalid column family name: " + cfm.cfName);
-        }
-        
-        Callable<Migration> call = new Callable<Migration>()
-        {
-            public Migration call() throws Exception
-            {
-                // blow up if there is a schema saved.
-                if (DatabaseDescriptor.getDefsVersion().timestamp() > 0 || Migration.getLastMigrationId() != null)
-                    throw new ConfigurationException("Cannot import schema when one already exists");
-             
-                Migration migration = null;
-                for (KSMetaData table : tables)
-                {
-                    migration = new AddKeyspace(table); 
-                    migration.apply();
-                }
-                return migration;
-            }
-        };
-        Migration migration;
-        try
-        {
-            migration = StageManager.getStage(Stage.MIGRATION).submit(call).get();
-        }
-        catch (InterruptedException e)
-        {
-            throw new RuntimeException(e);
-        }
-        catch (ExecutionException e)
-        {
-            if (e.getCause() instanceof ConfigurationException)
-                throw (ConfigurationException)e.getCause();
-            else if (e.getCause() instanceof IOException)
-                throw (IOException)e.getCause();
-            else if (e.getCause() instanceof Exception)
-                throw new ConfigurationException(e.getCause().getMessage(), (Exception)e.getCause());
-            else
-                throw new RuntimeException(e);
-        }
-        
-        assert DatabaseDescriptor.getDefsVersion().timestamp() > 0;
-        DefsTable.dumpToStorage(DatabaseDescriptor.getDefsVersion());
-        // flush system and definition tables.
-        Collection<Future> flushers = new ArrayList<Future>();
-        flushers.addAll(Table.open(Table.SYSTEM_TABLE).flush());
-        for (Future f : flushers)
-        {
-            try
-            {
-                f.get();
-            }
-            catch (Exception e)
-            {
-                ConfigurationException ce = new ConfigurationException(e.getMessage());
-                ce.initCause(e);
-                throw ce;
-            }
-        }
-        
-        // we don't want to announce after every Migration.apply(). keep track of the last one and then announce the
-        // current version.
-        if (migration != null)
-            migration.announce();
-        
-    }
-
-    public String exportSchema() throws IOException
-    {
-        List<RawKeyspace> keyspaces = new ArrayList<RawKeyspace>();
-        for (String ksname : DatabaseDescriptor.getNonSystemTables())
-        {
-            KSMetaData ksm = DatabaseDescriptor.getTableDefinition(ksname);
-            RawKeyspace rks = new RawKeyspace();
-            rks.name = ksm.name;
-            rks.replica_placement_strategy = ksm.strategyClass.getName();
-            rks.replication_factor = ksm.replicationFactor;
-            rks.column_families = new RawColumnFamily[ksm.cfMetaData().size()];
-            int i = 0;
-            for (CFMetaData cfm : ksm.cfMetaData().values())
-            {
-                RawColumnFamily rcf = new RawColumnFamily();
-                rcf.name = cfm.cfName;
-                rcf.compare_with = cfm.comparator.getClass().getName();
-                rcf.default_validation_class = cfm.getDefaultValidator().getClass().getName();
-                rcf.compare_subcolumns_with = cfm.subcolumnComparator == null ? null : cfm.subcolumnComparator.getClass().getName();
-                rcf.column_type = cfm.cfType;
-                rcf.comment = cfm.getComment();
-                rcf.keys_cached = cfm.getKeyCacheSize();
-                rcf.read_repair_chance = cfm.getReadRepairChance();
-                rcf.replicate_on_write = cfm.getReplicateOnWrite();
-                rcf.gc_grace_seconds = cfm.getGcGraceSeconds();
-                rcf.rows_cached = cfm.getRowCacheSize();
-                rcf.column_metadata = new RawColumnDefinition[cfm.getColumn_metadata().size()];
-                int j = 0;
-                for (ColumnDefinition cd : cfm.getColumn_metadata().values())
-                {
-                    RawColumnDefinition rcd = new RawColumnDefinition();
-                    rcd.index_name = cd.getIndexName();
-                    rcd.index_type = cd.getIndexType();
-                    rcd.name = ByteBufferUtil.string(cd.name, Charsets.UTF_8);
-                    rcd.validator_class = cd.validator.getClass().getName();
-                    rcf.column_metadata[j++] = rcd;
-                }
-                if (j == 0)
-                    rcf.column_metadata = null;
-                rks.column_families[i++] = rcf;
-            }
-            // whew.
-            keyspaces.add(rks);
-        }
-        
-        DumperOptions options = new DumperOptions();
-        /* Use a block YAML arrangement */
-        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
-        SkipNullRepresenter representer = new SkipNullRepresenter();
-        /* Use Tag.MAP to avoid the class name being included as global tag */
-        representer.addClassTag(RawColumnFamily.class, Tag.MAP);
-        representer.addClassTag(Keyspaces.class, Tag.MAP);
-        representer.addClassTag(ColumnDefinition.class, Tag.MAP);
-        Dumper dumper = new Dumper(representer, options);
-        Yaml yaml = new Yaml(dumper);
-        Keyspaces ks = new Keyspaces();
-        ks.keyspaces = keyspaces;
-        return yaml.dump(ks);
-    }
-    
-    public class Keyspaces
-    {
-        public List<RawKeyspace> keyspaces;
-    }
-    
     // Never ever do this at home. Used by tests.
     IPartitioner setPartitionerUnsafe(IPartitioner newPartitioner)
     {
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/service/StorageServiceMBean.java b/cassandra/trunk/src/java/org/apache/cassandra/service/StorageServiceMBean.java
index c01b46f3..c37969b2 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/service/StorageServiceMBean.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/service/StorageServiceMBean.java
@@ -237,18 +237,6 @@
     /** makes node unavailable for writes, flushes memtables and replays commitlog. */
     public void drain() throws IOException, InterruptedException, ExecutionException;
 
-    /**
-     * Introduced in 0.7 to allow nodes to load their existing yaml defined schemas.
-     * @todo: deprecate in 0.7+1, remove in 0.7+2.
-     */ 
-    public void loadSchemaFromYAML() throws ConfigurationException, IOException;
-
-    /**
-     * Introduced in 0.7 to allow schema yaml to be exported.
-     * @todo: deprecate in 0.7+1, remove in 0.7+2.
-     */
-    public String exportSchema() throws IOException;
-
     /**
      * Truncates (deletes) the given columnFamily from the provided keyspace.
      * Calling truncate results in actual deletion of all data in the cluster
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java b/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
index f4f1893a..5f6fef08 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
@@ -922,27 +922,29 @@ private CFMetaData convertToCFMetaData(CfDef cf_def) throws InvalidRequestExcept
         CFMetaData.validateMinMaxCompactionThresholds(cf_def);
         CFMetaData.validateMemtableSettings(cf_def);
 
-        return new CFMetaData(cf_def.keyspace,
+        CFMetaData newCFMD = new CFMetaData(cf_def.keyspace,
                               cf_def.name,
                               cfType,
                               DatabaseDescriptor.getComparator(cf_def.comparator_type),
-                              cf_def.subcomparator_type == null ? null : DatabaseDescriptor.getComparator(cf_def.subcomparator_type),
-                              cf_def.comment,
-                              cf_def.row_cache_size,
-                              cf_def.key_cache_size,
-                              cf_def.read_repair_chance,
-                              cf_def.replicate_on_write,
-                              cf_def.isSetGc_grace_seconds() ? cf_def.gc_grace_seconds : CFMetaData.DEFAULT_GC_GRACE_SECONDS,
-                              DatabaseDescriptor.getComparator(cf_def.default_validation_class),
-                              cf_def.isSetMin_compaction_threshold() ? cf_def.min_compaction_threshold : CFMetaData.DEFAULT_MIN_COMPACTION_THRESHOLD,
-                              cf_def.isSetMax_compaction_threshold() ? cf_def.max_compaction_threshold : CFMetaData.DEFAULT_MAX_COMPACTION_THRESHOLD,
-                              cf_def.isSetRow_cache_save_period_in_seconds() ? cf_def.row_cache_save_period_in_seconds : CFMetaData.DEFAULT_ROW_CACHE_SAVE_PERIOD_IN_SECONDS,
-                              cf_def.isSetKey_cache_save_period_in_seconds() ? cf_def.key_cache_save_period_in_seconds : CFMetaData.DEFAULT_KEY_CACHE_SAVE_PERIOD_IN_SECONDS,
-                              cf_def.isSetMemtable_flush_after_mins() ? cf_def.memtable_flush_after_mins : CFMetaData.DEFAULT_MEMTABLE_LIFETIME_IN_MINS,
-                              cf_def.isSetMemtable_throughput_in_mb() ? cf_def.memtable_throughput_in_mb : CFMetaData.DEFAULT_MEMTABLE_THROUGHPUT_IN_MB,
-                              cf_def.isSetMemtable_operations_in_millions() ? cf_def.memtable_operations_in_millions : CFMetaData.DEFAULT_MEMTABLE_OPERATIONS_IN_MILLIONS,
-                              cf_def.isSetMerge_shards_chance() ? cf_def.merge_shards_chance : CFMetaData.DEFAULT_MERGE_SHARDS_CHANCE,
-                              ColumnDefinition.fromColumnDef(cf_def.column_metadata));
+                                            cf_def.subcomparator_type == null ? null : DatabaseDescriptor.getComparator(cf_def.subcomparator_type));
+
+        if (cf_def.isSetGc_grace_seconds()) { newCFMD.gcGraceSeconds(cf_def.gc_grace_seconds); }
+        if (cf_def.isSetMin_compaction_threshold()) { newCFMD.minCompactionThreshold(cf_def.min_compaction_threshold); }
+        if (cf_def.isSetMax_compaction_threshold()) { newCFMD.maxCompactionThreshold(cf_def.max_compaction_threshold); }
+        if (cf_def.isSetRow_cache_save_period_in_seconds()) { newCFMD.rowCacheSavePeriod(cf_def.row_cache_save_period_in_seconds); }
+        if (cf_def.isSetKey_cache_save_period_in_seconds()) { newCFMD.keyCacheSavePeriod(cf_def.key_cache_save_period_in_seconds); }
+        if (cf_def.isSetMemtable_flush_after_mins()) { newCFMD.memTime(cf_def.memtable_flush_after_mins); }
+        if (cf_def.isSetMemtable_throughput_in_mb()) { newCFMD.memSize(cf_def.memtable_throughput_in_mb); }
+        if (cf_def.isSetMemtable_operations_in_millions()) { newCFMD.memOps(cf_def.memtable_operations_in_millions); }
+        if (cf_def.isSetMerge_shards_chance()) { newCFMD.mergeShardsChance(cf_def.merge_shards_chance); }
+
+        return newCFMD.comment(cf_def.comment)
+                      .rowCacheSize(cf_def.row_cache_size)
+                      .keyCacheSize(cf_def.key_cache_size)
+                      .readRepairChance(cf_def.read_repair_chance)
+                      .replicateOnWrite(cf_def.replicate_on_write)
+                      .defaultValidator(DatabaseDescriptor.getComparator(cf_def.default_validation_class))
+                      .columnMetadata(ColumnDefinition.fromColumnDef(cf_def.column_metadata));
     }
 
     public void truncate(String cfname) throws InvalidRequestException, UnavailableException, TException
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeProbe.java b/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeProbe.java
index ee899dac..8f216670 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeProbe.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeProbe.java
@@ -491,17 +491,6 @@ public void truncate(String tableName, String cfName)
         }
     }
     
-    @Deprecated
-    public void loadSchemaFromYAML() throws ConfigurationException, IOException
-    {
-        ssProxy.loadSchemaFromYAML();
-    }
-    
-    public String exportSchemaToYAML() throws IOException
-    {
-        return ssProxy.exportSchema();
-    }
-
     public MessagingServiceMBean getMsProxy()
     {
         try
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/tools/SchemaTool.java b/cassandra/trunk/src/java/org/apache/cassandra/tools/SchemaTool.java
index 853fc51a..e69de29b 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/tools/SchemaTool.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/tools/SchemaTool.java
@@ -1,61 +0,0 @@
-package org.apache.cassandra.tools;
-/*
- * 
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- * 
- */
-
-import java.io.IOException;
-
-import org.apache.cassandra.config.ConfigurationException;
-
-public class SchemaTool
-{
-    public static void main(String[] args)
-    throws NumberFormatException, IOException, InterruptedException, ConfigurationException
-    {
-        if (args.length < 3 || args.length > 3)
-            usage();
-        
-        String host = args[0];
-        int port = 0;
-        
-        try
-        {
-            port = Integer.parseInt(args[1]);
-        }
-        catch (NumberFormatException e)
-        {
-            System.err.println("Port must be a number.");
-            System.exit(1);
-        }
-        
-        if ("import".equals(args[2]))
-            new NodeProbe(host, port).loadSchemaFromYAML();
-        else if ("export".equals(args[2]))
-            System.out.println(new NodeProbe(host, port).exportSchemaToYAML());
-        else
-            usage();
-    }
-    
-    private static void usage()
-    {
-        System.err.printf("java %s <host> <port> import|export%n", SchemaTool.class.getName());
-        System.exit(1);
-    }
-}
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/SchemaLoader.java b/cassandra/trunk/test/unit/org/apache/cassandra/SchemaLoader.java
index efe67397..ad45bcfd 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/SchemaLoader.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/SchemaLoader.java
@@ -18,22 +18,30 @@
 
 package org.apache.cassandra;
 
-import org.apache.cassandra.config.CFMetaData;
-import org.apache.cassandra.config.ConfigurationException;
-import org.apache.cassandra.config.DatabaseDescriptor;
-import org.apache.cassandra.config.KSMetaData;
+import java.nio.ByteBuffer;
+import java.util.*;
+
+import org.apache.commons.lang.NotImplementedException;
+
+import com.google.common.base.Charsets;
+import org.apache.cassandra.config.*;
+import org.apache.cassandra.db.ColumnFamilyType;
+import org.apache.cassandra.db.KeyspaceNotDefinedException;
+import org.apache.cassandra.db.marshal.*;
+import org.apache.cassandra.locator.AbstractReplicationStrategy;
+import org.apache.cassandra.locator.SimpleStrategy;
+import org.apache.cassandra.thrift.IndexType;
+
 import org.junit.BeforeClass;
 
 public class SchemaLoader
 {
-    // todo: when xml is fully deprecated, this method should be changed to manually load a few table definitions into
-    // the definitions keyspace.
     @BeforeClass
-    public static void loadSchemaFromYaml()
+    public static void loadSchema()
     {
         try
         {
-            for (KSMetaData ksm : DatabaseDescriptor.readTablesFromYaml())
+            for (KSMetaData ksm : schemaDefinition())
             {
                 for (CFMetaData cfm : ksm.cfMetaData().values())
                     CFMetaData.map(cfm);
@@ -45,4 +53,170 @@ public static void loadSchemaFromYaml()
             throw new RuntimeException(e);
         }
     }
+
+    public static Collection<KSMetaData> schemaDefinition()
+    {
+        List<KSMetaData> schema = new ArrayList<KSMetaData>();
+
+        // A whole bucket of shorthand
+        String ks1 = "Keyspace1";
+        String ks2 = "Keyspace2";
+        String ks3 = "Keyspace3";
+        String ks4 = "Keyspace4";
+        String ks5 = "Keyspace5";
+        String ks_kcs = "KeyCacheSpace";
+        String ks_rcs = "RowCacheSpace";
+
+        Class<? extends AbstractReplicationStrategy> simple = SimpleStrategy.class;
+        Map<String, String> no_opts = Collections.<String, String>emptyMap();
+        int rep_factor1 = 1;
+        int rep_factor2 = 2;
+        int rep_factor3 = 3;
+        int rep_factor5 = 5;
+
+        ColumnFamilyType st = ColumnFamilyType.Standard;
+        ColumnFamilyType su = ColumnFamilyType.Super;
+        AbstractType bytes = BytesType.instance;
+
+        // Keyspace 1
+        schema.add(new KSMetaData(ks1,
+                                  simple,
+                                  no_opts,
+                                  rep_factor1,
+
+                                  // Column Families
+                                  standardCFMD(ks1, "Standard1"),
+                                  standardCFMD(ks1, "Standard2"),
+                                  standardCFMD(ks1, "Standard3"),
+                                  standardCFMD(ks1, "Standard4"),
+                                  standardCFMD(ks1, "StandardLong1"),
+                                  standardCFMD(ks1, "StandardLong2"),
+                                  superCFMD(ks1, "Super1", LongType.instance),
+                                  superCFMD(ks1, "Super2", LongType.instance),
+                                  superCFMD(ks1, "Super3", LongType.instance),
+                                  superCFMD(ks1, "Super4", UTF8Type.instance),
+                                  superCFMD(ks1, "Super5", bytes),
+                                  indexCFMD(ks1, "Indexed1", true),
+                                  indexCFMD(ks1, "Indexed2", false),
+                                  new CFMetaData(ks1,
+                                                 "StandardInteger1",
+                                                 st,
+                                                 IntegerType.instance,
+                                                 null)
+                                                 .keyCacheSize(0),
+                                  new CFMetaData(ks1,
+                                                 "Counter1",
+                                                 st,
+                                                 bytes,
+                                                 null)
+                                                 .defaultValidator(CounterColumnType.instance),
+                                  new CFMetaData(ks1,
+                                                 "SuperCounter1",
+                                                 su,
+                                                 bytes,
+                                                 bytes)
+                                                 .defaultValidator(CounterColumnType.instance),
+                                  jdbcCFMD(ks1, "JdbcInteger", IntegerType.instance),
+                                  jdbcCFMD(ks1, "JdbcUtf8", UTF8Type.instance),
+                                  jdbcCFMD(ks1, "JdbcLong", LongType.instance),
+                                  jdbcCFMD(ks1, "JdbcBytes", bytes),
+                                  jdbcCFMD(ks1, "JdbcAscii", AsciiType.instance)));
+
+        // Keyspace 2
+        schema.add(new KSMetaData(ks2,
+                                  simple,
+                                  no_opts,
+                                  rep_factor1,
+
+                                  // Column Families
+                                  standardCFMD(ks2, "Standard1"),
+                                  standardCFMD(ks2, "Standard3"),
+                                  superCFMD(ks2, "Super3", bytes),
+                                  superCFMD(ks2, "Super4", TimeUUIDType.instance),
+                                  indexCFMD(ks2, "Indexed1", true)));
+
+        // Keyspace 3
+        schema.add(new KSMetaData(ks3,
+                                  simple,
+                                  no_opts,
+                                  rep_factor5,
+
+                                  // Column Families
+                                  standardCFMD(ks3, "Standard1"),
+                                  indexCFMD(ks3, "Indexed1", true)));
+
+        // Keyspace 4
+        schema.add(new KSMetaData(ks4,
+                                  simple,
+                                  no_opts,
+                                  rep_factor3,
+
+                                  // Column Families
+                                  standardCFMD(ks4, "Standard1"),
+                                  standardCFMD(ks4, "Standard3"),
+                                  superCFMD(ks4, "Super3", bytes),
+                                  superCFMD(ks4, "Super4", TimeUUIDType.instance),
+                                  new CFMetaData(ks4,
+                                                 "Super5",
+                                                 su,
+                                                 TimeUUIDType.instance,
+                                                 bytes)
+                                                 .keyCacheSize(0)));
+
+        // Keyspace 5
+        schema.add(new KSMetaData(ks5,
+                                  simple,
+                                  no_opts,
+                                  rep_factor2,
+
+                                  // Column Families
+                                  standardCFMD(ks5, "Standard1"),
+                                  standardCFMD(ks5, "Counter1")
+                                               .defaultValidator(CounterColumnType.instance)));
+
+        // KeyCacheSpace
+        schema.add(new KSMetaData(ks_kcs,
+                                  simple,
+                                  no_opts,
+                                  rep_factor1,
+                                  standardCFMD(ks_kcs, "Standard1")
+                                              .keyCacheSize(0.5),
+                                  standardCFMD(ks_kcs, "Standard2")
+                                              .keyCacheSize(1.0)));
+
+        // RowCacheSpace
+        schema.add(new KSMetaData(ks_rcs,
+                                  simple,
+                                  no_opts,
+                                  rep_factor1,
+                                  standardCFMD(ks_rcs, "CFWithoutCache"),
+                                  standardCFMD(ks_rcs, "CachedCF")
+                                              .rowCacheSize(100)));
+
+        return schema;
+    }
+
+    private static CFMetaData standardCFMD(String ksName, String cfName)
+    {
+        return new CFMetaData(ksName, cfName, ColumnFamilyType.Standard, BytesType.instance, null).keyCacheSize(0);
+    }
+    private static CFMetaData superCFMD(String ksName, String cfName, AbstractType subcc)
+    {
+        return new CFMetaData(ksName, cfName, ColumnFamilyType.Super, BytesType.instance, subcc).keyCacheSize(0);
+    }
+    private static CFMetaData indexCFMD(String ksName, String cfName, final Boolean withIdxType)
+    {
+        return standardCFMD(ksName, cfName)
+                .columnMetadata(Collections.unmodifiableMap(new HashMap<ByteBuffer, ColumnDefinition>()
+                    {{
+                        ByteBuffer cName = ByteBuffer.wrap("birthdate".getBytes(Charsets.UTF_8));
+                        IndexType keys = withIdxType ? IndexType.KEYS : null;
+                        put(cName,
+                            new ColumnDefinition(cName, LongType.instance, keys, null));
+                    }}));
+    }
+    private static CFMetaData jdbcCFMD(String ksName, String cfName, AbstractType comp)
+    {
+        return new CFMetaData(ksName, cfName, ColumnFamilyType.Standard, comp, comp);
+    }
 }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/config/ColumnDefinitionTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/config/ColumnDefinitionTest.java
index d16dbbfd..fafa2134 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/config/ColumnDefinitionTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/config/ColumnDefinitionTest.java
@@ -21,8 +21,10 @@
  */
 
 
-import java.nio.ByteBuffer;
 import org.junit.Test;
+
+import org.apache.cassandra.db.marshal.BytesType;
+import org.apache.cassandra.db.marshal.LongType;
 import org.apache.cassandra.thrift.IndexType;
 import org.apache.cassandra.utils.ByteBufferUtil;
 
@@ -32,12 +34,12 @@
     public void testSerializeDeserialize() throws Exception
     {
         ColumnDefinition cd0 = new ColumnDefinition(ByteBufferUtil.bytes("TestColumnDefinitionName0"),
-                                                    "BytesType",
+                                                    BytesType.instance,
                                                     IndexType.KEYS,
                                                     "random index name 0");
 
         ColumnDefinition cd1 = new ColumnDefinition(ByteBufferUtil.bytes("TestColumnDefinition1"),
-                                                    "LongType",
+                                                    LongType.instance,
                                                     null,
                                                     null);
 
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
index 395d9821..7f12e1e2 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
@@ -314,7 +314,7 @@ public void testIndexCreate() throws IOException, ConfigurationException, Interr
 
         ColumnFamilyStore cfs = table.getColumnFamilyStore("Indexed2");
         ColumnDefinition old = cfs.metadata.getColumn_metadata().get(ByteBufferUtil.bytes("birthdate"));
-        ColumnDefinition cd = new ColumnDefinition(old.name, old.validator.getClass().getName(), IndexType.KEYS, "birthdate_index");
+        ColumnDefinition cd = new ColumnDefinition(old.name, old.validator, IndexType.KEYS, "birthdate_index");
         Future<?> future = cfs.addIndex(cd);
         future.get();
         // we had a bug (CASSANDRA-2244) where index would get created but not flushed -- check for that
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
index d519ad19..42ce6d75 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
@@ -22,8 +22,7 @@
 import java.io.DataInputStream;
 import java.io.IOException;
 import java.nio.ByteBuffer;
-import java.util.Arrays;
-import java.util.TreeMap;
+import java.util.*;
 
 import org.apache.cassandra.SchemaLoader;
 import org.junit.Test;
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
index 9bcd493e..db010434 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
@@ -25,7 +25,6 @@
 import java.nio.ByteBuffer;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -102,29 +101,30 @@ public void testCFMetaDataApply() throws ConfigurationException
         for (int i = 0; i < 5; i++) 
         {
             ByteBuffer name = ByteBuffer.wrap(new byte[] { (byte)i });
-            indexes.put(name, new ColumnDefinition(name, null, IndexType.KEYS, Integer.toString(i)));
+            indexes.put(name, new ColumnDefinition(name, BytesType.instance, IndexType.KEYS, Integer.toString(i)));
         }
         CFMetaData cfm = new CFMetaData("Keyspace1",
                 "TestApplyCFM_CF",
                 ColumnFamilyType.Standard,
                 BytesType.instance,
-                null,
-                "No comment",
-                1.0,
-                1.0,
-                0.5,
-                false,
-                100000,
-                null,
-                500,
-                500,
-                500,
-                500,
-                500,
-                500,
-                500.0,
-                0,
-                indexes);
+                                        null);
+
+        cfm.comment("No comment")
+           .rowCacheSize(1.0)
+           .keyCacheSize(1.0)
+           .readRepairChance(0.5)
+           .replicateOnWrite(false)
+           .gcGraceSeconds(100000)
+           .defaultValidator(null)
+           .minCompactionThreshold(500)
+           .maxCompactionThreshold(500)
+           .rowCacheSavePeriod(500)
+           .keyCacheSavePeriod(500)
+           .memTime(500)
+           .memSize(500)
+           .memOps(500.0)
+           .mergeShardsChance(0.0)
+           .columnMetadata(indexes);
         
         // we'll be adding this one later. make sure it's not already there.
         assert cfm.getColumn_metadata().get(ByteBuffer.wrap(new byte[] { 5 })) == null;
@@ -300,11 +300,11 @@ public void dropCf() throws ConfigurationException, IOException, ExecutionExcept
         for (int i = 0; i < 100; i++)
             rm.add(new QueryPath(cfm.cfName, null, ByteBuffer.wrap(("col" + i).getBytes())), ByteBufferUtil.bytes("anyvalue"), 1L);
         rm.apply();
-        ColumnFamilyStore store = Table.open(cfm.tableName).getColumnFamilyStore(cfm.cfName);
+        ColumnFamilyStore store = Table.open(cfm.ksName).getColumnFamilyStore(cfm.cfName);
         assert store != null;
         store.forceBlockingFlush();
         store.getFlushPath();
-        assert DefsTable.getFiles(cfm.tableName, cfm.cfName).size() > 0;
+        assert DefsTable.getFiles(cfm.ksName, cfm.cfName).size() > 0;
         
         new DropColumnFamily(ks.name, cfm.cfName).apply();
         
@@ -325,7 +325,7 @@ public void dropCf() throws ConfigurationException, IOException, ExecutionExcept
         assert !success : "This mutation should have failed since the CF no longer exists.";
 
         // verify that the files are gone.
-        for (File file : DefsTable.getFiles(cfm.tableName, cfm.cfName))
+        for (File file : DefsTable.getFiles(cfm.ksName, cfm.cfName))
         {
             if (file.getPath().endsWith("Data.db") && !new File(file.getPath().replace("Data.db", "Compacted")).exists())
                 throw new AssertionError("undeleted file " + file);
@@ -346,23 +346,23 @@ public void renameCf() throws ConfigurationException, IOException, ExecutionExce
         for (int i = 0; i < 100; i++)
             rm.add(new QueryPath(oldCfm.cfName, null, ByteBuffer.wrap(("col" + i).getBytes())), ByteBufferUtil.bytes("anyvalue"), 1L);
         rm.apply();
-        ColumnFamilyStore store = Table.open(oldCfm.tableName).getColumnFamilyStore(oldCfm.cfName);
+        ColumnFamilyStore store = Table.open(oldCfm.ksName).getColumnFamilyStore(oldCfm.cfName);
         assert store != null;
         store.forceBlockingFlush();
-        int fileCount = DefsTable.getFiles(oldCfm.tableName, oldCfm.cfName).size();
+        int fileCount = DefsTable.getFiles(oldCfm.ksName, oldCfm.cfName).size();
         assert fileCount > 0;
         
         final String cfName = "St4ndard1Replacement";
-        new RenameColumnFamily(oldCfm.tableName, oldCfm.cfName, cfName).apply();
+        new RenameColumnFamily(oldCfm.ksName, oldCfm.cfName, cfName).apply();
         
         assert !DatabaseDescriptor.getTableDefinition(ks.name).cfMetaData().containsKey(oldCfm.cfName);
         assert DatabaseDescriptor.getTableDefinition(ks.name).cfMetaData().containsKey(cfName);
         
         // verify that new files are there.
-        assert DefsTable.getFiles(oldCfm.tableName, cfName).size() == fileCount;
+        assert DefsTable.getFiles(oldCfm.ksName, cfName).size() == fileCount;
         
         // do some reads.
-        store = Table.open(oldCfm.tableName).getColumnFamilyStore(cfName);
+        store = Table.open(oldCfm.ksName).getColumnFamilyStore(cfName);
         assert store != null;
         ColumnFamily cfam = store.getColumnFamily(QueryFilter.getSliceFilter(dk, new QueryPath(cfName), ByteBufferUtil.EMPTY_BYTE_BUFFER, ByteBufferUtil.EMPTY_BYTE_BUFFER, false, 1000));
         assert cfam.getSortedColumns().size() == 100; // should be good enough?
@@ -384,18 +384,18 @@ public void addNewKS() throws ConfigurationException, IOException, ExecutionExce
         DecoratedKey dk = Util.dk("key0");
         CFMetaData newCf = addTestCF("NewKeyspace1", "AddedStandard1", "A new cf for a new ks");
 
-        KSMetaData newKs = new KSMetaData(newCf.tableName, SimpleStrategy.class, null, 5, newCf);
+        KSMetaData newKs = new KSMetaData(newCf.ksName, SimpleStrategy.class, null, 5, newCf);
         
         new AddKeyspace(newKs).apply();
         
-        assert DatabaseDescriptor.getTableDefinition(newCf.tableName) != null;
-        assert DatabaseDescriptor.getTableDefinition(newCf.tableName) == newKs;
+        assert DatabaseDescriptor.getTableDefinition(newCf.ksName) != null;
+        assert DatabaseDescriptor.getTableDefinition(newCf.ksName) == newKs;
 
         // test reads and writes.
-        RowMutation rm = new RowMutation(newCf.tableName, dk.key);
+        RowMutation rm = new RowMutation(newCf.ksName, dk.key);
         rm.add(new QueryPath(newCf.cfName, null, ByteBufferUtil.bytes("col0")), ByteBufferUtil.bytes("value0"), 1L);
         rm.apply();
-        ColumnFamilyStore store = Table.open(newCf.tableName).getColumnFamilyStore(newCf.cfName);
+        ColumnFamilyStore store = Table.open(newCf.ksName).getColumnFamilyStore(newCf.cfName);
         assert store != null;
         store.forceBlockingFlush();
         
@@ -420,10 +420,10 @@ public void dropKS() throws ConfigurationException, IOException, ExecutionExcept
         for (int i = 0; i < 100; i++)
             rm.add(new QueryPath(cfm.cfName, null, ByteBuffer.wrap(("col" + i).getBytes())), ByteBufferUtil.bytes("anyvalue"), 1L);
         rm.apply();
-        ColumnFamilyStore store = Table.open(cfm.tableName).getColumnFamilyStore(cfm.cfName);
+        ColumnFamilyStore store = Table.open(cfm.ksName).getColumnFamilyStore(cfm.cfName);
         assert store != null;
         store.forceBlockingFlush();
-        assert DefsTable.getFiles(cfm.tableName, cfm.cfName).size() > 0;
+        assert DefsTable.getFiles(cfm.ksName, cfm.cfName).size() > 0;
         
         new DropKeyspace(ks.name).apply();
         
@@ -464,7 +464,7 @@ public void renameKs() throws ConfigurationException, IOException, ExecutionExce
         assert oldKs != null;
         final String cfName = "Standard3";
         assert oldKs.cfMetaData().containsKey(cfName);
-        assert oldKs.cfMetaData().get(cfName).tableName.equals(oldKs.name);
+        assert oldKs.cfMetaData().get(cfName).ksName.equals(oldKs.name);
         
         // write some data that we hope to read back later.
         RowMutation rm = new RowMutation(oldKs.name, dk.key);
@@ -484,7 +484,7 @@ public void renameKs() throws ConfigurationException, IOException, ExecutionExce
         assert newKs != null;
         assert newKs.name.equals(newKsName);
         assert newKs.cfMetaData().containsKey(cfName);
-        assert newKs.cfMetaData().get(cfName).tableName.equals(newKsName);
+        assert newKs.cfMetaData().get(cfName).ksName.equals(newKsName);
         assert DefsTable.getFiles(newKs.name, cfName).size() > 0;
         
         // read on old should fail.
@@ -578,16 +578,16 @@ public void testUpdateKeyspace() throws ConfigurationException, IOException, Exe
     {
         // create a keyspace to serve as existing.
         CFMetaData cf = addTestCF("UpdatedKeyspace", "AddedStandard1", "A new cf for a new ks");
-        KSMetaData oldKs = new KSMetaData(cf.tableName, SimpleStrategy.class, null, 5, cf);
+        KSMetaData oldKs = new KSMetaData(cf.ksName, SimpleStrategy.class, null, 5, cf);
         
         new AddKeyspace(oldKs).apply();
         
-        assert DatabaseDescriptor.getTableDefinition(cf.tableName) != null;
-        assert DatabaseDescriptor.getTableDefinition(cf.tableName) == oldKs;
+        assert DatabaseDescriptor.getTableDefinition(cf.ksName) != null;
+        assert DatabaseDescriptor.getTableDefinition(cf.ksName) == oldKs;
         
         // anything with cf defs should fail.
-        CFMetaData cf2 = addTestCF(cf.tableName, "AddedStandard2", "A new cf for a new ks");
-        KSMetaData newBadKs = new KSMetaData(cf.tableName, SimpleStrategy.class, null, 4, cf2);
+        CFMetaData cf2 = addTestCF(cf.ksName, "AddedStandard2", "A new cf for a new ks");
+        KSMetaData newBadKs = new KSMetaData(cf.ksName, SimpleStrategy.class, null, 4, cf2);
         try
         {
             new UpdateKeyspace(newBadKs).apply();
@@ -599,7 +599,7 @@ public void testUpdateKeyspace() throws ConfigurationException, IOException, Exe
         }
         
         // names should match.
-        KSMetaData newBadKs2 = new KSMetaData(cf.tableName + "trash", SimpleStrategy.class, null, 4);
+        KSMetaData newBadKs2 = new KSMetaData(cf.ksName + "trash", SimpleStrategy.class, null, 4);
         try
         {
             new UpdateKeyspace(newBadKs2).apply();
@@ -610,7 +610,7 @@ public void testUpdateKeyspace() throws ConfigurationException, IOException, Exe
             // expected.
         }
         
-        KSMetaData newKs = new KSMetaData(cf.tableName, OldNetworkTopologyStrategy.class, null, 1);
+        KSMetaData newKs = new KSMetaData(cf.ksName, OldNetworkTopologyStrategy.class, null, 1);
         new UpdateKeyspace(newKs).apply();
         
         KSMetaData newFetchedKs = DatabaseDescriptor.getKSMetaData(newKs.name);
@@ -625,12 +625,12 @@ public void testUpdateColumnFamilyNoIndexes() throws ConfigurationException, IOE
     {
         // create a keyspace with a cf to update.
         CFMetaData cf = addTestCF("UpdatedCfKs", "Standard1added", "A new cf that will be updated");
-        KSMetaData ksm = new KSMetaData(cf.tableName, SimpleStrategy.class, null, 1, cf);
+        KSMetaData ksm = new KSMetaData(cf.ksName, SimpleStrategy.class, null, 1, cf);
         new AddKeyspace(ksm).apply();
         
-        assert DatabaseDescriptor.getTableDefinition(cf.tableName) != null;
-        assert DatabaseDescriptor.getTableDefinition(cf.tableName) == ksm;
-        assert DatabaseDescriptor.getCFMetaData(cf.tableName, cf.cfName) != null;
+        assert DatabaseDescriptor.getTableDefinition(cf.ksName) != null;
+        assert DatabaseDescriptor.getTableDefinition(cf.ksName) == ksm;
+        assert DatabaseDescriptor.getCFMetaData(cf.ksName, cf.cfName) != null;
         
         // updating certain fields should fail.
         org.apache.cassandra.db.migration.avro.CfDef cf_def = CFMetaData.convertToAvro(cf);
@@ -668,12 +668,12 @@ public void testUpdateColumnFamilyNoIndexes() throws ConfigurationException, IOE
         // can't test changing the reconciler because there is only one impl.
         
         // check the cumulative affect.
-        assert DatabaseDescriptor.getCFMetaData(cf.tableName, cf.cfName).getComment().equals(cf_def.comment);
-        assert DatabaseDescriptor.getCFMetaData(cf.tableName, cf.cfName).getRowCacheSize() == cf_def.row_cache_size;
-        assert DatabaseDescriptor.getCFMetaData(cf.tableName, cf.cfName).getKeyCacheSize() == cf_def.key_cache_size;
-        assert DatabaseDescriptor.getCFMetaData(cf.tableName, cf.cfName).getReadRepairChance() == cf_def.read_repair_chance;
-        assert DatabaseDescriptor.getCFMetaData(cf.tableName, cf.cfName).getGcGraceSeconds() == cf_def.gc_grace_seconds;
-        assert DatabaseDescriptor.getCFMetaData(cf.tableName, cf.cfName).getDefaultValidator() == UTF8Type.instance;
+        assert DatabaseDescriptor.getCFMetaData(cf.ksName, cf.cfName).getComment().equals(cf_def.comment);
+        assert DatabaseDescriptor.getCFMetaData(cf.ksName, cf.cfName).getRowCacheSize() == cf_def.row_cache_size;
+        assert DatabaseDescriptor.getCFMetaData(cf.ksName, cf.cfName).getKeyCacheSize() == cf_def.key_cache_size;
+        assert DatabaseDescriptor.getCFMetaData(cf.ksName, cf.cfName).getReadRepairChance() == cf_def.read_repair_chance;
+        assert DatabaseDescriptor.getCFMetaData(cf.ksName, cf.cfName).getGcGraceSeconds() == cf_def.gc_grace_seconds;
+        assert DatabaseDescriptor.getCFMetaData(cf.ksName, cf.cfName).getDefaultValidator() == UTF8Type.instance;
         
         // todo: we probably don't need to reset old values in the catches anymore.
         // make sure some invalid operations fail.
@@ -761,26 +761,12 @@ public void testUpdateColumnFamilyNoIndexes() throws ConfigurationException, IOE
 
     private CFMetaData addTestCF(String ks, String cf, String comment)
     {
-        return new CFMetaData(ks,
-                              cf,
-                              ColumnFamilyType.Standard,
-                              UTF8Type.instance,
-                              null,
-                              comment,
-                              0,
-                              1.0,
-                              0,
-							  false,
-                              CFMetaData.DEFAULT_GC_GRACE_SECONDS,
-                              BytesType.instance,
-                              CFMetaData.DEFAULT_MIN_COMPACTION_THRESHOLD,
-                              CFMetaData.DEFAULT_MAX_COMPACTION_THRESHOLD,
-                              CFMetaData.DEFAULT_ROW_CACHE_SAVE_PERIOD_IN_SECONDS,
-                              CFMetaData.DEFAULT_KEY_CACHE_SAVE_PERIOD_IN_SECONDS,
-                              CFMetaData.DEFAULT_MEMTABLE_LIFETIME_IN_MINS,
-                              CFMetaData.DEFAULT_MEMTABLE_THROUGHPUT_IN_MB,
-                              CFMetaData.DEFAULT_MEMTABLE_OPERATIONS_IN_MILLIONS,
-                              0,
-                              Collections.<ByteBuffer, ColumnDefinition>emptyMap());
+        CFMetaData newCFMD = new CFMetaData(ks, cf, ColumnFamilyType.Standard, UTF8Type.instance, null);
+        newCFMD.comment(comment)
+               .keyCacheSize(1.0)
+               .readRepairChance(0.0)
+               .mergeShardsChance(0.0);
+
+        return newCFMD;
     }
 }
