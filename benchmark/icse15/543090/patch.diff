diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/ExceptionFormatter.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/ExceptionFormatter.java
index 958e4e95..8ffe4b8c 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/ExceptionFormatter.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/ExceptionFormatter.java
@@ -157,7 +157,6 @@ static public void printTrace(Sqlca sqlca,
             printWriter.println(header + " SqlCode        = " + sqlca.getSqlCode());
             printWriter.println(header + " SqlErrd        = " + Utils.getStringFromInts(sqlca.getSqlErrd()));
             printWriter.println(header + " SqlErrmc       = " + sqlca.getSqlErrmc());
-            printWriter.println(header + " SqlErrmcTokens = " + Utils.getStringFromStrings(sqlca.getSqlErrmcTokens()));
             printWriter.println(header + " SqlErrp        = " + sqlca.getSqlErrp());
             printWriter.println(header + " SqlState       = " + sqlca.getSqlState());
             printWriter.println(header + " SqlWarn        = " + new String(sqlca.getSqlWarn()));
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/SqlException.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/SqlException.java
index d205e322..19883c7f 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/SqlException.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/SqlException.java
@@ -75,6 +75,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 public class SqlException extends Exception implements Diagnosable {
     protected static final int DEFAULT_ERRCODE = 99999;
     protected transient Sqlca sqlca_ = null; // for engine generated errors only
+    /** Tells which of the messages in the SQLCA this exception refers to
+     * (counting from 0). For engine generated errors only. */
+    private transient int messageNumber_;
     protected String message_ = null;
     protected String cachedMessage_ = null;
     private String batchPositionLabel_; // for batched exceptions only
@@ -252,14 +255,43 @@ public SqlException(LogWriter logwriter,
         this(logwriter, msgid, new Object[] { arg1, arg2, arg3 });
     }
     
+    /**
+     * Create an exception for an engine generated error.
+     *
+     * @param logWriter object used for tracing
+     * @param sqlca the SQLCA sent from the server
+     */
     public SqlException(LogWriter logWriter, Sqlca sqlca) {
-        this.sqlca_ = sqlca;
+        this(sqlca, 0, true);
+        // only set the error code for the first exception in the chain (we
+        // don't know the error code for the rest)
+        errorcode_ = sqlca.getSqlCode();
         if ( logWriter != null )
         {
             logWriter.traceDiagnosable(this);
         }
     }
     
+    /**
+     * Create one of the exceptions in an exception chain generated by the
+     * engine. This constructor calls itself recursively to create the rest of
+     * the exception chain if <code>chain</code> is <code>true</code>.
+     *
+     * @param sqlca the SQLCA sent from the server
+     * @param number the message number for this exception (counting from 0)
+     * @param chain if <code>true</code>, generate the rest of the exception
+     * chain recursively and link it to this exception
+     */
+    private SqlException(Sqlca sqlca, int number, boolean chain) {
+        this.sqlca_ = sqlca;
+        messageNumber_ = number;
+        sqlstate_ = sqlca.getSqlState(number);
+        int nextMsg = number + 1;
+        if (chain && (sqlca.numberOfMessages() > nextMsg)) {
+            setThrowable(new SqlException(sqlca, nextMsg, true));
+        }
+    }
+    
     // Once all messages are internationalized, these methods should become
     // private
     protected SqlException(LogWriter logWriter, String reason, String sqlState,
@@ -398,7 +430,8 @@ public String getMessage() {
         // the connection and JDBC not being retrievable (hence why it is
         // being cached here).
         if (sqlca_ != null) {
-            cachedMessage_ = message_ = ((Sqlca) sqlca_).getJDBCMessage();
+            cachedMessage_ = message_ =
+                    ((Sqlca) sqlca_).getJDBCMessage(messageNumber_);
         }
         else if (cachedMessage_ != null) {
             // SQLCA is no longer valid, set the message to the previously
@@ -425,11 +458,7 @@ public String getSQLState() {
             return wrappedException_.getSQLState();
         }
         
-        if (sqlca_ == null) {
             return sqlstate_;
-        } else {
-            return sqlca_.getSqlState();
-        }
     }
 
     public int getErrorCode() {
@@ -438,11 +467,7 @@ public int getErrorCode() {
             return wrappedException_.getErrorCode();
         }
         
-        if (sqlca_ == null) {
             return errorcode_;
-        } else {
-            return sqlca_.getSqlCode();
-        }
     }
 
     public SqlException getNextException()
@@ -505,7 +530,8 @@ public static SqlException javaException(LogWriter logWriter, Throwable e) {
     // we have to create a new SqlException in order to break the chain with "next" as null.
     SqlException copyAsUnchainedSQLException(LogWriter logWriter) {
         if (sqlca_ != null) {
-            return new SqlException(logWriter, sqlca_); // server error
+            // server error
+            return new SqlException(sqlca_, messageNumber_, false);
         } else {
             return new SqlException(logWriter, getMessage(), getSQLState(), getErrorCode()); // client error
         }
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Sqlca.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Sqlca.java
index c656953d..e69130d8 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/Sqlca.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/Sqlca.java
@@ -31,8 +31,12 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
     // data corresponding to SQLCA fields
     protected int sqlCode_;        // SQLCODE
-    private String sqlErrmc_;       // A string with all error tokens delimited by sqlErrmcDelimiter
-    protected String[] sqlErrmcTokens_; // A string array with each element
+    /** A string representation of <code>sqlErrmcBytes_</code>. */
+    private String sqlErrmc_;
+    /** Array of errmc strings for each message in the chain. */
+    protected String[] sqlErrmcMessages_;
+    /** SQL states for all the messages in the exception chain. */
+    private String[] sqlStates_;
     // contain an error token
     protected String sqlErrp_;        // function name issuing error
     protected int[] sqlErrd_;        // 6 diagnostic Information
@@ -48,15 +52,20 @@ Licensed to the Apache Software Foundation (ASF) under one or more
     protected boolean containsSqlcax_ = true;
     protected long rowsetRowCount_;
 
-    //public static final String sqlErrmcDelimiter = "\u00FF";
-    private static final String sqlErrmcDelimiter__ = ";";
+    /**
+     * Character sequence that separates the different messages in the errmc.
+     * @see org.apache.derby.catalog.SystemProcedures#SQLERRMC_MESSAGE_DELIMITER
+     */
+    private static final String sqlErrmcDelimiter__ = "\u0014\u0014\u0014";
 
     // JDK stack trace calls e.getMessage(), so we must set some state on the sqlca that says return tokens only.
     private boolean returnTokensOnlyInMessageText_ = false;
 
     transient private final Agent agent_;
 
-    private String cachedMessage;
+    /** Cached error messages (to prevent multiple invocations of the stored
+     * procedure to get the same message). */
+    private String[] cachedMessages;
 
     protected Sqlca(org.apache.derby.client.am.Connection connection) {
         connection_ = connection;
@@ -67,6 +76,21 @@ void returnTokensOnlyInMessageText(boolean returnTokensOnlyInMessageText) {
         returnTokensOnlyInMessageText_ = returnTokensOnlyInMessageText;
     }
 
+    /**
+     * Returns the number of messages this SQLCA contains.
+     *
+     * @return number of messages
+     */
+    synchronized int numberOfMessages() {
+        initSqlErrmcMessages();
+        if (sqlErrmcMessages_ != null) {
+            return sqlErrmcMessages_.length;
+        }
+        // even if we don't have an array of errmc messages, we are able to get
+        // one message out of this sqlca (although it's not very readable)
+        return 1;
+    }
+
     synchronized public int getSqlCode() {
         return sqlCode_;
     }
@@ -76,19 +100,18 @@ synchronized public String getSqlErrmc() {
             return sqlErrmc_;
         }
 
-        // sqlErrmc string is dependent on sqlErrmcTokens array having been built
-        if (sqlErrmcTokens_ == null) {
-            getSqlErrmcTokens();
-        }
+        // sqlErrmc string is dependent on sqlErrmcMessages_ array having
+        // been built
+        initSqlErrmcMessages();
 
-        // sqlErrmc will be build only if sqlErrmcTokens has been build.
+        // sqlErrmc will be built only if sqlErrmcMessages_ has been built.
         // Otherwise, a null string will be returned.
-        if (sqlErrmcTokens_ == null) {
+        if (sqlErrmcMessages_ == null) {
             return null;
         }
 
         // create 0-length String if no tokens
-        if (sqlErrmcTokens_.length == 0) {
+        if (sqlErrmcMessages_.length == 0) {
             sqlErrmc_ = "";
             return sqlErrmc_;
         }
@@ -96,26 +119,32 @@ synchronized public String getSqlErrmc() {
         // concatenate tokens with sqlErrmcDelimiter delimiters into one String
         StringBuffer buffer = new StringBuffer();
         int indx;
-        for (indx = 0; indx < sqlErrmcTokens_.length - 1; indx++) {
-            buffer.append(sqlErrmcTokens_[indx]);
+        for (indx = 0; indx < sqlErrmcMessages_.length - 1; indx++) {
+            buffer.append(sqlErrmcMessages_[indx]);
             buffer.append(sqlErrmcDelimiter__);
+            // all but the first message should be preceded by the SQL state
+            // and a colon (see DRDAConnThread.buildTokenizedSqlerrmc() on the
+            // server)
+            buffer.append(sqlStates_[indx+1]);
+            buffer.append(":");
         }
         // add the last token
-        buffer.append(sqlErrmcTokens_[indx]);
+        buffer.append(sqlErrmcMessages_[indx]);
 
         // save as a string
         sqlErrmc_ = buffer.toString();
         return sqlErrmc_;
     }
 
-    synchronized public String[] getSqlErrmcTokens() {
-        if (sqlErrmcTokens_ != null) {
-            return sqlErrmcTokens_;
-        }
-
+    /**
+     * Initialize and build the arrays <code>sqlErrmcMessages_</code> and
+     * <code>sqlStates_</code>.
+     */
+    private void initSqlErrmcMessages() {
+        if (sqlErrmcMessages_ == null || sqlStates_ == null) {
         // processSqlErrmcTokens handles null sqlErrmcBytes_ case
-        sqlErrmcTokens_ = processSqlErrmcTokens(sqlErrmcBytes_);
-        return sqlErrmcTokens_;
+            processSqlErrmcTokens(sqlErrmcBytes_);
+        }
     }
 
     synchronized public String getSqlErrp() {
@@ -169,15 +198,29 @@ synchronized public String getSqlState() {
         return sqlState_;
     }
 
+    /**
+     * Get the SQL state for a given error.
+     *
+     * @param messageNumber the error to retrieve SQL state for
+     * @return SQL state for the error
+     */
+    synchronized String getSqlState(int messageNumber) {
+        initSqlErrmcMessages();
+        if (sqlStates_ != null) {
+            return sqlStates_[messageNumber];
+        }
+        return getSqlState();
+    }
+
     // Gets the formatted message, can throw an exception.
-    synchronized public String getMessage() throws SqlException {
+    private String getMessage(int messageNumber) throws SqlException {
         // should this be traced to see if we are calling a stored proc?
-        if (cachedMessage != null) {
-            return cachedMessage;
+        if (cachedMessages != null && cachedMessages[messageNumber] != null) {
+            return cachedMessages[messageNumber];
         }
 
         if (connection_ == null || connection_.isClosedX() || returnTokensOnlyInMessageText_) {
-            return getUnformattedMessage();
+            return getUnformattedMessage(messageNumber);
         }
 
         CallableStatement cs = null;
@@ -185,12 +228,20 @@ synchronized public String getMessage() throws SqlException {
             try {
                 cs = connection_.prepareMessageProc("call SYSIBM.SQLCAMESSAGE(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)");
 
+                String errmc = null;
+                String sqlState = null;
+
+                if (sqlErrmcMessages_ != null) {
+                    errmc = sqlErrmcMessages_[messageNumber];
+                    sqlState = sqlStates_[messageNumber];
+                }
+
                 // SQLCode: SQL return code.
-                cs.setIntX(1, getSqlCode());
+                cs.setIntX(1, (messageNumber == 0) ? getSqlCode() : 0);
                 // SQLErrml: Length of SQL error message tokens.
-                cs.setShortX(2, (short) ((getSqlErrmc() != null) ? getSqlErrmc().length() : 0));
-                // SQLErrmc: SQL error message tokens as a String (delimited by semicolon ";").
-                cs.setStringX(3, getSqlErrmc());
+                cs.setShortX(2, (short) ((errmc == null) ? 0 : errmc.length()));
+                // SQLErrmc: SQL error message tokens as a String
+                cs.setStringX(3, errmc);
                 // SQLErrp: Product signature.
                 cs.setStringX(4, getSqlErrp());
                 // SQLErrd: SQL internal error code.
@@ -203,7 +254,7 @@ synchronized public String getMessage() throws SqlException {
                 // SQLWarn: SQL warning flags.
                 cs.setStringX(11, new String(getSqlWarn()));
                 // SQLState: standard SQL state.
-                cs.setStringX(12, getSqlState());
+                cs.setStringX(12, sqlState);
                 // MessageFileName: Not used by our driver, so set to null.
                 cs.setStringX(13, null);
                 // Locale: language preference requested for the return error message.
@@ -220,12 +271,15 @@ synchronized public String getMessage() throws SqlException {
                     // Return the message text.
                     messageTextRetrievedContainsTokensOnly_ = false;
                     String message = cs.getStringX(15);
-                    cachedMessage = message;
+                    if (cachedMessages == null) {
+                        cachedMessages = new String[numberOfMessages()];
+                    }
+                    cachedMessages[messageNumber] = message;
                     return message;
                 } else {
                     // Stored procedure can't return a valid message text, so we return
                     // unformated exception
-                    return getUnformattedMessage();
+                    return getUnformattedMessage(messageNumber);
                 }
             } finally {
                 if (cs != null) {
@@ -239,24 +293,46 @@ synchronized public String getMessage() throws SqlException {
     }
 
     // May or may not get the formatted message depending upon datasource directives.  cannot throw exeption.
-    public synchronized String getJDBCMessage() {
+    synchronized String getJDBCMessage(int messageNumber) {
         // The transient connection_ member will only be null if the Sqlca has been deserialized
         if (connection_ != null && connection_.retrieveMessageText_) {
             try {
-                return getMessage();
+                return getMessage(messageNumber);
             } catch (SqlException e) {
                 // Invocation of stored procedure fails, so we return error message tokens directly.
                 exceptionThrownOnStoredProcInvocation_ = e;
                 chainDeferredExceptionsToAgentOrAsConnectionWarnings((SqlException) e);
-                return getUnformattedMessage();
+                return getUnformattedMessage(messageNumber);
             }
         } else {
-            return getUnformattedMessage();
+            return getUnformattedMessage(messageNumber);
         }
     }
 
-    private String getUnformattedMessage() {
-        return "DERBY SQL error: SQLCODE: " + getSqlCode() + ", SQLSTATE: " + getSqlState() + ", SQLERRMC: " + getSqlErrmc();
+    /**
+     * Get the unformatted message text (in case we cannot ask the server).
+     *
+     * @param messageNumber which message number to get the text for
+     * @return string with details about the error
+     */
+    private String getUnformattedMessage(int messageNumber) {
+        int sqlCode;
+        String sqlState;
+        String sqlErrmc;
+        if (messageNumber == 0) {
+            // if the first exception in the chain is requested, return all the
+            // information we have
+            sqlCode = getSqlCode();
+            sqlState = getSqlState();
+            sqlErrmc = getSqlErrmc();
+        } else {
+            // otherwise, return information about the specified error only
+            sqlCode = 0;
+            sqlState = sqlStates_[messageNumber];
+            sqlErrmc = sqlErrmcMessages_[messageNumber];
+        }
+        return "DERBY SQL error: SQLCODE: " + sqlCode + ", SQLSTATE: " +
+            sqlState + ", SQLERRMC: " + sqlErrmc;
     }
 
     private void chainDeferredExceptionsToAgentOrAsConnectionWarnings(SqlException e) {
@@ -291,68 +367,36 @@ public boolean includesSqlCode(int[] codes) {
     }
     // ------------------- helper methods ----------------------------------------
 
-    private String[] processSqlErrmcTokens(byte[] tokenBytes) {
+    private void processSqlErrmcTokens(byte[] tokenBytes) {
         if (tokenBytes == null) {
-            return null;
+            return;
         }
 
         // create 0-length String tokens array if tokenBytes is 0-length
         int length = tokenBytes.length;
         if (length == 0) {
-            return new String[0];
+            sqlStates_ = sqlErrmcMessages_ = new String[0];
+            return;
         }
 
         try {
             // tokenize and convert tokenBytes
-            java.io.ByteArrayOutputStream buffer = new java.io.ByteArrayOutputStream();
-            java.util.LinkedList tokens = new java.util.LinkedList();
-
-            // parse the error message tokens
-            for (int index = 0; index < length - 1; index++) {
-
-                // non-delimiter - continue to write into buffer
-                if (tokenBytes[index] != -1)  // -1 is the delimiter '\xFF'
-                {
-                    buffer.write(tokenBytes[index]);
-                }
-
-                // delimiter - convert current token and add to list
-                else {
-                    tokens.add(bytes2String(buffer.toByteArray(), 0, buffer.size()));
-                    buffer.reset();
-                }
-            }
-
-            int lastIndex = length - 1;
-            // check for last byte not being a delimiter, i.e. part of last token
-            if (tokenBytes[lastIndex] != -1) {
-                // write the last byte
-                buffer.write(tokenBytes[lastIndex]);
-                // convert the last token and add to list
-                tokens.add(bytes2String(buffer.toByteArray(), 0, buffer.size()));
-            }
-
-            // last byte is delimiter implying an empty String for last token
-            else {
-                // convert current token, if one exists, and add to list
-                if (lastIndex != 0) {
-                    tokens.add(bytes2String(buffer.toByteArray(), 0, buffer.size()));
+            String fullString = bytes2String(tokenBytes, 0, length);
+            String[] tokens = fullString.split("\\u0014{3}");
+            String[] states = new String[tokens.length];
+            states[0] = getSqlState();
+            for (int i = 1; i < tokens.length; i++) {
+                // All but the first message are preceded by the SQL state
+                // (five characters) and a colon. Extract the SQL state and
+                // clean up the token. See
+                // DRDAConnThread.buildTokenizedSqlerrmc() for more details.
+                states[i] = tokens[i].substring(0, 5);
+                tokens[i] = tokens[i].substring(6);
                 }
-                // last token is an empty String
-                tokens.add("");
-            }
-
-            // create the String array and fill it with tokens.
-            String[] tokenStrings = new String[tokens.size()];
-
-            java.util.Iterator iterator = tokens.iterator();
-            for (int i = 0; iterator.hasNext(); i++) {
-                tokenStrings[i] = (String) iterator.next();
-            }
-
-            return tokenStrings;
+            sqlStates_ = states;
+            sqlErrmcMessages_ = tokens;
         } catch (java.io.UnsupportedEncodingException e) {
-            return null;
+            /* do nothing, the arrays continue to be null */
         }
     }
 
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ProcedureInTriggerTest.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ProcedureInTriggerTest.java
index d3ed153c..3e049c83 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ProcedureInTriggerTest.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/ProcedureInTriggerTest.java
@@ -237,8 +237,6 @@ public void testModifiesSql() throws SQLException {
         } catch (SQLException se) {
             assertSQLState("38000", se);
             se = se.getNextException();
-            // Client does not get chained exceptions
-            if (usingEmbedded())
                 assertSQLState("38001", se);           
         }
         //--- check trigger is not fired.
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/junit/BaseJDBCTestCase.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/junit/BaseJDBCTestCase.java
index c3e49fce..79848a55 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/junit/BaseJDBCTestCase.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/junit/BaseJDBCTestCase.java
@@ -566,20 +566,7 @@ public static void assertSQLState(String message,
                 // Some VMs don't support initCause(). It is OK if they fail.
             }
 
-            if (usingDerbyNetClient())
-            {
-                /* For chained exceptions the Derby Client just concatenates
-                 * them into the exception message.  So search the message
-                 * for the desired SQLSTATE.  This isn't ideal, but it
-                 * should work...
-                 */
-                if (exception.getMessage().
-                    indexOf("SQLSTATE: " + expected) == -1)
-                {
-                    throw e;
-                }
-            }
-            else if (usingDerbyNet())
+            if (usingDerbyNet())
             {
                 /* For JCC the error message is a series of tokens representing
                  * different things like SQLSTATE, SQLCODE, nested SQL error
