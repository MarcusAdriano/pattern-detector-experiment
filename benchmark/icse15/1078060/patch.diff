diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/Activator.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/Activator.java
index 26cdb712..0e1b9e2c 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/Activator.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/Activator.java
@@ -24,7 +24,7 @@
 import org.apache.aries.subsystem.SubsystemAdmin;
 import org.apache.aries.subsystem.SubsystemConstants;
 import org.apache.aries.subsystem.SubsystemException;
-import org.apache.aries.subsystem.scope.ScopeAdmin;
+import org.apache.aries.subsystem.scope.Scope;
 import org.apache.aries.subsystem.spi.ResourceProcessor;
 import org.apache.aries.subsystem.spi.ResourceResolver;
 import org.osgi.framework.Bundle;
@@ -116,7 +116,7 @@ public static SubsystemEventDispatcher getEventDispatcher() {
         //private final List<ScopeAdmin> scopeAdmins = new ArrayList<ScopeAdmin>();
         private final List<SubsystemAdmin> admins = new ArrayList<SubsystemAdmin>();
         private final Map<SubsystemAdmin, Long> references = new HashMap<SubsystemAdmin, Long>();
-        private ScopeAdmin scopeAdmin; // scope admin for the root scope.
+        private Scope scopeAdmin; // scope admin for the root scope.
         private static ServiceTracker serviceTracker;
         private SubsystemAdmin defaultAdmin;
         private ServiceRegistration rootAdminReg;
@@ -124,11 +124,10 @@ public static SubsystemEventDispatcher getEventDispatcher() {
         public SubsystemAdminFactory() throws InvalidSyntaxException  {
             context = Activator.getBundleContext();
             
-            ServiceReference[] reference = Activator.getBundleContext().getServiceReferences(ScopeAdmin.class.getName(), 
-            "(&(ScopeName=root))");
-            if (reference != null && reference.length == 1) {
-                ScopeAdmin scopeAdmin = (ScopeAdmin)Activator.getBundleContext().getService(reference[0]);
-                Subsystem subsystem = new SubsystemImpl(scopeAdmin.getScope(), new HashMap<String, String>());
+            ServiceReference reference = Activator.getBundleContext().getServiceReference(Scope.class.getName());
+            if (reference != null) {
+                Scope scopeAdmin = (Scope)Activator.getBundleContext().getService(reference);
+                Subsystem subsystem = new SubsystemImpl(scopeAdmin, new HashMap<String, String>());
                 defaultAdmin = new SubsystemAdminImpl(scopeAdmin, subsystem, null);
                 rootAdminReg = context.registerService(SubsystemAdmin.class.getName(), 
                         defaultAdmin, 
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResourceProcessor.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResourceProcessor.java
index d708d38f..808393ac 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResourceProcessor.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/BundleResourceProcessor.java
@@ -18,15 +18,14 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import java.util.Map.Entry;
+import java.util.Set;
 
 import org.apache.aries.subsystem.SubsystemAdmin;
 import org.apache.aries.subsystem.SubsystemConstants;
 import org.apache.aries.subsystem.SubsystemException;
 import org.apache.aries.subsystem.scope.InstallInfo;
 import org.apache.aries.subsystem.scope.Scope;
-import org.apache.aries.subsystem.scope.ScopeAdmin;
 import org.apache.aries.subsystem.scope.ScopeUpdate;
 import org.apache.aries.subsystem.spi.Resource;
 import org.apache.aries.subsystem.spi.ResourceProcessor;
@@ -42,7 +41,7 @@ public Session createSession(SubsystemAdmin subsystemAdmin) {
 
     public static class BundleSession implements Session {
 
-        private final ScopeAdmin scopeAdmin;
+        private final Scope scopeAdmin;
         private final List<Bundle> installed = new ArrayList<Bundle>();
         private final Map<Resource, Bundle> updated = new HashMap<Resource, Bundle>();
         private final Map<Resource, Bundle> removed = new HashMap<Resource, Bundle>();
@@ -60,7 +59,7 @@ public void process(Resource resource) throws SubsystemException {
                 
                 if (bundle == null) {
                     // fresh install 
-                    InstallInfo installInfo = new InstallInfo(new URL(resource.getLocation()), resource.getLocation());
+                    InstallInfo installInfo = new InstallInfo(resource.getLocation(), new URL(resource.getLocation()));
                     ScopeUpdate scopeUpdate = scopeAdmin.newScopeUpdate();
                     scopeUpdate.getBundlesToInstall().add(installInfo);
                     scopeUpdate.commit();
@@ -138,7 +137,7 @@ public void rollback() {
                     Bundle bundle = entry.getValue();
                     Resource res = entry.getKey();
                     try {
-                        InstallInfo installInfo = new InstallInfo(res.open(), res.getLocation());
+                        InstallInfo installInfo = new InstallInfo(res.getLocation(), res.open());
                         ScopeUpdate scopeUpdate = scopeAdmin.newScopeUpdate();
                         scopeUpdate.getBundlesToInstall().add(installInfo);
                         scopeUpdate.commit();
@@ -152,7 +151,7 @@ public void rollback() {
         }
         
         protected Bundle findBundle(Resource resource) {
-            Scope scope = scopeAdmin.getScope();
+            Scope scope = scopeAdmin;
             for (Bundle b : scope.getBundles()) {
                 if (resource.getLocation().equals(scope.getLocation())) {
                     return b;
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemAdminImpl.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemAdminImpl.java
index 9d45c950..fe92f2db 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemAdminImpl.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemAdminImpl.java
@@ -28,7 +28,7 @@
 import org.apache.aries.subsystem.SubsystemEvent;
 import org.apache.aries.subsystem.SubsystemException;
 import org.apache.aries.subsystem.SubsystemListener;
-import org.apache.aries.subsystem.scope.ScopeAdmin;
+import org.apache.aries.subsystem.scope.Scope;
 import org.apache.aries.subsystem.spi.Resource;
 import org.apache.aries.subsystem.spi.ResourceResolver;
 import org.osgi.framework.BundleContext;
@@ -44,7 +44,7 @@
     private static final Version SUBSYSTEM_MANIFEST_VERSION = new Version("1.0");
 
     final BundleContext context;
-    final ScopeAdmin scopeAdmin;
+    final Scope scopeAdmin;
     final Map<Long, Subsystem> subsystems = new HashMap<Long, Subsystem>();
     final ServiceTracker resourceResolverTracker;
     final SubsystemEventDispatcher eventDispatcher;
@@ -52,7 +52,7 @@
     final Subsystem subsystem;
     final Subsystem parentSubsystem;
     
-    public SubsystemAdminImpl(ScopeAdmin scopeAdmin, Subsystem subsystem, Subsystem parentSubsystem) {
+    public SubsystemAdminImpl(Scope scopeAdmin, Subsystem subsystem, Subsystem parentSubsystem) {
         context = Activator.getBundleContext();
         this.eventDispatcher = Activator.getEventDispatcher();
         this.scopeAdmin = scopeAdmin;
@@ -283,7 +283,7 @@ private Subsystem getInstalledSubsytem(String url) {
     }
     
     // return the scope admin associated with the subsystemadmin.
-    protected ScopeAdmin getScopeAdmin() {
+    protected Scope getScopeAdmin() {
         return this.scopeAdmin;
     }
     
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemImpl.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemImpl.java
index e3afebd5..91a57c73 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemImpl.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemImpl.java
@@ -14,16 +14,18 @@
  */
 package org.apache.aries.subsystem.core.internal;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 
 import org.apache.aries.subsystem.Subsystem;
 import org.apache.aries.subsystem.SubsystemAdmin;
 import org.apache.aries.subsystem.SubsystemConstants;
 import org.apache.aries.subsystem.SubsystemEvent;
 import org.apache.aries.subsystem.SubsystemException;
-import org.apache.aries.subsystem.Subsystem.State;
 import org.apache.aries.subsystem.scope.Scope;
-import org.apache.aries.subsystem.scope.ScopeAdmin;
 import org.osgi.framework.Bundle;
 import org.osgi.framework.BundleContext;
 import org.osgi.framework.BundleException;
diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemResourceProcessor.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemResourceProcessor.java
index d211feb1..2a00449d 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemResourceProcessor.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/internal/SubsystemResourceProcessor.java
@@ -29,15 +29,13 @@
 import java.io.FileInputStream;
 import java.io.InputStream;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Collections;
-import java.util.Dictionary;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import java.util.Map.Entry;
+import java.util.Set;
 import java.util.jar.Attributes;
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
@@ -47,8 +45,7 @@
 import org.apache.aries.subsystem.SubsystemAdmin;
 import org.apache.aries.subsystem.SubsystemConstants;
 import org.apache.aries.subsystem.SubsystemException;
-import org.apache.aries.subsystem.scope.InstallInfo;
-import org.apache.aries.subsystem.scope.ScopeAdmin;
+import org.apache.aries.subsystem.scope.Scope;
 import org.apache.aries.subsystem.scope.ScopeUpdate;
 import org.apache.aries.subsystem.scope.SharePolicy;
 import org.apache.aries.subsystem.spi.Resource;
@@ -106,7 +103,7 @@ private void process(Resource res, Manifest manifest) {
 
             try {
                 SubsystemAdminImpl adminImpl = (SubsystemAdminImpl)subsystemAdmin;
-                ScopeAdmin admin = adminImpl.getScopeAdmin();
+                Scope admin = adminImpl.getScopeAdmin();
                 ResourceResolver resolver = getService(ResourceResolver.class);
 
                 if (manifest == null) {
@@ -176,7 +173,9 @@ private void process(Resource res, Manifest manifest) {
                     setupSharePolicies(exportSharePolicies, importSharePolicies, headers);
                     scopeUpdate.commit();
                     
-                    ScopeAdmin childScopeAdmin = getService(ScopeAdmin.class, "ScopeId=" + childScopeUpdate.getScope().getId());
+      //              ScopeAdmin childScopeAdmin = getService(ScopeAdmin.class, "ScopeId=" + childScopeUpdate.getScope().getId());
+      
+                    Scope childScopeAdmin = childScopeUpdate.getScope();
                     
                     subsystem = new SubsystemImpl(childScopeUpdate.getScope(), headers);
                     SubsystemAdmin childSubsystemAdmin = new SubsystemAdminImpl(childScopeAdmin, subsystem, subsystemAdmin.getSubsystem());
diff --git a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/AbstractIntegrationTest.java b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/AbstractIntegrationTest.java
index 04350c6b..2a004bab 100644
--- a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/AbstractIntegrationTest.java
+++ b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/AbstractIntegrationTest.java
@@ -18,30 +18,23 @@
  */
 package org.apache.aries.subsystem.itests;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-import java.io.*;
-import java.net.URISyntaxException;
+import static org.ops4j.pax.exam.CoreOptions.options;
+import static org.ops4j.pax.exam.CoreOptions.wrappedBundle;
+import static org.ops4j.pax.exam.OptionUtils.combine;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
 import java.net.URL;
-import java.text.SimpleDateFormat;
 import java.util.ArrayList;
-import java.util.Currency;
 import java.util.List;
 import java.util.Properties;
 
 import org.junit.After;
 import org.junit.Before;
 import org.ops4j.pax.exam.CoreOptions;
-import static org.ops4j.pax.exam.CoreOptions.options;
-import static org.ops4j.pax.exam.CoreOptions.wrappedBundle;
 import org.ops4j.pax.exam.Inject;
 import org.ops4j.pax.exam.Option;
-import static org.ops4j.pax.exam.OptionUtils.combine;
 import org.ops4j.pax.exam.options.MavenArtifactProvisionOption;
 import org.osgi.framework.Bundle;
 import org.osgi.framework.BundleContext;
@@ -49,7 +42,6 @@
 import org.osgi.framework.Filter;
 import org.osgi.framework.FrameworkUtil;
 import org.osgi.framework.InvalidSyntaxException;
-import org.osgi.service.blueprint.container.BlueprintContainer;
 import org.osgi.util.tracker.ServiceTracker;
 
 public abstract class AbstractIntegrationTest {
diff --git a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/SubsystemAdmin2Test.java b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/SubsystemAdmin2Test.java
index b55900df..f2712a13 100644
--- a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/SubsystemAdmin2Test.java
+++ b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/SubsystemAdmin2Test.java
@@ -19,43 +19,28 @@
 package org.apache.aries.subsystem.itests;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
 import static org.ops4j.pax.exam.CoreOptions.equinox;
 import static org.ops4j.pax.exam.CoreOptions.options;
 import static org.ops4j.pax.exam.CoreOptions.systemProperty;
 
 import java.io.File;
 import java.io.FileOutputStream;
-import java.net.URL;
-import java.text.SimpleDateFormat;
 import java.util.Collection;
-import java.util.Currency;
-import java.util.Hashtable;
-import java.util.HashMap;
-import java.util.Map;
-
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
 
 import org.apache.aries.subsystem.Subsystem;
 import org.apache.aries.subsystem.SubsystemAdmin;
-import org.apache.aries.subsystem.scope.ScopeAdmin;
+import org.apache.aries.subsystem.scope.Scope;
 import org.apache.aries.unittest.fixture.ArchiveFixture;
 import org.apache.aries.unittest.fixture.ArchiveFixture.ZipFixture;
-
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
 import org.ops4j.pax.exam.Option;
 import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
 import org.ops4j.pax.exam.junit.JUnit4TestRunner;
 import org.osgi.framework.Bundle;
-import org.osgi.framework.BundleContext;
-import org.osgi.framework.Constants;
-import org.osgi.framework.ServiceReference;
 
 
 @RunWith(JUnit4TestRunner.class)
@@ -85,7 +70,7 @@ public static void createApplications() throws Exception {
     @Test
     public void test() throws Exception {
         // make sure we are using a framework that provides scope admin service
-        ScopeAdmin scopeA = getOsgiService(ScopeAdmin.class);
+        Scope scopeA = getOsgiService(Scope.class);
         assertNotNull("scope admin should not be null", scopeA);
         System.out.println("able to get scope admin service");
         
@@ -138,7 +123,7 @@ public void test() throws Exception {
 
             PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),
 
-            equinox().version("3.7.0.v20110110")
+            equinox().version("3.7.0.v20110221")
         );
         options = updateOptions(options);
         return options;
diff --git a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/SubsystemAdminTest.java b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/SubsystemAdminTest.java
index 15df2b68..e7819a4b 100644
--- a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/SubsystemAdminTest.java
+++ b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/SubsystemAdminTest.java
@@ -19,45 +19,27 @@
 package org.apache.aries.subsystem.itests;
 
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
 import static org.ops4j.pax.exam.CoreOptions.equinox;
 import static org.ops4j.pax.exam.CoreOptions.options;
 import static org.ops4j.pax.exam.CoreOptions.systemProperty;
 
 import java.io.File;
 import java.io.FileOutputStream;
-import java.net.URL;
-import java.text.SimpleDateFormat;
 import java.util.Collection;
-import java.util.Currency;
-import java.util.Hashtable;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
 
 import org.apache.aries.subsystem.Subsystem;
 import org.apache.aries.subsystem.SubsystemAdmin;
-import org.apache.aries.subsystem.scope.ScopeAdmin;
+import org.apache.aries.subsystem.scope.Scope;
 import org.apache.aries.unittest.fixture.ArchiveFixture;
 import org.apache.aries.unittest.fixture.ArchiveFixture.ZipFixture;
-
+import org.junit.Before;
+import org.junit.runner.RunWith;
 import org.ops4j.pax.exam.Option;
 import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
 import org.ops4j.pax.exam.junit.JUnit4TestRunner;
 import org.osgi.framework.Bundle;
-import org.osgi.framework.BundleContext;
-import org.osgi.framework.Constants;
-import org.osgi.framework.ServiceReference;
 
 
 @RunWith(JUnit4TestRunner.class)
@@ -90,7 +72,7 @@ public static void createApplications() throws Exception {
     //@Test
     public void test() throws Exception {
         // make sure we are using a framework that provides composite admin service
-        ScopeAdmin scopeA = getOsgiService(ScopeAdmin.class);
+    	Scope scopeA = getOsgiService(Scope.class);
         assertNotNull("composite admin should not be null", scopeA);
         System.out.println("able to get composite admin service");
         
diff --git a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/ops4j/pax/runner/platform/equinox/internal/SsActivator.java b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/ops4j/pax/runner/platform/equinox/internal/SsActivator.java
index 8b09f3d6..c5efa6ad 100644
--- a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/ops4j/pax/runner/platform/equinox/internal/SsActivator.java
+++ b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/ops4j/pax/runner/platform/equinox/internal/SsActivator.java
@@ -25,6 +25,7 @@
             new EquinoxPlatformBuilder( bundleContext, "3.5.1" ),
             new EquinoxPlatformBuilder( bundleContext, "3.6.0" ),
             new EquinoxPlatformBuilder( bundleContext, "3.7.0.V20110110" ),
+            new EquinoxPlatformBuilder( bundleContext, "3.7.0.V20110221" ),
             new EquinoxPlatformBuilderSnapshot( bundleContext )
         };
     }
diff --git a/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/InstallInfo.java b/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/InstallInfo.java
index 2b7dfdd5..5f4c8cd1 100644
--- a/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/InstallInfo.java
+++ b/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/InstallInfo.java
@@ -18,6 +18,7 @@
  */
 package org.apache.aries.subsystem.scope;
 
+import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 
@@ -26,24 +27,16 @@
  * update}.
  */
 public class InstallInfo {
-	private final URL content;
+	private final InputStream content;
 	private final String location;
-	private final InputStream is;
 
 	/**
-	 * Returns a url to the content of the bundle to install.
-	 * @return a url to the content of the bundle to install.
+	 * Constructor for a bundle install info.
+	 * @param content the content of the bundle.
+	 * @param location the location of the bundle.
 	 */
-	public URL getContent() {
-		return content;
-	}
-
-	/**
-	 * Returns the location to use for bundle installation.
-	 * @return the location to use for bundle installation.
-	 */
-	public String getLocation() {
-		return location;
+	public InstallInfo(String location, URL content) throws IOException {
+		this(location == null ? content.toExternalForm() : location, content.openStream());
 	}
 
 	/**
@@ -51,20 +44,28 @@ public String getLocation() {
 	 * @param content the content of the bundle.
 	 * @param location the location of the bundle.
 	 */
-	public InstallInfo(URL content, String location) {
-		this.content = content;
+    public InstallInfo(String location, InputStream content) {
+    	if (location == null || location.length() == 0)
+    		throw new IllegalArgumentException("Missing required parameter: location");
+    	if (content == null)
+    		throw new NullPointerException("Missing required parameter: content");
 		this.location = location;
-		this.is = null;
+        this.content = content;
 	}
 	
 	   /**
-     * Constructor for a bundle install info.
-     * @param content the content of the bundle.
-     * @param location the location of the bundle.
+	 * Returns a url to the content of the bundle to install.
+	 * @return a url to the content of the bundle to install.
      */
-    public InstallInfo(InputStream is, String location) {
-        this.is = is;
-        this.location = location;
-        this.content = null;
+	public InputStream getContent() {
+		return content;
+	}
+
+	/**
+	 * Returns the location to use for bundle installation.
+	 * @return the location to use for bundle installation.
+	 */
+	public String getLocation() {
+		return location;
     }
 }
diff --git a/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/Scope.java b/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/Scope.java
index df985933..04aac3a0 100644
--- a/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/Scope.java
+++ b/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/Scope.java
@@ -73,14 +73,13 @@
 	 */
 	long getId();
 	
-	/**
-	 * destoy the scope
-	 */
-	void destroy();
-	
 	/**
 	 * Returns the install location String of the scope
 	 * @return   the install location String of the scope
 	 */
 	String getLocation();
+	
+	Scope getParent();
+	
+	ScopeUpdate newScopeUpdate();
 }
diff --git a/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/ScopeAdmin.java b/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/ScopeAdmin.java
index b294c347..e69de29b 100644
--- a/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/ScopeAdmin.java
+++ b/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/ScopeAdmin.java
@@ -1,47 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.aries.subsystem.scope;
-
-/**
- * Scope Admin is used to update the scopes for the system.
- * When a bundle obtains a scope admin service it retrieves
- * a scope admin service for the scope the bundle belongs to.
- *
- */
-public interface ScopeAdmin {
-	/**
-	 * The root scope of this scope admin.
-	 * @return the root scope of this scope admin
-	 */
-	Scope getScope();
-
-	/**
-	 * Creates a new scope update for updating
-	 * the root scope of this scope admin.
-	 * @return a new scope update.
-	 */
-	ScopeUpdate newScopeUpdate();
-
-	/**
-	 * Returns the parent scope for the root 
-	 * scope of this scope admin.
-	 * @return
-	 */
-	Scope getParentScope();
-}
diff --git a/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/ScopeUpdate.java b/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/ScopeUpdate.java
index fdd37daf..4a67b01b 100644
--- a/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/ScopeUpdate.java
+++ b/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/ScopeUpdate.java
@@ -211,12 +211,6 @@
 	 */
 	boolean commit() throws BundleException;
 	
-	/**
-	 * Returns the children scope to be removed
-	 * @return   the to be removed children.   
-	 */
-	Collection<Scope> getToBeRemovedChildren();
-	
 	/**
 	 * Returns the scope it is updating
 	 * @return   the scope it is updating
diff --git a/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/SharePolicy.java b/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/SharePolicy.java
index cf906f21..cce94dde 100644
--- a/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/SharePolicy.java
+++ b/aries/trunk/subsystem/subsystem-scope-api/src/main/java/org/apache/aries/subsystem/scope/SharePolicy.java
@@ -50,8 +50,14 @@
 	 * @param filter the filter for matching capabilities this policy controls.
 	 */
 	public SharePolicy(String type, String namespace, Filter filter) {
+		if (!(TYPE_EXPORT.equals(type) || TYPE_IMPORT.equals(type)))
+			throw new IllegalArgumentException("Invalid parameter value: type = " + type);
 		this.type = type;
+		if (namespace == null || namespace.length() == 0)
+			throw new IllegalArgumentException("Missing required paramater: namespace");
 		this.namespace = namespace;
+		if (filter == null)
+			throw new NullPointerException("Missing required parameter: filter");
 		this.filter = filter;
 	}
 
diff --git a/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/DictionaryBuilder.java b/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/DictionaryBuilder.java
index d9a610f4..e69de29b 100644
--- a/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/DictionaryBuilder.java
+++ b/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/DictionaryBuilder.java
@@ -1,52 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.aries.subsystem.scope.impl;
-
-import java.util.Dictionary;
-import java.util.Hashtable;
-
-public class DictionaryBuilder<K,V> {
-
-    public static <K,V> Dictionary<K,V> build(K k, V v) {
-        return new DictionaryBuilder<K,V>().p(k, v).get();
-    }
-
-    public static <K,V> Dictionary<K,V> build(K k1, V v1, K k2, V v2) {
-        return new DictionaryBuilder<K,V>().p(k1, v1).p(k2, v2).get();
-    }
-
-    public static <K,V> Dictionary<K,V> build(K k1, V v1, K k2, V v2, K k3, V v3) {
-        return new DictionaryBuilder<K,V>().p(k1, v1).p(k2, v2).p(k3, v3).get();
-    }
-
-    private Dictionary<K,V> dict;
-
-    public DictionaryBuilder() {
-        dict = new Hashtable<K,V>();
-    }
-
-    DictionaryBuilder<K,V> p(K k, V v) {
-        dict.put(k, v);
-        return this;
-    }
-
-    Dictionary<K,V> get() {
-        return dict;
-    }
-}
diff --git a/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeAdminImpl.java b/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeAdminImpl.java
index 667a3e7e..e69de29b 100644
--- a/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeAdminImpl.java
+++ b/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeAdminImpl.java
@@ -1,48 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.aries.subsystem.scope.impl;
-
-import org.apache.aries.subsystem.scope.Scope;
-import org.apache.aries.subsystem.scope.ScopeAdmin;
-import org.apache.aries.subsystem.scope.ScopeUpdate;
-import org.apache.aries.subsystem.scope.internal.Activator;
-
-public class ScopeAdminImpl implements ScopeAdmin {
-
-    private ScopeImpl parentScope;
-    private ScopeImpl scope;
-    
-    public ScopeAdminImpl(ScopeImpl parentScope, ScopeImpl scope) {
-        this.parentScope = parentScope;
-        this.scope = scope;
-    }
-    
-    public Scope getParentScope() {
-        return this.parentScope;
-    }
-
-    public Scope getScope() {
-        return this.scope;
-    }
- 
-    public ScopeUpdate newScopeUpdate() {
-        return new ScopeUpdateImpl(this.scope, Activator.getBundleContext());
-    }
-
-}
diff --git a/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeAdminServiceFactory.java b/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeAdminServiceFactory.java
index 2953b186..e69de29b 100644
--- a/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeAdminServiceFactory.java
+++ b/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeAdminServiceFactory.java
@@ -1,556 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.aries.subsystem.scope.impl;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Dictionary;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.aries.subsystem.scope.Scope;
-import org.apache.aries.subsystem.scope.ScopeAdmin;
-import org.apache.aries.subsystem.scope.ScopeUpdate;
-import org.apache.aries.subsystem.scope.SharePolicy;
-import org.apache.aries.subsystem.scope.internal.Activator;
-import org.osgi.framework.Bundle;
-import org.osgi.framework.BundleContext;
-import org.osgi.framework.BundleEvent;
-import org.osgi.framework.Constants;
-import org.osgi.framework.Filter;
-import org.osgi.framework.FrameworkUtil;
-import org.osgi.framework.InvalidSyntaxException;
-import org.osgi.framework.ServiceEvent;
-import org.osgi.framework.ServiceFactory;
-import org.osgi.framework.ServiceReference;
-import org.osgi.framework.ServiceRegistration;
-import org.osgi.framework.Version;
-import org.osgi.framework.hooks.bundle.EventHook;
-import org.osgi.framework.hooks.bundle.FindHook;
-import org.osgi.framework.hooks.resolver.ResolverHook;
-import org.osgi.framework.hooks.resolver.ResolverHookFactory;
-import org.osgi.framework.wiring.BundleRevision;
-import org.osgi.framework.wiring.Capability;
-import org.osgi.util.tracker.ServiceTracker;
-import org.osgi.util.tracker.ServiceTrackerCustomizer;
-
-// the idea is one scopeAdmin per scope. for bundles in the same scope, same
-// ScopeAdmin would be returned
-public class ScopeAdminServiceFactory implements ServiceFactory {
-
-    // mapping of scope and ScopeAdminImpl
-    private final List<ScopeAdmin> admins = new ArrayList<ScopeAdmin>();
-    private final Map<ScopeAdmin, Long> references = new HashMap<ScopeAdmin, Long>();
-    protected static ScopeAdminImpl defaultScopeAdmin;
-    private static BundleContext context;
-    private ServiceTracker serviceTracker;
-    private List<ServiceRegistration> srs = new ArrayList<ServiceRegistration>();
-    public static final String SERVICE_CAPABILITY = "osgi.service";
-    private ServiceRegistration rootScopeAdminserviceReg;
-    
-    public void init() throws InvalidSyntaxException {
-        context = Activator.getBundleContext();
-        Filter filter = FrameworkUtil.createFilter("(&("
-                + Constants.OBJECTCLASS + "=" + ScopeAdmin.class.getName() + "))");
-        serviceTracker = new ServiceTracker(context, filter,
-                new ServiceTrackerCustomizer() {
-
-                    public Object addingService(ServiceReference reference) {
-                        // adding new service, update admins map
-                        ScopeAdmin sa = (ScopeAdmin) context
-                                .getService(reference);
-                        admins.add(sa);
-
-                        return sa;
-                    }
-
-                    public void modifiedService(ServiceReference reference,
-                            Object service) {
-                        // TODO Auto-generated method stub
-
-                    }
-
-                    public void removedService(ServiceReference reference,
-                            Object service) {
-                        ScopeAdmin sa = (ScopeAdmin) service;
-                        admins.remove(sa);
-                    }
-
-                });
-        defaultScopeAdmin = new ScopeAdminImpl(null, new ScopeImpl("root",
-                context));
-        rootScopeAdminserviceReg = context.registerService(ScopeAdmin.class.getName(), 
-                defaultScopeAdmin, 
-                DictionaryBuilder.build("ScopeName", defaultScopeAdmin.getScope().getName(), "ScopeId", defaultScopeAdmin.getScope().getId()));
-        admins.add(defaultScopeAdmin);
-        references.put(defaultScopeAdmin, new Long(0));
-        serviceTracker.open();
-        
-        ScopeAdminBundleHooks bundleHooks = new ScopeAdminBundleHooks();
-        srs.add(context.registerService(new String[]{FindHook.class.getName(), EventHook.class.getName(), ResolverHookFactory.class.getName()}, bundleHooks, null));
-        ScopeAdminEventHooks eventHooks = new ScopeAdminEventHooks();
-        srs.add(context.registerService(new String[]{org.osgi.framework.hooks.service.FindHook.class.getName(), org.osgi.framework.hooks.service.EventHook.class.getName()}, eventHooks, null));
-
-        
-    }
-
-    public void destroy() {
-        if (serviceTracker != null) {
-            serviceTracker.close();
-        }
-        
-        for (ServiceRegistration sr : srs) {
-            sr.unregister();
-        }
-        
-        if (rootScopeAdminserviceReg != null) {
-            rootScopeAdminserviceReg.unregister();
-        }
-    }
-
-    public synchronized Object getService(Bundle bundle, ServiceRegistration registration) {
-        // determine bundle in which scope first, then determine the
-        // scopeadmin to return
-        ScopeAdmin sa = getScopeAdmin(bundle);
-        long ref = 0;
-
-        // unable to find scope admin in our admins map
-        if (sa == null) {
-            // unable to find scope admin, assuming it is in the root scope.
-            sa = defaultScopeAdmin;
-            
-        } else {
-            ref = references.get(sa);
-        }
-
-        references.put(sa, ref + 1);
-        return sa;
-    }
-
-    public synchronized void ungetService(Bundle bundle,
-            ServiceRegistration registration, Object service) {
-        ScopeAdminImpl admin = (ScopeAdminImpl) service;
-        long ref = references.get(admin) - 1;
-        if (ref == 0) {
-            // admin.dispose();
-            admins.remove(admin);
-            references.remove(admin);
-        } else {
-            references.put(admin, ref);
-        }
-    }
-    
-    // assume one bundle only belongs to one subsystem at most
-    private ScopeAdmin getScopeAdmin(Bundle bundle) {
-        
-        // add pax-exam-probe to default scope for now before we could figure out bundles in which scope via some sorta of installhook (bug 1747 in OSGi Aliance bug system)
-        if (bundle.getSymbolicName().equals("pax-exam-probe") || bundle.getSymbolicName().indexOf("fileinstall") > -1) {
-            ScopeUpdate scopeUpdate = ScopeAdminServiceFactory.defaultScopeAdmin.newScopeUpdate();
-            scopeUpdate.getBundles().add(bundle);
-        }
-        
-        // add hard coded value below due to bug 1747
-        if (bundle.getSymbolicName().indexOf("helloIsolation") > 0 && bundle.getVersion().equals(new Version("1.0.0"))) {
-            ScopeUpdate scopeUpdate = ScopeAdminServiceFactory.defaultScopeAdmin.newScopeUpdate();
-            scopeUpdate.getBundles().add(bundle);
-        }
-        
-        for (ScopeAdmin admin : admins) {
-            ScopeImpl scope = (ScopeImpl)admin.getScope();
-            
-            // it is possible the scope is in the tobeinstalled bundle location list, and hasn't fully installed yet.
-            Collection<String> bundlesLocations = scope.getToBeInstalledBundleLocation();
-            for (String loc : bundlesLocations) {
-                if (bundle.getLocation().equals(loc)) {
-                    return admin;
-                }
-            }
-            Collection<Bundle> bundles = scope.getBundles();
-            
-            for (Bundle b : bundles) {
-                if (b == bundle) {
-                    return admin;
-                }
-            }
-            
-
-        }
-
-        // it is possible there is no scopeAdmin for the bundle as the bundle has not been added to the scope yet.
-        return null;
-    }
-
-
-    private class ScopeAdminBundleHooks implements FindHook, EventHook, ResolverHookFactory {
-
-        public void find(BundleContext context, Collection<Bundle> bundles) {
-            Bundle b = context.getBundle();
-            // obtain bundle associated subsystem
-            ScopeAdmin scopeAdmin = getScopeAdmin(b);
-            
-            if (scopeAdmin != null) {
-                // able to obtain the correct scope otherwise, we don't need to do anything
-                Collection<Bundle> buns = scopeAdmin.getScope().getBundles();
-                trimBundleCollections(bundles, buns);
-            } else {
-                // should this be an error.  a bundle would have to be in a scope.
-            }
-            
-            // check the scope policy
-            // are we allow any package to be exported out of a scope?   yes  if yes, do we want to have bundle that exports the package visible?
-            // are we allow any service to be exported out of a scope?   yes
-            // go through bundles and remove the bundles that are not part of the scope
-        }
-
-        public void event(BundleEvent event, Collection<BundleContext> contexts) {
-            Bundle bundle = event.getBundle();
-            
-            // obtain bundle associated scopeAdmin
-            ScopeAdmin scopeAdmin = getScopeAdmin(bundle);
-            
-            if (scopeAdmin != null) {
-                // able to obtain the correct scope otherwise, we don't need to do anything
-                Collection<Bundle> buns = scopeAdmin.getScope().getBundles();
-                ScopeImpl scopeImpl = (ScopeImpl)scopeAdmin.getScope();
-                trimBundleContextCollections(contexts, buns, scopeImpl.getToBeInstalledBundleLocation());
-            } 
-            
-            // figure out where contexts reside in which scope and trim them as needed.
-            // should be easy as events should only been seen inside a scope
-            
-        }
-
-        public ResolverHook begin(Collection<BundleRevision> arg0) {
-			return new ResolverHook() {
-		        public void end() {
-		            // do nothing
-		        }
-		
-		        public void filterMatches(BundleRevision requirer, Collection<Capability> candidates) {
-		            // obtain requirer bundle
-		            Bundle bundle = requirer.getBundle();
-		            
-		            // figure out if the requirer bundle in any scope
-		            // obtain bundle associated scopeAdmin
-		            ScopeAdmin scopeAdmin = getScopeAdmin(bundle);
-		            
-		            if (scopeAdmin != null) {
-		                // able to obtain the correct scope otherwise, we don't need to do anything
-		                Collection<Bundle> buns = scopeAdmin.getScope().getBundles();
-		                
-		                Collection<Scope> childrenScopes = scopeAdmin.getScope().getChildren();
-		                List<SharePolicy> exportPackagePolicies = new ArrayList<SharePolicy>();
-		                for (Scope childScope : childrenScopes) {
-		                    Map<String, List<SharePolicy>> exportPolicies = childScope.getSharePolicies(SharePolicy.TYPE_EXPORT);
-		                    if (exportPolicies.get(Capability.PACKAGE_CAPABILITY) != null) {
-		                        exportPackagePolicies.addAll(exportPolicies.get(Capability.PACKAGE_CAPABILITY));
-		                    }
-		                }
-		                
-		                List<SharePolicy> importPackagePolicies = new ArrayList<SharePolicy>();
-		                Map<String, List<SharePolicy>> importPolicies = scopeAdmin.getScope().getSharePolicies(SharePolicy.TYPE_IMPORT);
-		                if (importPolicies.get(Capability.PACKAGE_CAPABILITY) != null) {
-		                    importPackagePolicies.addAll(importPolicies.get(Capability.PACKAGE_CAPABILITY));
-		                }
-		
-		                trimCapabilityCollections(candidates, buns, exportPackagePolicies, importPackagePolicies);
-		            }
-		            // simple filter candidates
-		          
-		        }
-		
-		        public void filterResolvable(Collection candidates) {
-		            // TODO Auto-generated method stub
-		            
-		        }
-		
-		        public void filterSingletonCollisions(Capability singleton, Collection collisionCandidates) {
-		            // TODO Auto-generated method stub
-		            
-		        }
-		        
-		    };
-        }
-    }
-    // based on event hooks
-    private class ScopeAdminEventHooks implements org.osgi.framework.hooks.service.FindHook, org.osgi.framework.hooks.service.EventHook {
-
-        // modifies getServiceReference
-        public void find(BundleContext context, String name, String filter,
-                boolean allServices, Collection references) {
-            Bundle bundle = context.getBundle();
-            
-            // figure out if the bundle in any scope
-            // obtain bundle associated scopeAdmin
-            ScopeAdmin scopeAdmin = getScopeAdmin(bundle);
-            
-            if (scopeAdmin != null) {
-                // able to obtain the correct scope otherwise, we don't need to do anything
-                Collection<Bundle> buns = scopeAdmin.getScope().getBundles();
-                
-                Collection<Scope> childrenScopes = scopeAdmin.getScope().getChildren();
-                List<SharePolicy> exportServicePolicies = new ArrayList<SharePolicy>();
-                for (Scope childScope : childrenScopes) {
-                    Map<String, List<SharePolicy>> exportPolicies = childScope.getSharePolicies(SharePolicy.TYPE_EXPORT);
-                    if (exportPolicies.get(SERVICE_CAPABILITY) != null) {
-                        exportServicePolicies.addAll(exportPolicies.get(SERVICE_CAPABILITY));
-                    }
-                }
-                
-                List<SharePolicy> importServicePolicies = new ArrayList<SharePolicy>();
-                Map<String, List<SharePolicy>> importPolicies = scopeAdmin.getScope().getSharePolicies(SharePolicy.TYPE_IMPORT);
-                if (importPolicies.get(SERVICE_CAPABILITY) != null) {
-                    importServicePolicies.addAll(importPolicies.get(SERVICE_CAPABILITY));
-                }
-                trimServiceReferenceCollections(references, buns, exportServicePolicies, importServicePolicies);       
-            }
-            
-            
-        }
-
-        // modifies service events - assume events are only seen in the scope.
-        public void event(ServiceEvent event, Collection contexts) {
-            Bundle bundle = event.getServiceReference().getBundle();
-            
-            // obtain bundle associated scopeAdmin
-            ScopeAdmin scopeAdmin = getScopeAdmin(bundle);
-            
-            if (scopeAdmin != null) {
-                // able to obtain the correct scope otherwise, we don't need to do anything
-                Collection<Bundle> buns = scopeAdmin.getScope().getBundles();
-                trimBundleContextCollections(contexts, buns, null);
-            }
-            
-        }
-
-        
-    }
-    
-    // trim the references candidate to only the ones in scopeBundles
-    private synchronized void trimServiceReferenceCollections(
-            Collection<ServiceReference> references,
-            Collection<Bundle> scopeBundles, 
-            List<SharePolicy> exportServicePolicies, 
-            List<SharePolicy> importServicePolicies) {
-        Collection<ServiceReference> toBeRemoved = new ArrayList<ServiceReference>();
-        for (ServiceReference reference : references) {
-            Bundle b = reference.getBundle();
-            boolean exist = false;
-
-            for (Bundle bundle : scopeBundles) {
-                if (b == bundle) {
-                    exist = true;
-                    break;
-                }
-            }
-
-            if (!exist) {
-                // double check toBeRemoved.  If it exists in toBeRemoved but are part of exportServicePolicies of the child scope
-                // then we still allow the services to be used
-                // if it exists in toBeRemoved but are part of importServicePolicies of the scope the bundle is in, we still allow
-                // the services to be used.
-                boolean matchPolicy = false;
-                // go through export package policies
-                for (SharePolicy sp : exportServicePolicies) {         
-                    if (sp.getFilter().match(reference)) {
-                        matchPolicy = true;
-                        continue;
-                    }
-                    
-                }
-                
-                if (!matchPolicy) {
-                    // go through import package policies
-                    for (SharePolicy sp : importServicePolicies) {
-                        if (sp.getFilter().match(reference)) {
-                            matchPolicy = true;
-                            continue;
-                        }
-                        
-                    }
-                    if (!matchPolicy) {
-                        toBeRemoved.add(reference);
-                    }
-                }
-            }
-        }
-
-        if (!toBeRemoved.isEmpty()) {
-            references.removeAll(toBeRemoved);
-        }
-    }
-    
-    // trim the bundles candidate to only the ones in subsystemBundles
-    private synchronized void trimBundleCollections(Collection<Bundle> bundles, Collection<Bundle> scopeBundles) {
-        Collection<Bundle> toBeRemoved = new ArrayList<Bundle>();
-        for (Bundle b : bundles) {
-            boolean exist = false;
-            
-            for (Bundle bundle : scopeBundles) {
-                if (b == bundle) {
-                    exist = true;
-                    break;
-                }
-            }
-            
-            if (!exist) {
-                toBeRemoved.add(b);
-            }
-        }
-
-        if (!toBeRemoved.isEmpty()) {
-            bundles.removeAll(toBeRemoved);
-        }
-    }
-    
-    // trim the bundles candidate to only the ones in scopeBundles
-    private synchronized void trimBundleContextCollections(Collection<BundleContext> bundleContexts, 
-            Collection<Bundle> scopeBundles, Collection<String> toBeInstalledBundleLocations) {
-        Collection<BundleContext> toBeRemoved = new ArrayList<BundleContext>();
-
-        for (BundleContext bc : bundleContexts) {
-            boolean exist = false;
-            
-            for (Bundle bundle : scopeBundles) {
-                if (bc.getBundle() == bundle || existsInList(bc.getBundle().getLocation(), toBeInstalledBundleLocations)) {
-                    exist = true;
-                    break;
-                }
-            }
-            
-            if (!exist) {
-                toBeRemoved.add(bc);
-            } 
-            
-        }
-        
-        if (!toBeRemoved.isEmpty()) {
-            bundleContexts.removeAll(toBeRemoved);
-        }
-
-    }
-
-    private boolean existsInList(String bundleLoc, Collection<String> toBeInstalledBundleLocations) {
-        if (toBeInstalledBundleLocations == null) {
-            return false;
-        }
-        
-        for (String loc : toBeInstalledBundleLocations) {
-            if (bundleLoc.equals(loc)) {
-                return true;
-            }
-        }
-        return false;
-    }
-    // trim the bundles candidate to only the ones in subsystemBundles
-    private synchronized void trimCapabilityCollections(Collection<Capability> capabilities, 
-            Collection<Bundle> scopeBundles, 
-            List<SharePolicy> exportPackagePolicies, 
-            List<SharePolicy> importPackagePolicies) {
-        Collection<Capability> toBeRemoved = new ArrayList<Capability>();
-
-        for (Capability cap : capabilities) {
-            Bundle b = cap.getProviderRevision().getBundle();
-
-            if (b.getBundleId() == 0) {
-                continue;
-            }
-            boolean exist = false;
-            
-            for (Bundle bundle : scopeBundles) {
-                if (b == bundle) {
-                    exist = true;
-                    break;
-                }
-            }
-            
-            if (!exist) {
-                // double check toBeRemoved.  If it exists in toBeRemoved but are part of exportPackagePolicies of the child scope
-                // then we still allow the capabilities to be used
-                // if it exists in toBeRemoved but are part of importPackagePolicies of the scope the bundle is in, we still allow
-                // the capabilities to be used.
-                boolean matchPolicy = false;
-                // go through export package policies
-                for (SharePolicy sp : exportPackagePolicies) {
-                    if (sp.getFilter().match(new UnmodifiableDictionary(cap.getAttributes()))) {
-                        matchPolicy = true;
-                        break;
-                    }
-                    
-                }
-                
-                if (!matchPolicy) {
-                    // go through import package policies
-                    for (SharePolicy sp : importPackagePolicies) {
-                        // append the scope to the capability to do scope affinity
-                        Map<String, Object> capabilityAttributes = new HashMap<String, Object>();
-                        capabilityAttributes.putAll(cap.getAttributes());
-                        Scope scope = getScopeAdmin(b).getScope();
-                        capabilityAttributes.put("scopeName", scope.getName());
-                        
-                        if (sp.getFilter().match(new UnmodifiableDictionary(capabilityAttributes))) {
-                            matchPolicy = true;
-                            break;
-                        }
-                        
-                    }
-                    if (!matchPolicy) {
-                        toBeRemoved.add(cap);
-                    }
-                }
-            }
-        }
-         
-        if (!toBeRemoved.isEmpty()) {
-            capabilities.removeAll(toBeRemoved);
-        }
-    }
-    
-    static class UnmodifiableDictionary extends Dictionary {
-        private final Map   wrapped;
-        UnmodifiableDictionary(Map wrapped) {
-            this.wrapped = wrapped;
-        }
-        public Enumeration elements() {
-            return Collections.enumeration(wrapped.values());
-        }
-        public Object get(Object key) {
-            return wrapped.get(key);
-        }
-        public boolean isEmpty() {
-            return wrapped.isEmpty();
-        }
-        public Enumeration keys() {
-            return Collections.enumeration(wrapped.keySet());
-        }
-        public Object put(Object key, Object value) {
-            throw new UnsupportedOperationException();
-        }
-        public Object remove(Object key) {
-            throw new UnsupportedOperationException();
-        }
-        public int size() {
-            return wrapped.size();
-        }
-    }
-}
-
diff --git a/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeImpl.java b/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeImpl.java
index df3dda59..344c8f49 100644
--- a/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeImpl.java
+++ b/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeImpl.java
@@ -1,186 +1,161 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
 package org.apache.aries.subsystem.scope.impl;
 
-import java.lang.IllegalArgumentException;
-import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import org.apache.aries.subsystem.scope.Scope;
+import org.apache.aries.subsystem.scope.ScopeUpdate;
 import org.apache.aries.subsystem.scope.SharePolicy;
 import org.osgi.framework.Bundle;
 import org.osgi.framework.BundleContext;
-import org.osgi.framework.BundleEvent;
-import org.osgi.util.tracker.BundleTracker;
-import org.osgi.util.tracker.BundleTrackerCustomizer;
 
 public class ScopeImpl implements Scope {
+	private static class UnmodifiableSharePolicyMap implements Map<String, List<SharePolicy>> {
+		private final Map<String, List<SharePolicy>> map;
 
-    private String name;
-    private String location;
-    private BundleContext context;
-    private List<Scope> children = new ArrayList<Scope>();
-    private List<Bundle> bundles = new ArrayList<Bundle>();
-    private Map<String, List<SharePolicy>> importPolicies = new HashMap<String, List<SharePolicy>>();
-    private Map<String, List<SharePolicy>> exportPolicies = new HashMap<String, List<SharePolicy>>();
-    private BundleTracker bt;
-    private long id;
-    private List<String> bundleLocations = new ArrayList<String>();
-    
-    public ScopeImpl(String name) {
-        this.name = name;
-        this.id = getId();
+		public UnmodifiableSharePolicyMap(Map<String, List<SharePolicy>> map) {
+			this.map = map;
     }
     
-    public ScopeImpl(String name, String location) {
-        this.name = name;
-        this.location = location;
-        this.id = getId();
-    }
-    // assume this constructor would be used to construct the root scope
-    public ScopeImpl(String name, BundleContext context) {
-        this(name);
+		public void clear() {
+			throw new UnsupportedOperationException();
+    }
 
-        this.context = context;
-        if (name.equals("root")) {
-            bundles.addAll(Arrays.asList(context.getBundles()));
+		public boolean containsKey(Object key) {
+			return map.containsKey(key);
         }
 
-     
-        // let's use a bundle tracker to dynamically update the bundle list - need to wait on the resolution of the new rfc 138 bug
-        // we cannot really use bundle tracker because the hooks may not work here
-        //bt = new BundleTracker(context, Bundle.INSTALLED | Bundle.UNINSTALLED, new ScopeBundleTrackerCustomizer());
-        //bt.open();
+		public boolean containsValue(Object value) {
+			return map.containsValue(value);
     }
     
-    public void destroy() {
-        /*if (bt != null) {
-            bt.close();
-        }*/
+		public Set<java.util.Map.Entry<String, List<SharePolicy>>> entrySet() {
+			Set<Map.Entry<String, List<SharePolicy>>> result = new HashSet<Map.Entry<String, List<SharePolicy>>>(map.size());
+			for (final Map.Entry<String, List<SharePolicy>> entry : map.entrySet()) {
+				result.add(new Map.Entry<String, List<SharePolicy>>() {
+					public String getKey() {
+						return entry.getKey();
     }
     
-    public Collection<Bundle> getBundles() {
-        return Collections.unmodifiableCollection(bundles);
+					public List<SharePolicy> getValue() {
+						return entry.getValue();
     }
     
-    protected Collection<String> getToBeInstalledBundleLocation() {
-        return bundleLocations;
+					public List<SharePolicy> setValue(List<SharePolicy> object) {
+						throw new UnsupportedOperationException();
+					}
+				});
+			}
+			return Collections.unmodifiableSet(result);
     }
     
-    protected void clearBundleLocations() {
-        bundleLocations = new ArrayList<String>();
+		public List<SharePolicy> get(Object key) {
+			List<SharePolicy> result = map.get(key);
+			return result == null ? null : Collections.unmodifiableList(result);
     }
     
-    protected Collection<Bundle> getModifiableBundles() {
-        return this.bundles;
+		public boolean isEmpty() {
+			return map.isEmpty();
     }
 
-    public Collection<Scope> getChildren() {
-        return Collections.unmodifiableList(children);
+		public Set<String> keySet() {
+			return Collections.unmodifiableSet(map.keySet());
     }
     
-    protected Collection<Scope> getModifiableChildren() {
-        return this.children;
+		public List<SharePolicy> put(String key, List<SharePolicy> value) {
+			throw new UnsupportedOperationException();
     }
 
-    public String getName() {
-        return this.name;
+		public void putAll(Map<? extends String, ? extends List<SharePolicy>> map) {
+			throw new UnsupportedOperationException();
     }
 
-    public Map<String, List<SharePolicy>> getSharePolicies(String type) {
-        if (type.equals(SharePolicy.TYPE_IMPORT)) {
-            return Collections.unmodifiableMap(this.importPolicies);
-        } else if (type.equals(SharePolicy.TYPE_EXPORT)) {
-            return Collections.unmodifiableMap(this.exportPolicies);
+		public List<SharePolicy> remove(Object key) {
+			throw new UnsupportedOperationException();
         }
-        throw new IllegalArgumentException("Valid Types are : " + SharePolicy.TYPE_EXPORT + " & " + 
-                SharePolicy.TYPE_IMPORT + " Invalid type: " + type);
         
+		public int size() {
+			return map.size();
     }
     
-    protected Map<String, List<SharePolicy>> getModifiableSharePolicies(String type) {
-        if (type.equals(SharePolicy.TYPE_IMPORT)) {
-            return this.importPolicies;
-        } else if (type.equals(SharePolicy.TYPE_EXPORT)) {
-            return this.exportPolicies;
+		public Collection<List<SharePolicy>> values() {
+			return Collections.unmodifiableCollection(map.values());
         }
-        throw new IllegalArgumentException("Valid Types are : " + SharePolicy.TYPE_EXPORT + " & " + 
-                SharePolicy.TYPE_IMPORT + " Invalid type: " + type);
     }
 
-    private class ScopeBundleTrackerCustomizer implements BundleTrackerCustomizer {
+	private static long lastId = -1;
 
-        public Object addingBundle(Bundle bundle, BundleEvent event) {
-            if (event.getType() == BundleEvent.INSTALLED) {
-                bundles.add(bundle);
-            } else if (event.getType() == BundleEvent.UNINSTALLED) {
-                bundles.remove(bundle);
+	private static synchronized long nextId() {
+		if (lastId == Long.MAX_VALUE)
+			throw new IllegalStateException("The next ID would exceed Long.MAX_VALUE");
+		return ++lastId;
             }
             
-            return bundle;
-        }
+	volatile boolean updating;
 
-        public void modifiedBundle(Bundle bundle, BundleEvent event,
-                Object object) {
-            if (event.getType() == BundleEvent.INSTALLED) {
-                bundles.add(bundle);
-            } else if (event.getType() == BundleEvent.UNINSTALLED) {
-                bundles.remove(bundle);
-            }
+	long lastUpdate;
             
-        }
+	final BundleContext bundleContext;
+	final Set<Bundle> bundles = Collections.synchronizedSet(new HashSet<Bundle>());
+	final Set<Scope> children = Collections.synchronizedSet(new HashSet<Scope>());
+	final Map<String, List<SharePolicy>> exportPolicies = Collections.synchronizedMap(new HashMap<String, List<SharePolicy>>());
+	final Map<String, List<SharePolicy>> importPolicies = Collections.synchronizedMap(new HashMap<String, List<SharePolicy>>());
 
-        public void removedBundle(Bundle bundle, BundleEvent event,
-                Object object) {
-            if (event.getType() == BundleEvent.INSTALLED) {
-                bundles.add(bundle);
-            } else if (event.getType() == BundleEvent.UNINSTALLED) {
-                bundles.remove(bundle);
-            }          
+	private final long id;
+	private final String location;
+	private final String name;
+	private final Scope parent;
+	
+	public ScopeImpl(
+			BundleContext bundleContext,
+			String name,
+			String location,
+			Scope parent) {
+		this.bundleContext = bundleContext;
+		this.name = name;
+		this.location = location;
+		this.parent = parent;
+		id = nextId();
         }
         
+	public Collection<Bundle> getBundles() {
+		return Collections.unmodifiableCollection(bundles);
     }
 
-    public long getId() {
-        if (id == 0) {
-            id = IdGenerator.next();
+	public Collection<Scope> getChildren() {
+		return Collections.unmodifiableCollection(children);
         } 
         
+	public long getId() {
         return id;
     }
     
-    private static class IdGenerator {
-        static long newId;       
+	public String getLocation() {
+		return location;
+	}
         
-        protected static synchronized long next() {
-            newId++;
-            return newId;
+	public String getName() {
+		return name;
         }
+	
+	public Scope getParent() {
+		return parent;
     }
 
-    public String getLocation() {
-        return this.location;
+	public Map<String, List<SharePolicy>> getSharePolicies(String type) {
+		if (SharePolicy.TYPE_EXPORT.equals(type))
+			return new UnmodifiableSharePolicyMap(exportPolicies);
+		else if (SharePolicy.TYPE_IMPORT.equals(type))
+			return new UnmodifiableSharePolicyMap(importPolicies);
+		throw new IllegalArgumentException(type);
     }
     
+	public ScopeUpdate newScopeUpdate() {
+		return ScopeUpdateImpl.newInstance(this);
+	}
 }
diff --git a/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeManager.java b/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeManager.java
index e69de29b..e3934127 100644
--- a/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeManager.java
+++ b/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeManager.java
@@ -0,0 +1,340 @@
+package org.apache.aries.subsystem.scope.impl;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.aries.subsystem.scope.Scope;
+import org.apache.aries.subsystem.scope.SharePolicy;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.BundleEvent;
+import org.osgi.framework.BundleException;
+import org.osgi.framework.ServiceEvent;
+import org.osgi.framework.ServiceReference;
+import org.osgi.framework.ServiceRegistration;
+import org.osgi.framework.hooks.service.ListenerHook.ListenerInfo;
+import org.osgi.framework.wiring.BundleCapability;
+import org.osgi.framework.wiring.BundleRequirement;
+import org.osgi.framework.wiring.BundleRevision;
+
+public class ScopeManager {
+	static final Map<Bundle, ScopeImpl> bundleToScope = Collections.synchronizedMap(new HashMap<Bundle, ScopeImpl>());
+	static final Map<String, ScopeImpl> installingBundleToScope = Collections.synchronizedMap(new HashMap<String, ScopeImpl>());
+	
+	final ScopeImpl rootScope;
+	
+	private final BundleContext bundleContext;
+	
+	public ScopeManager(BundleContext bundleContext) throws BundleException {
+		this.bundleContext = bundleContext;
+		rootScope = new ScopeImpl(bundleContext, "root", null, null);
+	}
+	
+	public Scope getRootScope() {
+		return rootScope;
+	}
+	
+	public EventHook newEventHook() {
+		return new EventHook();
+	}
+	
+	public EventListenerHook newEventListenerHook() {
+		return new EventListenerHook();
+	}
+	
+	public org.osgi.framework.hooks.bundle.FindHook newBundleFindHook() {
+		return new BundleFindHook();
+	}
+	
+	public ResolverHook newResolverHook() {
+		return new ResolverHook();
+	}
+	
+	public ResolverHookFactory newResolverHookFactory() {
+		return new ResolverHookFactory();
+	}
+	
+	public ServiceFactory newServiceFactory() {
+		return new ServiceFactory();
+	}
+	
+	public org.osgi.framework.hooks.service.FindHook newServiceFindHook() {
+		return new ServiceFindHook();
+	}
+	
+	private class EventHook implements org.osgi.framework.hooks.bundle.EventHook {
+		public void event(BundleEvent event, Collection<BundleContext> contexts) {
+			int type = event.getType();
+			if (type == BundleEvent.INSTALLED)
+				handleInstalledEvent(event);
+			handleAnyEvent(event, contexts);
+			if (type == BundleEvent.UNINSTALLED)
+				handleUninstalledEvent(event);
+		}
+		
+		private void handleAnyEvent(BundleEvent event, Collection<BundleContext> contexts) {
+			// All bundles may see system bundle lifecycle changes.
+			if (event.getBundle().getBundleId() != 0) {
+				// Otherwise, only bundles in the same scope as the bundle undergoing
+				// the state change may see the event.
+				ScopeImpl scope = bundleToScope.get(event.getBundle());
+				Collection<Bundle> bundles = scope.getBundles();
+				for (Iterator<BundleContext> i = contexts.iterator(); i.hasNext();) {
+					BundleContext bc = i.next();
+					if (!bundles.contains(bc.getBundle()))
+						i.remove();
+				}
+			}
+		}
+		
+		private void handleInstalledEvent(BundleEvent event) {
+			processOriginBundleOnInstall(event);
+			processSourceBundleOnInstall(event);
+		}
+		
+		private void handleUninstalledEvent(BundleEvent event) {
+			processSourceBundleOnUninstall(event);
+		}
+		
+		private void processOriginBundleOnInstall(BundleEvent event) {
+			Bundle b = event.getOrigin();
+			// There's a brief window when Scope Admin is initializing where it's
+			// possible for the origin bundle to not be in a scope.
+			if (bundleToScope.get(b) == null) {
+				bundleToScope.put(b, rootScope);
+				rootScope.bundles.add(b);
+			}
+		}
+		
+		private void processSourceBundleOnInstall(BundleEvent event) {
+			Bundle b = event.getBundle();
+			// If the installer is not Scope Admin, add the installed bundle
+			// to the installer's scope.
+			if (event.getOrigin().getBundleId() != bundleContext.getBundle().getBundleId()) {
+				ScopeImpl s = bundleToScope.get(event.getOrigin());
+				bundleToScope.put(b, s);
+				s.bundles.add(b);
+			}
+			else {
+				ScopeImpl s = installingBundleToScope.remove(b.getLocation());
+				bundleToScope.put(b, s);
+				s.bundles.add(b);
+			}
+		}
+		
+		private void processSourceBundleOnUninstall(BundleEvent event) {
+			Bundle b = event.getBundle();
+			ScopeImpl s = bundleToScope.remove(b);
+			// There's a brief window when Scope Admin is initializing where it's
+			// possible for the scope to be null.
+			if (s != null) {
+				s.bundles.remove(b);
+			}
+		}
+	}
+	
+	private class BundleFindHook implements org.osgi.framework.hooks.bundle.FindHook {
+		public void find(BundleContext context, Collection<Bundle> bundles) {
+			Scope scope = bundleToScope.get(context.getBundle());
+			// A bundle may only see other bundles within its scope.
+			bundles.retainAll(scope.getBundles());
+		}
+	}
+	
+	private class EventListenerHook implements org.osgi.framework.hooks.service.EventListenerHook {
+		public void event(ServiceEvent event, Map<BundleContext, Collection<ListenerInfo>> listeners) {
+			Bundle bundle = event.getServiceReference().getBundle();
+			ScopeImpl scope = bundleToScope.get(bundle);
+			for (Iterator<BundleContext> i = listeners.keySet().iterator(); i.hasNext();) {
+				if (!scope.getBundles().contains(i.next().getBundle()))
+					i.remove();
+			}
+		}
+	}
+	
+	private class ResolverHook implements org.osgi.framework.hooks.resolver.ResolverHook {
+		public void end() {
+		}
+		
+		public void filterMatches(BundleRequirement requirement, Collection<BundleCapability> candidates) {
+			for (Iterator<BundleCapability> i = candidates.iterator(); i.hasNext();) {
+				if (filterMatch(requirement, i.next()))
+					i.remove();
+			}
+		}
+		
+		public void filterResolvable(Collection<BundleRevision> candidates) {
+			for (Iterator<BundleRevision> i = candidates.iterator(); i.hasNext();) {
+				BundleRevision candidate = i.next();
+				ScopeImpl scope = bundleToScope.get(candidate.getBundle());
+				if (scope.updating)
+					i.remove();
+			}
+		}
+
+		public void filterSingletonCollisions(BundleCapability singleton, Collection<BundleCapability> collisionCandidates) {
+			ScopeImpl scope = bundleToScope.get(singleton.getRevision().getBundle());
+			for (Iterator<BundleCapability> i = collisionCandidates.iterator(); i.hasNext();) {
+				BundleCapability collisionCandidate = i.next();
+				if (!scope.getBundles().contains(collisionCandidate.getRevision().getBundle())) {
+					i.remove();
+				}
+			}
+		}
+		
+		private boolean filterMatch(BundleRequirement requirement, BundleCapability capability) {
+			Scope scope = bundleToScope.get(requirement.getRevision().getBundle());
+			if (scope.getBundles().contains(capability.getRevision().getBundle()))
+				return false;
+			if (scope.getId() < bundleToScope.get(capability.getRevision().getBundle()).getId()) {
+				if (matchesDescendants(scope.getChildren(), capability, null))
+					return false;
+			}
+			return !matchesAncestry(scope, capability);
+		}
+		
+		private boolean matchesPolicyAndContainsBundle(Scope scope, BundleCapability capability, String sharePolicyType) {
+			if (matchesPolicy(scope, capability, sharePolicyType)) {
+				if (scope.getBundles().contains(capability.getRevision().getBundle())) {
+					return true;
+				}
+			}
+			return false;
+		}
+		
+		private boolean matchesPolicy(Scope scope, BundleCapability capability, String sharePolicyType) {
+			List<SharePolicy> policies = scope.getSharePolicies(sharePolicyType).get(capability.getNamespace());
+			if (policies == null) return false;
+			for (SharePolicy policy : policies) {
+				if (policy.getFilter().matches(capability.getAttributes())) {
+					return true;
+				}
+			}
+			return false;
+		}
+		
+		private boolean matchesAncestry(Scope scope, BundleCapability capability) {
+			if (matchesPolicy(scope, capability, SharePolicy.TYPE_IMPORT)) {
+				Scope parent = scope.getParent();
+				if (parent != null) {
+					if (parent.getBundles().contains(capability.getRevision().getBundle())) 
+						return true;
+					if (matchesDescendants(parent.getChildren(), capability, scope))
+						return true;
+					return matchesAncestry(parent, capability);
+				}
+			}
+			return false;
+		}
+		
+		private boolean matchesDescendant(Scope child, BundleCapability capability) {
+			if (matchesPolicyAndContainsBundle(child, capability, SharePolicy.TYPE_EXPORT))
+				return true;
+			return matchesDescendants(child.getChildren(), capability, null);
+		}
+		
+		private boolean matchesDescendants(Collection<Scope> children, BundleCapability capability, Scope skip) {
+			for (Scope child : children) {
+				if (child.equals(skip))
+					continue;
+				if (matchesDescendant(child, capability)) {
+					return true;
+				}
+			}
+			return false;
+		}
+	}
+	
+	private class ResolverHookFactory implements org.osgi.framework.hooks.resolver.ResolverHookFactory {
+		public ResolverHook begin(java.util.Collection<BundleRevision> triggers) {
+			return new ResolverHook();
+		}
+	}
+	
+	private class ServiceFactory implements org.osgi.framework.ServiceFactory<Scope> {
+		public Scope getService(Bundle b, ServiceRegistration<Scope> sr) {
+			ScopeImpl scope = bundleToScope.get(b);
+			if (scope == null) {
+				scope = rootScope;
+				bundleToScope.put(b, scope);
+			}
+			return scope;
+		}
+
+		public void ungetService(Bundle b, ServiceRegistration<Scope> sr, Scope s) {
+		}
+	}
+	
+	private class ServiceFindHook implements org.osgi.framework.hooks.service.FindHook {
+		public void find(BundleContext context, String name, String filter, boolean allServices, Collection<ServiceReference<?>> references) {
+			// System bundle can see all services.
+			if (context.getBundle().getBundleId() == 0) return;
+			for (Iterator<ServiceReference<?>> i = references.iterator(); i.hasNext();) {
+				if (filterMatch(context, i.next()))
+					i.remove();
+			}
+		}
+		
+		private boolean filterMatch(BundleContext context, ServiceReference<?> reference) {
+			Scope scope = bundleToScope.get(context.getBundle());
+			if (scope.getBundles().contains(reference.getBundle()))
+				return false;
+			if (scope.getId() < bundleToScope.get(reference.getBundle()).getId()) {
+				if (matchesDescendants(scope.getChildren(), reference))
+					return false;
+			}
+			return !matchesAncestry(scope, reference);
+		}
+		
+		private boolean matchesPolicyAndContainsBundle(Scope scope, ServiceReference<?> reference, String sharePolicyType) {
+			if (matchesPolicy(scope, reference, sharePolicyType)) {
+				if (scope.getBundles().contains(reference.getBundle())) {
+					return true;
+				}
+			}
+			return false;
+		}
+		
+		private boolean matchesPolicy(Scope scope, ServiceReference<?> reference, String sharePolicyType) {
+			List<SharePolicy> policies = scope.getSharePolicies(sharePolicyType).get("scope.share.service");
+			if (policies == null) return false;
+			for (SharePolicy policy : policies) {
+				if (policy.getFilter().match(reference)) {
+					return true;
+				}
+			}
+			return false;
+		}
+		
+		private boolean matchesAncestry(Scope scope, ServiceReference<?> reference) {
+			if (matchesPolicy(scope, reference, SharePolicy.TYPE_IMPORT)) {
+				Scope parent = scope.getParent();
+				if (parent != null) {
+					if (parent.getBundles().contains(reference.getBundle())) 
+						return true;
+					return matchesAncestry(parent, reference);
+				}
+			}
+			return false;
+		}
+		
+		private boolean matchesDescendant(Scope child, ServiceReference<?> reference) {
+			if (matchesPolicyAndContainsBundle(child, reference, SharePolicy.TYPE_EXPORT))
+				return true;
+			return matchesDescendants(child.getChildren(), reference);
+		}
+		
+		private boolean matchesDescendants(Collection<Scope> children, ServiceReference<?> reference) {
+			for (Scope child : children) {
+				if (matchesDescendant(child, reference)) {
+					return true;
+				}
+			}
+			return false;
+		}
+	}
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeUpdateImpl.java b/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeUpdateImpl.java
index 14d5fdf2..ab8b5c42 100644
--- a/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeUpdateImpl.java
+++ b/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/impl/ScopeUpdateImpl.java
@@ -1,336 +1,213 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
 package org.apache.aries.subsystem.scope.impl;
 
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileReader;
-import java.io.IOException;
-import java.net.URL;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
+import java.util.Set;
 
 import org.apache.aries.subsystem.scope.InstallInfo;
 import org.apache.aries.subsystem.scope.Scope;
-import org.apache.aries.subsystem.scope.ScopeAdmin;
 import org.apache.aries.subsystem.scope.ScopeUpdate;
 import org.apache.aries.subsystem.scope.SharePolicy;
 import org.osgi.framework.Bundle;
-import org.osgi.framework.BundleContext;
 import org.osgi.framework.BundleException;
-import org.osgi.framework.ServiceReference;
-import org.osgi.framework.ServiceRegistration;
-import org.osgi.service.condpermadmin.ConditionInfo;
-import org.osgi.service.condpermadmin.ConditionalPermissionAdmin;
-import org.osgi.service.condpermadmin.ConditionalPermissionInfo;
-import org.osgi.service.condpermadmin.ConditionalPermissionUpdate;
-import org.osgi.service.permissionadmin.PermissionInfo;
 
 public class ScopeUpdateImpl implements ScopeUpdate {
-
-    private ScopeImpl scope;
-    private List<InstallInfo> installInfo = new ArrayList<InstallInfo>();
-    private List<ScopeUpdate> children = new ArrayList<ScopeUpdate>();
-    private List<Scope> tbrChildren = new ArrayList<Scope>();
-    private BundleContext bc;
-    private static ConcurrentHashMap<Long, ServiceRegistration> srs = new ConcurrentHashMap<Long, ServiceRegistration>();
-    private final static PermissionInfo[] denyInfo = 
-    {
-        new PermissionInfo("org.osgi.framework.ServicePermission", "org.osgi.service.condpermadmin.ConditionalPermissionAdmin", "*"),
-        new PermissionInfo("org.osgi.framework.ServicePermission", "org.osgi.service.permissionadmin.PermissionAdmin", "*"),
-        new PermissionInfo("org.osgi.framework.ServicePermission", "org.osgi.framework.hooks.service.*", "*"),
-        new PermissionInfo("org.osgi.framework.ServicePermission", "org.osgi.service.packageadmin.PackageAdmin", "*")
-    };
-    
-    private final static PermissionInfo[] allowInfo = {
-        new PermissionInfo("org.osgi.framework.PackagePermission", "*", "import"),
-        new PermissionInfo("org.osgi.framework.BundlePermission", "*", "host,provide,fragment"),
-    };
-    
-    private final static PermissionInfo[] defaultAllowInfo = {
-            new PermissionInfo("java.lang.RuntimePermission", "loadLibrary.*", "*"),
-            new PermissionInfo("java.lang.RuntimePermission", "queuePrintJob", "*"),
-            new PermissionInfo("java.net.SocketPermission", "*", "connect"),
-            new PermissionInfo("java.util.PropertyPermission", "*", "read"),
-            new PermissionInfo("org.osgi.framework.PackagePermission", "*", "exportonly,import"),
-            new PermissionInfo("org.osgi.framework.ServicePermission", "*", "get,register"),
-        };
-    
-    public ScopeUpdateImpl(ScopeImpl scope, BundleContext bc) {
-        this.scope = scope;
-        this.bc = bc;
+	public static ScopeUpdateImpl newInstance(ScopeImpl scope) {
+		ScopeUpdateImpl scopeUpdate = new ScopeUpdateImpl(null, null, scope, null);
+		for (Scope child : scopeUpdate.scope.getChildren()) {
+			scopeUpdate.children.add(new ScopeUpdateImpl(null, null, (ScopeImpl)child, scopeUpdate));
     }
-    
-    public ScopeUpdateImpl(ScopeImpl scope, List<InstallInfo> installInfo) {
-        this.scope = scope;
-        this.installInfo = installInfo;
+		return scopeUpdate;
     }
     
-    
-    public ScopeUpdateImpl(ScopeImpl scope, List<InstallInfo> installInfo, List<ScopeUpdate> children) {
-        this.scope = scope;
-        this.installInfo = installInfo;
-        this.children = children;
+	public static ScopeUpdateImpl newInstance(String name, String location, ScopeUpdateImpl parent) {
+		return new ScopeUpdateImpl(name, location, null, parent);
     }
     
-    public ScopeImpl getScope() {
-        return this.scope;
+	private static long lastId;
+	private static synchronized long nextId() {
+		if (lastId == Long.MAX_VALUE)
+			throw new IllegalStateException("The next ID would exceed Long.MAX_VALUE");
+		return ++lastId;
+	}
+	
+	private final Set<Bundle> bundles;
+	private final List<InstallInfo> bundlesToInstall = new ArrayList<InstallInfo>();
+	private final Set<ScopeUpdate> children = new HashSet<ScopeUpdate>();
+	private final Map<String, List<SharePolicy>> exportPolicies;
+	private final long id = nextId();
+	private final Map<String, List<SharePolicy>> importPolicies;
+	private final ScopeUpdateImpl parent;
+	private final ScopeImpl scope;
+	
+	private ScopeUpdateImpl(
+			String name,
+			String location,
+			ScopeImpl scope,
+			ScopeUpdateImpl parent) {
+		if (scope == null)
+			scope = new ScopeImpl(parent.scope.bundleContext, name, location, parent.scope);
+		this.scope = scope;
+		this.parent = parent;
+		bundles = new HashSet<Bundle>(scope.getBundles());
+		exportPolicies = new HashMap<String, List<SharePolicy>>(scope.getSharePolicies(SharePolicy.TYPE_EXPORT));
+		importPolicies = new HashMap<String, List<SharePolicy>>(scope.getSharePolicies(SharePolicy.TYPE_IMPORT));
     }
     
     public boolean commit() throws BundleException {
-        // process installedBundle
-        boolean success = false;
-        int numException = 0;
-        
-        List<Bundle> installedBundle = new ArrayList<Bundle>();
-        for (InstallInfo info : this.installInfo) {
-            URL url = info.getContent();
-            String loc = info.getLocation();
-            Bundle b;
-            Bundle oldB = alreadyInstalled(info);
-            
-            // in case of modify, uninstall the previous bundle first.
-            if (oldB != null) {
-                oldB.uninstall();
-                getBundles().remove(oldB);
-            }
-            
-            try {
-                // prefix location with scope-scopeId:
-                loc = "scope-" + this.getScope().getId() + ": " + loc;
-                scope.getToBeInstalledBundleLocation().add(loc);
-                b = bc.installBundle(loc, url.openStream());
-                installedBundle.add(b);
-            } catch (IOException e) {
-                // clear bundle location off the list.
-                scope.getToBeInstalledBundleLocation().remove(loc);
-                numException++;
-                throw new BundleException("problem when opening url " + e.getCause());
-            }
-            scope.getToBeInstalledBundleLocation().remove(loc);
+		if (parent != null)
+			throw new IllegalStateException("Only the root ScopeUpdate may be committed");
+		return commit0();
         }
         
-        // clear bundle location list since all install is finished.
-        scope.clearBundleLocations();
-        
-        // update bundle list for the scope
-        getBundles().addAll(installedBundle);
-
-        
-        // Sets up Java 2 security permissions for the application
-        try {
-          boolean suc = setupJava2Security(scope.getLocation());
-          if (!suc) {
-              numException++;
-          }
-        } catch (BundleException ex) {
-            numException++;
-            throw ex;
-        }
-        
-        // process child scopes
-        Collection<ScopeUpdate> children = getChildren();
-        for (ScopeUpdate child : children) {
+	public Collection<Bundle> getBundles() {
+		return bundles;
+	}
             
-            ScopeUpdateImpl scopeUpdateImpl = (ScopeUpdateImpl)child;
-            ServiceRegistration sr = null;
-            try {
-                // also create a new scopeAdmin as scopeadmin and scope is 1-1 relationship
-                ScopeAdminImpl newScopeAdmin = new ScopeAdminImpl(this.scope, scopeUpdateImpl.getScope());
+	public List<InstallInfo> getBundlesToInstall() {
+		return bundlesToInstall;
+	}
                 
+	public Collection<ScopeUpdate> getChildren() {
+		return children;
+	}
                 
-                sr = this.bc.registerService(ScopeAdmin.class.getName(), 
-                        newScopeAdmin, 
-                        DictionaryBuilder.build("ScopeName", child.getName(), "ScopeId", scopeUpdateImpl.getScope().getId()));
-                srs.put(scopeUpdateImpl.getScope().getId(), sr);
-                child.commit();
-            } catch (BundleException e) {
-                if (sr != null) {
-                    sr.unregister();
-                    srs.remove(scopeUpdateImpl.getScope().getId());
+	public String getName() {
+		return scope.getName();
                 }
-                numException++;
-                throw new BundleException("problem when commiting child scope: " + child.getName() + " " + e.getCause());
+	
+	public Scope getScope() {
+		return scope;
             }
             
-
-            // update current scope to specify the children.
-            getExistingChildren().add(scopeUpdateImpl.getScope());
+	public Map<String, List<SharePolicy>> getSharePolicies(String type) {
+		if (SharePolicy.TYPE_EXPORT.equals(type))
+			return exportPolicies;
+		else if (SharePolicy.TYPE_IMPORT.equals(type))
+			return importPolicies;
+		throw new IllegalArgumentException(type);
+	}
+
+	public ScopeUpdate newChild(String name) {
+		return newChild(name, null);
+	}
             
-
+	public ScopeUpdate newChild(String name, String location) {
+		return ScopeUpdateImpl.newInstance(name, location, this);
+	}
+
+	private void addBundles() {
+		for (Bundle b : getBundles()) {
+			if (!getScope().getBundles().contains(b)) {
+				if (contains(b, this)) {
+					throw new IllegalStateException("Bundle " + b.getSymbolicName() + " being added to scope " + getName() + " but already exists in another scope");
+				}
+				scope.bundles.add(b);
+				ScopeManager.bundleToScope.put(b, scope);
         }
-        // remove any scopes in to be removed children list
-        for (Scope scope : tbrChildren) {
-            removeChildScope(scope); 
         }
-        
-        return numException == 0 ? true : false;
     }
      
-    private boolean setupJava2Security(String location) throws BundleException {
-        // obtain security manager
-        SecurityManager secMan = System.getSecurityManager();
-        
-        if (secMan == null) {
+	private boolean commit0() throws BundleException {
+		if (scope.lastUpdate > id)
+			return false;
+		scope.updating = true;
+		for (ScopeUpdate child : children) {
+			if (!((ScopeUpdateImpl)child).commit0())
+				return false;
+		}
+		removeBundles();
+		addBundles();
+		installBundles();
+		uninstallScopes();
+		installScopes();
+		updateSharePolicies();
+		scope.lastUpdate = id;
+		scope.updating = false;
             return true;
         }
         
-        ServiceReference permRef = bc.getServiceReference(ConditionalPermissionAdmin.class.getName());
-
-        ConditionalPermissionAdmin permAdmin = (ConditionalPermissionAdmin) bc.getService(permRef);
-        ConditionalPermissionUpdate update = permAdmin.newConditionalPermissionUpdate();
-
-        List<ConditionalPermissionInfo> infos = update.getConditionalPermissionInfos();
-        //infos.clear();
-
-        // set up the conditionInfo
-        String scopePrefix = "scope-" + this.scope.getId() + "-*";
-        ConditionInfo[] conditionInfo = new ConditionInfo[] {new ConditionInfo("org.osgi.service.condpermadmin.BundleLocationCondition", new String[]{scopePrefix})}; 
-        // Set up permissions which are common to all applications
-        infos.add(permAdmin.newConditionalPermissionInfo(null, conditionInfo, denyInfo, "deny"));
-        infos.add(permAdmin.newConditionalPermissionInfo(null, conditionInfo, allowInfo, "allow"));
-
-        // exact scope permission from scope installation loc
-        // TODO: need to figure out the permFile from the scope/subsystem, META-INF/permissions.perm
-        // Also add code to handle the permission file
-        File permFile = new File("META-INF/permissions.perm");
-        if (!permFile.exists()) { 
-            /*
-             * If there is no specific permissions file provided, the following 
-             * default permissions are provided.
-             */        
-            infos.add(permAdmin.newConditionalPermissionInfo(null, conditionInfo, defaultAllowInfo, "allow"));
-
+	private boolean contains(Bundle bundle, ScopeUpdateImpl scopeUpdate) {
+		// Recurse to the top of the tree and then perform a depth-first search.
+		return parent == null ? contains0(bundle, scopeUpdate) : parent.contains(bundle, scopeUpdate);
         }
         
-        if (!update.commit()) {
+	private boolean contains0(Bundle bundle, ScopeUpdateImpl scopeUpdate) {
+		if (!equals(scopeUpdate) && bundles.contains(bundle))
+			return true;
+		// Depth-first search.
+		for (ScopeUpdate child : children) {
+			if (((ScopeUpdateImpl)child).contains0(bundle, scopeUpdate)) return true;
+		}
             return false;
         }
         
-        return true;
-        
-        
+	private void installBundles() throws BundleException {
+		for (InstallInfo installInfo : getBundlesToInstall()) {
+			ScopeManager.installingBundleToScope.put(installInfo.getLocation(), scope);
+			scope.bundleContext.installBundle(installInfo.getLocation(), installInfo.getContent());
+		}
     }
 
-    // check if the install info is already installed in the scope
-    private Bundle alreadyInstalled(InstallInfo info) {
-        String loc = info.getLocation();
-        
-        Collection<Bundle> bundles = scope.getBundles();
-        
-        for (Bundle b : bundles) {
-            if (b.getLocation().equals(loc)) {
-                return b;
+	private void installScopes() {
+		for (ScopeUpdate child : getChildren()) {
+			if (!getScope().getChildren().contains(child.getScope())) {
+				scope.children.add(child.getScope());
             }
         }
-        
-        return null;
     }
 
-    public Collection<Bundle> getBundles() {
-        return scope.getModifiableBundles();
+	private void removeBundles() throws BundleException {
+		Collection<Bundle> bundles = new HashSet<Bundle>(scope.getBundles());
+		for (Bundle b : bundles) {
+			if (!getBundles().contains(b)) {
+				if (!contains(b, null)) {
+					b.uninstall();
     }
-
-    public List<InstallInfo> getBundlesToInstall() {
-        return this.installInfo;
+				else {
+					scope.bundles.remove(b);
     }
-    
-    /*public List<InstallInfo> getBundlesToDelete() {
-        return this.installInfo;
     }
-    
-    public List<InstallInfo> getBundlesToModify() {
-        return this.installInfo;
-    }*/
-
-    public Collection<ScopeUpdate> getChildren() {
-        return this.children;
     }
-    
-    public Collection<Scope> getExistingChildren() {
-        return scope.getModifiableChildren();
     }
 
-    public Collection<Scope> getToBeRemovedChildren() {
-        return this.tbrChildren;
+	private void uninstallScopes() throws BundleException {
+		for (Iterator<Scope> i = scope.children.iterator(); i.hasNext();) {
+			Scope child = i.next();
+			boolean found = false;
+			for (ScopeUpdate su : getChildren()) {
+				if (child.equals(su.getScope())) {
+					found = true;
+					break;
     }
-    
-    // this would remove the child off the scope and uninstall the scope.
-    private void removeChildScope(Scope sc) {
-        removeChildScope(sc.getId());
     }
-    // this would remove the child off the scope and uninstall the scope.
-    private void removeChildScope(long id) {
-        Collection<Scope> scopes =  scope.getModifiableChildren();
-        for (Scope scope : scopes) {
-            if (scope.getId() == id) {
-                for (Bundle b : scope.getBundles()) {
-                    try {
+			if (!found) {
+				Collection<Bundle> bundles = new HashSet<Bundle>(child.getBundles());
+				for (Bundle b : bundles) {
                         b.uninstall();
-                    } catch (BundleException e) {
-                        // TODO Auto-generated catch block
-                        e.printStackTrace();
                     }
-                }
-                scopes.remove(scope);
-                // unregister the associated ScopeAdmin in service registry
-                ServiceRegistration sr = srs.get(id);
-                if (sr != null) {
-                    sr.unregister();
-                    srs.remove(id);
-                } else {
-                    throw new NullPointerException ("Unable to find the ScopeAdmin service Registration in the map");
-                }
-                return;
+				i.remove();
             }
         }
     }
     
-    public String getName() {
-        return scope.getName();
+	private void updateSharePolicies() {
+		updateExportSharePolicies(getSharePolicies(SharePolicy.TYPE_EXPORT));
+		updateImportSharePolicies(getSharePolicies(SharePolicy.TYPE_IMPORT));
     }
 
-    public Map<String, List<SharePolicy>> getSharePolicies(String type) {
-        return scope.getModifiableSharePolicies(type);
+	private void updateExportSharePolicies(Map<String, List<SharePolicy>> exportPolicies) {
+		scope.exportPolicies.clear();
+		scope.exportPolicies.putAll(exportPolicies);
     }
 
-    public ScopeUpdate newChild(String name) {
-        ScopeImpl newScope = new ScopeImpl(name);
-
-        // create scope update
-        ScopeUpdate scopeUpdate = new ScopeUpdateImpl(newScope, this.bc);
-        this.children.add(scopeUpdate);
-        return scopeUpdate;
+	private void updateImportSharePolicies(Map<String, List<SharePolicy>> importPolicies) {
+		scope.importPolicies.clear();
+		scope.importPolicies.putAll(importPolicies);
     }
-
-    public ScopeUpdate newChild(String name, String location) {
-        ScopeImpl newScope = new ScopeImpl(name, location);
-
-        // create scope update
-        ScopeUpdate scopeUpdate = new ScopeUpdateImpl(newScope, this.bc);
-        this.children.add(scopeUpdate);
-        return scopeUpdate;
     }
-}
diff --git a/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/internal/Activator.java b/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/internal/Activator.java
index 5dd0f91d..0b6925ef 100644
--- a/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/internal/Activator.java
+++ b/aries/trunk/subsystem/subsystem-scope-impl/src/main/java/org/apache/aries/subsystem/scope/internal/Activator.java
@@ -1,91 +1,75 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
 package org.apache.aries.subsystem.scope.internal;
 
 import java.util.ArrayList;
-import java.util.Dictionary;
-import java.util.List;
+import java.util.Arrays;
+import java.util.Collection;
 
-import org.apache.aries.subsystem.scope.ScopeAdmin;
-import org.apache.aries.subsystem.scope.impl.ScopeAdminServiceFactory;
+import org.apache.aries.subsystem.scope.Scope;
+import org.apache.aries.subsystem.scope.ScopeUpdate;
+import org.apache.aries.subsystem.scope.impl.ScopeManager;
 import org.osgi.framework.BundleActivator;
 import org.osgi.framework.BundleContext;
-import org.osgi.framework.ServiceFactory;
 import org.osgi.framework.ServiceRegistration;
+import org.osgi.framework.hooks.bundle.EventHook;
+import org.osgi.framework.hooks.resolver.ResolverHookFactory;
+import org.osgi.framework.hooks.service.EventListenerHook;
 
 public class Activator implements BundleActivator {
+	private final Collection<ServiceRegistration<?>> serviceRegistrations = new ArrayList<ServiceRegistration<?>>();
 
-    private static BundleContext context;
-    private List<ServiceRegistration> registrations = new ArrayList<ServiceRegistration>();
-    ScopeAdminServiceFactory scopeAdminFactory;
-
-    static BundleContext getContext() {
-        return context;
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * org.osgi.framework.BundleActivator#start(org.osgi.framework.BundleContext
-     * )
-     */
     public void start(BundleContext bundleContext) throws Exception {
-        Activator.context = bundleContext;
-        scopeAdminFactory = new ScopeAdminServiceFactory();
-        scopeAdminFactory.init();
-        register(ScopeAdmin.class, scopeAdminFactory, null);
-
-    }
-
-    protected <T> void register(Class<T> clazz, T service, Dictionary props) {
-        registrations.add(context.registerService(clazz.getName(), service,
-                props));
+		ScopeManager sm = new ScopeManager(bundleContext);
+		ServiceRegistration<?> sr = bundleContext.registerService(
+				EventHook.class, 
+				sm.newEventHook(), 
+				null);
+		serviceRegistrations.add(sr);
+		ScopeUpdate su = sm.getRootScope().newScopeUpdate();
+		su.getBundles().addAll(Arrays.asList(bundleContext.getBundles()));
+		su.commit();
+		sr = bundleContext.registerService(
+				org.osgi.framework.hooks.bundle.FindHook.class,
+				sm.newBundleFindHook(), 
+				null);
+		serviceRegistrations.add(sr);
+		sr = bundleContext.registerService(
+				ResolverHookFactory.class,
+				sm.newResolverHookFactory(), 
+				null);
+		serviceRegistrations.add(sr);
+		sr = bundleContext.registerService(
+				EventListenerHook.class,
+				sm.newEventListenerHook(), 
+				null);
+		serviceRegistrations.add(sr);
+		sr = bundleContext.registerService(
+				org.osgi.framework.hooks.service.FindHook.class,
+				sm.newServiceFindHook(), 
+				null);
+		serviceRegistrations.add(sr);
+		sr = bundleContext.registerService(
+				Scope.class.getName(), 
+				sm.newServiceFactory(), 
+				null);
+		serviceRegistrations.add(sr);
+	}
+	
+	public void stop(BundleContext bc) throws Exception {
+		unregisterQuietly();
+	}
+	
+	private void unregisterQuietly() {
+		for (ServiceRegistration<?> sr : serviceRegistrations)
+			unregisterQuietly(sr);
+		serviceRegistrations.clear();
     }
 
-    protected <T> void register(Class<T> clazz, ServiceFactory factory,
-            Dictionary props) {
-        registrations.add(context.registerService(clazz.getName(), factory,
-                props));
-    }
-
-    /*
-     * (non-Javadoc)
-     * 
-     * @see
-     * org.osgi.framework.BundleActivator#stop(org.osgi.framework.BundleContext)
-     */
-    public void stop(BundleContext bundleContext) throws Exception {
-        Activator.context = null;
-        for (ServiceRegistration r : registrations) {
+	private void unregisterQuietly(ServiceRegistration<?> serviceRegistration) {
             try {
-                r.unregister();
-            } catch (Exception e) {
-                // LOGGER.warn("Scope Activator shut down", e);
+			serviceRegistration.unregister();
             }
+		catch (Exception e) {
+			// ignore
         }
-
-        scopeAdminFactory.destroy();
     }
-
-    public static BundleContext getBundleContext() {
-        return context;
-    }
-
 }
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/AbstractIntegrationTest.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/AbstractIntegrationTest.java
index e69de29b..b730a365 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/AbstractIntegrationTest.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/AbstractIntegrationTest.java
@@ -0,0 +1,215 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.subsystem.scope.itests;
+
+import static org.ops4j.pax.exam.CoreOptions.options;
+import static org.ops4j.pax.exam.CoreOptions.wrappedBundle;
+import static org.ops4j.pax.exam.OptionUtils.combine;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+
+import org.apache.aries.subsystem.scope.ScopeUpdate;
+import org.apache.aries.subsystem.scope.SharePolicy;
+import org.junit.After;
+import org.junit.Before;
+import org.ops4j.pax.exam.CoreOptions;
+import org.ops4j.pax.exam.Inject;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.options.MavenArtifactProvisionOption;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Constants;
+import org.osgi.framework.Filter;
+import org.osgi.framework.FrameworkUtil;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.util.tracker.ServiceTracker;
+
+public abstract class AbstractIntegrationTest {
+
+    public static final long DEFAULT_TIMEOUT = 10000;
+
+    private List<ServiceTracker> srs;
+
+    @Before
+    public void setUp() {
+        srs = new ArrayList<ServiceTracker>();
+    }
+    
+    @After
+    public void tearDown() throws Exception{
+        for (ServiceTracker st : srs) {
+            if (st != null) {
+                st.close();
+            }  
+        }
+    }
+    
+    @Inject
+    protected BundleContext bundleContext;
+
+    protected <T> T getOsgiService(Class<T> type, long timeout) {
+        return getOsgiService(type, null, timeout);
+    }
+
+    protected <T> T getOsgiService(Class<T> type) {
+        return getOsgiService(type, null, DEFAULT_TIMEOUT);
+    }
+    
+    protected <T> T getOsgiService(BundleContext bc, Class<T> type, String filter, long timeout) {
+        ServiceTracker tracker = null;
+        try {
+            String flt;
+            if (filter != null) {
+                if (filter.startsWith("(")) {
+                    flt = "(&(" + Constants.OBJECTCLASS + "=" + type.getName() + ")" + filter + ")";
+                } else {
+                    flt = "(&(" + Constants.OBJECTCLASS + "=" + type.getName() + ")(" + filter + "))";
+                }
+            } else {
+                flt = "(" + Constants.OBJECTCLASS + "=" + type.getName() + ")";
+            }
+            Filter osgiFilter = FrameworkUtil.createFilter(flt);
+            tracker = new ServiceTracker(bc == null ? bundleContext : bc, osgiFilter, null);
+            tracker.open();
+            
+            // add tracker to the list of trackers we close at tear down
+            srs.add(tracker);
+            Object svc = type.cast(tracker.waitForService(timeout));
+            if (svc == null) {
+                throw new RuntimeException("Gave up waiting for service " + flt);
+            }
+            return type.cast(svc);
+        } catch (InvalidSyntaxException e) {
+            throw new IllegalArgumentException("Invalid filter", e);
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        }
+    }
+    
+    protected <T> T getOsgiService(Class<T> type, String filter, long timeout) {
+        return getOsgiService(null, type, filter, timeout);
+    }
+
+    protected Bundle installBundle(String groupId, String artifactId) throws Exception {
+        MavenArtifactProvisionOption mvnUrl = mavenBundle(groupId, artifactId);
+        return bundleContext.installBundle(mvnUrl.getURL());
+    }
+
+    protected Bundle getInstalledBundle(String symbolicName) {
+        for (Bundle b : bundleContext.getBundles()) {
+            if (b.getSymbolicName().equals(symbolicName)) {
+                return b;
+            }
+        }
+        return null;
+    }
+
+    public static MavenArtifactProvisionOption mavenBundle(String groupId, String artifactId) {
+        return CoreOptions.mavenBundle().groupId(groupId).artifactId(artifactId).versionAsInProject();
+    }
+    
+    public static MavenArtifactProvisionOption mavenBundleInTest(String groupId, String artifactId) {
+        return CoreOptions.mavenBundle().groupId(groupId).artifactId(artifactId).version(getArtifactVersion(groupId, artifactId));
+    }
+
+    //TODO getArtifactVersion and getFileFromClasspath are borrowed and modified from pax-exam.  They should be moved back ASAP.
+    public static String getArtifactVersion( final String groupId,
+                                             final String artifactId )
+    {
+        final Properties dependencies = new Properties();
+        try
+        {
+            InputStream in = getFileFromClasspath("META-INF/maven/dependencies.properties");
+            try {
+                dependencies.load(in);
+            } finally {
+                in.close();
+            }
+            final String version = dependencies.getProperty( groupId + "/" + artifactId + "/version" );
+            if( version == null )
+            {
+                throw new RuntimeException(
+                    "Could not resolve version. Do you have a dependency for " + groupId + "/" + artifactId
+                    + " in your maven project?"
+                );
+            }
+            return version;
+        }
+        catch( IOException e )
+        {
+            // TODO throw a better exception
+            throw new RuntimeException(
+                "Could not resolve version. Did you configured the plugin in your maven project?"
+                + "Or maybe you did not run the maven build and you are using an IDE?"
+            );
+        }
+    }
+
+    private static InputStream getFileFromClasspath( final String filePath )
+        throws FileNotFoundException
+    {
+        try
+        {
+            URL fileURL = AbstractIntegrationTest.class.getClassLoader().getResource( filePath );
+            if( fileURL == null )
+            {
+                throw new FileNotFoundException( "File [" + filePath + "] could not be found in classpath" );
+            }
+            return fileURL.openStream();
+        }
+        catch (IOException e)
+        {
+            throw new FileNotFoundException( "File [" + filePath + "] could not be found: " + e.getMessage() );
+        }
+    }
+
+
+    protected static Option[] updateOptions(Option[] options) {
+        // We need to add pax-exam-junit here when running with the ibm
+        // jdk to avoid the following exception during the test run:
+        // ClassNotFoundException: org.ops4j.pax.exam.junit.Configuration
+        if ("IBM Corporation".equals(System.getProperty("java.vendor"))) {
+            Option[] ibmOptions = options(
+                wrappedBundle(mavenBundle("org.ops4j.pax.exam", "pax-exam-junit"))
+            );
+            options = combine(ibmOptions, options);
+        }
+
+        return options;
+    }
+    
+    protected void addPackageImportPolicy(String packageName, ScopeUpdate scopeUpdate) throws InvalidSyntaxException {
+		Filter filter = bundleContext.createFilter("(osgi.wiring.package=" + packageName + ')');
+		SharePolicy policy = new SharePolicy(SharePolicy.TYPE_IMPORT, "osgi.wiring.package", filter);
+		Map<String, List<SharePolicy>> policyMap = scopeUpdate.getSharePolicies(SharePolicy.TYPE_IMPORT);
+		List<SharePolicy> policies = policyMap.get("osgi.wiring.package");
+		if (policies == null) {
+			policies = new ArrayList<SharePolicy>();
+			policyMap.put("osgi.wiring.package", policies);
+		}
+		policies.add(policy);
+	}
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/AbstractTest.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/AbstractTest.java
index e69de29b..6d1b4e01 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/AbstractTest.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/AbstractTest.java
@@ -0,0 +1,215 @@
+package org.apache.aries.subsystem.scope.itests;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.ops4j.pax.exam.CoreOptions.equinox;
+import static org.ops4j.pax.exam.CoreOptions.options;
+import static org.ops4j.pax.exam.CoreOptions.systemProperty;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.aries.subsystem.scope.InstallInfo;
+import org.apache.aries.subsystem.scope.Scope;
+import org.apache.aries.subsystem.scope.ScopeUpdate;
+import org.apache.aries.subsystem.scope.SharePolicy;
+import org.junit.After;
+import org.junit.Before;
+import org.ops4j.pax.exam.Customizer;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
+import org.ops4j.pax.swissbox.tinybundles.core.TinyBundles;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleException;
+import org.osgi.framework.Constants;
+import org.osgi.framework.Filter;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.ServiceReference;
+
+public class AbstractTest extends AbstractIntegrationTest {
+	protected Scope scope;
+	
+	private ServiceReference<Scope> scopeRef;
+	
+	protected void addPackageExportPolicy(String packageName, ScopeUpdate scopeUpdate) throws InvalidSyntaxException {
+		Filter filter = bundleContext.createFilter("(osgi.wiring.package=" + packageName + ')');
+		SharePolicy policy = new SharePolicy(SharePolicy.TYPE_EXPORT, "osgi.wiring.package", filter);
+		Map<String, List<SharePolicy>> policyMap = scopeUpdate.getSharePolicies(SharePolicy.TYPE_EXPORT);
+		List<SharePolicy> policies = policyMap.get("osgi.wiring.package");
+		if (policies == null) {
+			policies = new ArrayList<SharePolicy>();
+			policyMap.put("osgi.wiring.package", policies);
+		}
+		policies.add(policy);
+	}
+	
+	protected void addPackageImportPolicy(String packageName, ScopeUpdate scopeUpdate) throws InvalidSyntaxException {
+		Filter filter = bundleContext.createFilter("(osgi.wiring.package=" + packageName + ')');
+		SharePolicy policy = new SharePolicy(SharePolicy.TYPE_IMPORT, "osgi.wiring.package", filter);
+		Map<String, List<SharePolicy>> policyMap = scopeUpdate.getSharePolicies(SharePolicy.TYPE_IMPORT);
+		List<SharePolicy> policies = policyMap.get("osgi.wiring.package");
+		if (policies == null) {
+			policies = new ArrayList<SharePolicy>();
+			policyMap.put("osgi.wiring.package", policies);
+		}
+		policies.add(policy);
+	}
+	
+	protected void addServiceExportPolicy(Class<?> clazz, ScopeUpdate scopeUpdate) throws InvalidSyntaxException {
+		Filter filter = bundleContext.createFilter('(' + Constants.OBJECTCLASS + '=' + clazz.getName() + ')');
+		SharePolicy policy = new SharePolicy(SharePolicy.TYPE_EXPORT, "scope.share.service", filter);
+		Map<String, List<SharePolicy>> policyMap = scopeUpdate.getSharePolicies(SharePolicy.TYPE_EXPORT);
+		List<SharePolicy> policies = policyMap.get("scope.share.service");
+		if (policies == null) {
+			policies = new ArrayList<SharePolicy>();
+			policyMap.put("scope.share.service", policies);
+		}
+		policies.add(policy);
+	}
+	
+	protected void addServiceImportPolicy(Class<?> clazz, ScopeUpdate scopeUpdate) throws InvalidSyntaxException {
+		Filter filter = bundleContext.createFilter('(' + Constants.OBJECTCLASS + '=' + clazz.getName() + ')');
+		SharePolicy policy = new SharePolicy(SharePolicy.TYPE_IMPORT, "scope.share.service", filter);
+		Map<String, List<SharePolicy>> policyMap = scopeUpdate.getSharePolicies(SharePolicy.TYPE_IMPORT);
+		List<SharePolicy> policies = policyMap.get("scope.share.service");
+		if (policies == null) {
+			policies = new ArrayList<SharePolicy>();
+			policyMap.put("scope.share.service", policies);
+		}
+		policies.add(policy);
+	}
+	
+	protected void assertEmpty(Collection<?> c) {
+		assertNotNull(c);
+		assertTrue(c.isEmpty());
+	}
+	
+	protected void assertEmpty(Map<?, ?> m) {
+		assertNotNull(m);
+		assertTrue(m.isEmpty());
+	}
+	
+	protected void assertCollectionEquals(Collection<?> c1, Collection<?> c2) {
+		assertFalse((c1 == null && c2 != null) || (c1 != null && c2 == null));
+		assertTrue(c1.size() == c2.size());
+		for (Iterator<?> i = c2.iterator(); i.hasNext();) {
+			assertTrue(c2.contains(i.next()));
+		}
+	}
+	
+	protected Bundle findBundle(String symbolicName, Scope scope) {
+		return Utils.findBundle(symbolicName, scope);
+	}
+	
+	protected Bundle findBundleInRootScope(String symbolicName) {
+		return findBundle(symbolicName, scope);
+	}
+	
+	protected ScopeUpdate findChildUpdate(String name, ScopeUpdate parent) {
+		assertNotNull(name);
+		assertNotNull(parent);
+		ScopeUpdate result = null;
+		for (ScopeUpdate child : parent.getChildren()) {
+			if (name.equals(child.getName())) {
+				result = child;
+				break;
+			}
+		}
+		assertNotNull(result);
+		return result;
+	}
+	
+	protected String getBundleLocation(String bundle) {
+		URL url = AbstractTest.class.getClassLoader().getResource(bundle);
+		return url.toExternalForm();
+	}
+	
+	protected Bundle installBundle(String name) throws BundleException {
+		URL url = AbstractTest.class.getClassLoader().getResource(name);
+		return bundleContext.installBundle(url.toExternalForm());
+	}
+	
+	protected void installBundles(Scope scope, String[] bundleNames) throws Exception {
+		installBundles(scope, Arrays.asList(bundleNames));
+	}
+	
+	protected void installBundles(Scope scope, Collection<String> bundleNames) throws Exception {
+		ScopeUpdate scopeUpdate = scope.newScopeUpdate();
+		for (String bundleName : bundleNames) {
+			URL url = AbstractTest.class.getClassLoader().getResource(bundleName);
+			InstallInfo installInfo = new InstallInfo(url.toExternalForm(), url.openStream());
+			scopeUpdate.getBundlesToInstall().add(installInfo);
+		}
+		scopeUpdate.commit();
+	}
+	
+	@Before
+	public void before() throws Exception {
+		assertNotNull(bundleContext);
+		scopeRef = bundleContext.getServiceReference(Scope.class);
+		assertNotNull(scopeRef);
+		scope = bundleContext.getService(scopeRef);
+		assertNotNull(scope);
+	}
+
+	@After
+	public void after() throws Exception {
+	}
+	
+	protected void uninstallQuietly(Bundle bundle) {
+		Utils.uninstallQuietly(bundle);
+	}
+	
+	@org.ops4j.pax.exam.junit.Configuration
+    public static Option[] configuration() {
+        Option[] options = options(
+            // Log
+            mavenBundle("org.ops4j.pax.logging", "pax-logging-api"),
+            mavenBundle("org.ops4j.pax.logging", "pax-logging-service"),
+            // Felix Config Admin
+            mavenBundle("org.apache.felix", "org.apache.felix.configadmin"),
+            // Felix mvn url handler
+            mavenBundle("org.ops4j.pax.url", "pax-url-mvn"),
+
+
+            // this is how you set the default log level when using pax logging (logProfile)
+            systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("DEBUG"),
+
+            // Bundles
+            mavenBundle("org.apache.aries.testsupport", "org.apache.aries.testsupport.unit"),
+            mavenBundle("org.apache.aries.application", "org.apache.aries.application.api"),
+            mavenBundle("org.apache.aries", "org.apache.aries.util"),
+            mavenBundle("org.apache.aries.application", "org.apache.aries.application.utils"),
+            mavenBundle("org.apache.felix", "org.apache.felix.bundlerepository"),
+            mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.api"),
+            mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.scope.api"),
+            mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.scope.impl"),
+
+            // org.ops4j.pax.exam.container.def.PaxRunnerOptions.vmOption("-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005"),
+
+            PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),
+
+            equinox().version("3.7.0.v20110221"),
+            
+            new Customizer() {
+            	@Override
+                public InputStream customizeTestProbe(InputStream testProbe) throws IOException {
+                    return TinyBundles.modifyBundle(testProbe).
+                                      removeHeader(Constants.EXPORT_PACKAGE)
+                                      .set(Constants.EXPORT_PACKAGE, "org.apache.aries.subsystem.scope.itests")
+                                      .build();
+                }
+            }
+        );
+        options = updateOptions(options);
+        return options;
+    }
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/BasicTest.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/BasicTest.java
index e69de29b..b7da34e1 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/BasicTest.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/BasicTest.java
@@ -0,0 +1,105 @@
+package org.apache.aries.subsystem.scope.itests;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import java.net.URL;
+import java.util.Arrays;
+import java.util.Collection;
+
+import org.apache.aries.subsystem.scope.InstallInfo;
+import org.apache.aries.subsystem.scope.Scope;
+import org.apache.aries.subsystem.scope.ScopeUpdate;
+import org.apache.aries.subsystem.scope.SharePolicy;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleException;
+
+@RunWith(JUnit4TestRunner.class)
+public class BasicTest extends AbstractTest {
+	/**
+	 * Basic test of the initial state of the root scope.
+	 */
+	@Test
+	public void testRootScopeInitialState() {
+		Collection<Bundle> bundles = Arrays.asList(bundleContext.getBundles());
+		assertCollectionEquals(bundles, scope.getBundles());
+		assertEmpty(scope.getChildren());
+		assertEquals(0, scope.getId());
+		assertNull(scope.getLocation());
+		assertEquals("root", scope.getName());
+		assertNull(scope.getParent());
+		assertEmpty(scope.getSharePolicies(SharePolicy.TYPE_EXPORT));
+		assertEmpty(scope.getSharePolicies(SharePolicy.TYPE_IMPORT));
+		assertNotNull(scope.newScopeUpdate());
+	}
+	
+	/**
+	 * Basic test of the initial state of the root scope from another bundle.
+	 * The root scope instance should be the same as in the previous test.
+	 * @throws Exception
+	 */
+	@Test
+	public void testRootScopeInitialStateFromOtherBundle() throws Exception {
+		Bundle tb1 = installBundle("tb-1.jar");
+		try {
+			tb1.start();
+		}
+		catch (BundleException e) {
+			if (e.getCause() instanceof AssertionError) {
+				throw (AssertionError)e.getCause();
+			}
+			throw e;
+		}
+		finally {
+			tb1.uninstall();
+		}
+	}
+	
+	@Test
+	public void testInstallBundleIntoRootScope() throws Exception {
+		int previousSize = scope.getBundles().size();
+		String location = getBundleLocation("tb-2.jar");
+		URL url = new URL(location);
+		InstallInfo tb2Info = new InstallInfo(location, url.openStream());
+		ScopeUpdate scopeUpdate = scope.newScopeUpdate();
+		scopeUpdate.getBundlesToInstall().add(tb2Info);
+		assertTrue(scopeUpdate.commit());
+		Bundle b = bundleContext.getBundle(location);
+		assertNotNull(b);
+		Collection<Bundle> bundles = scope.getBundles();
+		assertEquals(previousSize + 1, bundles.size());
+		assertTrue(bundles.contains(b));
+	}
+	
+	@Test
+	public void testCreateChildScope() throws Exception {
+		String name = "scope1";
+		ScopeUpdate parent = scope.newScopeUpdate();
+		ScopeUpdate child = parent.newChild(name);
+		parent.getChildren().add(child);
+		assertTrue(parent.commit());
+		Collection<Scope> children = scope.getChildren();
+		assertEquals(1, children.size());
+		Scope feature1 = null;
+		for (Scope s : children) {
+			if (name.equals(s.getName())) {
+				feature1 = s;
+				break;
+			}
+		}
+		assertNotNull(feature1);
+		assertEmpty(feature1.getBundles());
+		assertEmpty(feature1.getChildren());
+		assertEquals(1, feature1.getId());
+		assertNull(feature1.getLocation());
+		assertEquals(name, feature1.getName());
+		assertEquals(scope, feature1.getParent());
+		assertEmpty(feature1.getSharePolicies(SharePolicy.TYPE_EXPORT));
+		assertEmpty(feature1.getSharePolicies(SharePolicy.TYPE_IMPORT));
+	}
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/BundleProvider.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/BundleProvider.java
index e69de29b..63e179f8 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/BundleProvider.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/BundleProvider.java
@@ -0,0 +1,11 @@
+package org.apache.aries.subsystem.scope.itests;
+
+import java.util.Collection;
+
+import org.osgi.framework.Bundle;
+
+public interface BundleProvider {
+	Bundle getBundle(long id);
+	
+	Collection<Bundle> getBundles();
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/GetScopeServiceTest.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/GetScopeServiceTest.java
index e69de29b..068dde7d 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/GetScopeServiceTest.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/GetScopeServiceTest.java
@@ -0,0 +1,113 @@
+package org.apache.aries.subsystem.scope.itests;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.net.URL;
+
+import org.apache.aries.subsystem.scope.InstallInfo;
+import org.apache.aries.subsystem.scope.Scope;
+import org.apache.aries.subsystem.scope.ScopeUpdate;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.ServiceReference;
+
+/**
+ * Tests that bundles requesting a Scope service receive the correct one. 
+ * Bundles should receive the Scope within which they exist. Requesting bundles 
+ * are in the root scope by default.
+ */
+@RunWith(JUnit4TestRunner.class)
+public class GetScopeServiceTest extends AbstractTest {
+	/**
+	 * The test bundle should be in and receive the root scope by default. The
+	 * root scope will always have an ID of '0' and name of 'root'.
+	 * @throws Exception
+	 */
+	@Test
+	public void test1() throws Exception {
+		assertEquals(0, scope.getId());
+		assertEquals("root", scope.getName());
+		assertTrue(scope.getBundles().contains(bundleContext.getBundle()));
+	}
+	
+	/**
+	 * The tb3 bundle should also be in and receive the root scope by default.
+	 * @throws Exception
+	 */
+	@Test
+	public void test2() throws Exception {
+		Bundle bundle = installBundle("tb-3.jar");
+		bundle.start();
+		ServiceReference<ScopeProvider> scopeProviderRef = bundleContext.getServiceReference(ScopeProvider.class);
+		ScopeProvider scopeProvider = bundleContext.getService(scopeProviderRef);
+		Scope scope = scopeProvider.getScope();
+		assertEquals(this.scope, scope);
+		assertTrue(scope.getBundles().contains(bundle));
+		bundleContext.ungetService(scopeProviderRef);
+		bundle.uninstall();
+	}
+	
+	/**
+	 * A new scope is created as a child of the root scope and the tb3 bundle
+	 * is added to it. The tb3 bundle should receive and be in the new scope.
+	 * @throws Exception
+	 */
+	@Test
+	public void test3() throws Exception {
+		ScopeUpdate scopeUpdate = scope.newScopeUpdate();
+		ScopeUpdate child = scopeUpdate.newChild("tb3");
+		scopeUpdate.getChildren().add(child);
+		String location = getBundleLocation("tb-3.jar");
+		URL url = new URL(location);
+		InstallInfo installInfo = new InstallInfo(location, url.openStream());
+		child.getBundlesToInstall().add(installInfo);
+		addPackageImportPolicy("org.osgi.framework", child);
+		addPackageImportPolicy("org.apache.aries.subsystem.scope", child);
+		addPackageImportPolicy("org.apache.aries.subsystem.scope.itests", child);
+		addServiceImportPolicy(Scope.class, child);
+		addServiceExportPolicy(ScopeProvider.class, child);
+		scopeUpdate.commit();
+		Bundle bundle = bundleContext.getBundle(location);
+		bundle.start();
+		ServiceReference<ScopeProvider> scopeProviderRef = bundleContext.getServiceReference(ScopeProvider.class);
+		ScopeProvider scopeProvider = bundleContext.getService(scopeProviderRef);
+		Scope scope = scopeProvider.getScope();
+		assertEquals("tb3", scope.getName());
+		assertTrue(scope.getBundles().contains(bundle));
+		bundleContext.ungetService(scopeProviderRef);
+		bundle.uninstall();
+	}
+	
+	/**
+	 * A new scope is created as a child of the root scope and the tb3 bundle
+	 * is added to it. The tb3 bundle should receive and be in the new scope.
+	 * The bundle is added directly as opposed to via an InstallInfo.
+	 * @throws Exception
+	 */
+	@Test
+	public void test4() throws Exception {
+		Bundle bundle = installBundle("tb-3.jar");
+		ScopeUpdate scopeUpdate = scope.newScopeUpdate();
+		scopeUpdate.getBundles().remove(bundle);
+		ScopeUpdate child = scopeUpdate.newChild("tb3");
+		scopeUpdate.getChildren().add(child);
+		child.getBundles().add(bundle);
+		addPackageImportPolicy("org.osgi.framework", child);
+		addPackageImportPolicy("org.apache.aries.subsystem.scope", child);
+		addPackageImportPolicy("org.apache.aries.subsystem.scope.itests", child);
+		addServiceImportPolicy(Scope.class, child);
+		addServiceExportPolicy(ScopeProvider.class, child);
+		scopeUpdate.commit();
+		bundle.start();
+		ServiceReference<ScopeProvider> scopeProviderRef = bundleContext.getServiceReference(ScopeProvider.class);
+		ScopeProvider scopeProvider = bundleContext.getService(scopeProviderRef);
+		Scope scope = scopeProvider.getScope();
+		assertEquals("tb3", scope.getName());
+		assertTrue(scope.getBundles().contains(bundle));
+		bundleContext.ungetService(scopeProviderRef);
+		bundle.uninstall();
+	}
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/JarCreator.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/JarCreator.java
index e69de29b..a11ce346 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/JarCreator.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/JarCreator.java
@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.subsystem.scope.itests;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.util.jar.Attributes;
+import java.util.jar.JarInputStream;
+import java.util.jar.JarOutputStream;
+import java.util.jar.Manifest;
+import java.util.zip.ZipEntry;
+
+import org.osgi.framework.Constants;
+
+/**
+ * create multiple version of the same jars for testing purpose 
+ * as OSGi require install bundles have unique jar by symbolicname and version.
+ *
+ */
+public class JarCreator
+{
+  public static void main(String[] args) throws Exception{
+    createJar("1.0.0");
+    createJar("2.0.0");
+  }
+
+  private static void createJar(String version) throws Exception {
+    createJarFromFile("../subsystem-example/subsystem-helloIsolation/target/org.apache.aries.subsystem.example.helloIsolation-0.4-SNAPSHOT.jar", version);
+    createJarFromFile("../subsystem-example/subsystem-helloIsolationRef/target/org.apache.aries.subsystem.example.helloIsolationRef-0.4-SNAPSHOT.jar", version);
+  }
+  private static void createJarFromFile(String fileName, String version) throws Exception {
+    JarOutputStream jos = null;
+    FileOutputStream fos = null;
+    ZipEntry entry = null;
+    try {
+      // let's get hold of jars on disk
+      File jarFile = new File(fileName);
+      JarInputStream jarInput = new JarInputStream(jarFile.toURL().openStream());
+      Manifest manifest = jarInput.getManifest();
+      
+      //update manifest, Bundle-Version
+      Attributes attr = manifest.getMainAttributes();
+      attr.putValue(Constants.BUNDLE_VERSION, version);
+      if (fileName.indexOf("helloIsolationRef") < 0) {
+          attr.putValue(Constants.EXPORT_PACKAGE, "org.apache.aries.subsystem.example.helloIsolation;uses:=\"org.osgi.util.tracker,org.osgi.framework\";version=" + version);
+      }
+      
+      int lastSlash = fileName.lastIndexOf("/");
+      // trim the path
+      fileName = fileName.substring(lastSlash + 1);
+      int loc = fileName.indexOf("-");
+      String jarFilePath = fileName.substring(0, loc + 1) + version + ".jar";
+      
+      if (fileName.indexOf("helloIsolationRef") < 0) {
+          File directory = new File(System.getProperty("user.home") + "/.m2/repository/org/apache/aries/subsystem/example/org.apache.aries.subsystem.example.helloIsolation/" + version + "/");
+          if (!directory.exists()) {
+              directory.mkdir();
+          }
+          fos = new FileOutputStream(directory.getAbsolutePath() + "/" + jarFilePath);
+      } else {
+          File directory = new File(System.getProperty("user.home") + "/.m2/repository/org/apache/aries/subsystem/example/org.apache.aries.subsystem.example.helloIsolationRef/" + version + "/");
+          if (!directory.exists()) {
+              directory.mkdir();
+          }
+          fos = new FileOutputStream(directory.getAbsolutePath() + "/" + jarFilePath);  
+      }
+      jos = new JarOutputStream(fos, manifest);
+      
+      //Copy across all entries from the original jar
+      int val;
+      while ((entry = jarInput.getNextEntry()) != null) {
+        jos.putNextEntry(entry);
+        byte[] buffer = new byte[4096];
+        while ((val = jarInput.read(buffer)) != -1)
+          jos.write(buffer, 0, val);
+      }
+      
+      jos.closeEntry();
+      jos.finish();
+      System.out.println("finishing creating jar file: " + jarFilePath + " in local m2 repo");
+    } finally {
+      if (jos != null) {
+        jos.close();
+      }
+      if (fos != null) {
+        fos.close();
+      }
+    }
+  }
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/MoveBundleTest.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/MoveBundleTest.java
index e934ea14..b1974b53 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/MoveBundleTest.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/MoveBundleTest.java
@@ -1,3 +1,115 @@
   + native
   + text/plain
   + Date Revision
+package org.apache.aries.subsystem.scope.itests;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+import org.apache.aries.subsystem.scope.Scope;
+import org.apache.aries.subsystem.scope.ScopeUpdate;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.osgi.framework.Bundle;
+
+/**
+ * Bundles may be moved from one scope to another.
+ */
+@RunWith(JUnit4TestRunner.class)
+public class MoveBundleTest extends AbstractTest {
+	/**
+	 * Create two scopes off of the root scope with the following structure.
+	 *    R
+	 *   / \
+	 * S1   S2
+	 * Install a bundle using the test bundle's bundle context. This should add
+	 * the bundle to R since the test bundle is in R. Next, move the bundle 
+	 * into S1. Finally, move the bundle into S2.
+	 * @throws Exception
+	 */
+	@Test
+	public void test1() throws Exception {
+		Bundle tb2 = installBundle("tb-2.jar");
+		Scope root = scope;
+		ScopeUpdate rootUpdate = root.newScopeUpdate();
+		ScopeUpdate s1Update = rootUpdate.newChild("S1");
+		ScopeUpdate s2Update = rootUpdate.newChild("S2");
+		rootUpdate.getChildren().add(s1Update);
+		rootUpdate.getChildren().add(s2Update);
+		rootUpdate.commit();
+		Scope s1 = s1Update.getScope();
+		Scope s2 = s2Update.getScope();
+		assertTrue(root.getBundles().contains(tb2));
+		assertFalse(s1.getBundles().contains(tb2));
+		assertFalse(s2.getBundles().contains(tb2));
+		
+		rootUpdate = root.newScopeUpdate();
+		rootUpdate.getBundles().remove(tb2);
+		s1Update = findChildUpdate("S1", rootUpdate);
+		s1Update.getBundles().add(tb2);
+		rootUpdate.commit();
+		assertFalse(root.getBundles().contains(tb2));
+		assertTrue(s1.getBundles().contains(tb2));
+		assertFalse(s2.getBundles().contains(tb2));
+		
+		rootUpdate = root.newScopeUpdate();
+		s1Update = findChildUpdate("S1", rootUpdate);
+		s1Update.getBundles().remove(tb2);
+		s2Update = findChildUpdate("S2", rootUpdate);
+		s2Update.getBundles().add(tb2);
+		rootUpdate.commit();
+		assertFalse(root.getBundles().contains(tb2));
+		assertFalse(s1.getBundles().contains(tb2));
+		assertTrue(s2.getBundles().contains(tb2));
+		
+		tb2.uninstall();
+	}
+	
+	/**
+	 * Create one scope off of the root scope with the following structure. 
+	 * R
+	 * |
+	 * S
+	 * Install a bundle using the test bundle's bundle context. This should add 
+	 * the bundle to R since the test bundle is in R. Next, move the bundle into
+	 * S without removing it from R. This should result in an 
+	 * IllegalStateException. Finally, correct the error using the same 
+	 * ScopeUpdate objects and commit again. This should succeed, and the bundle
+	 * should now be in S.
+	 * @throws Exception
+	 */
+	@Test
+	public void test2() throws Exception {
+		Bundle tb2 = installBundle("tb-2.jar");
+		Scope root = scope;
+		ScopeUpdate rootUpdate = root.newScopeUpdate();
+		ScopeUpdate sUpdate = rootUpdate.newChild("S");
+		rootUpdate.getChildren().add(sUpdate);
+		rootUpdate.commit();
+		Scope s = sUpdate.getScope();
+		assertTrue(root.getBundles().contains(tb2));
+		assertFalse(s.getBundles().contains(tb2));
+		
+		rootUpdate = root.newScopeUpdate();
+		sUpdate = findChildUpdate("S", rootUpdate);
+		sUpdate.getBundles().add(tb2);
+		try {
+			rootUpdate.commit();
+			fail();
+		}
+		catch (IllegalStateException e) {
+			// Okay.
+		}
+		assertTrue(root.getBundles().contains(tb2));
+		assertFalse(s.getBundles().contains(tb2));
+		
+		rootUpdate.getBundles().remove(tb2);
+		rootUpdate.commit();
+		assertFalse(root.getBundles().contains(tb2));
+		assertTrue(s.getBundles().contains(tb2));
+		
+		tb2.uninstall();
+	}
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ScopeAdminTest.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ScopeAdminTest.java
index e69de29b..e71b609b 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ScopeAdminTest.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ScopeAdminTest.java
@@ -0,0 +1,680 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.subsystem.scope.itests;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.ops4j.pax.exam.CoreOptions.equinox;
+import static org.ops4j.pax.exam.CoreOptions.options;
+import static org.ops4j.pax.exam.CoreOptions.systemProperty;
+
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.aries.subsystem.example.helloIsolation.HelloIsolation;
+import org.apache.aries.subsystem.scope.InstallInfo;
+import org.apache.aries.subsystem.scope.Scope;
+import org.apache.aries.subsystem.scope.ScopeUpdate;
+import org.apache.aries.subsystem.scope.SharePolicy;
+import org.junit.After;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
+import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleEvent;
+import org.osgi.framework.BundleException;
+import org.osgi.framework.Filter;
+import org.osgi.framework.FrameworkUtil;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.ServiceReference;
+import org.osgi.framework.wiring.BundleRevision;
+import org.osgi.util.tracker.BundleTracker;
+import org.osgi.util.tracker.BundleTrackerCustomizer;
+
+
+@RunWith(JUnit4TestRunner.class)
+public class ScopeAdminTest extends AbstractIntegrationTest {
+
+    /* Use @Before not @BeforeClass so as to ensure that these resources
+     * are created in the paxweb temp directory, and not in the svn tree 
+     */
+    static boolean createdApplications = false;
+    BundleTracker bt;
+    int addEventCount;
+    int modifyEventCount;
+    int removeEventCount;
+    
+    @After
+    public void tearDown() throws Exception {
+        if (bt != null) {
+            bt.close();
+        }
+    }
+    
+    @Test
+    public void testBundleServiceIsolation() throws Exception {
+        // make sure we are using a framework that provides composite admin service
+        Scope scopeAdmin = getOsgiService(Scope.class);
+        assertNotNull("scope admin should not be null", scopeAdmin);
+        System.out.println("able to get scope admin service");
+
+        bt = new BundleTracker(bundleContext, Bundle.INSTALLED | Bundle.UNINSTALLED | Bundle.ACTIVE, new BundleTrackerCustomizer() {
+
+            public synchronized Object addingBundle(Bundle bundle, BundleEvent event) {
+                if (event == null) {
+                    System.out.println("ScopeAdminTest - adding Bundle: " + bundle.getSymbolicName() + " event: null");
+                } else {
+                    System.out.println("ScopeAdminTest - adding Bundle: " + bundle.getSymbolicName() + " event: " + event.getType());
+                    addEventCount++;
+                }
+                return bundle;
+            }
+
+            public synchronized void modifiedBundle(Bundle bundle, BundleEvent event,
+                    Object object) {
+                if (event == null) {
+                    System.out.println("ScopeAdminTest - modifying Bundle: " + bundle.getSymbolicName() + " event: null");
+                } else {
+                    System.out.println("ScopeAdminTest - modifying Bundle: " + bundle.getSymbolicName() + " event: " + event.getType());
+                    modifyEventCount++;
+                }
+                
+                
+            }
+
+            public synchronized void removedBundle(Bundle bundle, BundleEvent event,
+                    Object object) {
+                if (event == null) {
+                    System.out.println("ScopeAdminTest - removing Bundle: " + bundle.getSymbolicName() + " event: null");
+                } else {
+                    System.out.println("ScopeAdminTest - removing Bundle: " + bundle.getSymbolicName() + " event: " + event.getType());
+                    removeEventCount++;
+                }
+            }
+            
+        });
+        bt.open();
+        
+        ScopeUpdate su = scopeAdmin.newScopeUpdate();
+        
+        ScopeUpdate childScopeUpdate = su.newChild("scope_test1");
+        su.getChildren().add(childScopeUpdate);
+        addPackageImportPolicy("org.osgi.framework", childScopeUpdate);
+        addPackageImportPolicy("org.osgi.util.tracker", childScopeUpdate);
+        
+        // build up installInfo object for the scope
+        InstallInfo info1 = new InstallInfo("helloIsolation", new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolation/0.4-SNAPSHOT"));
+        InstallInfo info2 = new InstallInfo("helloIsolationRef", new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolationRef/0.4-SNAPSHOT"));
+
+        List<InstallInfo> bundlesToInstall = childScopeUpdate.getBundlesToInstall();
+        bundlesToInstall.add(info1);
+        bundlesToInstall.add(info2);
+        
+        // add bundles to be installed, based on subsystem content
+        su.commit();
+        
+        assertEquals("add event count should be 0 since 0 bundles are installed in root scope", 0, addEventCount);
+        assertEquals("modify event count should be 0", 0, modifyEventCount);
+        assertEquals("remove event count should be 0", 0, removeEventCount);
+        // start all bundles in the scope scope_test1
+        Collection<Bundle> bundlesToStart = childScopeUpdate.getScope().getBundles();
+        for (Bundle b : bundlesToStart) {
+            b.start();
+            
+        }
+        
+        assertEquals("add event count should be 0 since 0 bundles are installed in root scope", 0, addEventCount);
+        assertEquals("modify event count should be 0", 0, modifyEventCount);
+        assertEquals("remove event count should be 0", 0, removeEventCount);
+        
+        try {
+            ServiceReference sr = bundleContext.getServiceReference(HelloIsolation.class.getName());
+            fail("should not be able to get the sr for HelloIsolation service");
+        } catch (Exception ex) {
+            // expected 
+        } catch (Error er) {
+            // expected
+        }
+        
+        // test bundle find hooks
+        Bundle[] bundles = bundleContext.getBundles();
+        for (Bundle b : bundles) {
+            System.out.println("Bundle is " + b.getBundleId() + ": " + b.getSymbolicName());
+            if (b.getSymbolicName().indexOf("org.apache.aries.subsystem.example.helloIsolation") > -1) {
+                fail("bundles with name starts with org.apache.aries.subsystem.example.helloIsolation should be in a different scope");
+            }
+        }
+        
+        // test bundle service find hook
+        //ServiceReference sr = bundleContext.getServiceReference(HelloIsolation.class.getName());
+        //assertNull("sr should be null", sr);
+        Collection<Scope> children = scopeAdmin.getChildren();
+        assertEquals(1, children.size());
+        
+        for (Scope child : children) {
+            if (child.getName().equals("scope_test1")) {
+                Collection<Bundle> buns = child.getBundles();
+                assertEquals(2, buns.size());
+                assertEquals(0, child.getChildren().size());
+                for (Bundle b : buns) {
+                    assertTrue(b.getSymbolicName().indexOf("org.apache.aries.subsystem.example.helloIsolation") > -1);
+                }
+                
+            }
+        }
+        
+        // install a test bundle in the root scope
+        URL url = new URL("mvn:org.apache.felix/org.apache.felix.fileinstall/2.0.8");
+        bundleContext.installBundle("org.apache.felix.fileinstall-rootScope", url.openStream());
+        assertEquals("add event count should be 1 since 1 bundles are installed", 1, addEventCount);
+        assertEquals("modify event count should be 0", 0, modifyEventCount);
+        assertEquals("remove event count should be 0", 0, removeEventCount);
+        
+        
+        // remove child scope
+        su = scopeAdmin.newScopeUpdate();
+//        Collection<Scope> scopes = su.getToBeRemovedChildren();
+        Collection<ScopeUpdate> scopes = su.getChildren();
+        childScopeUpdate = scopes.iterator().next();
+        
+        // obtain child scope admin from service registry
+//        String filter = "ScopeName=scope_test1";
+//        Scope childScopeAdmin = getOsgiService(Scope.class, filter, DEFAULT_TIMEOUT);
+        Scope childScopeAdmin = childScopeUpdate.getScope();
+        assertEquals(scopeAdmin, childScopeAdmin.getParent());
+//        scopes.add(childScopeAdmin);
+        scopes.remove(childScopeUpdate);
+        su.commit();
+        
+        assertFalse(scopeAdmin.getChildren().contains(childScopeAdmin));
+        su = scopeAdmin.newScopeUpdate();
+        assertFalse(su.getChildren().contains(childScopeUpdate));
+        
+//        childScopeAdmin = null;
+//        try {
+//            childScopeAdmin = getOsgiService(Scope.class, filter, DEFAULT_TIMEOUT);
+//        } catch (Exception ex) {
+//            // ignore
+//        }
+//        assertNull("scope admin service for the scope should be unregistered", childScopeAdmin);
+        
+    }
+    
+    @Test
+    public void testPackageIsolation() throws Exception {
+        // make sure we are using a framework that provides composite admin service
+        Scope scopeAdmin = getOsgiService(Scope.class);
+        assertNotNull("scope admin should not be null", scopeAdmin);
+        System.out.println("able to get scope admin service");
+
+        ScopeUpdate su = scopeAdmin.newScopeUpdate();
+        
+        ScopeUpdate childScopeUpdate = su.newChild("scope_test1");
+        su.getChildren().add(childScopeUpdate);
+        addPackageImportPolicy("org.osgi.framework", childScopeUpdate);
+        addPackageImportPolicy("org.osgi.util.tracker", childScopeUpdate);
+        // build up installInfo object for the scope
+        InstallInfo info1 = new InstallInfo("helloIsolation", new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolation/0.4-SNAPSHOT"));
+        InstallInfo info2 = new InstallInfo("helloIsolationRef", new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolationRef/0.4-SNAPSHOT"));
+
+        List<InstallInfo> bundlesToInstall = childScopeUpdate.getBundlesToInstall();
+        bundlesToInstall.add(info1);
+        bundlesToInstall.add(info2);
+        
+        // add bundles to be installed, based on subsystem content
+        su.commit();
+        
+        // start all bundles in the scope scope_test1
+        Collection<Bundle> bundlesToStart = childScopeUpdate.getScope().getBundles();
+        for (Bundle b : bundlesToStart) {
+            b.start();
+            
+        }
+        
+        // install helloIsolationRef1 bundle in the root scope
+        URL url1 = new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolationRef/1.0.0");
+        Bundle helloIsolationRef = bundleContext.installBundle("helloIsolationRef1-rootScope", url1.openStream());
+   
+        try {
+            helloIsolationRef.start();
+            fail("should not be able to start helloIsolationRef since missing import packages");
+        } catch (Exception ex) {
+            // expect resolving error
+        }
+        
+        URL url2 = new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolation/1.0.0");
+        Bundle helloIsolation = bundleContext.installBundle("helloIsolation1-rootScope", url2.openStream());
+ 
+        helloIsolation.start();
+        
+        // should be able to start the bundle now.
+        helloIsolationRef.start();
+               
+        // remove helloIsolationRef & helloIsolation
+        helloIsolationRef.uninstall();
+        helloIsolation.uninstall();
+        
+        // remove child scope
+        su = scopeAdmin.newScopeUpdate();
+//        Collection<Scope> scopes = su.getToBeRemovedChildren();
+        Collection<ScopeUpdate> scopes = su.getChildren();
+        childScopeUpdate = scopes.iterator().next();
+        // obtain child scope admin from service registry
+//        String filter = "ScopeName=scope_test1";
+//        Scope childScopeAdmin = getOsgiService(Scope.class, filter, DEFAULT_TIMEOUT);
+        Scope childScopeAdmin = childScopeUpdate.getScope();
+        assertEquals(scopeAdmin, childScopeAdmin.getParent());
+//        scopes.add(childScopeAdmin);
+        scopes.remove(childScopeUpdate);
+        su.commit();
+        
+        assertFalse(scopeAdmin.getChildren().contains(childScopeAdmin));
+        su = scopeAdmin.newScopeUpdate();
+        assertFalse(su.getChildren().contains(childScopeUpdate));
+        
+//        childScopeAdmin = null;
+//        try {
+//            childScopeAdmin = getOsgiService(Scope.class, filter, DEFAULT_TIMEOUT);
+//        } catch (Exception ex) {
+//            // ignore
+//        }
+//        assertNull("scope admin service for the scope should be unregistered", childScopeAdmin);
+        
+    }
+    
+    // test sharing the helloIsolation package from the test scope.
+    @Test
+    public void testPackageSharingFromTestScope() throws Exception {
+        // make sure we are using a framework that provides composite admin service
+        Scope scopeAdmin = getOsgiService(Scope.class);
+        assertNotNull("scope admin should not be null", scopeAdmin);
+        System.out.println("able to get scope admin service");
+
+        ScopeUpdate su = scopeAdmin.newScopeUpdate();
+        
+        ScopeUpdate childScopeUpdate = su.newChild("scope_test1");
+        su.getChildren().add(childScopeUpdate);
+        addPackageImportPolicy("org.osgi.framework", childScopeUpdate);
+        addPackageImportPolicy("org.osgi.util.tracker", childScopeUpdate);
+        Map<String, List<SharePolicy>> sharePolicies = childScopeUpdate.getSharePolicies(SharePolicy.TYPE_EXPORT);
+        final Filter filter1 = FrameworkUtil.createFilter(
+                "(&" + 
+                  "(osgi.wiring.package=org.apache.aries.subsystem.example.helloIsolation)" +
+                ")");
+        final Filter filter2 = FrameworkUtil.createFilter(
+                "(&" + 
+                  "(scope.share.service=org.apache.aries.subsystem.example.helloIsolation.HelloIsolation)" +
+                ")");
+        List<SharePolicy> packagePolicies = sharePolicies.get(BundleRevision.PACKAGE_NAMESPACE);
+        if (packagePolicies == null) {
+            packagePolicies = new ArrayList<SharePolicy>();
+            sharePolicies.put(BundleRevision.PACKAGE_NAMESPACE, packagePolicies);
+        }
+        packagePolicies.add(new SharePolicy(SharePolicy.TYPE_EXPORT, BundleRevision.PACKAGE_NAMESPACE, filter1));
+        List<SharePolicy> servicePolicies = sharePolicies.get("scope.share.service");
+        if (servicePolicies == null) {
+            servicePolicies = new ArrayList<SharePolicy>();
+            sharePolicies.put("scope.share.service", servicePolicies);
+        }
+        servicePolicies.add(new SharePolicy(SharePolicy.TYPE_EXPORT, "scope.share.service", filter2));
+
+
+        // build up installInfo object for the scope
+        InstallInfo info1 = new InstallInfo("helloIsolation", new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolation/0.4-SNAPSHOT"));
+        InstallInfo info2 = new InstallInfo("helloIsolationRef", new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolationRef/0.4-SNAPSHOT"));
+
+        List<InstallInfo> bundlesToInstall = childScopeUpdate.getBundlesToInstall();
+        bundlesToInstall.add(info1);
+        bundlesToInstall.add(info2);
+        
+        // add bundles to be installed, based on subsystem content
+        su.commit();
+        
+        // start all bundles in the scope scope_test1
+        Collection<Bundle> bundlesToStart = childScopeUpdate.getScope().getBundles();
+        for (Bundle b : bundlesToStart) {
+            b.start();
+            
+        }
+        
+        // install helloIsolationRef1 bundle in the root scope
+        URL url1 = new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolationRef/1.0.0");
+        Bundle helloIsolationRef = bundleContext.installBundle("helloIsolationRef1-rootScope", url1.openStream());
+   
+        try {
+            helloIsolationRef.start();
+        } catch (Exception ex) {
+            fail("should be able to start helloIsolationRef by import packages from scope_test1");
+        }
+        
+        // remove helloIsolationRef
+        helloIsolationRef.uninstall();
+        // remove child scope
+        su = scopeAdmin.newScopeUpdate();
+        Collection<ScopeUpdate> scopes = su.getChildren();
+        childScopeUpdate = scopes.iterator().next();
+        // obtain child scope admin from service registry
+//        String filter = "ScopeName=scope_test1";
+        Scope childScopeAdmin = childScopeUpdate.getScope();
+        assertEquals(scopeAdmin, childScopeAdmin.getParent());
+        scopes.remove(childScopeUpdate);
+        su.commit();
+        
+        assertFalse(scopeAdmin.getChildren().contains(childScopeAdmin));
+        su = scopeAdmin.newScopeUpdate();
+        assertFalse(su.getChildren().contains(childScopeUpdate));
+        
+//        childScopeAdmin = null;
+//        try {
+//            childScopeAdmin = getOsgiService(Scope.class, filter, DEFAULT_TIMEOUT);
+//        } catch (Exception ex) {
+//            // ignore
+//        }
+//        assertNull("scope admin service for the scope should be unregistered", childScopeAdmin);
+        
+    }
+
+    // test sharing the helloIsolation package & service from the root scope.
+    @Test
+    public void testPackageSharingFromRootScope() throws Exception {
+        // install helloIsolationRef1 bundle in the root scope
+        URL url1 = new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolation/1.0.0");
+        Bundle helloIsolation = bundleContext.installBundle("helloIsolation1-rootScope", url1.openStream());
+   
+        try {
+            helloIsolation.start();
+        } catch (Exception ex) {
+            fail("should be able to start helloIsolation");
+        }
+        
+        // make sure we are using a framework that provides composite admin service
+        Scope scopeAdmin = getOsgiService(Scope.class);
+        assertNotNull("scope admin should not be null", scopeAdmin);
+        System.out.println("able to get scope admin service");
+
+        ScopeUpdate su = scopeAdmin.newScopeUpdate();
+        
+        ScopeUpdate childScopeUpdate = su.newChild("scope_test1");
+        su.getChildren().add(childScopeUpdate);
+        addPackageImportPolicy("org.osgi.framework", childScopeUpdate);
+        Map<String, List<SharePolicy>> sharePolicies = childScopeUpdate.getSharePolicies(SharePolicy.TYPE_IMPORT);
+        final Filter filter1 = FrameworkUtil.createFilter(
+                "(&" + 
+                  "(osgi.wiring.package=org.apache.aries.subsystem.example.helloIsolation)" +
+                ")");
+        final Filter filter2 = FrameworkUtil.createFilter(
+                "(&" + 
+                  "(scope.share.service=org.apache.aries.subsystem.example.helloIsolation.HelloIsolation)" +
+                ")");
+        List<SharePolicy> packagePolicies = sharePolicies.get(BundleRevision.PACKAGE_NAMESPACE);
+        if (packagePolicies == null) {
+            packagePolicies = new ArrayList<SharePolicy>();
+            sharePolicies.put(BundleRevision.PACKAGE_NAMESPACE,packagePolicies);
+        }
+        packagePolicies.add(new SharePolicy(SharePolicy.TYPE_IMPORT, BundleRevision.PACKAGE_NAMESPACE, filter1));
+        List<SharePolicy> servicePolicies = sharePolicies.get("scope.share.service");
+        if (servicePolicies == null) {
+            servicePolicies = new ArrayList<SharePolicy>();
+            sharePolicies.put("scope.share.service", servicePolicies);
+        }
+        servicePolicies.add(new SharePolicy(SharePolicy.TYPE_IMPORT, "scope.share.service", filter2));
+
+
+        // build up installInfo object for the scope
+        InstallInfo info2 = new InstallInfo("helloIsolationRef", new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolationRef/0.4-SNAPSHOT"));
+
+        List<InstallInfo> bundlesToInstall = childScopeUpdate.getBundlesToInstall();
+        bundlesToInstall.add(info2);
+        
+        // add bundles to be installed, based on subsystem content
+        su.commit();
+        
+        // start all bundles in the scope scope_test1
+        Collection<Bundle> bundlesToStart = childScopeUpdate.getScope().getBundles();
+        for (Bundle b : bundlesToStart) {
+            try {
+                b.start();
+            } catch (Exception ex) {
+            	ex.printStackTrace();
+                fail("should be able to start helloIsolationRef in scope_test1");
+            }
+            
+        }
+ 
+        // remove helloIsolation in root scope
+        helloIsolation.uninstall();
+        
+        // remove child scope
+        su = scopeAdmin.newScopeUpdate();
+        Collection<ScopeUpdate> scopes = su.getChildren();
+        childScopeUpdate = scopes.iterator().next();
+        // obtain child scope admin from service registry
+//        String filter = "ScopeName=scope_test1";
+        Scope childScopeAdmin = childScopeUpdate.getScope();
+        assertEquals(scopeAdmin, childScopeAdmin.getParent());
+        scopes.remove(childScopeUpdate);
+        su.commit();
+        
+        assertFalse(scopeAdmin.getChildren().contains(childScopeAdmin));
+        su = scopeAdmin.newScopeUpdate();
+        assertFalse(su.getChildren().contains(childScopeUpdate));
+        
+//        childScopeAdmin = null;
+//        try {
+//            childScopeAdmin = getOsgiService(Scope.class, filter, DEFAULT_TIMEOUT);
+//        } catch (Exception ex) {
+//            // ignore
+//        }
+//        assertNull("scope admin service for the scope should be unregistered", childScopeAdmin);
+    }
+    
+    // test ability to select the helloIsolation package from which scope it wants to use
+    // not necessarily the highest version one by default.
+    @Test
+    public void testScopeAffinity() throws Exception {
+        // make sure we are using a framework that provides composite admin service
+        Scope scopeAdmin = getOsgiService(Scope.class);
+        assertNotNull("scope admin should not be null", scopeAdmin);
+        System.out.println("able to get scope admin service");
+
+        // install helloIsolation 0.3 in scope_test1
+        Scope scope1 = createScope(scopeAdmin, "scope_test1", 
+                "mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolation/0.4-SNAPSHOT",
+                "0.3");
+        
+        // install helloIsolation 2.0 in scope_test2
+        Scope scope2 = createScope(scopeAdmin, "scope_test2", 
+                "mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolation/2.0.0",
+                "2.0");
+        
+        // install helloIsolationRef 2.0 in scope_test3
+        ScopeUpdate su = scopeAdmin.newScopeUpdate();
+        
+        ScopeUpdate childScopeUpdate = su.newChild("scope_test3");
+        su.getChildren().add(childScopeUpdate);
+        addPackageImportPolicy("org.osgi.framework", childScopeUpdate);
+        Scope scope3 = childScopeUpdate.getScope();
+        
+        Map<String, List<SharePolicy>> sharePolicies = childScopeUpdate.getSharePolicies(SharePolicy.TYPE_IMPORT);
+        /*final Filter filter1 = FrameworkUtil.createFilter(
+                "(&" + 
+                  "(osgi.package=org.apache.aries.subsystem.example.helloIsolation)" +
+                  "(bundle-symbolic-name=org.apache.aries.subsystem.example.helloIsolation)" + 
+                  "(bundle-version<=1.1)" + 
+                ")");*/
+        final Filter filter1 = FrameworkUtil.createFilter(
+                "(&" + 
+                  "(osgi.wiring.package=org.apache.aries.subsystem.example.helloIsolation)" +
+                  //"(scopeName=scope_test1)" +  
+                ")");
+        final Filter filter2 = FrameworkUtil.createFilter(
+                "(&" + 
+                  "(scope.share.service=org.apache.aries.subsystem.example.helloIsolation.HelloIsolation)" +
+                ")");
+        List<SharePolicy> packagePolicies = sharePolicies.get(BundleRevision.PACKAGE_NAMESPACE);
+        if (packagePolicies == null) {
+            packagePolicies = new ArrayList<SharePolicy>();
+            sharePolicies.put(BundleRevision.PACKAGE_NAMESPACE,packagePolicies);
+        }
+        packagePolicies.add(new SharePolicy(SharePolicy.TYPE_IMPORT, BundleRevision.PACKAGE_NAMESPACE, filter1));
+        List<SharePolicy> servicePolicies = sharePolicies.get("scope.share.service");
+        if (servicePolicies == null) {
+            servicePolicies = new ArrayList<SharePolicy>();
+            sharePolicies.put("scope.share.service", servicePolicies);
+        }
+        servicePolicies.add(new SharePolicy(SharePolicy.TYPE_IMPORT, "scope.share.service", filter2));
+
+
+        // build up installInfo object for the scope
+        InstallInfo info2 = new InstallInfo("helloIsolationRef", new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolationRef/0.4-SNAPSHOT"));
+
+        List<InstallInfo> bundlesToInstall = childScopeUpdate.getBundlesToInstall();
+        bundlesToInstall.add(info2);
+        
+        // add bundles to be installed, based on subsystem content
+        su.commit();
+        
+        // start all bundles in the scope scope_test3
+        Collection<Bundle> bundlesToStart = childScopeUpdate.getScope().getBundles();
+        for (Bundle b : bundlesToStart) {
+            try {
+                b.start();
+            } catch (Exception ex) {
+            	ex.printStackTrace();
+                fail("should be able to start helloIsolationRef in scope_test1");
+            }
+            
+        }
+        
+        /*  // install helloIsolationRef in root scope
+        URL url1 = new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolationRef/1.0.0");
+        Bundle helloIsolationRef = bundleContext.installBundle("helloIsolationRef1-rootScope", url1.openStream());
+   
+        try {
+            helloIsolationRef.start();
+        } catch (Exception ex) {
+            fail("should be able to start helloIsolationRef");
+        }*/
+        
+        // remove child scope - cleanup
+        su = scopeAdmin.newScopeUpdate();
+        Collection<ScopeUpdate> scopes = su.getChildren();
+        scopes.clear();
+//        scopes.add(scope1);
+//        scopes.add(scope2);
+//        scopes.add(scope3);
+        su.commit();
+        assertTrue(scopeAdmin.getChildren().isEmpty());
+        assertTrue(scopeAdmin.newScopeUpdate().getChildren().isEmpty());
+    }
+    
+    @org.ops4j.pax.exam.junit.Configuration
+    public static Option[] configuration() {
+        Option[] options = options(
+            // Log
+            mavenBundle("org.ops4j.pax.logging", "pax-logging-api"),
+            mavenBundle("org.ops4j.pax.logging", "pax-logging-service"),
+            // Felix Config Admin
+            mavenBundle("org.apache.felix", "org.apache.felix.configadmin"),
+            // Felix mvn url handler
+            mavenBundle("org.ops4j.pax.url", "pax-url-mvn"),
+
+
+            // this is how you set the default log level when using pax logging (logProfile)
+            systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("DEBUG"),
+
+            // Bundles
+            mavenBundle("org.apache.aries.testsupport", "org.apache.aries.testsupport.unit"),
+            mavenBundle("org.apache.aries.application", "org.apache.aries.application.api"),
+            mavenBundle("org.apache.aries", "org.apache.aries.util"),
+            mavenBundle("org.apache.aries.application", "org.apache.aries.application.utils"),
+            mavenBundle("org.apache.felix", "org.apache.felix.bundlerepository"),
+            mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.api"),
+            mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.scope.api"),
+            mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.scope.impl"),
+
+            // org.ops4j.pax.exam.container.def.PaxRunnerOptions.vmOption("-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005"),
+
+            PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),
+
+            equinox().version("3.7.0.v20110221")
+        );
+        options = updateOptions(options);
+        return options;
+    }
+
+    private Scope createScope(Scope scopeAdmin, String scopeName, String loc, String version) throws MalformedURLException, InvalidSyntaxException, BundleException, IOException {
+        ScopeUpdate su = scopeAdmin.newScopeUpdate();
+        
+        ScopeUpdate childScopeUpdate = su.newChild(scopeName);
+        su.getChildren().add(childScopeUpdate);
+        addPackageImportPolicy("org.osgi.framework", childScopeUpdate);
+        addPackageImportPolicy("org.osgi.util.tracker", childScopeUpdate);
+        Map<String, List<SharePolicy>> sharePolicies = childScopeUpdate.getSharePolicies(SharePolicy.TYPE_EXPORT);
+        final Filter filter1 = FrameworkUtil.createFilter(
+                "(&" + 
+                  "(osgi.wiring.package=org.apache.aries.subsystem.example.helloIsolation)" +
+                  "(version=" + version + ")" +
+                ")");
+        final Filter filter2 = FrameworkUtil.createFilter(
+                "(&" + 
+                  "(scope.share.service=org.apache.aries.subsystem.example.helloIsolation.HelloIsolation)" +
+                ")");
+        List<SharePolicy> packagePolicies = sharePolicies.get(BundleRevision.PACKAGE_NAMESPACE);
+        if (packagePolicies == null) {
+            packagePolicies = new ArrayList<SharePolicy>();
+            sharePolicies.put(BundleRevision.PACKAGE_NAMESPACE, packagePolicies);
+        }
+        packagePolicies.add(new SharePolicy(SharePolicy.TYPE_EXPORT, BundleRevision.PACKAGE_NAMESPACE, filter1));
+        List<SharePolicy> servicePolicies = sharePolicies.get("scope.share.service");
+        if (servicePolicies == null) {
+            servicePolicies = new ArrayList<SharePolicy>();
+            sharePolicies.put("scope.share.service", servicePolicies);
+        }
+        servicePolicies.add(new SharePolicy(SharePolicy.TYPE_EXPORT, "scope.share.service", filter2));
+
+
+        // build up installInfo object for the scope
+        InstallInfo info1 = new InstallInfo("helloIsolation_" + scopeName, new URL(loc));
+
+        List<InstallInfo> bundlesToInstall = childScopeUpdate.getBundlesToInstall();
+        bundlesToInstall.add(info1);
+        
+        // add bundles to be installed, based on subsystem content
+        su.commit();
+        
+        // start all bundles in the scope scope_test1
+        Collection<Bundle> bundlesToStart = childScopeUpdate.getScope().getBundles();
+        for (Bundle b : bundlesToStart) {
+            b.start();
+        }
+        
+        return childScopeUpdate.getScope();
+    }
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ScopeProvider.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ScopeProvider.java
index e69de29b..e698e48a 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ScopeProvider.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ScopeProvider.java
@@ -0,0 +1,7 @@
+package org.apache.aries.subsystem.scope.itests;
+
+import org.apache.aries.subsystem.scope.Scope;
+
+public interface ScopeProvider {
+	Scope getScope();
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ScopeSecurityTest.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ScopeSecurityTest.java
index e69de29b..42068d90 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ScopeSecurityTest.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ScopeSecurityTest.java
@@ -0,0 +1,394 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.subsystem.scope.itests;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.ops4j.pax.exam.CoreOptions.equinox;
+import static org.ops4j.pax.exam.CoreOptions.options;
+import static org.ops4j.pax.exam.CoreOptions.systemProperty;
+
+import java.net.URL;
+import java.security.Permission;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.aries.subsystem.example.helloIsolation.HelloIsolation;
+import org.apache.aries.subsystem.scope.InstallInfo;
+import org.apache.aries.subsystem.scope.Scope;
+import org.apache.aries.subsystem.scope.ScopeUpdate;
+import org.apache.aries.subsystem.scope.SharePolicy;
+import org.junit.After;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.ops4j.pax.exam.Option;
+import org.ops4j.pax.exam.container.def.PaxRunnerOptions;
+import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Filter;
+import org.osgi.framework.FrameworkUtil;
+import org.osgi.framework.PackagePermission;
+import org.osgi.framework.ServiceReference;
+import org.osgi.framework.wiring.BundleRevision;
+import org.osgi.service.condpermadmin.ConditionInfo;
+import org.osgi.service.condpermadmin.ConditionalPermissionAdmin;
+import org.osgi.service.condpermadmin.ConditionalPermissionInfo;
+import org.osgi.service.condpermadmin.ConditionalPermissionUpdate;
+import org.osgi.service.permissionadmin.PermissionInfo;
+import org.osgi.util.tracker.BundleTracker;
+
+
+@RunWith(JUnit4TestRunner.class)
+public class ScopeSecurityTest extends AbstractIntegrationTest {
+
+    /* Use @Before not @BeforeClass so as to ensure that these resources
+     * are created in the paxweb temp directory, and not in the svn tree 
+     */
+    static boolean createdApplications = false;
+    BundleTracker bt;
+    int addEventCount;
+    int modifyEventCount;
+    int removeEventCount;
+    private final static PermissionInfo[] adminAllowInfo = {
+        new PermissionInfo("java.security.AllPermission", "*", "*"),
+        new PermissionInfo("java.lang.RuntimePermission", "loadLibrary.*", "*"),
+        new PermissionInfo("java.lang.RuntimePermission", "queuePrintJob", "*"),
+        new PermissionInfo("java.net.SocketPermission", "*", "connect"),
+        new PermissionInfo("java.util.PropertyPermission", "*", "read"),
+        new PermissionInfo("org.osgi.framework.PackagePermission", "*", "exportonly,import"),
+        new PermissionInfo("org.osgi.framework.ServicePermission", "*", "get,register"),
+        new PermissionInfo("org.osgi.framework.AdminPermission", "*", "execute,resolve"),
+    };
+    
+    @After
+    public void tearDown() throws Exception {
+        if (bt != null) {
+            bt.close();
+        }
+    }
+    
+    //@Test
+    public void testScopeSecurityWithServiceIsolation() throws Exception {
+        // make sure we are using a framework that provides composite admin service
+        Scope scopeAdmin = getOsgiService(Scope.class);
+        assertNotNull("scope admin should not be null", scopeAdmin);
+        System.out.println("able to get scope admin service");
+       
+        ScopeUpdate su = scopeAdmin.newScopeUpdate();
+        
+        ScopeUpdate childScopeUpdate = su.newChild("scope_test1");
+        
+        // build up installInfo object for the scope
+        InstallInfo info1 = new InstallInfo("helloIsolation", new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolation/0.4-SNAPSHOT"));
+        InstallInfo info2 = new InstallInfo("helloIsolationRef", new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolationRef/0.4-SNAPSHOT"));
+
+        List<InstallInfo> bundlesToInstall = childScopeUpdate.getBundlesToInstall();
+        bundlesToInstall.add(info1);
+        bundlesToInstall.add(info2);
+        
+        // add bundles to be installed, based on subsystem content
+        su.commit();
+
+        // start all bundles in the scope scope_test1
+        Collection<Bundle> bundlesToStart = childScopeUpdate.getBundles();
+        for (Bundle b : bundlesToStart) {
+            b.start();
+            
+        }
+        
+        try {
+            ServiceReference sr = bundleContext.getServiceReference("org.apache.aries.subsystem.example.helloIsolation.HelloIsolation");
+            fail("should not be able to get the sr for HelloIsolation service");
+        } catch (Exception ex) {
+            // expected 
+        } catch (Error er) {
+            // expected
+        }
+        
+        // test bundle find hooks
+        Bundle[] bundles = bundleContext.getBundles();
+        for (Bundle b : bundles) {
+            System.out.println("Bundle is " + b.getBundleId() + ": " + b.getSymbolicName());
+            if (b.getSymbolicName().indexOf("org.apache.aries.subsystem.example.helloIsolation") > -1) {
+                fail("bundles with name starts with org.apache.aries.subsystem.example.helloIsolation should be in a different scope");
+            }
+        }
+        
+        // test bundle service find hook
+        //ServiceReference sr = bundleContext.getServiceReference(HelloIsolation.class.getName());
+        //assertNull("sr should be null", sr);
+        Collection<Scope> children = scopeAdmin.getChildren();
+        assertEquals(1, children.size());
+        
+        for (Scope child : children) {
+            if (child.getName().equals("scope_test1")) {
+                Collection<Bundle> buns = child.getBundles();
+                assertEquals(2, buns.size());
+                assertEquals(0, child.getChildren().size());
+                BundleContext childScopebundleContext = null;
+
+                for (Bundle b : buns) {
+                    assertTrue(b.getSymbolicName().indexOf("org.apache.aries.subsystem.example.helloIsolation") > -1);
+                    if (b.getSymbolicName().indexOf("org.apache.aries.subsystem.example.helloIsolationRef") > -1) {
+                        childScopebundleContext = b.getBundleContext();
+                    }
+
+                }
+                assertNotNull(childScopebundleContext);
+                ServiceReference sr = childScopebundleContext.getServiceReference("org.apache.aries.subsystem.example.helloIsolation.HelloIsolation");
+                assertNotNull("sr is not null", sr);
+                System.out.println("got the sr, go get service next");
+                Object obj = childScopebundleContext.getService(sr);
+                //HelloIsolation hi = (HelloIsolation)childScopebundleContext.getService(sr);
+                
+            }
+        }
+        
+        // install a test bundle in the root scope
+        URL url = new URL("mvn:org.apache.felix/org.apache.felix.fileinstall/2.0.8");
+        bundleContext.installBundle("org.apache.felix.fileinstall-rootScope", url.openStream());
+        
+        // remove child scope
+        su = scopeAdmin.newScopeUpdate();
+        Collection<ScopeUpdate> scopes = su.getChildren();
+        
+        // obtain child scope admin from service registry
+//        String filter = "ScopeName=scope_test1";
+        Scope childScopeAdmin = childScopeUpdate.getScope();
+        assertEquals(scopeAdmin, childScopeAdmin.getParent());
+        scopes.remove(childScopeUpdate);
+        su.commit();
+        
+        assertFalse(scopeAdmin.getChildren().contains(childScopeAdmin));
+        su = scopeAdmin.newScopeUpdate();
+        assertFalse(su.getChildren().contains(childScopeUpdate));
+        
+//        childScopeAdmin = null;
+//        try {
+//            childScopeAdmin = getOsgiService(Scope.class, filter, DEFAULT_TIMEOUT);
+//        } catch (Exception ex) {
+//            // ignore
+//        }
+//        assertNull("scope admin service for the scope should be unregistered", childScopeAdmin);
+        
+    }
+    
+    //@Test
+    public void testScopeSecurityWithServiceShared() throws Exception {
+        
+        SecurityManager security = System.getSecurityManager();
+        assertNotNull("Security manager should not be null", security);
+       
+        Bundle[] bundles = bundleContext.getBundles();
+        
+        for (Bundle b : bundles) {
+            // set up condition permission for scopeAdmin
+            if (b.getSymbolicName().indexOf("subsystem.scope.impl") > -1) {
+                ServiceReference permRef = bundleContext.getServiceReference(ConditionalPermissionAdmin.class.getName());
+
+                ConditionalPermissionAdmin permAdmin = (ConditionalPermissionAdmin) bundleContext.getService(permRef);
+                ConditionalPermissionUpdate update = permAdmin.newConditionalPermissionUpdate();
+
+                List<ConditionalPermissionInfo> infos = update.getConditionalPermissionInfos();
+                //infos.clear();
+
+                // set up the conditionInfo
+                ConditionInfo[] conditionInfo = new ConditionInfo[] {new ConditionInfo("org.osgi.service.condpermadmin.BundleLocationCondition", new String[]{b.getLocation()})}; 
+                // Set up permissions which are common to all applications
+                infos.add(permAdmin.newConditionalPermissionInfo(null, conditionInfo, adminAllowInfo, "allow"));
+                update.commit();
+            }
+            
+        }
+        
+        // make sure we are using a framework that provides composite admin service
+        Scope scopeAdmin = getOsgiService(Scope.class);
+        assertNotNull("scope admin should not be null", scopeAdmin);
+        System.out.println("able to get scope admin service");
+        
+        ScopeUpdate su = scopeAdmin.newScopeUpdate();
+        
+        ScopeUpdate childScopeUpdate = su.newChild("scope_test1");
+        
+        Map<String, List<SharePolicy>> sharePolicies = childScopeUpdate.getSharePolicies(SharePolicy.TYPE_EXPORT);
+        final Filter filter1 = FrameworkUtil.createFilter(
+                "(&" + 
+                  "(osgi.package=org.apache.aries.subsystem.example.helloIsolation)" +
+                ")");
+        final Filter filter2 = FrameworkUtil.createFilter(
+                "(&" + 
+                  "(osgi.service=org.apache.aries.subsystem.example.helloIsolation.HelloIsolation)" +
+                ")");
+        List<SharePolicy> packagePolicies = sharePolicies.get(BundleRevision.PACKAGE_NAMESPACE);
+        if (packagePolicies == null) {
+            packagePolicies = new ArrayList<SharePolicy>();
+            sharePolicies.put(BundleRevision.PACKAGE_NAMESPACE, packagePolicies);
+        }
+        packagePolicies.add(new SharePolicy(SharePolicy.TYPE_EXPORT, BundleRevision.PACKAGE_NAMESPACE, filter1));
+        List<SharePolicy> servicePolicies = sharePolicies.get("scope.share.service");
+        if (servicePolicies == null) {
+            servicePolicies = new ArrayList<SharePolicy>();
+            sharePolicies.put("scope.share.service", servicePolicies);
+        }
+        servicePolicies.add(new SharePolicy(SharePolicy.TYPE_EXPORT, "scope.share.service", filter2));
+
+        // build up installInfo object for the scope
+        InstallInfo info1 = new InstallInfo("helloIsolation", new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolation/0.4-SNAPSHOT"));
+        InstallInfo info2 = new InstallInfo("helloIsolationRef", new URL("mvn:org.apache.aries.subsystem.example/org.apache.aries.subsystem.example.helloIsolationRef/0.4-SNAPSHOT"));
+
+        List<InstallInfo> bundlesToInstall = childScopeUpdate.getBundlesToInstall();
+        bundlesToInstall.add(info1);
+        bundlesToInstall.add(info2);
+        
+        // add bundles to be installed, based on subsystem content
+        su.commit();
+        
+        // start all bundles in the scope scope_test1
+        Collection<Bundle> bundlesToStart = childScopeUpdate.getBundles();
+        for (Bundle b : bundlesToStart) {
+            b.start();
+            
+        }
+        
+        try {
+            ServiceReference sr = bundleContext.getServiceReference("org.apache.aries.subsystem.example.helloIsolation.HelloIsolation");
+            fail("should not be able to get the sr for HelloIsolation service");
+        } catch (Exception ex) {
+            // expected 
+        } catch (Error er) {
+            // expected
+        }
+        
+        // test bundle find hooks
+        bundles = bundleContext.getBundles();
+        for (Bundle b : bundles) {
+            System.out.println("Bundle is " + b.getBundleId() + ": " + b.getSymbolicName());
+            if (b.getSymbolicName().indexOf("org.apache.aries.subsystem.example.helloIsolation") > -1) {
+                fail("bundles with name starts with org.apache.aries.subsystem.example.helloIsolation should be in a different scope");
+            }
+        }
+        
+        // test bundle service find hook
+        //ServiceReference sr = bundleContext.getServiceReference(HelloIsolation.class.getName());
+        //assertNull("sr should be null", sr);
+        Collection<Scope> children = scopeAdmin.getChildren();
+        assertEquals(1, children.size());
+        
+        for (Scope child : children) {
+            if (child.getName().equals("scope_test1")) {
+                Collection<Bundle> buns = child.getBundles();
+                assertEquals(2, buns.size());
+                assertEquals(0, child.getChildren().size());
+                BundleContext childScopebundleContext = null;
+
+                for (Bundle b : buns) {
+                    assertTrue(b.getSymbolicName().indexOf("org.apache.aries.subsystem.example.helloIsolation") > -1);
+                    if (b.getSymbolicName().indexOf("org.apache.aries.subsystem.example.helloIsolationRef") > -1) {
+                        childScopebundleContext = b.getBundleContext();
+                    }
+
+                }
+                assertNotNull(childScopebundleContext);
+                ServiceReference sr = childScopebundleContext.getServiceReference("org.apache.aries.subsystem.example.helloIsolation.HelloIsolation");
+                assertNotNull("sr is not null", sr);
+                System.out.println("got the sr, go get service next");
+                HelloIsolation hi = (HelloIsolation)childScopebundleContext.getService(sr);
+                hi.hello();
+                
+                Permission permission = new PackagePermission("*", PackagePermission.IMPORT);
+                hi.checkPermission(permission);
+            }
+        }
+        
+        // install a test bundle in the root scope
+        URL url = new URL("mvn:org.apache.felix/org.apache.felix.fileinstall/2.0.8");
+        bundleContext.installBundle("org.apache.felix.fileinstall-rootScope", url.openStream());
+        
+        // remove child scope
+        su = scopeAdmin.newScopeUpdate();
+        Collection<ScopeUpdate> scopes = su.getChildren();
+        
+        // obtain child scope admin from service registry
+//        String filter = "ScopeName=scope_test1";
+        Scope childScopeAdmin = childScopeUpdate.getScope();
+        assertEquals(scopeAdmin, childScopeAdmin.getParent());
+        scopes.remove(childScopeUpdate);
+        su.commit();
+        
+        assertFalse(scopeAdmin.getChildren().contains(childScopeAdmin));
+        su = scopeAdmin.newScopeUpdate();
+        assertFalse(su.getChildren().contains(childScopeUpdate));
+        
+//        childScopeAdmin = null;
+//        try {
+//            childScopeAdmin = getOsgiService(Scope.class, filter, DEFAULT_TIMEOUT);
+//        } catch (Exception ex) {
+//            // ignore
+//        }
+//        assertNull("scope admin service for the scope should be unregistered", childScopeAdmin);
+        
+    }
+    
+   
+    @org.ops4j.pax.exam.junit.Configuration
+    public static Option[] configuration() {
+        Option[] options = options(
+            // Log
+            mavenBundle("org.ops4j.pax.logging", "pax-logging-api"),
+            mavenBundle("org.ops4j.pax.logging", "pax-logging-service"),
+            // Felix Config Admin
+            mavenBundle("org.apache.felix", "org.apache.felix.configadmin"),
+            // Felix mvn url handler
+            mavenBundle("org.ops4j.pax.url", "pax-url-mvn"),
+
+
+            // this is how you set the default log level when using pax logging (logProfile)
+            systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("DEBUG"),
+
+            // Bundles
+            mavenBundle("org.apache.aries.testsupport", "org.apache.aries.testsupport.unit"),
+            mavenBundle("org.apache.aries.application", "org.apache.aries.application.api"),
+            mavenBundle("org.apache.aries", "org.apache.aries.util"),
+            mavenBundle("org.apache.aries.application", "org.apache.aries.application.utils"),
+            mavenBundle("org.apache.felix", "org.apache.felix.bundlerepository"),
+            mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.api"),
+            mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.scope.api"),
+            mavenBundle("org.apache.aries.subsystem", "org.apache.aries.subsystem.scope.impl"),
+
+            // uncomment the following line if you want to turn on security.  the policy file can be found in src/test/resources dir and you want to update the value of -Djava.security.policy to 
+            // the exact location of the policy file.
+            //org.ops4j.pax.exam.container.def.PaxRunnerOptions.vmOption("-Declipse.security=osgi -Djava.security.policy=/policy"),
+            //org.ops4j.pax.exam.container.def.PaxRunnerOptions.vmOption("-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005 -Declipse.security=osgi -Djava.security.policy=/policy"),
+
+            PaxRunnerOptions.rawPaxRunnerOption("config", "classpath:ss-runner.properties"),
+
+            equinox().version("3.7.0.v20110221")
+        );
+        options = updateOptions(options);
+        return options;
+    }
+
+   
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/Service.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/Service.java
index e69de29b..5334b9c7 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/Service.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/Service.java
@@ -0,0 +1,4 @@
+package org.apache.aries.subsystem.scope.itests;
+
+public interface Service {
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ServiceVisibilityTest.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ServiceVisibilityTest.java
index ada1bb9a..deab583f 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ServiceVisibilityTest.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/ServiceVisibilityTest.java
@@ -1,3 +1,81 @@
   + text/plain
   + Date Revision
   + native
+package org.apache.aries.subsystem.scope.itests;
+
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import java.net.URL;
+
+import org.apache.aries.subsystem.scope.InstallInfo;
+import org.apache.aries.subsystem.scope.ScopeUpdate;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.ServiceReference;
+
+/**
+ * Bundles may only see other services registered by other bundles within the 
+ * same scope. The one exception is the system bundle, whose services may be 
+ * seen by all bundles regardless of scope.
+ */
+@RunWith(JUnit4TestRunner.class)
+public class ServiceVisibilityTest extends AbstractTest {
+	/**
+	 * Install a bundle registering a service into the same scope as this one. 
+	 * This bundle should be able to see the service.
+	 * @throws Exception
+	 */
+	@Test
+	public void test1() throws Exception {
+		assertTrue(scope.getBundles().contains(bundleContext.getBundle()));
+		ScopeUpdate scopeUpdate = scope.newScopeUpdate();
+		String location = getBundleLocation("tb-7.jar");
+		assertNull(bundleContext.getBundle(location));
+		URL url = new URL(location);
+		InstallInfo installInfo = new InstallInfo(location, url.openStream());
+		scopeUpdate.getBundlesToInstall().add(installInfo);
+		scopeUpdate.commit();
+		Bundle bundle = bundleContext.getBundle(location);
+		assertNotNull(bundle);
+		assertTrue(scope.getBundles().contains(bundle));
+		bundle.start();
+		ServiceReference<Service> serviceRef = bundleContext.getServiceReference(Service.class);
+		assertNotNull(serviceRef);
+		Service service = bundleContext.getService(serviceRef);
+		assertNotNull(service);
+		bundleContext.ungetService(serviceRef);
+		bundle.uninstall();
+	}
+	
+	/**
+	 * Install a bundle registering a service into a different scope than this 
+	 * one. This bundle should not be able to see the service.
+	 * @throws Exception
+	 */
+	@Test
+	public void test2() throws Exception {
+		assertTrue(scope.getBundles().contains(bundleContext.getBundle()));
+		String location = getBundleLocation("tb-7.jar");
+		assertNull(bundleContext.getBundle(location));
+		URL url = new URL(location);
+		InstallInfo installInfo = new InstallInfo(location, url.openStream());
+		ScopeUpdate scopeUpdate = scope.newScopeUpdate();
+		ScopeUpdate child = scopeUpdate.newChild("tb7");
+		scopeUpdate.getChildren().add(child);
+		child.getBundlesToInstall().add(installInfo);
+		addPackageImportPolicy("org.osgi.framework", child);
+		addPackageImportPolicy("org.apache.aries.subsystem.scope.itests", child);
+		scopeUpdate.commit();
+		Bundle bundle = bundleContext.getBundle(location);
+		assertNotNull(bundle);
+		assertTrue(child.getScope().getBundles().contains(bundle));
+		bundle.start();
+		ServiceReference<Service> serviceRef = bundleContext.getServiceReference(Service.class);
+		assertNull(serviceRef);
+		bundle.uninstall();
+	}
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/SharePolicyTest.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/SharePolicyTest.java
index ada1bb9a..046d7605 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/SharePolicyTest.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/SharePolicyTest.java
@@ -1,3 +1,200 @@
   + text/plain
   + Date Revision
   + native
+package org.apache.aries.subsystem.scope.itests;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+import java.net.URL;
+import java.util.Arrays;
+
+import org.apache.aries.subsystem.scope.InstallInfo;
+import org.apache.aries.subsystem.scope.ScopeUpdate;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.wiring.FrameworkWiring;
+
+@RunWith(JUnit4TestRunner.class)
+public class SharePolicyTest extends AbstractTest {
+	/**
+	 * Bundle tb5
+	 * Bundle tb6
+	 * tb5 imports package exported by tb6
+	 * tb5 and tb6 in same scope
+	 * tb5 should resolve
+	 * 
+	 * Share policies have no effect within the same scope.
+	 * 
+	 * @throws Exception
+	 */
+	@Test
+	public void test1() throws Exception {
+		Bundle tb5 = null;
+		Bundle tb6 = null;
+		try {
+			String tb5Location = getBundleLocation("tb-5.jar");
+			String tb6Location = getBundleLocation("tb-6.jar");
+			InstallInfo tb5Info = new InstallInfo(tb5Location, new URL(tb5Location));
+			InstallInfo tb6Info = new InstallInfo(tb6Location, new URL(tb6Location));
+			ScopeUpdate scopeUpdate = scope.newScopeUpdate();
+			scopeUpdate.getBundlesToInstall().add(tb5Info);
+			scopeUpdate.commit();
+			tb5 = findBundleInRootScope("org.apache.aries.subsystem.scope.itests.tb5");
+			assertNotNull(tb5);
+			FrameworkWiring frameworkWiring = bundleContext.getBundle(0).adapt(FrameworkWiring.class);
+			assertFalse(frameworkWiring.resolveBundles(Arrays.asList(new Bundle[]{tb5})));
+			scopeUpdate = scope.newScopeUpdate();
+			scopeUpdate.getBundlesToInstall().add(tb6Info);
+			scopeUpdate.commit();
+			tb6 = findBundleInRootScope("org.apache.aries.subsystem.scope.itests.tb6");
+			assertNotNull(tb6);
+			assertTrue(frameworkWiring.resolveBundles(Arrays.asList(new Bundle[]{tb5,tb6})));
+		}
+		finally {
+			uninstallQuietly(tb6);
+			uninstallQuietly(tb5);
+		}
+	}
+	
+	/**
+	 * Bundle tb5
+	 * Bundle tb6
+	 * tb5 imports package exported by tb6
+	 * tb5 in root scope
+	 * tb6 in child scope of root
+	 * tb6 scope does not export tb6 package
+	 * tb5 should not resolve
+	 * @throws Exception
+	 */
+	@Test
+	public void test2() throws Exception {
+		Bundle tb5 = null;
+		Bundle tb6 = null;
+		try {
+			String tb5Location = getBundleLocation("tb-5.jar");
+			String tb6Location = getBundleLocation("tb-6.jar");
+			InstallInfo tb5Info = new InstallInfo(tb5Location, new URL(tb5Location));
+			InstallInfo tb6Info = new InstallInfo(tb6Location, new URL(tb6Location));
+			ScopeUpdate scopeUpdate = scope.newScopeUpdate();
+			scopeUpdate.getBundlesToInstall().add(tb5Info);
+			scopeUpdate.commit();
+			tb5 = findBundleInRootScope("org.apache.aries.subsystem.scope.itests.tb5");
+			assertNotNull(tb5);
+			FrameworkWiring frameworkWiring = bundleContext.getBundle(0).adapt(FrameworkWiring.class);
+			assertFalse(frameworkWiring.resolveBundles(Arrays.asList(new Bundle[]{tb5})));
+			scopeUpdate = scope.newScopeUpdate();
+			ScopeUpdate tb6ScopeUpdate = scopeUpdate.newChild("tb6");
+			scopeUpdate.getChildren().add(tb6ScopeUpdate);
+			tb6ScopeUpdate.getBundlesToInstall().add(tb6Info);
+			scopeUpdate.commit();
+			tb6 = findBundle("org.apache.aries.subsystem.scope.itests.tb6", tb6ScopeUpdate.getScope());
+			assertNotNull(tb6);
+			assertFalse(frameworkWiring.resolveBundles(Arrays.asList(new Bundle[]{tb5,tb6})));
+		}
+		finally {
+			uninstallQuietly(tb6);
+			uninstallQuietly(tb5);
+		}
+	}
+	
+	/**
+	 * Bundle tb5
+	 * Bundle tb6
+	 * tb5 imports package exported by tb6
+	 * tb5 in root scope
+	 * tb6 in child scope of root
+	 * tb6 scope exports tb6 package
+	 * tb5 should resolve
+	 * 
+	 * There is an implicit import between parent and child. In other words,
+	 * anything exported by a child is automatically available without the
+	 * parent explicitly importing it.
+	 * 
+	 * @throws Exception
+	 */
+	@Test
+	public void test3() throws Exception {
+		Bundle tb5 = null;
+		Bundle tb6 = null;
+		try {
+			String tb5Location = getBundleLocation("tb-5.jar");
+			String tb6Location = getBundleLocation("tb-6.jar");
+			InstallInfo tb5Info = new InstallInfo(tb5Location, new URL(tb5Location));
+			InstallInfo tb6Info = new InstallInfo(tb6Location, new URL(tb6Location));
+			ScopeUpdate scopeUpdate = scope.newScopeUpdate();
+			scopeUpdate.getBundlesToInstall().add(tb5Info);
+			scopeUpdate.commit();
+			tb5 = findBundleInRootScope("org.apache.aries.subsystem.scope.itests.tb5");
+			assertNotNull(tb5);
+			FrameworkWiring frameworkWiring = bundleContext.getBundle(0).adapt(FrameworkWiring.class);
+			assertFalse(frameworkWiring.resolveBundles(Arrays.asList(new Bundle[]{tb5})));
+			scopeUpdate = scope.newScopeUpdate();
+			ScopeUpdate tb6ScopeUpdate = scopeUpdate.newChild("tb6");
+			scopeUpdate.getChildren().add(tb6ScopeUpdate);
+			tb6ScopeUpdate.getBundlesToInstall().add(tb6Info);
+			addPackageExportPolicy("org.apache.aries.subsystem.scope.itests.tb6", tb6ScopeUpdate);
+			scopeUpdate.commit();
+			tb6 = findBundle("org.apache.aries.subsystem.scope.itests.tb6", tb6ScopeUpdate.getScope());
+			assertNotNull(tb6);
+			tb5.start();
+			assertTrue(frameworkWiring.resolveBundles(Arrays.asList(new Bundle[]{tb5,tb6})));
+		}
+		finally {
+			uninstallQuietly(tb6);
+			uninstallQuietly(tb5);
+		}
+	}
+	
+	/**
+	 * Bundle tb5
+	 * Bundle tb6
+	 * tb5 imports package exported by tb6
+	 * tb5 in child scope of root
+	 * tb6 in different child scope of root
+	 * tb6 scope exports tb6 package
+	 * root scope exports tb6 package
+	 * tb5 scope imports tb6 package
+	 * tb5 should resolve
+	 * 
+	 * @throws Exception
+	 */
+	@Test
+	public void test4() throws Exception {
+		Bundle tb5 = null;
+		Bundle tb6 = null;
+		try {
+			String tb5Location = getBundleLocation("tb-5.jar");
+			String tb6Location = getBundleLocation("tb-6.jar");
+			InstallInfo tb5Info = new InstallInfo(tb5Location, new URL(tb5Location));
+			InstallInfo tb6Info = new InstallInfo(tb6Location, new URL(tb6Location));
+			ScopeUpdate rootUpdate = scope.newScopeUpdate();
+			addPackageExportPolicy("org.apache.aries.subsystem.scope.itests.tb6", rootUpdate);
+			ScopeUpdate tb5Update = rootUpdate.newChild("tb5");
+			rootUpdate.getChildren().add(tb5Update);
+			tb5Update.getBundlesToInstall().add(tb5Info);
+			addPackageImportPolicy("org.apache.aries.subsystem.scope.itests.tb6", tb5Update);
+			rootUpdate.commit();
+			tb5 = findBundle("org.apache.aries.subsystem.scope.itests.tb5", tb5Update.getScope());
+			assertNotNull(tb5);
+			FrameworkWiring frameworkWiring = bundleContext.getBundle(0).adapt(FrameworkWiring.class);
+			assertFalse(frameworkWiring.resolveBundles(Arrays.asList(new Bundle[]{tb5})));
+			rootUpdate = scope.newScopeUpdate();
+			ScopeUpdate tb6Update = rootUpdate.newChild("tb6");
+			rootUpdate.getChildren().add(tb6Update);
+			tb6Update.getBundlesToInstall().add(tb6Info);
+			addPackageExportPolicy("org.apache.aries.subsystem.scope.itests.tb6", tb6Update);
+			rootUpdate.commit();
+			tb6 = findBundle("org.apache.aries.subsystem.scope.itests.tb6", tb6Update.getScope());
+			assertNotNull(tb6);
+			assertTrue(frameworkWiring.resolveBundles(Arrays.asList(new Bundle[]{tb5,tb6})));
+		}
+		finally {
+			uninstallQuietly(tb6);
+			uninstallQuietly(tb5);
+		}
+	}
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/UninstallBundleTest.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/UninstallBundleTest.java
index e69de29b..ca32dddc 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/UninstallBundleTest.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/UninstallBundleTest.java
@@ -0,0 +1,54 @@
+package org.apache.aries.subsystem.scope.itests;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+import java.util.Arrays;
+
+import org.apache.aries.subsystem.scope.ScopeUpdate;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.ops4j.pax.exam.junit.JUnit4TestRunner;
+import org.osgi.framework.Bundle;
+
+/**
+ * Tests whether or not a bundle can be successfully uninstalled from a scope.
+ * The root scope is used for this test.
+ */
+@RunWith(JUnit4TestRunner.class)
+public class UninstallBundleTest extends AbstractTest {
+	private Bundle bundle;
+	private String location;
+	
+	@Test
+	public void test() throws Exception {
+		ScopeUpdate scopeUpdate = scope.newScopeUpdate();
+		assertTrue("The bundle should have been removed", scopeUpdate.getBundles().remove(bundle));
+		assertTrue("The commit should have been successful", scopeUpdate.commit());
+		assertFalse("The bundle should have been removed from the scope", scope.getBundles().contains(bundle));
+		assertFalse(Arrays.asList(bundleContext.getBundles()).contains(bundle));
+		assertNull("The bundle should have been uninstalled", bundleContext.getBundle(location));
+	}
+	
+	@Before
+	public void before0() throws Exception {
+		super.before();
+		location = getBundleLocation("tb-2.jar");
+		bundle = bundleContext.getBundle(location);
+		assertNull("The bundle should not exist", bundle);
+		installBundles(scope, new String[]{"tb-2.jar"});
+		bundle = bundleContext.getBundle(location);
+		assertNotNull("The bundle should exist", bundle);
+		assertTrue("The bundle should part of the scope", scope.getBundles().contains(bundle));
+	}
+	
+	@After
+	public void after0() throws Exception {
+		uninstallQuietly(bundle);
+		super.after();
+	}
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/Utils.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/Utils.java
index e69de29b..546aa701 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/Utils.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/apache/aries/subsystem/scope/itests/Utils.java
@@ -0,0 +1,52 @@
+package org.apache.aries.subsystem.scope.itests;
+
+import org.apache.aries.subsystem.scope.Scope;
+import org.osgi.framework.Bundle;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceReference;
+import org.osgi.framework.ServiceRegistration;
+
+public class Utils {
+	public static Bundle findBundle(String symbolicName, Scope scope) {
+		if (scope == null) return null;
+		for (Bundle b : scope.getBundles()) {
+			if (symbolicName == null) {
+				if (b.getSymbolicName() == null)
+					return b;
+			}
+			else if (symbolicName.equals(b.getSymbolicName()))
+				return b;
+		}
+		return null;
+	}
+	
+	public static void ungetQuietly(ServiceReference<?> serviceReference, BundleContext bundleContext) {
+		if (serviceReference == null) return;
+		try {
+			bundleContext.ungetService(serviceReference);
+		}
+		catch (Exception e) {
+			// ignore
+		}
+	}
+	
+	public static void uninstallQuietly(Bundle bundle) {
+		if (bundle == null) return;
+		try {
+			bundle.uninstall();
+		}
+		catch (Exception e) {
+			// ignore
+		}
+	}
+	
+	public static void unregisterQuietly(ServiceRegistration<?> serviceRegistration) {
+		if (serviceRegistration == null) return;
+		try {
+			serviceRegistration.unregister();
+		}
+		catch (Exception e) {
+			// ignore
+		}
+	}
+}
diff --git a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/ops4j/pax/runner/platform/equinox/internal/SsActivator.java b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/ops4j/pax/runner/platform/equinox/internal/SsActivator.java
index 8c3aa744..f85f24f0 100644
--- a/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/ops4j/pax/runner/platform/equinox/internal/SsActivator.java
+++ b/aries/trunk/subsystem/subsystem-scope-itests/src/test/java/org/ops4j/pax/runner/platform/equinox/internal/SsActivator.java
@@ -43,6 +43,7 @@
             new EquinoxPlatformBuilder( bundleContext, "3.5.1" ),
             new EquinoxPlatformBuilder( bundleContext, "3.6.0" ),
             new EquinoxPlatformBuilder( bundleContext, "3.7.0.V20101022" ),
+            new EquinoxPlatformBuilder( bundleContext, "3.7.0.V20110221" ),
             new EquinoxPlatformBuilderSnapshot( bundleContext )
         };
     }
