diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/JoinStrategy.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/JoinStrategy.java
index 5d2c4fb0..6d3784b1 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/JoinStrategy.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/JoinStrategy.java
@@ -115,7 +115,8 @@ OptimizablePredicateList getBasePredicates(
 	 * @return	The extra selectivity due to non-base predicates
 	 */
 	double nonBasePredicateSelectivity(Optimizable innerTable,
-										OptimizablePredicateList predList);
+										OptimizablePredicateList predList)
+	throws StandardException;
 
 	/**
 	 * Put back and base predicates that were removed from the list by
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/OptimizablePredicate.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/OptimizablePredicate.java
index 9b62ba11..10f51830 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/OptimizablePredicate.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/OptimizablePredicate.java
@@ -133,7 +133,8 @@ int hasEqualOnColumnList(int[] baseColumnPositions,
 	 *
 	 * @param optTable	The Optimizable that this predicate restricts
 	 */
-	double selectivity(Optimizable optTable);
+	double selectivity(Optimizable optTable)
+	throws StandardException;
 
 	/**
 	 * Get the position of the index column that this predicate restricts.
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BaseColumnNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BaseColumnNode.java
index a33f20d5..a92b175d 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BaseColumnNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BaseColumnNode.java
@@ -67,7 +67,7 @@
 	public void init(
 							Object columnName,
 							Object tableName,
-				   			Object dts)
+				   			Object dts) throws StandardException
 	{
 		this.columnName = (String) columnName;
 		this.tableName = (TableName) tableName;
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryListOperatorNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryListOperatorNode.java
index adc1b070..0e92cf62 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryListOperatorNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryListOperatorNode.java
@@ -164,7 +164,7 @@ public ValueNode bindExpression(
 		rightOperandList.bindExpression(fromList, subqueryList, aggregateVector);
 
 		/* Is there a ? parameter on the left? */
-		if (leftOperand.isParameterNode())
+		if (leftOperand.requiresTypeFromContext())
 		{
 			ValueNode rightOperand = (ValueNode) rightOperandList.elementAt(0);
 
@@ -178,7 +178,7 @@ public ValueNode bindExpression(
 			}
 
 			/* Set the left operand to the type of right parameter. */
-			((ParameterNode) leftOperand).setDescriptor(rightOperandList.getTypeServices());
+			leftOperand.setType(rightOperandList.getTypeServices());
 		}
 
 		/* Is there a ? parameter on the right? */
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryLogicalOperatorNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryLogicalOperatorNode.java
index 1a55db50..dc8ecf6d 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryLogicalOperatorNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryLogicalOperatorNode.java
@@ -93,6 +93,13 @@ public ValueNode bindExpression(
 		//following is to check if we have something like "? AND 1=1" or "2>1 OR ?" 
 		if (leftOperand.isParameterNode() || rightOperand.isParameterNode())
 			throw StandardException.newException(SQLState.LANG_NON_BOOLEAN_WHERE_CLAUSE, "PARAMETER" );
+		//following 2 ifs are to check if we have something like "+? AND 1=1" or "2>1 OR -?" ie -?/+? by themselves 
+		if ((leftOperand instanceof UnaryOperatorNode) &&
+				((UnaryOperatorNode)leftOperand).isUnaryMinusOrPlusWithParameter())
+			throw StandardException.newException(SQLState.LANG_NON_BOOLEAN_WHERE_CLAUSE, "PARAMETER" );
+		if ((rightOperand instanceof UnaryOperatorNode) &&
+				((UnaryOperatorNode)rightOperand).isUnaryMinusOrPlusWithParameter())
+			throw StandardException.newException(SQLState.LANG_NON_BOOLEAN_WHERE_CLAUSE, "PARAMETER" );
 
 		super.bindExpression(fromList, subqueryList, aggregateVector);
 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java
index 0d977096..177cda8e 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java
@@ -313,26 +313,26 @@ public ValueNode bindExpression(
 			return bindXMLExists();
 
 		/* Is there a ? parameter on the left? */
-		if (leftOperand.isParameterNode())
+		if (leftOperand.requiresTypeFromContext())
 		{
 			/*
 			** It's an error if both operands are ? parameters.
 			*/
-			if (rightOperand.isParameterNode())
+			if (rightOperand.requiresTypeFromContext())
 			{
 				throw StandardException.newException(SQLState.LANG_BINARY_OPERANDS_BOTH_PARMS, 
 																	operator);
 			}
 
 			/* Set the left operand to the type of right parameter. */
-			((ParameterNode) leftOperand).setDescriptor(rightOperand.getTypeServices());
+			leftOperand.setType(rightOperand.getTypeServices());
 		}
 
 		/* Is there a ? parameter on the right? */
-		if (rightOperand.isParameterNode())
+		if (rightOperand.requiresTypeFromContext())
 		{
 			/* Set the right operand to the type of the left parameter. */
-			((ParameterNode) rightOperand).setDescriptor(leftOperand.getTypeServices());
+			rightOperand.setType(leftOperand.getTypeServices());
 		}
 
 		return genSQLJavaSQLTree();
@@ -382,16 +382,16 @@ public ValueNode bindXMLExists() throws StandardException
         }
 
         // Is there a ? parameter on the left?
-        if (leftOperand.isParameterNode())
+        if (leftOperand.requiresTypeFromContext())
         {
             // Set the left operand to be a VARCHAR, which should be
             // long enough to hold the XPath expression.
-            ((ParameterNode) leftOperand).setDescriptor(
+            leftOperand.setType(
                 DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR));
         }
 
         // Is there a ? parameter on the right?
-        if (rightOperand.isParameterNode())
+        if (rightOperand.requiresTypeFromContext())
         {
             // For now, since JDBC has no type defined for XML, we
             // don't allow binding to an XML parameter.
@@ -619,6 +619,7 @@ public void generateExpression(ExpressionClassBuilder acb,
 	//following method is no-op here but in concatenation node, this method is used to check if resultField is null,
 	//and if yes, then we want it to be initialized to NULL SQLxxx type object
 	protected void initializeResultField(ExpressionClassBuilder acb, MethodBuilder mb, LocalField resultField)
+	throws StandardException
 	{
 	}
 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryRelationalOperatorNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryRelationalOperatorNode.java
index da7f527a..cf5afcad 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryRelationalOperatorNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/BinaryRelationalOperatorNode.java
@@ -710,7 +710,7 @@ public boolean compareWithKnownConstant(Optimizable optTable, boolean considerPa
 		if (considerParameters)
 		{
 			return (node instanceof ConstantNode) ||
-						((node.isParameterNode()) &&
+						((node.requiresTypeFromContext()) &&
 						 (((ParameterNode)node).getDefaultValue() != null));
 		}
 		else
@@ -738,9 +738,14 @@ public DataValueDescriptor getCompareValue(Optimizable optTable)
 		{
 			return ((ConstantNode)node).getValue();
 		}
-		else if (node.isParameterNode())
+		else if (node.requiresTypeFromContext())
 		{
-			return ((ParameterNode)node).getDefaultValue();
+			ParameterNode pn;
+			if (node instanceof UnaryOperatorNode) 
+	  			pn = ((UnaryOperatorNode)node).getParameterOperand();
+			else
+	  			pn = (ParameterNode) (node);
+			return pn.getDefaultValue();
 		}
 		else
 		{	
@@ -754,6 +759,7 @@ else if (node.isParameterNode())
 	 * selectivity otherwise.
 	 */
 	protected double booleanSelectivity(Optimizable optTable)
+	throws StandardException
 	{
 		TypeId	typeId = null;
 		double				retval = -1.0d;
@@ -990,6 +996,7 @@ public int getOperator()
 	/** return the selectivity of this predicate.
 	 */
 	public double selectivity(Optimizable optTable)
+	throws StandardException
 	{
 		double retval = booleanSelectivity(optTable);
 		
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CastNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CastNode.java
index 3ac8c725..29225aa1 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CastNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CastNode.java
@@ -403,7 +403,7 @@ public void bindCastNodeOnly()
 			destCTI = castTarget.getTypeId();
 		}
 
-		if (castOperand.isParameterNode())
+		if (castOperand.requiresTypeFromContext())
 		{
 			bindParameter();
 		}
@@ -819,7 +819,7 @@ public boolean constantExpression(PredicateList whereClause)
 	void bindParameter()
 					throws StandardException
 	{
-		((ParameterNode) castOperand).setDescriptor(castTarget);
+		castOperand.setType(castTarget);
 	}
 
 	/**
@@ -887,7 +887,7 @@ public void generateExpression(ExpressionClassBuilder acb,
 		 * They'll get an exception, as expected, if the
 		 * conversion cannot be performed.
 		 */
-		else if (castOperand.isParameterNode())
+		else if (castOperand.requiresTypeFromContext())
 		{
 			sourceCTI = destCTI;
 		}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CoalesceFunctionNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CoalesceFunctionNode.java
index e3823508..abdd2837 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CoalesceFunctionNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CoalesceFunctionNode.java
@@ -147,7 +147,7 @@ public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
 		//find the first non-param argument. The generated method will generate code to call coalesce on this argument
 		for (int index = 0; index < argumentsListSize; index++)
 		{
-			if (!(((ValueNode) argumentsList.elementAt(index)).isParameterNode()))
+			if (!(((ValueNode) argumentsList.elementAt(index)).requiresTypeFromContext()))
 			{
 				firstNonParameterNode = (ValueNode) argumentsList.elementAt(index);
 				break;
@@ -157,7 +157,7 @@ public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
 		//make sure these arguments are compatible to each other before coalesce can be allowed
 		for (int index = 0; index < argumentsListSize; index++)
 		{
-			if (((ValueNode) argumentsList.elementAt(index)).isParameterNode()) //since we don't know the type of param, can't check for compatibility
+			if (((ValueNode) argumentsList.elementAt(index)).requiresTypeFromContext()) //since we don't know the type of param, can't check for compatibility
 				continue;
 				argumentsList.compatible((ValueNode) argumentsList.elementAt(index));
 		}
@@ -168,9 +168,9 @@ public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
 		//set all the parameter types to the type of the result type
 		for (int index = 0; index < argumentsListSize; index++)
 		{
-			if (((ValueNode) argumentsList.elementAt(index)).isParameterNode())
+			if (((ValueNode) argumentsList.elementAt(index)).requiresTypeFromContext())
 			{
-				((ParameterNode) argumentsList.elementAt(index)).setDescriptor(getTypeServices());
+				((ValueNode)argumentsList.elementAt(index)).setType(getTypeServices());
 				break;
 			}
 		}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnDefinitionNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnDefinitionNode.java
index 86cf5bf8..cb863a19 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnDefinitionNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnDefinitionNode.java
@@ -591,6 +591,7 @@ private static DefaultInfoImpl createDefaultInfoOfAutoInc(){
 	public boolean defaultTypeIsValid(TypeId columnType,
 		DataTypeDescriptor columnDesc, TypeId defaultType,
 		ValueNode defaultNode, String defaultText)
+	throws StandardException
 	{
 
 		if (defaultText.length() > Limits.DB2_CHAR_MAXWIDTH)
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
index 0a6149dc..0be16261 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
@@ -1018,7 +1018,7 @@ boolean pointsToColumnReference()
 	 * @return	The DataTypeServices from this Node.  This
 	 *		may be null if the node isn't bound yet.
 	 */
-	public DataTypeDescriptor getTypeServices()
+	public DataTypeDescriptor getTypeServices() throws StandardException
 	{
         DataTypeDescriptor dtd = super.getTypeServices();
         if( dtd == null && source != null)
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ConcatenationOperatorNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ConcatenationOperatorNode.java
index 64e9ae75..f66553db 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ConcatenationOperatorNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ConcatenationOperatorNode.java
@@ -94,9 +94,9 @@ public ValueNode bindExpression(
 			maximum length for that type.
 		*/
 
-		if (leftOperand.isParameterNode())
+		if (leftOperand.requiresTypeFromContext())
 		{
-			if (rightOperand.isParameterNode())
+			if (rightOperand.requiresTypeFromContext())
 			{
 				throw StandardException.newException(SQLState.LANG_BINARY_OPERANDS_BOTH_PARMS,
 																	operator);
@@ -137,13 +137,13 @@ public ValueNode bindExpression(
 					leftType = TypeId.getBuiltInTypeId(Types.VARCHAR);
 			}
 
-		((ParameterNode) leftOperand).setDescriptor(new DataTypeDescriptor(leftType, true));
+		leftOperand.setType(new DataTypeDescriptor(leftType, true));
 		}
 
 		/*
 			Is there a ? parameter on the right?
 		*/
-		if (rightOperand.isParameterNode())
+		if (rightOperand.requiresTypeFromContext())
 		{
 			TypeId 	rightType;
 
@@ -180,7 +180,7 @@ public ValueNode bindExpression(
 					rightType = TypeId.getBuiltInTypeId(Types.VARCHAR);
 			}
 		
-		((ParameterNode) rightOperand).setDescriptor(
+		rightOperand.setType(
 							new DataTypeDescriptor(
 										rightType,
 										true));
@@ -491,6 +491,7 @@ else if (higherType.equals(TypeId.LONGVARBIT_NAME))
 	 *worry about field coming in as null
 	*/
 	protected void initializeResultField(ExpressionClassBuilder acb, MethodBuilder mb, LocalField resultField)
+	throws StandardException
 	{
 		mb.conditionalIfNull();//get the field on the stack and if it is null
 			acb.generateNull(mb, getTypeCompiler());// yes, it is, hence create a NULL SQLxxx type object and put that on stack
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ConditionalNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ConditionalNode.java
index 7318f996..413c2883 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ConditionalNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ConditionalNode.java
@@ -175,9 +175,9 @@ public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
 		 * If it is a ? parameter on the left, then set type to boolean,
 		 * otherwise verify that the result type is boolean.
 		 */
-		if (testCondition.isParameterNode())
+		if (testCondition.requiresTypeFromContext())
 		{
-			((ParameterNode) testCondition).setDescriptor(
+			testCondition.setType(
 							new DataTypeDescriptor(
 										TypeId.BOOLEAN_ID,
 										true));
@@ -207,7 +207,7 @@ else if (thenElseList.containsParameterNode())
 			DataTypeDescriptor dts;
 			ValueNode typeExpression;
 
-			if (thenExpression.isParameterNode())
+			if (thenExpression.requiresTypeFromContext())
 			{
 				dts = elseExpression.getTypeServices();
 			}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java
index 1d573c84..593fe0ce 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/FromBaseTable.java
@@ -1239,7 +1239,7 @@ public CostEstimate estimateCost(OptimizablePredicateList predList,
 						if (firstColumn != null && leftOpnd instanceof LikeEscapeOperatorNode)
 						{
 							LikeEscapeOperatorNode likeNode = (LikeEscapeOperatorNode) leftOpnd;
-							if (likeNode.getLeftOperand().isParameterNode())
+							if (likeNode.getLeftOperand().requiresTypeFromContext())
 							{
 								ValueNode receiver = ((TernaryOperatorNode) likeNode).getReceiver();
 								if (receiver instanceof ColumnReference)
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/HasVariantValueNodeVisitor.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/HasVariantValueNodeVisitor.java
index 50ca89f5..db709a3b 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/HasVariantValueNodeVisitor.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/HasVariantValueNodeVisitor.java
@@ -115,7 +115,7 @@ public Visitable visit(Visitable node) throws StandardException
 	{
 		if (node instanceof ValueNode)
 		{
-			if (ignoreParameters && ((ValueNode)node).isParameterNode())
+			if (ignoreParameters && ((ValueNode)node).requiresTypeFromContext())
 				return node;
 				
 			if (((ValueNode)node).getOrderableVariantType() <= variantType)
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/HashJoinStrategy.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/HashJoinStrategy.java
index 6ab01ef9..a584aed7 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/HashJoinStrategy.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/HashJoinStrategy.java
@@ -172,7 +172,8 @@ public OptimizablePredicateList getBasePredicates(
 	/** @see JoinStrategy#nonBasePredicateSelectivity */
 	public double nonBasePredicateSelectivity(
 										Optimizable innerTable,
-										OptimizablePredicateList predList) {
+										OptimizablePredicateList predList) 
+	throws StandardException {
 		double retval = 1.0;
 
 		if (predList != null) {
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/IsNullNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/IsNullNode.java
index 88940f93..b8c59d5b 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/IsNullNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/IsNullNode.java
@@ -146,8 +146,7 @@ void bindParameter()
 		** for a varchar.
 		*/
 
-		((ParameterNode) operand).setDescriptor(
-							new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), true));
+		operand.setType(new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), true));
 	}
 
 	/* RelationalOperator interface */
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/JavaValueNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/JavaValueNode.java
index 723b323c..266911ca 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/JavaValueNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/JavaValueNode.java
@@ -74,7 +74,7 @@
 	/* Name of field holding receiver value, if any */
 	private LocalField receiverField;
 
-	public boolean isPrimitiveType()
+	public boolean isPrimitiveType() throws StandardException
 	{
 		JSQLType	myType = getJSQLType();
 		
@@ -82,7 +82,7 @@ public boolean isPrimitiveType()
 		else { return ( myType.getCategory() == JSQLType.JAVA_PRIMITIVE ); }
 	}
 
-	public String getJavaTypeName()
+	public String getJavaTypeName() throws StandardException
 	{
 		JSQLType	myType = getJSQLType();
 
@@ -156,9 +156,7 @@ public void castToPrimitive(boolean booleanValue)
 	  *	@return	the corresponding JSQLType
 	  *
 	  */
-	public	JSQLType	getJSQLType
-	(
-    )
+	public	JSQLType	getJSQLType() throws StandardException
 	{ return jsqlType; }
 
 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/JoinNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/JoinNode.java
index b5d37768..9a5b264b 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/JoinNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/JoinNode.java
@@ -907,7 +907,7 @@ else if (usingClause != null)
 			/* If joinClause is a parameter, (where ?), then we assume
 			 * it will be a nullable boolean.
 			 */
-			if (joinClause.isParameterNode())
+			if (joinClause.requiresTypeFromContext())
 			{
 				joinClause.setType(new DataTypeDescriptor(TypeId.BOOLEAN_ID, true));
 			}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/LengthOperatorNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/LengthOperatorNode.java
index 08065f37..b7e04c67 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/LengthOperatorNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/LengthOperatorNode.java
@@ -147,8 +147,7 @@ void bindParameter()
 		** for a varchar.
 		*/
 
-		((ParameterNode) operand).setDescriptor(
-							DataTypeDescriptor.getBuiltInDataTypeDescriptor(parameterType, true, 
+		operand.setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor(parameterType, true, 
 												parameterWidth));
 	}
 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/LikeEscapeOperatorNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/LikeEscapeOperatorNode.java
index 1ece92ff..5d3636bf 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/LikeEscapeOperatorNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/LikeEscapeOperatorNode.java
@@ -164,7 +164,7 @@ public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
 
 		// pattern must be a string or a parameter
 
-		if (!(leftOperand.isParameterNode()) && !(leftOperand.getTypeId().isStringTypeId()))
+		if (!(leftOperand.requiresTypeFromContext()) && !(leftOperand.getTypeId().isStringTypeId()))
 			throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE,
 													 "LIKE", "FUNCTION");
 
@@ -177,7 +177,7 @@ public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
 
 		// escape must be a string or a parameter
 		if ((rightOperand != null) && 
-			!(rightOperand.isParameterNode()) && 
+			!(rightOperand.requiresTypeFromContext()) && 
 			!(rightOperand.getTypeId().isStringTypeId()))
 		{
 			throw StandardException.newException(SQLState.LANG_DB2_FUNCTION_INCOMPATIBLE,
@@ -193,9 +193,9 @@ public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
 		 *  the left, since it won't match if it is any longer than it.
 		 */
 
-		if (receiver.isParameterNode())
+		if (receiver.requiresTypeFromContext())
 		{
-			((ParameterNode) receiver).setDescriptor(
+			receiver.setType(
 							new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), true));
 		}
 
@@ -206,7 +206,7 @@ public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
 		 *  REMIND: should nullability be copied, or set to true?
 		 */
 
-		if (leftOperand.isParameterNode())
+		if (leftOperand.requiresTypeFromContext())
 		{
 			/*
 			 * Set the pattern to the type of the left parameter, if
@@ -214,11 +214,11 @@ public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
 			 */
 			if (receiver.getTypeId().isStringTypeId())
 			{
-				((ParameterNode) leftOperand).setDescriptor(receiver.getTypeServices());
+				leftOperand.setType(receiver.getTypeServices());
 			}
 			else
 			{
-				((ParameterNode) leftOperand).setDescriptor(
+				leftOperand.setType(
 							new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), true));
 			}
 		}
@@ -229,7 +229,7 @@ public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
 		 *  both will be max length.  nullability is set to true.
 		 */
 
-		if (rightOperand != null && rightOperand.isParameterNode())
+		if (rightOperand != null && rightOperand.requiresTypeFromContext())
 		{
 			/*
 			 * Set the pattern to the type of the left parameter, if
@@ -237,11 +237,11 @@ public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
 			 */
 			if (receiver.getTypeId().isStringTypeId())
 			{
-				((ParameterNode) rightOperand).setDescriptor(receiver.getTypeServices());
+				rightOperand.setType(receiver.getTypeServices());
 			}
 			else
 			{
-				((ParameterNode) rightOperand).setDescriptor(
+				rightOperand.setType(
 							new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.VARCHAR), true));
 			}
 		}
@@ -526,7 +526,7 @@ public ValueNode preprocess(int numTables,
 		 * beginning of execution.
 		 */
 		if (!(leftOperand instanceof CharConstantNode) &&
-			!(leftOperand.isParameterNode()))
+			!(leftOperand.requiresTypeFromContext()))
 		{
 			return this;
 		}
@@ -604,11 +604,11 @@ public ValueNode preprocess(int numTables,
 		   Currently for a national string we do not add a < than operator
 		   since we don't know (?) how to calculate such a string.
 		 */
-		if ( lessThanString != null || ( leftOperand.isParameterNode() &&
+		if ( lessThanString != null || ( leftOperand.requiresTypeFromContext() &&
                                          ! receiver.getTypeId().isNationalStringTypeId() ))
 		{
 			QueryTreeNode likeLTopt;
-			if (leftOperand.isParameterNode())
+			if (leftOperand.requiresTypeFromContext())
 			{
 				likeLTopt = setupOptimizeStringFromParameter(leftOperand, rightOperand,
 								"lessThanStringFromParameter");
@@ -650,7 +650,7 @@ public ValueNode preprocess(int numTables,
 		 */
 
 		ValueNode likeGEopt;
-		if (leftOperand.isParameterNode()) {
+		if (leftOperand.requiresTypeFromContext()) {
 
 			// Create an expression off the parameter
 			// new SQLChar(Like.greaterEqualString(?));
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/MethodCallNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/MethodCallNode.java
index cdc69f7f..51dfaa0f 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/MethodCallNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/MethodCallNode.java
@@ -645,8 +645,7 @@ public void	setNullParameterInfo(String[] parmTypeNames)
 			{		
 				/* Set the type information in the null constant node */
 				DataTypeDescriptor dts = DataTypeDescriptor.getSQLDataTypeDescriptor(parmTypeNames[i]);
-				((SQLToJavaValueNode)methodParms[i]).value.setDescriptor(
-																	dts);
+				((SQLToJavaValueNode)methodParms[i]).value.setType(dts);
 
 				/* Set the correct java type name */
 				methodParms[i].setJavaTypeName(parmTypeNames[i]);
@@ -1058,7 +1057,7 @@ protected	boolean	someParametersAreNull()
 			if (methodParms[index] instanceof SQLToJavaValueNode)
 			{
 				SQLToJavaValueNode stjvn = (SQLToJavaValueNode) methodParms[index];
-				if (stjvn.value.isParameterNode())
+				if (stjvn.value.requiresTypeFromContext())
 				{
 					isParam[index] = true;
 				}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NonStaticMethodCallNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NonStaticMethodCallNode.java
index 1e740f96..4572842b 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NonStaticMethodCallNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NonStaticMethodCallNode.java
@@ -152,11 +152,9 @@ public JavaValueNode bindExpression(
 			//	then we have a type for it. Binding can continue.
 			//
 
-			if (SQLValue.isParameterNode())
+			if (SQLValue.requiresTypeFromContext())
 			{
-				ParameterNode	unnamedParameter = (ParameterNode) SQLValue;
-
-				if ( unnamedParameter.getTypeServices() == null )
+				if ( SQLValue.getTypeServices() == null )
 				{ throw StandardException.newException(SQLState.LANG_PARAMETER_RECEIVER, methodName); }
 			}
 		}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ParameterNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ParameterNode.java
index d5c06a20..8393607a 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ParameterNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ParameterNode.java
@@ -180,21 +180,12 @@ public void setDescriptors(DataTypeDescriptor[] descriptors)
 	 * @return	Nothing
 	 */
 
-	public void setDescriptor(DataTypeDescriptor descriptor)
+	public void setType(DataTypeDescriptor descriptor) throws StandardException
 	{
 		if (SanityManager.DEBUG)
 		SanityManager.ASSERT(typeServices != null,
 			"typeServices not initialized");
 
-		// if type already determined, there's nothing to do.
-		// this can occur if a named parameter ("?paramName") is
-		// set equal to a unnamed parameter ("?") in a COPY PUBLICATION
-		// statement. in this case, the named parameter may be referenced
-		// multiple times. each time it must resolve to the same "?"
-		// parameter.
-
-		if ( typeServices[parameterNumber] != null ) { return; }
-
 		/* Make sure the type is nullable. */
 		if ( ! descriptor.isNullable())
 		{
@@ -207,7 +198,10 @@ public void setDescriptor(DataTypeDescriptor descriptor)
 
 		typeServices[parameterNumber] = descriptor;
 
-		setType(descriptor);
+		//make sure we are calling super's setType. We will get into
+		//an infinite loop if this setType ends up calling the local
+		//setType method
+		super.setType(descriptor);
 
 		if ( getJSQLType() == null ) { setJSQLType(  new JSQLType( descriptor ) ); }
 	}
@@ -236,7 +230,7 @@ public boolean isReturnOutputParam()
 	 * Bind this expression.  A parameter can't figure out what its type
 	 * is without knowing where it appears, so this method does nothing.
 	 * It is up to the node that points to this parameter node to figure
-	 * out the type of the parameter and set it, using the setDescriptor()
+	 * out the type of the parameter and set it, using the setType()
 	 * method above.
 	 *
 	 * @param fromList		The FROM list for the query this
@@ -387,7 +381,7 @@ public void generateExpression(ExpressionClassBuilder acb,
 		// in "bindExpression" because at the time of bindExpression,
 		// we don't know yet what the type is going to be (only when
 		// the node that points to this parameter calls
-		// "setDescriptor" do we figure out the type).
+		// "setType" do we figure out the type).
 			throw StandardException.newException(
 				SQLState.LANG_ATTEMPT_TO_BIND_XML);
 		}
@@ -467,7 +461,7 @@ void generateHolder(ExpressionClassBuilder acb) throws StandardException {
 		/* The constructor portion is done */
 	}
 
-	public TypeId getTypeId()
+	public TypeId getTypeId() throws StandardException
 	{
 		return (returnOutputParameter != null) ?
 			returnOutputParameter.getTypeId() : super.getTypeId();
@@ -595,6 +589,14 @@ DataValueDescriptor getDefaultValue()
 		return defaultValue;
 	}
 	
+	/**
+	 * @see ValueNode#requiresTypeFromContext
+	 */
+	public boolean requiresTypeFromContext()
+	{
+		return true;
+	}
+	
 	/**
 	 * @see ValueNode#isParameterNode
 	 */
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/Predicate.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/Predicate.java
index 73a13151..51cd5c8f 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/Predicate.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/Predicate.java
@@ -244,6 +244,7 @@ public boolean equalsComparisonWithConstantExpression(Optimizable optTable)
 
 	/** @see OptimizablePredicate#selectivity */
 	public double selectivity(Optimizable optTable)
+	throws StandardException
 	{
 		return andNode.getLeftOperand().selectivity(optTable);
 	}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java
index 5cf25c9b..9e01c5d9 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/PredicateList.java
@@ -1049,6 +1049,7 @@ public void eliminateBooleanTrueAndBooleanTrue()
 	 * @return ValueNode	The rebuilt expression tree.
 	 */
 	public ValueNode restoreConstantPredicates()
+	throws StandardException
 	{
 		AndNode			nextAnd;
 		AndNode			falseAnd = null;
@@ -1145,6 +1146,7 @@ else if (falseAnd != null)
 	 * @return ValueNode	The rebuilt expression tree.
 	 */
 	public ValueNode restorePredicates()
+	throws StandardException
 	{
 		AndNode			nextAnd;
 		AndNode			falseAnd = null;
@@ -3649,6 +3651,7 @@ private int chooseLongestMatch(PredicateWrapperList[] predArray, Vector ret,
 	 * Compute selectivity the old fashioned way.
 	 */
 	private double selectivityNoStatistics(Optimizable optTable)
+	throws StandardException
 	{
 		double selectivity = 1.0;
 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java
index e6e15736..04773bd7 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java
@@ -138,7 +138,7 @@
 	 *
 	 * @return	The newly initialized ResultColumn
 	 */
-	public void init(Object arg1, Object arg2)
+	public void init(Object arg1, Object arg2) throws StandardException
 	{
 		// RESOLVE: This is something of a hack - it is not obvious that
 		// the first argument being null means it should be treated as
@@ -282,7 +282,7 @@ public DataTypeDescriptor getType()
 		return dataTypeServices;
 	}
 
-	public DataTypeDescriptor getExpressionType()
+	public DataTypeDescriptor getExpressionType() throws StandardException
 	{
 		return (expression == null) ?
 			dataTypeServices :
@@ -574,11 +574,11 @@ public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
 		** Don't do it if this result column doesn't have a type yet.
 		** This can happen if the parameter is part of a table constructor.
 		*/
-		if (expression.isParameterNode())
+		if (expression.requiresTypeFromContext())
 		{
 			if (getTypeServices() != null)
 			{
-				((ParameterNode) expression).setDescriptor(getTypeServices());
+				expression.setType(getTypeServices());
 			}
 		}
 
@@ -977,7 +977,7 @@ boolean columnTypeAndLengthMatch()
 		** parameters.  So don't even bother in this
 		** case.
 		*/
-		if (expression.isParameterNode())
+		if (expression.requiresTypeFromContext())
 		{
 			return false;
 		}
@@ -1051,8 +1051,8 @@ boolean columnTypeAndLengthMatch(ResultColumn otherColumn)
 		** parameters.  So don't even bother in this
 		** case.
 		*/
-		if ((otherExpression != null) && (otherExpression.isParameterNode()) ||
-			(expression.isParameterNode()))
+		if ((otherExpression != null) && (otherExpression.requiresTypeFromContext()) ||
+			(expression.requiresTypeFromContext()))
 		{
 			return false;
 		}
@@ -1294,12 +1294,12 @@ public void markAsGroupingColumn()
 	}
 
 	/**
-	 * Look for and reject ? parameter under this ResultColumn.  This is
+	 * Look for and reject ?/-?/+? parameter under this ResultColumn.  This is
 	 * called for SELECT statements.
 	 *
 	 * @return	Nothing
 	 *
-	 * @exception StandardException		Thrown if a ? parameter was found
+	 * @exception StandardException		Thrown if a ?/-?/+? parameter was found
 	 *									directly under this ResultColumn.
 	 */
 
@@ -1307,6 +1307,9 @@ void rejectParameter() throws StandardException
 	{
 		if ((expression != null) && (expression.isParameterNode()))
 			throw StandardException.newException(SQLState.LANG_PARAM_IN_SELECT_LIST);
+		if ((expression != null) && (expression instanceof UnaryOperatorNode) &&
+				((UnaryOperatorNode)expression).isUnaryMinusOrPlusWithParameter())
+			throw StandardException.newException(SQLState.LANG_PARAM_IN_SELECT_LIST);
 	}
 
 	/*
@@ -1710,7 +1713,7 @@ private DataValueDescriptor convertConstant(TypeId toTypeId, int maxWidth, DataV
 	 * @return	The TypeId from this Node.  This
 	 *		may be null if the node isn't bound yet.
 	 */
-	public TypeId getTypeId()
+	public TypeId getTypeId() throws StandardException
 	{
         TypeId t = super.getTypeId();
         if( t == null)
@@ -1731,7 +1734,7 @@ public TypeId getTypeId()
 	 * @return	The DataTypeServices from this Node.  This
 	 *		may be null if the node isn't bound yet.
 	 */
-	public DataTypeDescriptor getTypeServices()
+	public DataTypeDescriptor getTypeServices() throws StandardException
 	{
         DataTypeDescriptor dtd = super.getTypeServices();
         if( dtd == null && expression != null)
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
index c9ba77d2..37c628db 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
@@ -1532,7 +1532,7 @@ public void nameAllResultColumns()
 	 *
 	 * @return Nothing.
 	 */
-	public void copyTypesAndLengthsToSource(ResultColumnList sourceRCL)
+	public void copyTypesAndLengthsToSource(ResultColumnList sourceRCL) throws StandardException
 	{
 		/* Source and target can have different lengths. */
 		int size = (size() > sourceRCL.size()) ? size() : sourceRCL.size();
@@ -2279,7 +2279,7 @@ public void	checkAutoincrementUnion(ResultSetNode rs)
 	 *
 	 * @return boolean	Whether or not there is an exact UNION type match on the 2 RCLs.
 	 */
-	public boolean isExactTypeAndLengthMatch(ResultColumnList otherRCL)
+	public boolean isExactTypeAndLengthMatch(ResultColumnList otherRCL) throws StandardException
 	{
 		int size = size();
 		for (int index = 0; index < size; index++)
@@ -2843,7 +2843,7 @@ void setIndexRow(long cid, boolean forUpdate)
 	 *
 	 * @return boolean	Whether or not the type information is consistent
 	 */
-	public boolean hasConsistentTypeInfo()
+	public boolean hasConsistentTypeInfo() throws StandardException
 	{
 		boolean isConsistent = true;
 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultSetNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultSetNode.java
index e8171b9a..41e541c1 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultSetNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultSetNode.java
@@ -329,7 +329,7 @@ void setTableConstructorTypes(ResultColumnList typeColumns)
 
 			ValueNode re = rc.getExpression();
 
-			if (re.isParameterNode())
+			if (re.requiresTypeFromContext())
 			{
 				ResultColumn	typeCol =
 					(ResultColumn) typeColumns.elementAt(index);
@@ -338,8 +338,7 @@ void setTableConstructorTypes(ResultColumnList typeColumns)
 				** We found a ? - set its type to the type of the
 				** corresponding column of the target table.
 				*/
-				((ParameterNode) re).setDescriptor(
-										typeCol.getTypeServices());
+				re.setType(typeCol.getTypeServices());
 			}
 			else if (re instanceof CharConstantNode)
 			{
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SQLToJavaValueNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SQLToJavaValueNode.java
index 099bc6f2..f1f7ac9b 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SQLToJavaValueNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SQLToJavaValueNode.java
@@ -103,6 +103,7 @@ public void printSubNodes(int depth)
 	  *
 	  */
 	public String getJavaTypeName()
+	throws StandardException
 	{
 		JSQLType	myType = getJSQLType();
 
@@ -143,15 +144,18 @@ public String getPrimitiveTypeName()
 	  *	@return	the corresponding JSQLType
 	  *
 	  */
-	public	JSQLType	getJSQLType
-	(
-    )
+	public	JSQLType	getJSQLType	() throws StandardException
 	{
 		if ( jsqlType == null )
 		{
-			if ( value.isParameterNode() ) 
+			if ( value.requiresTypeFromContext()) 
 			{
-				jsqlType = ((ParameterNode) value).getJSQLType();
+  				ParameterNode pn;
+	  			if (value instanceof UnaryOperatorNode) 
+	  				pn = ((UnaryOperatorNode)value).getParameterOperand();
+	  			else
+	  				pn = (ParameterNode) (value);
+				jsqlType = pn.getJSQLType();
 			}
 			else
 			{
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
index 212148e9..63e7dda9 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
@@ -528,12 +528,13 @@ public void bindExpressions(FromList fromListParam)
 				throw StandardException.newException(SQLState.LANG_NO_AGGREGATES_IN_WHERE_CLAUSE);
 			}
 
-			/* If whereClause is a parameter, (where ?), then we should catch it and throw exception
+			/* If whereClause is a parameter, (where ?/where -?/where +?), then we should catch it and throw exception
 			 */
 			if (whereClause.isParameterNode())
-			{
 				throw StandardException.newException(SQLState.LANG_NON_BOOLEAN_WHERE_CLAUSE, "PARAMETER" );
-			}
+			if ((whereClause instanceof UnaryOperatorNode) &&
+					((UnaryOperatorNode)whereClause).isUnaryMinusOrPlusWithParameter())
+				throw StandardException.newException(SQLState.LANG_NON_BOOLEAN_WHERE_CLAUSE, "PARAMETER" );
 			
 			whereClause = whereClause.checkIsBoolean();
 		}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SetOperatorNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SetOperatorNode.java
index a99b27cd..0f63fab5 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SetOperatorNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SetOperatorNode.java
@@ -249,6 +249,7 @@ public void bindUntypedNullsToResultColumns(ResultColumnList rcl)
 	 * @return	The number of new types found in the RowResultSetNode
 	 */
 	int getParamColumnTypes(DataTypeDescriptor[] types, RowResultSetNode rrsn)
+	 throws StandardException
 	{
 		int	numTypes = 0;
 
@@ -259,7 +260,7 @@ int getParamColumnTypes(DataTypeDescriptor[] types, RowResultSetNode rrsn)
 			{
 				ResultColumn rc =
 					(ResultColumn) rrsn.getResultColumns().elementAt(i);
-				if ( ! (rc.getExpression().isParameterNode()))
+				if ( ! (rc.getExpression().requiresTypeFromContext()))
 				{
 					types[i] = rc.getExpressionType();
 					numTypes++;
@@ -294,14 +295,13 @@ void setParamColumnTypes(DataTypeDescriptor[] types, RowResultSetNode rrsn)
 		{
 			ResultColumn	rc = (ResultColumn) rrcl.elementAt(index);
 
-			if (rc.getExpression().isParameterNode())
+			if (rc.getExpression().requiresTypeFromContext())
 			{
 				/*
 				** We found a ? - set its type to the type from the
 				** type array.
 				*/
-				((ParameterNode) rc.getExpression()).setDescriptor(
-											types[index]);
+				rc.getExpression().setType(types[index]);
 			}
 		}
 	}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SimpleStringOperatorNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SimpleStringOperatorNode.java
index e4d07191..7a181075 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SimpleStringOperatorNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SimpleStringOperatorNode.java
@@ -146,8 +146,7 @@ void bindParameter()
 		** for a bit.
 		*/
 
-		((ParameterNode) operand).setDescriptor(
-							DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR));
+		operand.setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR));
 	}
 
 	/**
@@ -157,4 +156,14 @@ void bindParameter()
 	public String getReceiverInterfaceName() {
 	    return ClassName.StringDataValue;
 	}
+
+	/**
+	 * @see ValueNode#requiresTypeFromContext
+	 */
+	public boolean requiresTypeFromContext()
+	{
+	    //should return false because lower(?)/upper(?) are bound to varchar and hence don't
+	    //require their type to be set from the context. 
+	    return false;
+	}
 }
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/StaticClassFieldReferenceNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/StaticClassFieldReferenceNode.java
index a65a3bb3..f2f3483b 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/StaticClassFieldReferenceNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/StaticClassFieldReferenceNode.java
@@ -229,6 +229,7 @@ protected int getOrderableVariantType()
 	 */
 	public void generateExpression(ExpressionClassBuilder acb,
 											MethodBuilder mb)
+	throws StandardException
 	{
 		/*
 		** Generate the following:
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/StaticMethodCallNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/StaticMethodCallNode.java
index 80ac9ef7..0aaf6b1c 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/StaticMethodCallNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/StaticMethodCallNode.java
@@ -381,7 +381,7 @@ private void resolveRoutine(FromList fromList, SubqueryList subqueryList, Vector
 				}
 
 				boolean isParameterMarker = true;
-				if ((sqlParamNode == null) || !sqlParamNode.isParameterNode())
+				if ((sqlParamNode == null) || !sqlParamNode.requiresTypeFromContext())
 				{
 					if (parameterMode != JDBC30Translation.PARAMETER_MODE_IN) {
 					 
@@ -395,6 +395,10 @@ private void resolveRoutine(FromList fromList, SubqueryList subqueryList, Vector
 				{
 					if (applicationParameterNumbers == null)
 						applicationParameterNumbers = new int[parameterCount];
+		  			if (sqlParamNode instanceof UnaryOperatorNode) {
+		  				ParameterNode pn = ((UnaryOperatorNode)sqlParamNode).getParameterOperand();
+		  				applicationParameterNumbers[p] = pn.getParameterNumber();
+		  			} else
 					applicationParameterNumbers[p] = ((ParameterNode) sqlParamNode).getParameterNumber();
 				}
 
@@ -416,7 +420,7 @@ private void resolveRoutine(FromList fromList, SubqueryList subqueryList, Vector
 					// type of the procedure parameter.
 					if (sqlParamNode instanceof UntypedNullConstantNode)
 					{
-						sqlParamNode.setDescriptor(paramdtd);
+						sqlParamNode.setType(paramdtd);
 					}
 					else
 					{
@@ -504,7 +508,7 @@ private void resolveRoutine(FromList fromList, SubqueryList subqueryList, Vector
 				// only force the type for a ? so that the correct type shows up
 				// in parameter meta data
 				if (isParameterMarker)
-					sqlParamNode.setDescriptor(paramdtd);
+					sqlParamNode.setType(paramdtd);
 			}
 
 			if (sigParameterCount != parameterCount) {
@@ -547,7 +551,6 @@ public	void generateOneParameter(ExpressionClassBuilder acb,
 	{
 		int parameterMode;
 
-
 		SQLToJavaValueNode sql2j = null;
 		if (methodParms[parameterNumber] instanceof SQLToJavaValueNode)
 			sql2j = (SQLToJavaValueNode) methodParms[parameterNumber];
@@ -562,10 +565,15 @@ public	void generateOneParameter(ExpressionClassBuilder acb,
 			parameterMode = JDBC30Translation.PARAMETER_MODE_IN;
 
 			if (sql2j != null) {
-				if (sql2j.getSQLValueNode().isParameterNode()) {
+				if (sql2j.getSQLValueNode().requiresTypeFromContext()) {
+	  				ParameterNode pn;
+		  			if (sql2j.getSQLValueNode() instanceof UnaryOperatorNode) 
+		  				pn = ((UnaryOperatorNode)sql2j.getSQLValueNode()).getParameterOperand();
+		  			else
+		  				pn = (ParameterNode) (sql2j.getSQLValueNode());
 
 					// applicationParameterNumbers is only set up for a procedure.
-					int applicationParameterNumber = ((ParameterNode) (sql2j.getSQLValueNode())).getParameterNumber();
+					int applicationParameterNumber = pn.getParameterNumber();
 
 					String parameterType = methodParameterTypes[parameterNumber];
 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java
index 54e90e3e..cceacb83 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java
@@ -526,9 +526,9 @@ public ValueNode bindExpression(FromList fromList, SubqueryList subqueryList,
 		 * A ? parameter to the left of this subquery gets type of the
 		 * subquery's sole column.
 		 */
-		if (leftOperand != null && leftOperand.isParameterNode())
+		if (leftOperand != null && leftOperand.requiresTypeFromContext())
 		{
-			((ParameterNode) leftOperand).setDescriptor(
+			leftOperand.setType(
 				((ResultColumn) resultColumns.elementAt(0)).getTypeServices());
 		}
 
@@ -712,8 +712,7 @@ public ValueNode preprocess(int numTables,
 				additionalEQ = additionalEQ &&
 								((leftOperand instanceof ConstantNode) ||
 								 (leftOperand instanceof ColumnReference) ||
-
-								 (leftOperand.isParameterNode()));
+								 (leftOperand.requiresTypeFromContext()));
 				/* If we got this far and we are an expression subquery
 				 * then we want to set leftOperand to be the left side
 				 * of the comparison in case we pull the comparison into
@@ -851,7 +850,7 @@ private boolean singleFromBaseTable(FromList fromList)
 	 *
 	 * @return Whether or not the NOT IN or ALL subquery can be flattened.
 	 */
-	private boolean canAllBeFlattened ()
+	private boolean canAllBeFlattened () throws StandardException
 	{
 		boolean result = false;
 		if (isNOT_IN() || isALL())
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java
index c5970b78..fb20d4e3 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java
@@ -539,7 +539,7 @@ private ValueNode trimBind()
 		// handle parameters here
 
 		/* Is there a ? parameter for the receiver? */
-		if (receiver.isParameterNode())
+		if (receiver.requiresTypeFromContext())
 		{
 			/*
 			** According to the SQL standard, if trim has a ? receiver,
@@ -547,14 +547,14 @@ private ValueNode trimBind()
 			** for a varchar.
 			*/
 	
-			((ParameterNode) receiver).setDescriptor(getVarcharDescriptor());
+			receiver.setType(getVarcharDescriptor());
 		}
 
 		/* Is there a ? parameter on the left? */
-		if (leftOperand.isParameterNode())
+		if (leftOperand.requiresTypeFromContext())
 		{
 			/* Set the left operand type to varchar. */
-			((ParameterNode) leftOperand).setDescriptor(getVarcharDescriptor());
+			leftOperand.setType(getVarcharDescriptor());
 		}
 
 		bindToBuiltIn();
@@ -626,17 +626,17 @@ public ValueNode locateBind() throws StandardException
 		 * left/firstOperand's.  If the left/firstOperand are both parameters,
 		 * both will be max length.
 		 */
-		if( receiver.isParameterNode())
+		if( receiver.requiresTypeFromContext())
 		{
-			if( leftOperand.isParameterNode())
+			if( leftOperand.requiresTypeFromContext())
 			{
-				((ParameterNode) receiver).setDescriptor(getVarcharDescriptor());
+				receiver.setType(getVarcharDescriptor());
 			}
 			else
 			{
 				if( leftOperand.getTypeId().isStringTypeId() )
 				{
-					((ParameterNode) receiver).setDescriptor(
+					receiver.setType(
 							         leftOperand.getTypeServices());
 				}
 			}
@@ -646,17 +646,17 @@ public ValueNode locateBind() throws StandardException
 		 * Is there a ? parameter for the second arg.  Copy the receiver's.
 		 * If the receiver are both parameters, both will be max length.
 		 */
-		if(leftOperand.isParameterNode())
+		if(leftOperand.requiresTypeFromContext())
 		{
-			if(receiver.isParameterNode())
+			if(receiver.requiresTypeFromContext())
 			{
-				((ParameterNode) leftOperand).setDescriptor(getVarcharDescriptor());
+				leftOperand.setType(getVarcharDescriptor());
 			}
 			else
 			{
 				if( receiver.getTypeId().isStringTypeId() )
 				{
-					((ParameterNode) leftOperand).setDescriptor(
+					leftOperand.setType(
 							         receiver.getTypeServices());
 				}
 			}
@@ -665,9 +665,9 @@ public ValueNode locateBind() throws StandardException
 		/*
 		 * Is there a ? paramter for the third arg.  It will be an int.
 		 */
-		if( rightOperand.isParameterNode())
+		if( rightOperand.requiresTypeFromContext())
 		{
-			((ParameterNode) rightOperand).setDescriptor(
+			rightOperand.setType(
 				new DataTypeDescriptor(TypeId.INTEGER_ID, true)); 
 		}
 
@@ -735,7 +735,7 @@ public ValueNode substrBind()
 		// handle parameters here
 
 		/* Is there a ? parameter for the receiver? */
-		if (receiver.isParameterNode())
+		if (receiver.requiresTypeFromContext())
 		{
 			/*
 			** According to the SQL standard, if substr has a ? receiver,
@@ -743,22 +743,22 @@ public ValueNode substrBind()
 			** for a varchar.
 			*/
 	
-			((ParameterNode) receiver).setDescriptor(getVarcharDescriptor());
+			receiver.setType(getVarcharDescriptor());
 		}
 
 		/* Is there a ? parameter on the left? */
-		if (leftOperand.isParameterNode())
+		if (leftOperand.requiresTypeFromContext())
 		{
 			/* Set the left operand type to int. */
-			((ParameterNode) leftOperand).setDescriptor(							
+			leftOperand.setType(							
 				new DataTypeDescriptor(TypeId.INTEGER_ID, true)); 
 		}
 
 		/* Is there a ? parameter on the right? */
-		if ((rightOperand != null) && rightOperand.isParameterNode())
+		if ((rightOperand != null) && rightOperand.requiresTypeFromContext())
 		{
 			/* Set the right operand type to int. */
-			((ParameterNode) rightOperand).setDescriptor(							
+			rightOperand.setType(							
 				new DataTypeDescriptor(TypeId.INTEGER_ID, true)); 
 		}
 
@@ -865,9 +865,9 @@ private void bindDateTimeArg( ValueNode arg, int argNumber) throws StandardExcep
 
     private boolean bindParameter( ValueNode arg, int jdbcType) throws StandardException
     {
-        if( arg.isParameterNode() && arg.getTypeId() == null)
+        if( arg.requiresTypeFromContext() && arg.getTypeId() == null)
         {
-            ((ParameterNode) arg).setDescriptor( new DataTypeDescriptor(TypeId.getBuiltInTypeId( jdbcType), true));
+            arg.setType( new DataTypeDescriptor(TypeId.getBuiltInTypeId( jdbcType), true));
             return true;
         }
         return false;
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/TimestampOperatorNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/TimestampOperatorNode.java
index e33cb616..fa9c2965 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/TimestampOperatorNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/TimestampOperatorNode.java
@@ -85,12 +85,19 @@ public ValueNode bindExpression(
 		rightOperand = rightOperand.bindExpression(fromList, subqueryList, 
 			aggregateVector);
 
+		//Set the type if there is a parameter involved here 
+		if (leftOperand.requiresTypeFromContext())
+			leftOperand.setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.DATE));
+		//Set the type if there is a parameter involved here 
+		if (rightOperand.requiresTypeFromContext())
+			rightOperand.setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.TIME));
+
         TypeId leftTypeId = leftOperand.getTypeId();
         TypeId rightTypeId = rightOperand.getTypeId();
-        if( !(leftTypeId.isStringTypeId() || leftTypeId.getJDBCTypeId() == Types.DATE || leftOperand.isParameterNode()))
+        if( !(leftOperand.requiresTypeFromContext() || leftTypeId.isStringTypeId() || leftTypeId.getJDBCTypeId() == Types.DATE))
             throw StandardException.newException(SQLState.LANG_BINARY_OPERATOR_NOT_SUPPORTED, 
                                                  operator, leftTypeId.getSQLTypeName(), rightTypeId.getSQLTypeName());
-        if( !(rightTypeId.isStringTypeId() || rightTypeId.getJDBCTypeId() == Types.TIME || rightOperand.isParameterNode()))
+        if( !(rightOperand.requiresTypeFromContext() || rightTypeId.isStringTypeId() || rightTypeId.getJDBCTypeId() == Types.TIME))
             throw StandardException.newException(SQLState.LANG_BINARY_OPERATOR_NOT_SUPPORTED, 
                                                  operator, leftTypeId.getSQLTypeName(), rightTypeId.getSQLTypeName());
         setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor( Types.TIMESTAMP));
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/UnaryArithmeticOperatorNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/UnaryArithmeticOperatorNode.java
index dae7f4fb..1982831b 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/UnaryArithmeticOperatorNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/UnaryArithmeticOperatorNode.java
@@ -52,6 +52,22 @@
 
 	private int operatorType;
 
+	//when the bindExpression method is called during the normal binding phase,
+	//unary minus and unary plus dynamic parameters are not ready for
+	//binding because the type of these dynamic parameters is not yet set.
+	//For eg, consider sql select * from t1 where c1 = -?
+	//bindExpression on -? gets called from BinaryComparisonOperatorNode's
+	//bindExpression but the parameter type has not been set yet for -?
+	//Later on, in BinaryComparisonOperatorNode's bindExpression, the type
+	//of the -? gets set to the type of c1 by the setType call. 
+	//Now, at this point, we are ready to finish binding phase for -? 
+	//(This class's setType method calls the bindExpression to finish binding)
+	//In order to accomplish binding later on, we need to save the following 
+	//3 objects during first call to bindExpression and then later this 
+	//gets used in setType method when it calls the bindExpression method.
+	FromList localCopyFromList;
+	SubqueryList localCopySubqueryList;
+	Vector localAggregateVector;
 
 	/**
 	 * Initializer for a UnaryArithmeticOperatorNode
@@ -103,9 +119,12 @@ void bindParameter() throws StandardException
 	{
 		if (operatorType == SQRT || operatorType == ABSOLUTE)
 		{
-			((ParameterNode) operand).setDescriptor(
+			operand.setType(
 				new DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.DOUBLE), true));
 		}
+		//Derby-582 add support for dynamic parameter for unary plus and minus
+		else if (operatorType == UNARY_MINUS || operatorType == UNARY_PLUS) 
+			return;
 		else if (operand.getTypeServices() == null)
 		{
 			throw StandardException.newException(SQLState.LANG_UNARY_OPERAND_PARM, operator);
@@ -128,6 +147,14 @@ public ValueNode bindExpression(
 		Vector	aggregateVector)
 			throws StandardException
 	{
+		localCopyFromList = fromList;
+		localCopySubqueryList = subqueryList;
+		localAggregateVector = aggregateVector;
+		//Return with no binding, if the type of unary minus/plus parameter is not set yet.
+		if (operand.requiresTypeFromContext() && ((operatorType == UNARY_PLUS || operatorType == UNARY_MINUS))
+				&& operand.getTypeServices() == null)
+				return this;
+
 		super.bindExpression(fromList, subqueryList,
 				aggregateVector);
 
@@ -150,7 +177,7 @@ else if (operatorType == UNARY_PLUS || operatorType == UNARY_MINUS)
 		/*
 		** The result type of a +, -, SQRT, ABS is the same as its operand.
 		*/
-		setType(operand.getTypeServices());
+		super.setType(operand.getTypeServices());
 		return this;
 	}
 
@@ -218,4 +245,19 @@ private void bindSQRTABS()
 			((CastNode) operand).bindCastNodeOnly();
 		}
 	}
+
+	/** @see ValueNode#setType */
+	/* We are overwriting this method here because for -?/+?, we now know
+	the type of these dynamic parameters and hence we can do the parameter
+	binding. The setType method will call the binding code after setting
+	the type of the parameter*/
+	public void setType(DataTypeDescriptor descriptor) throws StandardException
+	{
+		operand.setType(descriptor);
+		super.setType(descriptor);
+		//Derby-582 add support for dynamic parameters for unary plus and minus
+		//Now that we know the type of this parameter node, we can do the
+		//binding.
+		bindExpression(localCopyFromList, localCopySubqueryList, localAggregateVector);
+	}
 }
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java
index c9461459..a913ddd9 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java
@@ -259,6 +259,28 @@ public ValueNode getOperand()
 		return operand;
 	}
 
+	/**
+	 * Get the parameter operand of this unary operator.
+	 * For the example below, for abs unary operator node, we want to get ?
+	 * select * from t1 where -? = max_cni(abs(-?), sqrt(+?))
+	 * 
+	 * This gets called when ParameterNode is needed to get parameter
+	 * specific information like getDefaultValue(), getParameterNumber() etc 
+	 * 
+	 * @return	The parameter operand of this unary operator else null.
+	 */
+	public ParameterNode getParameterOperand()
+	{
+		if (requiresTypeFromContext() == false)
+			return null;
+		else {
+			UnaryOperatorNode tempUON = this;
+			while (!(tempUON.getOperand() instanceof ParameterNode)) 
+				tempUON = (UnaryOperatorNode)tempUON.getOperand();
+			return (ParameterNode)(tempUON.getOperand());
+		}
+	}
+
 	/**
 	 * Set the clause that this node appears in.
 	 *
@@ -319,10 +341,14 @@ protected ValueNode bindUnaryOperator(
 			return this;
 		}
 
+		//Return with no binding, if the type of unary minus/plus parameter is not set yet.
+		if (operand.requiresTypeFromContext() && ((operator.equals("-") || operator.equals("+"))) && operand.getTypeServices() == null)
+			return this;
+
 		operand = operand.bindExpression(fromList, subqueryList,
 								aggregateVector);
 
-		if (operand.isParameterNode())
+		if (operand.requiresTypeFromContext())
 			bindParameter();
 
 		/* If the operand is not a built-in type, then generate a bound conversion
@@ -532,6 +558,34 @@ public boolean constantExpression(PredicateList whereClause)
 					operand.constantExpression(whereClause);
 	}
 
+	/**
+	 * @see ValueNode#requiresTypeFromContext
+	 */
+	public boolean requiresTypeFromContext()
+	{
+		if (operand == null)
+			return false;
+		else
+			return (operand.requiresTypeFromContext()); 
+	}
+
+
+	/**
+	 * Returns true if this UnaryOperatorNode is for -?/+?.
+	 * This is required to check -?/+? say in the following sql
+	 * select * from t1 where -? and c11=c11 or +?
+	 * 
+	 * @return	True if this +?/-? node
+	 */
+	public boolean isUnaryMinusOrPlusWithParameter()
+	{
+		if (operand !=null && operand instanceof ParameterNode && operand.requiresTypeFromContext() && 
+				(operator!= null && (operator.equals("-") || operator.equals("+"))))
+			return true;
+		else
+			return false;
+	}
+
 	/**
 	 * By default unary operators don't accept ? parameters as operands.
 	 * This can be over-ridden for particular unary operators.
@@ -554,7 +608,7 @@ void bindParameter() throws StandardException
         // an XML string can be arbitrarily long...is this okay?
         // The SQL/XML spec doesn't state what the type of the param
         // should be; only that it "shall be a character type".
-	        ((ParameterNode) operand).setDescriptor(
+	        operand.setType(
  	           DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CLOB));
 		}
 		else if (operatorType == XMLSERIALIZE_OP) {
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java
index 63d102f9..8f2fbe41 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ValueNode.java
@@ -182,7 +182,7 @@ public String toString()
 	 * @return	The DataTypeServices from this ValueNode.  This
 	 *		may be null if the node isn't bound yet.
 	 */
-	public DataTypeDescriptor getTypeServices()
+	public DataTypeDescriptor getTypeServices() throws StandardException
 	{
 		return dataTypeServices;
 	}
@@ -193,7 +193,7 @@ public DataTypeDescriptor getTypeServices()
 	 * @return	The TypeId from this ValueNode.  This
 	 *		may be null if the node isn't bound yet.
 	 */
-	public TypeId getTypeId()
+	public TypeId getTypeId() throws StandardException
 	{
 		return typeId;
 	}
@@ -212,7 +212,7 @@ protected final DataValueFactory getDataValueFactory() {
 	 * @return	This ValueNode's TypeCompiler
 	 *
 	 */
-	public TypeCompiler getTypeCompiler()
+	public TypeCompiler getTypeCompiler() throws StandardException
 	{
 		if (typeCompiler == null)
 		{
@@ -227,7 +227,8 @@ public TypeCompiler getTypeCompiler()
 	}
 
 	/**
-	 * Set the DataTypeServices in this ValueNode.
+	 * Set the DataTypeServices for this ValueNode.  This method is
+	 * overridden in ParameterNode.
 	 *
 	 * @param dataTypeServices	The DataTypeServices to set in this
 	 *				ValueNode
@@ -235,7 +236,7 @@ public TypeCompiler getTypeCompiler()
 	 * @return	Nothing
 	 */
 
-	public void setType(DataTypeDescriptor dataTypeServices)
+	public void setType(DataTypeDescriptor dataTypeServices) throws StandardException
 	{
 		this.dataTypeServices = dataTypeServices;
 
@@ -249,20 +250,6 @@ public void setType(DataTypeDescriptor dataTypeServices)
 		typeCompiler = null;
 	}
 
-	/**
-	 * Set the DataTypeServices for this ValueNode.  This method is
-	 * overridden in ParameterNode.
-	 *
-	 * @param descriptor	The DataTypeServices to set for this ValueNode
-	 *
-	 * @return	Nothing
-	 *
-	 */
-
-	public void setDescriptor(DataTypeDescriptor descriptor)
-	{
-		setType(descriptor);
-	}
 
 	/**
 	 * Get the source for this ValueNode.
@@ -768,7 +755,7 @@ public ValueNode getClone() throws StandardException
 	 * @param oldVN		The ValueNode to copy from.
 	 *
 	 */
-	public void copyFields(ValueNode oldVN)
+	public void copyFields(ValueNode oldVN) throws StandardException
 	{
 		dataTypeServices = oldVN.getTypeServices();
 		typeId = oldVN.getTypeId();
@@ -1010,6 +997,7 @@ public	void generateFilter(ExpressionClassBuilder ecb,
 	 * in specific cases, such as the RelationalOperators.
 	 */
 	public double selectivity(Optimizable optTable)
+	throws StandardException
 	{
 		// Return 1 if additional predicates have been generated from this one.
 		if (transformed)
@@ -1172,7 +1160,7 @@ private void updateMaps(JBitSet[] tableColMap, boolean[] eqOuterCols,
 		 * It is a good = for only the All array if
 		 * the right side is a column from this query block.
 		 */
-		if ((arg1 instanceof ConstantNode) || (arg1.isParameterNode()))
+		if ((arg1 instanceof ConstantNode) || (arg1.requiresTypeFromContext()))
 		{
 			setValueCols(tableColMap, eqOuterCols,
 				((ColumnReference) arg2).getColumnNumber(), resultTable);
@@ -1330,6 +1318,17 @@ public boolean optimizableEqualityNode(Optimizable optTable,
 		return false;
 	}
 
+	/**
+	 * Returns TRUE if the type of this node will be determined from the
+	 * context in which it is getting used.
+	 *
+	 * @return Whether this node's type will be determined from the context
+	 */
+	public boolean requiresTypeFromContext()
+	{
+		return false;
+	}
+
 	/**
 	 * Returns TRUE if this is a parameter node. We do lots of special things
 	 * with Parameter Nodes.
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ValueNodeList.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ValueNodeList.java
index cb5d7cb3..424508f2 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ValueNodeList.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ValueNodeList.java
@@ -184,7 +184,7 @@ public DataTypeDescriptor getDominantTypeServices() throws StandardException
 			ValueNode			valueNode;
 
 			valueNode = (ValueNode) elementAt(index);
-			if (valueNode.isParameterNode())
+			if (valueNode.requiresTypeFromContext())
 				continue;
 			DataTypeDescriptor valueNodeDTS = valueNode.getTypeServices();
 
@@ -240,6 +240,7 @@ public DataTypeDescriptor getTypeServices() throws StandardException
 	 *			type precendence as the specified value.
 	 */
 	boolean allSamePrecendence(int precedence)
+	throws StandardException
 	{
 		boolean allSame = true;
 		int size = size();
@@ -285,7 +286,7 @@ public void compatible(ValueNode leftOperand) throws StandardException
 		for (int index = 0; index < size; index++)
 		{
 			valueNode = (ValueNode) elementAt(index);
-			if (valueNode.isParameterNode())
+			if (valueNode.requiresTypeFromContext())
 				continue;
 
 
@@ -350,6 +351,7 @@ public void comparable(ValueNode leftOperand) throws StandardException
 	 *					are nullable.
 	 */
 	public boolean isNullable()
+	throws StandardException
 	{
 		int size = size();
 
@@ -374,7 +376,7 @@ public boolean containsParameterNode()
 
 		for (int index = 0; index < size; index++)
 		{
-			if (((ValueNode) elementAt(index)).isParameterNode())
+			if (((ValueNode) elementAt(index)).requiresTypeFromContext())
 			{
 				return true;
 			}
@@ -393,7 +395,7 @@ public boolean containsAllParameterNodes()
 
 		for (int index = 0; index < size; index++)
 		{
-			if (! (((ValueNode) elementAt(index)).isParameterNode()))
+			if (! (((ValueNode) elementAt(index)).requiresTypeFromContext()))
 			{
 				return false;
 			}
@@ -488,9 +490,9 @@ public void setParameterDescriptor(DataTypeDescriptor descriptor)
 		for (int index = 0; index < size; index++)
 		{
 			valueNode = (ValueNode) elementAt(index);
-			if (valueNode.isParameterNode())
+			if (valueNode.requiresTypeFromContext())
 			{
-				((ParameterNode) valueNode).setDescriptor(descriptor);
+				valueNode.setType(descriptor);
 			}
 		}
 	}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java
index a540acb8..6e4b85ee 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/VirtualColumnNode.java
@@ -68,7 +68,7 @@
 	public void init(
 						Object sourceResultSet,
 						Object sourceColumn,
-						Object columnId)
+						Object columnId) throws StandardException
 	{
 		ResultColumn source = (ResultColumn) sourceColumn;
 
@@ -280,7 +280,7 @@ protected int getOrderableVariantType() throws StandardException
 	 * @return	The DataTypeServices from this Node.  This
 	 *		may be null if the node isn't bound yet.
 	 */
-	public DataTypeDescriptor getTypeServices()
+	public DataTypeDescriptor getTypeServices() throws StandardException
 	{
         DataTypeDescriptor dtd = super.getTypeServices();
         if( dtd == null && sourceColumn != null)
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/unaryArithmeticDynamicParameter.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/unaryArithmeticDynamicParameter.java
index e69de29b..ff16c036 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/unaryArithmeticDynamicParameter.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/unaryArithmeticDynamicParameter.java
@@ -0,0 +1,486 @@
+/*
+
+Derby - Class org.apache.derbyTesting.functionTests.tests.lang.unaryArithmeticDynamicParameter
+
+Copyright 2005 The Apache Software Foundation or its licensors, as applicable.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+   http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+package org.apache.derbyTesting.functionTests.tests.lang;
+
+import java.sql.Connection;
+import java.sql.ParameterMetaData;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+
+import org.apache.derby.tools.ij;
+
+
+/**
+  This tests unary minus and unary plus as dynamic parameters in PreparedStatements.
+  Derby-582
+ */
+public class unaryArithmeticDynamicParameter { 
+
+	public static void main (String[] argv) throws Throwable
+	{
+		System.out.println("Test using parameters for unary minus and unary plus");
+		ij.getPropertyArg(argv);
+		Connection conn = ij.startJBMS();
+		Statement s = conn.createStatement();
+		s.executeUpdate("create table t1 (c11 int, c12 smallint, c13 double, c14 char(3))");
+		s.execute("create table t2 (c21 int)");
+		s.execute("insert into t2 values (-1),(-2)");
+
+		System.out.println("insert into t1 values(?,+?,-?,?)");
+		PreparedStatement ps = conn.prepareStatement("insert into t1 values(?,+?,-?,?)");
+		ps.setInt(1,1);
+		ps.setInt(2,1);
+		ps.setDouble(3,-1.1);
+		ps.setString(4,"abc");
+		ParameterMetaData pmd = ps.getParameterMetaData();
+		System.out.println("? parameter type is " + pmd.getParameterTypeName(1));
+ 		System.out.println("unary +? parameter type is " + pmd.getParameterTypeName(2));
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(3));
+		ps.executeUpdate();
+		ps.setInt(1,-1);
+		ps.setInt(2,-1);
+		ps.setDouble(3,1.0);
+		ps.setString(4,"def");
+		ps.executeUpdate();
+
+		System.out.println("select * from t1 where -? in (select c21 from t2)");
+		ps = conn.prepareStatement("select * from t1 where -? in (select c21 from t2)");
+		ps.setInt(1,1);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("select * from t1 where c11 = -? and c12 = +? and c13 = ?");
+		ps = conn.prepareStatement("select * from t1 where c11 = -? and c12 = +? and c13 = ?");
+		ps.setInt(1,-1);
+		ps.setInt(2,1);
+		ps.setDouble(3,1.1);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+ 		System.out.println("unary +? parameter type is " + pmd.getParameterTypeName(2));
+		System.out.println("? parameter type is " + pmd.getParameterTypeName(3));
+		dumpRS(ps.executeQuery());
+		ps.setShort(1,(short) 1);
+		ps.setInt(2,-1);
+		ps.setInt(3,-1);
+		dumpRS(ps.executeQuery());
+
+		System.out.println("select * from t1 where -? = ABS_FUNCT(+?)");
+		s.execute("CREATE FUNCTION ABS_FUNCT(P1 INT) RETURNS INT CALLED ON NULL INPUT EXTERNAL NAME 'java.lang.Math.abs' LANGUAGE JAVA PARAMETER STYLE JAVA");
+		ps = conn.prepareStatement("select * from t1 where -? = abs_funct(+?)");
+		ps.setInt(1,-1);
+		ps.setInt(2,1);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+		System.out.println("unary +? parameter type is " + pmd.getParameterTypeName(2));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("select * from t1 where -? = max_cni(-5,-1)");
+		s.execute("CREATE FUNCTION MAX_CNI(P1 INT, P2 INT) RETURNS INT CALLED ON NULL INPUT EXTERNAL NAME 'java.lang.Math.max' LANGUAGE JAVA PARAMETER STYLE JAVA");
+		ps = conn.prepareStatement("select * from t1 where -? = max_cni(-5,-1)");
+		ps.setInt(1,1);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("select * from t1 where -? = max_cni(-?,+?)");
+		ps = conn.prepareStatement("select * from t1 where -? = max_cni(-?,+?)");
+		ps.setInt(1,-1);
+		ps.setInt(2,1);
+		ps.setInt(3,1);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(2));
+		System.out.println("unary +? parameter type is " + pmd.getParameterTypeName(3));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("Try the function again. But use, use sqrt(+?) & abs(-?) functions to send params");
+		System.out.println("select * from t1 where -? = max_cni(abs(-?), sqrt(+?))");
+		ps = conn.prepareStatement("select * from t1 where -? = max_cni(abs(-?), sqrt(+?))");
+		ps.setInt(1,-2);
+		ps.setInt(2,1);
+		ps.setInt(3,4);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(2));
+		System.out.println("unary +? parameter type is " + pmd.getParameterTypeName(3));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("select * from t1 where c11 between -? and +?");
+		ps = conn.prepareStatement("select * from t1 where c11 between -? and +?");
+		ps.setInt(1,-1);
+		ps.setInt(2,1);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+		System.out.println("unary +? parameter type is " + pmd.getParameterTypeName(2));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("select * from t1 where +? not in (-?, +?, 2, ?)");
+		ps = conn.prepareStatement("select * from t1 where +? not in (-?, +?, 2, ?)");
+		ps.setInt(1,-11);
+		ps.setInt(2,1);
+		ps.setInt(3,1);
+		ps.setInt(4,4);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary +? parameter type is " + pmd.getParameterTypeName(1));
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(2));
+		System.out.println("unary +? parameter type is " + pmd.getParameterTypeName(3));
+		System.out.println("? parameter type is " + pmd.getParameterTypeName(4));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("select * from t1 where +? < c12");
+		ps = conn.prepareStatement("select * from t1 where +? < c12");
+		ps.setInt(1,0);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary +? parameter type is " + pmd.getParameterTypeName(1));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("select * from t1 where -? = c11 + ?");
+		ps = conn.prepareStatement("select * from t1 where -? = c11 + ?");
+		ps.setInt(1,2);
+		ps.setInt(2,-1);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+		System.out.println("? parameter type is " + pmd.getParameterTypeName(1));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("select * from t1 where c11 + ? = -?");
+		ps = conn.prepareStatement("select * from t1 where c11 + ? = -?");
+		ps.setInt(1,-1);
+		ps.setInt(2,2);
+		pmd = ps.getParameterMetaData();
+		System.out.println("? parameter type is " + pmd.getParameterTypeName(1));
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("select * from t1 where c11 + c12 = -?");
+		ps = conn.prepareStatement("select * from t1 where c11 + c12 = -?");
+		ps.setInt(1,2);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("select * from t1 where -? not in (select c21+? from t2)");
+		ps = conn.prepareStatement("select * from t1 where -? not in (select c21+? from t2)");
+		ps.setInt(1,1);
+		ps.setInt(2,2);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+		System.out.println("? parameter type is " + pmd.getParameterTypeName(1));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("select cast(-? as smallint), cast(+? as int) from t1");
+		ps = conn.prepareStatement("select cast(-? as smallint), cast(+? as int) from t1");
+		ps.setInt(1,2);
+		ps.setInt(2,2);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+		System.out.println("unary +? parameter type is " + pmd.getParameterTypeName(2));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("select nullif(-?,c11) from t1");
+		ps = conn.prepareStatement("select nullif(-?,c11) from t1");
+		ps.setInt(1,22);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("select sqrt(-?) from t1");
+		ps = conn.prepareStatement("select sqrt(-?) from t1");
+		ps.setInt(1,-64);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("select * from t1 where c11 = any (select -? from t2)");
+		try {
+			ps = conn.prepareStatement("select * from t1 where c11 = any (select -? from t2)");
+			ps.setInt(1,1);
+			pmd = ps.getParameterMetaData();
+			System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+			dumpRS(ps.executeQuery());
+		}
+		catch (SQLException e) {
+			System.out.println("SQL State : " + e.getSQLState());
+			System.out.println("Got expected exception " + e.getMessage());
+		}
+
+		System.out.println("Negative test - -?/+? at the beginning and/ at the end of where clause");
+		System.out.println("select * from t1 where -? and c11=c11 or +?");
+		try {
+			ps = conn.prepareStatement("select * from t1 where -? and c11=c11 or +?");
+			ps.setString(1,"SYS%");
+			ps.setString(2,"");
+			pmd = ps.getParameterMetaData();
+			System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+			System.out.println("unary +? parameter type is " + pmd.getParameterTypeName(2));
+			dumpRS(ps.executeQuery());
+			System.out.println("FAIL-test should have failed");
+		}
+		catch (SQLException e) {
+			System.out.println("SQL State : " + e.getSQLState());
+			System.out.println("Got expected exception " + e.getMessage());
+		}
+
+		System.out.println("Negative test - -?/+? in like escape function");
+		System.out.println("select * from sys.systables where tablename like -? escape +?");
+		try {
+			ps = conn.prepareStatement("select * from sys.systables where tablename like -? escape +?");
+			ps.setString(1,"SYS%");
+			ps.setString(2,"");
+			pmd = ps.getParameterMetaData();
+			System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+			System.out.println("unary +? parameter type is " + pmd.getParameterTypeName(2));
+			dumpRS(ps.executeQuery());
+			System.out.println("FAIL-test should have failed");
+		}
+		catch (SQLException e) {
+			System.out.println("SQL State : " + e.getSQLState());
+			System.out.println("Got expected exception " + e.getMessage());
+		}
+
+		System.out.println("Negative test - -?/+? in binary timestamp function");
+		System.out.println("select timestamp(-?,+?) from t1");
+		try {
+			ps = conn.prepareStatement("select timestamp(-?,+?) from t1");
+			ps.setInt(1,22);
+			ps.setInt(2,22);
+			pmd = ps.getParameterMetaData();
+			System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+			dumpRS(ps.executeQuery());
+			System.out.println("FAIL-test should have failed");
+		}
+		catch (SQLException e) {
+			System.out.println("SQL State : " + e.getSQLState());
+			System.out.println("Got expected exception " + e.getMessage());
+		}
+
+		System.out.println("Negative test - -? in unary timestamp function");
+		System.out.println("select timestamp(-?) from t1");
+		try {
+			ps = conn.prepareStatement("select timestamp(-?) from t1");
+			ps.setInt(1,22);
+			pmd = ps.getParameterMetaData();
+			System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+			dumpRS(ps.executeQuery());
+			System.out.println("FAIL-test should have failed");
+		}
+		catch (SQLException e) {
+			System.out.println("SQL State : " + e.getSQLState());
+			System.out.println("Got expected exception " + e.getMessage());
+		}
+
+		System.out.println("Negative test - -? in views");
+		System.out.println("create view v1 as select * from t1 where c11 = -?");
+		try {
+			ps = conn.prepareStatement("create view v1 as select * from t1 where c11 = -?");
+			ps.setInt(1,22);
+			pmd = ps.getParameterMetaData();
+			System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+			dumpRS(ps.executeQuery());
+			System.out.println("FAIL-test should have failed");
+		}
+		catch (SQLException e) {
+			System.out.println("SQL State : " + e.getSQLState());
+			System.out.println("Got expected exception " + e.getMessage());
+		}
+
+		System.out.println("Negative test - -? in inner join");
+		System.out.println("select * from t1 inner join t1 as t333 on -?");
+		try {
+			ps = conn.prepareStatement("select * from t1 inner join t1 as t333 on -?");
+			ps.setInt(1,22);
+			pmd = ps.getParameterMetaData();
+			System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+			dumpRS(ps.executeQuery());
+			System.out.println("FAIL-test should have failed");
+		}
+		catch (SQLException e) {
+			System.out.println("SQL State : " + e.getSQLState());
+			System.out.println("Got expected exception " + e.getMessage());
+		}
+
+		System.out.println("Negative test - -? by itself in where clause");
+		System.out.println("select * from t1 where -?");
+		try {
+			ps = conn.prepareStatement("select * from t1 where -?");
+			ps.setInt(1,22);
+			pmd = ps.getParameterMetaData();
+			System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+			dumpRS(ps.executeQuery());
+			System.out.println("FAIL-test should have failed");
+		}
+		catch (SQLException e) {
+			System.out.println("SQL State : " + e.getSQLState());
+			System.out.println("Got expected exception " + e.getMessage());
+		}
+
+		System.out.println("Negative test - -? is null not allowed because is null allowed on char types only");
+		System.out.println("select * from t1 where -? is null");
+		try {
+			ps = conn.prepareStatement("select * from t1 where -? is null");
+			ps.setInt(1,22);
+			pmd = ps.getParameterMetaData();
+			System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+			dumpRS(ps.executeQuery());
+			System.out.println("FAIL-test should have failed");
+		}
+		catch (SQLException e) {
+			System.out.println("SQL State : " + e.getSQLState());
+			System.out.println("Got expected exception " + e.getMessage());
+		}
+
+		System.out.println("select case when -?=c11 then -? else c12 end from t1");
+		ps = conn.prepareStatement("select case when -?=c11 then -? else c12 end from t1");
+		ps.setInt(1,1);
+		ps.setInt(2,22);
+		pmd = ps.getParameterMetaData();
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+		System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(2));
+		dumpRS(ps.executeQuery());
+
+		System.out.println("Negative test - unary plus parameters on both sides of / operator");
+		System.out.println("select * from t1 where c11 = ?/-?");
+		try {
+			ps = conn.prepareStatement("select * from t1 where c11 = ?/-?");
+			ps.setInt(1,0);
+			ps.setInt(2,0);
+			pmd = ps.getParameterMetaData();
+			System.out.println("? parameter type is " + pmd.getParameterTypeName(1));
+			System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(2));
+			dumpRS(ps.executeQuery());
+			System.out.println("FAIL-test should have failed");
+		}
+		catch (SQLException e) {
+			System.out.println("SQL State : " + e.getSQLState());
+			System.out.println("Got expected exception " + e.getMessage());
+		}
+
+		System.out.println("Negative test - unary plus in || operation");
+		System.out.println("select c11 || +? from t1");
+		try {
+			ps = conn.prepareStatement("select c11 || +? from t1");
+			ps.setInt(1,0);
+			pmd = ps.getParameterMetaData();
+			System.out.println("? parameter type is " + pmd.getParameterTypeName(1));
+			System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(2));
+			dumpRS(ps.executeQuery());
+			System.out.println("FAIL-test should have failed");
+		}
+		catch (SQLException e) {
+			System.out.println("SQL State : " + e.getSQLState());
+			System.out.println("Got expected exception " + e.getMessage());
+		}
+
+		System.out.println("Negative test - unary minus for char column");
+		System.out.println("select * from t1 where c14 = -?");
+		try {
+			ps = conn.prepareStatement("select * from t1 where c14 = -?");
+			ps.setInt(1,-1);
+			pmd = ps.getParameterMetaData();
+			System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+			dumpRS(ps.executeQuery());
+			System.out.println("FAIL-test should have failed");
+		}
+		catch (SQLException e) {
+			System.out.println("SQL State : " + e.getSQLState());
+			System.out.println("Got expected exception " + e.getMessage());
+		}
+
+		System.out.println("Negative test - unary plus for char column");
+		System.out.println("select * from t1 where c14 like +?");
+		try {
+			ps = conn.prepareStatement("select * from t1 where c14 like +?");
+			ps.setInt(1,-1);
+			pmd = ps.getParameterMetaData();
+			System.out.println("unary -? parameter type is " + pmd.getParameterTypeName(1));
+			dumpRS(ps.executeQuery());
+			System.out.println("FAIL-test should have failed");
+		}
+		catch (SQLException e) {
+			System.out.println("SQL State : " + e.getSQLState());
+			System.out.println("Got expected exception " + e.getMessage());
+		}
+	};
+	private static void dumpRS(ResultSet s) throws SQLException
+	{
+		if (s == null)
+		{
+			System.out.println("<NULL>");
+			return;
+		}
+
+		java.sql.ResultSetMetaData rsmd = s.getMetaData();
+
+		// Get the number of columns in the result set
+		int numCols = rsmd.getColumnCount();
+
+		if (numCols <= 0) 
+		{
+			System.out.println("(no columns!)");
+			return;
+		}
+
+		StringBuffer heading = new StringBuffer("\t ");
+		StringBuffer underline = new StringBuffer("\t ");
+
+		int len;
+		// Display column headings
+		for (int i=1; i<=numCols; i++) 
+		{
+			if (i > 1) 
+			{
+				heading.append(",");
+				underline.append(" ");
+			}
+			len = heading.length();
+			heading.append(rsmd.getColumnLabel(i));
+			len = heading.length() - len;
+			for (int j = len; j > 0; j--)
+			{
+				underline.append("-");
+			}
+		}
+		System.out.println(heading.toString());
+		System.out.println(underline.toString());
+		
+	
+		StringBuffer row = new StringBuffer();
+		// Display data, fetching until end of the result set
+		while (s.next()) 
+		{
+			row.append("\t{");
+			// Loop through each column, getting the
+			// column data and displaying
+			for (int i=1; i<=numCols; i++) 
+			{
+				if (i > 1) row.append(",");
+				row.append(s.getString(i));
+			}
+			row.append("}\n");
+		}
+		System.out.println(row.toString());
+		s.close();
+	}
+}
+
