diff --git a/db/derby/code/branches/10.3/java/client/org/apache/derby/client/ClientPooledConnection.java b/db/derby/code/branches/10.3/java/client/org/apache/derby/client/ClientPooledConnection.java
index 03eb62f2..e4ef735c 100644
--- a/db/derby/code/branches/10.3/java/client/org/apache/derby/client/ClientPooledConnection.java
+++ b/db/derby/code/branches/10.3/java/client/org/apache/derby/client/ClientPooledConnection.java
@@ -23,8 +23,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import org.apache.derby.client.net.NetXAConnection;
+import org.apache.derby.iapi.error.ExceptionSeverity;
 import org.apache.derby.jdbc.ClientBaseDataSource;
-import org.apache.derby.jdbc.ClientDataSource;
 import org.apache.derby.jdbc.ClientDriver;
 import org.apache.derby.client.am.ClientMessageId;
 import org.apache.derby.client.am.SqlException;
@@ -263,6 +263,10 @@ public void recycleConnection() {
 
     // Not public, but needs to be visible to am.LogicalConnection
     public void trashConnection(SqlException exception) {
+		// only report fatal error  
+		if (exception.getErrorCode() < ExceptionSeverity.SESSION_SEVERITY)
+			return;
+
         for (java.util.Enumeration e = listeners_.elements(); e.hasMoreElements();) {
             javax.sql.ConnectionEventListener listener = (javax.sql.ConnectionEventListener) e.nextElement();
             java.sql.SQLException sqle = exception.getSQLException();
diff --git a/db/derby/code/branches/10.3/java/client/org/apache/derby/client/am/LogicalConnection.java b/db/derby/code/branches/10.3/java/client/org/apache/derby/client/am/LogicalConnection.java
index c6eab3aa..894b47e3 100644
--- a/db/derby/code/branches/10.3/java/client/org/apache/derby/client/am/LogicalConnection.java
+++ b/db/derby/code/branches/10.3/java/client/org/apache/derby/client/am/LogicalConnection.java
@@ -130,17 +130,42 @@ protected void checkForNullPhysicalConnection() throws SQLException {
         }
     }
 
+    /**
+     * This method checks if the physcial connection underneath is null and
+     * if yes, then it simply returns.
+     * Otherwise, if the severity of exception is greater than equal to
+     * ExceptionSeverity.SESSION_SEVERITY, then we will send 
+     * connectionErrorOccurred event to all the registered listeners.
+     * 
+     * @param sqle SQLException An event will be sent to the listeners if the
+     * exception's severity is >= ExceptionSeverity.SESSION_SEVERITY.
+     */
+	final void notifyException(SQLException sqle) {
+        if (physicalConnection_ != null) 
+        	pooledConnection_.trashConnection(new SqlException(sqle));
+	}
+
     // ---------------------- wrapped public entry points ------------------------
     // All methods are forwarded to the physical connection in a standard way
 
     synchronized public java.sql.Statement createStatement() throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.createStatement();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     synchronized public java.sql.PreparedStatement prepareStatement(String sql) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.prepareStatement(sql);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     synchronized public PreparedStatement preparePositionedUpdateStatement(String sql, Section querySection) throws SqlException {
@@ -153,177 +178,337 @@ synchronized public PreparedStatement preparePositionedUpdateStatement(String sq
     }
 
     synchronized public java.sql.CallableStatement prepareCall(String sql) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.prepareCall(sql);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public String nativeSQL(String sql) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.nativeSQL(sql);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     synchronized public void setAutoCommit(boolean autoCommit) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         physicalConnection_.setAutoCommit(autoCommit);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public boolean getAutoCommit() throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.getAutoCommit();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     synchronized public void commit() throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         physicalConnection_.commit();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     synchronized public void rollback() throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         physicalConnection_.rollback();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     synchronized public void setTransactionIsolation(int level) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         physicalConnection_.setTransactionIsolation(level);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public int getTransactionIsolation() throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.getTransactionIsolation();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public java.sql.SQLWarning getWarnings() throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.getWarnings();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     synchronized public void clearWarnings() throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         physicalConnection_.clearWarnings();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public java.sql.DatabaseMetaData getMetaData() throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.getMetaData();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     synchronized public void setReadOnly(boolean readOnly) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         physicalConnection_.setReadOnly(readOnly);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public boolean isReadOnly() throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.isReadOnly();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     synchronized public void setCatalog(String catalog) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         physicalConnection_.setCatalog(catalog);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public String getCatalog() throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.getCatalog();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     synchronized public java.sql.Statement createStatement(int resultSetType,
                                                            int resultSetConcurrency) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.createStatement(resultSetType, resultSetConcurrency);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     synchronized public java.sql.PreparedStatement prepareStatement(String sql,
                                                                     int resultSetType,
                                                                     int resultSetConcurrency) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.prepareStatement(sql, resultSetType, resultSetConcurrency);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     synchronized public java.sql.CallableStatement prepareCall(String sql,
                                                                int resultSetType,
                                                                int resultSetConcurrency) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.prepareCall(sql, resultSetType, resultSetConcurrency);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public java.util.Map getTypeMap() throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.getTypeMap();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     synchronized public void setTypeMap(java.util.Map map) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         physicalConnection_.setTypeMap(map);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public java.sql.Statement createStatement(int resultSetType, int resultSetConcurrency,
                                               int resultSetHoldability) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public java.sql.CallableStatement prepareCall(String sql, int resultSetType,
                                                   int resultSetConcurrency,
                                                   int resultSetHoldability) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public java.sql.PreparedStatement prepareStatement(String sql, int resultSetType,
                                                        int resultSetConcurrency, int resultSetHoldability)
             throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.prepareStatement(sql, resultSetType, resultSetConcurrency,
                 resultSetHoldability);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public java.sql.PreparedStatement prepareStatement(String sql, int autoGeneratedKeys)
             throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.prepareStatement(sql, autoGeneratedKeys);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public java.sql.PreparedStatement prepareStatement(String sql, int columnIndexes[])
             throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.prepareStatement(sql, columnIndexes);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public java.sql.PreparedStatement prepareStatement(String sql, String columnNames[])
             throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.prepareStatement(sql, columnNames);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public void setHoldability(int holdability) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         physicalConnection_.setHoldability(holdability);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public int getHoldability() throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.getHoldability();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public java.sql.Savepoint setSavepoint() throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.setSavepoint();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public java.sql.Savepoint setSavepoint(String name) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         return physicalConnection_.setSavepoint(name);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public void rollback(java.sql.Savepoint savepoint) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         physicalConnection_.rollback(savepoint);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public void releaseSavepoint(java.sql.Savepoint savepoint) throws SQLException {
+		try {
         checkForNullPhysicalConnection();
         physicalConnection_.releaseSavepoint(savepoint);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     //----------------------------------------------------------------------------
diff --git a/db/derby/code/branches/10.3/java/client/org/apache/derby/client/am/LogicalConnection40.java b/db/derby/code/branches/10.3/java/client/org/apache/derby/client/am/LogicalConnection40.java
index 15c9ac60..07b78663 100644
--- a/db/derby/code/branches/10.3/java/client/org/apache/derby/client/am/LogicalConnection40.java
+++ b/db/derby/code/branches/10.3/java/client/org/apache/derby/client/am/LogicalConnection40.java
@@ -54,38 +54,74 @@ public LogicalConnection40(Connection physicalConnection,
 
     public Array createArrayOf(String typeName, Object[] elements)
         throws SQLException {
+        try
+        {
 		checkForNullPhysicalConnection();
         return physicalConnection_.createArrayOf( typeName, elements );
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
     
     public Blob createBlob()
         throws SQLException {
+        try
+        {
 		checkForNullPhysicalConnection();
         return physicalConnection_.createBlob();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public Clob createClob()
         throws SQLException {
+        try
+        {
 		checkForNullPhysicalConnection();
         return physicalConnection_.createClob();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
     
     public NClob createNClob()
         throws SQLException {
+        try
+        {
 		checkForNullPhysicalConnection();
         return physicalConnection_.createNClob();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public SQLXML createSQLXML()
         throws SQLException {
+        try
+        {
 		checkForNullPhysicalConnection();
         return physicalConnection_.createSQLXML();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     public Struct createStruct(String typeName, Object[] attributes)
         throws SQLException {
+        try
+        {
 		checkForNullPhysicalConnection();
         return physicalConnection_.createStruct( typeName, attributes );
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     /**
@@ -100,8 +136,14 @@ public Struct createStruct(String typeName, Object[] attributes)
      */
     public Properties getClientInfo()
         throws SQLException {
+        try
+        {
 	checkForNullPhysicalConnection();
 	return physicalConnection_.getClientInfo();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
     
     /**
@@ -116,8 +158,14 @@ public Properties getClientInfo()
      */
     public String getClientInfo(String name)
         throws SQLException {
+        try
+        {
 	checkForNullPhysicalConnection();
 	return physicalConnection_.getClientInfo(name);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     /**
@@ -127,8 +175,14 @@ public String getClientInfo(String name)
      * @exception SQLException if a database access error occurs
      */
     public Map<String, Class<?>> getTypeMap() throws SQLException {
+        try
+        {
         checkForNullPhysicalConnection();
         return ((java.sql.Connection) physicalConnection_).getTypeMap();
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     /**
@@ -146,18 +200,30 @@ public String getClientInfo(String name)
      * exception.
      */
     synchronized public boolean isValid(int timeout) throws SQLException {
+        try
+        {
         // Check if we have a underlying physical connection
         if (physicalConnection_ == null) {
             return false;
         }
         return physicalConnection_.isValid(timeout);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
    
 
     public boolean isWrapperFor(Class<?> interfaces)
         throws SQLException {
+        try
+        {
         checkForNullPhysicalConnection();
         return interfaces.isInstance(this);
+		} catch (SQLException sqle) {
+			notifyException(sqle);
+			throw sqle;
+		}
     }
 
     /**
@@ -170,13 +236,20 @@ public boolean isWrapperFor(Class<?> interfaces)
      */
     public void setClientInfo(Properties properties)
         throws SQLClientInfoException {
-	try { checkForNullPhysicalConnection(); }
-	catch (SQLException se) { 
+        try
+        {
+    		checkForNullPhysicalConnection(); 
+        	physicalConnection_.setClientInfo(properties);
+        } catch (SQLClientInfoException cie) {
+            notifyException(cie);
+            throw cie;
+    	} catch (SQLException sqle) {
+    		notifyException(sqle);
 	    throw new SQLClientInfoException
-		(se.getMessage(), se.getSQLState(), 
+    		(sqle.getMessage(), sqle.getSQLState(), 
+    				sqle.getErrorCode(),
 		 (new FailedProperties40(properties)).getProperties());
 	}
-	physicalConnection_.setClientInfo(properties);
     }
     
     /**
@@ -189,19 +262,28 @@ public void setClientInfo(Properties properties)
      */
     public void setClientInfo(String name, String value)
         throws SQLClientInfoException {
-	try { checkForNullPhysicalConnection(); }
-        catch (SQLException se) {
+        try
+        {
+    		checkForNullPhysicalConnection(); 
+        	physicalConnection_.setClientInfo(name, value);
+        } catch (SQLClientInfoException cie) {
+            notifyException(cie);
+            throw cie;
+    	} catch (SQLException sqle) {
+    		notifyException(sqle);
             throw new SQLClientInfoException
-                (se.getMessage(), se.getSQLState(),
+            (sqle.getMessage(), sqle.getSQLState(),
+            		sqle.getErrorCode(),
                  new FailedProperties40
                  (FailedProperties40.makeProperties
                   (name,value)).getProperties());
         }
-	physicalConnection_.setClientInfo(name, value);
     }
     
     public <T>T unwrap(Class<T> interfaces)
         throws SQLException {
+        try
+        {
         checkForNullPhysicalConnection();
         // Derby does not implement non-standard methods on JDBC objects
         try {
@@ -211,6 +293,10 @@ public void setClientInfo(String name, String value)
                                    new ClientMessageId(SQLState.UNABLE_TO_UNWRAP),
                                    interfaces).getSQLException();
         }
+    	} catch (SQLException sqle) {
+    		notifyException(sqle);
+    		throw sqle;
+    	}
     }
     
 } // End class LogicalConnection40
diff --git a/db/derby/code/branches/10.3/java/client/org/apache/derby/client/am/SqlCode.java b/db/derby/code/branches/10.3/java/client/org/apache/derby/client/am/SqlCode.java
index e96c961c..09851127 100644
--- a/db/derby/code/branches/10.3/java/client/org/apache/derby/client/am/SqlCode.java
+++ b/db/derby/code/branches/10.3/java/client/org/apache/derby/client/am/SqlCode.java
@@ -50,7 +50,7 @@ public final int getCode() {
 
     public final static SqlCode queuedXAError = new SqlCode(-4203);
 
-    public final static SqlCode disconnectError = new SqlCode(-4499);
+    public final static SqlCode disconnectError = new SqlCode(40000);
 
     public final static SqlCode undefinedError = new SqlCode(-99999);
     
diff --git a/db/derby/code/branches/10.3/java/client/org/apache/derby/client/net/NetConnection40.java b/db/derby/code/branches/10.3/java/client/org/apache/derby/client/net/NetConnection40.java
index c97daa8f..caeac804 100644
--- a/db/derby/code/branches/10.3/java/client/org/apache/derby/client/net/NetConnection40.java
+++ b/db/derby/code/branches/10.3/java/client/org/apache/derby/client/net/NetConnection40.java
@@ -245,6 +245,7 @@ public void setClientInfo(String name, String value)
 	catch (SqlException se) {
             throw new SQLClientInfoException
                 (se.getMessage(), se.getSQLState(), 
+                		se.getErrorCode(),
                  new FailedProperties40(p).getProperties());
         }
 
@@ -274,6 +275,7 @@ public void setClientInfo(Properties properties)
 	try { checkForClosedConnection(); } 
 	catch (SqlException se) {
 	    throw new SQLClientInfoException(se.getMessage(), se.getSQLState(),
+	    		se.getErrorCode(),
 					  fp.getProperties());
 	}
 	
@@ -287,7 +289,9 @@ public void setClientInfo(Properties properties)
 			     (SQLState.PROPERTY_UNSUPPORTED_CHANGE), 
 			     fp.getFirstKey(), fp.getFirstValue());
         throw new SQLClientInfoException(se.getMessage(),
-                                         se.getSQLState(), fp.getProperties());
+        		se.getSQLState(), 
+	    		se.getErrorCode(),
+	    		fp.getProperties());
     }
 
     /**
diff --git a/db/derby/code/branches/10.3/java/engine/org/apache/derby/iapi/jdbc/BrokeredConnection40.java b/db/derby/code/branches/10.3/java/engine/org/apache/derby/iapi/jdbc/BrokeredConnection40.java
index 62e91d41..6059b45d 100644
--- a/db/derby/code/branches/10.3/java/engine/org/apache/derby/iapi/jdbc/BrokeredConnection40.java
+++ b/db/derby/code/branches/10.3/java/engine/org/apache/derby/iapi/jdbc/BrokeredConnection40.java
@@ -67,9 +67,6 @@ public Array createArrayOf(String typeName, Object[] elements)
      *
      */
     public Blob createBlob() throws SQLException {
-        if (isClosed()) {
-            throw Util.noCurrentConnection();
-        }
         // Forward the createBlob call to the physical connection
         try {
             return getRealConnection().createBlob();
@@ -93,9 +90,6 @@ public Blob createBlob() throws SQLException {
      *
      */
     public Clob createClob() throws SQLException{
-        if (isClosed()) {
-            throw Util.noCurrentConnection();
-        }
         // Forward the createClob call to the physical connection
         try {
             return getRealConnection().createClob();
@@ -182,8 +176,10 @@ public void setClientInfo(String name, String value)
             throw se;
         }
         catch (SQLException se) {
+            notifyException(se);
             throw new SQLClientInfoException
                 (se.getMessage(), se.getSQLState(), 
+                		se.getErrorCode(),
   		 (new FailedProperties40
 		  (FailedProperties40.makeProperties(name,value))).
 		 getProperties());
@@ -210,8 +206,10 @@ public void setClientInfo(Properties properties)
             throw cie;
         }
         catch (SQLException se) {
+            notifyException(se);
             throw new SQLClientInfoException
                 (se.getMessage(), se.getSQLState(), 
+                		se.getErrorCode(),
   		 (new FailedProperties40(properties)).getProperties());
         }
     }
@@ -311,8 +309,14 @@ public final BrokeredCallableStatement newBrokeredStatement(BrokeredStatementCon
      *                                with the given interface.
      */
     public final boolean isWrapperFor(Class<?> interfaces) throws SQLException {
-        checkIfClosed();
+        try {
+            if (getRealConnection().isClosed())
+                throw Util.noCurrentConnection();
         return interfaces.isInstance(this);
+        } catch (SQLException sqle) {
+            notifyException(sqle);
+            throw sqle;
+        }
     }
     
     /**
@@ -325,7 +329,9 @@ public final boolean isWrapperFor(Class<?> interfaces) throws SQLException {
      */
     public final <T> T unwrap(java.lang.Class<T> interfaces) 
                             throws SQLException{
-        checkIfClosed();
+        try {
+            if (getRealConnection().isClosed())
+                throw Util.noCurrentConnection();
         //Derby does not implement non-standard methods on 
         //JDBC objects
         try {
@@ -334,5 +340,9 @@ public final boolean isWrapperFor(Class<?> interfaces) throws SQLException {
             throw Util.generateCsSQLException(SQLState.UNABLE_TO_UNWRAP,
                     interfaces);
         }
+        } catch (SQLException sqle) {
+            notifyException(sqle);
+            throw sqle;
+        }
     }    
 }
diff --git a/db/derby/code/branches/10.3/java/engine/org/apache/derby/impl/jdbc/EmbedConnection40.java b/db/derby/code/branches/10.3/java/engine/org/apache/derby/impl/jdbc/EmbedConnection40.java
index b87c5829..3b42341a 100644
--- a/db/derby/code/branches/10.3/java/engine/org/apache/derby/impl/jdbc/EmbedConnection40.java
+++ b/db/derby/code/branches/10.3/java/engine/org/apache/derby/impl/jdbc/EmbedConnection40.java
@@ -120,6 +120,7 @@ public void setClientInfo(String name, String value)
             FailedProperties40 fp = new FailedProperties40(p);
             throw new SQLClientInfoException(se.getMessage(), 
                                              se.getSQLState(), 
+                                             se.getErrorCode(),
                                              fp.getProperties());
         }
         // Allow null to simplify compliance testing through
@@ -152,7 +153,7 @@ public void setClientInfo(Properties properties)
         try { checkIfClosed(); }
         catch (SQLException se) {
             throw new SQLClientInfoException(se.getMessage(), se.getSQLState(),
-                                             fp.getProperties());
+            		se.getErrorCode(), fp.getProperties());
         }
 
         // Allow null to simplify compliance testing through
@@ -169,7 +170,9 @@ public void setClientInfo(Properties properties)
              fp.getFirstKey(), 
              fp.getFirstValue());
         throw new SQLClientInfoException(se.getMessage(),
-                                         se.getSQLState(), fp.getProperties());
+        		se.getSQLState(), 
+        		se.getErrorCode(),
+        		fp.getProperties());
     }
     
     /**
diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/BadConnectionTest.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/BadConnectionTest.java
index 07e9f491..4887b1fe 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/BadConnectionTest.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/derbynet/BadConnectionTest.java
@@ -65,7 +65,7 @@ public void testNoUserOrPassword()
 					"jdbc:derby://" + host + ":" + port + "/testbase");
 		} catch (SQLException e) {
 			assertSQLState("08004", e);
-			assertEquals(-4499, e.getErrorCode());
+			assertEquals(40000, e.getErrorCode());
 		}
 	}
 	
@@ -84,7 +84,7 @@ public void testDatabaseNotFound()
 		} catch (SQLException e)
 		{
 			assertSQLState("08004", e);
-			assertEquals(-4499, e.getErrorCode());
+			assertEquals(40000, e.getErrorCode());
 		}
 	}
 	
diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/jdbc4/DataSourceTest.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/jdbc4/DataSourceTest.java
index a49fa832..cb5606b2 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/jdbc4/DataSourceTest.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/jdbc4/DataSourceTest.java
@@ -23,11 +23,19 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 import junit.framework.*;
 
+import org.apache.derby.drda.NetworkServerControl;
+import org.apache.derby.jdbc.ClientConnectionPoolDataSource;
+import org.apache.derby.jdbc.EmbeddedConnectionPoolDataSource;
+import org.apache.derbyTesting.functionTests.tests.jdbcapi.AssertEventCatcher;
+import org.apache.derbyTesting.functionTests.util.TestUtil;
 import org.apache.derbyTesting.junit.BaseJDBCTestCase;
+import org.apache.derbyTesting.junit.JDBC;
 import org.apache.derbyTesting.junit.JDBCDataSource;
 import org.apache.derbyTesting.junit.TestConfiguration;
 
+import java.net.InetAddress;
 import java.sql.*;
+
 import javax.sql.*;
 
 /**
@@ -38,6 +46,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
     
     //Default DataSource that will be used by the tests
     private DataSource ds = null;
+    protected static String dbName = 
+        TestConfiguration.getCurrent().getDefaultDatabaseName();
     
     /**
      *
@@ -116,6 +126,251 @@ public void testUnwrapResultSet() {
         }
     }
 
+    /**
+     * Test case for DERBY-3172
+     * When the Derby engine is shutdown or Network Server is brought down, any
+     * api on JDBC Connection object should generate a Connection error event.
+     */
+    public void testConnectionErrorEvent() throws SQLException, Exception
+    {
+    	Connection conn;
+    	ConnectionPoolDataSource ds;
+    	PooledConnection pc;
+    	Statement st;
+        AssertEventCatcher aes12 = new AssertEventCatcher(12);
+        //Get the correct ConnectionPoolDataSource object
+        if (usingEmbedded())
+        {
+        	ds = new EmbeddedConnectionPoolDataSource();
+            ((EmbeddedConnectionPoolDataSource)ds).setDatabaseName(dbName);
+        } else
+        {
+            ds = new ClientConnectionPoolDataSource();
+            ((ClientConnectionPoolDataSource)ds).setDatabaseName(dbName);
+        }
+        pc = ds.getPooledConnection();
+        //Add a connection event listener to ConnectionPoolDataSource
+        pc.addConnectionEventListener(aes12);
+        conn = pc.getConnection();
+        st = conn.createStatement();
+        //TAB1 does not exist and hence catch the expected exception
+        try {
+            st.executeUpdate("drop table TAB1");
+        } catch (SQLException sqle) {
+            assertSQLState("42Y55", sqle);
+        }
+        //No event should have been generated at this point
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertFalse(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        //Shutdown the Derby engine or Network Server depending on what 
+        //mode we are running in.
+        if (usingEmbedded())
+        {
+        	getTestConfiguration().shutdownDatabase();
+        } else
+        {
+        	stopNetworkServer();
+        }
+        //Now try to use various apis on the JDBC Connection object created 
+        //before shutdown and they all should generate connection error event.
+        try {
+            conn.createArrayOf("junk", null);
+        } catch (SQLException e) {
+            assertSQLState("0A000", e);
+        }
+        try {
+            conn.createNClob();
+        } catch (SQLException e) {
+            assertSQLState("0A000", e);
+        }
+        try {
+            conn.createSQLXML();
+        } catch (SQLException e) {
+            assertSQLState("0A000", e);
+        }
+        try {
+            conn.createStruct("junk", null);
+        } catch (SQLException e) {
+            assertSQLState("0A000", e);
+        }
+        try {
+            conn.createBlob();
+        } catch (SQLException e) {
+            //The first call on JDBC Connection object after Network Server
+            //shutdown will generate a communication error and that's why we
+            //are checking for SQL State 08006 rather than No current connection
+            //SQL State 08003. In embedded mode, we will get SQL State 08003
+        	//meaning No current connection
+            if (usingEmbedded())
+                assertSQLState("08003", e);
+            else
+                assertSQLState("08006", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();        	
+        try {
+            conn.createClob();
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();        	
+        try {
+            conn.getClientInfo();
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();        	
+        try {
+            conn.getClientInfo("junk");
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();        	
+        try {
+            conn.setClientInfo(null);
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();        	
+        try {
+            conn.setClientInfo("junk1", "junk2");
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();        	
+        try {
+            conn.isWrapperFor(this.getClass());
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        if (usingEmbedded())
+        	assertTrue(aes12.didConnectionErrorEventHappen());
+        else
+        	//We do not make any call on underneath JDBC Connection
+        	//object for isWrapperFor and hence never get Connection
+        	//Error event
+        	assertFalse(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();        	
+        try {
+            conn.unwrap(this.getClass());
+        } catch (SQLException e) {
+            if (usingEmbedded())
+                assertSQLState("08003", e);
+            else
+            	//We do not make any call on underneath JDBC Connection
+            	//object for unwrap and hence never get Connection
+            	//closed exception. Instead we got exception because
+            	//client driver code is trying to unwrap this.getClass
+            	//and it can't do that
+                assertSQLState("XJ128", e);
+        }
+    	assertFalse(aes12.didConnectionClosedEventHappen());
+        if (usingEmbedded())
+        	assertTrue(aes12.didConnectionErrorEventHappen());
+        else
+        	//We do not make any call on underneath JDBC Connection
+        	//object for isWrapperFor and hence never get Connection
+        	//Error event
+        	assertFalse(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();        	
+        try {
+            conn.isValid(5);
+        } catch (SQLException e) {
+            assertSQLState("08003", e);
+        }
+        if (usingEmbedded())
+        	assertTrue(aes12.didConnectionClosedEventHappen());
+        else
+        	assertFalse(aes12.didConnectionClosedEventHappen());
+    	//As per the JDBC definition, an exception and hence an event is raised
+    	//for isValid only if the param value is illegal
+    	assertFalse(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();        	
+        if (usingEmbedded())
+        {
+            Class.forName("org.apache.derby.jdbc.EmbeddedDriver").newInstance();
+        }else
+        {
+        	startNetworkServer();
+        }
+
+        // Get a new connection to the database
+        conn = getConnection();
+        conn.close();
+    }
+    /**
+     * Stop the network server
+     */
+    private void stopNetworkServer() {
+        try {
+            NetworkServerControl networkServer = new NetworkServerControl();
+            networkServer.shutdown();
+        } catch(Exception e) {
+            System.out.println("INFO: Network server shutdown returned: " + e);
+        }
+    }
+
+    /**
+     * Start the network server
+     */
+    private void startNetworkServer() {
+        int serverPort;
+
+        // Determines which host and port to run the network server on
+        // This is based how it is done in the test testSecMec.java
+        String serverName = TestUtil.getHostName();
+        if (serverName.equals("localhost")) {
+            serverPort = 1527;
+        }
+        else {
+            serverPort = 20000;
+        }
+
+        try {
+            NetworkServerControl networkServer = 
+                     new NetworkServerControl(InetAddress.getByName(serverName), 
+                                              serverPort);
+            networkServer.start(null);
+
+            // Wait for the network server to start
+            boolean started = false;
+            int retries = 10;         // Max retries = max seconds to wait
+            while (!started && retries > 0) {
+                try {
+                    // Sleep 1 second and then ping the network server
+		      Thread.sleep(1000);
+                    networkServer.ping();
+
+                    // If ping does not throw an exception the server has started
+                    started = true;
+                } catch(Exception e) {
+                    System.out.println("INFO: ping returned: " + e);
+                    retries--;
+	         }
+	     }
+
+            // Check if we got a reply on ping
+            if (!started) {
+                System.out.println("FAIL: Failed to start network server");
+            }
+        } catch (Exception e) {
+            System.out.println("FAIL: startNetworkServer got exception: " + e);
+        }
+    }
+
     /**
      * Return suite with all tests of the class.
      */
diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/AssertEventCatcher.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/AssertEventCatcher.java
index e69de29b..c2e2b0d5 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/AssertEventCatcher.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/AssertEventCatcher.java
@@ -0,0 +1,75 @@
+/*
+ 
+   Derby - Class org.apache.derbyTesting.functionTests.tests.jdbcapi.AssertEventCatcher
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+ 
+      http://www.apache.org/licenses/LICENSE-2.0
+ 
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+ 
+ */
+
+package org.apache.derbyTesting.functionTests.tests.jdbcapi;
+
+import javax.sql.*;
+
+public class AssertEventCatcher implements ConnectionEventListener
+{
+    private final int catcher;
+    //The following flags will indicate what kind of event was
+    //received by this listener
+    private boolean gotConnectionClosed = false;
+    private boolean gotConnectionErrorOccured = false;
+
+    public AssertEventCatcher(int which) {
+        catcher=which;
+    }
+
+    // ConnectionEventListener methods
+    public void connectionClosed(ConnectionEvent event)
+    {
+        gotConnectionClosed = true;
+    }
+
+    public void connectionErrorOccurred(ConnectionEvent event)
+    {
+        gotConnectionErrorOccured = true;
+    }
+
+    /**
+     * Tell the caller if we received Connection closed event
+     * @return true if received Connection closed event
+     */
+    public boolean didConnectionClosedEventHappen() 
+    {
+    	return gotConnectionClosed;
+    }
+    
+    /**
+     * Tell the caller if we received Connection error event
+     * @return true if received Connection error event
+     */
+    public boolean didConnectionErrorEventHappen() 
+    {
+    	return gotConnectionErrorOccured;
+    }
+    
+    /**
+     * Clear the event received flags for this listener.
+     */
+    public void resetState() 
+    {
+    	gotConnectionClosed = false;
+    	gotConnectionErrorOccured = false;
+    }
+}
diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/DataSourceTest.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/DataSourceTest.java
index e02b571c..9641f6dd 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/DataSourceTest.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/DataSourceTest.java
@@ -23,7 +23,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 package org.apache.derbyTesting.functionTests.tests.jdbcapi;
 
 import java.io.File;
+import java.io.FileOutputStream;
+import java.io.PrintWriter;
 import java.io.Serializable;
+import java.net.InetAddress;
 import java.security.AccessController;
 import java.sql.CallableStatement;
 import java.sql.Connection;
@@ -33,11 +36,11 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Statement;
+import java.sql.Savepoint;
 import java.util.Hashtable;
 import java.util.Iterator;
 
-import javax.sql.ConnectionEvent;
-import javax.sql.ConnectionEventListener;
+import org.apache.derbyTesting.functionTests.tests.jdbcapi.AssertEventCatcher;
 import javax.sql.ConnectionPoolDataSource;
 import javax.sql.DataSource;
 import javax.sql.PooledConnection;
@@ -50,6 +53,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import junit.framework.Test;
 import junit.framework.TestSuite;
 
+import org.apache.derby.drda.NetworkServerControl;
 import org.apache.derby.jdbc.ClientConnectionPoolDataSource;
 import org.apache.derby.jdbc.ClientDataSource;
 import org.apache.derby.jdbc.ClientXADataSource;
@@ -58,6 +62,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.jdbc.EmbeddedSimpleDataSource;
 import org.apache.derby.jdbc.EmbeddedXADataSource;
 import org.apache.derbyTesting.functionTests.util.SecurityCheck;
+import org.apache.derbyTesting.functionTests.util.TestUtil;
 import org.apache.derbyTesting.junit.BaseJDBCTestCase;
 import org.apache.derbyTesting.junit.J2EEDataSource;
 import org.apache.derbyTesting.junit.JDBC;
@@ -193,6 +198,419 @@ public void testDataSourceAPI() throws SQLException, ClassNotFoundException
     }
      */
     
+    /**
+     * Test case for DERBY-3172
+     * When the Derby engine is shutdown or Network Server is brought down, any
+     * api on JDBC Connection object should generate a Connection error event.
+     */
+    public void testConnectionErrorEvent() throws SQLException, Exception
+    {
+    	Connection conn;
+    	ConnectionPoolDataSource ds;
+    	PooledConnection pc;
+    	Statement st;
+        AssertEventCatcher aes12 = new AssertEventCatcher(12);
+        //Get the correct ConnectionPoolDataSource object
+        if (usingEmbedded())
+        {
+        	ds = new EmbeddedConnectionPoolDataSource();
+            ((EmbeddedConnectionPoolDataSource)ds).setDatabaseName(dbName);
+        } else
+        {
+            ds = new ClientConnectionPoolDataSource();
+            ((ClientConnectionPoolDataSource)ds).setDatabaseName(dbName);
+        }
+        pc = ds.getPooledConnection();
+        //Add a connection event listener to ConnectionPoolDataSource
+        pc.addConnectionEventListener(aes12);
+        conn = pc.getConnection();
+        st = conn.createStatement();
+        //TAB1 does not exist and hence catch the expected exception
+        try {
+            st.executeUpdate("drop table TAB1");
+        } catch (SQLException sqle) {
+            assertSQLState("42Y55", sqle);
+        }
+        //No event should have been generated at this point
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertFalse(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        //Shutdown the Derby engine or Network Server depending on what 
+        //mode we are running in.
+        if (usingEmbedded())
+        {
+        	getTestConfiguration().shutdownDatabase();
+        } else
+        {
+        	stopNetworkServer();
+        }
+        //Now try to use various apis on the JDBC Connection object created 
+        //before shutdown and they all should generate connection error event.
+        try {
+            conn.prepareStatement("CREATE TABLE TAB1(COL1 INT NOT NULL)");
+        } catch (SQLException e) {
+            //The first call on JDBC Connection object after Network Server
+            //shutdown will generate a communication error and that's why we
+            //are checking for SQL State 08006 rather than No current connection
+            //SQL State 08003. In embedded mode, we will get SQL State 08003
+        	//meaning No current connection
+            if (usingEmbedded())
+                assertSQLState("08003", e);
+            else
+                assertSQLState("08006", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.prepareStatement("CREATE TABLE TAB1(COL1 INT NOT NULL)", 1);
+        } catch (SQLException e) {
+            assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+        	int[] columnIndexes = {1};
+            conn.prepareStatement("CREATE TABLE TAB1(COL1 INT NOT NULL)", 
+            		columnIndexes);
+        } catch (SQLException e) {
+            assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+        	String[] columnNames = {"col1"};
+            conn.prepareStatement("CREATE TABLE TAB1(COL1 INT NOT NULL)", 
+            		columnNames);
+        } catch (SQLException e) {
+            assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.prepareStatement("CREATE TABLE TAB1(COL1 INT NOT NULL)",
+            		ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.prepareStatement("CREATE TABLE TAB1(COL1 INT NOT NULL)",
+            		ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
+            		ResultSet.CLOSE_CURSORS_AT_COMMIT);
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.createStatement();
+        } catch (SQLException e) {
+            assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
+            		ResultSet.CONCUR_READ_ONLY,
+            		ResultSet.CLOSE_CURSORS_AT_COMMIT);
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, 
+            ResultSet.CONCUR_READ_ONLY);
+        } catch (SQLException e) {
+            assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.prepareCall("CREATE TABLE TAB1(COL1 INT NOT NULL)",
+            		ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.prepareCall("CREATE TABLE TAB1(COL1 INT NOT NULL)");
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.prepareCall("CREATE TABLE TAB1(COL1 INT NOT NULL)",
+            		ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
+            		ResultSet.CLOSE_CURSORS_AT_COMMIT);
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.nativeSQL("CREATE TABLE TAB1(COL1 INT NOT NULL)");
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.getAutoCommit();
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.setAutoCommit(false);
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.getHoldability();
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.setHoldability(1);
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.commit();
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.rollback();
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.setSavepoint();
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.setSavepoint("savept1");
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.rollback((Savepoint)null);
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.releaseSavepoint((Savepoint)null);
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.getTransactionIsolation();
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.getWarnings();
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.clearWarnings();
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.getMetaData();
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.isReadOnly();
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.setReadOnly(true);
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.setCatalog(null);
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.getCatalog();
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.getTypeMap();
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        try {
+            conn.setTypeMap(null);
+        } catch (SQLException e) {
+                assertSQLState("08003", e);
+        }
+        assertFalse(aes12.didConnectionClosedEventHappen());
+        assertTrue(aes12.didConnectionErrorEventHappen());
+        aes12.resetState();
+        if (usingEmbedded())
+        {
+            Class.forName("org.apache.derby.jdbc.EmbeddedDriver").newInstance();
+        }else
+        {
+        	startNetworkServer();
+        }
+
+        // Get a new connection to the database
+        conn = getConnection();
+        conn.close();
+    }
+    /**
+     * Stop the network server
+     */
+    private void stopNetworkServer() {
+        try {
+            NetworkServerControl networkServer = new NetworkServerControl();
+            networkServer.shutdown();
+        } catch(Exception e) {
+            System.out.println("INFO: Network server shutdown returned: " + e);
+        }
+    }
+
+    /**
+     * Start the network server
+     */
+    private void startNetworkServer() {
+        int serverPort;
+
+        // Determines which host and port to run the network server on
+        // This is based how it is done in the test testSecMec.java
+        String serverName = TestUtil.getHostName();
+        if (serverName.equals("localhost")) {
+            serverPort = 1527;
+        }
+        else {
+            serverPort = 20000;
+        }
+
+        try {
+            NetworkServerControl networkServer = 
+                     new NetworkServerControl(InetAddress.getByName(serverName), 
+                                              serverPort);
+            networkServer.start(null);
+
+            // Wait for the network server to start
+            boolean started = false;
+            int retries = 10;         // Max retries = max seconds to wait
+            while (!started && retries > 0) {
+                try {
+                    // Sleep 1 second and then ping the network server
+		      Thread.sleep(1000);
+                    networkServer.ping();
+
+                    // If ping does not throw an exception the server has started
+                    started = true;
+                } catch(Exception e) {
+                    System.out.println("INFO: ping returned: " + e);
+                    retries--;
+	         }
+	     }
+
+            // Check if we got a reply on ping
+            if (!started) {
+                System.out.println("FAIL: Failed to start network server");
+            }
+        } catch (Exception e) {
+            System.out.println("FAIL: startNetworkServer got exception: " + e);
+        }
+    }
+    
     public void testAllDataSources() throws SQLException, Exception
     {
         Connection dmc = getConnection();
@@ -3261,62 +3679,3 @@ public int getFormatId()
         return(branch_id);
     }
 }
-
-class AssertEventCatcher implements ConnectionEventListener
-{
-    private final int catcher;
-    //The following flags will indicate what kind of event was
-    //received by this listener
-    private boolean gotConnectionClosed = false;
-    private boolean gotConnectionErrorOccured = false;
-
-    AssertEventCatcher(int which) {
-        catcher=which;
-    }
-
-    // ConnectionEventListener methods
-    public void connectionClosed(ConnectionEvent event)
-    {
-        SQLException sqle = event.getSQLException();
-        if (sqle != null)
-            System.out.print("DataSourceTest-" + catcher + "; SQLSTATE="
-                + sqle.getSQLState());
-        gotConnectionClosed = true;
-    }
-
-    public void connectionErrorOccurred(ConnectionEvent event)
-    {
-        SQLException sqle = event.getSQLException();
-        if (sqle != null)
-            System.out.print("DataSourceTest-" + catcher + "; SQLSTATE=" +
-                sqle.getSQLState());
-        gotConnectionErrorOccured = true;
-    }
-
-    /**
-     * Tell the caller if we received Connection closed event
-     * @return true if received Connection closed event
-     */
-    public boolean didConnectionClosedEventHappen() 
-    {
-    	return gotConnectionClosed;
-    }
-    
-    /**
-     * Tell the caller if we received Connection error event
-     * @return true if received Connection error event
-     */
-    public boolean didConnectionErrorEventHappen() 
-    {
-    	return gotConnectionErrorOccured;
-    }
-    
-    /**
-     * Clear the event received flags for this listener.
-     */
-    public void resetState() 
-    {
-    	gotConnectionClosed = false;
-    	gotConnectionErrorOccured = false;
-    }
-}
diff --git a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/system/nstest/NsTest.java b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/system/nstest/NsTest.java
index 7eef2c6a..c77a0ac4 100644
--- a/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/system/nstest/NsTest.java
+++ b/db/derby/code/branches/10.3/java/testing/org/apache/derbyTesting/system/nstest/NsTest.java
@@ -310,7 +310,7 @@ public static void main(String[] args) throws SQLException, IOException,
 
 			System.out.println("\n\n " + sqe + sqe.getErrorCode() + " "
 					+ sqe.getSQLState());
-			if ((sqe.getErrorCode() == -4499)
+			if ((sqe.getErrorCode() == 40000)
 					|| sqe.getSQLState().equalsIgnoreCase("08001")) {
 				System.out
 				.println("\n Unable to connect, test cannot proceed. Please verify if the Network Server is started on port 1900.");
