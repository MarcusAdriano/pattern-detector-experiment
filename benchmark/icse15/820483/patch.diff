diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/C_NodeTypes.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/C_NodeTypes.java
index 7bb5d1a3..267bbd91 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/C_NodeTypes.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/compile/C_NodeTypes.java
@@ -226,10 +226,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
     static final int GRANT_ROLE_NODE = 215;
     static final int REVOKE_ROLE_NODE = 216;
 
-    // OLAP Window functions
-    static final int WINDOW_NODE = 220;
-    static final int ROW_NUMBER_COLUMN_NODE = 221;
-
     // generated columns
     static final int GENERATION_CLAUSE_NODE = 222;
 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/execute/ResultSetFactory.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/execute/ResultSetFactory.java
index 000e804a..0672d609 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/execute/ResultSetFactory.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/execute/ResultSetFactory.java
@@ -25,6 +25,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 import org.apache.derby.iapi.error.StandardException;
 
+import org.apache.derby.iapi.sql.ResultDescription;
 import org.apache.derby.iapi.sql.ResultSet;
 import org.apache.derby.iapi.sql.Activation;
 
@@ -1099,35 +1100,6 @@ public NoPutResultSet getIndexRowToBaseRowResultSet(
 			throws StandardException;
 
         /**
-		A WindowResultSet is used for gathering rows from OLAP window functions.
-
-		<p>
-
-		@param source	the source result set, which is expected to provide
-						rows for the WindowResultSet
-		@param resultSetNumber	The resultSetNumber for the ResultSet
-		@param restriction		The restriction, if any, to be applied to the base row
-		@param optimizerEstimatedRowCount	Estimated total # of rows by
-											optimizer
-		@param optimizerEstimatedCost		Estimated total cost by optimizer
-
-		@return the window function as a result set.
-		@exception StandardException thrown when unable to create the
-			result set
-	 */
-	public NoPutResultSet getWindowResultSet(
-								Activation activation,
-								NoPutResultSet source,
-								GeneratedMethod rowAllocator,
-								int resultSetNumber,
-								int level,
-								int erdNumber,
-								GeneratedMethod restriction,
-								double optimizerEstimatedRowCount,
-								double optimizerEstimatedCost)
-	   	throws StandardException;
-        
-	/**
 		A nested loop left outer join result set forms a result set on top of
 		2 other result sets.
 		The rows can be constructed as they are requested from the
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/C_NodeNames.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/C_NodeNames.java
index c601f1d4..fd500671 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/C_NodeNames.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/C_NodeNames.java
@@ -234,8 +234,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	static final String REVOKE_ROLE_NODE_NAME =
 		"org.apache.derby.impl.sql.compile.RevokeRoleNode";
 
-	static final String ROW_NUMBER_COLUMN_NODE_NAME = "org.apache.derby.impl.sql.compile.RowNumberColumnNode";    
-
 	static final String ROW_RESULT_SET_NODE_NAME = "org.apache.derby.impl.sql.compile.RowResultSetNode";
 
 	static final String SQL_BOOLEAN_CONSTANT_NODE_NAME = "org.apache.derby.impl.sql.compile.SQLBooleanConstantNode";
@@ -300,8 +298,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 	static final String VIRTUAL_COLUMN_NODE_NAME = "org.apache.derby.impl.sql.compile.VirtualColumnNode";
 
-	static final String WINDOW_NODE_NAME = "org.apache.derby.impl.sql.compile.WindowNode";
-        
 	static final String SAVEPOINT_NODE_NAME = "org.apache.derby.impl.sql.compile.SavepointNode";
 
 	static final String XML_CONSTANT_NODE_NAME = "org.apache.derby.impl.sql.compile.XMLConstantNode";
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
index 44b71741..e8f3a3f9 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ColumnReference.java
@@ -611,7 +611,6 @@ public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)
 		referencedTabs.set(tableNumber);
 
 		return ( ! replacesAggregate ) &&
-			   ( ! source.isWindowFunction() ) && 
 			   ( (source.getExpression() instanceof ColumnReference) ||
 			     (source.getExpression() instanceof VirtualColumnNode) ||
 				 (source.getExpression() instanceof ConstantNode));
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NodeFactoryImpl.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NodeFactoryImpl.java
index 03003b98..4c7197f6 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NodeFactoryImpl.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/NodeFactoryImpl.java
@@ -614,15 +614,9 @@ protected String nodeName(int nodeType)
           case C_NodeTypes.TABLE_PRIVILEGES_NODE:
             return C_NodeNames.TABLE_PRIVILEGES_NAME;
 
-          case C_NodeTypes.WINDOW_NODE:
-            return C_NodeNames.WINDOW_NODE_NAME;
-
           case C_NodeTypes.GENERATION_CLAUSE_NODE:
             return C_NodeNames.GENERATION_CLAUSE_NODE_NAME;
 		  	
-          case C_NodeTypes.ROW_NUMBER_COLUMN_NODE:
-            return C_NodeNames.ROW_NUMBER_COLUMN_NODE_NAME;
-
           case C_NodeTypes.ROW_COUNT_NODE:
             return C_NodeNames.ROW_COUNT_NODE_NAME;
 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/OrderByList.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/OrderByList.java
index 2a629ace..7b8276e6 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/OrderByList.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/OrderByList.java
@@ -823,36 +823,6 @@ boolean requiresDescending(ColumnReference cRef, int numOptimizables)
 		return false;
 	}
 
-	/**
-	 * Adjust the OrderByList after removal of window function columns.
-	 *
-	 * @exception StandardException		Thrown on error
-	 */
-	public void adjustForWindowFunctionColumns() 	
-		throws StandardException
-	{	
-		/* 
-		 * Recreate the template due to removal of window function columns 
-		 * in the resultToSort RCL.
-		 */
-		resultRow =				
-				resultToSort.getResultColumns().buildEmptyRow().getRowArray();				
-		/*
-		 * Adjust the VirtualColumnIds OrderByColumns to the updated RCL. 
-		 */
-		for (int index = 0; index < size(); index++)
-		{
-			OrderByColumn obc = (OrderByColumn) elementAt(index);
-			obc.bindOrderByColumn(resultToSort, this);
-		}
-		/* 
-		 * Update the columOrdering
-		 *
-		 * TODO - is this really necessary?
-		 */
-		columnOrdering = getColumnOrdering();		
-	}
-
 
 	public String toString() {
 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ProjectRestrictNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ProjectRestrictNode.java
index 61560f80..dbc4c8a9 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ProjectRestrictNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ProjectRestrictNode.java
@@ -634,38 +634,6 @@ public Optimizable modifyAccessPath(JBitSet outerTables)
 			 */
 			childResult = childResult.modifyAccessPaths(restrictionList);
 
-			/*
-			 * If we have a subquery select with window function columns, we 
-			 * have the following simplified querytre before the above call:
-			 *    SELECT -> PRN -> SELECT
-			 * where middle PRN is what was originally a FromSubquery node.
-			 * With window functions we pull any WindowNodes into the tree, 
-			 * modify the lower selects RCL, and put a (noop) PRN on top in the 
-			 * above call. This results in:
-			 *    SELECT -> PRN -> PRN(noop) -> WN -> ...			 
-			 * A DISTINCT query will place an additional DistinctNode on top of 
-			 * the window node:
-			 *    SELECT -> PRN -> PRN(noop) -> DN -> WN -> ...
-			 * Note that the RCL for the initial PRN and its child SELECT used 
-			 * to be the same object. After the above call, the initial PRNs RCL 
-			 * is incorrect, and we need to regenerate the VCNs. 
-			 * The above two combinations are the only two possible from 
-			 * modifyAccessPaths() that require regeneration of the VCNs.
-			 */
-			if (childResult instanceof ProjectRestrictNode){
-				ProjectRestrictNode prn = (ProjectRestrictNode) childResult;
-				if (prn.childResult.getResultColumns()
-					.containsWindowFunctionResultColumn())
-				{
-					/* 
-					 * We have a window function column in the RCL of our child 
-					 * PRN, and need to regenerate the VCNs.
-					 */					
-					resultColumns.genVirtualColumnNodes(
-						prn.childResult, prn.childResult.getResultColumns());
-				}
-			}
-			
 			/* Mark this node as having the truly ... for
 			 * the underlying tree.
 			 */
@@ -1131,9 +1099,7 @@ public void pushExpressions(PredicateList predicateList)
 		 * if we can push any of the predicates which just got pushed
 		 * down to our level into the SelectNode.
 		 */			
-		if (pushPList != null && 
-			childResult instanceof SelectNode &&
-			!resultColumns.containsWindowFunctionResultColumn() )
+		if (pushPList != null && (childResult instanceof SelectNode))
 		{
 			pushPList.pushExpressionsIntoSelect((SelectNode) childResult, false);
 		}
@@ -1422,6 +1388,8 @@ private void generateMinion(ExpressionClassBuilder acb,
    		// static Method exprN = method pointer to exprN;
 
 	
+
+
 		// Map the result columns to the source columns
 		int[] mapArray = resultColumns.mapSourceColumns();
 		int mapArrayItem = acb.addItem(new ReferencedColumnsDescriptorImpl(mapArray));
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java
index 5ce8f553..1f2b7e11 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumn.java
@@ -1780,37 +1780,6 @@ public boolean isEquivalent(ValueNode o) throws StandardException
         return false;
 	}
 
-	/**
-	 * Check whether this ResultColumn immediate expression is a window function 
-	 * column or not.
-	 *
-	 * @return true if RCs expression is a window function column, false if not.
-	 */
-	public boolean expressionIsWindowFunction() 
-	{			
-		if (getExpression() instanceof WindowFunctionColumnNode){
-			return true;
-		}
-		return false;
-	}
-	
-	/**
-	 * Check whether this ResultColumn is a window function column or not, but 
-	 * do not traverse the complete chain of references.
-	 *
-	 * @return true if RC is a window function column, false if not.
-	 */
-	public boolean isWindowFunction() 
-	{	
-		ValueNode expr = getExpression();
-		
-		if (expr instanceof WindowFunctionColumnNode || 
-			(expr instanceof VirtualColumnNode && 
-			 expr.getSourceResultColumn().getExpression() instanceof WindowFunctionColumnNode)){
-			return true;
-		}
-		return false;
-	}
 
 	/**
 	 * Return true if this result column represents a generated column.
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
index 5e7fbf4c..102562ba 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/ResultColumnList.java
@@ -1105,10 +1105,6 @@ void generateCore(ExpressionClassBuilder acb,
 				{
 					continue;
 				}
-				/* Window function columns are added by the WindowResultSet for this levels RCL */
-				if (rc.isWindowFunction()) {
-					continue;
-				}
 			}
 
 
@@ -4196,42 +4192,6 @@ public int visibleSize()
 		return size() - orderBySelect - numGeneratedColumns();
 	}
 	
-	/**
-	 * Return whether or not this RCL contains any window ResultColumns
-	 *
-	 * @return Whether or not this RCL contains any window ResultColumns
-	 */
-	public boolean containsWindowFunctionResultColumn()
-	{		
-		int size = size();
-		for (int index = 0; index < size; index++) {
-			ResultColumn rc = (ResultColumn) elementAt(index);			
-			if (rc.isWindowFunction()){
-				return true;
-			}
-		}
-		return false;
-	}
-
-	/*
-	 * Remove all window functions columns from this list
-	 */
-	void removeWindowFunctionColumns() {
-		/* Walk the list backwards as we are removing elements */
-		int sz = size();
-		for (int index = sz - 1; index >= 0; index--) {
-			ResultColumn rc = (ResultColumn) elementAt(index);			
-			if (rc.isWindowFunction()){
-				removeElementAt(index);
-			}
-		}
-		/* 
-		 * Remap VirtualColumnIds now that window function columns are gone. 
-		 * Needed for ordering to work.
-		 */
-		resetVirtualColumnIds();
-	}
-
 	/**
 	 * Convert this object to a String.  See comments in QueryTreeNode.java
 	 * for how this should be done for tree printing.
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowNumberColumnNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowNumberColumnNode.java
index 22b459b7..e69de29b 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowNumberColumnNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/RowNumberColumnNode.java
@@ -1,81 +0,0 @@
-/*
-
-   Derby - Class org.apache.derby.impl.sql.compile.RowNumberColumnNode
-
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to you under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-
-package	org.apache.derby.impl.sql.compile;
-
-import org.apache.derby.iapi.error.StandardException;
-import org.apache.derby.iapi.types.TypeId;
-
-import java.sql.Types;
-
-public final class RowNumberColumnNode extends WindowFunctionColumnNode
-{
-	
-	/**
-	 * Initializer for a RowNumberColumnNode
-	 *
-	 * @exception StandardException
-	 */
-	public void init()
-		throws StandardException
-	{
-		super.init();
-		setType( TypeId.getBuiltInTypeId( Types.BIGINT ),
-				 TypeId.LONGINT_PRECISION,
-				 TypeId.LONGINT_SCALE, 
-				 false,
-				 TypeId.LONGINT_MAXWIDTH);			
-	}
-        
-	/**
-	 * Initializer for a RowNumberColumn node
-	 *
-	 * @param arg1 The window definition
-	 *
-	 * @exception StandardException
-	 */
-	public void init(Object arg1)
-		throws StandardException
-	{
-		this.init();		
-		setWindowNode((WindowNode) arg1);
-	}
-            
-	public boolean isEquivalent(ValueNode o) throws StandardException
-	{
-        /* Two RowNumberColumnNodes should never be equivalent */
-        return false;
-	}
-
-	/**
-	 * Indicate whether this column is ascending or not.
-	 * By default assume that all ordered columns are
-	 * necessarily ascending.  If this class is inherited
-	 * by someone that can be desceneded, they are expected
-	 * to override this method.
-	 *
-	 * @return true
-	 */
-	public boolean isAscending()
-	{
-		return true;
-	}
-}		
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
index a8feba3a..f0f5e072 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SelectNode.java
@@ -33,6 +33,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.sql.dictionary.DataDictionary;
 import org.apache.derby.iapi.sql.dictionary.TableDescriptor;
 
+import org.apache.derby.iapi.types.TypeId;
+import org.apache.derby.iapi.types.DataTypeDescriptor;
 
 import org.apache.derby.iapi.reference.Limits;
 import org.apache.derby.iapi.reference.SQLState;
@@ -1254,28 +1256,10 @@ public ResultSetNode genProjectRestrict(int origFromListSize)
 				throws StandardException
 	{
 		boolean				eliminateSort = false;
+		PredicateList		restrictionList;
+		ResultColumnList	prRCList;
 		ResultSetNode		prnRSN;
-		boolean				hasWindowFunction = false;
-		ResultColumnList	originalRCL = this.resultColumns.copyListAndObjects();		
 
-		/*
-		 * Even if we have a window function, we must do all projection and
-		 * restriction at this stage. Restricting on a window function, i.e
-		 *    SELECT ... <WINDOWFUNCTION> AS W ... WHERE W ...
-		 * is not allowed. Restrictions need to be evaluated in an outer SELECT
-		 * to achieve this.
-		 */
-		hasWindowFunction = resultColumns.containsWindowFunctionResultColumn();		
-		if (hasWindowFunction) {				
-			/*
-			 * Remove any window function columns now, and reinsert them from
-			 * the copy made above once grouping and ordering has been performed.
-			 */						
-			resultColumns.removeWindowFunctionColumns();			
-			if (orderByList != null) {
-				orderByList.adjustForWindowFunctionColumns();				
-			}
-		}
 		
 		prnRSN = (ResultSetNode) getNodeFactory().getNode(
 								C_NodeTypes.PROJECT_RESTRICT_NODE,
@@ -1324,12 +1308,8 @@ public ResultSetNode genProjectRestrict(int origFromListSize)
 			eliminateSort = eliminateSort || gbn.getIsInSortedOrder();
 		}
 
-		/* 
-		 * If it is distinct, that must also be taken care of. But, if there is 
-		 * a window function in the RCL we must delay duplicate elimination
-		 * until after the window function has been evaluated.
-		 */
-		if (isDistinct && !hasWindowFunction)
+		// if it is distinct, that must also be taken care of.
+		if (isDistinct)
 		{
 			// We first verify that a distinct is valid on the
 			// RCL.
@@ -1433,10 +1413,6 @@ public ResultSetNode genProjectRestrict(int origFromListSize)
 								null,
 								null,
 								getContextManager());
-				/*
-				 * Remove added ordering columns from the saved original RCL
-				*/								
-				originalRCL.removeOrderByColumns();				
 			}
 		}
 
@@ -1485,93 +1461,6 @@ public ResultSetNode genProjectRestrict(int origFromListSize)
 		/* Set the cost of this node in the generated node */
 		prnRSN.costEstimate = costEstimate.cloneMe();
 
-		/*
-		 * Now that grouping and ordering has been performed, we can reinsert 
-		 * the window function column(s), and pull the WindowNode(s) up from 
-		 * under the window function ResultColumn(s).
-		 */
-		if (hasWindowFunction) {		
-			/*
-			 * Pull all WindowNodes up from under their window function column,
-			 * and place the WindowNode on top.
-			 */			
-			int size = originalRCL.size();						
-			int windowFunctionLevel = 0;		
-			ResultColumnList windowFunctionRCL = originalRCL.copyListAndObjects();										
-			for (int index = 0; index < size; index++) {
-				ResultColumn rc = (ResultColumn) originalRCL.elementAt(index);				
-				/*
-				 * NOTE: We only care about window function columns that appear 
-				 * here, and not about references into subquerys or similar.
-				 */
-				if (rc.expressionIsWindowFunction()) {					
-			
-					WindowFunctionColumnNode wfcn = (WindowFunctionColumnNode) rc.getExpression();
-					WindowNode windowNode = wfcn.getWindowNode();
-
-					windowFunctionLevel++;
-					
-					windowNode.setResultColumns(windowFunctionRCL);
-					windowNode.setChildResult((ResultSetNode) prnRSN);
-					windowNode.setWindowFunctionLevel(windowFunctionLevel);
-					
-					/* Set the cost of this node in the generated node */
-					windowNode.costEstimate = costEstimate.cloneMe();
-					/* Set the new top */
-					prnRSN = windowNode;
-				}
-			}
-
-			/* 
-			 * After evaluation of the window function, we can do duplicate 
-			 * elimination for distinct queries.
-			 */
-			if (isDistinct)
-			{
-				/* Verify that a distinct is valid on the RCL. */
-				prnRSN.getResultColumns().verifyAllOrderable();
-
-				/*
-				 * We cannot push duplicate elimination into store via a hash 
-				 * scan when there is a window function in the RCL, but it may 
-				 * be possible to filter out duplicates without a sorter.
-				 */
-				boolean inSortedOrder = isOrderedResult(prnRSN.getResultColumns(), 
-														prnRSN, 
-														!(orderByAndDistinctMerged));
-				prnRSN = (ResultSetNode) getNodeFactory().getNode(
-											C_NodeTypes.DISTINCT_NODE,
-											prnRSN,
-											new Boolean(inSortedOrder),
-											null,
-											getContextManager());
-				prnRSN.costEstimate = costEstimate.cloneMe();
-			}
-			
-			/*
-			 * Top off with a PRN as this is the intent of this method. Even 
-			 * though this PRN is a noop and will never be generated, we should 
-			 * leave it here as other parts of the code expects to find 
-			 * PRN -> WN, or PRN -> DN -> WN.
-			 */
-			ResultColumnList newRCL = prnRSN.getResultColumns().copyListAndObjects(); 
-			newRCL.genVirtualColumnNodes(prnRSN, prnRSN.getResultColumns());
-						
-			prnRSN = (ResultSetNode) getNodeFactory().getNode(
-				C_NodeTypes.PROJECT_RESTRICT_NODE,
-				prnRSN, /* Child ResultSet */
-				newRCL, /* Projection */ 
-				null, /* Restriction */
-				null, /* Restriction as PredicateList */
-				null, /* Subquerys in Projection */
-				null, /* Subquerys in Restriction */
-				null,
-				getContextManager());
-		
-			/* Set the cost of this node in the generated node */
-			prnRSN.costEstimate = costEstimate.cloneMe();						
-		}
-	
 		return prnRSN;
 	}
 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java
index 0acac70d..b9d85986 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/SubqueryNode.java
@@ -622,12 +622,10 @@ public ValueNode preprocess(int numTables,
 		 *           b) it appears within a WHERE clause but does not itself 
 		 *              contain a WHERE clause with other subqueries in it. 
 		 *          (DERBY-3301)
-		 *  o It does not contain a window function column.
 		 */
 		flattenable = (resultSet instanceof RowResultSetNode) &&
 					  underTopAndNode && !havingSubquery &&
 					  !isWhereExistsAnyInWithWhereSubquery() &&
-					  !hasWindowFunctionColumn() &&
 					  parentComparisonOperator instanceof BinaryComparisonOperatorNode;
 		if (flattenable)
 		{
@@ -689,14 +687,12 @@ public ValueNode preprocess(int numTables,
 		 *           b) it appears within a WHERE clause but does not itself 
 		 *              contain a WHERE clause with other subqueries in it. 
 		 *          (DERBY-3301)
-		 *  o The subquery has a window function column.
 		 */
 		boolean flattenableNotExists = (isNOT_EXISTS() || canAllBeFlattened());
 
 		flattenable = (resultSet instanceof SelectNode) &&
 					  underTopAndNode && !havingSubquery &&
 					  !isWhereExistsAnyInWithWhereSubquery() &&
-					  !hasWindowFunctionColumn() &&
 					  (isIN() || isANY() || isEXISTS() || flattenableNotExists ||
                        parentComparisonOperator != null);
 
@@ -2470,35 +2466,4 @@ public boolean isWhereExistsAnyInWithWhereSubquery()
 			return false;
 		}
 	}
-	
-	/**
-	 * Check whether this subquery has a window function column. 
-	 * Used in flattening decision making.
-	 * 
-	 * @return true if this subquery has a windowfunction column.	 
-	 */
-	public boolean hasWindowFunctionColumn() 
-			throws StandardException
-	{
-		if (resultSet instanceof SelectNode){
-			/*
-			 * Check the subquery select for a window function column in the RCL 
-			 */
-			SelectNode sn = (SelectNode) resultSet;
-			ResultColumnList rcl = sn.getResultColumns();
-			/*
-			CollectNodesVisitor cnv = 
-					new CollectNodesVisitor(WindowFunctionColumnNode.class,
-											WindowFunctionColumnNode.class);
-			rcl.accept(cnv);
-			return !cnv.getList().isEmpty();
-			 */
-			/*
-			 * Check this SelectNodes immediate RCL, 
-			 * and not traverse the full tree 
-			 */
-			rcl.containsWindowFunctionResultColumn();
-		}
-		return false;
-	}
 }
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowFunctionColumnNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowFunctionColumnNode.java
index c1cf0d51..e69de29b 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowFunctionColumnNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowFunctionColumnNode.java
@@ -1,188 +0,0 @@
-/*
-
-   Derby - Class org.apache.derby.impl.sql.compile.WindowFunctionColumnNode
-
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to you under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-
-package org.apache.derby.impl.sql.compile;
-
-import java.util.Vector;
-import org.apache.derby.iapi.error.StandardException;
-import org.apache.derby.iapi.services.compiler.MethodBuilder;
-import org.apache.derby.iapi.services.sanity.SanityManager;
-
-/**
- * Abstract WindowFunctionColumnNode for window function columns in a 
- * ResultColumnList. 
- * <p>
- * This abstract class contains the common code for window function columns, 
- * and simplifies checks in the code for compilation and execution.
- * <p>
- */
-abstract class WindowFunctionColumnNode extends ResultColumn
-{
-	/* 
-	 * WindowNode containing the window definition 
-	 * for this window function column
-	 */
-	private WindowNode windowNode;
-	
-	
-	/**
-	 * Initializer for a WindowFunctionColumnNode
-	 *
-	 * @exception StandardException
-	 */
-	public void init()
-		throws StandardException
-	{		
-		this.windowNode = null;
-		this.isGenerated = true;		
-	}	
-	
-	/**
-	 * getWindowNode
-	 *
-	 * @return the WindowNode for this window function column 
-	 */
-	public WindowNode getWindowNode()
-	{
-		return this.windowNode;
-	}
-	
-	/**
-	 * setWindowNode
-	 *
-	 * @param wn The WindowNode with the window definition for this 
-	 *			window function column 
-	 */	
-	public void setWindowNode(WindowNode wn)
-	{
-		this.windowNode = wn;
-	}
-	
-	/**
-	 * Preprocess an expression tree.  We do a number of transformations
-	 * here (including subqueries, IN lists, LIKE and BETWEEN) plus
-	 * subquery flattening.
-	 * NOTE: This is done before the outer ResultSetNode is preprocessed.
-	 *
-	 * @param	numTables			Number of tables in the DML Statement
-	 * @param	outerFromList		FromList from outer query block
-	 * @param	outerSubqueryList	SubqueryList from outer query block
-	 * @param	outerPredicateList	PredicateList from outer query block
-	 *
-	 * @return		The modified expression
-	 *
-	 * @exception StandardException		Thrown on error
-	 */
-	public ValueNode preprocess(int numTables,
-								FromList outerFromList,
-								SubqueryList outerSubqueryList,
-								PredicateList outerPredicateList) 
-					throws StandardException
-	{
-		/* 
-		 * Preprocess our WindowNode
-		 */
-		windowNode = (WindowNode)windowNode.preprocess(numTables, 
-			outerFromList,
-			outerSubqueryList,
-			outerPredicateList);
-		return this;
-	}
-	
-	
-	/**
-	 * Bind this expression.  This means binding the sub-expressions,
-	 * as well as figuring out what the return type is for this expression.
-	 * In this case, there are no sub-expressions, and the return type
-	 * is already known, so this is just a stub.
-	 *
-	 * @param fromList		The FROM list for the query this
-	 *						expression is in, for binding columns.
-	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
-	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
-	 *
-	 * @return	The new top of the expression tree.
-	 *
-	 * @exception StandardException		Thrown on error. Although this class
-	 * doesn't throw this exception, it's subclasses do and hence this method
-	 * signature here needs to have throws StandardException 
-	 */
-	public ValueNode bindExpression(
-			FromList fromList, 
-			SubqueryList subqueryList,
-			Vector	aggregateVector)
-		throws StandardException
-	{
-		/*
-		 * Call into the windows bind method
-		 */		
-		windowNode.bind(fromList, subqueryList, aggregateVector);		
-		return this;
-	}
-        
-	/**
-	 * Do code generation for this window function
-	 *
-	 * @param acb	The ExpressionClassBuilder for the class we're generating
-	 * @param mb	The method the code to place the code
-	 *
-	 *
-	 * @exception StandardException		Thrown on error
-	 */
-	public void generateExpression(ExpressionClassBuilder acb,
-                                       MethodBuilder mb)                                       
-		throws StandardException
-	{
-		/* 
-		 * Window function columns are added by the WindowResultSet, so we 
-		 * should never call into here.
-		 */
-		if (SanityManager.DEBUG)
-			SanityManager.ASSERT(false, "Code generation for WindowFunctionColumnNode is unimplemented");
-	}        
-
-	/**
-	 * Window functions do not have a (base)tablename, so we return null.
-	 * Overrides method from parent class.
-	 */
-	public String getTableName()
-	{
-		return null;
-	}
-
-	/**
-	 * Prints the sub-nodes of this object.  See QueryTreeNode.java for
-	 * how tree printing is supposed to work.
-	 *
-	 * @param depth		The depth of this node in the tree
-	 */
-
-	public void printSubNodes(int depth)
-	{
-		super.printSubNodes(depth);
-		if (SanityManager.DEBUG)
-		{
-			printLabel(depth, "windownode: ");
-			windowNode.treePrint(depth + 1);
-		}
-	}
-
-}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowNode.java
index def10d2c..e69de29b 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/WindowNode.java
@@ -1,278 +0,0 @@
-/*
-	Derby - Class org.apache.derby.impl.sql.compile.WindowNode
- 
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to you under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
-*/
-
-package org.apache.derby.impl.sql.compile;
-
-import java.util.Properties;
-
-import java.util.Vector;
-import org.apache.derby.iapi.error.StandardException;
-
-import org.apache.derby.iapi.reference.ClassName;
-import org.apache.derby.iapi.services.classfile.VMOpcode;
-import org.apache.derby.iapi.services.compiler.MethodBuilder;
-
-import org.apache.derby.iapi.services.io.FormatableBitSet;
-import org.apache.derby.iapi.services.sanity.SanityManager;
-import org.apache.derby.iapi.util.JBitSet;
-
-/**
- * This node type handles window functions. It takes a
- * FromTable as its source ResultSetNode, and generates an
- * WindowResultSet.
- * 
- * The implementation is based on IndexToBaseRowNode.
- */
-public class WindowNode extends SingleChildResultSetNode {	
-	
-	/* The following members define the window properties 
-	 * 
-	 * NOTE: Named windows, and window partitions except the full ResultSet 
-	 *       are not yet supported.
-	 */
-	private String windowName;
-	private ResultColumnList partitionDefinition;
-	private OrderByList orderByList;
-	private Object frameDefinition; // TODO
-		
-	/* 
-	 * When there are multiple window function columns in a RCL, 
-	 * 'windowFunctionLevel' is used to identify which level this WindowNode 
-	 * is at in the chain.
-	 */
-	private int windowFunctionLevel;
-	
-	private Properties tableProperties;
-	private int numTables;
-	
-	public void init(Object windowName,
-		Object partitionDefinition,
-		Object orderByList,
-		Object frameDefinition)
-		throws StandardException {
-		this.windowName = (String) windowName;
-		this.partitionDefinition = (ResultColumnList) partitionDefinition;
-		this.orderByList = (OrderByList) orderByList;
-		this.frameDefinition = (Object) frameDefinition; // TODO		
-		this.windowFunctionLevel = -1;
-	}
-
-	/*
-	 *  ResultSet implementation
-	 */
-	
-	/**
-	 * Preprocess a WindowNode by calling into its source preprocess.
-	 *
-	 * RESOLVE: We should probably push predicates down as well?
-	 *
-	 * @param numTables			The number of tables in the DML Statement	 
-	 * @param fromList			The from list, if any
-	 * @param subqueryList		The subquery list, if any
-	 * @param predicateList		The predicate list, if any
-	 *
-	 * @return ResultSetNode at top of preprocessed tree.
-	 *
-	 * @exception StandardException		Thrown on error
-	 */
-	public ResultSetNode preprocess(int numTables,
-		FromList fromList,
-		SubqueryList subqueryList,
-		PredicateList predicateList)
-		throws StandardException {
-
-		/* Set up the referenced table map */
-		this.numTables = numTables;
-		referencedTableMap = new JBitSet(numTables);
-		int flSize = fromList.size();
-		for (int index = 0; index < flSize; index++)
-		{
-			referencedTableMap.or(((FromTable) fromList.elementAt(index)).
-													getReferencedTableMap());
-		}			
-		
-		return this;
-	}
-
-	/**
-	 * Bind this node. 
-	 *
-	 * @param fromList		The FROM list for the query this
-	 *						expression is in, for binding columns.
-	 * @param subqueryList		The subquery list being built as we find SubqueryNodes
-	 * @param aggregateVector	The aggregate vector being built as we find AggregateNodes
-	 *
-	 * @return	The new top of the expression tree.
-	 *
-	 * @exception StandardException		Thrown on error. Although this class
-	 * doesn't throw this exception, it's subclasses do and hence this method
-	 * signature here needs to have throws StandardException 
-	 */
-	public WindowNode bind(
-			FromList fromList, 
-			SubqueryList subqueryList,
-			Vector	aggregateVector)
-		throws StandardException
-	{
-		/*		 
-		 * This is simply a stub returning the new top of the querytree, since 
-		 * there is nothing to as long as we only support ROW_NUMBER(). It does 
-		 * not need any binding to source result columns.		 
-		 */
-		return this;
-	}
-	
-	/**
-	 * Generation of an WindowNode creates an WindowResultSet
-	 *
-	 * @param acb	The ActivationClassBuilder for the class being built
-	 * @param mb	the method  for the method to be built
-	 *
-	 * @exception StandardException		Thrown on error
-	 */
-	public void generate(ActivationClassBuilder acb,	
-		MethodBuilder mb)
-		throws StandardException {
-		int rclSize = resultColumns.size();
-		FormatableBitSet referencedCols = new FormatableBitSet(rclSize);
-		int erdNumber = -1;
-		int numSet = 0;
-
-		/*
-		 ** Get the next ResultSet #, so that we can number this ResultSetNode,
-		 ** its ResultColumnList and ResultSet.
-		 */
-		assignResultSetNumber();
-
-		// Get the CostEstimate info for the underlying scan
-		costEstimate = getFinalCostEstimate();
-
-		acb.pushGetResultSetFactoryExpression(mb);
-
-		/* 
-		 * Build a FormatableBitSet for columns to copy from source. If there are 
-		 * multiple window function coulmns, they will be added right to left.		 
-		 */
-		int skip = 0;
-		for (int index = rclSize-1; index >= 0; index--) {		
-			ResultColumn rc = (ResultColumn) resultColumns.elementAt(index);
-			if ( rc.isWindowFunction() && skip < this.windowFunctionLevel) {
-				// Skip this
-				skip++;
-				continue;
-			}
-			// if not
-			referencedCols.set(index);
-			numSet++;
-		}
-
-		erdNumber = acb.addItem(referencedCols);
-
-		acb.pushThisAsActivation(mb); // arg 1
-
-		childResult.generate(acb, mb);	  // arg 2
-		mb.upCast(ClassName.NoPutResultSet);
-
-		/* row allocator */
-		resultColumns.generateHolder(acb, mb); // arg 3		
-
-		mb.push(resultSetNumber); //arg 4
-		mb.push(windowFunctionLevel); //arg 5
-
-		/* Pass in the erdNumber for the referenced column FormatableBitSet */
-		mb.push(erdNumber); // arg 6		
-
-		/* There is no restriction at this level, we just want to pass null. */
-		mb.pushNull(ClassName.GeneratedMethod); // arg 7
-		
-		mb.push(costEstimate.rowCount()); //arg 8
-		mb.push(costEstimate.getEstimatedCost()); // arg 9
-
-		mb.callMethod(VMOpcode.INVOKEINTERFACE, (String) null,			
-			"getWindowResultSet", ClassName.NoPutResultSet, 9);
-
-		/*
-		 ** Remember if this result set is the cursor target table, so we
-		 ** can know which table to use when doing positioned update and delete.
-		 */
-		if (cursorTargetTable) {
-			acb.rememberCursorTarget(mb);
-		}
-	}
-
-	/**
-	 * Consider materialization for this ResultSet tree if it is valid and cost 
-	 * effective. It is not valid if incorrect results would be returned.
-	 *
-	 * @return Top of the new/same ResultSet tree.
-	 *
-	 * @exception StandardException		Thrown on error
-	 */
-	public ResultSetNode considerMaterialization(JBitSet outerTables)
-		throws StandardException {
-		/* 
-		 * For queries involving window functions like ROW_NUMBER() we should
-		 * most likely materialize the ResultSet.
-		 * 
-		 * Return a reference to ourselves.
-		 */
-		return this;
-	}
-
-	/**
-	 * Return whether or not to materialize this ResultSet tree.
-	 *
-	 * @return Whether or not to materialize this ResultSet tree.
-	 *			would return valid results.
-	 *
-	 * @exception StandardException		Thrown on error
-	 */
-	public boolean performMaterialization(JBitSet outerTables)
-		throws StandardException {
-		/* 
-		 * Queries involving window functions will most likely benefit from 
-		 * materializing the ResultSet. It does not make sense for ROW_NUMBER 
-		 * though, so it should probably depend on what function is evaluated.
-		 */
-		return false;		
-	}
-	
-	/**
-	 * Get the windowFunctionLevel of this WindowNode in case there are 
-	 * multiple window functions in a RCL.
-	 *
-	 * @return the windowFunctionLevel for this window function column 
-	 */
-	public int getWindowFunctionLevel()
-	{
-		return this.windowFunctionLevel;
-	}
-	
-	/**
-	 * Set the windowFunctionLevel of this WindowNode in case there are 
-	 * multiple window functions in a RCL.
-	 *
-	 * @param level The window function level of this window function column 
-	 */	
-	public void setWindowFunctionLevel(int level)
-	{
-		this.windowFunctionLevel = level;
-	}
-}
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/GenericResultSetFactory.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/GenericResultSetFactory.java
index 5d6bc420..bd44817d 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/GenericResultSetFactory.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/GenericResultSetFactory.java
@@ -826,34 +826,6 @@ public NoPutResultSet getIndexRowToBaseRowResultSet(
 								optimizerEstimatedCost);
 	}
 
-	/**
-		@see ResultSetFactory#getWindowResultSet
-		@exception StandardException	Thrown on error
-	 */
-	public NoPutResultSet getWindowResultSet(
-								Activation activation,
-								NoPutResultSet source,
-								GeneratedMethod rowAllocator,								
-								int resultSetNumber,
-								int level,
-								int erdNumber,								
-								GeneratedMethod restriction,
-								double optimizerEstimatedRowCount,
-								double optimizerEstimatedCost)																
-		throws StandardException
-	{
-		return new WindowResultSet(
-								activation,								
-								source,
-								rowAllocator,								
-								resultSetNumber,
-								level,
-								erdNumber,
-								restriction,
-								optimizerEstimatedRowCount,
-								optimizerEstimatedCost);
-	}
-
 	/**
 		@see ResultSetFactory#getNestedLoopJoinResultSet
 		@exception StandardException thrown on error
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/RealResultSetStatisticsFactory.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/RealResultSetStatisticsFactory.java
index c1052e98..f0ee52fc 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/RealResultSetStatisticsFactory.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/RealResultSetStatisticsFactory.java
@@ -69,7 +69,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.impl.sql.execute.UnionResultSet;
 import org.apache.derby.impl.sql.execute.UpdateResultSet;
 import org.apache.derby.impl.sql.execute.VTIResultSet;
-import org.apache.derby.impl.sql.execute.WindowResultSet;
 import org.apache.derby.impl.sql.execute.DependentResultSet;
 
 import org.apache.derby.iapi.sql.execute.RunTimeStatistics;
@@ -105,7 +104,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.impl.sql.execute.rts.RealUnionResultSetStatistics;
 import org.apache.derby.impl.sql.execute.rts.RealUpdateResultSetStatistics;
 import org.apache.derby.impl.sql.execute.rts.RealVTIStatistics;
-import org.apache.derby.impl.sql.execute.rts.RealWindowResultSetStatistics;
 import org.apache.derby.impl.sql.execute.rts.RealRowCountStatistics;
 import org.apache.derby.impl.sql.execute.rts.ResultSetStatistics;
 import org.apache.derby.impl.sql.execute.rts.RunTimeStatisticsImpl;
@@ -821,24 +819,6 @@ else if (rs instanceof IndexRowToBaseRowResultSet)
 																irtbrrs.source)
 											);
 		}
-		else if (rs instanceof WindowResultSet)
-		{
-			WindowResultSet wrs = (WindowResultSet) rs;
-
-			return new RealWindowResultSetStatistics(											
-											wrs.numOpens,
-											wrs.rowsSeen,
-											wrs.rowsFiltered,
-											wrs.constructorTime,
-											wrs.openTime,
-											wrs.nextTime,
-											wrs.closeTime,
-											wrs.resultSetNumber,											
-											wrs.optimizerEstimatedRowCount,
-											wrs.optimizerEstimatedCost,
-											getResultSetStatistics(wrs.source)		
-											);
-		}
 		else if (rs instanceof RowResultSet)
 		{
 			RowResultSet rrs = (RowResultSet) rs;
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/WindowResultSet.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/WindowResultSet.java
index 64811c85..e69de29b 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/WindowResultSet.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/WindowResultSet.java
@@ -1,307 +0,0 @@
-/*
-
-   Derby - Class org.apache.derby.impl.sql.execute.WindowResultSet
-
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to you under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-package org.apache.derby.impl.sql.execute;
-
-import org.apache.derby.iapi.services.sanity.SanityManager;
-import org.apache.derby.iapi.services.loader.GeneratedMethod;
-
-import org.apache.derby.iapi.sql.Activation;
-import org.apache.derby.iapi.sql.execute.ExecRow;
-import org.apache.derby.iapi.sql.execute.NoPutResultSet;
-
-import org.apache.derby.iapi.types.DataValueDescriptor;
-
-import org.apache.derby.iapi.reference.SQLState;
-import org.apache.derby.iapi.error.StandardException;
-import org.apache.derby.iapi.services.io.FormatableBitSet;
-
-/**
- * WindowResultSet
- * 
- * This ResultSet handles a window function ResultSet. 
- * The implementation is based on IndexRowToBaseRowResultSet.
- * 
- * The ResultSet is opened using openCore().  Each row is fetched and any 
- * restrictions evaluated for each row in a do-while loop in getNextRowCore().
- * The ResultSet is closed using closeCore().
- * 
- * The WindowResultSet may have any type ResultSet as its source 
- * ResultSet to accomodate future window function implementation. 
- * Ranking window functions can use an already grouped or ordered 
- * resultset as its source.
- */
-class WindowResultSet extends NoPutResultSetImpl 
-{
-	private GeneratedMethod restriction = null;
-	private GeneratedMethod row;
-	public NoPutResultSet source = null;
-	public long restrictionTime;
-
-	private FormatableBitSet referencedColumns;
-	private ExecRow allocatedRow;
-	private int rownumber;
-	private int level;
-	
-	/**
-	 *  Constructor
-	 *
-	 *	@param	activation			The activation
-	 *	@param	resultSetNumber		The resultSetNumber
-	 *  @param	optimizerEstimatedRowCount	The optimizer's estimated number
-	 *										of rows.
-	 *  @param	optimizerEstimatedCost		The optimizer's estimated cost
-	 *  @param  restriction
-	 */
-	WindowResultSet(Activation activation,
-		NoPutResultSet source,
-		GeneratedMethod rowAllocator,
-		int resultSetNumber,
-		int level,
-		int erdNumber,		
-		GeneratedMethod restriction,
-		double optimizerEstimatedRowCount,
-		double optimizerEstimatedCost) {
-		super(activation,
-			resultSetNumber,
-			optimizerEstimatedRowCount,
-			optimizerEstimatedCost);
-
-		if (SanityManager.DEBUG) {
-			SanityManager.ASSERT(activation != null, "activation expected to be non-null");
-			SanityManager.ASSERT(resultSetNumber >= 0, "resultSetNumber expected to be >= 0");
-			SanityManager.ASSERT(level > 0, "level expected to be > 0");			
-		}
-		this.restriction = restriction;
-		this.source = source;
-		this.row = rowAllocator;
-		this.allocatedRow = null;
-		this.rownumber = 0;
-		this.level = level;
-		 
-		if (erdNumber != -1)
-		{
-			this.referencedColumns = (FormatableBitSet)(activation.getPreparedStatement().
-								getSavedObject(erdNumber));
-		}
-		
-		recordConstructorTime();
-	}
-
-	/**
-	 * open this ResultSet.
-	 *
-	 * @exception StandardException thrown if cursor finished.
-	 */
-	public void openCore() throws StandardException {
-		if (SanityManager.DEBUG) {
-			SanityManager.ASSERT(!isOpen,
-				"WindowResultSet already open");
-		}
-
-		beginTime = getCurrentTimeMillis();
-
-		/* Call into the source openCore() */
-		source.openCore();
-
-		isOpen = true;
-		rownumber = 0;
-		numOpens++;
-		openTime += getElapsedMillis(beginTime);
-	}
-
-	/**
-	 * reopen this ResultSet.
-	 *
-	 * @exception StandardException thrown if cursor finished.
-	 */
-	public void reopenCore() throws StandardException {
-		if (SanityManager.DEBUG) {
-			SanityManager.ASSERT(isOpen, "WindowResultSet already open");
-		}
-
-		beginTime = getCurrentTimeMillis();
-
-		/* Reopen the source */
-		source.reopenCore();
-
-		rownumber = 0;
-		numOpens++;
-		openTime += getElapsedMillis(beginTime);
-	}
-
-	/**
-	 * Return the requested values computed from the next row (if any) for which
-	 * the restriction evaluates to true.
-	 * <p>
-	 * restriction and projection parameters are evaluated for each row.
-	 *
-	 * @exception StandardException thrown on failure.
-	 * @exception StandardException ResultSetNotOpen thrown if not yet open.
-	 *
-	 * @return the next row in the result
-	 */
-	public ExecRow getNextRowCore() throws StandardException 
-	{
-		ExecRow sourceRow = null;
-		ExecRow retval = null;
-		boolean restrict = false;
-		DataValueDescriptor restrictBoolean;
-		long beginRT = 0;
-
-		beginTime = getCurrentTimeMillis();
-		if (!isOpen) {
-			throw StandardException.newException(SQLState.LANG_RESULT_SET_NOT_OPEN, "next");
-		}
-
-		/*
-		 * Loop until we get a row from the source that qualifies, or there are 
-		 * no more rows to qualify. For each iteration fetch a row from the 
-		 * source, and evaluate against the restriction if any.
-		 */
-		ExecRow tmpRow = null;
-		
-		do {			
-			sourceRow = source.getNextRowCore();			
-			if (sourceRow != null) {
-				this.rownumber++;
-				tmpRow = getAllocatedRow();
-				populateFromSourceRow(sourceRow, tmpRow);						
-				setCurrentRow(tmpRow);
-
-				/* Evaluate any restrictions */
-				restrictBoolean = (DataValueDescriptor) ((restriction == null) ? 
-									null : restriction.invoke(activation));
-
-				restrictionTime += getElapsedMillis(beginRT);
-
-				// if the result is null, we make it false --
-				// so the row won't be returned.
-				restrict = (restrictBoolean == null) ||
-					((!restrictBoolean.isNull()) &&
-					restrictBoolean.getBoolean());
-
-				if (!restrict) {
-					rowsFiltered++;
-					clearCurrentRow();
-				}
-
-				/* Update the run time statistics */
-				rowsSeen++;
-				retval = currentRow;
-			} else {
-				clearCurrentRow();
-				retval = null;
-			}
-		} while ((sourceRow != null) && (!restrict));
-
-		nextTime += getElapsedMillis(beginTime);
-		return retval;
-	}
-
-	/**
-	 * If the result set has been opened, close the open scan.
-	 *
-	 * @exception StandardException thrown on error
-	 */
-	public void close() throws StandardException {
-		beginTime = getCurrentTimeMillis();
-		if (isOpen) {
-			clearCurrentRow();
-			
-			/* 
-			 * Make sure to close the source 
-			 */
-			source.close();
-			super.close();
-		} else if (SanityManager.DEBUG) {
-			SanityManager.DEBUG("CloseRepeatInfo", "Close of WindowResultSet repeated");
-		}
-
-		closeTime += getElapsedMillis(beginTime);
-	}
-
-	/**
-	 * @exception StandardException thrown on failure to open
-	 */
-	public void populateFromSourceRow(ExecRow srcrow, ExecRow destrow)
-		throws StandardException 
-	{		
-		int srcindex = 1;
-		int levelCnt = 1;
-		try {			
-			DataValueDescriptor[] columns = destrow.getRowArray();
-			for (int index = 0; index < columns.length; index++) {				
-				if (referencedColumns != null && (!referencedColumns.get(index))) {
-					/* 
-					 * TODO: For now any unreferenced columm is a RowNumberColumn 
-					 */
-					if (levelCnt > this.level){
-						/* Value will be added at higher level WindowNode */					
-						continue; 
-					}
-					columns[index].setValue((long)this.rownumber);
-					levelCnt++;
-				} else {								
-					destrow.setColumn(index+1, srcrow.getColumn(srcindex));
-					srcindex++;
-				}				
-			}
-		} catch (StandardException se) {
-			throw se;
-		} catch (Throwable t) {
-			throw StandardException.unexpectedUserException(t);
-		}
-	}
-
-	/**
-	 * Return the total amount of time spent in this ResultSet
-	 *
-	 * @param type	CURRENT_RESULTSET_ONLY - time spent only in this ResultSet
-	 *			ENTIRE_RESULTSET_TREE  - time spent in this ResultSet and below.
-	 *
-	 * @return long	The total amount of time spent (in milliseconds).
-	 */
-	public long getTimeSpent(int type) {
-		long totTime = constructorTime + openTime + nextTime + closeTime;
-		if (type == NoPutResultSet.CURRENT_RESULTSET_ONLY) {
-			return totTime - source.getTimeSpent(ENTIRE_RESULTSET_TREE);
-		} else {
-			return totTime;
-		}
-	}
-
-	/**
-	 * Cache the ExecRow for this result set.
-	 *
-	 * @return The cached ExecRow for this ResultSet
-	 *
-	 * @exception StandardException thrown on failure.
-	 */
-	private ExecRow getAllocatedRow()
-		throws StandardException {
-		if (allocatedRow == null) {
-			allocatedRow = (ExecRow) row.invoke(activation);
-		}
-
-		return allocatedRow;
-	}
-}
-        
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/rts/RealWindowResultSetStatistics.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/rts/RealWindowResultSetStatistics.java
index 0add8bb5..e69de29b 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/rts/RealWindowResultSetStatistics.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/rts/RealWindowResultSetStatistics.java
@@ -1,175 +0,0 @@
-/*
-
-   Derby - Class org.apache.derby.impl.sql.execute.rts.RealWindowResultSetStatistics
-
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to you under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-
-package org.apache.derby.impl.sql.execute.rts;
-
-import org.apache.derby.iapi.services.i18n.MessageService;
-import org.apache.derby.impl.sql.execute.xplain.XPLAINUtil;
-import org.apache.derby.iapi.sql.execute.xplain.XPLAINVisitor;
-import org.apache.derby.iapi.reference.SQLState;
-
-/**
- * ResultSetStatistics implemenation for WindowResultSet.
- */
-public class RealWindowResultSetStatistics 
-	extends RealNoPutResultSetStatistics
-{	
-	
-	/* Leave these fields public for object inspectors */	
-	public ResultSetStatistics childResultSetStatistics;
-
-	// CONSTRUCTORS
-
-	/**
-	 * 
-	 *
-	 */
-    public	RealWindowResultSetStatistics(								
-								int numOpens,
-								int rowsSeen,
-								int rowsFiltered,
-								long constructorTime,
-								long openTime,
-								long nextTime,
-								long closeTime,
-								int resultSetNumber,								
-								double optimizerEstimatedRowCount,
-								double optimizerEstimatedCost,
-								ResultSetStatistics childResultSetStatistics
-								)
-	{
-		super(
-			numOpens,
-			rowsSeen,
-			rowsFiltered,
-			constructorTime,
-			openTime,
-			nextTime,
-			closeTime,
-			resultSetNumber,
-			optimizerEstimatedRowCount,
-			optimizerEstimatedCost
-			);				
-		this.childResultSetStatistics = childResultSetStatistics;
-		
-	}
-
-	// ResultSetStatistics interface
-
-	/**
-	 * Return the statement execution plan as a String.
-	 *
-	 * @param depth	Indentation level.
-	 *
-	 * @return String	The statement execution plan as a String.
-	 */
-	public String getStatementExecutionPlanText(int depth)
-	{
-		initFormatInfo(depth);
-
-		return
-			indent + MessageService.getTextMessage(
-							SQLState.RTS_NUM_OPENS) +
-							" = " + numOpens + "\n" +
-			indent + MessageService.getTextMessage(
-							SQLState.RTS_ROWS_SEEN) +
-							" = " + rowsSeen + "\n" +
-			dumpTimeStats(indent, subIndent) + "\n" +
-			dumpEstimatedCosts(subIndent) + "\n" +
-			childResultSetStatistics.getStatementExecutionPlanText(sourceDepth) + "\n";
-	}
-
-	/**
-	 * Return information on the scan nodes from the statement execution 
-	 * plan as a String.
-	 *
-	 * @param depth	Indentation level.
-	 * @param tableName if not NULL then print information for this table only
-	 *
-	 * @return String	The information on the scan nodes from the 
-	 *					statement execution plan as a String.
-	 */
-	public String getScanStatisticsText(String tableName, int depth)
-	{
-		return getStatementExecutionPlanText(depth);		
-	}
-
-
-	// Class implementation
-	
-	public String toString()
-	{
-		return getStatementExecutionPlanText(0);
-	}
-
-	public java.util.Vector getChildren()
-	{
-		java.util.Vector children = new java.util.Vector();
-		children.addElement(childResultSetStatistics);
-		return children;
-	}
-
-	/**
-	 * If this node is on a database item (like a table or an index), then provide a
-	 * string that describes the on item.
-	 *
-	 */
-	public String getNodeOn(){
-		return MessageService.getTextMessage(
-									SQLState.RTS_FOR_TAB_NAME,
-									"<WINDOW FUNCTION>");
-	}
-	
-	/**
-	 * Format for display, a name for this node.
-	 *
-	 */
-	public String getNodeName(){
-		return MessageService.getTextMessage(SQLState.RTS_IRTBR);
-	}
-
-	/**
-	 * Return the ResultSetStatistics for the child of this node.
-	 *
-	 * @return The ResultSetStatistics for the child of this node.
-	 */
-	ResultSetStatistics getChildResultSetStatistics()
-	{
-		return childResultSetStatistics;
-	}
-
-  // -----------------------------------------------------
-  // XPLAINable Implementation
-  // -----------------------------------------------------
-  
-    public void accept(XPLAINVisitor visitor) {
-        // I have only one child
-        visitor.setNumberOfChildren(1);
-        
-        // pre-order, depth-first traversal
-        // me first
-        visitor.visit(this);
-        // then my child
-        childResultSetStatistics.accept(visitor);
-	}
-
-    public String getRSXplainType() { return XPLAINUtil.OP_WINDOW; }
-}
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java
index b58d1951..bcce7693 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java
@@ -139,7 +139,6 @@ public static Test suite() {
         suite.addTest(NestedWhereSubqueryTest.suite());
         suite.addTest(ConglomerateSharingTest.suite());
         suite.addTest(NullableUniqueConstraintTest.suite());
-        suite.addTest(OLAPTest.suite());
         suite.addTest(UniqueConstraintSetNullTest.suite());
         suite.addTest(ViewsTest.suite());
         suite.addTest(DeadlockModeTest.suite());
