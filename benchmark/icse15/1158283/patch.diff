diff --git a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/ResourceHelper.java b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/ResourceHelper.java
index e69de29b..3463645f 100644
--- a/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/ResourceHelper.java
+++ b/aries/trunk/subsystem/subsystem-core/src/main/java/org/apache/aries/subsystem/core/ResourceHelper.java
@@ -0,0 +1,61 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.aries.subsystem.core;
+
+import java.util.Collection;
+import java.util.List;
+
+import org.osgi.framework.Version;
+import org.osgi.framework.wiring.Capability;
+import org.osgi.framework.wiring.Requirement;
+import org.osgi.framework.wiring.Resource;
+import org.osgi.framework.wiring.ResourceConstants;
+import org.osgi.service.repository.Repository;
+
+public class ResourceHelper {
+	public static String getContentAttribute(Resource resource) {
+		// TODO Add to constants.
+		return (String)getContentAttribute(resource, "osgi.content");
+	}
+	
+	public static Object getContentAttribute(Resource resource, String name) {
+		// TODO Add to constants.
+		List<Capability> capabilities = resource.getCapabilities("osgi.content");
+		Capability capability = capabilities.get(0);
+		return capability.getAttributes().get(name);
+	}
+	
+	public static Object getIdentityAttribute(Resource resource, String name) {
+		List<Capability> capabilities = resource.getCapabilities(ResourceConstants.IDENTITY_NAMESPACE);
+		Capability capability = capabilities.get(0);
+		return capability.getAttributes().get(name);
+	}
+	
+	public static Resource getResource(Requirement requirement, Repository repository) {
+		Collection<Capability> capabilities = repository.findProviders(requirement);
+		return capabilities == null ? null : capabilities.size() == 0 ? null : capabilities.iterator().next().getResource();
+	}
+	
+	public static String getSymbolicNameAttribute(Resource resource) {
+		return (String)getIdentityAttribute(resource, ResourceConstants.IDENTITY_NAMESPACE);
+	}
+	
+	public static String getTypeAttribute(Resource resource) {
+		return (String)getIdentityAttribute(resource, ResourceConstants.IDENTITY_TYPE_ATTRIBUTE);
+	}
+	
+	public static Version getVersionAttribute(Resource resource) {
+		return (Version)getIdentityAttribute(resource, ResourceConstants.IDENTITY_VERSION_ATTRIBUTE);
+	}
+}
diff --git a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/BundleInfoImpl.java b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/BundleInfoImpl.java
index e69de29b..6e9aa301 100644
--- a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/BundleInfoImpl.java
+++ b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/BundleInfoImpl.java
@@ -0,0 +1,141 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.subsystem.itests.util;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.jar.Attributes;
+import java.util.jar.JarFile;
+import java.util.jar.Manifest;
+
+import org.apache.aries.application.Content;
+import org.apache.aries.application.management.BundleInfo;
+import org.apache.aries.util.manifest.ManifestHeaderProcessor;
+import org.osgi.framework.Constants;
+import org.osgi.framework.Version;
+
+public class BundleInfoImpl implements BundleInfo {
+
+    private Map<String, String> attributeMap = new HashMap<String, String>();
+    private String path;
+    private Attributes attributes;
+
+    public BundleInfoImpl(String pathToJar) {
+        Manifest manifest = null;
+        try {
+        	File jarFile = new File(pathToJar);
+            this.path = jarFile.toURI().toURL().toString();
+            JarFile f = new JarFile(new File(pathToJar));
+            manifest = f.getManifest();
+        } catch (IOException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        process(manifest);
+    }
+
+    private void process(Manifest manifest) {
+        if (manifest != null) {
+            this.attributes = manifest.getMainAttributes();
+            Set<Object> set = this.attributes.keySet();
+            for (Object entry : set) {
+                String key = entry.toString();
+                attributeMap.put(key, this.attributes.getValue(key));
+            }
+        }
+    }
+
+    public Map<String, String> getBundleAttributes() {
+        return attributeMap;
+    }
+
+    public Map<String, String> getBundleDirectives() {
+        // TODO Auto-generated method stub
+        return new HashMap<String, String>();
+    }
+
+    public Set<Content> getExportPackage() {
+        String exportPkgs = attributeMap.get(Constants.EXPORT_PACKAGE);
+        List<String> list = ManifestHeaderProcessor.split(exportPkgs, ",");
+        Set<Content> contents = new HashSet<Content>();
+        for (String content : list) {
+            contents.add(new ContentImpl(content));
+        }
+
+        return contents;
+    }
+
+    public Set<Content> getExportService() {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    public Map<String, String> getHeaders() {
+        return attributeMap;
+    }
+
+    public Set<Content> getImportPackage() {
+        String importPkgs = attributeMap.get(Constants.IMPORT_PACKAGE);
+        List<String> list = ManifestHeaderProcessor.split(importPkgs, ",");
+        Set<Content> contents = new HashSet<Content>();
+        for (String content : list) {
+            contents.add(new ContentImpl(content));
+        }
+
+        return contents;
+    }
+
+    public Set<Content> getImportService() {
+        // TODO Auto-generated method stub
+        return null;
+    }
+
+    public String getLocation() {
+        return path;
+    }
+
+    public Set<Content> getRequireBundle() {
+        String requireBundle = attributeMap.get(Constants.REQUIRE_BUNDLE);
+        List<String> list = ManifestHeaderProcessor.split(requireBundle, ",");
+        Set<Content> contents = new HashSet<Content>();
+        for (String content : list) {
+            contents.add(new ContentImpl(content));
+        }
+
+        return contents;
+    }
+
+    public String getSymbolicName() {
+        return attributeMap.get(Constants.BUNDLE_SYMBOLICNAME);
+    }
+
+    public Version getVersion() {
+        return Version.parseVersion(attributeMap.get(Constants.BUNDLE_VERSION));
+    }
+
+	public Attributes getRawAttributes() {
+        return this.attributes;
+	}
+
+}
diff --git a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/ContentImpl.java b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/ContentImpl.java
index e69de29b..1e7b0688 100644
--- a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/ContentImpl.java
+++ b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/ContentImpl.java
@@ -0,0 +1,199 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.subsystem.itests.util;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.aries.application.Content;
+import org.apache.aries.util.VersionRange;
+import org.apache.aries.util.manifest.ManifestHeaderProcessor;
+import org.osgi.framework.Constants;
+import org.osgi.framework.Version;
+
+
+/**
+ * Implementation of Content, copied from org.apache.aries.application.utils folder with 
+ * intention to common this out to a common util folder
+ *
+ */
+public final class ContentImpl implements Content
+{
+  private String contentName;
+  protected Map<String, String> attributes;
+  private Map<String, String> directives;
+  private Map<String, String> nameValueMap;
+  
+  /**
+   * 
+   * @param content  Application-Content, Import-Package content
+   */
+  public ContentImpl(String content) {
+    Map<String, Map<String, String>> appContentsMap = ManifestHeaderProcessor.parseImportString(content);
+    if (appContentsMap.size() != 1) {
+      throw new IllegalArgumentException("Invalid content string " + content);
+    }
+    for (Map.Entry<String, Map<String, String>> entry : appContentsMap.entrySet()) {
+      this.contentName = entry.getKey();
+      this.nameValueMap= entry.getValue();
+      setup();
+      break;
+    }
+  }
+  
+  public ContentImpl (String bundleSymbolicName, Version version) { 
+    this.contentName = bundleSymbolicName;
+    this.nameValueMap = new HashMap<String, String>();
+    nameValueMap.put("version", version.toString());
+    setup();
+  }
+  
+  /**
+   * 
+   * @param contentName  
+   * @param nameValueMap
+   */
+  public ContentImpl(String contentName, Map<String, String> nameValueMap) {
+    this.contentName = contentName;
+    this.nameValueMap= nameValueMap;
+    setup();
+  }
+  
+  public String getContentName() {
+    return this.contentName;
+  }
+  
+  public Map<String, String> getAttributes() {
+    return Collections.unmodifiableMap(this.attributes);
+  }
+  
+  public Map<String, String> getDirectives() {
+    return Collections.unmodifiableMap(this.directives);
+  }
+  
+  public String getAttribute(String key) {
+    String toReturn = this.attributes.get(key);
+    return toReturn;
+  }
+  
+  /**
+   * add key value to the attributes map
+   * @param key
+   * @param value
+   */
+  public void addAttribute(String key, String value) {
+    this.attributes.put(key, value);
+  }
+  
+  public String getDirective(String key) {
+    String toReturn = this.directives.get(key);
+    return toReturn;
+  }
+  
+  public Map<String, String> getNameValueMap() {
+    Map<String, String> nvm = new HashMap<String, String>();
+    for (String key : this.nameValueMap.keySet()) {
+      nvm.put(key, this.nameValueMap.get(key));
+    }
+    return nvm;
+  }
+  
+  /**
+   * add key value to the directives map
+   * @param key
+   * @param value
+   */
+  public void addDirective(String key, String value) {
+    this.directives.put(key, value);
+  }
+  
+  public VersionRange getVersion() {
+    VersionRange vi = null;
+    if (this.attributes.get(Constants.VERSION_ATTRIBUTE) != null 
+        && this.attributes.get(Constants.VERSION_ATTRIBUTE).length() > 0) {
+      vi = ManifestHeaderProcessor.parseVersionRange(this.attributes.get(Constants.VERSION_ATTRIBUTE));
+    } else {
+      // what if version is not specified?  let's interpret it as 0.0.0 
+      vi = ManifestHeaderProcessor.parseVersionRange("0.0.0");
+    }
+    return vi;
+  }
+  
+  @Override
+  public String toString()
+  {
+    return this.contentName + ";" + this.nameValueMap.toString();
+  }
+  
+  @Override
+  public boolean equals(Object other)
+  {
+    if (other == this) return true;
+    if (other == null) return false;
+    
+    if (other instanceof ContentImpl) {
+      ContentImpl otherContent = (ContentImpl)other;
+      
+      Map<String,String> attributesWithoutVersion = attributes;
+      
+      if (attributes.containsKey("version")) {
+        attributesWithoutVersion = new HashMap<String, String>(attributes);
+        attributesWithoutVersion.remove("version");
+      }
+      
+      Map<String, String> otherAttributesWithoutVersion = otherContent.attributes;
+      
+      if (otherContent.attributes.containsKey("version")) {
+        otherAttributesWithoutVersion = new HashMap<String, String>(otherContent.attributes);
+        otherAttributesWithoutVersion.remove("version");
+      }
+      
+      return contentName.equals(otherContent.contentName) && 
+             attributesWithoutVersion.equals(otherAttributesWithoutVersion) &&
+             directives.equals(otherContent.directives) &&
+             getVersion().equals(otherContent.getVersion());
+    }
+    
+    return false;
+  }
+  
+  @Override
+  public int hashCode()
+  {
+    return contentName.hashCode();
+  }
+  
+  /**
+   * set up directives and attributes
+   */
+  protected void setup() {
+    this.attributes = new HashMap<String, String>();
+    this.directives = new HashMap<String, String>();
+    
+    for (String key : this.nameValueMap.keySet()) {
+      if (key.endsWith(":")) {
+        this.directives.put(key.substring(0, key.length() - 1), this.nameValueMap.get(key));
+      } else {
+        this.attributes.put(key, this.nameValueMap.get(key));
+      }
+    }
+  }
+}
+
diff --git a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/Manve2Repository.java b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/Manve2Repository.java
index e69de29b..b91c48ac 100644
--- a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/Manve2Repository.java
+++ b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/Manve2Repository.java
@@ -0,0 +1,126 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIESOR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.aries.subsystem.itests.util;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.SortedSet;
+import java.util.TreeSet;
+
+public class Manve2Repository {
+
+    private File rootFile;
+    public Manve2Repository(File rootFile) {
+        this.rootFile = rootFile;
+    }
+    // list jar files of the repository
+    public SortedSet<String> listFiles() {
+        SortedSet<String> artifacts = new TreeSet<String>();
+        File[] groupIds = rootFile.listFiles();
+        for (int i = 0; i < groupIds.length; i++) {
+            File groupId = groupIds[i];
+            if (groupId.canRead() && groupId.isDirectory()) {
+                File[] versionDirs = groupId.listFiles();
+                for (int j = 0; j < versionDirs.length; j++) {
+                    File versionDir = versionDirs[j];
+                    if (versionDir.canRead() && versionDir.isDirectory()) {
+                        artifacts.addAll(getArtifacts(null, versionDir, null, "jar", null));
+                    }
+                }
+            }
+        }
+        
+        return artifacts;
+    }
+    
+    // reuse code from apache geronimo with slight modification
+    private List<String> getArtifacts(String groupId, File versionDir, String artifactMatch, String typeMatch, String versionMatch) {
+        // org/apache/xbean/xbean-classpath/2.2-SNAPSHOT/xbean-classpath-2.2-SNAPSHOT.jar
+        List<String> artifacts = new ArrayList<String>();
+        String artifactId = versionDir.getParentFile().getName();
+
+        File[] files = versionDir.listFiles();
+        for (int i = 0; i < files.length; i++) {
+            File file = files[i];
+            if (file.canRead()) {
+                if (file.isDirectory()) {
+                    File test = new File(file, "META-INF");
+                    if(test.exists() && test.isDirectory() && test.canRead() && groupId != null) {
+                        String version = versionDir.getName();
+                        String fileHeader = artifactId + "-" + version + ".";
+
+                        String fileName = file.getName();
+                        if (fileName.startsWith(fileHeader)) {
+                            // type is everything after the file header
+                            String type = fileName.substring(fileHeader.length());
+
+                            if (!type.endsWith(".sha1") && !type.endsWith(".md5")) {
+                                if(artifactMatch != null && !artifactMatch.equals(artifactId)) {
+                                    continue;
+                                }
+                                if(typeMatch != null && !typeMatch.equals(type)) {
+                                    continue;
+                                }
+                                if(versionMatch != null && !versionMatch.equals(version)) {
+                                    continue;
+                                }
+                                artifacts.add(file.getPath());
+                            }
+                        }
+                    } else { // this is just part of the path to the artifact
+                        String nextGroupId;
+                        if (groupId == null) {
+                            nextGroupId = artifactId;
+                        } else {
+                            nextGroupId = groupId + "." + artifactId;
+                        }
+
+                        artifacts.addAll(getArtifacts(nextGroupId, file, artifactMatch, typeMatch, versionMatch));
+                    }
+                } else if (groupId != null) {
+                    String version = versionDir.getName();
+                    String fileHeader = artifactId + "-" + version + ".";
+
+                    String fileName = file.getName();
+                    if (fileName.startsWith(fileHeader)) {
+                        // type is everything after the file header
+                        String type = fileName.substring(fileHeader.length());
+
+                        if (!type.endsWith(".sha1") && !type.endsWith(".md5")) {
+                            if(artifactMatch != null && !artifactMatch.equals(artifactId)) {
+                                continue;
+                            }
+                            if(typeMatch != null && !typeMatch.equals(type)) {
+                                continue;
+                            }
+                            if(versionMatch != null && !versionMatch.equals(version)) {
+                                continue;
+                            }
+                            artifacts.add(file.getPath());
+                        }
+                    }
+                }
+            }
+        }
+        return artifacts;
+    }
+    
+}
diff --git a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/RepositoryDescriptorGenerator.java b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/RepositoryDescriptorGenerator.java
index e69de29b..538a237c 100644
--- a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/RepositoryDescriptorGenerator.java
+++ b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/RepositoryDescriptorGenerator.java
@@ -0,0 +1,196 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.aries.subsystem.itests.util;
+
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+
+import org.apache.aries.application.Content;
+import org.apache.aries.application.management.BundleInfo;
+import org.apache.aries.subsystem.core.ResourceHelper;
+import org.apache.aries.util.manifest.ManifestHeaderProcessor;
+import org.apache.felix.bundlerepository.Resource;
+import org.osgi.framework.Constants;
+import org.osgi.framework.wiring.BundleRevision;
+import org.osgi.framework.wiring.Requirement;
+import org.w3c.dom.Document;
+import org.w3c.dom.Element;
+
+// copy from application obr with modification, intend to put this in common util folder when trunk becomes stable
+public final class RepositoryDescriptorGenerator
+{
+  public static Document generateRepositoryDescriptor(String name, Set<BundleInfo> bundles) throws ParserConfigurationException
+  {
+    Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
+    Element root = doc.createElement("repository");
+    
+    root.setAttribute("name", name);
+    doc.appendChild(root);
+    
+    for (BundleInfo info : bundles) {
+      Element resource = doc.createElement("resource");
+      resource.setAttribute(Resource.VERSION, info.getVersion().toString());
+      resource.setAttribute("uri", info.getLocation());
+      resource.setAttribute(Resource.SYMBOLIC_NAME, info.getSymbolicName());
+      resource.setAttribute(Resource.PRESENTATION_NAME, info.getHeaders().get(Constants.BUNDLE_NAME));
+      resource.setAttribute(Resource.ID, info.getSymbolicName() + "/" + info.getVersion());
+      root.appendChild(resource);
+      
+      addBundleCapability(doc, resource, info);
+      
+      for (Content p : info.getExportPackage()) {
+        addPackageCapability(doc, resource, info, p);
+      }
+      
+      for (Content p : info.getImportPackage()) {
+        addPackageRequirement(doc, resource, info, p);
+      }
+      
+      for (Content p : info.getRequireBundle()) {
+        addBundleRequirement(doc, resource, info, p);
+      }
+      
+    }
+    
+    return doc;
+  }
+  
+  public static Document generateRepositoryDescriptor(String name, Collection<org.osgi.framework.wiring.Resource> resources) throws ParserConfigurationException {
+	  Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
+	  Element rootElement = document.createElement("repository");
+	  rootElement.setAttribute("name", name);
+	  document.appendChild(rootElement);
+	  for (org.osgi.framework.wiring.Resource resource : resources) {
+		  Element element = document.createElement("resource");
+		  String version = String.valueOf(ResourceHelper.getVersionAttribute(resource));
+	      element.setAttribute(Resource.VERSION, version);
+	      element.setAttribute("uri", ResourceHelper.getContentAttribute(resource));
+	      String symbolicName = ResourceHelper.getSymbolicNameAttribute(resource);
+	      element.setAttribute(Resource.SYMBOLIC_NAME, symbolicName);
+	      element.setAttribute(Resource.PRESENTATION_NAME, symbolicName);
+	      element.setAttribute(Resource.ID, symbolicName + "/" + version);
+	      rootElement.appendChild(element);
+	      addRequirements(document, element, resource);
+	  }
+	  return document;
+  }
+  
+  private static void addRequirements(Document document, Element rootElement, org.osgi.framework.wiring.Resource resource) {
+	  for (Requirement requirement : resource.getRequirements(null))
+		  addRequirement(document, rootElement, requirement);
+  }
+  
+  private static void addRequirement(Document document, Element rootElement, Requirement requirement) {
+	  Element element = document.createElement("require");
+	  if (requirement.getNamespace().equals(BundleRevision.PACKAGE_NAMESPACE)) {
+		  addPackageRequirement(element, requirement);
+	  }
+	  else {
+		  throw new IllegalArgumentException("Unsupported requirement namespace: " + requirement.getNamespace());
+	  }
+	  rootElement.appendChild(element);
+  }
+  
+  private static void addPackageRequirement(Element element, Requirement requirement) {
+	  element.setAttribute("name", "package");
+	  element.setAttribute("filter", requirement.getDirectives().get(Constants.FILTER_DIRECTIVE).replaceAll(BundleRevision.PACKAGE_NAMESPACE, "package"));
+  }
+
+  private static void addBundleRequirement(Document doc, Element resource, BundleInfo info, Content p)
+  {
+    Element requirement = doc.createElement("require");
+    requirement.setAttribute("name", "bundle");
+    
+    requirement.setAttribute("extend", "false");
+    requirement.setAttribute("multiple", "false");
+    requirement.setAttribute("optional", "false");
+    
+    requirement.setAttribute("filter", ManifestHeaderProcessor.generateFilter("bundle", p.getContentName(), p.getAttributes()));
+    
+    resource.appendChild(requirement);
+  }
+
+  private static void addPackageRequirement(Document doc, Element resource, BundleInfo info, Content p)
+  {
+    Element requirement = doc.createElement("require");
+    requirement.setAttribute("name", "package");
+    
+    requirement.setAttribute("extend", "false");
+    requirement.setAttribute("multiple", "false");
+    
+    String optional = p.getDirective("optional");
+    if (optional == null) optional = "false";
+    
+    requirement.setAttribute("optional", optional);
+    
+    requirement.setAttribute("filter", ManifestHeaderProcessor.generateFilter("package", p.getContentName(), p.getAttributes()));
+    
+    resource.appendChild(requirement);
+  }
+
+  private static void addPackageCapability(Document doc, Element resource, BundleInfo info, Content p)
+  {
+    Element capability = doc.createElement("capability");
+    capability.setAttribute("name", "package");
+    resource.appendChild(capability);
+    
+    addProperty(doc, capability, "package", p.getContentName(), null);
+    addProperty(doc, capability, Constants.VERSION_ATTRIBUTE, p.getVersion().toString(), "version");
+    addProperty(doc, capability, Constants.BUNDLE_SYMBOLICNAME_ATTRIBUTE, info.getSymbolicName(), null);
+    addProperty(doc, capability, Constants.BUNDLE_VERSION_ATTRIBUTE, info.getVersion().toString(), "version");
+    
+    for (Map.Entry<String, String> entry : p.getAttributes().entrySet()) {
+      if (!!!Constants.VERSION_ATTRIBUTE.equals(entry.getKey())) {
+        addProperty(doc, capability, entry.getKey(), entry.getValue(), null);
+      }
+    }
+    
+    String mandatory = p.getDirective(Constants.MANDATORY_DIRECTIVE);
+    if (mandatory == null) mandatory = "";
+    addProperty(doc, capability, Constants.MANDATORY_DIRECTIVE, mandatory, "set");
+  }
+
+  private static void addBundleCapability(Document doc, Element resource, BundleInfo info)
+  {
+    Element capability = doc.createElement("capability");
+    capability.setAttribute("name", "bundle");
+    resource.appendChild(capability);
+    
+    addProperty(doc, capability, Resource.SYMBOLIC_NAME, info.getSymbolicName(), null);
+    addProperty(doc, capability, Constants.VERSION_ATTRIBUTE, info.getVersion().toString(), "version");
+    addProperty(doc, capability, Resource.PRESENTATION_NAME, info.getHeaders().get(Constants.BUNDLE_NAME), null);
+    addProperty(doc, capability, Constants.BUNDLE_MANIFESTVERSION, "2", "version");
+    addProperty(doc, capability, Constants.FRAGMENT_ATTACHMENT_DIRECTIVE, info.getBundleDirectives().get(Constants.FRAGMENT_ATTACHMENT_DIRECTIVE), null);
+    addProperty(doc, capability, Constants.SINGLETON_DIRECTIVE, info.getBundleDirectives().get(Constants.SINGLETON_DIRECTIVE), null);
+  }
+
+  private static void addProperty(Document doc, Element capability, String name,
+      String value, String type)
+  {
+    Element p = doc.createElement("p");
+    p.setAttribute("n", name);
+    p.setAttribute("v", value);
+    if (type != null) p.setAttribute("t", type);
+    capability.appendChild(p);
+  }
+}
diff --git a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/RepositoryGenerator.java b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/RepositoryGenerator.java
index e69de29b..442b72f7 100644
--- a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/RepositoryGenerator.java
+++ b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/RepositoryGenerator.java
@@ -0,0 +1,362 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.aries.subsystem.itests.util;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.SortedSet;
+
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.dom.DOMSource;
+import javax.xml.transform.stream.StreamResult;
+
+import org.apache.aries.application.Content;
+import org.apache.aries.application.management.BundleInfo;
+import org.apache.aries.subsystem.core.ResourceHelper;
+import org.apache.aries.subsystem.core.obr.felix.FelixResourceAdapter;
+import org.apache.aries.subsystem.core.obr.felix.OsgiResourceAdapter;
+import org.apache.felix.bundlerepository.Capability;
+import org.apache.felix.bundlerepository.Property;
+import org.apache.felix.bundlerepository.Reason;
+import org.apache.felix.bundlerepository.Repository;
+import org.apache.felix.bundlerepository.RepositoryAdmin;
+import org.apache.felix.bundlerepository.Requirement;
+import org.apache.felix.bundlerepository.Resolver;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.ServiceReference;
+import org.osgi.framework.Version;
+import org.osgi.framework.wiring.Resource;
+import org.osgi.service.subsystem.SubsystemConstants;
+import org.osgi.service.subsystem.SubsystemException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.w3c.dom.Document;
+
+public class RepositoryGenerator {
+    private static final Logger LOGGER = LoggerFactory
+            .getLogger(RepositoryGenerator.class);
+
+    final private BundleContext context;
+    private RepositoryAdmin repositoryAdmin;
+    private static boolean generated = false;
+    private String obrPath;
+
+    public RepositoryGenerator(BundleContext context) {
+        this.context = context;
+    }
+
+    public RepositoryGenerator(BundleContext context, String obrPath) {
+        this.context = context;
+        this.obrPath = obrPath;
+    }
+    
+    public  void generateOBR() {
+        if (generated) {
+            return;
+        }
+        synchronized(this) {
+            if (obrPath == null) {
+                // set to a default obr file which is local m2 repo
+                String file = System.getProperty("user.home") + "/.m2/repository/";
+                if (new File(file).exists()) {
+                    obrPath = file;
+                }
+    
+            }
+            
+            // if repository.xml already exists, no need to generate it
+            if (new File(obrPath + "repository.xml").exists()) {
+                registerOBR();
+                generated = true;
+                return;
+            }
+    
+            File rootFile = new File(obrPath);
+            if (!rootFile.exists() || !rootFile.isDirectory()) {
+                throw new IllegalArgumentException("obr path " + obrPath
+                        + " is not valid");
+            }
+    
+            Manve2Repository repo = new Manve2Repository(rootFile);
+    
+            SortedSet<String> ss = repo.listFiles();
+            Set<BundleInfo> infos = new HashSet<BundleInfo>();
+    
+            for (String s : ss) {
+                BundleInfo info = new BundleInfoImpl(s);
+                infos.add(info);
+            }
+    
+            Document doc;
+            try {
+                doc = RepositoryDescriptorGenerator.generateRepositoryDescriptor(
+                        "Subsystem Repository description", infos);
+                FileOutputStream fout = new FileOutputStream(obrPath
+                        + "repository.xml");
+    
+                TransformerFactory.newInstance().newTransformer().transform(
+                        new DOMSource(doc), new StreamResult(fout));
+    
+                fout.close();
+    
+                TransformerFactory.newInstance().newTransformer().transform(
+                        new DOMSource(doc), new StreamResult(System.out));
+            } catch (Exception e) {
+                LOGGER.error("Exception occurred when generate obr", e);
+                e.printStackTrace();
+            }
+    
+            registerOBR();
+            
+            generated = true;
+
+        }
+
+    }
+
+    private void registerOBR() {
+        // set repositoryAdmin
+        ServiceReference ref = context
+                .getServiceReference(RepositoryAdmin.class.getName());
+        
+        if (ref != null) {
+            this.repositoryAdmin = (RepositoryAdmin) context.getService(ref);
+    
+            try {
+                this.repositoryAdmin.addRepository(new File(obrPath
+                        + "repository.xml").toURI().toURL());
+            } catch (Exception e) {
+                LOGGER.warn("Exception occurred when register obr", e);
+                e.printStackTrace();
+            }
+    
+            this.context.ungetService(ref);
+        } else {
+            LOGGER.error("Unable to register OBR as RepositoryAdmin service is not available");
+        }
+
+    }
+
+    /**
+     * the format of resource is like bundlesymbolicname;version=1.0.0, for example com.ibm.ws.eba.example.blog.api;version=1.0.0,
+     */
+    public Resource find(String resource) throws SubsystemException {
+        generateOBR();
+        
+        Content content = new ContentImpl(resource);
+        
+        String symbolicName = content.getContentName();
+        // this version could possibly be a range
+        String version = content.getVersion().toString();
+        StringBuilder filterString = new StringBuilder();
+        filterString.append("(&(name" + "=" + symbolicName + "))");
+        filterString.append("(version" + "=" + version + "))");
+
+        //org.apache.felix.bundlerepository.Resource[] res = this.repositoryAdmin.discoverResources(filterString.toString());
+        Repository[] repos = this.repositoryAdmin.listRepositories();
+        org.apache.felix.bundlerepository.Resource res = null;
+        for (Repository repo : repos) {
+            org.apache.felix.bundlerepository.Resource[] resources = repo.getResources();
+            for (int i = 0; i < resources.length; i++) {
+                if (resources[i].getSymbolicName().equals(symbolicName)) {
+                    if (resources[i].getVersion().compareTo(new Version(version)) == 0) {
+                        res = resources[i];
+                        break;
+                    }
+                }
+            }
+        }
+        if (res == null) {
+//            throw new SubsystemException("unable to find the resource " + resource);
+        	return null;
+        }
+        
+        Map props = res.getProperties();
+        
+
+        Object type = props.get(SubsystemConstants.RESOURCE_TYPE_ATTRIBUTE);
+
+        return new FelixResourceAdapter(res);
+    }
+    
+    /**
+     * the format of resource is like bundlesymbolicname;version=1.0.0, for example com.ibm.ws.eba.example.blog.api;version=1.0.0,
+     */
+    private org.apache.felix.bundlerepository.Resource findOBRResource(Resource resource) throws SubsystemException {
+        String symbolicName = ResourceHelper.getSymbolicNameAttribute(resource);
+        // this version could possibly be a range
+        Version version = ResourceHelper.getVersionAttribute(resource);
+
+        //org.apache.felix.bundlerepository.Resource[] res = this.repositoryAdmin.discoverResources(filterString.toString());
+        Repository[] repos = this.repositoryAdmin.listRepositories();
+        org.apache.felix.bundlerepository.Resource res = null;
+        for (Repository repo : repos) {
+            org.apache.felix.bundlerepository.Resource[] resources = repo.getResources();
+            for (int i = 0; i < resources.length; i++) {
+                if (resources[i].getSymbolicName().equals(symbolicName)) {
+                    if (resources[i].getVersion().compareTo(version) == 0) {
+                        res = resources[i];
+                    }
+                }
+            }
+        }
+        return res;
+    }
+
+    /**
+     * convert to the resource from the obr resource
+     */
+    private Resource toResource(org.apache.felix.bundlerepository.Resource resource) throws SubsystemException {
+        if (resource == null) {
+            throw new SubsystemException("unable to find the resource " + resource);
+        }
+        
+        Map props = resource.getProperties();
+        
+
+        Object type = props.get(SubsystemConstants.RESOURCE_TYPE_ATTRIBUTE);
+
+        return new FelixResourceAdapter(resource);
+    }
+    
+    public List<Resource> resolve(List<Resource> subsystemContent,
+            List<Resource> subsystemResources) throws SubsystemException {
+        generateOBR();
+        if (LOGGER.isDebugEnabled()) {
+            LOGGER.debug("Attempt to resolve subsystem content {} subsystem resource {}", subsystemContent.toString(), subsystemResources.toString());
+        }
+        Resolver obrResolver = this.repositoryAdmin.resolver();
+        
+        // add subsystem content to the resolver
+        for (Resource res : subsystemContent) {
+//            org.apache.felix.bundlerepository.Resource obrRes = findOBRResource(res);
+//            obrResolver.add(obrRes);
+            obrResolver.add(new OsgiResourceAdapter(res));
+        }
+        
+        // add subsystem resource to the resolver
+        for (Resource res : subsystemResources) {
+//            org.apache.felix.bundlerepository.Resource obrRes = findOBRResource(res);
+//            obrResolver.add(obrRes);
+        	obrResolver.add(new OsgiResourceAdapter(res));
+        }
+        
+        // Question: do we need to create the repository.xml for the subsystem and add the repo to RepoAdmin?
+        List<Resource> resources = new ArrayList<Resource>();
+        if (obrResolver.resolve()) {
+            for (org.apache.felix.bundlerepository.Resource res : obrResolver.getRequiredResources()) {
+//                resources.add(toResource(res));
+            	resources.add(new FelixResourceAdapter(res));
+            }
+            
+            // Question: should we handle optional resource differently?
+            for (org.apache.felix.bundlerepository.Resource res : obrResolver.getOptionalResources()) {
+//                resources.add(toResource(res));
+            	resources.add(new FelixResourceAdapter(res));
+            }
+        } else {
+            // log the unsatisfied requirement
+            Reason[] reasons = obrResolver.getUnsatisfiedRequirements();
+            StringBuilder builder = new StringBuilder("Failed to resolve subsystem").append(System.getProperty("line.separator"));
+            for (Reason reason : reasons) {
+                LOGGER.warn("Unable to resolve subsystem content {} subsystem resource {} because of unsatisfied requirement {}", 
+                        new Object[] {subsystemContent.toString(), subsystemResources.toString(), reason.getRequirement().getName()});
+                builder
+                	.append("resource = ")
+                	.append(reason.getResource().getSymbolicName())
+                	.append(", requirement = ")
+                	.append(reason.getRequirement().getName())
+                	.append(System.getProperty("line.separator"));
+            }
+            throw new SubsystemException(builder.toString());
+        }
+        return resources;
+    }
+    
+    private org.apache.felix.bundlerepository.Resource convert(final Resource resource) {
+    	return new org.apache.felix.bundlerepository.Resource() {
+			public Capability[] getCapabilities() {
+				Collection<Capability> result = new ArrayList<Capability>(resource.getCapabilities(null).size());
+				for (org.osgi.framework.wiring.Capability capability : resource.getCapabilities(null)) {
+					result.add(new Capability() {
+						public String getName() {
+							// TODO Auto-generated method stub
+							return null;
+						}
+
+						public Property[] getProperties() {
+							// TODO Auto-generated method stub
+							return null;
+						}
+
+						public Map getPropertiesAsMap() {
+							// TODO Auto-generated method stub
+							return null;
+						}
+					});
+				}
+				return null;
+			}
+
+			public String[] getCategories() {
+				return new String[0];
+			}
+
+			public String getId() {
+				return getSymbolicName() + ";version=" + getVersion();
+			}
+
+			public String getPresentationName() {
+				return getSymbolicName();
+			}
+
+			public Map getProperties() {
+				return Collections.EMPTY_MAP;
+			}
+
+			public Requirement[] getRequirements() {
+				// TODO Auto-generated method stub
+				return null;
+			}
+
+			public Long getSize() {
+				return 0L;
+			}
+
+			public String getSymbolicName() {
+				return ResourceHelper.getSymbolicNameAttribute(resource);
+			}
+
+			public String getURI() {
+				return ResourceHelper.getContentAttribute(resource);
+			}
+
+			public Version getVersion() {
+				return ResourceHelper.getVersionAttribute(resource);
+			}
+
+			public boolean isLocal() {
+				return false;
+			}
+    	};
+    }
+
+}
diff --git a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/Utils.java b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/Utils.java
index e69de29b..77896a11 100644
--- a/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/Utils.java
+++ b/aries/trunk/subsystem/subsystem-itests/src/test/java/org/apache/aries/subsystem/itests/util/Utils.java
@@ -0,0 +1,23 @@
+package org.apache.aries.subsystem.itests.util;
+
+import java.io.Closeable;
+
+import org.osgi.framework.ServiceRegistration;
+
+public class Utils {
+	public static void closeQuietly(Closeable closeable) {
+		if (closeable == null) return;
+		try {
+			closeable.close();
+		}
+		catch (Exception e) {}
+	}
+	
+	public static void unregisterQuietly(ServiceRegistration<?> reg) {
+		if (reg == null) return;
+		try {
+			reg.unregister();
+		}
+		catch (Exception e) {}
+	}
+}
