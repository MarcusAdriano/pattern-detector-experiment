diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AccessLevel.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AccessLevel.java
index c4dfe761..c78a3e6c 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AccessLevel.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AccessLevel.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 
 import java.util.Map;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthenticationException.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthenticationException.java
index 73cd0e5e..a4384dd1 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthenticationException.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthenticationException.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthenticationRequest.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthenticationRequest.java
index 16dcf716..733fc425 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthenticationRequest.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthenticationRequest.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthorizationException.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthorizationException.java
index b9ebce7e..cddf0694 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthorizationException.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/AuthorizationException.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java
index fba3cb47..4a124423 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Cassandra.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
@@ -105,16 +126,16 @@
     public void insert(byte[] key, ColumnParent column_parent, Column column, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
 
     /**
-     * Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
+     * Remove data from the row specified by key at the granularity specified by column_path, and the given clock. Note
      * that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
      * row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
      * 
      * @param key
      * @param column_path
-     * @param timestamp
+     * @param clock
      * @param consistency_level
      */
-    public void remove(byte[] key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
+    public void remove(byte[] key, ColumnPath column_path, Clock clock, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException;
 
     /**
      *   Mutate many columns or super columns for many row keys. See also: Mutation.
@@ -660,19 +681,19 @@ public void recv_insert() throws InvalidRequestException, UnavailableException,
       return;
     }
 
-    public void remove(byte[] key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
+    public void remove(byte[] key, ColumnPath column_path, Clock clock, ConsistencyLevel consistency_level) throws InvalidRequestException, UnavailableException, TimedOutException, TException
     {
-      send_remove(key, column_path, timestamp, consistency_level);
+      send_remove(key, column_path, clock, consistency_level);
       recv_remove();
     }
 
-    public void send_remove(byte[] key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level) throws TException
+    public void send_remove(byte[] key, ColumnPath column_path, Clock clock, ConsistencyLevel consistency_level) throws TException
     {
       oprot_.writeMessageBegin(new TMessage("remove", TMessageType.CALL, seqid_));
       remove_args args = new remove_args();
       args.key = key;
       args.column_path = column_path;
-      args.timestamp = timestamp;
+      args.clock = clock;
       args.consistency_level = consistency_level;
       args.write(oprot_);
       oprot_.writeMessageEnd();
@@ -1687,7 +1708,7 @@ public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TExcepti
         iprot.readMessageEnd();
         remove_result result = new remove_result();
         try {
-          iface_.remove(args.key, args.column_path, args.timestamp, args.consistency_level);
+          iface_.remove(args.key, args.column_path, args.clock, args.consistency_level);
         } catch (InvalidRequestException ire) {
           result.ire = ire;
         } catch (UnavailableException ue) {
@@ -11450,12 +11471,12 @@ public void validate() throws TException {
 
     private static final TField KEY_FIELD_DESC = new TField("key", TType.STRING, (short)1);
     private static final TField COLUMN_PATH_FIELD_DESC = new TField("column_path", TType.STRUCT, (short)2);
-    private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)3);
+    private static final TField CLOCK_FIELD_DESC = new TField("clock", TType.STRUCT, (short)3);
     private static final TField CONSISTENCY_LEVEL_FIELD_DESC = new TField("consistency_level", TType.I32, (short)4);
 
     public byte[] key;
     public ColumnPath column_path;
-    public long timestamp;
+    public Clock clock;
     /**
      * 
      * @see ConsistencyLevel
@@ -11466,7 +11487,7 @@ public void validate() throws TException {
     public enum _Fields implements TFieldIdEnum {
       KEY((short)1, "key"),
       COLUMN_PATH((short)2, "column_path"),
-      TIMESTAMP((short)3, "timestamp"),
+      CLOCK((short)3, "clock"),
       /**
        * 
        * @see ConsistencyLevel
@@ -11525,16 +11546,14 @@ public String getFieldName() {
     }
 
     // isset id assignments
-    private static final int __TIMESTAMP_ISSET_ID = 0;
-    private BitSet __isset_bit_vector = new BitSet(1);
 
     public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
       put(_Fields.KEY, new FieldMetaData("key", TFieldRequirementType.REQUIRED, 
           new FieldValueMetaData(TType.STRING)));
       put(_Fields.COLUMN_PATH, new FieldMetaData("column_path", TFieldRequirementType.REQUIRED, 
           new StructMetaData(TType.STRUCT, ColumnPath.class)));
-      put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.REQUIRED, 
-          new FieldValueMetaData(TType.I64)));
+      put(_Fields.CLOCK, new FieldMetaData("clock", TFieldRequirementType.REQUIRED, 
+          new StructMetaData(TType.STRUCT, Clock.class)));
       put(_Fields.CONSISTENCY_LEVEL, new FieldMetaData("consistency_level", TFieldRequirementType.DEFAULT, 
           new EnumMetaData(TType.ENUM, ConsistencyLevel.class)));
     }});
@@ -11551,14 +11570,13 @@ public remove_args() {
     public remove_args(
       byte[] key,
       ColumnPath column_path,
-      long timestamp,
+      Clock clock,
       ConsistencyLevel consistency_level)
     {
       this();
       this.key = key;
       this.column_path = column_path;
-      this.timestamp = timestamp;
-      setTimestampIsSet(true);
+      this.clock = clock;
       this.consistency_level = consistency_level;
     }
 
@@ -11566,8 +11584,6 @@ public remove_args(
      * Performs a deep copy on <i>other</i>.
      */
     public remove_args(remove_args other) {
-      __isset_bit_vector.clear();
-      __isset_bit_vector.or(other.__isset_bit_vector);
       if (other.isSetKey()) {
         this.key = new byte[other.key.length];
         System.arraycopy(other.key, 0, key, 0, other.key.length);
@@ -11575,7 +11591,9 @@ public remove_args(remove_args other) {
       if (other.isSetColumn_path()) {
         this.column_path = new ColumnPath(other.column_path);
       }
-      this.timestamp = other.timestamp;
+      if (other.isSetClock()) {
+        this.clock = new Clock(other.clock);
+      }
       if (other.isSetConsistency_level()) {
         this.consistency_level = other.consistency_level;
       }
@@ -11638,27 +11656,28 @@ public void setColumn_pathIsSet(boolean value) {
       }
     }
 
-    public long getTimestamp() {
-      return this.timestamp;
+    public Clock getClock() {
+      return this.clock;
     }
 
-    public remove_args setTimestamp(long timestamp) {
-      this.timestamp = timestamp;
-      setTimestampIsSet(true);
+    public remove_args setClock(Clock clock) {
+      this.clock = clock;
       return this;
     }
 
-    public void unsetTimestamp() {
-      __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
+    public void unsetClock() {
+      this.clock = null;
     }
 
-    /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
-    public boolean isSetTimestamp() {
-      return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
+    /** Returns true if field clock is set (has been asigned a value) and false otherwise */
+    public boolean isSetClock() {
+      return this.clock != null;
     }
 
-    public void setTimestampIsSet(boolean value) {
-      __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
+    public void setClockIsSet(boolean value) {
+      if (!value) {
+        this.clock = null;
+      }
     }
 
     /**
@@ -11711,11 +11730,11 @@ public void setFieldValue(_Fields field, Object value) {
         }
         break;
 
-      case TIMESTAMP:
+      case CLOCK:
         if (value == null) {
-          unsetTimestamp();
+          unsetClock();
         } else {
-          setTimestamp((Long)value);
+          setClock((Clock)value);
         }
         break;
 
@@ -11742,8 +11761,8 @@ public Object getFieldValue(_Fields field) {
       case COLUMN_PATH:
         return getColumn_path();
 
-      case TIMESTAMP:
-        return new Long(getTimestamp());
+      case CLOCK:
+        return getClock();
 
       case CONSISTENCY_LEVEL:
         return getConsistency_level();
@@ -11763,8 +11782,8 @@ public boolean isSet(_Fields field) {
         return isSetKey();
       case COLUMN_PATH:
         return isSetColumn_path();
-      case TIMESTAMP:
-        return isSetTimestamp();
+      case CLOCK:
+        return isSetClock();
       case CONSISTENCY_LEVEL:
         return isSetConsistency_level();
       }
@@ -11806,12 +11825,12 @@ public boolean equals(remove_args that) {
           return false;
       }
 
-      boolean this_present_timestamp = true;
-      boolean that_present_timestamp = true;
-      if (this_present_timestamp || that_present_timestamp) {
-        if (!(this_present_timestamp && that_present_timestamp))
+      boolean this_present_clock = true && this.isSetClock();
+      boolean that_present_clock = true && that.isSetClock();
+      if (this_present_clock || that_present_clock) {
+        if (!(this_present_clock && that_present_clock))
           return false;
-        if (this.timestamp != that.timestamp)
+        if (!this.clock.equals(that.clock))
           return false;
       }
 
@@ -11858,11 +11877,11 @@ public int compareTo(remove_args other) {
           return lastComparison;
         }
       }
-      lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
+      lastComparison = Boolean.valueOf(isSetClock()).compareTo(typedOther.isSetClock());
       if (lastComparison != 0) {
         return lastComparison;
       }
-      if (isSetTimestamp()) {        lastComparison = TBaseHelper.compareTo(timestamp, typedOther.timestamp);
+      if (isSetClock()) {        lastComparison = TBaseHelper.compareTo(clock, typedOther.clock);
         if (lastComparison != 0) {
           return lastComparison;
         }
@@ -11904,10 +11923,10 @@ public void read(TProtocol iprot) throws TException {
               TProtocolUtil.skip(iprot, field.type);
             }
             break;
-          case 3: // TIMESTAMP
-            if (field.type == TType.I64) {
-              this.timestamp = iprot.readI64();
-              setTimestampIsSet(true);
+          case 3: // CLOCK
+            if (field.type == TType.STRUCT) {
+              this.clock = new Clock();
+              this.clock.read(iprot);
             } else { 
               TProtocolUtil.skip(iprot, field.type);
             }
@@ -11927,9 +11946,6 @@ public void read(TProtocol iprot) throws TException {
       iprot.readStructEnd();
 
       // check for required fields of primitive type, which can't be checked in the validate method
-      if (!isSetTimestamp()) {
-        throw new TProtocolException("Required field 'timestamp' was not found in serialized data! Struct: " + toString());
-      }
       validate();
     }
 
@@ -11947,9 +11963,11 @@ public void write(TProtocol oprot) throws TException {
         this.column_path.write(oprot);
         oprot.writeFieldEnd();
       }
-      oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
-      oprot.writeI64(this.timestamp);
+      if (this.clock != null) {
+        oprot.writeFieldBegin(CLOCK_FIELD_DESC);
+        this.clock.write(oprot);
       oprot.writeFieldEnd();
+      }
       if (this.consistency_level != null) {
         oprot.writeFieldBegin(CONSISTENCY_LEVEL_FIELD_DESC);
         oprot.writeI32(this.consistency_level.getValue());
@@ -11985,8 +12003,12 @@ public String toString() {
       }
       first = false;
       if (!first) sb.append(", ");
-      sb.append("timestamp:");
-      sb.append(this.timestamp);
+      sb.append("clock:");
+      if (this.clock == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.clock);
+      }
       first = false;
       if (!first) sb.append(", ");
       sb.append("consistency_level:");
@@ -12008,7 +12030,9 @@ public void validate() throws TException {
       if (column_path == null) {
         throw new TProtocolException("Required field 'column_path' was not present! Struct: " + toString());
       }
-      // alas, we cannot check 'timestamp' because it's a primitive and you chose the non-beans generator.
+      if (clock == null) {
+        throw new TProtocolException("Required field 'clock' was not present! Struct: " + toString());
+      }
     }
 
   }
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/CfDef.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/CfDef.java
index 832c14f2..50dddaa3 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/CfDef.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/CfDef.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
@@ -29,16 +50,18 @@
   private static final TField TABLE_FIELD_DESC = new TField("table", TType.STRING, (short)1);
   private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)2);
   private static final TField COLUMN_TYPE_FIELD_DESC = new TField("column_type", TType.STRING, (short)3);
-  private static final TField COMPARATOR_TYPE_FIELD_DESC = new TField("comparator_type", TType.STRING, (short)4);
-  private static final TField SUBCOMPARATOR_TYPE_FIELD_DESC = new TField("subcomparator_type", TType.STRING, (short)5);
-  private static final TField COMMENT_FIELD_DESC = new TField("comment", TType.STRING, (short)6);
-  private static final TField ROW_CACHE_SIZE_FIELD_DESC = new TField("row_cache_size", TType.DOUBLE, (short)7);
-  private static final TField PRELOAD_ROW_CACHE_FIELD_DESC = new TField("preload_row_cache", TType.BOOL, (short)8);
-  private static final TField KEY_CACHE_SIZE_FIELD_DESC = new TField("key_cache_size", TType.DOUBLE, (short)9);
+  private static final TField CLOCK_TYPE_FIELD_DESC = new TField("clock_type", TType.STRING, (short)4);
+  private static final TField COMPARATOR_TYPE_FIELD_DESC = new TField("comparator_type", TType.STRING, (short)5);
+  private static final TField SUBCOMPARATOR_TYPE_FIELD_DESC = new TField("subcomparator_type", TType.STRING, (short)6);
+  private static final TField COMMENT_FIELD_DESC = new TField("comment", TType.STRING, (short)7);
+  private static final TField ROW_CACHE_SIZE_FIELD_DESC = new TField("row_cache_size", TType.DOUBLE, (short)8);
+  private static final TField PRELOAD_ROW_CACHE_FIELD_DESC = new TField("preload_row_cache", TType.BOOL, (short)9);
+  private static final TField KEY_CACHE_SIZE_FIELD_DESC = new TField("key_cache_size", TType.DOUBLE, (short)10);
 
   public String table;
   public String name;
   public String column_type;
+  public String clock_type;
   public String comparator_type;
   public String subcomparator_type;
   public String comment;
@@ -51,12 +74,13 @@
     TABLE((short)1, "table"),
     NAME((short)2, "name"),
     COLUMN_TYPE((short)3, "column_type"),
-    COMPARATOR_TYPE((short)4, "comparator_type"),
-    SUBCOMPARATOR_TYPE((short)5, "subcomparator_type"),
-    COMMENT((short)6, "comment"),
-    ROW_CACHE_SIZE((short)7, "row_cache_size"),
-    PRELOAD_ROW_CACHE((short)8, "preload_row_cache"),
-    KEY_CACHE_SIZE((short)9, "key_cache_size");
+    CLOCK_TYPE((short)4, "clock_type"),
+    COMPARATOR_TYPE((short)5, "comparator_type"),
+    SUBCOMPARATOR_TYPE((short)6, "subcomparator_type"),
+    COMMENT((short)7, "comment"),
+    ROW_CACHE_SIZE((short)8, "row_cache_size"),
+    PRELOAD_ROW_CACHE((short)9, "preload_row_cache"),
+    KEY_CACHE_SIZE((short)10, "key_cache_size");
 
     private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
     private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
@@ -122,6 +146,8 @@ public String getFieldName() {
         new FieldValueMetaData(TType.STRING)));
     put(_Fields.COLUMN_TYPE, new FieldMetaData("column_type", TFieldRequirementType.OPTIONAL, 
         new FieldValueMetaData(TType.STRING)));
+    put(_Fields.CLOCK_TYPE, new FieldMetaData("clock_type", TFieldRequirementType.OPTIONAL, 
+        new FieldValueMetaData(TType.STRING)));
     put(_Fields.COMPARATOR_TYPE, new FieldMetaData("comparator_type", TFieldRequirementType.OPTIONAL, 
         new FieldValueMetaData(TType.STRING)));
     put(_Fields.SUBCOMPARATOR_TYPE, new FieldMetaData("subcomparator_type", TFieldRequirementType.OPTIONAL, 
@@ -143,6 +169,8 @@ public String getFieldName() {
   public CfDef() {
     this.column_type = "Standard";
 
+    this.clock_type = "Timestamp";
+
     this.comparator_type = "BytesType";
 
     this.subcomparator_type = "";
@@ -181,6 +209,9 @@ public CfDef(CfDef other) {
     if (other.isSetColumn_type()) {
       this.column_type = other.column_type;
     }
+    if (other.isSetClock_type()) {
+      this.clock_type = other.clock_type;
+    }
     if (other.isSetComparator_type()) {
       this.comparator_type = other.comparator_type;
     }
@@ -276,6 +307,30 @@ public void setColumn_typeIsSet(boolean value) {
     }
   }
 
+  public String getClock_type() {
+    return this.clock_type;
+  }
+
+  public CfDef setClock_type(String clock_type) {
+    this.clock_type = clock_type;
+    return this;
+  }
+
+  public void unsetClock_type() {
+    this.clock_type = null;
+  }
+
+  /** Returns true if field clock_type is set (has been asigned a value) and false otherwise */
+  public boolean isSetClock_type() {
+    return this.clock_type != null;
+  }
+
+  public void setClock_typeIsSet(boolean value) {
+    if (!value) {
+      this.clock_type = null;
+    }
+  }
+
   public String getComparator_type() {
     return this.comparator_type;
   }
@@ -443,6 +498,14 @@ public void setFieldValue(_Fields field, Object value) {
       }
       break;
 
+    case CLOCK_TYPE:
+      if (value == null) {
+        unsetClock_type();
+      } else {
+        setClock_type((String)value);
+      }
+      break;
+
     case COMPARATOR_TYPE:
       if (value == null) {
         unsetComparator_type();
@@ -509,6 +572,9 @@ public Object getFieldValue(_Fields field) {
     case COLUMN_TYPE:
       return getColumn_type();
 
+    case CLOCK_TYPE:
+      return getClock_type();
+
     case COMPARATOR_TYPE:
       return getComparator_type();
 
@@ -544,6 +610,8 @@ public boolean isSet(_Fields field) {
       return isSetName();
     case COLUMN_TYPE:
       return isSetColumn_type();
+    case CLOCK_TYPE:
+      return isSetClock_type();
     case COMPARATOR_TYPE:
       return isSetComparator_type();
     case SUBCOMPARATOR_TYPE:
@@ -604,6 +672,15 @@ public boolean equals(CfDef that) {
         return false;
     }
 
+    boolean this_present_clock_type = true && this.isSetClock_type();
+    boolean that_present_clock_type = true && that.isSetClock_type();
+    if (this_present_clock_type || that_present_clock_type) {
+      if (!(this_present_clock_type && that_present_clock_type))
+        return false;
+      if (!this.clock_type.equals(that.clock_type))
+        return false;
+    }
+
     boolean this_present_comparator_type = true && this.isSetComparator_type();
     boolean that_present_comparator_type = true && that.isSetComparator_type();
     if (this_present_comparator_type || that_present_comparator_type) {
@@ -701,6 +778,15 @@ public int compareTo(CfDef other) {
         return lastComparison;
       }
     }
+    lastComparison = Boolean.valueOf(isSetClock_type()).compareTo(typedOther.isSetClock_type());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetClock_type()) {      lastComparison = TBaseHelper.compareTo(clock_type, typedOther.clock_type);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
     lastComparison = Boolean.valueOf(isSetComparator_type()).compareTo(typedOther.isSetComparator_type());
     if (lastComparison != 0) {
       return lastComparison;
@@ -789,28 +875,35 @@ public void read(TProtocol iprot) throws TException {
             TProtocolUtil.skip(iprot, field.type);
           }
           break;
-        case 4: // COMPARATOR_TYPE
+        case 4: // CLOCK_TYPE
+          if (field.type == TType.STRING) {
+            this.clock_type = iprot.readString();
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        case 5: // COMPARATOR_TYPE
           if (field.type == TType.STRING) {
             this.comparator_type = iprot.readString();
           } else { 
             TProtocolUtil.skip(iprot, field.type);
           }
           break;
-        case 5: // SUBCOMPARATOR_TYPE
+        case 6: // SUBCOMPARATOR_TYPE
           if (field.type == TType.STRING) {
             this.subcomparator_type = iprot.readString();
           } else { 
             TProtocolUtil.skip(iprot, field.type);
           }
           break;
-        case 6: // COMMENT
+        case 7: // COMMENT
           if (field.type == TType.STRING) {
             this.comment = iprot.readString();
           } else { 
             TProtocolUtil.skip(iprot, field.type);
           }
           break;
-        case 7: // ROW_CACHE_SIZE
+        case 8: // ROW_CACHE_SIZE
           if (field.type == TType.DOUBLE) {
             this.row_cache_size = iprot.readDouble();
             setRow_cache_sizeIsSet(true);
@@ -818,7 +911,7 @@ public void read(TProtocol iprot) throws TException {
             TProtocolUtil.skip(iprot, field.type);
           }
           break;
-        case 8: // PRELOAD_ROW_CACHE
+        case 9: // PRELOAD_ROW_CACHE
           if (field.type == TType.BOOL) {
             this.preload_row_cache = iprot.readBool();
             setPreload_row_cacheIsSet(true);
@@ -826,7 +919,7 @@ public void read(TProtocol iprot) throws TException {
             TProtocolUtil.skip(iprot, field.type);
           }
           break;
-        case 9: // KEY_CACHE_SIZE
+        case 10: // KEY_CACHE_SIZE
           if (field.type == TType.DOUBLE) {
             this.key_cache_size = iprot.readDouble();
             setKey_cache_sizeIsSet(true);
@@ -866,6 +959,13 @@ public void write(TProtocol oprot) throws TException {
         oprot.writeFieldEnd();
       }
     }
+    if (this.clock_type != null) {
+      if (isSetClock_type()) {
+        oprot.writeFieldBegin(CLOCK_TYPE_FIELD_DESC);
+        oprot.writeString(this.clock_type);
+        oprot.writeFieldEnd();
+      }
+    }
     if (this.comparator_type != null) {
       if (isSetComparator_type()) {
         oprot.writeFieldBegin(COMPARATOR_TYPE_FIELD_DESC);
@@ -936,6 +1036,16 @@ public String toString() {
       }
       first = false;
     }
+    if (isSetClock_type()) {
+      if (!first) sb.append(", ");
+      sb.append("clock_type:");
+      if (this.clock_type == null) {
+        sb.append("null");
+      } else {
+        sb.append(this.clock_type);
+      }
+      first = false;
+    }
     if (isSetComparator_type()) {
       if (!first) sb.append(", ");
       sb.append("comparator_type:");
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Clock.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Clock.java
index e69de29b..94ccfeaa 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Clock.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Clock.java
@@ -0,0 +1,335 @@
+/**
+ * Autogenerated by Thrift
+ *
+ * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+ */
+package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
+
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.HashMap;
+import java.util.EnumMap;
+import java.util.Set;
+import java.util.HashSet;
+import java.util.EnumSet;
+import java.util.Collections;
+import java.util.BitSet;
+import java.util.Arrays;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import org.apache.thrift.*;
+import org.apache.thrift.meta_data.*;
+import org.apache.thrift.protocol.*;
+
+/**
+ * Encapsulate types of conflict resolution.
+ * 
+ * @param timestamp. User-supplied timestamp. When two columns with this type of clock conflict, the one with the
+ *                   highest timestamp is the one whose value the system will converge to. No other assumptions
+ *                   are made about what the timestamp represents, but using microseconds-since-epoch is customary.
+ */
+public class Clock implements TBase<Clock._Fields>, java.io.Serializable, Cloneable, Comparable<Clock> {
+  private static final TStruct STRUCT_DESC = new TStruct("Clock");
+
+  private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)1);
+
+  public long timestamp;
+
+  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
+  public enum _Fields implements TFieldIdEnum {
+    TIMESTAMP((short)1, "timestamp");
+
+    private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
+    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
+
+    static {
+      for (_Fields field : EnumSet.allOf(_Fields.class)) {
+        byId.put((int)field._thriftId, field);
+        byName.put(field.getFieldName(), field);
+      }
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, or null if its not found.
+     */
+    public static _Fields findByThriftId(int fieldId) {
+      return byId.get(fieldId);
+    }
+
+    /**
+     * Find the _Fields constant that matches fieldId, throwing an exception
+     * if it is not found.
+     */
+    public static _Fields findByThriftIdOrThrow(int fieldId) {
+      _Fields fields = findByThriftId(fieldId);
+      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
+      return fields;
+    }
+
+    /**
+     * Find the _Fields constant that matches name, or null if its not found.
+     */
+    public static _Fields findByName(String name) {
+      return byName.get(name);
+    }
+
+    private final short _thriftId;
+    private final String _fieldName;
+
+    _Fields(short thriftId, String fieldName) {
+      _thriftId = thriftId;
+      _fieldName = fieldName;
+    }
+
+    public short getThriftFieldId() {
+      return _thriftId;
+    }
+
+    public String getFieldName() {
+      return _fieldName;
+    }
+  }
+
+  // isset id assignments
+  private static final int __TIMESTAMP_ISSET_ID = 0;
+  private BitSet __isset_bit_vector = new BitSet(1);
+
+  public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
+    put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.REQUIRED, 
+        new FieldValueMetaData(TType.I64)));
+  }});
+
+  static {
+    FieldMetaData.addStructMetaDataMap(Clock.class, metaDataMap);
+  }
+
+  public Clock() {
+  }
+
+  public Clock(
+    long timestamp)
+  {
+    this();
+    this.timestamp = timestamp;
+    setTimestampIsSet(true);
+  }
+
+  /**
+   * Performs a deep copy on <i>other</i>.
+   */
+  public Clock(Clock other) {
+    __isset_bit_vector.clear();
+    __isset_bit_vector.or(other.__isset_bit_vector);
+    this.timestamp = other.timestamp;
+  }
+
+  public Clock deepCopy() {
+    return new Clock(this);
+  }
+
+  @Deprecated
+  public Clock clone() {
+    return new Clock(this);
+  }
+
+  public long getTimestamp() {
+    return this.timestamp;
+  }
+
+  public Clock setTimestamp(long timestamp) {
+    this.timestamp = timestamp;
+    setTimestampIsSet(true);
+    return this;
+  }
+
+  public void unsetTimestamp() {
+    __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
+  }
+
+  /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
+  public boolean isSetTimestamp() {
+    return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
+  }
+
+  public void setTimestampIsSet(boolean value) {
+    __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
+  }
+
+  public void setFieldValue(_Fields field, Object value) {
+    switch (field) {
+    case TIMESTAMP:
+      if (value == null) {
+        unsetTimestamp();
+      } else {
+        setTimestamp((Long)value);
+      }
+      break;
+
+    }
+  }
+
+  public void setFieldValue(int fieldID, Object value) {
+    setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
+  }
+
+  public Object getFieldValue(_Fields field) {
+    switch (field) {
+    case TIMESTAMP:
+      return new Long(getTimestamp());
+
+    }
+    throw new IllegalStateException();
+  }
+
+  public Object getFieldValue(int fieldId) {
+    return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
+  }
+
+  /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
+  public boolean isSet(_Fields field) {
+    switch (field) {
+    case TIMESTAMP:
+      return isSetTimestamp();
+    }
+    throw new IllegalStateException();
+  }
+
+  public boolean isSet(int fieldID) {
+    return isSet(_Fields.findByThriftIdOrThrow(fieldID));
+  }
+
+  @Override
+  public boolean equals(Object that) {
+    if (that == null)
+      return false;
+    if (that instanceof Clock)
+      return this.equals((Clock)that);
+    return false;
+  }
+
+  public boolean equals(Clock that) {
+    if (that == null)
+      return false;
+
+    boolean this_present_timestamp = true;
+    boolean that_present_timestamp = true;
+    if (this_present_timestamp || that_present_timestamp) {
+      if (!(this_present_timestamp && that_present_timestamp))
+        return false;
+      if (this.timestamp != that.timestamp)
+        return false;
+    }
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    return 0;
+  }
+
+  public int compareTo(Clock other) {
+    if (!getClass().equals(other.getClass())) {
+      return getClass().getName().compareTo(other.getClass().getName());
+    }
+
+    int lastComparison = 0;
+    Clock typedOther = (Clock)other;
+
+    lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetTimestamp()) {      lastComparison = TBaseHelper.compareTo(timestamp, typedOther.timestamp);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    return 0;
+  }
+
+  public void read(TProtocol iprot) throws TException {
+    TField field;
+    iprot.readStructBegin();
+    while (true)
+    {
+      field = iprot.readFieldBegin();
+      if (field.type == TType.STOP) { 
+        break;
+      }
+      switch (field.id) {
+        case 1: // TIMESTAMP
+          if (field.type == TType.I64) {
+            this.timestamp = iprot.readI64();
+            setTimestampIsSet(true);
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        default:
+          TProtocolUtil.skip(iprot, field.type);
+      }
+      iprot.readFieldEnd();
+    }
+    iprot.readStructEnd();
+
+    // check for required fields of primitive type, which can't be checked in the validate method
+    if (!isSetTimestamp()) {
+      throw new TProtocolException("Required field 'timestamp' was not found in serialized data! Struct: " + toString());
+    }
+    validate();
+  }
+
+  public void write(TProtocol oprot) throws TException {
+    validate();
+
+    oprot.writeStructBegin(STRUCT_DESC);
+    oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
+    oprot.writeI64(this.timestamp);
+    oprot.writeFieldEnd();
+    oprot.writeFieldStop();
+    oprot.writeStructEnd();
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder("Clock(");
+    boolean first = true;
+
+    sb.append("timestamp:");
+    sb.append(this.timestamp);
+    first = false;
+    sb.append(")");
+    return sb.toString();
+  }
+
+  public void validate() throws TException {
+    // check for required fields
+    // alas, we cannot check 'timestamp' because it's a primitive and you chose the non-beans generator.
+  }
+
+}
+
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Column.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Column.java
index f528716a..fd08e2fd 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Column.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Column.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
@@ -27,7 +48,7 @@
  * Basic unit of data within a ColumnFamily.
  * @param name, the name by which this column is set and retrieved.  Maximum 64KB long.
  * @param value. The data associated with the name.  Maximum 2GB long, but in practice you should limit it to small numbers of MB (since Thrift must read the full value into memory to operate on it).
- * @param timestamp. The highest timestamp associated with the given column name is the one whose value the system will converge to.  No other assumptions are made about what the timestamp represents, but using microseconds-since-epoch is customary.
+ * @param clock. The clock is used for conflict detection/resolution when two columns with same name need to be compared.
  * @param ttl. An optional, positive delay (in seconds) after which the column will be automatically deleted.
  */
 public class Column implements TBase<Column._Fields>, java.io.Serializable, Cloneable, Comparable<Column> {
@@ -35,19 +56,19 @@
 
   private static final TField NAME_FIELD_DESC = new TField("name", TType.STRING, (short)1);
   private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short)2);
-  private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)3);
+  private static final TField CLOCK_FIELD_DESC = new TField("clock", TType.STRUCT, (short)3);
   private static final TField TTL_FIELD_DESC = new TField("ttl", TType.I32, (short)4);
 
   public byte[] name;
   public byte[] value;
-  public long timestamp;
+  public Clock clock;
   public int ttl;
 
   /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
   public enum _Fields implements TFieldIdEnum {
     NAME((short)1, "name"),
     VALUE((short)2, "value"),
-    TIMESTAMP((short)3, "timestamp"),
+    CLOCK((short)3, "clock"),
     TTL((short)4, "ttl");
 
     private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();
@@ -102,17 +123,16 @@ public String getFieldName() {
   }
 
   // isset id assignments
-  private static final int __TIMESTAMP_ISSET_ID = 0;
-  private static final int __TTL_ISSET_ID = 1;
-  private BitSet __isset_bit_vector = new BitSet(2);
+  private static final int __TTL_ISSET_ID = 0;
+  private BitSet __isset_bit_vector = new BitSet(1);
 
   public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
     put(_Fields.NAME, new FieldMetaData("name", TFieldRequirementType.REQUIRED, 
         new FieldValueMetaData(TType.STRING)));
     put(_Fields.VALUE, new FieldMetaData("value", TFieldRequirementType.REQUIRED, 
         new FieldValueMetaData(TType.STRING)));
-    put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.REQUIRED, 
-        new FieldValueMetaData(TType.I64)));
+    put(_Fields.CLOCK, new FieldMetaData("clock", TFieldRequirementType.REQUIRED, 
+        new StructMetaData(TType.STRUCT, Clock.class)));
     put(_Fields.TTL, new FieldMetaData("ttl", TFieldRequirementType.OPTIONAL, 
         new FieldValueMetaData(TType.I32)));
   }});
@@ -127,13 +147,12 @@ public Column() {
   public Column(
     byte[] name,
     byte[] value,
-    long timestamp)
+    Clock clock)
   {
     this();
     this.name = name;
     this.value = value;
-    this.timestamp = timestamp;
-    setTimestampIsSet(true);
+    this.clock = clock;
   }
 
   /**
@@ -150,7 +169,9 @@ public Column(Column other) {
       this.value = new byte[other.value.length];
       System.arraycopy(other.value, 0, value, 0, other.value.length);
     }
-    this.timestamp = other.timestamp;
+    if (other.isSetClock()) {
+      this.clock = new Clock(other.clock);
+    }
     this.ttl = other.ttl;
   }
 
@@ -211,27 +232,28 @@ public void setValueIsSet(boolean value) {
     }
   }
 
-  public long getTimestamp() {
-    return this.timestamp;
+  public Clock getClock() {
+    return this.clock;
   }
 
-  public Column setTimestamp(long timestamp) {
-    this.timestamp = timestamp;
-    setTimestampIsSet(true);
+  public Column setClock(Clock clock) {
+    this.clock = clock;
     return this;
   }
 
-  public void unsetTimestamp() {
-    __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
+  public void unsetClock() {
+    this.clock = null;
   }
 
-  /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
-  public boolean isSetTimestamp() {
-    return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
+  /** Returns true if field clock is set (has been asigned a value) and false otherwise */
+  public boolean isSetClock() {
+    return this.clock != null;
   }
 
-  public void setTimestampIsSet(boolean value) {
-    __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
+  public void setClockIsSet(boolean value) {
+    if (!value) {
+      this.clock = null;
+    }
   }
 
   public int getTtl() {
@@ -275,11 +297,11 @@ public void setFieldValue(_Fields field, Object value) {
       }
       break;
 
-    case TIMESTAMP:
+    case CLOCK:
       if (value == null) {
-        unsetTimestamp();
+        unsetClock();
       } else {
-        setTimestamp((Long)value);
+        setClock((Clock)value);
       }
       break;
 
@@ -306,8 +328,8 @@ public Object getFieldValue(_Fields field) {
     case VALUE:
       return getValue();
 
-    case TIMESTAMP:
-      return new Long(getTimestamp());
+    case CLOCK:
+      return getClock();
 
     case TTL:
       return new Integer(getTtl());
@@ -327,8 +349,8 @@ public boolean isSet(_Fields field) {
       return isSetName();
     case VALUE:
       return isSetValue();
-    case TIMESTAMP:
-      return isSetTimestamp();
+    case CLOCK:
+      return isSetClock();
     case TTL:
       return isSetTtl();
     }
@@ -370,12 +392,12 @@ public boolean equals(Column that) {
         return false;
     }
 
-    boolean this_present_timestamp = true;
-    boolean that_present_timestamp = true;
-    if (this_present_timestamp || that_present_timestamp) {
-      if (!(this_present_timestamp && that_present_timestamp))
+    boolean this_present_clock = true && this.isSetClock();
+    boolean that_present_clock = true && that.isSetClock();
+    if (this_present_clock || that_present_clock) {
+      if (!(this_present_clock && that_present_clock))
         return false;
-      if (this.timestamp != that.timestamp)
+      if (!this.clock.equals(that.clock))
         return false;
     }
 
@@ -422,11 +444,11 @@ public int compareTo(Column other) {
         return lastComparison;
       }
     }
-    lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
+    lastComparison = Boolean.valueOf(isSetClock()).compareTo(typedOther.isSetClock());
     if (lastComparison != 0) {
       return lastComparison;
     }
-    if (isSetTimestamp()) {      lastComparison = TBaseHelper.compareTo(timestamp, typedOther.timestamp);
+    if (isSetClock()) {      lastComparison = TBaseHelper.compareTo(clock, typedOther.clock);
       if (lastComparison != 0) {
         return lastComparison;
       }
@@ -467,10 +489,10 @@ public void read(TProtocol iprot) throws TException {
             TProtocolUtil.skip(iprot, field.type);
           }
           break;
-        case 3: // TIMESTAMP
-          if (field.type == TType.I64) {
-            this.timestamp = iprot.readI64();
-            setTimestampIsSet(true);
+        case 3: // CLOCK
+          if (field.type == TType.STRUCT) {
+            this.clock = new Clock();
+            this.clock.read(iprot);
           } else { 
             TProtocolUtil.skip(iprot, field.type);
           }
@@ -491,9 +513,6 @@ public void read(TProtocol iprot) throws TException {
     iprot.readStructEnd();
 
     // check for required fields of primitive type, which can't be checked in the validate method
-    if (!isSetTimestamp()) {
-      throw new TProtocolException("Required field 'timestamp' was not found in serialized data! Struct: " + toString());
-    }
     validate();
   }
 
@@ -511,9 +530,11 @@ public void write(TProtocol oprot) throws TException {
       oprot.writeBinary(this.value);
       oprot.writeFieldEnd();
     }
-    oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
-    oprot.writeI64(this.timestamp);
+    if (this.clock != null) {
+      oprot.writeFieldBegin(CLOCK_FIELD_DESC);
+      this.clock.write(oprot);
     oprot.writeFieldEnd();
+    }
     if (isSetTtl()) {
       oprot.writeFieldBegin(TTL_FIELD_DESC);
       oprot.writeI32(this.ttl);
@@ -554,8 +575,12 @@ public String toString() {
     }
     first = false;
     if (!first) sb.append(", ");
-    sb.append("timestamp:");
-    sb.append(this.timestamp);
+    sb.append("clock:");
+    if (this.clock == null) {
+      sb.append("null");
+    } else {
+      sb.append(this.clock);
+    }
     first = false;
     if (isSetTtl()) {
       if (!first) sb.append(", ");
@@ -575,7 +600,9 @@ public void validate() throws TException {
     if (value == null) {
       throw new TProtocolException("Required field 'value' was not present! Struct: " + toString());
     }
-    // alas, we cannot check 'timestamp' because it's a primitive and you chose the non-beans generator.
+    if (clock == null) {
+      throw new TProtocolException("Required field 'clock' was not present! Struct: " + toString());
+    }
   }
 
 }
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ColumnOrSuperColumn.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ColumnOrSuperColumn.java
index 7dfb125b..328ca031 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ColumnOrSuperColumn.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ColumnOrSuperColumn.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ColumnParent.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ColumnParent.java
index 8e3c3d5f..0d3730f6 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ColumnParent.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ColumnParent.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ColumnPath.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ColumnPath.java
index ead8735d..a89548b2 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ColumnPath.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ColumnPath.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ConsistencyLevel.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ConsistencyLevel.java
index 5b5ca9d9..709a6ad6 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ConsistencyLevel.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/ConsistencyLevel.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 
 import java.util.Map;
@@ -19,21 +40,22 @@
  * allowing availability in the face of node failures up to half of <ReplicationFactor>. Of course if latency is more
  * important than consistency then you can use lower values for either or both.
  * 
- * Write:
+ * Write consistency levels make the following guarantees before reporting success to the client:
  *      ZERO    Ensure nothing. A write happens asynchronously in background
  *      ANY     Ensure that the write has been written once somewhere, including possibly being hinted in a non-target node.
- *      ONE     Ensure that the write has been written to at least 1 node's commit log and memory table before responding to the client.
- *      QUORUM  Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes before responding to the client.
+ *   ONE          Ensure that the write has been written to at least 1 node's commit log and memory table
+ *   QUORUM       Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes
+ *   DCQUORUM     Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes, within the local datacenter (requires DatacenterShardStrategy)
+ *   DCQUORUMSYNC Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes in each datacenter (requires DatacenterShardStrategy)
  *      ALL     Ensure that the write is written to <code>&lt;ReplicationFactor&gt;</code> nodes before responding to the client.
  * 
  * Read:
  *      ZERO    Not supported, because it doesn't make sense.
  *      ANY     Not supported. You probably want ONE instead.
- *      ONE     Will return the record returned by the first node to respond. A consistency check is always done in a
- *              background thread to fix any consistency issues when ConsistencyLevel.ONE is used. This means subsequent
- *              calls will have correct data even if the initial read gets an older value. (This is called 'read repair'.)
- *      QUORUM  Will query all storage nodes and return the record with the most recent timestamp once it has at least a
- *              majority of replicas reported. Again, the remaining replicas will be checked in the background.
+ *   ONE          Will return the record returned by the first node to respond. A consistency check is always done in a background thread to fix any consistency issues when ConsistencyLevel.ONE is used. This means subsequent calls will have correct data even if the initial read gets an older value. (This is called 'read repair'.)
+ *   QUORUM       Will query all storage nodes and return the record with the most recent timestamp once it has at least a majority of replicas reported. Again, the remaining replicas will be checked in the background.
+ *   DCQUORUM     Returns the record with the most recent timestamp once a majority of replicas within the local datacenter have replied.
+ *   DCQUORUMSYNC Returns the record with the most recent timestamp once a majority of replicas within each datacenter have replied.
  *      ALL     Queries all storage nodes and returns the record with the most recent timestamp.
  */
 public enum ConsistencyLevel implements TEnum {
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Constants.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Constants.java
index 35e98fbd..b96e3433 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Constants.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Constants.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
@@ -21,6 +42,6 @@
 
 public class Constants {
 
-  public static final String VERSION = "6.1.0";
+  public static final String VERSION = "7.0.0";
 
 }
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Deletion.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Deletion.java
index ed9e9cdb..dc79776c 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Deletion.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Deletion.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
@@ -26,17 +47,17 @@
 public class Deletion implements TBase<Deletion._Fields>, java.io.Serializable, Cloneable, Comparable<Deletion> {
   private static final TStruct STRUCT_DESC = new TStruct("Deletion");
 
-  private static final TField TIMESTAMP_FIELD_DESC = new TField("timestamp", TType.I64, (short)1);
+  private static final TField CLOCK_FIELD_DESC = new TField("clock", TType.STRUCT, (short)1);
   private static final TField SUPER_COLUMN_FIELD_DESC = new TField("super_column", TType.STRING, (short)2);
   private static final TField PREDICATE_FIELD_DESC = new TField("predicate", TType.STRUCT, (short)3);
 
-  public long timestamp;
+  public Clock clock;
   public byte[] super_column;
   public SlicePredicate predicate;
 
   /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
   public enum _Fields implements TFieldIdEnum {
-    TIMESTAMP((short)1, "timestamp"),
+    CLOCK((short)1, "clock"),
     SUPER_COLUMN((short)2, "super_column"),
     PREDICATE((short)3, "predicate");
 
@@ -92,12 +113,10 @@ public String getFieldName() {
   }
 
   // isset id assignments
-  private static final int __TIMESTAMP_ISSET_ID = 0;
-  private BitSet __isset_bit_vector = new BitSet(1);
 
   public static final Map<_Fields, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class) {{
-    put(_Fields.TIMESTAMP, new FieldMetaData("timestamp", TFieldRequirementType.REQUIRED, 
-        new FieldValueMetaData(TType.I64)));
+    put(_Fields.CLOCK, new FieldMetaData("clock", TFieldRequirementType.REQUIRED, 
+        new StructMetaData(TType.STRUCT, Clock.class)));
     put(_Fields.SUPER_COLUMN, new FieldMetaData("super_column", TFieldRequirementType.OPTIONAL, 
         new FieldValueMetaData(TType.STRING)));
     put(_Fields.PREDICATE, new FieldMetaData("predicate", TFieldRequirementType.OPTIONAL, 
@@ -112,20 +131,19 @@ public Deletion() {
   }
 
   public Deletion(
-    long timestamp)
+    Clock clock)
   {
     this();
-    this.timestamp = timestamp;
-    setTimestampIsSet(true);
+    this.clock = clock;
   }
 
   /**
    * Performs a deep copy on <i>other</i>.
    */
   public Deletion(Deletion other) {
-    __isset_bit_vector.clear();
-    __isset_bit_vector.or(other.__isset_bit_vector);
-    this.timestamp = other.timestamp;
+    if (other.isSetClock()) {
+      this.clock = new Clock(other.clock);
+    }
     if (other.isSetSuper_column()) {
       this.super_column = new byte[other.super_column.length];
       System.arraycopy(other.super_column, 0, super_column, 0, other.super_column.length);
@@ -144,27 +162,28 @@ public Deletion clone() {
     return new Deletion(this);
   }
 
-  public long getTimestamp() {
-    return this.timestamp;
+  public Clock getClock() {
+    return this.clock;
   }
 
-  public Deletion setTimestamp(long timestamp) {
-    this.timestamp = timestamp;
-    setTimestampIsSet(true);
+  public Deletion setClock(Clock clock) {
+    this.clock = clock;
     return this;
   }
 
-  public void unsetTimestamp() {
-    __isset_bit_vector.clear(__TIMESTAMP_ISSET_ID);
+  public void unsetClock() {
+    this.clock = null;
   }
 
-  /** Returns true if field timestamp is set (has been asigned a value) and false otherwise */
-  public boolean isSetTimestamp() {
-    return __isset_bit_vector.get(__TIMESTAMP_ISSET_ID);
+  /** Returns true if field clock is set (has been asigned a value) and false otherwise */
+  public boolean isSetClock() {
+    return this.clock != null;
   }
 
-  public void setTimestampIsSet(boolean value) {
-    __isset_bit_vector.set(__TIMESTAMP_ISSET_ID, value);
+  public void setClockIsSet(boolean value) {
+    if (!value) {
+      this.clock = null;
+    }
   }
 
   public byte[] getSuper_column() {
@@ -217,11 +236,11 @@ public void setPredicateIsSet(boolean value) {
 
   public void setFieldValue(_Fields field, Object value) {
     switch (field) {
-    case TIMESTAMP:
+    case CLOCK:
       if (value == null) {
-        unsetTimestamp();
+        unsetClock();
       } else {
-        setTimestamp((Long)value);
+        setClock((Clock)value);
       }
       break;
 
@@ -250,8 +269,8 @@ public void setFieldValue(int fieldID, Object value) {
 
   public Object getFieldValue(_Fields field) {
     switch (field) {
-    case TIMESTAMP:
-      return new Long(getTimestamp());
+    case CLOCK:
+      return getClock();
 
     case SUPER_COLUMN:
       return getSuper_column();
@@ -270,8 +289,8 @@ public Object getFieldValue(int fieldId) {
   /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
   public boolean isSet(_Fields field) {
     switch (field) {
-    case TIMESTAMP:
-      return isSetTimestamp();
+    case CLOCK:
+      return isSetClock();
     case SUPER_COLUMN:
       return isSetSuper_column();
     case PREDICATE:
@@ -297,12 +316,12 @@ public boolean equals(Deletion that) {
     if (that == null)
       return false;
 
-    boolean this_present_timestamp = true;
-    boolean that_present_timestamp = true;
-    if (this_present_timestamp || that_present_timestamp) {
-      if (!(this_present_timestamp && that_present_timestamp))
+    boolean this_present_clock = true && this.isSetClock();
+    boolean that_present_clock = true && that.isSetClock();
+    if (this_present_clock || that_present_clock) {
+      if (!(this_present_clock && that_present_clock))
         return false;
-      if (this.timestamp != that.timestamp)
+      if (!this.clock.equals(that.clock))
         return false;
     }
 
@@ -340,11 +359,11 @@ public int compareTo(Deletion other) {
     int lastComparison = 0;
     Deletion typedOther = (Deletion)other;
 
-    lastComparison = Boolean.valueOf(isSetTimestamp()).compareTo(typedOther.isSetTimestamp());
+    lastComparison = Boolean.valueOf(isSetClock()).compareTo(typedOther.isSetClock());
     if (lastComparison != 0) {
       return lastComparison;
     }
-    if (isSetTimestamp()) {      lastComparison = TBaseHelper.compareTo(timestamp, typedOther.timestamp);
+    if (isSetClock()) {      lastComparison = TBaseHelper.compareTo(clock, typedOther.clock);
       if (lastComparison != 0) {
         return lastComparison;
       }
@@ -380,10 +399,10 @@ public void read(TProtocol iprot) throws TException {
         break;
       }
       switch (field.id) {
-        case 1: // TIMESTAMP
-          if (field.type == TType.I64) {
-            this.timestamp = iprot.readI64();
-            setTimestampIsSet(true);
+        case 1: // CLOCK
+          if (field.type == TType.STRUCT) {
+            this.clock = new Clock();
+            this.clock.read(iprot);
           } else { 
             TProtocolUtil.skip(iprot, field.type);
           }
@@ -411,9 +430,6 @@ public void read(TProtocol iprot) throws TException {
     iprot.readStructEnd();
 
     // check for required fields of primitive type, which can't be checked in the validate method
-    if (!isSetTimestamp()) {
-      throw new TProtocolException("Required field 'timestamp' was not found in serialized data! Struct: " + toString());
-    }
     validate();
   }
 
@@ -421,9 +437,11 @@ public void write(TProtocol oprot) throws TException {
     validate();
 
     oprot.writeStructBegin(STRUCT_DESC);
-    oprot.writeFieldBegin(TIMESTAMP_FIELD_DESC);
-    oprot.writeI64(this.timestamp);
+    if (this.clock != null) {
+      oprot.writeFieldBegin(CLOCK_FIELD_DESC);
+      this.clock.write(oprot);
     oprot.writeFieldEnd();
+    }
     if (this.super_column != null) {
       if (isSetSuper_column()) {
         oprot.writeFieldBegin(SUPER_COLUMN_FIELD_DESC);
@@ -447,8 +465,12 @@ public String toString() {
     StringBuilder sb = new StringBuilder("Deletion(");
     boolean first = true;
 
-    sb.append("timestamp:");
-    sb.append(this.timestamp);
+    sb.append("clock:");
+    if (this.clock == null) {
+      sb.append("null");
+    } else {
+      sb.append(this.clock);
+    }
     first = false;
     if (isSetSuper_column()) {
       if (!first) sb.append(", ");
@@ -481,7 +503,9 @@ public String toString() {
 
   public void validate() throws TException {
     // check for required fields
-    // alas, we cannot check 'timestamp' because it's a primitive and you chose the non-beans generator.
+    if (clock == null) {
+      throw new TProtocolException("Required field 'clock' was not present! Struct: " + toString());
+    }
   }
 
 }
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/InvalidRequestException.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/InvalidRequestException.java
index d269467e..ba1350df 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/InvalidRequestException.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/InvalidRequestException.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeyRange.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeyRange.java
index 5e8b644d..6d514e23 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeyRange.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeyRange.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeySlice.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeySlice.java
index 35b30059..774c2213 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeySlice.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KeySlice.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KsDef.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KsDef.java
index aaea5081..1882a1b6 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KsDef.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/KsDef.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Mutation.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Mutation.java
index 8999e73e..b89cdad3 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Mutation.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/Mutation.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/NotFoundException.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/NotFoundException.java
index 4b127804..585a027b 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/NotFoundException.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/NotFoundException.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/SlicePredicate.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/SlicePredicate.java
index 0907d594..c5c91728 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/SlicePredicate.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/SlicePredicate.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/SliceRange.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/SliceRange.java
index 4f7b2f38..ca7c476d 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/SliceRange.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/SliceRange.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/SuperColumn.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/SuperColumn.java
index 2d7667e4..807cb119 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/SuperColumn.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/SuperColumn.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/TimedOutException.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/TimedOutException.java
index bf0ed927..f751c297 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/TimedOutException.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/TimedOutException.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/TokenRange.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/TokenRange.java
index 1a5952f6..360bdfaf 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/TokenRange.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/TokenRange.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/UnavailableException.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/UnavailableException.java
index f58d0bcb..37a0ae73 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/UnavailableException.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/UnavailableException.java
@@ -4,6 +4,27 @@
  * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
  */
 package org.apache.cassandra.thrift;
+/*
+ * 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ * 
+ */
+
 
 import java.util.List;
 import java.util.ArrayList;
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/avro/AvroRecordFactory.java b/cassandra/trunk/src/java/org/apache/cassandra/avro/AvroRecordFactory.java
index 20791445..26930d9c 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/avro/AvroRecordFactory.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/avro/AvroRecordFactory.java
@@ -27,18 +27,25 @@
 
 public class AvroRecordFactory
 {
-    public static Column newColumn(ByteBuffer name, ByteBuffer value, long timestamp)
+    public static Column newColumn(ByteBuffer name, ByteBuffer value, Clock clock)
     {
         Column column = new Column();
         column.name = name;
         column.value = value;
-        column.timestamp = timestamp;
+        column.clock = clock;
         return column;
     }
     
-    public static Column newColumn(byte[] name, byte[] value, long timestamp)
+    public static Clock newClock(long timestamp)
     {
-        return newColumn(ByteBuffer.wrap(name), ByteBuffer.wrap(value), timestamp);
+        Clock clock = new Clock();
+        clock.timestamp = timestamp;
+        return clock;
+    }
+    
+    public static Column newColumn(byte[] name, byte[] value, Clock clock)
+    {
+        return newColumn(ByteBuffer.wrap(name), ByteBuffer.wrap(value), clock);
     }
     
     public static SuperColumn newSuperColumn(ByteBuffer name, GenericArray<Column> columns)
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java b/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java
index 639dab77..15a3637d 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java
@@ -67,6 +67,7 @@
     
     // CfDef default values
     private final static String D_CF_CFTYPE = "Standard";
+    private final static String D_CF_CFCLOCKTYPE = "Timestamp";
     private final static String D_CF_COMPTYPE = "BytesType";
     private final static String D_CF_SUBCOMPTYPE = "";
     private final static String D_CF_COMMENT = "";
@@ -172,13 +173,18 @@ public ColumnOrSuperColumn get(ByteBuffer key, ColumnPath columnPath, Consistenc
             if (column.isMarkedForDelete())
                 continue;
             
-            Column avroColumn = newColumn(column.name(), column.value(), column.timestamp());
+            Column avroColumn = newColumn(column.name(), column.value(), avronateIClock(column.clock()));
             avroColumns.add(avroColumn);
         }
         
         return avroColumns;
     }
     
+    private static Clock avronateIClock(IClock clock)
+    {
+        return newClock(((org.apache.cassandra.db.TimestampClock) clock).timestamp());
+    }
+
     private GenericArray<ColumnOrSuperColumn> avronateColumns(Collection<IColumn> columns, boolean reverseOrder)
     {
         ArrayList<ColumnOrSuperColumn> avroColumns = new ArrayList<ColumnOrSuperColumn>(columns.size());
@@ -187,7 +193,7 @@ public ColumnOrSuperColumn get(ByteBuffer key, ColumnPath columnPath, Consistenc
             if (column.isMarkedForDelete())
                 continue;
             
-            Column avroColumn = newColumn(column.name(), column.value(), column.timestamp());
+            Column avroColumn = newColumn(column.name(), column.value(), avronateIClock(column.clock()));
             
             if (column instanceof ExpiringColumn)
                 avroColumn.ttl = ((ExpiringColumn)column).getTimeToLive();
@@ -268,7 +274,7 @@ public Void insert(ByteBuffer key, ColumnParent parent, Column column, Consisten
                    parent.super_column == null ? null : parent.super_column.array(),
                    column.name.array()),
                    column.value.array(),
-                   column.timestamp,
+                   unavronateClock(column.clock),
                    column.ttl == null ? 0 : column.ttl);
         }
         catch (MarshalException e)
@@ -339,14 +345,14 @@ private static RowMutation getRowMutation(String keyspace, byte[] key, Map<Utf8,
                     for (Column column : cosc.super_column.columns)
                     {
                         QueryPath path = new QueryPath(cfName, cosc.super_column.name.array(), column.name.array());
-                        rm.add(path, column.value.array(), column.timestamp);
+                        rm.add(path, column.value.array(), unavronateClock(column.clock), column.ttl == null ? 0 : column.ttl);
                     }
                 }
                 else
                 {
                     assert cosc.super_column == null;
                     QueryPath path = new QueryPath(cfName, null, cosc.column.name.array());
-                    rm.add(path, cosc.column.value.array(), cosc.column.timestamp);
+                    rm.add(path, cosc.column.value.array(), unavronateClock(cosc.column.clock), cosc.column.ttl == null ? 0 : cosc.column.ttl);
                 }
             }
         }
@@ -402,6 +408,11 @@ public Void batch_mutate(Utf8 keyspace, Map<Utf8, Map<Utf8, GenericArray<Mutatio
         return null;
     }
     
+    private static IClock unavronateClock(Clock clock)
+    {
+        return new org.apache.cassandra.db.TimestampClock(clock.timestamp);
+    }
+    
     // FIXME: This is copypasta from o.a.c.db.RowMutation, (RowMutation.getRowMutation uses Thrift types directly).
     private static RowMutation getRowMutationFromMutations(String keyspace, String key, Map<Utf8, GenericArray<Mutation>> cfMap)
     {
@@ -430,11 +441,11 @@ private static void addColumnOrSuperColumnToRowMutation(RowMutation rm, String c
         if (cosc.column == null)
         {
             for (Column column : cosc.super_column.columns)
-                rm.add(new QueryPath(cfName, cosc.super_column.name.array(), column.name.array()), column.value.array(), column.timestamp);
+                rm.add(new QueryPath(cfName, cosc.super_column.name.array(), column.name.array()), column.value.array(), unavronateClock(column.clock));
         }
         else
         {
-            rm.add(new QueryPath(cfName, null, cosc.column.name.array()), cosc.column.value.array(), cosc.column.timestamp);
+            rm.add(new QueryPath(cfName, null, cosc.column.name.array()), cosc.column.value.array(), unavronateClock(cosc.column.clock));
         }
     }
     
@@ -446,14 +457,14 @@ private static void deleteColumnOrSuperColumnToRowMutation(RowMutation rm, Strin
             for (ByteBuffer col : del.predicate.column_names)
             {
                 if (del.super_column == null && DatabaseDescriptor.getColumnFamilyType(rm.getTable(), cfName) == ColumnFamilyType.Super)
-                    rm.delete(new QueryPath(cfName, col.array()), del.timestamp);
+                    rm.delete(new QueryPath(cfName, col.array()), unavronateClock(del.clock));
                 else
-                    rm.delete(new QueryPath(cfName, del.super_column.array(), col.array()), del.timestamp);
+                    rm.delete(new QueryPath(cfName, del.super_column.array(), col.array()), unavronateClock(del.clock));
             }
         }
         else
         {
-            rm.delete(new QueryPath(cfName, del.super_column.array()), del.timestamp);
+            rm.delete(new QueryPath(cfName, del.super_column.array()), unavronateClock(del.clock));
         }
     }
     
@@ -501,8 +512,9 @@ public Void system_add_keyspace(KsDef ksDef) throws AvroRemoteException, Invalid
             Collection<CFMetaData> cfDefs = new ArrayList<CFMetaData>((int)ksDef.cf_defs.size());
             for (CfDef cfDef : ksDef.cf_defs)
             {
-                String cfType, compare, subCompare;
+                String cfType, clockType, compare, subCompare;
                 cfType = cfDef.column_type == null ? D_CF_CFTYPE : cfDef.column_type.toString();
+                clockType = cfDef.clock_type == null ? D_CF_CFCLOCKTYPE : cfDef.clock_type.toString();
                 compare = cfDef.comparator_type == null ? D_CF_COMPTYPE : cfDef.comparator_type.toString();
                 subCompare = cfDef.subcomparator_type == null ? D_CF_SUBCOMPTYPE : cfDef.subcomparator_type.toString();
                 
@@ -510,6 +522,7 @@ public Void system_add_keyspace(KsDef ksDef) throws AvroRemoteException, Invalid
                         cfDef.keyspace.toString(),
                         cfDef.name.toString(),
                         ColumnFamilyType.create(cfType),
+                        ClockType.create(clockType),
                         DatabaseDescriptor.getComparator(compare),
                         subCompare.length() == 0 ? null : DatabaseDescriptor.getComparator(subCompare),
                         cfDef.comment == null ? D_CF_COMMENT : cfDef.comment.toString(), 
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/cli/CliClient.java b/cassandra/trunk/src/java/org/apache/cassandra/cli/CliClient.java
index 6b684596..3771d2ca 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/cli/CliClient.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/cli/CliClient.java
@@ -21,6 +21,7 @@
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.BytesType;
 import org.apache.cassandra.thrift.*;
+
 import org.apache.thrift.*;
 
 import org.antlr.runtime.tree.*;
@@ -228,8 +229,9 @@ else if (columnSpecCnt == 2)
             columnName = CliCompiler.getColumn(columnFamilySpec, 1).getBytes("UTF-8");
         }
 
+        Clock thrift_clock = new Clock().setTimestamp(timestampMicros());
         thriftClient_.remove(key.getBytes(), new ColumnPath(columnFamily).setSuper_column(superColumnName).setColumn(columnName),
-                             timestampMicros(), ConsistencyLevel.ONE);
+                             thrift_clock, ConsistencyLevel.ONE);
         css_.out.println(String.format("%s removed.", (columnSpecCnt == 0) ? "row" : "column"));
     }
 
@@ -259,7 +261,7 @@ private void doSlice(String keyspace, String key, String columnFamily, byte[] su
                 css_.out.printf("=> (super_column=%s,", formatSuperColumnName(keyspace, columnFamily, superColumn));
                 for (Column col : superColumn.getColumns())
                     css_.out.printf("\n     (column=%s, value=%s, timestamp=%d)", formatSubcolumnName(keyspace, columnFamily, col),
-                                    new String(col.value, "UTF-8"), col.timestamp);
+                                    new String(col.value, "UTF-8"), col.clock.timestamp);
                 
                 css_.out.println(")"); 
             }
@@ -267,7 +269,7 @@ private void doSlice(String keyspace, String key, String columnFamily, byte[] su
             {
                 Column column = cosc.column;
                 css_.out.printf("=> (column=%s, value=%s, timestamp=%d)\n", formatColumnName(keyspace, columnFamily, column),
-                                new String(column.value, "UTF-8"), column.timestamp);
+                                new String(column.value, "UTF-8"), column.clock.timestamp);
             }
         }
         
@@ -365,7 +367,7 @@ else if (columnSpecCnt == 2)
         ColumnPath path = new ColumnPath(columnFamily).setSuper_column(superColumnName).setColumn(columnName);
         Column column = thriftClient_.get(key.getBytes(), path, ConsistencyLevel.ONE).column;
         css_.out.printf("=> (column=%s, value=%s, timestamp=%d)\n", formatColumnName(keySpace, columnFamily, column),
-                        new String(column.value, "UTF-8"), column.timestamp);
+                        new String(column.value, "UTF-8"), column.clock.timestamp);
     }
 
     // Execute SET statement
@@ -410,8 +412,9 @@ else if (columnSpecCnt == 1)
         }
         
         // do the insert
+        Clock thrift_clock = new Clock().setTimestamp(timestampMicros());
         thriftClient_.insert(key.getBytes(), new ColumnParent(columnFamily).setSuper_column(superColumnName),
-                             new Column(columnName, value.getBytes(), timestampMicros()), ConsistencyLevel.ONE);
+                             new Column(columnName, value.getBytes(), thrift_clock), ConsistencyLevel.ONE);
         
         css_.out.println("Value inserted.");
     }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/CFMetaData.java b/cassandra/trunk/src/java/org/apache/cassandra/config/CFMetaData.java
index 909c967e..4bc22924 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/CFMetaData.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/CFMetaData.java
@@ -35,6 +35,7 @@
 import org.apache.commons.lang.builder.HashCodeBuilder;
 
 import org.apache.cassandra.db.ColumnFamilyType;
+import org.apache.cassandra.db.ClockType;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.utils.Pair;
 
@@ -54,10 +55,10 @@
     
     private static final BiMap<Pair<String, String>, Integer> cfIdMap = HashBiMap.<Pair<String, String>, Integer>create();
     
-    public static final CFMetaData StatusCf = new CFMetaData(Table.SYSTEM_TABLE, SystemTable.STATUS_CF, ColumnFamilyType.Standard, new UTF8Type(), null, "persistent metadata for the local node", 0, false, 0.01, 0);
-    public static final CFMetaData HintsCf = new CFMetaData(Table.SYSTEM_TABLE, HintedHandOffManager.HINTS_CF, ColumnFamilyType.Super, new UTF8Type(), new BytesType(), "hinted handoff data", 0, false, 0.01, 1);
-    public static final CFMetaData MigrationsCf = new CFMetaData(Table.SYSTEM_TABLE, Migration.MIGRATIONS_CF, ColumnFamilyType.Standard, new TimeUUIDType(), null, "individual schema mutations", 0, false, 2);
-    public static final CFMetaData SchemaCf = new CFMetaData(Table.SYSTEM_TABLE, Migration.SCHEMA_CF, ColumnFamilyType.Standard, new UTF8Type(), null, "current state of the schema", 0, false, 3);
+    public static final CFMetaData StatusCf = new CFMetaData(Table.SYSTEM_TABLE, SystemTable.STATUS_CF, ColumnFamilyType.Standard, ClockType.Timestamp, new UTF8Type(), null, "persistent metadata for the local node", 0, false, 0.01, 0);
+    public static final CFMetaData HintsCf = new CFMetaData(Table.SYSTEM_TABLE, HintedHandOffManager.HINTS_CF, ColumnFamilyType.Super, ClockType.Timestamp, new UTF8Type(), new BytesType(), "hinted handoff data", 0, false, 0.01, 1);
+    public static final CFMetaData MigrationsCf = new CFMetaData(Table.SYSTEM_TABLE, Migration.MIGRATIONS_CF, ColumnFamilyType.Standard, ClockType.Timestamp, new TimeUUIDType(), null, "individual schema mutations", 0, false, 2);
+    public static final CFMetaData SchemaCf = new CFMetaData(Table.SYSTEM_TABLE, Migration.SCHEMA_CF, ColumnFamilyType.Standard, ClockType.Timestamp, new UTF8Type(), null, "current state of the schema", 0, false, 3);
 
     /**
      * @return An immutable mapping of (ksname,cfname) to id.
@@ -101,6 +102,7 @@ public static final void fixMaxId()
     public final String tableName;            // name of table which has this column family
     public final String cfName;               // name of the column family
     public final ColumnFamilyType cfType;     // type: super, standard, etc.
+    public final ClockType clockType;         // clock type: timestamp, etc.
     public final AbstractType comparator;       // name sorted, time stamp sorted etc.
     public final AbstractType subcolumnComparator; // like comparator, for supercolumns
     public final String comment; // for humans only
@@ -111,11 +113,12 @@ public static final void fixMaxId()
     public boolean preloadRowCache;
 
 
-    private CFMetaData(String tableName, String cfName, ColumnFamilyType cfType, AbstractType comparator, AbstractType subcolumnComparator, String comment, double rowCacheSize, boolean preloadRowCache, double keyCacheSize, double readRepairChance, int cfId)
+    private CFMetaData(String tableName, String cfName, ColumnFamilyType cfType, ClockType clockType, AbstractType comparator, AbstractType subcolumnComparator, String comment, double rowCacheSize, boolean preloadRowCache, double keyCacheSize, double readRepairChance, int cfId)
     {
         this.tableName = tableName;
         this.cfName = cfName;
         this.cfType = cfType;
+        this.clockType = clockType;
         this.comparator = comparator;
         this.subcolumnComparator = subcolumnComparator;
         this.comment = comment;
@@ -139,27 +142,27 @@ public static void map(CFMetaData cfm) throws ConfigurationException
         }
     }
     
-    public CFMetaData(String tableName, String cfName, ColumnFamilyType cfType, AbstractType comparator, AbstractType subcolumnComparator, String comment, double rowCacheSize, boolean preloadRowCache, double keyCacheSize)
+    public CFMetaData(String tableName, String cfName, ColumnFamilyType cfType, ClockType clockType, AbstractType comparator, AbstractType subcolumnComparator, String comment, double rowCacheSize, boolean preloadRowCache, double keyCacheSize)
     {
-        this(tableName, cfName, cfType, comparator, subcolumnComparator, comment, rowCacheSize, preloadRowCache, keyCacheSize, DEFAULT_READ_REPAIR_CHANCE, nextId());
+        this(tableName, cfName, cfType, clockType, comparator, subcolumnComparator, comment, rowCacheSize, preloadRowCache, keyCacheSize, DEFAULT_READ_REPAIR_CHANCE, nextId());
     }
 
-    public CFMetaData(String tableName, String cfName, ColumnFamilyType cfType, AbstractType comparator, AbstractType subcolumnComparator, String comment, double rowCacheSize, boolean preloadRowCache, double keyCacheSize, double readRepairChance)
+    public CFMetaData(String tableName, String cfName, ColumnFamilyType cfType, ClockType clockType, AbstractType comparator, AbstractType subcolumnComparator, String comment, double rowCacheSize, boolean preloadRowCache, double keyCacheSize, double readRepairChance)
     {
-        this(tableName, cfName, cfType, comparator, subcolumnComparator, comment, rowCacheSize, preloadRowCache, keyCacheSize, readRepairChance, nextId());
+        this(tableName, cfName, cfType, clockType, comparator, subcolumnComparator, comment, rowCacheSize, preloadRowCache, keyCacheSize, readRepairChance, nextId());
     }
 
     /** clones an existing CFMetaData using the same id. */
     public static CFMetaData rename(CFMetaData cfm, String newName)
     {
-        CFMetaData newCfm = new CFMetaData(cfm.tableName, newName, cfm.cfType, cfm.comparator, cfm.subcolumnComparator, cfm.comment, cfm.rowCacheSize, cfm.preloadRowCache, cfm.keyCacheSize, cfm.readRepairChance, cfm.cfId);
+        CFMetaData newCfm = new CFMetaData(cfm.tableName, newName, cfm.cfType, cfm.clockType, cfm.comparator, cfm.subcolumnComparator, cfm.comment, cfm.rowCacheSize, cfm.preloadRowCache, cfm.keyCacheSize, cfm.readRepairChance, cfm.cfId);
         return newCfm;
     }
     
     /** clones existing CFMetaData. keeps the id but changes the table name.*/
     public static CFMetaData renameTable(CFMetaData cfm, String tableName)
     {
-        return new CFMetaData(tableName, cfm.cfName, cfm.cfType, cfm.comparator, cfm.subcolumnComparator, cfm.comment, cfm.rowCacheSize, cfm.preloadRowCache, cfm.keyCacheSize, cfm.readRepairChance, cfm.cfId);
+        return new CFMetaData(tableName, cfm.cfName, cfm.cfType, cfm.clockType, cfm.comparator, cfm.subcolumnComparator, cfm.comment, cfm.rowCacheSize, cfm.preloadRowCache, cfm.keyCacheSize, cfm.readRepairChance, cfm.cfId);
     }
     
     /** used for evicting cf data out of static tracking collections. */
@@ -174,6 +177,7 @@ public String pretty()
     {
         return tableName + "." + cfName + "\n"
                + "Column Family Type: " + cfType + "\n"
+               + "Column Family Clock Type: " + clockType + "\n"
                + "Columns Sorted By: " + comparator + "\n";
     }
 
@@ -184,6 +188,7 @@ public String pretty()
         dout.writeUTF(cfm.tableName);
         dout.writeUTF(cfm.cfName);
         dout.writeUTF(cfm.cfType.name());
+        dout.writeUTF(cfm.clockType.name());
         dout.writeUTF(cfm.comparator.getClass().getName());
         dout.writeBoolean(cfm.subcolumnComparator != null);
         if (cfm.subcolumnComparator != null)
@@ -206,6 +211,7 @@ public static CFMetaData deserialize(InputStream in) throws IOException
         String tableName = din.readUTF();
         String cfName = din.readUTF();
         ColumnFamilyType cfType = ColumnFamilyType.create(din.readUTF());
+        ClockType clockType = ClockType.create(din.readUTF());
         AbstractType comparator = null;
         try
         {
@@ -230,7 +236,7 @@ public static CFMetaData deserialize(InputStream in) throws IOException
         double keyCacheSize = din.readDouble();
         double readRepairChance = din.readDouble();
         int cfId = din.readInt();
-        return new CFMetaData(tableName, cfName, cfType, comparator, subcolumnComparator, comment, rowCacheSize, preloadRowCache, keyCacheSize, readRepairChance, cfId);
+        return new CFMetaData(tableName, cfName, cfType, clockType, comparator, subcolumnComparator, comment, rowCacheSize, preloadRowCache, keyCacheSize, readRepairChance, cfId);
     }
     
 
@@ -250,6 +256,7 @@ else if (obj == null || obj.getClass() != getClass())
             .append(tableName, rhs.tableName)
             .append(cfName, rhs.cfName)
             .append(cfType, rhs.cfType)
+            .append(clockType, rhs.clockType)
             .append(comparator, rhs.comparator)
             .append(subcolumnComparator, rhs.subcolumnComparator)
             .append(comment, rhs.comment)
@@ -266,6 +273,7 @@ public int hashCode()
             .append(tableName)
             .append(cfName)
             .append(cfType)
+            .append(clockType)
             .append(comparator)
             .append(subcolumnComparator)
             .append(comment)
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java b/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
index 96249767..84d1213e 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
@@ -511,7 +511,7 @@ else if (cf.compare_subcolumns_with != null)
                 {                        
                     throw new ConfigurationException("read_repair_chance must be between 0.0 and 1.0");
                 }
-                cfDefs[j++] = new CFMetaData(keyspace.name, cf.name, cfType, comparator, subcolumnComparator, cf.comment, cf.rows_cached, cf.preload_row_cache, cf.keys_cached, cf.read_repair_chance);
+                cfDefs[j++] = new CFMetaData(keyspace.name, cf.name, cfType, ClockType.Timestamp, comparator, subcolumnComparator, cf.comment, cf.rows_cached, cf.preload_row_cache, cf.keys_cached, cf.read_repair_chance);
             }
             defs.add(new KSMetaData(keyspace.name, strategyClass, keyspace.replication_factor, cfDefs));
             
@@ -714,6 +714,15 @@ public static ColumnFamilyType getColumnFamilyType(String tableName, String cfNa
         return cfMetaData.cfType;
     }
 
+    public static ClockType getClockType(String tableName, String cfName)
+    {
+        assert tableName != null && cfName != null;
+        CFMetaData cfMetaData = getCFMetaData(tableName, cfName);
+
+        assert (cfMetaData != null);
+        return cfMetaData.clockType;
+    }
+
     public static Set<String> getTables()
     {
         return tables.keySet();
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/ClockType.java b/cassandra/trunk/src/java/org/apache/cassandra/db/ClockType.java
index e69de29b..3f4ad1b7 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/ClockType.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/ClockType.java
@@ -0,0 +1,48 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.cassandra.db;
+
+import org.apache.cassandra.io.ICompactSerializer2;
+
+public enum ClockType
+{
+    Timestamp;
+
+    public final static ClockType create(String name)
+    {
+        assert name != null;
+        try
+        {
+            return ClockType.valueOf(name);
+        }
+        catch (IllegalArgumentException e)
+        {
+            return null;
+        }
+    }
+
+    public final IClock minClock()
+    {
+        return TimestampClock.MIN_VALUE;
+    }
+
+    public final ICompactSerializer2<IClock> serializer()
+    {
+        return TimestampClock.SERIALIZER;
+    }
+}
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/Column.java b/cassandra/trunk/src/java/org/apache/cassandra/db/Column.java
index 39257352..8fc59c51 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/Column.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/Column.java
@@ -27,6 +27,7 @@
 import org.apache.commons.lang.ArrayUtils;
 
 import org.apache.cassandra.db.marshal.AbstractType;
+import org.apache.cassandra.db.IClock.ClockRelationship;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.utils.FBUtilities;
 
@@ -41,16 +42,14 @@
 {
     private static Logger logger = LoggerFactory.getLogger(Column.class);
 
-    private static ColumnSerializer serializer = new ColumnSerializer();
-
-    public static ColumnSerializer serializer()
+    public static ColumnSerializer serializer(ClockType clockType)
     {
-        return serializer;
+        return new ColumnSerializer(clockType);
     }
 
     protected final byte[] name;
     protected final byte[] value;
-    protected final long timestamp;
+    protected final IClock clock;
 
     Column(byte[] name)
     {
@@ -59,17 +58,18 @@ public static ColumnSerializer serializer()
 
     public Column(byte[] name, byte[] value)
     {
-        this(name, value, 0);
+        // safe to set to null, only used for filter comparisons
+        this(name, value, null);
     }
 
-    public Column(byte[] name, byte[] value, long timestamp)
+    public Column(byte[] name, byte[] value, IClock clock)
     {
         assert name != null;
         assert value != null;
         assert name.length <= IColumn.MAX_NAME_LENGTH;
         this.name = name;
         this.value = value;
-        this.timestamp = timestamp;
+        this.clock = clock;
     }
 
     public byte[] name()
@@ -97,9 +97,9 @@ public int getObjectCount()
         return 1;
     }
 
-    public long timestamp()
+    public IClock clock()
     {
-        return timestamp;
+        return clock;
     }
 
     public boolean isMarkedForDelete()
@@ -107,14 +107,14 @@ public boolean isMarkedForDelete()
         return false;
     }
 
-    public long getMarkedForDeleteAt()
+    public IClock getMarkedForDeleteAt()
     {
         throw new IllegalStateException("column is not marked for delete");
     }
 
-    public long mostRecentLiveChangeAt()
+    public IClock mostRecentLiveChangeAt()
     {
-        return timestamp;
+        return clock;
     }
 
     public int size()
@@ -123,11 +123,11 @@ public int size()
          * Size of a column is =
          *   size of a name (short + length of the string)
          * + 1 byte to indicate if the column has been deleted
-         * + 8 bytes for timestamp
+         * + x bytes depending on IClock size
          * + 4 bytes which basically indicates the size of the byte array
          * + entire byte array.
         */
-        return DBConstants.shortSize_ + name.length + DBConstants.boolSize_ + DBConstants.tsSize_ + DBConstants.intSize_ + value.length;
+        return DBConstants.shortSize_ + name.length + DBConstants.boolSize_ + clock.size() + DBConstants.intSize_ + value.length;
     }
 
     /*
@@ -146,7 +146,7 @@ public void addColumn(IColumn column)
 
     public IColumn diff(IColumn column)
     {
-        if (timestamp() < column.timestamp())
+        if (ClockRelationship.GREATER_THAN == column.clock().compare(clock))
         {
             return column;
         }
@@ -160,7 +160,7 @@ public void updateDigest(MessageDigest digest)
         DataOutputBuffer buffer = new DataOutputBuffer();
         try
         {
-            buffer.writeLong(timestamp);
+            clock.serialize(buffer);
             buffer.writeByte((isMarkedForDelete()) ? ColumnSerializer.DELETION_MASK : 0);
         }
         catch (IOException e)
@@ -176,20 +176,46 @@ public int getLocalDeletionTime()
     }
 
     // note that we do not call this simply compareTo since it also makes sense to compare Columns by name
-    public long comparePriority(Column o)
+    public ClockRelationship comparePriority(Column o)
     {
+        ClockRelationship rel = clock.compare(o.clock());
+
         // tombstone always wins ties.
         if (isMarkedForDelete())
-            return timestamp < o.timestamp ? -1 : 1;
+        {
+            switch (rel)
+            {
+                case EQUAL:
+                    return ClockRelationship.GREATER_THAN;
+                default:
+                    return rel;
+            }
+        }
         if (o.isMarkedForDelete())
-            return timestamp > o.timestamp ? 1 : -1;
+        {
+            switch (rel)
+            {
+                case EQUAL:
+                    return ClockRelationship.LESS_THAN;
+                default:
+                    return rel;
+            }
+        }
         
-        // compare value as tie-breaker for equal timestamps
-        if (timestamp == o.timestamp)
-            return FBUtilities.compareByteArrays(value, o.value);
+        // compare value as tie-breaker for equal clocks
+        if (ClockRelationship.EQUAL == rel)
+        {
+            int valRel = FBUtilities.compareByteArrays(value, o.value);
+            if (1 == valRel)
+                return ClockRelationship.GREATER_THAN;
+            if (0 == valRel)
+                return ClockRelationship.EQUAL;
+            // -1 == valRel
+            return ClockRelationship.LESS_THAN;
+        }
 
-        // neither is tombstoned and timestamps are different
-        return timestamp - o.timestamp;
+        // neither is tombstoned and clocks are different
+        return rel;
     }
 
     public String getString(AbstractType comparator)
@@ -201,7 +227,7 @@ public String getString(AbstractType comparator)
         sb.append(":");
         sb.append(value.length);
         sb.append("@");
-        sb.append(timestamp());
+        sb.append(clock.toString());
         return sb.toString();
     }
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamily.java b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamily.java
index 7e3d6522..c7008b21 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamily.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamily.java
@@ -28,11 +28,13 @@
 import java.security.NoSuchAlgorithmException;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
 
 import org.apache.cassandra.config.CFMetaData;
 
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.io.ICompactSerializer2;
+import org.apache.cassandra.db.IClock.ClockRelationship;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.utils.FBUtilities;
@@ -62,28 +64,31 @@ public static ColumnFamily create(CFMetaData cfm)
     {
         if (cfm == null)
             throw new IllegalArgumentException("Unknown column family.");
-        return new ColumnFamily(cfm.cfType, cfm.comparator, cfm.subcolumnComparator, cfm.cfId);
+        return new ColumnFamily(cfm.cfType, cfm.clockType, cfm.comparator, cfm.subcolumnComparator, cfm.cfId);
     }
 
     private final int cfid;
     private final ColumnFamilyType type;
+    private final ClockType clockType;
 
     private transient ICompactSerializer2<IColumn> columnSerializer;
-    final AtomicLong markedForDeleteAt = new AtomicLong(Long.MIN_VALUE);
+    final AtomicReference<IClock> markedForDeleteAt;
     final AtomicInteger localDeletionTime = new AtomicInteger(Integer.MIN_VALUE);
     private ConcurrentSkipListMap<byte[], IColumn> columns;
 
-    public ColumnFamily(ColumnFamilyType type, AbstractType comparator, AbstractType subcolumnComparator, int cfid)
+    public ColumnFamily(ColumnFamilyType type, ClockType clockType, AbstractType comparator, AbstractType subcolumnComparator, int cfid)
     {
         this.type = type;
-        columnSerializer = type == ColumnFamilyType.Standard ? Column.serializer() : SuperColumn.serializer(subcolumnComparator);
+        this.clockType = clockType;
+        this.markedForDeleteAt = new AtomicReference<IClock>(clockType.minClock());
+        columnSerializer = type == ColumnFamilyType.Standard ? Column.serializer(clockType) : SuperColumn.serializer(subcolumnComparator, clockType);
         columns = new ConcurrentSkipListMap<byte[], IColumn>(comparator);
         this.cfid = cfid;
      }
     
     public ColumnFamily cloneMeShallow()
     {
-        ColumnFamily cf = new ColumnFamily(type, getComparator(), getSubComparator(), cfid);
+        ColumnFamily cf = new ColumnFamily(type, clockType, getComparator(), getSubComparator(), cfid);
         cf.markedForDeleteAt.set(markedForDeleteAt.get());
         cf.localDeletionTime.set(localDeletionTime.get());
         return cf;
@@ -99,6 +104,11 @@ public ColumnFamilyType getColumnFamilyType()
         return type;
     }
 
+    public ClockType getClockType()
+    {
+        return clockType;
+    }
+
     public ColumnFamily cloneMe()
     {
         ColumnFamily cf = cloneMeShallow();
@@ -156,32 +166,32 @@ public boolean isSuper()
         return type == ColumnFamilyType.Super;
     }
 
-    public void addColumn(QueryPath path, byte[] value, long timestamp)
+    public void addColumn(QueryPath path, byte[] value, IClock clock)
     {
         assert path.columnName != null : path;
-        addColumn(path.superColumnName, new Column(path.columnName, value, timestamp));
+        addColumn(path.superColumnName, new Column(path.columnName, value, clock));
     }
 
-    public void addTombstone(QueryPath path, byte[] localDeletionTime, long timestamp)
+    public void addTombstone(QueryPath path, byte[] localDeletionTime, IClock clock)
     {
-        addColumn(path.superColumnName, new DeletedColumn(path.columnName, localDeletionTime, timestamp));
+        addColumn(path.superColumnName, new DeletedColumn(path.columnName, localDeletionTime, clock));
     }
 
-    public void addColumn(QueryPath path, byte[] value, long timestamp, int timeToLive)
+    public void addColumn(QueryPath path, byte[] value, IClock clock, int timeToLive)
     {
         assert path.columnName != null : path;
         Column column;
         if (timeToLive > 0)
-            column = new ExpiringColumn(path.columnName, value, timestamp, timeToLive);
+            column = new ExpiringColumn(path.columnName, value, clock, timeToLive);
         else
-            column = new Column(path.columnName, value, timestamp);
+            column = new Column(path.columnName, value, clock);
         addColumn(path.superColumnName, column);
     }
 
-    public void deleteColumn(QueryPath path, int localDeletionTime, long timestamp)
+    public void deleteColumn(QueryPath path, int localDeletionTime, IClock clock)
     {
         assert path.columnName != null : path;
-        addColumn(path.superColumnName, new DeletedColumn(path.columnName, localDeletionTime, timestamp));
+        addColumn(path.superColumnName, new DeletedColumn(path.columnName, localDeletionTime, clock));
     }
 
     public void addColumn(byte[] superColumnName, Column column)
@@ -194,7 +204,7 @@ public void addColumn(byte[] superColumnName, Column column)
         else
         {
             assert isSuper();
-            c = new SuperColumn(superColumnName, getSubComparator());
+            c = new SuperColumn(superColumnName, getSubComparator(), clockType);
             c.addColumn(column); // checks subcolumn name
         }
         addColumn(c);
@@ -221,7 +231,7 @@ public void addColumn(IColumn column)
             }
             else
             {
-                while (((Column) oldColumn).comparePriority((Column)column) <= 0)
+                while (ClockRelationship.GREATER_THAN != ((Column) oldColumn).comparePriority((Column) column))
                 {
                     if (columns.replace(name, oldColumn, column))
                         break;
@@ -257,10 +267,10 @@ public void remove(byte[] columnName)
     }
 
     @Deprecated // TODO this is a hack to set initial value outside constructor
-    public void delete(int localtime, long timestamp)
+    public void delete(int localtime, IClock clock)
     {
         localDeletionTime.set(localtime);
-        markedForDeleteAt.set(timestamp);
+        markedForDeleteAt.set(clock);
     }
 
     public void delete(ColumnFamily cf2)
@@ -271,7 +281,8 @@ public void delete(ColumnFamily cf2)
 
     public boolean isMarkedForDelete()
     {
-        return markedForDeleteAt.get() > Long.MIN_VALUE;
+        IClock _markedForDeleteAt = markedForDeleteAt.get();
+        return _markedForDeleteAt.compare(clockType.minClock()) == ClockRelationship.GREATER_THAN;
     }
 
     /*
@@ -280,8 +291,9 @@ public boolean isMarkedForDelete()
      */
     public ColumnFamily diff(ColumnFamily cfComposite)
     {
-        ColumnFamily cfDiff = new ColumnFamily(cfComposite.type, getComparator(), getSubComparator(), cfComposite.id());
-        if (cfComposite.getMarkedForDeleteAt() > getMarkedForDeleteAt())
+        ColumnFamily cfDiff = new ColumnFamily(cfComposite.type, cfComposite.clockType, getComparator(), getSubComparator(), cfComposite.id());
+        ClockRelationship rel = cfComposite.getMarkedForDeleteAt().compare(getMarkedForDeleteAt());
+        if (ClockRelationship.GREATER_THAN == rel)
         {
             cfDiff.delete(cfComposite.getLocalDeletionTime(), cfComposite.getMarkedForDeleteAt());
         }
@@ -346,7 +358,7 @@ public String toString()
         sb.append(cfm == null ? "-deleted-" : cfm.cfName);
 
         if (isMarkedForDelete())
-            sb.append(" -deleted at " + getMarkedForDeleteAt() + "-");
+            sb.append(" -deleted at " + getMarkedForDeleteAt().toString() + "-");
 
         sb.append(" [").append(getComparator().getColumnsString(getSortedColumns())).append("])");
         return sb.toString();
@@ -375,7 +387,7 @@ public void updateDigest(MessageDigest digest)
             column.updateDigest(digest);
     }
 
-    public long getMarkedForDeleteAt()
+    public IClock getMarkedForDeleteAt()
     {
         return markedForDeleteAt.get();
     }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java
index fb6f76b2..0c92d827 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilySerializer.java
@@ -74,7 +74,8 @@ public void serializeForSSTable(ColumnFamily columnFamily, DataOutput dos)
         try
         {
             dos.writeInt(columnFamily.localDeletionTime.get());
-            dos.writeLong(columnFamily.markedForDeleteAt.get());
+            IClock _markedForDeleteAt = columnFamily.markedForDeleteAt.get();
+            columnFamily.getClockType().serializer().serialize(_markedForDeleteAt, dos);
 
             Collection<IColumn> columns = columnFamily.getSortedColumns();
             dos.writeInt(columns.size());
@@ -141,7 +142,7 @@ private AbstractType readComparator(DataInput dis) throws IOException
 
     public ColumnFamily deserializeFromSSTableNoColumns(ColumnFamily cf, DataInput input) throws IOException
     {
-        cf.delete(input.readInt(), input.readLong());
+        cf.delete(input.readInt(), cf.getClockType().serializer().deserialize(input));
         return cf;
     }
 
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index 9b7775d1..6c81d364 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -41,6 +41,8 @@
 import org.apache.cassandra.concurrent.StageManager;
 import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.config.DatabaseDescriptor;
+import org.apache.cassandra.db.IClock;
+import org.apache.cassandra.db.IClock.ClockRelationship;
 import org.apache.cassandra.db.commitlog.CommitLog;
 import org.apache.cassandra.db.commitlog.CommitLogSegment;
 import org.apache.cassandra.db.filter.*;
@@ -484,11 +486,19 @@ private static void removeDeletedStandard(ColumnFamily cf, int gcBefore)
         for (byte[] cname : cf.getColumnNames())
         {
             IColumn c = cf.getColumnsMap().get(cname);
-            if ((c.isMarkedForDelete() && c.getLocalDeletionTime() <= gcBefore)
-                || c.timestamp() <= cf.getMarkedForDeleteAt())
+            // we split the test to avoid comparing if not necessary
+            if ((c.isMarkedForDelete() && c.getLocalDeletionTime() <= gcBefore))
             {
                 cf.remove(cname);
             }
+            else
+            {
+                ClockRelationship rel = c.clock().compare(cf.getMarkedForDeleteAt());
+                if ((ClockRelationship.LESS_THAN == rel) || (ClockRelationship.EQUAL == rel))
+                {
+                    cf.remove(cname);
+                }
+            }
         }
     }
 
@@ -500,14 +510,23 @@ private static void removeDeletedSuper(ColumnFamily cf, int gcBefore)
         for (byte[] cname : cf.getColumnNames())
         {
             IColumn c = cf.getColumnsMap().get(cname);
-            long minTimestamp = Math.max(c.getMarkedForDeleteAt(), cf.getMarkedForDeleteAt());
+            List<IClock> clocks = Arrays.asList(cf.getMarkedForDeleteAt());
+            IClock minClock = c.getMarkedForDeleteAt().getSuperset(clocks);
             for (IColumn subColumn : c.getSubColumns())
             {
-                if (subColumn.timestamp() <= minTimestamp
-                    || (subColumn.isMarkedForDelete() && subColumn.getLocalDeletionTime() <= gcBefore))
+                // we split the test to avoid comparing if not necessary
+                if (subColumn.isMarkedForDelete() && subColumn.getLocalDeletionTime() <= gcBefore)
                 {
                     ((SuperColumn)c).remove(subColumn.name());
                 }
+                else
+                {
+                    ClockRelationship subRel = subColumn.clock().compare(minClock);
+                    if ((ClockRelationship.LESS_THAN == subRel) || (ClockRelationship.EQUAL == subRel))
+                    {
+                        ((SuperColumn)c).remove(subColumn.name());
+                    }
+                }
             }
             if (c.getSubColumns().isEmpty() && c.getLocalDeletionTime() <= gcBefore)
             {
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnSerializer.java b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnSerializer.java
index a6aa40ab..c27a6dbc 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnSerializer.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnSerializer.java
@@ -33,6 +33,13 @@
     public final static int DELETION_MASK = 0x01;
     public final static int EXPIRATION_MASK = 0x02;
 
+    private ClockType clockType;
+
+    public ColumnSerializer(ClockType clockType)
+    {
+        this.clockType = clockType;
+    }
+    
     public void serialize(IColumn column, DataOutput dos)
     {
         FBUtilities.writeShortByteArray(column.name(), dos);
@@ -45,7 +52,7 @@ public void serialize(IColumn column, DataOutput dos)
             } else {
               dos.writeByte((column.isMarkedForDelete()) ? DELETION_MASK : 0);
             }
-            dos.writeLong(column.timestamp());
+            clockType.serializer().serialize(column.clock(), dos);
             FBUtilities.writeByteArray(column.value(), dos);
         }
         catch (IOException e)
@@ -62,7 +69,7 @@ public Column deserialize(DataInput dis) throws IOException
         {
             int ttl = dis.readInt();
             int expiration = dis.readInt();
-            long ts = dis.readLong();
+            IClock clock = clockType.serializer().deserialize(dis);
             byte[] value = FBUtilities.readByteArray(dis);
             if ((int) (System.currentTimeMillis() / 1000 ) > expiration)
             {
@@ -70,22 +77,22 @@ public Column deserialize(DataInput dis) throws IOException
                 // tombstone
                 ByteBuffer bytes = ByteBuffer.allocate(4);
                 bytes.putInt(expiration);
-                return new DeletedColumn(name, bytes.array(), ts);
+                return new DeletedColumn(name, bytes.array(), clock);
             }
             else
             {
-                return new ExpiringColumn(name, value, ts, ttl, expiration);
+                return new ExpiringColumn(name, value, clock, ttl, expiration);
             }
         }
         else
         {
             boolean delete = FBUtilities.testBitUsingBitMask(b, DELETION_MASK);
-            long ts = dis.readLong();
+            IClock clock = clockType.serializer().deserialize(dis);
             byte[] value = FBUtilities.readByteArray(dis);
             if (FBUtilities.testBitUsingBitMask(b, DELETION_MASK)) {
-                return new DeletedColumn(name, value, ts);
+                return new DeletedColumn(name, value, clock);
             } else {
-                return new Column(name, value, ts);
+                return new Column(name, value, clock);
             }
         }
     }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/DefsTable.java b/cassandra/trunk/src/java/org/apache/cassandra/db/DefsTable.java
index 869ff3d5..99c1ca3b 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/DefsTable.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/DefsTable.java
@@ -51,12 +51,12 @@ public static synchronized void dumpToStorage(UUID version) throws IOException
         for (String tableName : DatabaseDescriptor.getNonSystemTables())
         {
             KSMetaData ks = DatabaseDescriptor.getTableDefinition(tableName);
-            rm.add(new QueryPath(Migration.SCHEMA_CF, null, ks.name.getBytes()), KSMetaData.serialize(ks), now);
+            rm.add(new QueryPath(Migration.SCHEMA_CF, null, ks.name.getBytes()), KSMetaData.serialize(ks), new TimestampClock(now));
         }
         rm.apply();
         
         rm = new RowMutation(Table.SYSTEM_TABLE, Migration.LAST_MIGRATION_KEY);
-        rm.add(new QueryPath(Migration.SCHEMA_CF, null, Migration.LAST_MIGRATION_KEY), UUIDGen.decompose(version), now);
+        rm.add(new QueryPath(Migration.SCHEMA_CF, null, Migration.LAST_MIGRATION_KEY), UUIDGen.decompose(version), new TimestampClock(now));
         rm.apply();
     }
 
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/DeletedColumn.java b/cassandra/trunk/src/java/org/apache/cassandra/db/DeletedColumn.java
index 89c08398..239d3b92 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/DeletedColumn.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/DeletedColumn.java
@@ -28,14 +28,14 @@
 {
     private static Logger logger = LoggerFactory.getLogger(DeletedColumn.class);
     
-    public DeletedColumn(byte[] name, int localDeletionTime, long timestamp)
+    public DeletedColumn(byte[] name, int localDeletionTime, IClock clock)
     {
-        this(name, FBUtilities.toByteArray(localDeletionTime), timestamp);
+        this(name, FBUtilities.toByteArray(localDeletionTime), clock);
     }
 
-    public DeletedColumn(byte[] name, byte[] value, long ts)
+    public DeletedColumn(byte[] name, byte[] value, IClock clock)
     {
-        super(name, value, ts);
+        super(name, value, clock);
     }
 
     @Override
@@ -45,9 +45,9 @@ public boolean isMarkedForDelete()
     }
 
     @Override
-    public long getMarkedForDeleteAt()
+    public IClock getMarkedForDeleteAt()
     {
-        return timestamp;
+        return clock;
     }
 
     @Override
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/ExpiringColumn.java b/cassandra/trunk/src/java/org/apache/cassandra/db/ExpiringColumn.java
index 19b2f22d..12f7801a 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/ExpiringColumn.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/ExpiringColumn.java
@@ -43,14 +43,14 @@
     private final int localExpirationTime;
     private final int timeToLive;
 
-    public ExpiringColumn(byte[] name, byte[] value, long timestamp, int timeToLive)
+    public ExpiringColumn(byte[] name, byte[] value, IClock clock, int timeToLive)
     {
-      this(name, value, timestamp, timeToLive, (int) (System.currentTimeMillis() / 1000) + timeToLive);
+      this(name, value, clock, timeToLive, (int) (System.currentTimeMillis() / 1000) + timeToLive);
     }
 
-    public ExpiringColumn(byte[] name, byte[] value, long timestamp, int timeToLive, int localExpirationTime)
+    public ExpiringColumn(byte[] name, byte[] value, IClock clock, int timeToLive, int localExpirationTime)
     {
-        super(name, value, timestamp);
+        super(name, value, clock);
         assert timeToLive > 0;
         assert localExpirationTime > 0;
         this.timeToLive = timeToLive;
@@ -87,7 +87,7 @@ public void updateDigest(MessageDigest digest)
         DataOutputBuffer buffer = new DataOutputBuffer();
         try
         {
-            buffer.writeLong(timestamp());
+            clock.serialize(buffer);
             buffer.writeByte(ColumnSerializer.EXPIRATION_MASK);
             buffer.writeInt(timeToLive);
         }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/HintedHandOffManager.java b/cassandra/trunk/src/java/org/apache/cassandra/db/HintedHandOffManager.java
index eb3a7836..ab1cf1d5 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/HintedHandOffManager.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/HintedHandOffManager.java
@@ -143,14 +143,14 @@ private static boolean sendMessage(InetAddress endpoint, String tableName, byte[
     private static void deleteEndpoint(byte[] endpointAddress, String tableName, byte[] key, long timestamp) throws IOException
     {
         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, tableName.getBytes(UTF8));
-        rm.delete(new QueryPath(HINTS_CF, key, endpointAddress), timestamp);
+        rm.delete(new QueryPath(HINTS_CF, key, endpointAddress), new TimestampClock(timestamp));
         rm.apply();
     }
 
     private static void deleteHintKey(String tableName, byte[] key) throws IOException
     {
         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, tableName.getBytes(UTF8));
-        rm.delete(new QueryPath(HINTS_CF, key, null), System.currentTimeMillis());
+        rm.delete(new QueryPath(HINTS_CF, key, null), new TimestampClock(System.currentTimeMillis()));
         rm.apply();
     }
 
@@ -294,7 +294,7 @@ public static void renameHints(String oldTable, String newTable) throws IOExcept
             RowMutation drop = new RowMutation(Table.SYSTEM_TABLE, oldTableKey.key);
             for (byte[] key : cf.getColumnNames())
             {
-                drop.delete(new QueryPath(HINTS_CF, key), now);
+                drop.delete(new QueryPath(HINTS_CF, key), new TimestampClock(now));
                 startCol = key;
             }
             drop.apply();
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/IClock.java b/cassandra/trunk/src/java/org/apache/cassandra/db/IClock.java
index e69de29b..9e7d487d 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/IClock.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/IClock.java
@@ -0,0 +1,72 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.db;
+
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.List;
+
+/**
+ * A clock used for conflict resolution.
+ */
+public interface IClock
+{
+    public static enum ClockRelationship
+    {
+        EQUAL,
+        GREATER_THAN,
+        LESS_THAN,
+        DISJOINT
+    };
+
+    /**
+     * @param other Compare these two clocks.
+     * @return The relationship between the two clocks,
+     * lets us know if reconciliation will have to take place.
+     */
+    public ClockRelationship compare(IClock other);
+
+    /**
+     * @param otherClocks The other clock to use when extracting the superset.
+     * @return The superset of the two clocks.
+     */
+    public IClock getSuperset(List<IClock> otherClocks);
+
+    /**
+     * @return number of bytes this type of clock
+     * uses up when serialized.
+     */
+    public int size();
+
+    /**
+     * @return the type of this clock.
+     */
+    public ClockType type();
+
+    /**
+     * @param out Write a serialized representation of this clock to the output.
+     * @throws IOException Thrown if writing failed.
+     */
+    public void serialize(DataOutput out) throws IOException;
+
+    /**
+     * @return a textual representation of this clock.
+     */
+    public String toString();
+}
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/IColumn.java b/cassandra/trunk/src/java/org/apache/cassandra/db/IColumn.java
index 611e3d48..5c3fdaa5 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/IColumn.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/IColumn.java
@@ -29,12 +29,12 @@
     public static final int MAX_NAME_LENGTH = FBUtilities.MAX_UNSIGNED_SHORT;
 
     public boolean isMarkedForDelete();
-    public long getMarkedForDeleteAt();
-    public long mostRecentLiveChangeAt();
+    public IClock getMarkedForDeleteAt();
+    public IClock mostRecentLiveChangeAt();
     public byte[] name();
     public int size();
     public int serializedSize();
-    public long timestamp();
+    public IClock clock();
     public byte[] value();
     public Collection<IColumn> getSubColumns();
     public IColumn getSubColumn(byte[] columnName);
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/IColumnContainer.java b/cassandra/trunk/src/java/org/apache/cassandra/db/IColumnContainer.java
index c22f1c8c..17804fb4 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/IColumnContainer.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/IColumnContainer.java
@@ -28,7 +28,7 @@
     public void addColumn(IColumn column);
 
     public boolean isMarkedForDelete();
-    public long getMarkedForDeleteAt();
+    public IClock getMarkedForDeleteAt();
 
     public AbstractType getComparator();
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/Memtable.java b/cassandra/trunk/src/java/org/apache/cassandra/db/Memtable.java
index e4498d42..aebade34 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/Memtable.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/Memtable.java
@@ -219,7 +219,7 @@ public static IColumnIterator getSliceIterator(final DecoratedKey key, final Col
         if (isStandard)
             startIColumn = new Column(filter.start);
         else
-            startIColumn = new SuperColumn(filter.start, null); // ok to not have subcolumnComparator since we won't be adding columns to this object
+            startIColumn = new SuperColumn(filter.start, null, cf.getClockType()); // ok to not have subcolumnComparator since we won't be adding columns to this object
 
         // can't use a ColumnComparatorFactory comparator since those compare on both name and time (and thus will fail to match
         // our dummy column, since the time there is arbitrary).
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutation.java b/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutation.java
index 79e844da..3368d14f 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutation.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/RowMutation.java
@@ -36,6 +36,7 @@
 import org.apache.cassandra.thrift.ColumnOrSuperColumn;
 import org.apache.cassandra.thrift.Deletion;
 import org.apache.cassandra.thrift.Mutation;
+import org.apache.cassandra.thrift.Clock;
 import org.apache.cassandra.utils.FBUtilities;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.config.CFMetaData;
@@ -100,7 +101,7 @@ public String getTable()
     void addHints(byte[] key, byte[] host) throws IOException
     {
         QueryPath path = new QueryPath(HintedHandOffManager.HINTS_CF, key, host);
-        add(path, ArrayUtils.EMPTY_BYTE_ARRAY, System.currentTimeMillis());
+        add(path, ArrayUtils.EMPTY_BYTE_ARRAY, new TimestampClock(System.currentTimeMillis()));
     }
 
     /*
@@ -133,10 +134,10 @@ public boolean isEmpty()
      *
      * param @ cf - column name as <column family>:<column>
      * param @ value - value associated with the column
-     * param @ timestamp - timestamp associated with this data.
+     * param @ clock - clock associated with this data.
      * param @ timeToLive - ttl for the column, 0 for standard (non expiring) columns
     */
-    public void add(QueryPath path, byte[] value, long timestamp, int timeToLive)
+    public void add(QueryPath path, byte[] value, IClock clock, int timeToLive)
     {
         Integer id = CFMetaData.getId(table_, path.columnFamilyName);
         ColumnFamily columnFamily = modifications_.get(id);
@@ -145,15 +146,15 @@ public void add(QueryPath path, byte[] value, long timestamp, int timeToLive)
             columnFamily = ColumnFamily.create(table_, path.columnFamilyName);
             modifications_.put(id, columnFamily);
         }
-        columnFamily.addColumn(path, value, timestamp, timeToLive);
+        columnFamily.addColumn(path, value, clock, timeToLive);
     }
 
-    public void add(QueryPath path, byte[] value, long timestamp)
+    public void add(QueryPath path, byte[] value, IClock clock)
     {
-        add(path, value, timestamp, 0);
+        add(path, value, clock, 0);
     }
 
-    public void delete(QueryPath path, long timestamp)
+    public void delete(QueryPath path, IClock clock)
     {
         Integer id = CFMetaData.getId(table_, path.columnFamilyName);
 
@@ -168,17 +169,18 @@ public void delete(QueryPath path, long timestamp)
 
         if (path.superColumnName == null && path.columnName == null)
         {
-            columnFamily.delete(localDeleteTime, timestamp);
+            columnFamily.delete(localDeleteTime, clock);
         }
         else if (path.columnName == null)
         {
-            SuperColumn sc = new SuperColumn(path.superColumnName, columnFamily.getSubComparator());
-            sc.markForDeleteAt(localDeleteTime, timestamp);
+            SuperColumn sc = new SuperColumn(path.superColumnName, columnFamily.getSubComparator(), 
+                    columnFamily.getClockType());
+            sc.markForDeleteAt(localDeleteTime, clock);
             columnFamily.addColumn(sc);
         }
         else
         {
-            columnFamily.deleteColumn(path, localDeleteTime, timestamp);
+            columnFamily.deleteColumn(path, localDeleteTime, clock);
         }
     }
 
@@ -247,13 +249,13 @@ public static RowMutation getRowMutation(String table, byte[] key, Map<String, L
                     assert cosc.super_column != null;
                     for (org.apache.cassandra.thrift.Column column : cosc.super_column.columns)
                     {
-                        rm.add(new QueryPath(cfName, cosc.super_column.name, column.name), column.value, column.timestamp, column.ttl);
+                        rm.add(new QueryPath(cfName, cosc.super_column.name, column.name), column.value, unthriftifyClock(column.clock), column.ttl);
                     }
                 }
                 else
                 {
                     assert cosc.super_column == null;
-                    rm.add(new QueryPath(cfName, null, cosc.column.name), cosc.column.value, cosc.column.timestamp, cosc.column.ttl);
+                    rm.add(new QueryPath(cfName, null, cosc.column.name), cosc.column.value, unthriftifyClock(cosc.column.clock), cosc.column.ttl);
                 }
             }
         }
@@ -299,12 +301,12 @@ private static void addColumnOrSuperColumnToRowMutation(RowMutation rm, String c
         {
             for (org.apache.cassandra.thrift.Column column : cosc.super_column.columns)
             {
-                rm.add(new QueryPath(cfName, cosc.super_column.name, column.name), column.value, column.timestamp, column.ttl);
+                rm.add(new QueryPath(cfName, cosc.super_column.name, column.name), column.value, unthriftifyClock(column.clock), column.ttl);
             }
         }
         else
         {
-            rm.add(new QueryPath(cfName, null, cosc.column.name), cosc.column.value, cosc.column.timestamp, cosc.column.ttl);
+            rm.add(new QueryPath(cfName, null, cosc.column.name), cosc.column.value, unthriftifyClock(cosc.column.clock), cosc.column.ttl);
         }
     }
 
@@ -315,16 +317,21 @@ private static void deleteColumnOrSuperColumnToRowMutation(RowMutation rm, Strin
             for(byte[] c : del.predicate.column_names)
             {
                 if (del.super_column == null && DatabaseDescriptor.getColumnFamilyType(rm.table_, cfName) == ColumnFamilyType.Super)
-                    rm.delete(new QueryPath(cfName, c), del.timestamp);
+                    rm.delete(new QueryPath(cfName, c), unthriftifyClock(del.clock));
                 else
-                    rm.delete(new QueryPath(cfName, del.super_column, c), del.timestamp);
+                    rm.delete(new QueryPath(cfName, del.super_column, c), unthriftifyClock(del.clock));
             }
         }
         else
         {
-            rm.delete(new QueryPath(cfName, del.super_column), del.timestamp);
+            rm.delete(new QueryPath(cfName, del.super_column), unthriftifyClock(del.clock));
         }
     }
+
+    private static IClock unthriftifyClock(Clock clock)
+    {
+        return new TimestampClock(clock.getTimestamp());
+    }
 }
 
 class RowMutationSerializer implements ICompactSerializer<RowMutation>
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/SuperColumn.java b/cassandra/trunk/src/java/org/apache/cassandra/db/SuperColumn.java
index 025daf89..f1a89c96 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/SuperColumn.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/SuperColumn.java
@@ -20,10 +20,12 @@
 
 import java.io.*;
 import java.util.Collection;
+import java.util.LinkedList;
+import java.util.List;
 import java.util.concurrent.ConcurrentSkipListMap;
 import java.security.MessageDigest;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -31,6 +33,7 @@
 import org.apache.cassandra.io.ICompactSerializer2;
 import org.apache.cassandra.io.util.DataOutputBuffer;
 import org.apache.cassandra.db.marshal.AbstractType;
+import org.apache.cassandra.db.IClock.ClockRelationship;
 import org.apache.cassandra.utils.FBUtilities;
 
 
@@ -38,27 +41,28 @@
 {
 	private static Logger logger_ = LoggerFactory.getLogger(SuperColumn.class);
 
-    public static SuperColumnSerializer serializer(AbstractType comparator)
+    public static SuperColumnSerializer serializer(AbstractType comparator, ClockType clockType)
     {
-        return new SuperColumnSerializer(comparator);
+        return new SuperColumnSerializer(comparator, clockType);
     }
 
     private byte[] name_;
     private ConcurrentSkipListMap<byte[], IColumn> columns_;
     private AtomicInteger localDeletionTime = new AtomicInteger(Integer.MIN_VALUE);
-	private AtomicLong markedForDeleteAt = new AtomicLong(Long.MIN_VALUE);
+    private AtomicReference<IClock> markedForDeleteAt;
 
-    public SuperColumn(byte[] name, AbstractType comparator)
+    public SuperColumn(byte[] name, AbstractType comparator, ClockType clockType)
     {
-        this(name, new ConcurrentSkipListMap<byte[], IColumn>(comparator));
+        this(name, new ConcurrentSkipListMap<byte[], IColumn>(comparator), clockType);
     }
 
-    private SuperColumn(byte[] name, ConcurrentSkipListMap<byte[], IColumn> columns)
+    private SuperColumn(byte[] name, ConcurrentSkipListMap<byte[], IColumn> columns, ClockType clockType)
     {
         assert name != null;
         assert name.length <= IColumn.MAX_NAME_LENGTH;
     	name_ = name;
         columns_ = columns;
+        markedForDeleteAt = new AtomicReference<IClock>(clockType.minClock());
     }
 
     public AbstractType getComparator()
@@ -68,21 +72,24 @@ public AbstractType getComparator()
 
     public SuperColumn cloneMeShallow()
     {
-        SuperColumn sc = new SuperColumn(name_, getComparator());
-        sc.markForDeleteAt(localDeletionTime.get(), markedForDeleteAt.get());
+        IClock _markedForDeleteAt = markedForDeleteAt.get();
+        SuperColumn sc = new SuperColumn(name_, getComparator(), _markedForDeleteAt.type());
+        sc.markForDeleteAt(localDeletionTime.get(), _markedForDeleteAt);
         return sc;
     }
 
     public IColumn cloneMe()
     {
-        SuperColumn sc = new SuperColumn(name_, new ConcurrentSkipListMap<byte[], IColumn>(columns_));
-        sc.markForDeleteAt(localDeletionTime.get(), markedForDeleteAt.get());
+        IClock _markedForDeleteAt = markedForDeleteAt.get();
+        SuperColumn sc = new SuperColumn(name_, new ConcurrentSkipListMap<byte[], IColumn>(columns_), _markedForDeleteAt.type());
+        sc.markForDeleteAt(localDeletionTime.get(), _markedForDeleteAt);
         return sc;
     }
 
 	public boolean isMarkedForDelete()
 	{
-		return markedForDeleteAt.get() > Long.MIN_VALUE;
+        IClock _markedForDeleteAt = markedForDeleteAt.get();
+        return _markedForDeleteAt.compare(_markedForDeleteAt.type().minClock()) == ClockRelationship.GREATER_THAN;
 	}
 
     public byte[] name()
@@ -125,7 +132,8 @@ public int serializedSize()
     	 * We need to keep the way we are calculating the column size in sync with the
     	 * way we are calculating the size for the column family serializer.
     	 */
-    	return DBConstants.shortSize_ + name_.length + DBConstants.intSize_ + DBConstants.longSize_ + DBConstants.intSize_ + size();
+      IClock _markedForDeleteAt = markedForDeleteAt.get();
+      return DBConstants.shortSize_ + name_.length + DBConstants.intSize_ + _markedForDeleteAt.size() + DBConstants.intSize_ + size();
     }
 
     public void remove(byte[] columnName)
@@ -133,22 +141,22 @@ public void remove(byte[] columnName)
     	columns_.remove(columnName);
     }
 
-    public long timestamp()
+    public IClock clock()
     {
     	throw new UnsupportedOperationException("This operation is not supported for Super Columns.");
     }
 
-    public long mostRecentLiveChangeAt()
+    public IClock mostRecentLiveChangeAt()
     {
-        long max = Long.MIN_VALUE;
+        List<IClock> clocks = new LinkedList<IClock>();
         for (IColumn column : columns_.values())
         {
-            if (!column.isMarkedForDelete() && column.timestamp() > max)
+            if (!column.isMarkedForDelete())
             {
-                max = column.timestamp();
+                clocks.add(column.clock());
             }
         }
-        return max;
+        return markedForDeleteAt.get().type().minClock().getSuperset(clocks);
     }
 
     public byte[] value()
@@ -163,11 +171,13 @@ public void addColumn(IColumn column)
         IColumn oldColumn = columns_.putIfAbsent(name, column);
     	if (oldColumn != null)
         {
-    		while (((Column)oldColumn).comparePriority((Column)column) <= 0)
+            ClockRelationship rel = ((Column)oldColumn).comparePriority((Column)column);
+            while (ClockRelationship.GREATER_THAN != rel)
             {
     			if (columns_.replace(name, oldColumn, column))
                     break;
                 oldColumn = columns_.get(name);
+                rel = ((Column)oldColumn).comparePriority((Column)column);
             }
     	}
     }
@@ -193,15 +203,17 @@ public int getObjectCount()
     	return 1 + columns_.size();
     }
 
-    public long getMarkedForDeleteAt()
+    public IClock getMarkedForDeleteAt()
     {
         return markedForDeleteAt.get();
     }
 
     public IColumn diff(IColumn columnNew)
     {
-    	IColumn columnDiff = new SuperColumn(columnNew.name(), ((SuperColumn)columnNew).getComparator());
-        if (columnNew.getMarkedForDeleteAt() > getMarkedForDeleteAt())
+        IClock _markedForDeleteAt = markedForDeleteAt.get();
+        IColumn columnDiff = new SuperColumn(columnNew.name(), ((SuperColumn)columnNew).getComparator(), _markedForDeleteAt.type());
+        ClockRelationship rel = columnNew.getMarkedForDeleteAt().compare(_markedForDeleteAt);
+        if (ClockRelationship.GREATER_THAN == rel)
         {
             ((SuperColumn)columnDiff).markForDeleteAt(columnNew.getLocalDeletionTime(), columnNew.getMarkedForDeleteAt());
         }
@@ -239,7 +251,8 @@ public void updateDigest(MessageDigest digest)
         DataOutputBuffer buffer = new DataOutputBuffer();
         try
         {
-            buffer.writeLong(markedForDeleteAt.get());
+            IClock _markedForDeleteAt = markedForDeleteAt.get();
+            _markedForDeleteAt.serialize(buffer);
         }
         catch (IOException e)
         {
@@ -259,7 +272,7 @@ public String getString(AbstractType comparator)
     	sb.append(comparator.getString(name_));
 
         if (isMarkedForDelete()) {
-            sb.append(" -delete at ").append(getMarkedForDeleteAt()).append("-");
+            sb.append(" -delete at ").append(getMarkedForDeleteAt().toString()).append("-");
         }
 
         sb.append(" [");
@@ -275,20 +288,22 @@ public int getLocalDeletionTime()
     }
 
     @Deprecated // TODO this is a hack to set initial value outside constructor
-    public void markForDeleteAt(int localDeleteTime, long timestamp)
+    public void markForDeleteAt(int localDeleteTime, IClock clock)
     {
         this.localDeletionTime.set(localDeleteTime);
-        this.markedForDeleteAt.set(timestamp);
+        this.markedForDeleteAt.set(clock);
     }
 }
 
 class SuperColumnSerializer implements ICompactSerializer2<IColumn>
 {
     private AbstractType comparator;
+    private ClockType clockType;
 
-    public SuperColumnSerializer(AbstractType comparator)
+    public SuperColumnSerializer(AbstractType comparator, ClockType clockType)
     {
         this.comparator = comparator;
+        this.clockType = clockType;
     }
 
     public AbstractType getComparator()
@@ -303,13 +318,14 @@ public void serialize(IColumn column, DataOutput dos)
         try
         {
             dos.writeInt(superColumn.getLocalDeletionTime());
-            dos.writeLong(superColumn.getMarkedForDeleteAt());
+            IClock _markedForDeleteAt = superColumn.getMarkedForDeleteAt();
+            clockType.serializer().serialize(_markedForDeleteAt, dos);
 
             Collection<IColumn> columns = column.getSubColumns();
             dos.writeInt(columns.size());
             for (IColumn subColumn : columns)
             {
-                Column.serializer().serialize(subColumn, dos);
+                Column.serializer(clockType).serialize(subColumn, dos);
             }
         }
         catch (IOException e)
@@ -321,19 +337,19 @@ public void serialize(IColumn column, DataOutput dos)
     public IColumn deserialize(DataInput dis) throws IOException
     {
         byte[] name = FBUtilities.readShortByteArray(dis);
-        SuperColumn superColumn = new SuperColumn(name, comparator);
+        SuperColumn superColumn = new SuperColumn(name, comparator, clockType);
         int localDeleteTime = dis.readInt();
         if (localDeleteTime != Integer.MIN_VALUE && localDeleteTime <= 0)
         {
             throw new IOException("Invalid localDeleteTime read: " + localDeleteTime);
         }
-        superColumn.markForDeleteAt(localDeleteTime, dis.readLong());
+        superColumn.markForDeleteAt(localDeleteTime, clockType.serializer().deserialize(dis));
 
         /* read the number of columns */
         int size = dis.readInt();
         for ( int i = 0; i < size; ++i )
         {
-            IColumn subColumn = Column.serializer().deserialize(dis);
+            IColumn subColumn = Column.serializer(clockType).deserialize(dis);
             superColumn.addColumn(subColumn);
         }
         return superColumn;
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/SystemTable.java b/cassandra/trunk/src/java/org/apache/cassandra/db/SystemTable.java
index 396dc8f4..8e0dfd72 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/SystemTable.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/SystemTable.java
@@ -68,7 +68,7 @@ public static synchronized void updateToken(InetAddress ep, Token token)
     {
         IPartitioner p = StorageService.getPartitioner();
         ColumnFamily cf = ColumnFamily.create(Table.SYSTEM_TABLE, STATUS_CF);
-        cf.addColumn(new Column(ep.getAddress(), p.getTokenFactory().toByteArray(token), System.currentTimeMillis()));
+        cf.addColumn(new Column(ep.getAddress(), p.getTokenFactory().toByteArray(token), new TimestampClock(System.currentTimeMillis())));
         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, LOCATION_KEY);
         rm.add(cf);
         try
@@ -89,7 +89,7 @@ public static synchronized void updateToken(Token token)
         assert metadata != null;
         IPartitioner p = StorageService.getPartitioner();
         ColumnFamily cf = ColumnFamily.create(Table.SYSTEM_TABLE, STATUS_CF);
-        cf.addColumn(new Column(SystemTable.TOKEN, p.getTokenFactory().toByteArray(token), System.currentTimeMillis()));
+        cf.addColumn(new Column(SystemTable.TOKEN, p.getTokenFactory().toByteArray(token), new TimestampClock(System.currentTimeMillis())));
         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, LOCATION_KEY);
         rm.add(cf);
         try
@@ -145,9 +145,9 @@ public static synchronized StorageMetadata initMetadata() throws IOException
 
             RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, LOCATION_KEY);
             cf = ColumnFamily.create(Table.SYSTEM_TABLE, SystemTable.STATUS_CF);
-            cf.addColumn(new Column(TOKEN, p.getTokenFactory().toByteArray(token)));
-            cf.addColumn(new Column(GENERATION, FBUtilities.toByteArray(generation)));
-            cf.addColumn(new Column(CLUSTERNAME, DatabaseDescriptor.getClusterName().getBytes()));
+            cf.addColumn(new Column(TOKEN, p.getTokenFactory().toByteArray(token), TimestampClock.ZERO_VALUE));
+            cf.addColumn(new Column(GENERATION, FBUtilities.toByteArray(generation), TimestampClock.ZERO_VALUE));
+            cf.addColumn(new Column(CLUSTERNAME, DatabaseDescriptor.getClusterName().getBytes(), TimestampClock.ZERO_VALUE));
             rm.add(cf);
             rm.apply();
             metadata = new StorageMetadata(token, generation, DatabaseDescriptor.getClusterName().getBytes());
@@ -170,7 +170,8 @@ public static synchronized StorageMetadata initMetadata() throws IOException
 
         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, LOCATION_KEY);
         cf = ColumnFamily.create(Table.SYSTEM_TABLE, SystemTable.STATUS_CF);
-        Column generation2 = new Column(GENERATION, FBUtilities.toByteArray(gen), generation.timestamp() + 1);
+        TimestampClock genClock = new TimestampClock(((TimestampClock)generation.clock()).timestamp() + 1);
+        Column generation2 = new Column(GENERATION, FBUtilities.toByteArray(gen), genClock);
         cf.addColumn(generation2);
         byte[] cname;
         if (cluster != null)
@@ -180,7 +181,7 @@ public static synchronized StorageMetadata initMetadata() throws IOException
         }
         else
         {
-            Column clustername = new Column(CLUSTERNAME, DatabaseDescriptor.getClusterName().getBytes());
+            Column clustername = new Column(CLUSTERNAME, DatabaseDescriptor.getClusterName().getBytes(), TimestampClock.ZERO_VALUE);
             cf.addColumn(clustername);
             cname = DatabaseDescriptor.getClusterName().getBytes();
             logger.info("Saved ClusterName not found. Using " + DatabaseDescriptor.getClusterName());
@@ -204,7 +205,7 @@ public static boolean isBootstrapped()
     public static void setBootstrapped(boolean isBootstrapped)
     {
         ColumnFamily cf = ColumnFamily.create(Table.SYSTEM_TABLE, STATUS_CF);
-        cf.addColumn(new Column(BOOTSTRAP, new byte[] { (byte) (isBootstrapped ? 1 : 0) }, System.currentTimeMillis()));
+        cf.addColumn(new Column(BOOTSTRAP, new byte[] { (byte) (isBootstrapped ? 1 : 0) }, new TimestampClock(System.currentTimeMillis())));
         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, BOOTSTRAP_KEY);
         rm.add(cf);
         try
@@ -228,7 +229,7 @@ public static void deleteDroppedCfMarkers(Collection<IColumn> cols) throws IOExc
         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, GRAVEYARD_KEY);
         long now = System.currentTimeMillis();
         for (IColumn col : cols)
-            rm.delete(new QueryPath(STATUS_CF, null, col.name()), now);
+            rm.delete(new QueryPath(STATUS_CF, null, col.name()), new TimestampClock(now));
         rm.apply();
     }
     
@@ -236,7 +237,7 @@ public static void deleteDroppedCfMarkers(Collection<IColumn> cols) throws IOExc
     public static void markForRemoval(CFMetaData cfm)
     {
         ColumnFamily cf = ColumnFamily.create(Table.SYSTEM_TABLE, STATUS_CF);
-        cf.addColumn(new Column((cfm.tableName + "-" + cfm.cfName + "-" + cfm.cfId).getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, System.currentTimeMillis()));
+        cf.addColumn(new Column((cfm.tableName + "-" + cfm.cfName + "-" + cfm.cfId).getBytes(), ArrayUtils.EMPTY_BYTE_ARRAY, new TimestampClock(System.currentTimeMillis())));
         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, GRAVEYARD_KEY);
         rm.add(cf);
         try
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/TimestampClock.java b/cassandra/trunk/src/java/org/apache/cassandra/db/TimestampClock.java
index e69de29b..761596ca 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/TimestampClock.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/TimestampClock.java
@@ -0,0 +1,118 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.cassandra.db;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.log4j.Logger;
+import org.apache.commons.lang.ArrayUtils;
+
+import org.apache.cassandra.io.ICompactSerializer2;
+
+/**
+ * A simple clock composed of a timestamp.
+ * The comparison is the timestamp comparison.
+ */
+public class TimestampClock implements IClock
+{
+    private static Logger logger_ = Logger.getLogger(TimestampClock.class);
+    public static TimestampClock MIN_VALUE = new TimestampClock(Long.MIN_VALUE);
+    public static TimestampClock ZERO_VALUE = new TimestampClock(0);
+    public static ICompactSerializer2<IClock> SERIALIZER = new TimestampClockSerializer();
+
+    private final long timestamp;
+
+    public TimestampClock(long timestamp)
+    {
+        this.timestamp = timestamp;
+    }
+
+    public long timestamp()
+    {
+        return timestamp;
+    }
+
+    public ClockRelationship compare(IClock other)
+    {
+        assert other instanceof TimestampClock : "Wrong class type.";
+
+        long otherTimestamp = ((TimestampClock)other).timestamp();
+        if (timestamp > otherTimestamp)
+        {
+            return ClockRelationship.GREATER_THAN;
+        }
+        else if (timestamp == otherTimestamp)
+        {
+            return ClockRelationship.EQUAL;
+        }
+        // timestamp < otherTimestamp
+        return ClockRelationship.LESS_THAN;
+    }
+
+    public IClock getSuperset(List<IClock> otherClocks)
+    {
+        IClock max = this;
+
+        for (IClock clock : otherClocks)
+        {
+            if (clock.compare(max) == ClockRelationship.GREATER_THAN)
+            {
+                max = clock;
+            }
+        }
+
+        return max;
+    }
+
+    public int size()
+    {
+        return DBConstants.tsSize_;
+    }
+
+    public ClockType type()
+    {
+        return ClockType.Timestamp;
+    }
+
+    public void serialize(DataOutput out) throws IOException
+    {
+        SERIALIZER.serialize(this, out);
+    }
+
+    public String toString()
+    {
+        return Long.toString(timestamp);
+    }
+}
+
+class TimestampClockSerializer implements ICompactSerializer2<IClock>
+{
+    public void serialize(IClock tc, DataOutput out) throws IOException
+    {
+        out.writeLong(((TimestampClock)tc).timestamp());
+    }
+
+    public IClock deserialize(DataInput in) throws IOException
+    {
+        return new TimestampClock(in.readLong());
+    }
+}
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/QueryFilter.java b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/QueryFilter.java
index 9854d2e0..d123ae31 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/QueryFilter.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/QueryFilter.java
@@ -28,6 +28,7 @@
 import org.apache.cassandra.utils.ReducingIterator;
 import org.apache.cassandra.db.*;
 import org.apache.cassandra.db.marshal.AbstractType;
+import org.apache.cassandra.db.IClock.ClockRelationship;
 
 public class QueryFilter
 {
@@ -112,8 +113,8 @@ protected IColumn getReduced()
                     // filterSuperColumn only looks at immediate parent (the supercolumn) when determining if a subcolumn
                     // is still live, i.e., not shadowed by the parent's tombstone.  so, bump it up temporarily to the tombstone
                     // time of the cf, if that is greater.
-                    long deletedAt = c.getMarkedForDeleteAt();
-                    if (returnCF.getMarkedForDeleteAt() > deletedAt)
+                    IClock deletedAt = c.getMarkedForDeleteAt();
+                    if (returnCF.getMarkedForDeleteAt().compare(deletedAt) == ClockRelationship.GREATER_THAN)
                         ((SuperColumn)c).markForDeleteAt(c.getLocalDeletionTime(), returnCF.getMarkedForDeleteAt());
 
                     c = filter.filterSuperColumn((SuperColumn)c, gcBefore);
@@ -137,9 +138,9 @@ public static boolean isRelevant(IColumn column, IColumnContainer container, int
         // the column itself must be not gc-able (it is live, or a still relevant tombstone, or has live subcolumns), (1)
         // and if its container is deleted, the column must be changed more recently than the container tombstone (2)
         // (since otherwise, the only thing repair cares about is the container tombstone)
-        long maxChange = column.mostRecentLiveChangeAt();
-        return (!column.isMarkedForDelete() || column.getLocalDeletionTime() > gcBefore || maxChange > column.getMarkedForDeleteAt()) // (1)
-               && (!container.isMarkedForDelete() || maxChange > container.getMarkedForDeleteAt()); // (2)
+        IClock maxChange = column.mostRecentLiveChangeAt();
+        return (!column.isMarkedForDelete() || column.getLocalDeletionTime() > gcBefore || (ClockRelationship.GREATER_THAN == maxChange.compare(column.getMarkedForDeleteAt()))) // (1)
+               && (!container.isMarkedForDelete() || (ClockRelationship.GREATER_THAN == maxChange.compare(container.getMarkedForDeleteAt()))); // (2)
     }
 
     /**
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
index 12df52b6..e78a61ac 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/filter/SliceQueryFilter.java
@@ -33,6 +33,7 @@
 import org.apache.cassandra.io.sstable.SSTableReader;
 import org.apache.cassandra.io.util.FileDataInput;
 import org.apache.cassandra.db.*;
+import org.apache.cassandra.db.IClock.ClockRelationship;
 import org.apache.cassandra.db.marshal.AbstractType;
 
 import com.google.common.base.Predicate;
@@ -147,7 +148,7 @@ public void collectReducedColumns(IColumnContainer container, Iterator<IColumn>
             // only count live columns towards the `count` criteria
             if (!column.isMarkedForDelete()
                 && (!container.isMarkedForDelete()
-                    || column.mostRecentLiveChangeAt() > container.getMarkedForDeleteAt()))
+                    || (ClockRelationship.GREATER_THAN == column.mostRecentLiveChangeAt().compare(container.getMarkedForDeleteAt()))))
             {
                 liveColumns++;
             }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/Migration.java b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/Migration.java
index 4bdc2981..d14d297b 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/migration/Migration.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/migration/Migration.java
@@ -26,6 +26,7 @@
 import org.apache.cassandra.db.CompactionManager;
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.IColumn;
+import org.apache.cassandra.db.TimestampClock;
 import org.apache.cassandra.db.RowMutation;
 import org.apache.cassandra.db.Table;
 import org.apache.cassandra.db.filter.QueryFilter;
@@ -117,13 +118,13 @@ public final void apply() throws IOException, ConfigurationException
             long now = System.currentTimeMillis();
             byte[] buf = getBytes();
             RowMutation migration = new RowMutation(Table.SYSTEM_TABLE, MIGRATIONS_KEY);
-            migration.add(new QueryPath(MIGRATIONS_CF, null, UUIDGen.decompose(newVersion)), buf, now);
+            migration.add(new QueryPath(MIGRATIONS_CF, null, UUIDGen.decompose(newVersion)), buf, new TimestampClock(now));
             migration.apply();
             
             // note that we storing this in the system table, which is not replicated, instead of the definitions table, which is.
             logger.debug("Applying migration " + newVersion.toString());
             migration = new RowMutation(Table.SYSTEM_TABLE, LAST_MIGRATION_KEY);
-            migration.add(new QueryPath(SCHEMA_CF, null, LAST_MIGRATION_KEY), UUIDGen.decompose(newVersion), now);
+            migration.add(new QueryPath(SCHEMA_CF, null, LAST_MIGRATION_KEY), UUIDGen.decompose(newVersion), new TimestampClock(now));
             migration.apply();
             
             // if we fail here, there will be schema changes in the CL that will get replayed *AFTER* the schema is loaded.
@@ -208,9 +209,9 @@ static RowMutation makeDefinitionMutation(KSMetaData add, KSMetaData remove, UUI
         final long now = System.currentTimeMillis();
         RowMutation rm = new RowMutation(Table.SYSTEM_TABLE, toBytes(versionId));
         if (remove != null)
-            rm.delete(new QueryPath(SCHEMA_CF, null, remove.name.getBytes()), System.currentTimeMillis());
+            rm.delete(new QueryPath(SCHEMA_CF, null, remove.name.getBytes()), new TimestampClock(System.currentTimeMillis()));
         if (add != null)
-            rm.add(new QueryPath(SCHEMA_CF, null, add.name.getBytes()), KSMetaData.serialize(add), now);
+            rm.add(new QueryPath(SCHEMA_CF, null, add.name.getBytes()), KSMetaData.serialize(add), new TimestampClock(now));
         
         // include all other key spaces.
         for (String tableName : DatabaseDescriptor.getNonSystemTables())
@@ -218,7 +219,7 @@ static RowMutation makeDefinitionMutation(KSMetaData add, KSMetaData remove, UUI
             if (add != null && add.name.equals(tableName) || remove != null && remove.name.equals(tableName))
                 continue;
             KSMetaData ksm = DatabaseDescriptor.getTableDefinition(tableName);
-            rm.add(new QueryPath(SCHEMA_CF, null, ksm.name.getBytes()), KSMetaData.serialize(ksm), now);
+            rm.add(new QueryPath(SCHEMA_CF, null, ksm.name.getBytes()), KSMetaData.serialize(ksm), new TimestampClock(now));
         }
         return rm;
     }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java b/cassandra/trunk/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
index 5366abfc..ec077957 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/hadoop/ColumnFamilyRecordReader.java
@@ -289,7 +289,8 @@ private IColumn unthriftify(ColumnOrSuperColumn cosc)
     private IColumn unthriftifySuper(SuperColumn super_column)
     {
         AbstractType subComparator = DatabaseDescriptor.getSubComparator(keyspace, cfName);
-        org.apache.cassandra.db.SuperColumn sc = new org.apache.cassandra.db.SuperColumn(super_column.name, subComparator);
+        ClockType clockType = DatabaseDescriptor.getClockType(keyspace, cfName);
+        org.apache.cassandra.db.SuperColumn sc = new org.apache.cassandra.db.SuperColumn(super_column.name, subComparator, clockType);
         for (Column column : super_column.columns)
         {
             sc.addColumn(unthriftifySimple(column));
@@ -299,6 +300,11 @@ private IColumn unthriftifySuper(SuperColumn super_column)
 
     private IColumn unthriftifySimple(Column column)
     {
-        return new org.apache.cassandra.db.Column(column.name, column.value, column.timestamp);
+        return new org.apache.cassandra.db.Column(column.name, column.value, unthriftifyClock(column.clock));
+    }
+
+    private static IClock unthriftifyClock(Clock clock)
+    {
+        return new org.apache.cassandra.db.TimestampClock(clock.getTimestamp());
     }
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/io/sstable/SSTableReader.java b/cassandra/trunk/src/java/org/apache/cassandra/io/sstable/SSTableReader.java
index bd262e4e..50d43b73 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/io/sstable/SSTableReader.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/io/sstable/SSTableReader.java
@@ -277,9 +277,10 @@ public ColumnFamily makeColumnFamily()
     public ICompactSerializer2<IColumn> getColumnSerializer()
     {
         ColumnFamilyType cfType = DatabaseDescriptor.getColumnFamilyType(getTableName(), getColumnFamilyName());
+        ClockType clockType = DatabaseDescriptor.getClockType(getTableName(), getColumnFamilyName());
         return cfType == ColumnFamilyType.Standard
-               ? Column.serializer()
-               : SuperColumn.serializer(getColumnComparator());
+               ? Column.serializer(clockType)
+               : SuperColumn.serializer(getColumnComparator(), clockType);
     }
 
     /**
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java b/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
index e6fe75f8..c647b08d 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
@@ -137,7 +137,7 @@ public CassandraServer()
             {
                 continue;
             }
-            Column thrift_column = new Column(column.name(), column.value(), column.timestamp());
+            Column thrift_column = new Column(column.name(), column.value(), thriftifyIClock(column.clock()));
             if (column instanceof ExpiringColumn)
             {
                 thrift_column.setTtl(((ExpiringColumn) column).getTimeToLive());
@@ -157,7 +157,7 @@ public CassandraServer()
             {
                 continue;
             }
-            Column thrift_column = new Column(column.name(), column.value(), column.timestamp());
+            Column thrift_column = new Column(column.name(), column.value(), thriftifyIClock(column.clock()));
             if (column instanceof ExpiringColumn)
             {
                 thrift_column.setTtl(((ExpiringColumn) column).getTimeToLive());
@@ -193,6 +193,16 @@ public CassandraServer()
         return thriftSuperColumns;
     }
 
+    private static Clock thriftifyIClock(IClock clock)
+    {
+        Clock thrift_clock = new Clock();
+        if (clock instanceof TimestampClock)
+        {
+            thrift_clock.setTimestamp(((TimestampClock)clock).timestamp());
+        }
+        return thrift_clock;
+    }
+
     private Map<byte[], List<ColumnOrSuperColumn>> getSlice(List<ReadCommand> commands, ConsistencyLevel consistency_level)
     throws InvalidRequestException, UnavailableException, TimedOutException
     {
@@ -344,11 +354,12 @@ public void insert(byte[] key, ColumnParent column_parent, Column column, Consis
         ThriftValidation.validateKey(key);
         ThriftValidation.validateColumnParent(keySpace.get(), column_parent);
         ThriftValidation.validateColumn(keySpace.get(), column_parent, column);
+        IClock cassandra_clock = ThriftValidation.validateClock(column.clock);
 
         RowMutation rm = new RowMutation(keySpace.get(), key);
         try
         {
-            rm.add(new QueryPath(column_parent.column_family, column_parent.super_column, column.name), column.value, column.timestamp, column.ttl);
+            rm.add(new QueryPath(column_parent.column_family, column_parent.super_column, column.name), column.value, cassandra_clock, column.ttl);
         }
         catch (MarshalException e)
         {
@@ -418,7 +429,7 @@ public void batch_mutate(Map<byte[],Map<String,List<Mutation>>> mutation_map, Co
         }
     }
 
-    public void remove(byte[] key, ColumnPath column_path, long timestamp, ConsistencyLevel consistency_level)
+    public void remove(byte[] key, ColumnPath column_path, Clock clock, ConsistencyLevel consistency_level)
     throws InvalidRequestException, UnavailableException, TimedOutException
     {
         if (logger.isDebugEnabled())
@@ -429,8 +440,10 @@ public void remove(byte[] key, ColumnPath column_path, long timestamp, Consisten
         ThriftValidation.validateKey(key);
         ThriftValidation.validateColumnPathOrParent(keySpace.get(), column_path);
         
+        IClock cassandra_clock = ThriftValidation.validateClock(clock);
+
         RowMutation rm = new RowMutation(keySpace.get(), key);
-        rm.delete(new QueryPath(column_path), timestamp);
+        rm.delete(new QueryPath(column_path), cassandra_clock);
 
         doInsert(consistency_level, rm);
     }
@@ -469,6 +482,7 @@ private void doInsert(ConsistencyLevel consistency_level, RowMutation rm) throws
 
             Map<String, String> columnMap = new HashMap<String, String>();
             columnMap.put("Type", columnFamilyMetaData.cfType.name());
+            columnMap.put("ClockType", columnFamilyMetaData.clockType.name());
             columnMap.put("Desc", columnFamilyMetaData.comment == null ? columnFamilyMetaData.pretty() : columnFamilyMetaData.comment);
             columnMap.put("CompareWith", columnFamilyMetaData.comparator.getClass().getName());
             if (columnFamilyMetaData.cfType == ColumnFamilyType.Super)
@@ -624,6 +638,7 @@ public String system_add_column_family(CfDef cf_def) throws InvalidRequestExcept
                         cf_def.table,
                         cf_def.name,
                         cfType,
+                        ClockType.Timestamp,
                         DatabaseDescriptor.getComparator(cf_def.comparator_type),
                         cf_def.subcomparator_type.length() == 0 ? null : DatabaseDescriptor.getComparator(cf_def.subcomparator_type),
                         cf_def.comment,
@@ -733,6 +748,7 @@ public String system_add_keyspace(KsDef ks_def) throws InvalidRequestException,
                         cfDef.table,
                         cfDef.name,
                         cfType,
+                        ClockType.Timestamp,
                         DatabaseDescriptor.getComparator(cfDef.comparator_type),
                         cfDef.subcomparator_type.length() == 0 ? null : DatabaseDescriptor.getComparator(cfDef.subcomparator_type),
                         cfDef.comment,
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/thrift/ThriftValidation.java b/cassandra/trunk/src/java/org/apache/cassandra/thrift/ThriftValidation.java
index f5b3cabb..bca607f5 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/thrift/ThriftValidation.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/thrift/ThriftValidation.java
@@ -22,11 +22,14 @@
 
 import java.util.Comparator;
 import java.util.Arrays;
+import org.apache.commons.lang.ArrayUtils;
 
 import org.apache.cassandra.db.KeyspaceNotDefinedException;
 import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.IColumn;
 import org.apache.cassandra.db.ColumnFamilyType;
+import org.apache.cassandra.db.IClock;
+import org.apache.cassandra.db.TimestampClock;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.db.marshal.MarshalException;
 
@@ -210,6 +213,7 @@ public static void validateColumnOrSuperColumn(String keyspace, String cfName, C
         if (cosc.column != null)
         {
             validateTtl(cosc.column);
+            validateClock(cosc.column.clock);
             ThriftValidation.validateColumnPath(keyspace, new ColumnPath(cfName).setSuper_column(null).setColumn(cosc.column.name));
         }
 
@@ -218,6 +222,7 @@ public static void validateColumnOrSuperColumn(String keyspace, String cfName, C
             for (Column c : cosc.super_column.columns)
             {
                 validateTtl(c);
+                validateClock(c.clock);
                 ThriftValidation.validateColumnPath(keyspace, new ColumnPath(cfName).setSuper_column(cosc.super_column.name).setColumn(c.name));
             }
         }
@@ -236,6 +241,15 @@ private static void validateTtl(Column column) throws InvalidRequestException
         assert column.isSetTtl() || column.ttl == 0;
     }
 
+    public static IClock validateClock(Clock clock) throws InvalidRequestException
+    {
+        if (clock.isSetTimestamp())
+        {
+            return new TimestampClock(clock.getTimestamp());
+        }
+        throw new InvalidRequestException("Clock must have one a timestamp");
+    }
+
     public static void validateMutation(String keyspace, String cfName, Mutation mut)
             throws InvalidRequestException
     {
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableExport.java b/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableExport.java
index f7df9f1b..530245b3 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableExport.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableExport.java
@@ -27,6 +27,7 @@
 import org.apache.cassandra.db.ColumnFamily;
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.IColumn;
+import org.apache.cassandra.db.TimestampClock;
 import org.apache.cassandra.db.marshal.AbstractType;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.io.sstable.SSTable;
@@ -95,7 +96,7 @@ private static String serializeColumns(Collection<IColumn> cols, AbstractType co
             json.append(", ");
             json.append(quote(bytesToHex(column.value())));
             json.append(", ");
-            json.append(column.timestamp());
+            json.append(((TimestampClock) column.clock()).timestamp());
             json.append(", ");
             json.append(column.isMarkedForDelete());
             json.append("]");
@@ -125,7 +126,7 @@ private static String serializeRow(SSTableIdentityIterator row) throws IOExcepti
                 json.append(asKey(bytesToHex(column.name())));
                 json.append("{");
                 json.append(asKey("deletedAt"));
-                json.append(column.getMarkedForDeleteAt());
+                json.append(((TimestampClock) column.getMarkedForDeleteAt()).timestamp());
                 json.append(", ");
                 json.append(asKey("subColumns"));
                 json.append(serializeColumns(column.getSubColumns(), comparator));
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableImport.java b/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableImport.java
index 2d4833e1..f222de0f 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableImport.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/tools/SSTableImport.java
@@ -27,6 +27,7 @@
 import org.apache.cassandra.db.DecoratedKey;
 import org.apache.cassandra.db.SuperColumn;
 import org.apache.cassandra.db.ColumnFamilyType;
+import org.apache.cassandra.db.TimestampClock;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.dht.IPartitioner;
 import org.apache.cassandra.io.util.DataOutputBuffer;
@@ -64,6 +65,7 @@
     {
         private String name;
         private String value;
+        // TODO: fix when we adding other clock type
         private long timestamp;
         private boolean isDeleted;
         
@@ -73,6 +75,7 @@ private JsonColumn(Object obj) throws ClassCastException
             assert colSpec.size() == 4;
             name = (String)colSpec.get(0);
             value = (String)colSpec.get(1);
+            // TODO: fix when we adding other clock type
             timestamp = (Long)colSpec.get(2);
             isDeleted = (Boolean)colSpec.get(3);
         }
@@ -93,9 +96,9 @@ private static void addToStandardCF(JSONArray row, ColumnFamily cfamily)
             JsonColumn col = new JsonColumn(c);
             QueryPath path = new QueryPath(cfm.cfName, null, hexToBytes(col.name));
             if (col.isDeleted) {
-                cfamily.addColumn(path, hexToBytes(col.value), col.timestamp);
+                cfamily.addColumn(path, hexToBytes(col.value), new TimestampClock(col.timestamp));
             } else {
-                cfamily.addTombstone(path, hexToBytes(col.value), col.timestamp);
+                cfamily.addTombstone(path, hexToBytes(col.value), new TimestampClock(col.timestamp));
             }
         }
     }
@@ -123,14 +126,14 @@ private static void addToSuperCF(JSONObject row, ColumnFamily cfamily)
                 JsonColumn col = new JsonColumn(c);
                 QueryPath path = new QueryPath(cfm.cfName, superName, hexToBytes(col.name));
                 if (col.isDeleted) {
-                    cfamily.addColumn(path, hexToBytes(col.value), col.timestamp);
+                    cfamily.addColumn(path, hexToBytes(col.value), new TimestampClock(col.timestamp));
                 } else {
-                    cfamily.addTombstone(path, hexToBytes(col.value), col.timestamp);
+                    cfamily.addTombstone(path, hexToBytes(col.value), new TimestampClock(col.timestamp));
                 }
             }
             
             SuperColumn superColumn = (SuperColumn)cfamily.getColumn(superName);
-            superColumn.markForDeleteAt((int)(System.currentTimeMillis()/1000), deletedAt);
+            superColumn.markForDeleteAt((int)(System.currentTimeMillis()/1000), new TimestampClock(deletedAt));
         }
     }
 
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/utils/FBUtilities.java b/cassandra/trunk/src/java/org/apache/cassandra/utils/FBUtilities.java
index 591de65b..96ad04dc 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/utils/FBUtilities.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/utils/FBUtilities.java
@@ -28,6 +28,7 @@
 import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.zip.DataFormatException;
 import java.util.zip.Deflater;
 import java.util.zip.Inflater;
@@ -39,6 +40,8 @@
 
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.DecoratedKey;
+import org.apache.cassandra.db.IClock;
+import org.apache.cassandra.db.IClock.ClockRelationship;
 import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
 import org.apache.thrift.TBase;
@@ -399,23 +402,48 @@ public int compare(T o1, T o2)
 
     public static void atomicSetMax(AtomicInteger atomic, int i)
     {
-        int j;
         while (true)
         {
-            if ((j = atomic.getAndSet(i)) <= i)
+            int j = atomic.get();
+            if (j >= i || atomic.compareAndSet(j, i))
                 break;
-            i = j;
         }
     }
 
     public static void atomicSetMax(AtomicLong atomic, long i)
     {
-        long j;
         while (true)
         {
-            if ((j = atomic.getAndSet(i)) <= i)
+            long j = atomic.get();
+            if (j >= i || atomic.compareAndSet(j, i))
+                break;
+        }
+    }
+
+    /** 
+     * Sets an atomic clock reference to the maximum of its current value and
+     * a new value.
+     *
+     * The function is not synchronized and does not guarantee that the resulting
+     * reference will hold either the old or new value, but it does guarantee
+     * that it will hold a value, v, such that: v = max(oldValue, newValue, v).
+     *
+     * @param atomic the atomic reference to set
+     * @param newClock the new provided value
+     */
+    public static void atomicSetMax(AtomicReference<IClock> atomic, IClock newClock)
+    {
+        while (true)
+        {
+            IClock oldClock = atomic.get();
+            ClockRelationship rel = oldClock.compare(newClock);
+            if (rel == ClockRelationship.DISJOINT)
+            {
+                newClock = oldClock.getSuperset(Arrays.asList(newClock));
+            }
+            if (rel == ClockRelationship.GREATER_THAN || rel == ClockRelationship.EQUAL 
+                || atomic.compareAndSet(oldClock, newClock))
                 break;
-            i = j;
         }
     }
 
diff --git a/cassandra/trunk/test/long/org/apache/cassandra/db/LongCompactionSpeedTest.java b/cassandra/trunk/test/long/org/apache/cassandra/db/LongCompactionSpeedTest.java
index 0c8cff44..ec013211 100644
--- a/cassandra/trunk/test/long/org/apache/cassandra/db/LongCompactionSpeedTest.java
+++ b/cassandra/trunk/test/long/org/apache/cassandra/db/LongCompactionSpeedTest.java
@@ -85,9 +85,9 @@ protected void testCompaction(int sstableCount, int rowsPerSSTable, int colsPerR
                 for (int i = 0; i < colsPerRow; i++)
                 {
                     // last sstable has highest timestamps
-                    cols[i] = Util.column(String.valueOf(i), String.valueOf(i), k);
+                    cols[i] = Util.column(String.valueOf(i), String.valueOf(i), new TimestampClock(k));
                 }
-                rows.put(key, SSTableUtils.createCF(Long.MIN_VALUE, Integer.MIN_VALUE, cols));
+                rows.put(key, SSTableUtils.createCF(ClockType.Timestamp.minClock(), Integer.MIN_VALUE, cols));
             }
             SSTableReader sstable = SSTableUtils.writeSSTable(rows);
             sstables.add(sstable);
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/Util.java b/cassandra/trunk/test/unit/org/apache/cassandra/Util.java
index 39a9d08e..e6ab6b5c 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/Util.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/Util.java
@@ -44,9 +44,9 @@ public static DecoratedKey dk(String key)
         return StorageService.getPartitioner().decorateKey(key.getBytes(UTF8));
     }
 
-    public static Column column(String name, String value, long timestamp)
+    public static Column column(String name, String value, IClock clock)
     {
-        return new Column(name.getBytes(), value.getBytes(), timestamp);
+        return new Column(name.getBytes(), value.getBytes(), clock);
     }
 
     public static Range range(IPartitioner p, String left, String right)
@@ -54,9 +54,9 @@ public static Range range(IPartitioner p, String left, String right)
         return new Range(p.getToken(left.getBytes()), p.getToken(right.getBytes()));
     }
 
-    public static void addMutation(RowMutation rm, String columnFamilyName, String superColumnName, long columnName, String value, long timestamp)
+    public static void addMutation(RowMutation rm, String columnFamilyName, String superColumnName, long columnName, String value, IClock clock)
     {
-        rm.add(new QueryPath(columnFamilyName, superColumnName.getBytes(), getBytes(columnName)), value.getBytes(), timestamp);
+        rm.add(new QueryPath(columnFamilyName, superColumnName.getBytes(), getBytes(columnName)), value.getBytes(), clock);
     }
 
     public static byte[] getBytes(long v)
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/client/TestRingCache.java b/cassandra/trunk/test/unit/org/apache/cassandra/client/TestRingCache.java
index 19f2724e..d2164f97 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/client/TestRingCache.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/client/TestRingCache.java
@@ -24,6 +24,7 @@
 
 import org.apache.cassandra.thrift.Cassandra;
 import org.apache.cassandra.thrift.Column;
+import org.apache.cassandra.thrift.Clock;
 import org.apache.cassandra.thrift.ColumnPath;
 import org.apache.cassandra.thrift.ColumnParent;
 import org.apache.cassandra.thrift.ConsistencyLevel;
@@ -105,9 +106,11 @@ public static void main(String[] args) throws Throwable
             // now, read the row back directly from the host owning the row locally
             tester.setup(endpoints.get(0).getHostAddress(), DatabaseDescriptor.getRpcPort());
             tester.thriftClient.set_keyspace(keyspace);
-            tester.thriftClient.insert(row, parent, new Column("col1".getBytes(), "val1".getBytes(), 1), ConsistencyLevel.ONE);
+            Clock clock = new Clock();
+            clock.setTimestamp(1);
+            tester.thriftClient.insert(row, parent, new Column("col1".getBytes(), "val1".getBytes(), clock), ConsistencyLevel.ONE);
             Column column = tester.thriftClient.get(row, col, ConsistencyLevel.ONE).column;
-            System.out.println("read row " + new String(row) + " " + new String(column.name) + ":" + new String(column.value) + ":" + column.timestamp);
+            System.out.println("read row " + new String(row) + " " + new String(column.name) + ":" + new String(column.value) + ":" + column.clock.timestamp);
         }
 
         System.exit(1);
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
index 0ee71b25..4a9b19ff 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyStoreTest.java
@@ -58,8 +58,8 @@ public void testGetColumnWithWrongBF() throws IOException, ExecutionException, I
         List<RowMutation> rms = new LinkedList<RowMutation>();
         RowMutation rm;
         rm = new RowMutation("Keyspace1", "key1".getBytes());
-        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), 0);
-        rm.add(new QueryPath("Standard1", null, "Column2".getBytes()), "asdf".getBytes(), 0);
+        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), new TimestampClock(0));
+        rm.add(new QueryPath("Standard1", null, "Column2".getBytes()), "asdf".getBytes(), new TimestampClock(0));
         rms.add(rm);
         ColumnFamilyStore store = Util.writeColumnFamily(rms);
 
@@ -79,7 +79,7 @@ public void testEmptyRow() throws Exception
         RowMutation rm;
 
         rm = new RowMutation("Keyspace1", "key1".getBytes());
-        rm.delete(new QueryPath("Standard2", null, null), System.currentTimeMillis());
+        rm.delete(new QueryPath("Standard2", null, null), new TimestampClock(System.currentTimeMillis()));
         rm.apply();
 
         Runnable r = new WrappedRunnable()
@@ -112,7 +112,7 @@ private void testAntiCompaction(String columnFamilyName, int insertsPerTable) th
         {
             String key = String.valueOf(j);
             RowMutation rm = new RowMutation("Keyspace1", key.getBytes());
-            rm.add(new QueryPath(columnFamilyName, null, "0".getBytes()), new byte[0], j);
+            rm.add(new QueryPath(columnFamilyName, null, "0".getBytes()), new byte[0], new TimestampClock(j));
             rms.add(rm);
         }
         ColumnFamilyStore store = Util.writeColumnFamily(rms);
@@ -166,12 +166,12 @@ private ColumnFamilyStore insertKey1Key2() throws IOException, ExecutionExceptio
         List<RowMutation> rms = new LinkedList<RowMutation>();
         RowMutation rm;
         rm = new RowMutation("Keyspace2", "key1".getBytes());
-        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), 0);
+        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), new TimestampClock(0));
         rms.add(rm);
         Util.writeColumnFamily(rms);
 
         rm = new RowMutation("Keyspace2", "key2".getBytes());
-        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), 0);
+        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), new TimestampClock(0));
         rms.add(rm);
         return Util.writeColumnFamily(rms);
     }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
index 743e6114..b7e3f067 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/ColumnFamilyTest.java
@@ -41,7 +41,7 @@ public void testSingleColumn() throws IOException
         ColumnFamily cf;
 
         cf = ColumnFamily.create("Keyspace1", "Standard1");
-        cf.addColumn(column("C", "v", 1));
+        cf.addColumn(column("C", "v", new TimestampClock(1)));
         DataOutputBuffer bufOut = new DataOutputBuffer();
         ColumnFamily.serializer().serialize(cf, bufOut);
 
@@ -68,7 +68,7 @@ public void testManyColumns() throws IOException
         DataOutputBuffer bufOut = new DataOutputBuffer();
         for (String cName : map.navigableKeySet())
         {
-            cf.addColumn(column(cName, map.get(cName), 314));
+            cf.addColumn(column(cName, map.get(cName), new TimestampClock(314)));
         }
         ColumnFamily.serializer().serialize(cf, bufOut);
 
@@ -87,9 +87,9 @@ public void testGetColumnCount()
     {
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
 
-        cf.addColumn(column("col1", "", 1));
-        cf.addColumn(column("col2", "", 2));
-        cf.addColumn(column("col1", "", 3));
+        cf.addColumn(column("col1", "", new TimestampClock(1)));
+        cf.addColumn(column("col2", "", new TimestampClock(2)));
+        cf.addColumn(column("col1", "", new TimestampClock(3)));
 
         assert 2 == cf.getColumnCount();
         assert 2 == cf.getSortedColumns().size();
@@ -100,9 +100,9 @@ public void testTimestamp()
     {
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
 
-        cf.addColumn(column("col1", "val1", 2));
-        cf.addColumn(column("col1", "val2", 2)); // same timestamp, new value
-        cf.addColumn(column("col1", "val3", 1)); // older timestamp -- should be ignored
+        cf.addColumn(column("col1", "val1", new TimestampClock(2)));
+        cf.addColumn(column("col1", "val2", new TimestampClock(2))); // same timestamp, new value
+        cf.addColumn(column("col1", "val3", new TimestampClock(1))); // older timestamp -- should be ignored
 
         assert Arrays.equals("val2".getBytes(), cf.getColumn("col1".getBytes()).value());
     }
@@ -117,11 +117,11 @@ public void testMergeAndAdd()
         byte val2[] = "x value ".getBytes();
 
         // exercise addColumn(QueryPath, ...)
-        cf_new.addColumn(QueryPath.column("col1".getBytes()), val, 3);
-        cf_new.addColumn(QueryPath.column("col2".getBytes()), val, 4);
+        cf_new.addColumn(QueryPath.column("col1".getBytes()), val, new TimestampClock(3));
+        cf_new.addColumn(QueryPath.column("col2".getBytes()), val, new TimestampClock(4));
 
-        cf_old.addColumn(QueryPath.column("col2".getBytes()), val2, 1);
-        cf_old.addColumn(QueryPath.column("col3".getBytes()), val2, 2);
+        cf_old.addColumn(QueryPath.column("col2".getBytes()), val2, new TimestampClock(1));
+        cf_old.addColumn(QueryPath.column("col3".getBytes()), val2, new TimestampClock(2));
 
         cf_result.addAll(cf_new);
         cf_result.addAll(cf_old);
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/CommitLogTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/CommitLogTest.java
index d5dd6062..9648cdd4 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/CommitLogTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/CommitLogTest.java
@@ -45,8 +45,8 @@ public void testCleanup() throws IOException, ExecutionException, InterruptedExc
         for (int i = 0; i < 10; i++)
         {
             rm = new RowMutation("Keyspace1", "key1".getBytes());
-            rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), value, 0);
-            rm.add(new QueryPath("Standard2", null, "Column1".getBytes()), value, 0);
+            rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), value, new TimestampClock(0));
+            rm.add(new QueryPath("Standard2", null, "Column1".getBytes()), value, new TimestampClock(0));
             rm.apply();
         }
         assert CommitLog.instance().getSegmentCount() > 1;
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsPurgeTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsPurgeTest.java
index 433e5377..d0421bfc 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsPurgeTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsPurgeTest.java
@@ -59,7 +59,7 @@ public void testCompactionPurge() throws IOException, ExecutionException, Interr
         rm = new RowMutation(TABLE1, key.key);
         for (int i = 0; i < 10; i++)
         {
-            rm.add(new QueryPath(cfName, null, String.valueOf(i).getBytes()), new byte[0], 0);
+            rm.add(new QueryPath(cfName, null, String.valueOf(i).getBytes()), new byte[0], new TimestampClock(0));
         }
         rm.apply();
         cfs.forceBlockingFlush();
@@ -68,21 +68,21 @@ public void testCompactionPurge() throws IOException, ExecutionException, Interr
         for (int i = 0; i < 10; i++)
         {
             rm = new RowMutation(TABLE1, key.key);
-            rm.delete(new QueryPath(cfName, null, String.valueOf(i).getBytes()), 1);
+            rm.delete(new QueryPath(cfName, null, String.valueOf(i).getBytes()), new TimestampClock(1));
             rm.apply();
         }
         cfs.forceBlockingFlush();
 
         // resurrect one column
         rm = new RowMutation(TABLE1, key.key);
-        rm.add(new QueryPath(cfName, null, String.valueOf(5).getBytes()), new byte[0], 2);
+        rm.add(new QueryPath(cfName, null, String.valueOf(5).getBytes()), new byte[0], new TimestampClock(2));
         rm.apply();
         cfs.forceBlockingFlush();
 
         // verify that non-major compaction does no GC to ensure correctness (see CASSANDRA-604)
         Collection<SSTableReader> sstablesIncomplete = cfs.getSSTables();
         rm = new RowMutation(TABLE1, Util.dk("blah").key);
-        rm.add(new QueryPath(cfName, null, "0".getBytes()), new byte[0], 0);
+        rm.add(new QueryPath(cfName, null, "0".getBytes()), new byte[0], new TimestampClock(0));
         rm.apply();
         cfs.forceBlockingFlush();
         CompactionManager.instance.doCompaction(cfs, sstablesIncomplete, CompactionManager.getDefaultGCBefore());
@@ -113,7 +113,7 @@ public void testCompactionPurgeOneFile() throws IOException, ExecutionException,
         rm = new RowMutation(TABLE1, key.key);
         for (int i = 0; i < 5; i++)
         {
-            rm.add(new QueryPath(cfName, null, String.valueOf(i).getBytes()), new byte[0], 0);
+            rm.add(new QueryPath(cfName, null, String.valueOf(i).getBytes()), new byte[0], new TimestampClock(0));
         }
         rm.apply();
 
@@ -121,7 +121,7 @@ public void testCompactionPurgeOneFile() throws IOException, ExecutionException,
         for (int i = 0; i < 5; i++)
         {
             rm = new RowMutation(TABLE1, key.key);
-            rm.delete(new QueryPath(cfName, null, String.valueOf(i).getBytes()), 1);
+            rm.delete(new QueryPath(cfName, null, String.valueOf(i).getBytes()), new TimestampClock(1));
             rm.apply();
         }
         store.forceBlockingFlush();
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsTest.java
index 01b94e59..761030cf 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/CompactionsTest.java
@@ -57,7 +57,7 @@ public void testCompactions() throws IOException, ExecutionException, Interrupte
             for (int i = 0; i < ROWS_PER_SSTABLE; i++) {
                 DecoratedKey key = Util.dk(String.valueOf(i % 2));
                 RowMutation rm = new RowMutation(TABLE1, key.key);
-                rm.add(new QueryPath("Standard1", null, String.valueOf(i / 2).getBytes()), new byte[0], j * ROWS_PER_SSTABLE + i);
+                rm.add(new QueryPath("Standard1", null, String.valueOf(i / 2).getBytes()), new byte[0], new TimestampClock(j * ROWS_PER_SSTABLE + i));
                 rm.apply();
                 inserted.add(key);
             }
@@ -90,7 +90,7 @@ public void testCompactionReadonly() throws IOException, ExecutionException, Int
             for (int i = 0; i < ROWS_PER_SSTABLE; i++) {
                 byte[] key = String.valueOf(i % 2).getBytes();
                 RowMutation rm = new RowMutation(TABLE2, key);
-                rm.add(new QueryPath("Standard1", null, String.valueOf(i / 2).getBytes()), new byte[0], j * ROWS_PER_SSTABLE + i);
+                rm.add(new QueryPath("Standard1", null, String.valueOf(i / 2).getBytes()), new byte[0], new TimestampClock(j * ROWS_PER_SSTABLE + i));
                 rm.apply();
             }
             store.forceBlockingFlush();
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
index d2dc9c9f..32966913 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
@@ -80,7 +80,7 @@ public void saveAndRestore() throws IOException
     @Test
     public void addNewCfToBogusTable() throws InterruptedException
     {
-        CFMetaData newCf = new CFMetaData("MadeUpKeyspace", "NewCF", ColumnFamilyType.Standard, new UTF8Type(), null, "new cf", 0, false, 0);
+        CFMetaData newCf = new CFMetaData("MadeUpKeyspace", "NewCF", ColumnFamilyType.Standard, ClockType.Timestamp, new UTF8Type(), null, "new cf", 0, false, 0);
         try
         {
             new AddColumnFamily(newCf).apply();
@@ -105,7 +105,7 @@ public void testMigrations() throws IOException, ConfigurationException
         assert DatabaseDescriptor.getDefsVersion().equals(prior);
         
         // add a cf.
-        CFMetaData newCf1 = new CFMetaData("Keyspace1", "MigrationCf_1", ColumnFamilyType.Standard, new UTF8Type(), null, "Migration CF ", 0, false, 0);
+        CFMetaData newCf1 = new CFMetaData("Keyspace1", "MigrationCf_1", ColumnFamilyType.Standard, ClockType.Timestamp, new UTF8Type(), null, "Migration CF ", 0, false, 0);
         Migration m1 = new AddColumnFamily(newCf1);
         m1.apply();
         UUID ver1 = m1.getVersion();
@@ -164,7 +164,7 @@ public void addNewCF() throws ConfigurationException, IOException, ExecutionExce
         final String cf = "BrandNewCf";
         KSMetaData original = DatabaseDescriptor.getTableDefinition(ks);
 
-        CFMetaData newCf = new CFMetaData(original.name, cf, ColumnFamilyType.Standard, new UTF8Type(), null, "A New Column Family", 0, false, 0);
+        CFMetaData newCf = new CFMetaData(original.name, cf, ColumnFamilyType.Standard, ClockType.Timestamp, new UTF8Type(), null, "A New Column Family", 0, false, 0);
         int clSegments = CommitLog.instance().getSegmentCount();
         assert !DatabaseDescriptor.getTableDefinition(ks).cfMetaData().containsKey(newCf.cfName);
         new AddColumnFamily(newCf).apply();
@@ -176,7 +176,7 @@ public void addNewCF() throws ConfigurationException, IOException, ExecutionExce
         // now read and write to it.
         DecoratedKey dk = Util.dk("key0");
         RowMutation rm = new RowMutation(ks, dk.key);
-        rm.add(new QueryPath(cf, null, "col0".getBytes()), "value0".getBytes(), 1L);
+        rm.add(new QueryPath(cf, null, "col0".getBytes()), "value0".getBytes(), new TimestampClock(1L));
         rm.apply();
         ColumnFamilyStore store = Table.open(ks).getColumnFamilyStore(cf);
         assert store != null;
@@ -201,7 +201,7 @@ public void dropCf() throws ConfigurationException, IOException, ExecutionExcept
         // write some data, force a flush, then verify that files exist on disk.
         RowMutation rm = new RowMutation(ks.name, dk.key);
         for (int i = 0; i < 100; i++)
-            rm.add(new QueryPath(cfm.cfName, null, ("col" + i).getBytes()), "anyvalue".getBytes(), 1L);
+            rm.add(new QueryPath(cfm.cfName, null, ("col" + i).getBytes()), "anyvalue".getBytes(), new TimestampClock(1L));
         rm.apply();
         ColumnFamilyStore store = Table.open(cfm.tableName).getColumnFamilyStore(cfm.cfName);
         assert store != null;
@@ -217,7 +217,7 @@ public void dropCf() throws ConfigurationException, IOException, ExecutionExcept
         rm = new RowMutation(ks.name, dk.key);
         try
         {
-            rm.add(new QueryPath("Standard1", null, "col0".getBytes()), "value0".getBytes(), 1L);
+            rm.add(new QueryPath("Standard1", null, "col0".getBytes()), "value0".getBytes(), new TimestampClock(1L));
             rm.apply();
             assert false : "This mutation should have failed since the CF no longer exists.";
         }
@@ -242,7 +242,7 @@ public void renameCf() throws ConfigurationException, IOException, ExecutionExce
         // write some data, force a flush, then verify that files exist on disk.
         RowMutation rm = new RowMutation(ks.name, dk.key);
         for (int i = 0; i < 100; i++)
-            rm.add(new QueryPath(oldCfm.cfName, null, ("col" + i).getBytes()), "anyvalue".getBytes(), 1L);
+            rm.add(new QueryPath(oldCfm.cfName, null, ("col" + i).getBytes()), "anyvalue".getBytes(), new TimestampClock(1L));
         rm.apply();
         ColumnFamilyStore store = Table.open(oldCfm.tableName).getColumnFamilyStore(oldCfm.cfName);
         assert store != null;
@@ -267,7 +267,7 @@ public void renameCf() throws ConfigurationException, IOException, ExecutionExce
         
         // do some writes
         rm = new RowMutation(ks.name, dk.key);
-        rm.add(new QueryPath(cfName, null, "col5".getBytes()), "updated".getBytes(), 2L);
+        rm.add(new QueryPath(cfName, null, "col5".getBytes()), "updated".getBytes(), new TimestampClock(2L));
         rm.apply();
         store.forceBlockingFlush();
         
@@ -280,7 +280,7 @@ public void renameCf() throws ConfigurationException, IOException, ExecutionExce
     public void addNewKS() throws ConfigurationException, IOException, ExecutionException, InterruptedException
     {
         DecoratedKey dk = Util.dk("key0");
-        CFMetaData newCf = new CFMetaData("NewKeyspace1", "AddedStandard1", ColumnFamilyType.Standard, new UTF8Type(), null, "A new cf for a new ks", 0, false, 0);
+        CFMetaData newCf = new CFMetaData("NewKeyspace1", "AddedStandard1", ColumnFamilyType.Standard, ClockType.Timestamp, new UTF8Type(), null, "A new cf for a new ks", 0, false, 0);
         KSMetaData newKs = new KSMetaData(newCf.tableName, RackUnawareStrategy.class, 5, newCf);
         
         int segmentCount = CommitLog.instance().getSegmentCount();
@@ -292,7 +292,7 @@ public void addNewKS() throws ConfigurationException, IOException, ExecutionExce
 
         // test reads and writes.
         RowMutation rm = new RowMutation(newCf.tableName, dk.key);
-        rm.add(new QueryPath(newCf.cfName, null, "col0".getBytes()), "value0".getBytes(), 1L);
+        rm.add(new QueryPath(newCf.cfName, null, "col0".getBytes()), "value0".getBytes(), new TimestampClock(1L));
         rm.apply();
         ColumnFamilyStore store = Table.open(newCf.tableName).getColumnFamilyStore(newCf.cfName);
         assert store != null;
@@ -317,7 +317,7 @@ public void dropKS() throws ConfigurationException, IOException, ExecutionExcept
         // write some data, force a flush, then verify that files exist on disk.
         RowMutation rm = new RowMutation(ks.name, dk.key);
         for (int i = 0; i < 100; i++)
-            rm.add(new QueryPath(cfm.cfName, null, ("col" + i).getBytes()), "anyvalue".getBytes(), 1L);
+            rm.add(new QueryPath(cfm.cfName, null, ("col" + i).getBytes()), "anyvalue".getBytes(), new TimestampClock(1L));
         rm.apply();
         ColumnFamilyStore store = Table.open(cfm.tableName).getColumnFamilyStore(cfm.cfName);
         assert store != null;
@@ -332,7 +332,7 @@ public void dropKS() throws ConfigurationException, IOException, ExecutionExcept
         rm = new RowMutation(ks.name, dk.key);
         try
         {
-            rm.add(new QueryPath("Standard1", null, "col0".getBytes()), "value0".getBytes(), 1L);
+            rm.add(new QueryPath("Standard1", null, "col0".getBytes()), "value0".getBytes(), new TimestampClock(1L));
             rm.apply();
             throw new AssertionError("This mutation should have failed since the CF no longer exists.");
         }
@@ -366,7 +366,7 @@ public void renameKs() throws ConfigurationException, IOException, ExecutionExce
         // write some data that we hope to read back later.
         RowMutation rm = new RowMutation(oldKs.name, dk.key);
         for (int i = 0; i < 10; i++)
-            rm.add(new QueryPath(cfName, null, ("col" + i).getBytes()), "value".getBytes(), 1L);
+            rm.add(new QueryPath(cfName, null, ("col" + i).getBytes()), "value".getBytes(), new TimestampClock(1L));
         rm.apply();
         ColumnFamilyStore store = Table.open(oldKs.name).getColumnFamilyStore(cfName);
         assert store != null;
@@ -399,7 +399,7 @@ public void renameKs() throws ConfigurationException, IOException, ExecutionExce
         rm = new RowMutation(oldKs.name, "any key will do".getBytes());
         try
         {
-            rm.add(new QueryPath(cfName, null, "col0".getBytes()), "value0".getBytes(), 1L);
+            rm.add(new QueryPath(cfName, null, "col0".getBytes()), "value0".getBytes(), new TimestampClock(1L));
             rm.apply();
             throw new AssertionError("This mutation should have failed since the CF/Table no longer exists.");
         }
@@ -410,7 +410,7 @@ public void renameKs() throws ConfigurationException, IOException, ExecutionExce
         
         // write on new should work.
         rm = new RowMutation(newKsName, dk.key);
-        rm.add(new QueryPath(cfName, null, "col0".getBytes()), "newvalue".getBytes(), 2L);
+        rm.add(new QueryPath(cfName, null, "col0".getBytes()), "newvalue".getBytes(), new TimestampClock(2L));
         rm.apply();
         store = Table.open(newKs.name).getColumnFamilyStore(cfName);
         assert store != null;
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/MultitableTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/MultitableTest.java
index 40bba6e9..81aebeb3 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/MultitableTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/MultitableTest.java
@@ -46,13 +46,13 @@ public void testSameCFs() throws IOException, ExecutionException, InterruptedExc
 
         rm = new RowMutation("Keyspace1", dk.key);
         cf = ColumnFamily.create("Keyspace1", "Standard1");
-        cf.addColumn(column("col1", "val1", 1L));
+        cf.addColumn(column("col1", "val1", new TimestampClock(1L)));
         rm.add(cf);
         rm.apply();
 
         rm = new RowMutation("Keyspace2", dk.key);
         cf = ColumnFamily.create("Keyspace2", "Standard1");
-        cf.addColumn(column("col2", "val2", 1L));
+        cf.addColumn(column("col2", "val2", new TimestampClock(1L)));
         rm.add(cf);
         rm.apply();
 
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/NameSortTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/NameSortTest.java
index 3ef563c0..38e023b0 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/NameSortTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/NameSortTest.java
@@ -73,7 +73,7 @@ private void testNameSort(int N) throws IOException, ExecutionException, Interru
             {
                 byte[] bytes = j % 2 == 0 ? "a".getBytes() : "b".getBytes();
                 rm = new RowMutation("Keyspace1", key);
-                rm.add(new QueryPath("Standard1", null, ("Column-" + j).getBytes()), bytes, j);
+                rm.add(new QueryPath("Standard1", null, ("Column-" + j).getBytes()), bytes, new TimestampClock(j));
                 rm.apply();
             }
 
@@ -84,7 +84,7 @@ private void testNameSort(int N) throws IOException, ExecutionException, Interru
                 for (int k = 0; k < 4; ++k)
                 {
                     String value = (j + k) % 2 == 0 ? "a" : "b";
-                    addMutation(rm, "Super1", "SuperColumn-" + j, k, value, k);
+                    addMutation(rm, "Super1", "SuperColumn-" + j, k, value, new TimestampClock(k));
                 }
                 rm.apply();
             }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/OneCompactionTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/OneCompactionTest.java
index 6d5683e9..bfe7716d 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/OneCompactionTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/OneCompactionTest.java
@@ -44,7 +44,7 @@ private void testCompaction(String columnFamilyName, int insertsPerTable) throws
         for (int j = 0; j < insertsPerTable; j++) {
             DecoratedKey key = Util.dk(String.valueOf(j));
             RowMutation rm = new RowMutation("Keyspace1", key.key);
-            rm.add(new QueryPath(columnFamilyName, null, "0".getBytes()), new byte[0], j);
+            rm.add(new QueryPath(columnFamilyName, null, "0".getBytes()), new byte[0], new TimestampClock(j));
             rm.apply();
             inserted.add(key);
             store.forceBlockingFlush();
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/ReadMessageTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/ReadMessageTest.java
index eb751302..ac8905c1 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/ReadMessageTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/ReadMessageTest.java
@@ -105,7 +105,7 @@ public void testGetColumn() throws IOException, ColumnFamilyNotDefinedException
 
         // add data
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "abcd".getBytes(), 0);
+        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "abcd".getBytes(), new TimestampClock(0));
         rm.apply();
 
         ReadCommand command = new SliceByNamesReadCommand("Keyspace1", dk.key, new QueryPath("Standard1"), Arrays.asList("Column1".getBytes()));
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
index 0c957e76..35a38529 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManager2Test.java
@@ -60,7 +60,7 @@ private void insertRow(String key) throws IOException
     {
         RowMutation rm = new RowMutation("Keyspace1", key.getBytes());
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
-        cf.addColumn(column("col1", "val1", 1L));
+        cf.addColumn(column("col1", "val1", new TimestampClock(1L)));
         rm.add(cf);
         rm.apply();
     }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
index 4ca71435..112c17f7 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManagerTest.java
@@ -51,13 +51,13 @@ public void testOne() throws IOException, ExecutionException, InterruptedExcepti
 
         rm = new RowMutation("Keyspace1", dk.key);
         cf = ColumnFamily.create("Keyspace1", "Standard1");
-        cf.addColumn(column("col1", "val1", 1L));
+        cf.addColumn(column("col1", "val1", new TimestampClock(1L)));
         rm.add(cf);
         rm.apply();
 
         rm = new RowMutation("Keyspace2", dk.key);
         cf = ColumnFamily.create("Keyspace2", "Standard3");
-        cf.addColumn(column("col2", "val2", 1L));
+        cf.addColumn(column("col2", "val2", new TimestampClock(1L)));
         rm.add(cf);
         rm.apply();
 
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java
index 77eaeb45..3872070f 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RecoveryManagerTruncateTest.java
@@ -52,7 +52,7 @@ public void testTruncate() throws IOException, ExecutionException, InterruptedEx
 		// trucate clears memtable
 		rm = new RowMutation("Keyspace1", "keymulti".getBytes());
 		cf = ColumnFamily.create("Keyspace1", "Standard1");
-		cf.addColumn(column("col1", "val1", 1L));
+		cf.addColumn(column("col1", "val1", new TimestampClock(1L)));
 		rm.add(cf);
 		rm.apply();
 
@@ -69,7 +69,7 @@ public void testTruncate() throws IOException, ExecutionException, InterruptedEx
 		// truncate clears sstable
 		rm = new RowMutation("Keyspace1", "keymulti".getBytes());
 		cf = ColumnFamily.create("Keyspace1", "Standard1");
-		cf.addColumn(column("col1", "val1", 1L));
+		cf.addColumn(column("col1", "val1", new TimestampClock(1L)));
 		rm.add(cf);
 		rm.apply();
 		cfs.forceBlockingFlush();
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyTest.java
index a57b36e0..cae6930c 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyTest.java
@@ -42,12 +42,12 @@ public void testRemoveColumnFamily() throws IOException, ExecutionException, Int
 
         // add data
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), 0);
+        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), new TimestampClock(0));
         rm.apply();
 
         // remove
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.delete(new QueryPath("Standard1"), 1);
+        rm.delete(new QueryPath("Standard1"), new TimestampClock(1));
         rm.apply();
 
         ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Standard1", null, "Column1".getBytes())));
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush1Test.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush1Test.java
index 6d96702f..435b41a7 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush1Test.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush1Test.java
@@ -42,14 +42,14 @@ public void testRemoveColumnFamilyWithFlush1() throws IOException, ExecutionExce
 
         // add data
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), 0);
-        rm.add(new QueryPath("Standard1", null, "Column2".getBytes()), "asdf".getBytes(), 0);
+        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), new TimestampClock(0));
+        rm.add(new QueryPath("Standard1", null, "Column2".getBytes()), "asdf".getBytes(), new TimestampClock(0));
         rm.apply();
         store.forceBlockingFlush();
 
         // remove
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.delete(new QueryPath("Standard1"), 1);
+        rm.delete(new QueryPath("Standard1"), new TimestampClock(1));
         rm.apply();
 
         ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Standard1")));
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush2Test.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush2Test.java
index 2f9fb8a9..688bbf89 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush2Test.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnFamilyWithFlush2Test.java
@@ -42,11 +42,11 @@ public void testRemoveColumnFamilyWithFlush2() throws IOException, ExecutionExce
 
         // add data
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), 0);
+        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), new TimestampClock(0));
         rm.apply();
         // remove
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.delete(new QueryPath("Standard1"), 1);
+        rm.delete(new QueryPath("Standard1"), new TimestampClock(1));
         rm.apply();
         store.forceBlockingFlush();
 
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnTest.java
index fcec2a5d..6cfdc44f 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveColumnTest.java
@@ -43,13 +43,13 @@ public void testRemoveColumn() throws IOException, ExecutionException, Interrupt
 
         // add data
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), 0);
+        rm.add(new QueryPath("Standard1", null, "Column1".getBytes()), "asdf".getBytes(), new TimestampClock(0));
         rm.apply();
         store.forceBlockingFlush();
 
         // remove
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.delete(new QueryPath("Standard1", null, "Column1".getBytes()), 1);
+        rm.delete(new QueryPath("Standard1", null, "Column1".getBytes()), new TimestampClock(1));
         rm.apply();
 
         ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Standard1"), "Column1".getBytes()));
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSubColumnTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSubColumnTest.java
index cace0790..6b97f018 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSubColumnTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSubColumnTest.java
@@ -42,13 +42,13 @@ public void testRemoveSubColumn() throws IOException, ExecutionException, Interr
 
         // add data
         rm = new RowMutation("Keyspace1", dk.key);
-        Util.addMutation(rm, "Super1", "SC1", 1, "asdf", 0);
+        Util.addMutation(rm, "Super1", "SC1", 1, "asdf", new TimestampClock(0));
         rm.apply();
         store.forceBlockingFlush();
 
         // remove
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.delete(new QueryPath("Super1", "SC1".getBytes(), getBytes(1)), 1);
+        rm.delete(new QueryPath("Super1", "SC1".getBytes(), getBytes(1)), new TimestampClock(1));
         rm.apply();
 
         ColumnFamily retrieved = store.getColumnFamily(QueryFilter.getIdentityFilter(dk, new QueryPath("Super1", "SC1".getBytes())));
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java
index 9f6eae24..184fda58 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RemoveSuperColumnTest.java
@@ -46,13 +46,13 @@ public void testRemoveSuperColumn() throws IOException, ExecutionException, Inte
 
         // add data
         rm = new RowMutation("Keyspace1", dk.key);
-        addMutation(rm, "Super1", "SC1", 1, "val1", 0);
+        addMutation(rm, "Super1", "SC1", 1, "val1", new TimestampClock(0));
         rm.apply();
         store.forceBlockingFlush();
 
         // remove
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.delete(new QueryPath("Super1", "SC1".getBytes()), 1);
+        rm.delete(new QueryPath("Super1", "SC1".getBytes()), new TimestampClock(1));
         rm.apply();
 
         validateRemoveTwoSources(dk);
@@ -74,14 +74,14 @@ public void testRemoveDeletedSubColumn() throws IOException, ExecutionException,
 
         // add data
         rm = new RowMutation("Keyspace1", dk.key);
-        addMutation(rm, "Super3", "SC1", 1, "val1", 0);
-        addMutation(rm, "Super3", "SC1", 2, "val1", 0);
+        addMutation(rm, "Super3", "SC1", 1, "val1", new TimestampClock(0));
+        addMutation(rm, "Super3", "SC1", 2, "val1", new TimestampClock(0));
         rm.apply();
         store.forceBlockingFlush();
 
         // remove
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.delete(new QueryPath("Super3", "SC1".getBytes(), Util.getBytes(1)), 1);
+        rm.delete(new QueryPath("Super3", "SC1".getBytes(), Util.getBytes(1)), new TimestampClock(1));
         rm.apply();
 
         validateRemoveSubColumn(dk);
@@ -101,7 +101,7 @@ private void validateRemoveTwoSources(DecoratedKey dk) throws IOException
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super1");
         ColumnFamily resolved = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super1"), "SC1".getBytes()));
-        assert resolved.getSortedColumns().iterator().next().getMarkedForDeleteAt() == 1 : resolved;
+        assert ((TimestampClock)resolved.getSortedColumns().iterator().next().getMarkedForDeleteAt()).timestamp() == 1 : resolved;
         assert resolved.getSortedColumns().iterator().next().getSubColumns().size() == 0 : resolved;
         assertNull(ColumnFamilyStore.removeDeleted(resolved, Integer.MAX_VALUE));
         assertNull(store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super1"), "SC1".getBytes()), Integer.MAX_VALUE));
@@ -113,7 +113,7 @@ private void validateRemoveCompacted(DecoratedKey dk) throws IOException
     {
         ColumnFamilyStore store = Table.open("Keyspace1").getColumnFamilyStore("Super1");
         ColumnFamily resolved = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super1"), "SC1".getBytes()));
-        assert resolved.getSortedColumns().iterator().next().getMarkedForDeleteAt() == 1;
+        assert ((TimestampClock)resolved.getSortedColumns().iterator().next().getMarkedForDeleteAt()).timestamp() == 1;
         Collection<IColumn> subColumns = resolved.getSortedColumns().iterator().next().getSubColumns();
         assert subColumns.size() == 0;
     }
@@ -127,18 +127,18 @@ public void testRemoveSuperColumnWithNewData() throws IOException, ExecutionExce
 
         // add data
         rm = new RowMutation("Keyspace1", dk.key);
-        addMutation(rm, "Super2", "SC1", 1, "val1", 0);
+        addMutation(rm, "Super2", "SC1", 1, "val1", new TimestampClock(0));
         rm.apply();
         store.forceBlockingFlush();
 
         // remove
         rm = new RowMutation("Keyspace1", dk.key);
-        rm.delete(new QueryPath("Super2", "SC1".getBytes()), 1);
+        rm.delete(new QueryPath("Super2", "SC1".getBytes()), new TimestampClock(1));
         rm.apply();
 
         // new data
         rm = new RowMutation("Keyspace1", dk.key);
-        addMutation(rm, "Super2", "SC1", 2, "val2", 2);
+        addMutation(rm, "Super2", "SC1", 2, "val2", new TimestampClock(2));
         rm.apply();
 
         validateRemoveWithNewData(dk);
@@ -157,7 +157,7 @@ private void validateRemoveWithNewData(DecoratedKey dk) throws IOException
         ColumnFamily resolved = store.getColumnFamily(QueryFilter.getNamesFilter(dk, new QueryPath("Super2", "SC1".getBytes()), getBytes(2)), Integer.MAX_VALUE);
         Collection<IColumn> subColumns = resolved.getSortedColumns().iterator().next().getSubColumns();
         assert subColumns.size() == 1;
-        assert subColumns.iterator().next().timestamp() == 2;
+        assert ((TimestampClock)subColumns.iterator().next().clock()).timestamp() == 2;
     }
 
     @Test
@@ -169,24 +169,24 @@ public void testRemoveSuperColumnResurrection() throws IOException, ExecutionExc
 
         // add data
         rm = new RowMutation("Keyspace1", key.key);
-        addMutation(rm, "Super2", "SC1", 1, "val1", 0);
+        addMutation(rm, "Super2", "SC1", 1, "val1", new TimestampClock(0));
         rm.apply();
 
         // remove
         rm = new RowMutation("Keyspace1", key.key);
-        rm.delete(new QueryPath("Super2", "SC1".getBytes()), 1);
+        rm.delete(new QueryPath("Super2", "SC1".getBytes()), new TimestampClock(1));
         rm.apply();
         assertNull(store.getColumnFamily(QueryFilter.getNamesFilter(key, new QueryPath("Super2"), "SC1".getBytes()), Integer.MAX_VALUE));
 
         // resurrect
         rm = new RowMutation("Keyspace1", key.key);
-        addMutation(rm, "Super2", "SC1", 1, "val2", 2);
+        addMutation(rm, "Super2", "SC1", 1, "val2", new TimestampClock(2));
         rm.apply();
 
         // validate
         ColumnFamily resolved = store.getColumnFamily(QueryFilter.getNamesFilter(key, new QueryPath("Super2"), "SC1".getBytes()), Integer.MAX_VALUE);
         Collection<IColumn> subColumns = resolved.getSortedColumns().iterator().next().getSubColumns();
         assert subColumns.size() == 1;
-        assert subColumns.iterator().next().timestamp() == 2;
+        assert ((TimestampClock)subColumns.iterator().next().clock()).timestamp() == 2;
     }
 }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/RowTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/RowTest.java
index 5618970d..57c6379b 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/RowTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/RowTest.java
@@ -33,39 +33,39 @@
     public void testDiffColumnFamily()
     {
         ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
-        cf1.addColumn(column("one", "onev", 0));
+        cf1.addColumn(column("one", "onev", new TimestampClock(0)));
 
         ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
-        cf2.delete(0, 0);
+        cf2.delete(0, new TimestampClock(0));
 
         ColumnFamily cfDiff = cf1.diff(cf2);
         assertEquals(cfDiff.getColumnsMap().size(), 0);
-        assertEquals(cfDiff.getMarkedForDeleteAt(), 0);
+        assertEquals(((TimestampClock) cfDiff.getMarkedForDeleteAt()).timestamp(), 0);
     }
 
     @Test
     public void testDiffSuperColumn()
     {
-        SuperColumn sc1 = new SuperColumn("one".getBytes(), new AsciiType());
-        sc1.addColumn(column("subcolumn", "A", 0));
+        SuperColumn sc1 = new SuperColumn("one".getBytes(), new AsciiType(), ClockType.Timestamp);
+        sc1.addColumn(column("subcolumn", "A", new TimestampClock(0)));
 
-        SuperColumn sc2 = new SuperColumn("one".getBytes(), new AsciiType());
-        sc2.markForDeleteAt(0, 0);
+        SuperColumn sc2 = new SuperColumn("one".getBytes(), new AsciiType(), ClockType.Timestamp);
+        sc2.markForDeleteAt(0, new TimestampClock(0));
 
         SuperColumn scDiff = (SuperColumn)sc1.diff(sc2);
         assertEquals(scDiff.getSubColumns().size(), 0);
-        assertEquals(scDiff.getMarkedForDeleteAt(), 0);
+        assertEquals(((TimestampClock)scDiff.getMarkedForDeleteAt()).timestamp(), 0);
     }
 
     @Test
     public void testResolve()
     {
         ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
-        cf1.addColumn(column("one", "A", 0));
+        cf1.addColumn(column("one", "A", new TimestampClock(0)));
 
         ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
-        cf2.addColumn(column("one", "B", 1));
-        cf2.addColumn(column("two", "C", 1));
+        cf2.addColumn(column("one", "B", new TimestampClock(1)));
+        cf2.addColumn(column("two", "C", new TimestampClock(1)));
 
         cf1.resolve(cf2);
         assert Arrays.equals(cf1.getColumn("one".getBytes()).value(), "B".getBytes());
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/SuperColumnTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/SuperColumnTest.java
index 6d5d4bc5..2e3761f9 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/SuperColumnTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/SuperColumnTest.java
@@ -1,6 +1,5 @@
 /*
-* Licensed to the Apache Software Foundation (ASF) under one
-* or more contributor license agreements.  See the NOTICE file
+* Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
@@ -29,8 +28,8 @@
 {   
     @Test
     public void testMissingSubcolumn() {
-    	SuperColumn sc = new SuperColumn("sc1".getBytes(), new LongType());
-    	sc.addColumn(new Column(getBytes(1), "value".getBytes(), 1));
+    	SuperColumn sc = new SuperColumn("sc1".getBytes(), new LongType(), ClockType.Timestamp);
+    	sc.addColumn(new Column(getBytes(1), "value".getBytes(), new TimestampClock(1)));
     	assertNotNull(sc.getSubColumn(getBytes(1)));
     	assertNull(sc.getSubColumn(getBytes(2)));
     }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/TableTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/TableTest.java
index f075aceb..116999fa 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/TableTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/TableTest.java
@@ -70,7 +70,7 @@ public void testGetRowNoColumns() throws Throwable
 
         RowMutation rm = new RowMutation("Keyspace2", TEST_KEY.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace2", "Standard3");
-        cf.addColumn(column("col1","val1", 1L));
+        cf.addColumn(column("col1","val1", new TimestampClock(1L)));
         rm.add(cf);
         rm.apply();
 
@@ -101,9 +101,9 @@ public void testGetRowSingleColumn() throws Throwable
 
         RowMutation rm = new RowMutation("Keyspace1", TEST_KEY.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
-        cf.addColumn(column("col1","val1", 1L));
-        cf.addColumn(column("col2","val2", 1L));
-        cf.addColumn(column("col3","val3", 1L));
+        cf.addColumn(column("col1","val1", new TimestampClock(1L)));
+        cf.addColumn(column("col2","val2", new TimestampClock(1L)));
+        cf.addColumn(column("col3","val3", new TimestampClock(1L)));
         rm.add(cf);
         rm.apply();
 
@@ -132,9 +132,9 @@ public void testGetRowSliceByRange() throws Throwable
     	RowMutation rm = new RowMutation("Keyspace1", key.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
         // First write "a", "b", "c"
-        cf.addColumn(column("a", "val1", 1L));
-        cf.addColumn(column("b", "val2", 1L));
-        cf.addColumn(column("c", "val3", 1L));
+        cf.addColumn(column("a", "val1", new TimestampClock(1L)));
+        cf.addColumn(column("b", "val2", new TimestampClock(1L)));
+        cf.addColumn(column("c", "val3", new TimestampClock(1L)));
         rm.add(cf);
         rm.apply();
         
@@ -157,7 +157,7 @@ public void testGetSliceNoMatch() throws Throwable
         Table table = Table.open("Keyspace1");
         RowMutation rm = new RowMutation("Keyspace1", "row1000".getBytes());
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard2");
-        cf.addColumn(column("col1", "val1", 1));
+        cf.addColumn(column("col1", "val1", new TimestampClock(1)));
         rm.add(cf);
         rm.apply();
 
@@ -185,7 +185,7 @@ public void testGetSliceWithCutoff() throws Throwable
         // at this rate, we're getting 78-79 cos/block, assuming the blocks are set to be about 4k.
         // so if we go to 300, we'll get at least 4 blocks, which is plenty for testing.
         for (int i = 0; i < 300; i++)
-            cf.addColumn(column("col" + fmt.format(i), "omg!thisisthevalue!"+i, 1L));
+            cf.addColumn(column("col" + fmt.format(i), "omg!thisisthevalue!"+i, new TimestampClock(1L)));
         rm.add(cf);
         rm.apply();
 
@@ -244,7 +244,7 @@ public void testGetSliceWithBitmasks() throws Throwable
         // at this rate, we're getting 78-79 cos/block, assuming the blocks are set to be about 4k.
         // so if we go to 300, we'll get at least 4 blocks, which is plenty for testing.
         for (int i = 0; i < 300; i++)
-            cf.addColumn(column("col" + fmt.format(i), "omg!thisisthevalue!"+i, 1L));
+            cf.addColumn(column("col" + fmt.format(i), "omg!thisisthevalue!"+i, new TimestampClock(1L)));
         rm.add(cf);
         rm.apply();
 
@@ -318,17 +318,17 @@ public void testGetSliceFromBasic() throws Throwable
 
         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
-        cf.addColumn(column("col1", "val1", 1L));
-        cf.addColumn(column("col3", "val3", 1L));
-        cf.addColumn(column("col4", "val4", 1L));
-        cf.addColumn(column("col5", "val5", 1L));
-        cf.addColumn(column("col7", "val7", 1L));
-        cf.addColumn(column("col9", "val9", 1L));
+        cf.addColumn(column("col1", "val1", new TimestampClock(1L)));
+        cf.addColumn(column("col3", "val3", new TimestampClock(1L)));
+        cf.addColumn(column("col4", "val4", new TimestampClock(1L)));
+        cf.addColumn(column("col5", "val5", new TimestampClock(1L)));
+        cf.addColumn(column("col7", "val7", new TimestampClock(1L)));
+        cf.addColumn(column("col9", "val9", new TimestampClock(1L)));
         rm.add(cf);
         rm.apply();
 
         rm = new RowMutation("Keyspace1", ROW.key);
-        rm.delete(new QueryPath("Standard1", null, "col4".getBytes()), 2L);
+        rm.delete(new QueryPath("Standard1", null, "col4".getBytes()), new TimestampClock(2L));
         rm.apply();
 
         Runnable verify = new WrappedRunnable()
@@ -374,21 +374,21 @@ public void testGetSliceFromAdvanced() throws Throwable
 
         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
-        cf.addColumn(column("col1", "val1", 1L));
-        cf.addColumn(column("col2", "val2", 1L));
-        cf.addColumn(column("col3", "val3", 1L));
-        cf.addColumn(column("col4", "val4", 1L));
-        cf.addColumn(column("col5", "val5", 1L));
-        cf.addColumn(column("col6", "val6", 1L));
+        cf.addColumn(column("col1", "val1", new TimestampClock(1L)));
+        cf.addColumn(column("col2", "val2", new TimestampClock(1L)));
+        cf.addColumn(column("col3", "val3", new TimestampClock(1L)));
+        cf.addColumn(column("col4", "val4", new TimestampClock(1L)));
+        cf.addColumn(column("col5", "val5", new TimestampClock(1L)));
+        cf.addColumn(column("col6", "val6", new TimestampClock(1L)));
         rm.add(cf);
         rm.apply();
         cfStore.forceBlockingFlush();
 
         rm = new RowMutation("Keyspace1", ROW.key);
         cf = ColumnFamily.create("Keyspace1", "Standard1");
-        cf.addColumn(column("col1", "valx", 2L));
-        cf.addColumn(column("col2", "valx", 2L));
-        cf.addColumn(column("col3", "valx", 2L));
+        cf.addColumn(column("col1", "valx", new TimestampClock(2L)));
+        cf.addColumn(column("col2", "valx", new TimestampClock(2L)));
+        cf.addColumn(column("col3", "valx", new TimestampClock(2L)));
         rm.add(cf);
         rm.apply();
 
@@ -419,7 +419,7 @@ public void testGetSliceFromLarge() throws Throwable
         RowMutation rm = new RowMutation("Keyspace1", key.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Standard1");
         for (int i = 1000; i < 2000; i++)
-            cf.addColumn(column("col" + i, ("v" + i), 1L));
+            cf.addColumn(column("col" + i, ("v" + i), new TimestampClock(1L)));
         rm.add(cf);
         rm.apply();
         cfStore.forceBlockingFlush();
@@ -497,8 +497,8 @@ public void testGetSliceFromSuperBasic() throws Throwable
 
         RowMutation rm = new RowMutation("Keyspace1", ROW.key);
         ColumnFamily cf = ColumnFamily.create("Keyspace1", "Super1");
-        SuperColumn sc = new SuperColumn("sc1".getBytes(), new LongType());
-        sc.addColumn(new Column(getBytes(1), "val1".getBytes(), 1L));
+        SuperColumn sc = new SuperColumn("sc1".getBytes(), new LongType(), ClockType.Timestamp);
+        sc.addColumn(new Column(getBytes(1), "val1".getBytes(), new TimestampClock(1L)));
         cf.addColumn(sc);
         rm.add(cf);
         rm.apply();
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/TimeSortTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/TimeSortTest.java
index 48d1a3d4..0b5923c5 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/TimeSortTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/TimeSortTest.java
@@ -46,12 +46,12 @@ public void testMixedSources() throws IOException, ExecutionException, Interrupt
         DecoratedKey key = Util.dk("key0");
 
         rm = new RowMutation("Keyspace1", key.key);
-        rm.add(new QueryPath("StandardLong1", null, getBytes(100)), "a".getBytes(), 100);
+        rm.add(new QueryPath("StandardLong1", null, getBytes(100)), "a".getBytes(), new TimestampClock(100));
         rm.apply();
         cfStore.forceBlockingFlush();
 
         rm = new RowMutation("Keyspace1", key.key);
-        rm.add(new QueryPath("StandardLong1", null, getBytes(0)), "b".getBytes(), 0);
+        rm.add(new QueryPath("StandardLong1", null, getBytes(0)), "b".getBytes(), new TimestampClock(0));
         rm.apply();
 
         ColumnFamily cf = cfStore.getColumnFamily(key, new QueryPath("StandardLong1"), getBytes(10), ArrayUtils.EMPTY_BYTE_ARRAY, false, 1000);
@@ -70,7 +70,7 @@ public void testTimeSort() throws IOException, ExecutionException, InterruptedEx
             RowMutation rm = new RowMutation("Keyspace1", Integer.toString(i).getBytes());
             for (int j = 0; j < 8; ++j)
             {
-                rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2)), "a".getBytes(), j * 2);
+                rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2)), "a".getBytes(), new TimestampClock(j * 2));
             }
             rm.apply();
         }
@@ -85,13 +85,13 @@ public void testTimeSort() throws IOException, ExecutionException, InterruptedEx
         RowMutation rm = new RowMutation("Keyspace1", key.key);
         for (int j = 0; j < 4; ++j)
         {
-            rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2 + 1)), "b".getBytes(), j * 2 + 1);
+            rm.add(new QueryPath("StandardLong1", null, getBytes(j * 2 + 1)), "b".getBytes(), new TimestampClock(j * 2 + 1));
         }
         rm.apply();
         // and some overwrites
         rm = new RowMutation("Keyspace1", key.key);
-        rm.add(new QueryPath("StandardLong1", null, getBytes(0)), "c".getBytes(), 100);
-        rm.add(new QueryPath("StandardLong1", null, getBytes(10)), "c".getBytes(), 100);
+        rm.add(new QueryPath("StandardLong1", null, getBytes(0)), "c".getBytes(), new TimestampClock(100));
+        rm.add(new QueryPath("StandardLong1", null, getBytes(10)), "c".getBytes(), new TimestampClock(100));
         rm.apply();
 
         // verify
@@ -126,7 +126,8 @@ private void validateTimeSort(Table table) throws IOException
                 int k = j;
                 for (IColumn c : columns)
                 {
-                    assertEquals((k++) * 2, c.timestamp());
+                    assertEquals((k++) * 2, ((TimestampClock)c.clock()).timestamp());
+
                 }
             }
         }
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
index 6e7d4c45..59f7ce30 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableReaderTest.java
@@ -35,7 +35,7 @@ public void testSpannedIndexPositions() throws IOException, ExecutionException,
         {
             byte[] key = String.valueOf(j).getBytes();
             RowMutation rm = new RowMutation("Keyspace1", key);
-            rm.add(new QueryPath("Standard1", null, "0".getBytes()), new byte[0], j);
+            rm.add(new QueryPath("Standard1", null, "0".getBytes()), new byte[0], new TimestampClock(j));
             rm.apply();
         }
         store.forceBlockingFlush();
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java b/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
index 89ec7321..97bf2bc4 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/io/sstable/SSTableUtils.java
@@ -34,7 +34,7 @@
     public static String TABLENAME = "Keyspace1";
     public static String CFNAME = "Standard1";
 
-    public static ColumnFamily createCF(long mfda, int ldt, IColumn... cols)
+    public static ColumnFamily createCF(IClock mfda, int ldt, IColumn... cols)
     {
         ColumnFamily cf = ColumnFamily.create(TABLENAME, CFNAME);
         cf.delete(ldt, mfda);
@@ -65,7 +65,7 @@ public static SSTableReader writeSSTable(Set<String> keys) throws IOException
         for (String key : keys)
         {
             ColumnFamily cf = ColumnFamily.create(TABLENAME, CFNAME);
-            cf.addColumn(new Column(key.getBytes(), key.getBytes(), 0));
+            cf.addColumn(new Column(key.getBytes(), key.getBytes(), new TimestampClock(0)));
             map.put(key, cf);
         }
         return writeSSTable(map);
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
index dd74566d..ad3832e0 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/service/AntiEntropyServiceTest.java
@@ -119,7 +119,7 @@ public void testValidatorPrepare() throws Throwable
         List<RowMutation> rms = new LinkedList<RowMutation>();
         RowMutation rm;
         rm = new RowMutation(tablename, "key1".getBytes());
-        rm.add(new QueryPath(cfname, null, "Column1".getBytes()), "asdf".getBytes(), 0);
+        rm.add(new QueryPath(cfname, null, "Column1".getBytes()), "asdf".getBytes(), new TimestampClock(0));
         rms.add(rm);
         Util.writeColumnFamily(rms);
 
@@ -177,7 +177,7 @@ public void testTreeStore() throws Throwable
         // populate column family
         List<RowMutation> rms = new LinkedList<RowMutation>();
         RowMutation rm = new RowMutation(tablename, "key".getBytes());
-        rm.add(new QueryPath(cfname, null, "Column1".getBytes()), "asdf".getBytes(), 0);
+        rm.add(new QueryPath(cfname, null, "Column1".getBytes()), "asdf".getBytes(), new TimestampClock(0));
         rms.add(rm);
         // with two SSTables
         Util.writeColumnFamily(rms);
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/service/EmbeddedCassandraServiceTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/service/EmbeddedCassandraServiceTest.java
index a3dc51af..c235d9eb 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/service/EmbeddedCassandraServiceTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/service/EmbeddedCassandraServiceTest.java
@@ -30,6 +30,7 @@
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.config.KSMetaData;
 import org.apache.cassandra.thrift.Cassandra;
+import org.apache.cassandra.thrift.Clock;
 import org.apache.cassandra.thrift.Column;
 import org.apache.cassandra.thrift.ColumnOrSuperColumn;
 import org.apache.cassandra.thrift.Column;
@@ -111,8 +112,10 @@ public void testEmbeddedCassandraService() throws AuthenticationException, Autho
         cp.setColumn("name".getBytes("utf-8"));
 
         // insert
+        Clock clock = new Clock();
+        clock.setTimestamp(timestamp);
         client.insert(key_user_id, par, new Column("name".getBytes("utf-8"),
-                "Ran".getBytes("UTF-8"), timestamp), ConsistencyLevel.ONE);
+                "Ran".getBytes("UTF-8"), clock), ConsistencyLevel.ONE);
 
         // read
         ColumnOrSuperColumn got = client.get(key_user_id, cp,
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/service/ReadResponseResolverTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/service/ReadResponseResolverTest.java
index 8c988a2e..425086bd 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/service/ReadResponseResolverTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/service/ReadResponseResolverTest.java
@@ -27,6 +27,7 @@
 import org.junit.Test;
 
 import org.apache.cassandra.db.ColumnFamily;
+import org.apache.cassandra.db.TimestampClock;
 
 import static org.apache.cassandra.db.TableTest.assertColumns;
 import static org.apache.cassandra.Util.column;
@@ -38,10 +39,10 @@
     public void testResolveSupersetNewer()
     {
         ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
-        cf1.addColumn(column("c1", "v1", 0));
+        cf1.addColumn(column("c1", "v1", new TimestampClock(0)));
 
         ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
-        cf2.addColumn(column("c1", "v2", 1));
+        cf2.addColumn(column("c1", "v2", new TimestampClock(1)));
 
         ColumnFamily resolved = ReadResponseResolver.resolveSuperset(Arrays.asList(cf1, cf2));
         assertColumns(resolved, "c1");
@@ -53,10 +54,10 @@ public void testResolveSupersetNewer()
     public void testResolveSupersetDisjoint()
     {
         ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
-        cf1.addColumn(column("c1", "v1", 0));
+        cf1.addColumn(column("c1", "v1", new TimestampClock(0)));
 
         ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
-        cf2.addColumn(column("c2", "v2", 1));
+        cf2.addColumn(column("c2", "v2", new TimestampClock(1)));
 
         ColumnFamily resolved = ReadResponseResolver.resolveSuperset(Arrays.asList(cf1, cf2));
         assertColumns(resolved, "c1", "c2");
@@ -68,7 +69,7 @@ public void testResolveSupersetDisjoint()
     public void testResolveSupersetNullOne()
     {
         ColumnFamily cf2 = ColumnFamily.create("Keyspace1", "Standard1");
-        cf2.addColumn(column("c2", "v2", 1));
+        cf2.addColumn(column("c2", "v2", new TimestampClock(1)));
 
         ColumnFamily resolved = ReadResponseResolver.resolveSuperset(Arrays.asList(null, cf2));
         assertColumns(resolved, "c2");
@@ -80,7 +81,7 @@ public void testResolveSupersetNullOne()
     public void testResolveSupersetNullTwo()
     {
         ColumnFamily cf1 = ColumnFamily.create("Keyspace1", "Standard1");
-        cf1.addColumn(column("c1", "v1", 0));
+        cf1.addColumn(column("c1", "v1", new TimestampClock(0)));
 
         ColumnFamily resolved = ReadResponseResolver.resolveSuperset(Arrays.asList(cf1, null));
         assertColumns(resolved, "c1");
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/tools/SSTableExportTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/tools/SSTableExportTest.java
index be1c41bd..db306c32 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/tools/SSTableExportTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/tools/SSTableExportTest.java
@@ -27,6 +27,7 @@
 import org.apache.cassandra.SchemaLoader;
 import org.apache.cassandra.config.DatabaseDescriptor;
 import org.apache.cassandra.db.ColumnFamily;
+import org.apache.cassandra.db.TimestampClock;
 import org.apache.cassandra.db.filter.QueryFilter;
 import org.apache.cassandra.db.filter.QueryPath;
 import org.apache.cassandra.dht.IPartitioner;
@@ -63,14 +64,14 @@ public void testEnumeratekeys() throws IOException
         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, partitioner);
         
         // Add rowA
-        cfamily.addColumn(new QueryPath("Standard1", null, "colA".getBytes()), "valA".getBytes(), 1);
+        cfamily.addColumn(new QueryPath("Standard1", null, "colA".getBytes()), "valA".getBytes(), new TimestampClock(1));
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
         writer.append(Util.dk("rowA"), dob);
         dob.reset();
         cfamily.clear();
         
         // Add rowB
-        cfamily.addColumn(new QueryPath("Standard1", null, "colB".getBytes()), "valB".getBytes(), 1);
+        cfamily.addColumn(new QueryPath("Standard1", null, "colB".getBytes()), "valB".getBytes(), new TimestampClock(1));
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
         writer.append(Util.dk("rowB"), dob);
         dob.reset();
@@ -101,21 +102,21 @@ public void testExportSimpleCf() throws IOException    {
         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, partitioner);
         
         // Add rowA
-        cfamily.addColumn(new QueryPath("Standard1", null, "colA".getBytes()), "valA".getBytes(), 1);
+        cfamily.addColumn(new QueryPath("Standard1", null, "colA".getBytes()), "valA".getBytes(), new TimestampClock(1));
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
         writer.append(Util.dk("rowA"), dob);
         dob.reset();
         cfamily.clear();
         
         // Add rowB
-        cfamily.addColumn(new QueryPath("Standard1", null, "colB".getBytes()), "valB".getBytes(), 1);
+        cfamily.addColumn(new QueryPath("Standard1", null, "colB".getBytes()), "valB".getBytes(), new TimestampClock(1));
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
         writer.append(Util.dk("rowB"), dob);
         dob.reset();
         cfamily.clear();
 
         // Add rowExclude
-        cfamily.addColumn(new QueryPath("Standard1", null, "colX".getBytes()), "valX".getBytes(), 1);
+        cfamily.addColumn(new QueryPath("Standard1", null, "colX".getBytes()), "valX".getBytes(), new TimestampClock(1));
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
         writer.append(Util.dk("rowExclude"), dob);
         dob.reset();
@@ -151,21 +152,21 @@ public void testExportSuperCf() throws IOException
         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, partitioner);
         
         // Add rowA
-        cfamily.addColumn(new QueryPath("Super4", "superA".getBytes(), "colA".getBytes()), "valA".getBytes(), 1);
+        cfamily.addColumn(new QueryPath("Super4", "superA".getBytes(), "colA".getBytes()), "valA".getBytes(), new TimestampClock(1));
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
         writer.append(Util.dk("rowA"), dob);
         dob.reset();
         cfamily.clear();
         
         // Add rowB
-        cfamily.addColumn(new QueryPath("Super4", "superB".getBytes(), "colB".getBytes()), "valB".getBytes(), 1);
+        cfamily.addColumn(new QueryPath("Super4", "superB".getBytes(), "colB".getBytes()), "valB".getBytes(), new TimestampClock(1));
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
         writer.append(Util.dk("rowB"), dob);
         dob.reset();
         cfamily.clear();
 
         // Add rowExclude
-        cfamily.addColumn(new QueryPath("Super4", "superX".getBytes(), "colX".getBytes()), "valX".getBytes(), 1);
+        cfamily.addColumn(new QueryPath("Super4", "superX".getBytes(), "colX".getBytes()), "valX".getBytes(), new TimestampClock(1));
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
         writer.append(Util.dk("rowExclude"), dob);
         dob.reset();
@@ -199,14 +200,14 @@ public void testRoundTripStandardCf() throws IOException, ParseException
         SSTableWriter writer = new SSTableWriter(tempSS.getPath(), 2, partitioner);
         
         // Add rowA
-        cfamily.addColumn(new QueryPath("Standard1", null, "name".getBytes()), "val".getBytes(), 1);
+        cfamily.addColumn(new QueryPath("Standard1", null, "name".getBytes()), "val".getBytes(), new TimestampClock(1));
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
         writer.append(Util.dk("rowA"), dob);
         dob.reset();
         cfamily.clear();
 
         // Add rowExclude
-        cfamily.addColumn(new QueryPath("Standard1", null, "name".getBytes()), "val".getBytes(), 1);
+        cfamily.addColumn(new QueryPath("Standard1", null, "name".getBytes()), "val".getBytes(), new TimestampClock(1));
         ColumnFamily.serializer().serializeWithIndexes(cfamily, dob);
         writer.append(Util.dk("rowExclude"), dob);
         dob.reset();
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/utils/FBUtilitiesTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/utils/FBUtilitiesTest.java
index be2411b4..216f41d2 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/utils/FBUtilitiesTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/utils/FBUtilitiesTest.java
@@ -21,6 +21,12 @@
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.apache.cassandra.db.IClock;
+import org.apache.cassandra.db.TimestampClock;
+
+
 import org.junit.Test;
 
 public class FBUtilitiesTest 
@@ -53,4 +59,25 @@ public void testIntBytesConversions()
             assertEquals(i, actual);
         }
     }
+    
+    @Test
+    public void testAtomicSetMaxIClock()
+    {
+        AtomicReference<IClock> atomicClock = new AtomicReference<IClock>(null);
+        
+        // atomic < new
+        atomicClock.set(TimestampClock.MIN_VALUE);
+        FBUtilities.atomicSetMax(atomicClock, new TimestampClock(1L));
+        assert ((TimestampClock)atomicClock.get()).timestamp() == 1L;
+        
+        // atomic == new
+        atomicClock.set(new TimestampClock(3L));
+        FBUtilities.atomicSetMax(atomicClock, new TimestampClock(3L));
+        assert ((TimestampClock)atomicClock.get()).timestamp() == 3L;
+
+        // atomic > new
+        atomicClock.set(new TimestampClock(9L));
+        FBUtilities.atomicSetMax(atomicClock, new TimestampClock(3L));
+        assert ((TimestampClock)atomicClock.get()).timestamp() == 9L;
+    } 
 }
