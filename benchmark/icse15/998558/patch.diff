diff --git a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/CfDef.java b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/CfDef.java
index 29c2ff95..6ba6fc52 100644
--- a/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/CfDef.java
+++ b/cassandra/trunk/interface/thrift/gen-java/org/apache/cassandra/thrift/CfDef.java
@@ -65,6 +65,8 @@
   private static final TField GC_GRACE_SECONDS_FIELD_DESC = new TField("gc_grace_seconds", TType.I32, (short)14);
   private static final TField DEFAULT_VALIDATION_CLASS_FIELD_DESC = new TField("default_validation_class", TType.STRING, (short)15);
   private static final TField ID_FIELD_DESC = new TField("id", TType.I32, (short)16);
+  private static final TField MIN_COMPACTION_THRESHOLD_FIELD_DESC = new TField("min_compaction_threshold", TType.I32, (short)17);
+  private static final TField MAX_COMPACTION_THRESHOLD_FIELD_DESC = new TField("max_compaction_threshold", TType.I32, (short)18);
 
   public String keyspace;
   public String name;
@@ -82,6 +84,8 @@
   public int gc_grace_seconds;
   public String default_validation_class;
   public int id;
+  public int min_compaction_threshold;
+  public int max_compaction_threshold;
 
   /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
   public enum _Fields implements TFieldIdEnum {
@@ -100,7 +104,9 @@
     COLUMN_METADATA((short)13, "column_metadata"),
     GC_GRACE_SECONDS((short)14, "gc_grace_seconds"),
     DEFAULT_VALIDATION_CLASS((short)15, "default_validation_class"),
-    ID((short)16, "id");
+    ID((short)16, "id"),
+    MIN_COMPACTION_THRESHOLD((short)17, "min_compaction_threshold"),
+    MAX_COMPACTION_THRESHOLD((short)18, "max_compaction_threshold");
 
     private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();
 
@@ -147,6 +153,10 @@ public static _Fields findByThriftId(int fieldId) {
           return DEFAULT_VALIDATION_CLASS;
         case 16: // ID
           return ID;
+        case 17: // MIN_COMPACTION_THRESHOLD
+          return MIN_COMPACTION_THRESHOLD;
+        case 18: // MAX_COMPACTION_THRESHOLD
+          return MAX_COMPACTION_THRESHOLD;
         default:
           return null;
       }
@@ -193,7 +203,9 @@ public String getFieldName() {
   private static final int __READ_REPAIR_CHANCE_ISSET_ID = 3;
   private static final int __GC_GRACE_SECONDS_ISSET_ID = 4;
   private static final int __ID_ISSET_ID = 5;
-  private BitSet __isset_bit_vector = new BitSet(6);
+  private static final int __MIN_COMPACTION_THRESHOLD_ISSET_ID = 6;
+  private static final int __MAX_COMPACTION_THRESHOLD_ISSET_ID = 7;
+  private BitSet __isset_bit_vector = new BitSet(8);
 
   public static final Map<_Fields, FieldMetaData> metaDataMap;
   static {
@@ -231,6 +243,10 @@ public String getFieldName() {
         new FieldValueMetaData(TType.STRING)));
     tmpMap.put(_Fields.ID, new FieldMetaData("id", TFieldRequirementType.OPTIONAL, 
         new FieldValueMetaData(TType.I32)));
+    tmpMap.put(_Fields.MIN_COMPACTION_THRESHOLD, new FieldMetaData("min_compaction_threshold", TFieldRequirementType.OPTIONAL, 
+        new FieldValueMetaData(TType.I32)));
+    tmpMap.put(_Fields.MAX_COMPACTION_THRESHOLD, new FieldMetaData("max_compaction_threshold", TFieldRequirementType.OPTIONAL, 
+        new FieldValueMetaData(TType.I32)));
     metaDataMap = Collections.unmodifiableMap(tmpMap);
     FieldMetaData.addStructMetaDataMap(CfDef.class, metaDataMap);
   }
@@ -307,6 +323,8 @@ public CfDef(CfDef other) {
       this.default_validation_class = other.default_validation_class;
     }
     this.id = other.id;
+    this.min_compaction_threshold = other.min_compaction_threshold;
+    this.max_compaction_threshold = other.max_compaction_threshold;
   }
 
   public CfDef deepCopy() {
@@ -711,6 +729,52 @@ public void setIdIsSet(boolean value) {
     __isset_bit_vector.set(__ID_ISSET_ID, value);
   }
 
+  public int getMin_compaction_threshold() {
+    return this.min_compaction_threshold;
+  }
+
+  public CfDef setMin_compaction_threshold(int min_compaction_threshold) {
+    this.min_compaction_threshold = min_compaction_threshold;
+    setMin_compaction_thresholdIsSet(true);
+    return this;
+  }
+
+  public void unsetMin_compaction_threshold() {
+    __isset_bit_vector.clear(__MIN_COMPACTION_THRESHOLD_ISSET_ID);
+  }
+
+  /** Returns true if field min_compaction_threshold is set (has been asigned a value) and false otherwise */
+  public boolean isSetMin_compaction_threshold() {
+    return __isset_bit_vector.get(__MIN_COMPACTION_THRESHOLD_ISSET_ID);
+  }
+
+  public void setMin_compaction_thresholdIsSet(boolean value) {
+    __isset_bit_vector.set(__MIN_COMPACTION_THRESHOLD_ISSET_ID, value);
+  }
+
+  public int getMax_compaction_threshold() {
+    return this.max_compaction_threshold;
+  }
+
+  public CfDef setMax_compaction_threshold(int max_compaction_threshold) {
+    this.max_compaction_threshold = max_compaction_threshold;
+    setMax_compaction_thresholdIsSet(true);
+    return this;
+  }
+
+  public void unsetMax_compaction_threshold() {
+    __isset_bit_vector.clear(__MAX_COMPACTION_THRESHOLD_ISSET_ID);
+  }
+
+  /** Returns true if field max_compaction_threshold is set (has been asigned a value) and false otherwise */
+  public boolean isSetMax_compaction_threshold() {
+    return __isset_bit_vector.get(__MAX_COMPACTION_THRESHOLD_ISSET_ID);
+  }
+
+  public void setMax_compaction_thresholdIsSet(boolean value) {
+    __isset_bit_vector.set(__MAX_COMPACTION_THRESHOLD_ISSET_ID, value);
+  }
+
   public void setFieldValue(_Fields field, Object value) {
     switch (field) {
     case KEYSPACE:
@@ -841,6 +905,22 @@ public void setFieldValue(_Fields field, Object value) {
       }
       break;
 
+    case MIN_COMPACTION_THRESHOLD:
+      if (value == null) {
+        unsetMin_compaction_threshold();
+      } else {
+        setMin_compaction_threshold((Integer)value);
+      }
+      break;
+
+    case MAX_COMPACTION_THRESHOLD:
+      if (value == null) {
+        unsetMax_compaction_threshold();
+      } else {
+        setMax_compaction_threshold((Integer)value);
+      }
+      break;
+
     }
   }
 
@@ -898,6 +978,12 @@ public Object getFieldValue(_Fields field) {
     case ID:
       return new Integer(getId());
 
+    case MIN_COMPACTION_THRESHOLD:
+      return new Integer(getMin_compaction_threshold());
+
+    case MAX_COMPACTION_THRESHOLD:
+      return new Integer(getMax_compaction_threshold());
+
     }
     throw new IllegalStateException();
   }
@@ -941,6 +1027,10 @@ public boolean isSet(_Fields field) {
       return isSetDefault_validation_class();
     case ID:
       return isSetId();
+    case MIN_COMPACTION_THRESHOLD:
+      return isSetMin_compaction_threshold();
+    case MAX_COMPACTION_THRESHOLD:
+      return isSetMax_compaction_threshold();
     }
     throw new IllegalStateException();
   }
@@ -1106,6 +1196,24 @@ public boolean equals(CfDef that) {
         return false;
     }
 
+    boolean this_present_min_compaction_threshold = true && this.isSetMin_compaction_threshold();
+    boolean that_present_min_compaction_threshold = true && that.isSetMin_compaction_threshold();
+    if (this_present_min_compaction_threshold || that_present_min_compaction_threshold) {
+      if (!(this_present_min_compaction_threshold && that_present_min_compaction_threshold))
+        return false;
+      if (this.min_compaction_threshold != that.min_compaction_threshold)
+        return false;
+    }
+
+    boolean this_present_max_compaction_threshold = true && this.isSetMax_compaction_threshold();
+    boolean that_present_max_compaction_threshold = true && that.isSetMax_compaction_threshold();
+    if (this_present_max_compaction_threshold || that_present_max_compaction_threshold) {
+      if (!(this_present_max_compaction_threshold && that_present_max_compaction_threshold))
+        return false;
+      if (this.max_compaction_threshold != that.max_compaction_threshold)
+        return false;
+    }
+
     return true;
   }
 
@@ -1266,6 +1374,24 @@ public int compareTo(CfDef other) {
         return lastComparison;
       }
     }
+    lastComparison = Boolean.valueOf(isSetMin_compaction_threshold()).compareTo(typedOther.isSetMin_compaction_threshold());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetMin_compaction_threshold()) {      lastComparison = TBaseHelper.compareTo(this.min_compaction_threshold, typedOther.min_compaction_threshold);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
+    lastComparison = Boolean.valueOf(isSetMax_compaction_threshold()).compareTo(typedOther.isSetMax_compaction_threshold());
+    if (lastComparison != 0) {
+      return lastComparison;
+    }
+    if (isSetMax_compaction_threshold()) {      lastComparison = TBaseHelper.compareTo(this.max_compaction_threshold, typedOther.max_compaction_threshold);
+      if (lastComparison != 0) {
+        return lastComparison;
+      }
+    }
     return 0;
   }
 
@@ -1408,6 +1534,22 @@ public void read(TProtocol iprot) throws TException {
             TProtocolUtil.skip(iprot, field.type);
           }
           break;
+        case 17: // MIN_COMPACTION_THRESHOLD
+          if (field.type == TType.I32) {
+            this.min_compaction_threshold = iprot.readI32();
+            setMin_compaction_thresholdIsSet(true);
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
+        case 18: // MAX_COMPACTION_THRESHOLD
+          if (field.type == TType.I32) {
+            this.max_compaction_threshold = iprot.readI32();
+            setMax_compaction_thresholdIsSet(true);
+          } else { 
+            TProtocolUtil.skip(iprot, field.type);
+          }
+          break;
         default:
           TProtocolUtil.skip(iprot, field.type);
       }
@@ -1526,6 +1668,16 @@ public void write(TProtocol oprot) throws TException {
       oprot.writeI32(this.id);
       oprot.writeFieldEnd();
     }
+    if (isSetMin_compaction_threshold()) {
+      oprot.writeFieldBegin(MIN_COMPACTION_THRESHOLD_FIELD_DESC);
+      oprot.writeI32(this.min_compaction_threshold);
+      oprot.writeFieldEnd();
+    }
+    if (isSetMax_compaction_threshold()) {
+      oprot.writeFieldBegin(MAX_COMPACTION_THRESHOLD_FIELD_DESC);
+      oprot.writeI32(this.max_compaction_threshold);
+      oprot.writeFieldEnd();
+    }
     oprot.writeFieldStop();
     oprot.writeStructEnd();
   }
@@ -1666,6 +1818,18 @@ public String toString() {
       sb.append(this.id);
       first = false;
     }
+    if (isSetMin_compaction_threshold()) {
+      if (!first) sb.append(", ");
+      sb.append("min_compaction_threshold:");
+      sb.append(this.min_compaction_threshold);
+      first = false;
+    }
+    if (isSetMax_compaction_threshold()) {
+      if (!first) sb.append(", ");
+      sb.append("max_compaction_threshold:");
+      sb.append(this.max_compaction_threshold);
+      first = false;
+    }
     sb.append(")");
     return sb.toString();
   }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java b/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java
index f0e9fee6..6a872b0d 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/avro/CassandraServer.java
@@ -866,6 +866,8 @@ private CFMetaData convertToCFMetaData(CfDef cf_def) throws InvalidRequestExcept
                               cf_def.read_repair_chance == null ? CFMetaData.DEFAULT_READ_REPAIR_CHANCE : cf_def.read_repair_chance,
                               cf_def.gc_grace_seconds != null ? cf_def.gc_grace_seconds : CFMetaData.DEFAULT_GC_GRACE_SECONDS,
                               DatabaseDescriptor.getComparator(validate),
+                              cf_def.min_compaction_threshold == null ? CFMetaData.DEFAULT_MIN_COMPACTION_THRESHOLD : cf_def.min_compaction_threshold,
+                              cf_def.max_compaction_threshold == null ? CFMetaData.DEFAULT_MAX_COMPACTION_THRESHOLD : cf_def.max_compaction_threshold,
                               ColumnDefinition.fromColumnDefs((Iterable<ColumnDef>) cf_def.column_metadata));
     }
 
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/CFMetaData.java b/cassandra/trunk/src/java/org/apache/cassandra/config/CFMetaData.java
index ce1f130d..3bdb92ac 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/CFMetaData.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/CFMetaData.java
@@ -49,11 +49,14 @@
 
 public final class CFMetaData
 {
-    public final static double DEFAULT_READ_REPAIR_CHANCE = 1.0;
-    public final static double DEFAULT_KEY_CACHE_SIZE = 200000;
     public final static double DEFAULT_ROW_CACHE_SIZE = 0.0;
+    public final static double DEFAULT_KEY_CACHE_SIZE = 200000;
+    public final static double DEFAULT_READ_REPAIR_CHANCE = 1.0;
     public final static boolean DEFAULT_PRELOAD_ROW_CACHE = false;
     public final static int DEFAULT_GC_GRACE_SECONDS = 864000;
+    public final static int DEFAULT_MIN_COMPACTION_THRESHOLD = 4;
+    public final static int DEFAULT_MAX_COMPACTION_THRESHOLD = 32;
+
     private static final int MIN_CF_ID = 1000;
 
     private static final AtomicInteger idGen = new AtomicInteger(MIN_CF_ID);
@@ -81,6 +84,8 @@ private static CFMetaData newSystemTable(String cfName, int cfId, String comment
                               0,
                               0,
                               BytesType.instance,
+                              DEFAULT_MIN_COMPACTION_THRESHOLD,
+                              DEFAULT_MAX_COMPACTION_THRESHOLD,
                               cfId,
                               Collections.<byte[], ColumnDefinition>emptyMap());
     }
@@ -125,12 +130,15 @@ public static final void fixMaxId()
     public final AbstractType subcolumnComparator; // like comparator, for supercolumns
     public final AbstractReconciler reconciler; // determine correct column from conflicting versions
     public final String comment; // for humans only
+
     public final double rowCacheSize; // default 0
     public final double keyCacheSize; // default 0.01
-    public final double readRepairChance; //chance 0 to 1, of doing a read repair; defaults 1.0 (always)
-    public final boolean preloadRowCache;
+    public final double readRepairChance;           // default 1.0 (always), chance [0.0,1.0] of read repair
+    public final boolean preloadRowCache;           // default false
     public final int gcGraceSeconds; // default 864000 (ten days)
-    public final AbstractType defaultValidator; // values are longs, strings, bytes (no-op)...
+    public final AbstractType defaultValidator;     // default none, use comparator types
+    public final Integer minCompactionThreshold;    // default 4
+    public final Integer maxCompactionThreshold;    // default 32
     // NOTE: if you find yourself adding members to this class, make sure you keep the convert methods in lockstep.
 
     public final Map<byte[], ColumnDefinition> column_metadata;
@@ -149,6 +157,8 @@ private CFMetaData(String tableName,
                        double readRepairChance,
                        int gcGraceSeconds,
                        AbstractType defaultValidator,
+                       int minCompactionThreshold,
+                       int maxCompactionThreshold,
                        Integer cfId,
                        Map<byte[], ColumnDefinition> column_metadata)
     {
@@ -169,6 +179,8 @@ private CFMetaData(String tableName,
         this.readRepairChance = readRepairChance;
         this.gcGraceSeconds = gcGraceSeconds;
         this.defaultValidator = defaultValidator;
+        this.minCompactionThreshold = minCompactionThreshold;
+        this.maxCompactionThreshold = maxCompactionThreshold;
         this.cfId = cfId;
         this.column_metadata = Collections.unmodifiableMap(column_metadata);
     }
@@ -185,21 +197,89 @@ public static void map(CFMetaData cfm) throws ConfigurationException
         }
     }
 
-    public CFMetaData(String tableName, String cfName, ColumnFamilyType cfType, ClockType clockType, AbstractType comparator, AbstractType subcolumnComparator, AbstractReconciler reconciler, String comment, double rowCacheSize, boolean preloadRowCache, double keyCacheSize, double readRepairChance, int gcGraceSeconds, AbstractType defaultvalidator, Map<byte[], ColumnDefinition> column_metadata)
+    public CFMetaData(String tableName,
+                      String cfName,
+                      ColumnFamilyType cfType,
+                      ClockType clockType,
+                      AbstractType comparator,
+                      AbstractType subcolumnComparator,
+                      AbstractReconciler reconciler,
+                      String comment,
+                      double rowCacheSize,
+                      boolean preloadRowCache,
+                      double keyCacheSize,
+                      double readRepairChance,
+                      int gcGraceSeconds,
+                      AbstractType defaultValidator,
+                      int minCompactionThreshold,
+                      int maxCompactionThreshold,
+                      //This constructor generates the id!
+                      Map<byte[], ColumnDefinition> column_metadata)
     {
-        this(tableName, cfName, cfType, clockType, comparator, subcolumnComparator, reconciler, comment, rowCacheSize, preloadRowCache, keyCacheSize, readRepairChance, gcGraceSeconds, defaultvalidator, nextId(), column_metadata);
+        this(tableName,
+             cfName,
+             cfType,
+             clockType,
+             comparator,
+             subcolumnComparator,
+             reconciler,
+             comment,
+             rowCacheSize,
+             preloadRowCache,
+             keyCacheSize,
+             readRepairChance,
+             gcGraceSeconds,
+             defaultValidator,
+             minCompactionThreshold,
+             maxCompactionThreshold,
+             nextId(),
+             column_metadata);
     }
 
     /** clones an existing CFMetaData using the same id. */
     public static CFMetaData rename(CFMetaData cfm, String newName)
     {
-        return new CFMetaData(cfm.tableName, newName, cfm.cfType, cfm.clockType, cfm.comparator, cfm.subcolumnComparator, cfm.reconciler, cfm.comment, cfm.rowCacheSize, cfm.preloadRowCache, cfm.keyCacheSize, cfm.readRepairChance, cfm.gcGraceSeconds, cfm.defaultValidator, cfm.cfId, cfm.column_metadata);
+        return new CFMetaData(cfm.tableName,
+                              newName,
+                              cfm.cfType,
+                              cfm.clockType,
+                              cfm.comparator,
+                              cfm.subcolumnComparator,
+                              cfm.reconciler,
+                              cfm.comment,
+                              cfm.rowCacheSize,
+                              cfm.preloadRowCache,
+                              cfm.keyCacheSize,
+                              cfm.readRepairChance,
+                              cfm.gcGraceSeconds,
+                              cfm.defaultValidator,
+                              cfm.minCompactionThreshold,
+                              cfm.maxCompactionThreshold,
+                              cfm.cfId,
+                              cfm.column_metadata);
     }
     
     /** clones existing CFMetaData. keeps the id but changes the table name.*/
     public static CFMetaData renameTable(CFMetaData cfm, String tableName)
     {
-        return new CFMetaData(tableName, cfm.cfName, cfm.cfType, cfm.clockType, cfm.comparator, cfm.subcolumnComparator, cfm.reconciler, cfm.comment, cfm.rowCacheSize, cfm.preloadRowCache, cfm.keyCacheSize, cfm.readRepairChance, cfm.gcGraceSeconds, cfm.defaultValidator, cfm.cfId, cfm.column_metadata);
+        return new CFMetaData(tableName,
+                              cfm.cfName,
+                              cfm.cfType,
+                              cfm.clockType,
+                              cfm.comparator,
+                              cfm.subcolumnComparator,
+                              cfm.reconciler,
+                              cfm.comment,
+                              cfm.rowCacheSize,
+                              cfm.preloadRowCache,
+                              cfm.keyCacheSize,
+                              cfm.readRepairChance,
+                              cfm.gcGraceSeconds,
+                              cfm.defaultValidator,
+                              cfm.minCompactionThreshold,
+                              cfm.maxCompactionThreshold,
+                              cfm.cfId,
+                              cfm.column_metadata);
     }
     
     /** used for evicting cf data out of static tracking collections. */
@@ -209,6 +289,7 @@ public static void purge(CFMetaData cfm)
     }
 
     // a quick and dirty pretty printer for describing the column family...
+    //TODO: Make it prettier, use it in the CLI
     public String pretty()
     {
         return tableName + "." + cfName + "\n"
@@ -236,6 +317,8 @@ public String pretty()
         cf.read_repair_chance = readRepairChance;
         cf.gc_grace_seconds = gcGraceSeconds;
         cf.default_validation_class = new Utf8(defaultValidator.getClass().getName());
+        cf.min_compaction_threshold = minCompactionThreshold;
+        cf.max_compaction_threshold = maxCompactionThreshold;
         cf.column_metadata = SerDeUtils.createArray(column_metadata.size(),
                                                     org.apache.cassandra.config.avro.ColumnDef.SCHEMA$);
         for (ColumnDefinition cd : column_metadata.values())
@@ -269,7 +352,24 @@ public static CFMetaData inflate(org.apache.cassandra.config.avro.CfDef cf)
             ColumnDefinition cd = ColumnDefinition.inflate(aColumn_metadata);
             column_metadata.put(cd.name, cd);
         }
-        return new CFMetaData(cf.keyspace.toString(), cf.name.toString(), ColumnFamilyType.create(cf.column_type.toString()), ClockType.create(cf.clock_type.toString()), comparator, subcolumnComparator, reconciler, cf.comment.toString(), cf.row_cache_size, cf.preload_row_cache, cf.key_cache_size, cf.read_repair_chance, cf.gc_grace_seconds, validator, cf.id, column_metadata);
+        return new CFMetaData(cf.keyspace.toString(),
+                              cf.name.toString(),
+                              ColumnFamilyType.create(cf.column_type.toString()),
+                              ClockType.create(cf.clock_type.toString()),
+                              comparator,
+                              subcolumnComparator,
+                              reconciler,
+                              cf.comment.toString(),
+                              cf.row_cache_size,
+                              cf.preload_row_cache,
+                              cf.key_cache_size,
+                              cf.read_repair_chance,
+                              cf.gc_grace_seconds,
+                              validator,
+                              cf.min_compaction_threshold,
+                              cf.max_compaction_threshold,
+                              cf.id,
+                              column_metadata);
     }
 
     public boolean equals(Object obj) 
@@ -297,6 +397,8 @@ else if (obj == null || obj.getClass() != getClass())
             .append(keyCacheSize, rhs.keyCacheSize)
             .append(readRepairChance, rhs.readRepairChance)
             .append(gcGraceSeconds, rhs.gcGraceSeconds)
+            .append(minCompactionThreshold, rhs.minCompactionThreshold)
+            .append(maxCompactionThreshold, rhs.maxCompactionThreshold)
             .append(cfId.intValue(), rhs.cfId.intValue())
             .append(column_metadata, rhs.column_metadata)
             .isEquals();
@@ -317,6 +419,9 @@ public int hashCode()
             .append(keyCacheSize)
             .append(readRepairChance)
             .append(gcGraceSeconds)
+            .append(defaultValidator)
+            .append(minCompactionThreshold)
+            .append(maxCompactionThreshold)
             .append(cfId)
             .append(column_metadata)
             .toHashCode();
@@ -374,6 +479,8 @@ else if (subcolumnComparator != DatabaseDescriptor.getComparator(cf_def.subcompa
                               cf_def.read_repair_chance, 
                               cf_def.gc_grace_seconds, 
                               DatabaseDescriptor.getComparator(cf_def.default_validation_class == null ? (String)null : cf_def.default_validation_class.toString()), 
+                              cf_def.min_compaction_threshold,
+                              cf_def.max_compaction_threshold,
                               cfId, 
                               column_metadata);
     }
@@ -417,6 +524,8 @@ else if (subcolumnComparator != DatabaseDescriptor.getComparator(cf_def.subcompa
                               cf_def.read_repair_chance, 
                               cf_def.gc_grace_seconds, 
                               DatabaseDescriptor.getComparator(cf_def.default_validation_class == null ? null : cf_def.default_validation_class), 
+                              cf_def.min_compaction_threshold,
+                              cf_def.max_compaction_threshold,
                               cfId, 
                               column_metadata);
     }
@@ -442,6 +551,8 @@ else if (subcolumnComparator != DatabaseDescriptor.getComparator(cf_def.subcompa
         def.setRead_repair_chance(cfm.readRepairChance);
         def.setGc_grace_seconds(cfm.gcGraceSeconds);
         def.setDefault_validation_class(cfm.defaultValidator.getClass().getName());
+        def.setMin_compaction_threshold(cfm.minCompactionThreshold);
+        def.setMax_compaction_threshold(cfm.maxCompactionThreshold);
         List<org.apache.cassandra.thrift.ColumnDef> column_meta = new ArrayList< org.apache.cassandra.thrift.ColumnDef>(cfm.column_metadata.size());
         for (ColumnDefinition cd : cfm.column_metadata.values())
         {
@@ -479,6 +590,8 @@ else if (subcolumnComparator != DatabaseDescriptor.getComparator(cf_def.subcompa
         def.read_repair_chance = cfm.readRepairChance;
         def.gc_grace_seconds = cfm.gcGraceSeconds;
         def.default_validation_class = cfm.defaultValidator.getClass().getName();
+        def.min_compaction_threshold = cfm.minCompactionThreshold;
+        def.max_compaction_threshold = cfm.maxCompactionThreshold;
         List<org.apache.cassandra.avro.ColumnDef> column_meta = new ArrayList<org.apache.cassandra.avro.ColumnDef>(cfm.column_metadata.size());
         for (ColumnDefinition cd : cfm.column_metadata.values())
         {
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java b/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
index e08dc30b..4213ca5d 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/DatabaseDescriptor.java
@@ -586,6 +586,8 @@ else if (cf.compare_subcolumns_with != null)
                                              cf.read_repair_chance,
                                              cf.gc_grace_seconds,
                                              default_validator,
+                                             cf.min_compaction_threshold,
+                                             cf.max_compaction_threshold,
                                              metadata);
             }
             defs.add(new KSMetaData(keyspace.name,
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/config/RawColumnFamily.java b/cassandra/trunk/src/java/org/apache/cassandra/config/RawColumnFamily.java
index b57bdd37..f7d6d67f 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/config/RawColumnFamily.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/config/RawColumnFamily.java
@@ -45,5 +45,7 @@
     public boolean preload_row_cache = CFMetaData.DEFAULT_PRELOAD_ROW_CACHE;
     public int gc_grace_seconds = CFMetaData.DEFAULT_GC_GRACE_SECONDS;
     public String default_validation_class;
+    public int min_compaction_threshold = CFMetaData.DEFAULT_MIN_COMPACTION_THRESHOLD;
+    public int max_compaction_threshold = CFMetaData.DEFAULT_MAX_COMPACTION_THRESHOLD;
     public RawColumnDefinition[] column_metadata = new RawColumnDefinition[0];
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
index de5fee55..80128673 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java
@@ -132,12 +132,18 @@
 
     public final CFMetaData metadata;
     
+    /* These are locally held copies to be changed from the config during runtime */
+    private int minCompactionThreshold;
+    private int maxCompactionThreshold;
+
     private ColumnFamilyStore(String table, String columnFamilyName, IPartitioner partitioner, int generation, CFMetaData metadata)
     {
         assert metadata != null : "null metadata for " + table + ":" + columnFamilyName;
         this.table = table;
         columnFamily = columnFamilyName; 
         this.metadata = metadata;
+        this.minCompactionThreshold = metadata.minCompactionThreshold;
+        this.maxCompactionThreshold = metadata.maxCompactionThreshold;
         this.partitioner = partitioner;
         fileIndexGenerator.set(generation);
         memtable = new Memtable(this, this.partitioner);
@@ -192,6 +198,8 @@ private ColumnFamilyStore(String table, String columnFamilyName, IPartitioner pa
                                                           0,
                                                           CFMetaData.DEFAULT_GC_GRACE_SECONDS,
                                                           BytesType.instance,
+                                                          CFMetaData.DEFAULT_MIN_COMPACTION_THRESHOLD,
+                                                          CFMetaData.DEFAULT_MAX_COMPACTION_THRESHOLD,
                                                           Collections.<byte[], ColumnDefinition>emptyMap());
             ColumnFamilyStore indexedCfs = ColumnFamilyStore.createColumnFamilyStore(table, 
                                                                                      indexedCfName,
@@ -1603,4 +1611,30 @@ public String toString()
                ", columnFamily='" + columnFamily + '\'' +
                ')';
     }
+
+    public int getMinimumCompactionThreshold()
+    {
+        return minCompactionThreshold;
+    }
+    
+    public void setMinimumCompactionThreshold(int minCompactionThreshold)
+    {
+        this.minCompactionThreshold = minCompactionThreshold;
+    }
+
+    public int getMaximumCompactionThreshold()
+    {
+        return maxCompactionThreshold;
+    }
+
+    public void setMaximumCompactionThreshold(int maxCompactionThreshold)
+    {
+        this.maxCompactionThreshold = maxCompactionThreshold;
+    }
+
+    public void disableAutoCompaction()
+    {
+        this.minCompactionThreshold = 0;
+        this.maxCompactionThreshold = 0;
+    }
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
index c928bd51..26830642 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStoreMBean.java
@@ -165,4 +165,24 @@
     public double getBloomFilterFalseRatio();
 
     public double getRecentBloomFilterFalseRatio();
+
+    /**
+     * Gets the minimum number of sstables in queue before compaction kicks off
+     */
+    public int getMinimumCompactionThreshold();
+
+    /**
+     * Sets the minimum number of sstables in queue before compaction kicks off
+     */
+    public void setMinimumCompactionThreshold(int threshold);
+
+    /**
+     * Gets the maximum number of sstables in queue before compaction kicks off
+     */
+    public int getMaximumCompactionThreshold();
+
+    /**
+     * Sets the maximum number of sstables in queue before compaction kicks off
+     */
+    public void setMaximumCompactionThreshold(int threshold);
 }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/CompactionManager.java b/cassandra/trunk/src/java/org/apache/cassandra/db/CompactionManager.java
index acefc81c..e9ceba64 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/CompactionManager.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/CompactionManager.java
@@ -18,7 +18,6 @@
 
 package org.apache.cassandra.db;
 
-import java.io.FileFilter;
 import java.io.IOException;
 import java.io.File;
 import java.lang.management.ManagementFactory;
@@ -57,9 +56,6 @@
     private static final Logger logger = LoggerFactory.getLogger(CompactionManager.class);
     public static final CompactionManager instance;
 
-    private int minimumCompactionThreshold = 4; // compact this many sstables min at a time
-    private int maximumCompactionThreshold = 32; // compact this many sstables max at a time
-
     static
     {
         instance = new CompactionManager();
@@ -88,7 +84,10 @@
         {
             public Integer call() throws IOException
             {
-                if (minimumCompactionThreshold <= 0 || maximumCompactionThreshold <= 0)
+                Integer minThreshold = cfs.getMinimumCompactionThreshold();
+                Integer maxThreshold = cfs.getMaximumCompactionThreshold();
+
+                if (minThreshold <= 0 || maxThreshold <= 0)
                 {
                     logger.debug("Compaction is currently disabled.");
                     return 0;
@@ -99,12 +98,12 @@ public Integer call() throws IOException
                 
                 for (List<SSTableReader> sstables : buckets)
                 {
-                    if (sstables.size() >= minimumCompactionThreshold)
+                    if (sstables.size() >= minThreshold)
                     {
                         // if we have too many to compact all at once, compact older ones first -- this avoids
                         // re-compacting files we just created.
                         Collections.sort(sstables);
-                        return doCompaction(cfs, sstables.subList(0, Math.min(sstables.size(), maximumCompactionThreshold)), (int) (System.currentTimeMillis() / 1000) - cfs.metadata.gcGraceSeconds);
+                        return doCompaction(cfs, sstables.subList(0, Math.min(sstables.size(), maxThreshold)), (int) (System.currentTimeMillis() / 1000) - cfs.metadata.gcGraceSeconds);
                     }
                 }
                 return 0;
@@ -115,12 +114,15 @@ public Integer call() throws IOException
 
     private void updateEstimateFor(ColumnFamilyStore cfs, Set<List<SSTableReader>> buckets)
     {
+        Integer minct = cfs.getMinimumCompactionThreshold();
+        Integer maxct = cfs.getMaximumCompactionThreshold();
+
         int n = 0;
         for (List<SSTableReader> sstables : buckets)
         {
-            if (sstables.size() >= minimumCompactionThreshold)
+            if (sstables.size() >= minct)
             {
-                n += 1 + sstables.size() / (maximumCompactionThreshold - minimumCompactionThreshold);
+                n += 1 + sstables.size() / (maxct - minct);
             }
         }
         estimatedCompactions.put(cfs, n);
@@ -199,42 +201,15 @@ public Object call() throws IOException
         return executor.submit(callable);
     }
 
-    /**
-     * Gets the minimum number of sstables in queue before compaction kicks off
-     */
-    public int getMinimumCompactionThreshold()
-    {
-        return minimumCompactionThreshold;
-    }
-
-    /**
-     * Sets the minimum number of sstables in queue before compaction kicks off
-     */
-    public void setMinimumCompactionThreshold(int threshold)
-    {
-        minimumCompactionThreshold = threshold;
-    }
-
-    /**
-     * Gets the maximum number of sstables in queue before compaction kicks off
-     */
-    public int getMaximumCompactionThreshold()
+    /* Used in tests. */
+    public void disableAutoCompaction()
     {
-        return maximumCompactionThreshold;
-    }
-
-    /**
-     * Sets the maximum number of sstables in queue before compaction kicks off
-     */
-    public void setMaximumCompactionThreshold(int threshold)
+        for (String ksname : DatabaseDescriptor.getNonSystemTables())
     {
-        maximumCompactionThreshold = threshold;
+            Table ks = Table.open(ksname);
+            for (ColumnFamilyStore cfs : ks.columnFamilyStores.values())
+                cfs.disableAutoCompaction();
     }
-
-    public void disableAutoCompaction()
-    {
-        minimumCompactionThreshold = 0;
-        maximumCompactionThreshold = 0;
     }
 
     /**
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/db/CompactionManagerMBean.java b/cassandra/trunk/src/java/org/apache/cassandra/db/CompactionManagerMBean.java
index 719c020a..1820e951 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/db/CompactionManagerMBean.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/db/CompactionManagerMBean.java
@@ -20,25 +20,6 @@
 
 public interface CompactionManagerMBean
 {    
-    /**
-     * Gets the minimum number of sstables in queue before compaction kicks off
-     */
-    public int getMinimumCompactionThreshold();
-
-    /**
-     * Sets the minimum number of sstables in queue before compaction kicks off
-     */
-    public void setMinimumCompactionThreshold(int threshold);
-
-    /**
-     * Gets the maximum number of sstables in queue before compaction kicks off
-     */
-    public int getMaximumCompactionThreshold();
-
-    /**
-     * Sets the maximum number of sstables in queue before compaction kicks off
-     */
-    public void setMaximumCompactionThreshold(int threshold);
 
     /**
      * @return the columnfamily currently being compacted; null if none
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java b/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
index 944c42d4..838124a0 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/thrift/CassandraServer.java
@@ -952,6 +952,8 @@ private CFMetaData convertToCFMetaData(CfDef cf_def) throws InvalidRequestExcept
                               cf_def.read_repair_chance,
                               cf_def.isSetGc_grace_seconds() ? cf_def.gc_grace_seconds : CFMetaData.DEFAULT_GC_GRACE_SECONDS,
                               DatabaseDescriptor.getComparator(cf_def.default_validation_class),
+                              cf_def.min_compaction_threshold,
+                              cf_def.max_compaction_threshold,
                               ColumnDefinition.fromColumnDef(cf_def.column_metadata));
     }
 
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeCmd.java b/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeCmd.java
index 1db18f2c..bb0edb86 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeCmd.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeCmd.java
@@ -38,6 +38,7 @@
 
 import org.apache.cassandra.cache.JMXInstrumentedCacheMBean;
 import org.apache.cassandra.concurrent.IExecutorMBean;
+import org.apache.cassandra.config.CFMetaData;
 import org.apache.cassandra.db.ColumnFamilyStoreMBean;
 import org.apache.cassandra.db.CompactionManager;
 import org.apache.cassandra.dht.Token;
@@ -77,8 +78,8 @@ private static void printUsage()
         String header = String.format(
                 "%nAvailable commands: ring, info, version, cleanup, compact, cfstats, snapshot [snapshotname], clearsnapshot, " +
                 "tpstats, flush, drain, repair, decommission, move, loadbalance, removetoken, " +
-                "setcachecapacity <keyspace> <cfname> <keycachecapacity> <rowcachecapacity>, " +
-                "getcompactionthreshold, setcompactionthreshold [minthreshold] ([maxthreshold]), " +
+                "setcachecapacity [keyspace] [cfname] [keycachecapacity] [rowcachecapacity], " +
+                "getcompactionthreshold [keyspace] [cfname], setcompactionthreshold [cfname] [minthreshold] [maxthreshold], " +
                 "streams [host]");
         String usage = String.format("java %s --host <arg> <command>%n", NodeCmd.class.getName());
         hf.printHelp(usage, "", options, header);
@@ -511,9 +512,9 @@ else if (cmdName.equals("drain"))
         }
         else if (cmdName.equals("setcachecapacity"))
         {
-            if (cmd.getArgs().length != 5)
+            if (cmd.getArgs().length != 5) // ks cf keycachecap rowcachecap
             {
-                System.err.println("cacheinfo requires keyspace and column family name arguments, followed by key cache capacity and row cache capacity, in rows");
+                System.err.println("cacheinfo requires: Keyspace name, ColumnFamily name, key cache capacity (in keys), and row cache capacity (in rows)");
             }
             String tableName = cmd.getArgs()[1];
             String cfName = cmd.getArgs()[2];
@@ -523,21 +524,33 @@ else if (cmdName.equals("setcachecapacity"))
         }
         else if (cmdName.equals("getcompactionthreshold"))
         {
-            probe.getCompactionThreshold(System.out);
+            if (arguments.length < 3) // ks cf
+            {
+                System.err.println("Missing keyspace/cfname");
+                printUsage();
+                System.exit(1);
+            }
+            probe.getCompactionThreshold(System.out, cmd.getArgs()[1], cmd.getArgs()[2]);
         }
         else if (cmdName.equals("setcompactionthreshold"))
         {
-            if (arguments.length < 2)
+            if (cmd.getArgs().length != 5) // ks cf min max
             {
-                System.err.println("Missing threshold value(s)");
+                System.err.println("setcompactionthreshold requires: Keyspace name, ColumnFamily name, " +
+                                   "min threshold, and max threshold.");
                 printUsage();
                 System.exit(1);
             }
-            int minthreshold = Integer.parseInt(arguments[1]);
-            int maxthreshold = CompactionManager.instance.getMaximumCompactionThreshold();
-            if (arguments.length > 2)
+            String ks = cmd.getArgs()[1];
+            String cf = cmd.getArgs()[2];
+            int minthreshold = Integer.parseInt(arguments[3]);
+            int maxthreshold = Integer.parseInt(arguments[4]);
+
+            if ((minthreshold < 0) || (maxthreshold < 0))
             {
-                maxthreshold = Integer.parseInt(arguments[2]);
+                System.err.println("Thresholds must be positive integers.");
+                printUsage();
+                System.exit(1);
             }
 
             if (minthreshold > maxthreshold)
@@ -553,10 +566,11 @@ else if (cmdName.equals("setcompactionthreshold"))
                 printUsage();
                 System.exit(1);
             }
-            probe.setCompactionThreshold(minthreshold, maxthreshold);
+            probe.setCompactionThreshold(ks, cf, minthreshold, maxthreshold);
         }
         else if (cmdName.equals("streams"))
         {
+            // optional host
             String otherHost = arguments.length > 1 ? arguments[1] : null;
             nodeCmd.printStreamInfo(otherHost == null ? null : InetAddress.getByName(otherHost), System.out);
         }
diff --git a/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeProbe.java b/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeProbe.java
index 74247e32..690aad02 100644
--- a/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeProbe.java
+++ b/cassandra/trunk/src/java/org/apache/cassandra/tools/NodeProbe.java
@@ -41,9 +41,6 @@
 import org.apache.cassandra.concurrent.IExecutorMBean;
 import org.apache.cassandra.config.ConfigurationException;
 import org.apache.cassandra.db.ColumnFamilyStoreMBean;
-import org.apache.cassandra.db.CompactionManager;
-import org.apache.cassandra.db.CompactionManagerMBean;
-import org.apache.cassandra.dht.Range;
 import org.apache.cassandra.dht.Token;
 import org.apache.cassandra.service.StorageServiceMBean;
 import org.apache.cassandra.streaming.StreamingService;
@@ -67,7 +64,6 @@
     private StorageServiceMBean ssProxy;
     private MemoryMXBean memProxy;
     private RuntimeMXBean runtimeProxy;
-    private CompactionManagerMBean mcmProxy;
     private StreamingServiceMBean streamProxy;
     
     /**
@@ -112,8 +108,6 @@ private void connect() throws IOException
         {
             ObjectName name = new ObjectName(ssObjName);
             ssProxy = JMX.newMBeanProxy(mbeanServerConn, name, StorageServiceMBean.class);
-            name = new ObjectName(CompactionManager.MBEAN_OBJECT_NAME);
-            mcmProxy = JMX.newMBeanProxy(mbeanServerConn, name, CompactionManagerMBean.class);
             name = new ObjectName(StreamingService.MBEAN_OBJECT_NAME);
             streamProxy = JMX.newMBeanProxy(mbeanServerConn, name, StreamingServiceMBean.class);
         } catch (MalformedObjectNameException e)
@@ -324,10 +318,12 @@ public void removeToken(String token)
      *
      * @param outs the stream to write to
      */
-    public void getCompactionThreshold(PrintStream outs)
+    public void getCompactionThreshold(PrintStream outs, String ks, String cf)
     {
-        outs.println("Current compaction threshold: Min=" +  mcmProxy.getMinimumCompactionThreshold() +
-            ", Max=" +  mcmProxy.getMaximumCompactionThreshold());
+        ColumnFamilyStoreMBean cfsProxy = getCfsProxy(ks, cf);
+        outs.println("Current compaction thresholds for " + ks + "/" + cf + ": \n" +
+                     " min = " + cfsProxy.getMinimumCompactionThreshold() + ", " +
+                     " max = " + cfsProxy.getMaximumCompactionThreshold());
     }
 
     /**
@@ -336,13 +332,11 @@ public void getCompactionThreshold(PrintStream outs)
      * @param minimumCompactionThreshold minimum compaction threshold
      * @param maximumCompactionThreshold maximum compaction threshold
      */
-    public void setCompactionThreshold(int minimumCompactionThreshold, int maximumCompactionThreshold)
+    public void setCompactionThreshold(String ks, String cf, int minimumCompactionThreshold, int maximumCompactionThreshold)
     {
-        mcmProxy.setMinimumCompactionThreshold(minimumCompactionThreshold);
-        if (maximumCompactionThreshold >= 0)
-        {
-             mcmProxy.setMaximumCompactionThreshold(maximumCompactionThreshold);
-        }
+        ColumnFamilyStoreMBean cfsProxy = getCfsProxy(ks, cf);
+        cfsProxy.setMinimumCompactionThreshold(minimumCompactionThreshold);
+        cfsProxy.setMaximumCompactionThreshold(maximumCompactionThreshold);
     }
 
     public void setCacheCapacities(String tableName, String cfName, int keyCacheCapacity, int rowCacheCapacity)
@@ -425,6 +419,20 @@ public String exportSchemaToYAML() throws IOException
     {
         return ssProxy.exportSchema();
     }
+    
+    private ColumnFamilyStoreMBean getCfsProxy(String ks, String cf) {
+        ColumnFamilyStoreMBean cfsProxy = null;
+        try {
+            cfsProxy = JMX.newMBeanProxy(mbeanServerConn,
+                    new ObjectName("org.apache.cassandra.db:type=ColumnFamilies,keyspace="+ks+",columnfamily="+cf), 
+                    ColumnFamilyStoreMBean.class);
+        }
+        catch (MalformedObjectNameException mone) {
+            System.err.println("ColumnFamilyStore for " + ks + "/" + cf + " not found.");
+            System.exit(1);
+        }
+        return cfsProxy;
+    }
 }
 
 class ColumnFamilyStoreMBeanIterator implements Iterator<Map.Entry<String, ColumnFamilyStoreMBean>>
diff --git a/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java b/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
index 7d015dea..43ea4b8a 100644
--- a/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
+++ b/cassandra/trunk/test/unit/org/apache/cassandra/db/DefsTest.java
@@ -85,7 +85,7 @@ public void saveAndRestore() throws IOException
     @Test
     public void addNewCfToBogusTable() throws InterruptedException
     {
-        CFMetaData newCf = new CFMetaData("MadeUpKeyspace", "NewCF", ColumnFamilyType.Standard, ClockType.Timestamp, UTF8Type.instance, null, TimestampReconciler.instance, "new cf", 0, false, 1.0, 0, 864000, BytesType.instance, Collections.<byte[], ColumnDefinition>emptyMap());
+        CFMetaData newCf = addTestCF("MadeUpKeyspace", "NewCF", "new cf");
         try
         {
             new AddColumnFamily(newCf).apply();
@@ -110,7 +110,8 @@ public void testMigrations() throws IOException, ConfigurationException
         assert DatabaseDescriptor.getDefsVersion().equals(prior);
 
         // add a cf.
-        CFMetaData newCf1 = new CFMetaData("Keyspace1", "MigrationCf_1", ColumnFamilyType.Standard, ClockType.Timestamp, UTF8Type.instance, null, TimestampReconciler.instance, "Migration CF ", 0, false, 1.0, 0, 864000, BytesType.instance, Collections.<byte[], ColumnDefinition>emptyMap());
+        CFMetaData newCf1 = addTestCF("Keyspace1", "MigrationCf_1", "Migration CF");
+
         Migration m1 = new AddColumnFamily(newCf1);
         m1.apply();
         UUID ver1 = m1.getVersion();
@@ -160,7 +161,8 @@ public void addNewCF() throws ConfigurationException, IOException, ExecutionExce
         final String cf = "BrandNewCf";
         KSMetaData original = DatabaseDescriptor.getTableDefinition(ks);
 
-        CFMetaData newCf = new CFMetaData(original.name, cf, ColumnFamilyType.Standard, ClockType.Timestamp, UTF8Type.instance, null, TimestampReconciler.instance, "A New Column Family", 0, false, 1.0, 0, 864000, BytesType.instance, Collections.<byte[], ColumnDefinition>emptyMap());
+        CFMetaData newCf = addTestCF(original.name, cf, "A New Column Family");
+
         assert !DatabaseDescriptor.getTableDefinition(ks).cfMetaData().containsKey(newCf.cfName);
         new AddColumnFamily(newCf).apply();
 
@@ -279,7 +281,8 @@ public void renameCf() throws ConfigurationException, IOException, ExecutionExce
     public void addNewKS() throws ConfigurationException, IOException, ExecutionException, InterruptedException
     {
         DecoratedKey dk = Util.dk("key0");
-        CFMetaData newCf = new CFMetaData("NewKeyspace1", "AddedStandard1", ColumnFamilyType.Standard, ClockType.Timestamp, UTF8Type.instance, null, TimestampReconciler.instance, "A new cf for a new ks", 0, false, 1.0, 0, 864000, BytesType.instance, Collections.<byte[], ColumnDefinition>emptyMap());
+        CFMetaData newCf = addTestCF("NewKeyspace1", "AddedStandard1", "A new cf for a new ks");
+
         KSMetaData newKs = new KSMetaData(newCf.tableName, SimpleStrategy.class, null, 5, newCf);
         
         new AddKeyspace(newKs).apply();
@@ -436,7 +439,7 @@ public void createEmptyKsAddNewCf() throws ConfigurationException, IOException,
         new AddKeyspace(newKs).apply();
         assert DatabaseDescriptor.getTableDefinition("EmptyKeyspace") != null;
 
-        CFMetaData newCf = new CFMetaData("EmptyKeyspace", "AddedLater", ColumnFamilyType.Standard, ClockType.Timestamp, UTF8Type.instance, null, TimestampReconciler.instance, "A new CF to add to an empty KS", 0, false, 1.0, 0, 864000, BytesType.instance, Collections.<byte[], ColumnDefinition>emptyMap());
+        CFMetaData newCf = addTestCF("EmptyKeyspace", "AddedLater", "A new CF to add to an empty KS");
 
         //should not exist until apply
         assert !DatabaseDescriptor.getTableDefinition(newKs.name).cfMetaData().containsKey(newCf.cfName);
@@ -466,7 +469,7 @@ public void createEmptyKsAddNewCf() throws ConfigurationException, IOException,
     public void testUpdateKeyspace() throws ConfigurationException, IOException, ExecutionException, InterruptedException
     {
         // create a keyspace to serve as existing.
-        CFMetaData cf = new CFMetaData("UpdatedKeyspace", "AddedStandard1", ColumnFamilyType.Standard, ClockType.Timestamp, UTF8Type.instance, null, TimestampReconciler.instance, "A new cf for a new ks", 0, false, 1.0, 0, 864000, BytesType.instance, Collections.<byte[], ColumnDefinition>emptyMap());
+        CFMetaData cf = addTestCF("UpdatedKeyspace", "AddedStandard1", "A new cf for a new ks");
         KSMetaData oldKs = new KSMetaData(cf.tableName, SimpleStrategy.class, null, 5, cf);
         
         new AddKeyspace(oldKs).apply();
@@ -475,7 +478,7 @@ public void testUpdateKeyspace() throws ConfigurationException, IOException, Exe
         assert DatabaseDescriptor.getTableDefinition(cf.tableName) == oldKs;
         
         // anything with cf defs should fail.
-        CFMetaData cf2 = new CFMetaData(cf.tableName, "AddedStandard2", ColumnFamilyType.Standard, ClockType.Timestamp, UTF8Type.instance, null, TimestampReconciler.instance, "A new cf for a new ks", 0, false, 1.0, 0, 864000, BytesType.instance, Collections.<byte[], ColumnDefinition>emptyMap());
+        CFMetaData cf2 = addTestCF(cf.tableName, "AddedStandard2", "A new cf for a new ks");
         KSMetaData newBadKs = new KSMetaData(cf.tableName, SimpleStrategy.class, null, 4, cf2);
         try
         {
@@ -513,7 +516,7 @@ public void testUpdateKeyspace() throws ConfigurationException, IOException, Exe
     public void testUpdateColumnFamilyNoIndexes() throws ConfigurationException, IOException, ExecutionException, InterruptedException
     {
         // create a keyspace with a cf to update.
-        CFMetaData cf = new CFMetaData("UpdatedCfKs", "Standard1added", ColumnFamilyType.Standard, ClockType.Timestamp, UTF8Type.instance, null, TimestampReconciler.instance, "A new cf that will be updated", 0, false, 1.0, 0, 864000, BytesType.instance, Collections.<byte[], ColumnDefinition>emptyMap());
+        CFMetaData cf = addTestCF("UpdatedCfKs", "Standard1added", "A new cf that will be updated");
         KSMetaData ksm = new KSMetaData(cf.tableName, SimpleStrategy.class, null, 1, cf);
         new AddKeyspace(ksm).apply();
         
@@ -646,4 +649,26 @@ public void testUpdateColumnFamilyNoIndexes() throws ConfigurationException, IOE
             cf_def.setComparator_type(UTF8Type.class.getSimpleName());
         }
     }
+
+    private CFMetaData addTestCF(String ks, String cf, String comment)
+    {
+        return new CFMetaData(ks,
+                              cf,
+                              ColumnFamilyType.Standard,
+                              ClockType.Timestamp,
+                              UTF8Type.instance,
+                              null,
+                              TimestampReconciler.instance,
+                              comment,
+                              0,
+                              false,
+                              1.0,
+                              0,
+                              864000,
+                              BytesType.instance,
+                              4,
+                              32,
+                              Collections.<byte[], ColumnDefinition>emptyMap());
+    }
+
 }
