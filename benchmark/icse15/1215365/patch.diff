diff --git a/db/derby/code/trunk/java/build/org/apache/derbyBuild/splitmessages.java b/db/derby/code/trunk/java/build/org/apache/derbyBuild/splitmessages.java
index 00b41cb7..0abcf809 100644
--- a/db/derby/code/trunk/java/build/org/apache/derbyBuild/splitmessages.java
+++ b/db/derby/code/trunk/java/build/org/apache/derbyBuild/splitmessages.java
@@ -97,7 +97,6 @@ Licensed to the Apache Software Foundation (ASF) under one or more
         clientMessageIds.add(SQLState.UNSUPPORTED_HOLDABILITY_PROPERTY);
         clientMessageIds.add(SQLState.CANCEL_NOT_SUPPORTED_BY_SERVER);
         clientMessageIds.add(SQLState.LANG_INVALID_CALL_STATEMENT);
-        clientMessageIds.add(SQLState.LOSS_OF_PRECISION_EXCEPTION);
         clientMessageIds.add(SQLState.LANG_INVALID_SQL_IN_BATCH);
         clientMessageIds.add(SQLState.LANG_RESULT_SET_NOT_OPEN);
         clientMessageIds.add(SQLState.CANT_CONVERT_UNICODE_TO_EBCDIC);
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/CrossConverters.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/CrossConverters.java
index 4babad9f..2e75b732 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/CrossConverters.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/CrossConverters.java
@@ -191,7 +191,8 @@ final Object setObject(int targetType, int source) throws SqlException {
         case Types.SMALLINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Short.MAX_VALUE || source < Short.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "SMALLINT");
             }
             return new Short((short) source);
 
@@ -285,14 +286,16 @@ final Object setObject(int targetType, long source) throws SqlException {
         case Types.SMALLINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Short.MAX_VALUE || source < Short.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "SMALLINT");
             }
             return new Short((short) source);
 
         case Types.INTEGER:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Integer.MAX_VALUE || source < Integer.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "INTEGER");
             }
             return new Integer((int) source);
 
@@ -331,21 +334,24 @@ final Object setObject(int targetType, float source) throws SqlException {
         case Types.SMALLINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Short.MAX_VALUE || source < Short.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "SMALLINT");
             }
             return new Short((short) source);
 
         case Types.INTEGER:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Integer.MAX_VALUE || source < Integer.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "INTEGER");
             }
             return new Integer((int) source);
 
         case Types.BIGINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Long.MAX_VALUE || source < Long.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "BIGINT");
             }
             return new Long((long) source);
 
@@ -362,7 +368,8 @@ final Object setObject(int targetType, float source) throws SqlException {
                     //           |                          |________________________
                     //-----------------------------------------------------------------------------------
                     (source == Float.POSITIVE_INFINITY || source == Float.NEGATIVE_INFINITY)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "REAL");
             }
             return new Float(source);
 
@@ -377,7 +384,8 @@ final Object setObject(int targetType, float source) throws SqlException {
                     //            |                          |________________________
                     //-------------------------------------------------------------------------------------
                     (source == Double.POSITIVE_INFINITY || source == Double.NEGATIVE_INFINITY)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "DOUBLE");
             }
             // source passed in is a float, do we need to check if the source already contains "infinity"??
             return new Double(String.valueOf(source));
@@ -410,28 +418,32 @@ final Object setObject(int targetType, double source) throws SqlException {
         case Types.SMALLINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Short.MAX_VALUE || source < Short.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "SMALLINT");
             }
             return new Short((short) source);
 
         case Types.INTEGER:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Integer.MAX_VALUE || source < Integer.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "INTEGER");
             }
             return new Integer((int) source);
 
         case Types.BIGINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Long.MAX_VALUE || source < Long.MIN_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "BIGINT");
             }
             return new Long((long) source);
 
         case Types.REAL:
             if (Configuration.rangeCheckCrossConverters &&
                     (source > Float.MAX_VALUE || source < -Float.MAX_VALUE)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "REAL");
             }
             return new Float((float) source);
 
@@ -448,7 +460,8 @@ final Object setObject(int targetType, double source) throws SqlException {
                     //            |                          |________________________
                     //-------------------------------------------------------------------------------------
                     (source == Double.POSITIVE_INFINITY || source == Double.NEGATIVE_INFINITY)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "DOUBLE");
             }
             return new Double(source);
 
@@ -478,35 +491,40 @@ final Object setObject(int targetType, java.math.BigDecimal source) throws SqlEx
         case Types.SMALLINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source.compareTo(bdMaxShortValue__) == 1 || source.compareTo(bdMinShortValue__) == -1)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "SMALLINT");
             }
             return new Short(source.shortValue());
 
         case Types.INTEGER:
             if (Configuration.rangeCheckCrossConverters &&
                     (source.compareTo(bdMaxIntValue__) == 1 || source.compareTo(bdMinIntValue__) == -1)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "INTEGER");
             }
             return new Integer(source.intValue());
 
         case Types.BIGINT:
             if (Configuration.rangeCheckCrossConverters &&
                     (source.compareTo(bdMaxLongValue__) == 1 || source.compareTo(bdMinLongValue__) == -1)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "BIGINT");
             }
             return new Long(source.longValue());
 
         case Types.REAL:
             if (Configuration.rangeCheckCrossConverters &&
                     (source.compareTo(bdMaxFloatValue__) == 1 || source.compareTo(bdMinFloatValue__) == -1)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "REAL");
             }
             return new Float(source.floatValue());
 
         case Types.DOUBLE:
             if (Configuration.rangeCheckCrossConverters &&
                     (source.compareTo(bdMaxDoubleValue__) == 1 || source.compareTo(bdMinDoubleValue__) == -1)) {
-                throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+                throw new OutsideRangeForDataTypeException(
+                    agent_.logWriter_, "DOUBLE");
             }
             return new Double(source.doubleValue());
 
@@ -1000,7 +1018,8 @@ final boolean getBooleanFromString(String source) {
     final byte getByteFromShort(short source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Byte.MAX_VALUE || source < java.lang.Byte.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "TINYINT");
         }
 
         return (byte) source;
@@ -1009,7 +1028,8 @@ final byte getByteFromShort(short source) throws SqlException {
     final byte getByteFromInt(int source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Byte.MAX_VALUE || source < java.lang.Byte.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "TINYINT");
         }
 
         return (byte) source;
@@ -1018,7 +1038,8 @@ final byte getByteFromInt(int source) throws SqlException {
     final byte getByteFromLong(long source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Byte.MAX_VALUE || source < java.lang.Byte.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "TINYINT");
         }
 
         return (byte) source;
@@ -1027,7 +1048,8 @@ final byte getByteFromLong(long source) throws SqlException {
     final byte getByteFromFloat(float source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Byte.MAX_VALUE || source < java.lang.Byte.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "TINYINT");
         }
 
         return (byte) source;
@@ -1036,7 +1058,8 @@ final byte getByteFromFloat(float source) throws SqlException {
     final byte getByteFromDouble(double source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Byte.MAX_VALUE || source < java.lang.Byte.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "TINYINT");
         }
 
         return (byte) source;
@@ -1061,7 +1084,8 @@ final byte getByteFromString(String source) throws SqlException {
     final short getShortFromInt(int source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Short.MAX_VALUE || source < java.lang.Short.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "SMALLINT");
         }
 
         return (short) source;
@@ -1070,7 +1094,8 @@ final short getShortFromInt(int source) throws SqlException {
     final short getShortFromLong(long source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Short.MAX_VALUE || source < java.lang.Short.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "SMALLINT");
         }
 
         return (short) source;
@@ -1079,7 +1104,8 @@ final short getShortFromLong(long source) throws SqlException {
     final short getShortFromFloat(float source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Short.MAX_VALUE || source < java.lang.Short.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "SMALLINT");
         }
 
         return (short) source;
@@ -1088,7 +1114,8 @@ final short getShortFromFloat(float source) throws SqlException {
     final short getShortFromDouble(double source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Short.MAX_VALUE || source < java.lang.Short.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "SMALLINT");
         }
 
         return (short) source;
@@ -1114,7 +1141,8 @@ final short getShortFromString(String source) throws SqlException {
     final int getIntFromLong(long source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Integer.MAX_VALUE || source < java.lang.Integer.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "INTEGER");
         }
 
         return (int) source;
@@ -1123,7 +1151,8 @@ final int getIntFromLong(long source) throws SqlException {
     final int getIntFromFloat(float source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Integer.MAX_VALUE || source < java.lang.Integer.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "INTEGER");
         }
 
         return (int) source;
@@ -1132,7 +1161,8 @@ final int getIntFromFloat(float source) throws SqlException {
     final int getIntFromDouble(double source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Integer.MAX_VALUE || source < java.lang.Integer.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "INTEGER");
         }
 
         return (int) source;
@@ -1157,7 +1187,8 @@ final int getIntFromString(String source) throws SqlException {
     final long getLongFromFloat(float source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Long.MAX_VALUE || source < java.lang.Long.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "BIGINT");
         }
 
         return (long) source;
@@ -1166,7 +1197,8 @@ final long getLongFromFloat(float source) throws SqlException {
     final long getLongFromDouble(double source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 (source > java.lang.Long.MAX_VALUE || source < java.lang.Long.MIN_VALUE)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "BIGINT");
         }
 
         return (long) source;
@@ -1191,7 +1223,8 @@ final long getLongFromString(String source) throws SqlException {
     final float getFloatFromDouble(double source) throws SqlException {
         if (Configuration.rangeCheckCrossConverters &&
                 Float.isInfinite((float)source)) {
-            throw new LossOfPrecisionConversionException(agent_.logWriter_, String.valueOf(source));
+            throw new OutsideRangeForDataTypeException(
+                agent_.logWriter_, "DOUBLE");
         }
 
         return (float) source;
diff --git a/db/derby/code/trunk/java/client/org/apache/derby/client/am/SqlException.java b/db/derby/code/trunk/java/client/org/apache/derby/client/am/SqlException.java
index 93900d94..40fbd407 100644
--- a/db/derby/code/trunk/java/client/org/apache/derby/client/am/SqlException.java
+++ b/db/derby/code/trunk/java/client/org/apache/derby/client/am/SqlException.java
@@ -536,9 +536,10 @@ public static void setExceptionFactory (SQLExceptionFactory factory) {
 // An intermediate exception encapsulation to provide code-reuse
 // for common CrossConverters data conversion exceptions.
 
-class LossOfPrecisionConversionException extends SqlException {
-    LossOfPrecisionConversionException(LogWriter logWriter, String instance) {
-        super(logWriter, new ClientMessageId(SQLState.LOSS_OF_PRECISION_EXCEPTION), 
+class OutsideRangeForDataTypeException extends SqlException {
+    OutsideRangeForDataTypeException(LogWriter logWriter, String instance) {
+        super(logWriter,
+              new ClientMessageId(SQLState.LANG_OUTSIDE_RANGE_FOR_DATATYPE), 
             instance);
     }
 }
diff --git a/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java b/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java
index 564dcb7d..86b5f155 100644
--- a/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java
+++ b/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java
@@ -715,7 +715,6 @@ The message identifier (ie. the value that matches a field in this class)
     String LANG_SQRT_OF_NEG_NUMBER                                     = "22013";
     String LANG_INVALID_PARAMETER_FOR_SEARCH_POSITION                  = "22014";
     String LANG_INVALID_TYPE_FOR_LOCATE_FUNCTION                       = "22015";
-    String LOSS_OF_PRECISION_EXCEPTION                                 = "22015.S.1";
 	String LANG_FORMAT_EXCEPTION                                       = "22018";
 	String LANG_INVALID_ESCAPE_CHARACTER                               = "22019";
 	String LANG_INVALID_TRIM_CHARACTER                                 = "22020";
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/ParameterMappingTest.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/ParameterMappingTest.java
index 60be1ac4..38d96e92 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/ParameterMappingTest.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/ParameterMappingTest.java
@@ -1102,6 +1102,7 @@ public  void    testBigInteger() throws  Exception
      */
     protected void tearDown() throws Exception {
         Connection conn = getConnection();
+        rollback();
         Statement scb = conn.createStatement();
         scb.execute("DROP TABLE PM.LOB_GET");
         scb.close();
@@ -4485,6 +4486,548 @@ protected void    expectCompilationError( String sqlState, String query )
 
         assertCompileError( sqlState, query );
     }
-}
 
+    /**
+     * Tests that SQLStates are correct across drivers on rs.getXXX
+     * over/underflow.
+     * @exception SQLException database access error. Causes test to
+     *                         fail with an error.
+     */
+    public void testDerby5533GetXXX() throws SQLException
+    {
+        String createTableString = "CREATE TABLE MultiTypeTable (" +
+            "F01 SMALLINT," +
+            "F02 INTEGER," +
+            "F03 BIGINT," +
+            "F04 REAL," +
+            "F05 FLOAT," +
+            "F06 DOUBLE," +
+            "F07 DECIMAL(31)," +
+            "F08 NUMERIC," +
+            "F09 CHAR(100)," +
+            "F10 VARCHAR(256)," +
+            "F11 BOOLEAN)";
+        Statement stmt = createStatement();
+        stmt.executeUpdate(createTableString);
+
+        PreparedStatement ps = prepareStatement
+            ("insert into MultiTypeTable values(?,?,?,?,?,?,?,?,?,?,?)");
+
+        /* First check upper bounds */
+
+        ps.setShort(1, (short)((short)Byte.MAX_VALUE + 1));
+        ps.setInt(2, (int)Short.MAX_VALUE + 1);
+        ps.setLong(3, (long)Integer.MAX_VALUE + 1);
+        ps.setFloat(4, (float)Long.MAX_VALUE * 10);
+        ps.setFloat(5, (float)Long.MAX_VALUE * 10);
+        ps.setDouble(6, (double)Float.MAX_VALUE * 10);
+        // Largest integer representable in DECIMAL is Derby has 31 digits:
+        ps.setBigDecimal(7, new BigDecimal("9999999999999999999999999999999"));
+        ps.setInt(8, _X);
+        ps.setString(9, " ");
+        ps.setString(10, " ");
+        ps.setBoolean(11, true);
+        ps.executeUpdate();
+
+        ResultSet rs = createStatement().
+                executeQuery("select * from MultiTypeTable");
+        rs.next();
+
+        // JDBC type -> byte
+        assertGetState(rs, "F01", XXX_BYTE, "22003");
+        assertGetState(rs, "F02", XXX_BYTE, "22003");
+        assertGetState(rs, "F03", XXX_BYTE, "22003");
+        assertGetState(rs, "F04", XXX_BYTE, "22003");
+        assertGetState(rs, "F05", XXX_BYTE, "22003");
+        assertGetState(rs, "F06", XXX_BYTE, "22003");
+        assertGetState(rs, "F07", XXX_BYTE, "22003");
+
+        // JDBC type -> short
+        assertGetState(rs, "F02", XXX_SHORT, "22003");
+        assertGetState(rs, "F03", XXX_SHORT, "22003");
+        assertGetState(rs, "F04", XXX_SHORT, "22003");
+        assertGetState(rs, "F05", XXX_SHORT, "22003");
+        assertGetState(rs, "F06", XXX_SHORT, "22003");
+        assertGetState(rs, "F07", XXX_SHORT, "22003");
+
+        // JDBC type -> int
+        assertGetState(rs, "F03", XXX_INT, "22003");
+        assertGetState(rs, "F04", XXX_INT, "22003");
+        assertGetState(rs, "F05", XXX_INT, "22003");
+        assertGetState(rs, "F06", XXX_INT, "22003");
+        assertGetState(rs, "F07", XXX_INT, "22003");
+
+        // JDBC type -> long
+        assertGetState(rs, "F04", XXX_LONG, "22003");
+        assertGetState(rs, "F05", XXX_LONG, "22003");
+        assertGetState(rs, "F06", XXX_LONG, "22003");
+
+        // Uncomment when DERBY-5536 is fixed
+        // assertGetState(rs, "F07", XXX_LONG, "22003");
+
+
+        // JDBC type -> float
+        rs.close();
+        Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
+                ResultSet.CONCUR_UPDATABLE);
+        rs = s.executeQuery("SELECT * FROM MultiTypeTable");
+        rs.next();
+        rs.updateDouble("F06", Float.MAX_VALUE * 10.0);
+        rs.updateRow();
+
+        rs = createStatement().
+                executeQuery("select * from MultiTypeTable");
+        rs.next();
+
+        assertGetState(rs, "F06", XXX_FLOAT, "22003");
+
+
+        /* Now check lower bounds */
+        PreparedStatement psDelete = prepareStatement(
+                "delete from MultiTypeTable");
+        psDelete.executeUpdate();
+
+        ps.setShort(1, (short)((short)Byte.MIN_VALUE - 1));
+        ps.setInt(2, (int)Short.MIN_VALUE - 1);
+        ps.setLong(3, (long)Integer.MIN_VALUE - 1);
+        ps.setFloat(4, -(float)Long.MAX_VALUE * 10);
+        ps.setFloat(5, -(float)Long.MAX_VALUE * 10);
+        ps.setDouble(6, -(double)Float.MAX_VALUE * 10);
+        // Largest integer representable in DECIMAL is Derby has 31 digits:
+        ps.setBigDecimal(7, new BigDecimal("-999999999999999999999999999999"));
+        ps.setInt(8, _X);
+        ps.setString(9, " ");
+        ps.setString(10, " ");
+        ps.setBoolean(11, false);
+        ps.executeUpdate();
+
+        rs = createStatement().
+                executeQuery("select * from MultiTypeTable");
+        rs.next();
+        // JDBC type -> byte
+        assertGetState(rs, "F01", XXX_BYTE, "22003");
+        assertGetState(rs, "F02", XXX_BYTE, "22003");
+        assertGetState(rs, "F03", XXX_BYTE, "22003");
+        assertGetState(rs, "F04", XXX_BYTE, "22003");
+        assertGetState(rs, "F05", XXX_BYTE, "22003");
+        assertGetState(rs, "F06", XXX_BYTE, "22003");
+        assertGetState(rs, "F07", XXX_BYTE, "22003");
+
+        // JDBC type -> short
+        assertGetState(rs, "F02", XXX_SHORT, "22003");
+        assertGetState(rs, "F03", XXX_SHORT, "22003");
+        assertGetState(rs, "F04", XXX_SHORT, "22003");
+        assertGetState(rs, "F05", XXX_SHORT, "22003");
+        assertGetState(rs, "F06", XXX_SHORT, "22003");
+        assertGetState(rs, "F07", XXX_SHORT, "22003");
+
+        // JDBC type -> int
+        assertGetState(rs, "F03", XXX_INT, "22003");
+        assertGetState(rs, "F04", XXX_INT, "22003");
+        assertGetState(rs, "F05", XXX_INT, "22003");
+        assertGetState(rs, "F06", XXX_INT, "22003");
+        assertGetState(rs, "F07", XXX_INT, "22003");
+
+        // JDBC type -> long
+        assertGetState(rs, "F04", XXX_LONG, "22003");
+        assertGetState(rs, "F05", XXX_LONG, "22003");
+        assertGetState(rs, "F06", XXX_LONG, "22003");
+
+        // JDBC type -> float
+        rs.close();
+        s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
+                ResultSet.CONCUR_UPDATABLE);
+        rs = s.executeQuery("SELECT * FROM MultiTypeTable");
+        rs.next();
+        rs.updateDouble("F06", -Float.MAX_VALUE * 10.0);
+        rs.updateRow();
+
+        rs = createStatement().
+                executeQuery("select * from MultiTypeTable");
+        rs.next();
+
+        assertGetState(rs, "F06", XXX_FLOAT, "22003");
+    }
+
+
+    /**
+     * Tests that SQLStates are correct across drivers on updateXXX
+     * over/underflow.
+     * @exception SQLException database access error. Causes test to
+     *                         fail with an error.
+     */
+    public void testDerby5533UpdateXXX() throws SQLException
+    {
+        String createTableString = "CREATE TABLE MultiTypeTable (" +
+            "F01 SMALLINT," +
+            "F02 INTEGER," +
+            "F03 BIGINT," +
+            "F04 REAL," +
+            "F05 FLOAT," +
+            "F06 DOUBLE," +
+            "F07 DECIMAL(31)," +
+            "F08 NUMERIC," +
+            "F09 CHAR(100)," +
+            "F10 VARCHAR(256)," +
+            "F11 BOOLEAN)";
+        Statement stmt = createStatement();
+        stmt.executeUpdate(createTableString);
+
+        PreparedStatement ps = prepareStatement
+            ("insert into MultiTypeTable values(?,?,?,?,?,?,?,?,?,?,?)");
+        PreparedStatement psDelete = prepareStatement(
+            "delete from MultiTypeTable");
+
+        /* First check upper bounds */
+
+        ps.setShort(1, (short)1);
+        ps.setInt(2, 1);
+        ps.setLong(3, 1L);
+        ps.setFloat(4, 1.0f);
+        ps.setDouble(5, 1.0);
+        ps.setDouble(6, 1.0);
+        ps.setString(7, "1");
+        ps.setString(8, "1");
+        ps.setString(9, "1");
+        ps.setString(10, "1");
+        ps.setBoolean(11, true);
+
+        ps.executeUpdate();
+
+        Statement s = createStatement(ResultSet.TYPE_FORWARD_ONLY,
+                ResultSet.CONCUR_UPDATABLE);
+        ResultSet rs = s.executeQuery("SELECT * FROM MultiTypeTable");
+        rs.next();
+
+        // SMALLINT
+        assertUpdateState(rs, "F01",
+                          Short.MAX_VALUE + 1, _X, XXX_INT,"22003");
+        assertUpdateState(rs, "F01",
+                          _X, Short.MAX_VALUE + 1, XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F01",
+                          Short.MAX_VALUE + 1, _X, XXX_LONG, "22003");
+        assertUpdateState(rs, "F01",
+                          _X, Short.MAX_VALUE + 1, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F01",
+                          bdMaxShortValue.add(BigDecimal.ONE), "22003");
+
+        assertUpdateState(rs, "F01",
+                          Short.MIN_VALUE - 1, _X, XXX_INT,"22003");
+        assertUpdateState(rs, "F01",
+                          _X, Short.MIN_VALUE - 1, XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F01",
+                          Short.MIN_VALUE - 1, _X, XXX_LONG, "22003");
+        assertUpdateState(rs, "F01",
+                          _X, Short.MIN_VALUE - 1, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F01",
+                          bdMinShortValue.subtract(BigDecimal.ONE), "22003");
+
+
+        // INT
+        assertUpdateState(rs, "F02",
+                          (long)Integer.MAX_VALUE + 1, _X, XXX_LONG, "22003");
+        assertUpdateState(rs, "F02", _X,
+                          (float)Integer.MAX_VALUE * 10, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F02", _X,
+                          (double)Integer.MAX_VALUE * 10, XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F02",
+                          bdMaxIntValue.add(BigDecimal.ONE), "22003");
+
+        assertUpdateState(rs, "F02",
+                          (long)Integer.MIN_VALUE - 1, _X, XXX_LONG, "22003");
+        assertUpdateState(rs, "F02",
+                       _X, (float)Integer.MIN_VALUE * 10, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F02",
+                       _X, (double)Integer.MIN_VALUE * 10, XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F02",
+                          bdMinIntValue.subtract(BigDecimal.ONE), "22003");
+
+        // BIGINT
+        assertUpdateState(rs, "F03",
+                          _X, (float)Long.MAX_VALUE * 10, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F03",
+                          _X, (double)Long.MAX_VALUE * 10, XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F03",
+                          bdMaxLongValue.add(BigDecimal.ONE), "22003");
+
+        assertUpdateState(rs, "F03",
+                          _X, (float)Long.MIN_VALUE * 10, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F03",
+                          _X, (double)Long.MIN_VALUE * 10, XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F03",
+                          bdMinLongValue.subtract(BigDecimal.ONE), "22003");
+
+        // REAL overflow checking
+        assertUpdateState(rs, "F04",
+                          _X, (new Float(Float.MAX_VALUE)).doubleValue() * 10,
+                          XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F04",
+                          _X, Float.NEGATIVE_INFINITY, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F04",
+                          bdMaxFloatValue.multiply(BigDecimal.TEN), "22003");
+
+        assertUpdateState(rs, "F04",
+                          _X, -(new Float(Float.MAX_VALUE)).doubleValue() * 10,
+                          XXX_DOUBLE, "22003");
+        assertUpdateState(rs, "F04",
+                          _X, Float.NEGATIVE_INFINITY, XXX_FLOAT, "22003");
+        assertUpdateState(rs, "F04",
+                          bdMinFloatValue.multiply(BigDecimal.TEN), "22003");
+
+        // Remove test when DERBY-5534 is fixed
+        if (usingEmbedded()) {
+            assertUpdateState(rs, "F04",
+                              _X, Float.NaN, XXX_FLOAT, "22003");
+            assertUpdateState(rs, "F04",
+                              _X, Double.MIN_VALUE, XXX_DOUBLE, "22003");
+
+            // REAL DB2 limits: remove if DERBY-3398 is implemented
+            assertUpdateState(rs, "F04", bdSmallestPosFloatValue, "22003");
+            assertUpdateState(rs, "F04", bdSmallestNegFloatValue, "22003");
+
+            assertUpdateState(rs, "F04", bdMaxFloatValue, "22003");
+            assertUpdateState(rs, "F04", bdMinFloatValue, "22003");
+        }
+
+        // REAL Underflow checking
+        //
+        // Uncomment when DERBY-5546 is fixed:
+        // assertUpdateState(rs, "F04", bdSmallestPosDoubleValue, "22003");
+        // assertUpdateState(rs, "F04", bdSmallestNegDoubleValue, "22003");
+
+
+        // DOUBLE, FLOAT (SQL FLOAT is really the same as SQL DOUBLE in Derby)
+        final String[] dfCols = new String[]{"F05", "F06"};
+        for (int i = 0; i < 2; i++) {
+            assertUpdateState(rs, dfCols[i], _X,
+                              Float.POSITIVE_INFINITY, XXX_FLOAT, "22003");
+            assertUpdateState(rs, dfCols[i], _X,
+                              Double.POSITIVE_INFINITY, XXX_DOUBLE, "22003");
+            assertUpdateState(rs, dfCols[i],
+                              bdMaxDoubleValue.multiply(BigDecimal.TEN),
+                              "22003");
+
+            // Uncomment when DERBY-5534 is fixed, or remove entirely if
+            // DERBY-3398 is fixed
+            // assertUpdateState(rs, dfCols[i], _X,
+            //                   Double.MAX_VALUE, UPDATE_DOUBLE, "22003");
+
+            assertUpdateState(rs, dfCols[i],
+                              _X, Float.NEGATIVE_INFINITY, XXX_FLOAT, "22003");
+            assertUpdateState(rs, dfCols[i],
+                              _X, Double.NEGATIVE_INFINITY,
+                              XXX_DOUBLE, "22003");
+            assertUpdateState(rs, dfCols[i],
+                              bdMinDoubleValue.multiply(BigDecimal.TEN),
+                              "22003");
+
+            // Uncomment when DERBY-5534 is fixed, or remove entirely if
+            // DERBY-3398 is fixed
+
+            // assertUpdateState(rs, dfCols[i], _X,
+            //                   Double.MIN_VALUE, UPDATE_DOUBLE, "22003");
+
+            // Remove test when DERBY-5534 is fixed
+            if (usingEmbedded()) {
+                assertUpdateState(rs, dfCols[i],
+                                  _X, Double.NaN, XXX_DOUBLE, "22003");
+            }
+
+            // DOUBLE, FLOAT underflow checking
+            //
+            // Uncomment when DERBY-5546 is fixed
+            // assertUpdateState(rs, dfCols[i],
+            //     bdSmallestPosDoubleValue.divide(BigDecimal.TEN), "22003");
+            // assertUpdateState(rs, dfCols[i],
+            //     bdSmallestNegDoubleValue.divide(BigDecimal.TEN), "22003");
+        }
+
+        // Derby BOOLEAN: not range checked: FALSE of 0, else TRUE.
+        // assertUpdateState(rs, "F11", 2, _X, XXX_BYTE, "22003");
+        // assertUpdateState(rs, "F11", 2, _X, XXX_SHORT, "22003");
+        // assertUpdateState(rs, "F11", 2, _X, XXX_INT, "22003");
+        // assertUpdateState(rs, "F11", 2, _X, XXX_LONG, "22003");
+        // assertUpdateState(rs, "F11", _X, 2.0, XXX_FLOAT, "22003");
+        // assertUpdateState(rs, "F11", _X, 2.0, XXX_DOUBLE, "22003");
+        // assertUpdateState(rs, "F11", new BigDecimal(2), "22003");
+    }
+
+    // Short limits
+    //
+    private final static BigDecimal bdMaxShortValue =
+        BigDecimal.valueOf(Short.MAX_VALUE);
+
+    private final static BigDecimal bdMinShortValue =
+        BigDecimal.valueOf(Short.MIN_VALUE);
+
+    // Integer limits
+    //
+    private final static BigDecimal bdMaxIntValue =
+        BigDecimal.valueOf(Integer.MAX_VALUE);
+
+    private final static BigDecimal bdMinIntValue =
+        BigDecimal.valueOf(Integer.MIN_VALUE);
+
+    // Long limits
+    //
+    private final static BigDecimal bdMaxLongValue =
+        BigDecimal.valueOf(Long.MAX_VALUE);
+
+    private final static BigDecimal bdMinLongValue =
+        BigDecimal.valueOf(Long.MIN_VALUE);
+
+    // Float limits
+    //
+    private final static BigDecimal bdMaxFloatValue =
+        new BigDecimal(Float.MAX_VALUE);
+
+    private final static BigDecimal bdMinFloatValue =
+        new BigDecimal(-Float.MAX_VALUE);
+
+    private final static BigDecimal bdSmallestPosFloatValue =
+        new BigDecimal(Float.MIN_VALUE);
 
+    private final static BigDecimal bdSmallestNegFloatValue =
+        new BigDecimal(-Float.MIN_VALUE);
+
+    // Double limits
+    //
+    private final static BigDecimal bdMaxDoubleValue =
+        new BigDecimal(Double.MAX_VALUE);
+
+    private final static BigDecimal bdMinDoubleValue =
+        new BigDecimal(-Double.MAX_VALUE);
+
+    private final static BigDecimal bdSmallestPosDoubleValue =
+        new BigDecimal(Double.MIN_VALUE);
+
+    private final static BigDecimal bdSmallestNegDoubleValue =
+        new BigDecimal(-Double.MIN_VALUE);
+
+    // REAL/FLOAT/DOUBLE range limits
+
+    static final float DB2_SMALLEST_REAL = -3.402E+38f;
+    static final float DB2_LARGEST_REAL  = +3.402E+38f;
+    static final float DB2_SMALLEST_POSITIVE_REAL = +1.175E-37f;
+    static final float DB2_LARGEST_NEGATIVE_REAL  = -1.175E-37f;
+
+    static final double DB2_SMALLEST_DOUBLE = -1.79769E+308d;
+    static final double DB2_LARGEST_DOUBLE  = +1.79769E+308d;
+    static final double DB2_SMALLEST_POSITIVE_DOUBLE = +2.225E-307d;
+    static final double DB2_LARGEST_NEGATIVE_DOUBLE  = -2.225E-307d;
+
+    // Constants for use with assertUpdateState and assertGetState
+
+    private static final int _X = -1; // don't care
+    private static final int XXX_BYTE = 0;
+    private static final int XXX_SHORT = 1;
+    private static final int XXX_INT = 2;
+    private static final int XXX_LONG = 3;
+    private static final int XXX_FLOAT = 4;
+    private static final int XXX_DOUBLE = 5;
+
+    /*
+     * Using ResultSet.updateBigDecimal with value on colName, assert that we
+     * see the SQLstate expected.
+     */
+    private void assertUpdateState(
+        ResultSet rs,
+        String colName,
+        BigDecimal value,
+        String expected) throws SQLException {
+
+        try {
+            rs.updateBigDecimal(colName, value);
+            fail("exception expected");
+        } catch (SQLException e) {
+            println(e.toString());
+            assertSQLState(expected, e);
+        }
+    }
+
+
+    /*
+     * Using ResultSet.updateXXX with value or dvalue as the case may be on
+     * colName, assert that we see the SQLstate expected. XXX is indicated by
+     * updateType.
+     */
+    private void assertUpdateState(
+        ResultSet rs,
+        String colName,
+        long value,
+        double dvalue,
+        int updateType,
+        String expected) throws SQLException {
+
+        try {
+            switch (updateType) {
+            case XXX_BYTE:
+                rs.updateByte(colName, (byte)value);
+                break;
+            case XXX_SHORT:
+                rs.updateShort(colName, (short)value);
+            case XXX_INT:
+                rs.updateInt(colName, (int)value);
+                break;
+            case XXX_LONG:
+                rs.updateLong(colName, value);
+                break;
+            case XXX_FLOAT:
+                rs.updateFloat(colName, (float)dvalue);
+                break;
+            case XXX_DOUBLE:
+                rs.updateDouble(colName, dvalue);
+                break;
+            default:
+                fail("wrong argument");
+            }
+
+            fail("exception expected");
+        } catch (SQLException e) {
+            println(e.toString());
+            assertSQLState(expected, e);
+        }
+    }
+
+
+    /*
+     * Using ResultSet.getXXX on colName, assert that we see the SQLstate
+     * expected. XXX is indicated by getType.
+     */
+    private void assertGetState(
+        ResultSet rs,
+        String colName,
+        int getType,
+        String expected) throws SQLException {
+
+        try {
+            switch (getType) {
+            case XXX_BYTE:
+                rs.getByte(colName);
+                break;
+            case XXX_SHORT:
+                rs.getShort(colName);
+                    break;
+            case XXX_INT:
+                rs.getInt(colName);
+                break;
+            case XXX_LONG:
+                rs.getLong(colName);
+                break;
+            case XXX_FLOAT:
+                rs.getFloat(colName);
+                break;
+            case XXX_DOUBLE:
+                rs.getDouble(colName);
+                break;
+            default:
+                fail("wrong argument");
+            }
+
+            fail("exception expected");
+        } catch (SQLException e) {
+            println(e.toString());
+            assertSQLState(expected, e);
+        }
+    }
+}
