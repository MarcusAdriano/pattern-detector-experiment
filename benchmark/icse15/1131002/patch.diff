diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java
index d3e68d18..5366dd2f 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java
@@ -526,7 +526,7 @@ The offset from the base format number (0 based) gives the offset in the array.
         /* 461 */   "org.apache.derby.impl.sql.catalog.CoreDDFinderClassInfo",
         /* 462 */   "org.apache.derby.impl.sql.catalog.CoreDDFinderClassInfo",
         /* 463 */   "org.apache.derby.impl.sql.catalog.CoreDDFinderClassInfo",
-        /* 464 */   null,
+        /* 464 */   "org.apache.derby.iapi.types.SqlXmlUtil",        
 		/* 465 */   "org.apache.derby.impl.store.raw.data.CompressSpacePageOperation",
         /* 466 */   "org.apache.derby.impl.store.access.btree.index.B2I_10_3",
         /* 467 */   "org.apache.derby.impl.store.access.heap.Heap",
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java
index 72e0bbe4..4bf4d6df 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java
@@ -505,6 +505,12 @@ and another may restore (read) the object. The implication of this
     static public final int XML_TYPE_ID =
             (MIN_ID_2 + 456);
     
+    /**
+        class org.apache.derby.iapi.types.SqlXmlUtil
+    */
+    static public final int SQL_XML_UTIL_V01_ID =
+            (MIN_ID_2 + 464);
+    
     /**
         class org.apache.derby.iapi.types.JSQLType
      */
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/SqlXmlUtil.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/SqlXmlUtil.java
index 6c624a11..84034251 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/SqlXmlUtil.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/SqlXmlUtil.java
@@ -23,6 +23,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 import org.apache.derby.iapi.error.StandardException;
 import org.apache.derby.iapi.reference.SQLState;
+import org.apache.derby.iapi.services.io.Formatable;
+import org.apache.derby.iapi.services.io.StoredFormatIds;
 import org.apache.derby.iapi.services.sanity.SanityManager;
 
 import java.util.Properties;
@@ -31,6 +33,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import java.util.List;
 
 import java.io.IOException;
+import java.io.ObjectOutput;
+import java.io.ObjectInput;
 import java.io.StringReader;
 
 import java.lang.reflect.InvocationTargetException;
@@ -80,8 +84,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more
  *       query expression a single time per statement, instead of
  *       having to do it for every row against which the query
  *       is evaluated.  An instance of this class is created at
- *       compile time and then passed to the appropriate operator
- *       implementation method in XML.java.
+ *       compile time and then passed (using "saved objects")
+ *       to the appropriate operator implementation method in
+ *       XML.java; see SqlXmlExecutor.java for more about the
+ *       role this class plays in "saved object" processing.
  *
  *    2. By keeping all XML-specific references in this one class, 
  *       we have a single "point of entry" to the XML objects--namely,
@@ -107,7 +113,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
  *       _if_ s/he is trying to access or operate on XML values.
  */
 
-public class SqlXmlUtil
+public class SqlXmlUtil implements Formatable
 {
     // Used to parse a string into an XML value (DOM); checks
     // the well-formedness of the string while parsing.
@@ -797,6 +803,58 @@ private static String numberToString(double d)
         }
     }
 
+    /* ****
+     * Formatable interface implementation
+     * */
+
+    /** 
+     * @see java.io.Externalizable#writeExternal 
+     * 
+     * @exception IOException on error
+     */
+    public void writeExternal(ObjectOutput out) 
+        throws IOException
+    {
+        // query may be null
+        if (query == null)
+        {
+            out.writeBoolean(false);
+        }
+        else
+        {
+            out.writeBoolean(true);
+            out.writeObject(queryExpr);
+            out.writeObject(opName);
+        }
+    }
+
+    /** 
+     * @see java.io.Externalizable#readExternal 
+     *
+     * @exception IOException on error
+     * @exception ClassNotFoundException on error
+     */
+    public void readExternal(ObjectInput in) 
+        throws IOException, ClassNotFoundException
+    {
+        if (in.readBoolean())
+        {
+            queryExpr = (String)in.readObject();
+            opName = (String)in.readObject();
+            recompileQuery = true;
+	    }
+    }
+
+    /**
+     * Get the formatID which corresponds to this class.
+     *
+     * @return	the formatID of this class
+     */
+    public int getTypeFormatId()
+    { 
+        return StoredFormatIds.SQL_XML_UTIL_V01_ID;
+    }
+
     /*
      ** The XMLErrorHandler class is just a generic implementation
      ** of the ErrorHandler interface.  It allows us to catch
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XML.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XML.java
index 332d87de..154f31f2 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XML.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XML.java
@@ -598,7 +598,7 @@ public void loadStream() throws StandardException
      * store the _serialized_ version locally and then return
      * this XMLDataValue.
      *
-     * @param stringValue The string value to check.
+     * @param text The string value to check.
      * @param preserveWS Whether or not to preserve
      *  ignorable whitespace.
      * @param sqlxUtil Contains SQL/XML objects and util
@@ -609,18 +609,9 @@ public void loadStream() throws StandardException
      *  value is returned; otherwise, an exception is thrown. 
      * @exception StandardException Thrown on error.
      */
-    public XMLDataValue XMLParse(
-            StringDataValue stringValue,
-            boolean preserveWS,
-            SqlXmlUtil sqlxUtil)
-        throws StandardException
+    public XMLDataValue XMLParse(String text, boolean preserveWS,
+        SqlXmlUtil sqlxUtil) throws StandardException
     {
-        if (stringValue.isNull()) {
-            setToNull();
-            return this;
-        }
-
-        String text = stringValue.getString();
         try {
 
             if (preserveWS) {
@@ -843,10 +834,10 @@ public BooleanDataValue XMLExists(SqlXmlUtil sqlxUtil)
      * the received XMLDataValue "result" param (assuming "result" is
      * non-null; else create a new XMLDataValue).
      *
-     * @param sqlxUtil Contains SQL/XML objects and util methods that
-     *  facilitate execution of XML-related operations
      * @param result The result of a previous call to this method; null
      *  if not called yet.
+     * @param sqlxUtil Contains SQL/XML objects and util methods that
+     *  facilitate execution of XML-related operations
      * @return An XMLDataValue whose content corresponds to the serialized
      *  version of the results from evaluation of the query expression.
      *  Note: this XMLDataValue may not be storable into Derby XML
@@ -854,8 +845,8 @@ public BooleanDataValue XMLExists(SqlXmlUtil sqlxUtil)
      * @exception Exception thrown on error (and turned into a
      *  StandardException by the caller).
      */
-    public XMLDataValue XMLQuery(SqlXmlUtil sqlxUtil, XMLDataValue result)
-            throws StandardException
+    public XMLDataValue XMLQuery(XMLDataValue result,
+        SqlXmlUtil sqlxUtil) throws StandardException
     {
         if (this.isNull()) {
         // if the context is null, we return null,
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XMLDataValue.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XMLDataValue.java
index 890438b8..5ff48d14 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XMLDataValue.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/iapi/types/XMLDataValue.java
@@ -30,7 +30,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
      * store the _serialized_ version locally and then return
      * this XMLDataValue.
      *
-     * @param stringValue The string value to check.
+     * @param text The string value to check.
      * @param preserveWS Whether or not to preserve
      *  ignorable whitespace.
      * @param sqlxUtil Contains SQL/XML objects and util
@@ -41,11 +41,8 @@ Licensed to the Apache Software Foundation (ASF) under one or more
      *  value returned; otherwise, an exception is thrown. 
      * @exception StandardException Thrown on error.
      */
-    public XMLDataValue XMLParse(
-            StringDataValue stringValue,
-            boolean preserveWS,
-            SqlXmlUtil sqlxUtil)
-        throws StandardException;
+	public XMLDataValue XMLParse(String text, boolean preserveWS,
+		SqlXmlUtil sqlxUtil) throws StandardException;
 
     /**
      * The SQL/XML XMLSerialize operator.
@@ -93,10 +90,10 @@ public BooleanDataValue XMLExists(SqlXmlUtil sqlxUtil)
      * the received XMLDataValue "result" param (assuming "result" is
      * non-null; else create a new XMLDataValue).
      *
-     * @param sqlxUtil Contains SQL/XML objects and util methods that
-     *  facilitate execution of XML-related operations
      * @param result The result of a previous call to this method; null
      *  if not called yet.
+     * @param sqlxUtil Contains SQL/XML objects and util methods that
+     *  facilitate execution of XML-related operations
      * @return An XMLDataValue whose content corresponds to the serialized
      *  version of the results from evaluation of the query expression.
      *  Note: this XMLDataValue may not be storable into Derby XML
@@ -104,7 +101,7 @@ public BooleanDataValue XMLExists(SqlXmlUtil sqlxUtil)
      * @exception Exception thrown on error (and turned into a
      *  StandardException by the caller).
      */
-    public XMLDataValue XMLQuery(SqlXmlUtil sqlxUtil, XMLDataValue result)
+    public XMLDataValue XMLQuery(XMLDataValue result, SqlXmlUtil sqlxUtil)
 		throws StandardException;
 
     /* ****
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java
index 14ab3e21..c087546c 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/BinaryOperatorNode.java
@@ -21,16 +21,25 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 package	org.apache.derby.impl.sql.compile;
 
+import org.apache.derby.iapi.sql.compile.Visitable;
 import org.apache.derby.iapi.sql.compile.Visitor;
+import org.apache.derby.iapi.sql.dictionary.DataDictionary;
 import org.apache.derby.iapi.error.StandardException;
 
 import org.apache.derby.iapi.services.sanity.SanityManager;
 import org.apache.derby.iapi.services.compiler.MethodBuilder;
 import org.apache.derby.iapi.services.compiler.LocalField;
+import org.apache.derby.iapi.services.io.StoredFormatIds;
 
 import java.lang.reflect.Modifier;
+import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
+import org.apache.derby.impl.sql.compile.ActivationClassBuilder;
+import org.apache.derby.iapi.types.StringDataValue;
 import org.apache.derby.iapi.types.TypeId;
 import org.apache.derby.iapi.types.DataTypeDescriptor;
+import org.apache.derby.iapi.types.SqlXmlUtil;
+
+import org.apache.derby.iapi.store.access.Qualifier;
 
 import org.apache.derby.iapi.reference.ClassName;
 import org.apache.derby.iapi.reference.JDBC40Translation;
@@ -39,6 +48,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.util.JBitSet;
 import org.apache.derby.iapi.services.classfile.VMOpcode;
 
+import java.sql.Types;
 import java.util.Vector;
 
 /**
@@ -49,7 +59,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
  *
  */
 
-public class BinaryOperatorNode extends OperatorNode
+public class BinaryOperatorNode extends ValueNode
 {
 	String	operator;
 	String	methodName;
@@ -115,8 +125,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 		{ClassName.StringDataValue, ClassName.XMLDataValue}		// XMLQuery
 	};
 
-    /** The query expression if the operator is XMLEXISTS or XMLQUERY. */
-    private String xmlQuery;
+	// Class used to compile an XML query expression and/or load/process
+	// XML-specific objects.
+	private SqlXmlUtil sqlxUtil;
 
 	/**
 	 * Initializer for a BinaryOperatorNode
@@ -341,7 +352,11 @@ public ValueNode bindXMLQuery()
                 SQLState.LANG_INVALID_XML_QUERY_EXPRESSION);
         }
         else {
-            xmlQuery = ((CharConstantNode)leftOperand).getString();
+        // compile the query expression.
+            sqlxUtil = new SqlXmlUtil();
+            sqlxUtil.compileXQExpr(
+                ((CharConstantNode)leftOperand).getString(),
+                (operatorType == XMLEXISTS_OP ? "XMLEXISTS" : "XMLQUERY"));
         }
 
         // Right operand must be an XML data value.  NOTE: This
@@ -483,15 +498,29 @@ public void generateExpression(ExpressionClassBuilder acb,
 ** but how?
 */
 
-        // The number of arguments to pass to the method that implements the
-        // operator, depends on the type of the operator.
-        int numArgs;
-
 		// If we're dealing with XMLEXISTS or XMLQUERY, there is some
 		// additional work to be done.
 		boolean xmlGen =
 			(operatorType == XMLQUERY_OP) || (operatorType == XMLEXISTS_OP);
 
+		if (xmlGen) {
+		// We create an execution-time object so that we can retrieve
+		// saved objects (esp. our compiled query expression) from
+		// the activation.  We do this for two reasons: 1) this level
+		// of indirection allows us to separate the XML data type
+		// from the required XML implementation classes (esp. JAXP
+		// and Xalan classes)--for more on how this works, see the
+		// comments in SqlXmlUtil.java; and 2) we can take
+		// the XML query expression, which we've already compiled,
+		// and pass it to the execution-time object for each row,
+		// which means that we only have to compile the query
+		// expression once per SQL statement (instead of once per
+		// row); see SqlXmlExecutor.java for more.
+			mb.pushNewStart(
+				"org.apache.derby.impl.sql.execute.SqlXmlExecutor");
+			mb.pushNewComplete(addXmlOpMethodParams(acb, mb));
+		}
+
 		/*
 		** The receiver is the operand with the higher type precedence.
 		** Like always makes the left the receiver.
@@ -529,9 +558,6 @@ public void generateExpression(ExpressionClassBuilder acb,
 			rightOperand.generateExpression(acb, mb);
 			mb.cast(rightInterfaceType); // second arg with cast
 			// stack: left, left, right
-
-            // We've pushed two arguments
-            numArgs = 2;
 		}
 		else
 		{
@@ -555,25 +581,21 @@ public void generateExpression(ExpressionClassBuilder acb,
 			** UNLESS we're generating an XML operator such as XMLEXISTS.
 			** In that case we want to generate
 			** 
-			**  <right expression>.method(sqlXmlUtil)
+			**  SqlXmlExecutor.method(left, right)"
+			**
+			** and we've already pushed the SqlXmlExecutor object to
+			** the stack.
 			*/
 
 			rightOperand.generateExpression(acb, mb);			
 			mb.cast(receiverType); // cast the method instance
 			// stack: right
 			
-            if (xmlGen) {
-                // Push one argument (the SqlXmlUtil instance)
-                numArgs = 1;
-                pushSqlXmlUtil(acb, mb, xmlQuery, operator);
-                // stack: right,sqlXmlUtil
-            } else {
-                // Push two arguments (left, right)
-                numArgs = 2;
-
+			if (!xmlGen) {
 				mb.dup();
 				mb.cast(rightInterfaceType);
 				// stack: right,right
+			}
 			
                 leftOperand.generateExpression(acb, mb);
                 mb.cast(leftInterfaceType); // second arg with cast
@@ -582,20 +604,21 @@ public void generateExpression(ExpressionClassBuilder acb,
                 mb.swap();
                 // stack: right,left,right
             }
-		}
 
 		/* Figure out the result type name */
 		resultTypeName = (operatorType == -1)
 			? getTypeCompiler().interfaceName()
 			: resultInterfaceType;
 
-        // Boolean return types don't need a result field. For other types,
-        // allocate an object for re-use to hold the result of the operator.
-        LocalField resultField = getTypeId().isBooleanTypeId() ?
-            null : acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
+		// Boolean return types don't need a result field
+		boolean needField = !getTypeId().isBooleanTypeId();
+
+		if (needField) {
+
+			/* Allocate an object for re-use to hold the result of the operator */
+			LocalField resultField =
+				acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
 
-        // Push the result field onto the stack, if there is a result field.
-		if (resultField != null) {
 			/*
 			** Call the method for this operator.
 			*/
@@ -604,9 +627,6 @@ public void generateExpression(ExpressionClassBuilder acb,
 			//before generating code "field = method(p1, p2, field);"
 			initializeResultField(acb, mb, resultField);
 
-            // Adjust number of arguments for the result field
-            numArgs++;
-
 			/* pass statically calculated scale to decimal divide method to make
 			 * result set scale consistent, beetle 3901
 			 */
@@ -617,15 +637,17 @@ public void generateExpression(ExpressionClassBuilder acb,
 				operator.equals("/"))
 			{
 				mb.push(getTypeServices().getScale());		// 4th arg
-                numArgs++;
+				mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultTypeName, 4);
 			}
+			else if (xmlGen) {
+			// This is for an XMLQUERY operation, so invoke the method
+			// on our execution-time object.
+				mb.callMethod(VMOpcode.INVOKEVIRTUAL, null,
+					methodName, resultTypeName, 3);
         }
+			else
+				mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType, methodName, resultTypeName, 3);
 
-        mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType,
-                      methodName, resultTypeName, numArgs);
-
-        // Store the result of the method call, if there is a result field.
-        if (resultField != null) {
 			//the need for following if was realized while fixing bug 5704 where decimal*decimal was resulting an overflow value but we were not detecting it
 			if (getTypeId().variableLength())//since result type is numeric variable length, generate setWidth code.
 			{
@@ -648,6 +670,17 @@ public void generateExpression(ExpressionClassBuilder acb,
 			*/
 
 			mb.putField(resultField);
+		} else {
+			if (xmlGen) {
+			// This is for an XMLEXISTS operation, so invoke the method
+			// on our execution-time object.
+				mb.callMethod(VMOpcode.INVOKEVIRTUAL, null,
+					methodName, resultTypeName, 2);
+			}
+			else {
+				mb.callMethod(VMOpcode.INVOKEINTERFACE, receiverType,
+					methodName, resultTypeName, 2);
+			}
 		}
 	}
 
@@ -842,4 +875,32 @@ protected boolean isEquivalent(ValueNode o) throws StandardException
         	       && leftOperand.isEquivalent(other.leftOperand)
         	       && rightOperand.isEquivalent(other.rightOperand);
         }
+
+	/**
+	 * Push the fields necessary to generate an instance of
+	 * SqlXmlExecutor, which will then be used at execution
+	 * time to retrieve the compiled XML query expression,
+	 * along with any other XML-specific objects.
+	 *
+	 * @param acb The ExpressionClassBuilder for the class we're generating
+	 * @param mb  The method the code to place the code
+	 *
+	 * @return The number of items that this method pushed onto
+	 *  the mb's stack.
+	 */
+	private int addXmlOpMethodParams(ExpressionClassBuilder acb,
+		MethodBuilder mb) throws StandardException
+	{
+		// Push activation so that we can get our saved object
+		// (which will hold the compiled XML query expression)
+		// back at execute time.
+		acb.pushThisAsActivation(mb);
+
+		// Push our saved object (the compiled query and XML-specific
+		// objects).
+		mb.push(getCompilerContext().addSavedObject(sqlxUtil));
+
+		// We pushed 2 items to the stack.
+		return 2;
+	}
 }
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/OperatorNode.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/OperatorNode.java
index 62913b26..e69de29b 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/OperatorNode.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/OperatorNode.java
@@ -1,88 +0,0 @@
-/*
-
-   Derby - Class org.apache.derby.impl.sql.compile.OperatorNode
-
-   Licensed to the Apache Software Foundation (ASF) under one or more
-   contributor license agreements.  See the NOTICE file distributed with
-   this work for additional information regarding copyright ownership.
-   The ASF licenses this file to you under the Apache License, Version 2.0
-   (the "License"); you may not use this file except in compliance with
-   the License.  You may obtain a copy of the License at
-
-      http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
- */
-
-package org.apache.derby.impl.sql.compile;
-
-import java.lang.reflect.Modifier;
-import org.apache.derby.iapi.services.classfile.VMOpcode;
-import org.apache.derby.iapi.services.compiler.LocalField;
-import org.apache.derby.iapi.services.compiler.MethodBuilder;
-import org.apache.derby.iapi.types.SqlXmlUtil;
-
-/**
- * Abstract base-class for the various operator nodes: UnaryOperatorNode,
- * BinaryOperatorNode and TernarnyOperatorNode.
- */
-abstract class OperatorNode extends ValueNode {
-
-    /**
-     * <p>
-     * Generate code that pushes an SqlXmlUtil instance onto the stack. The
-     * instance will be created and cached in the activation's constructor, so
-     * that we don't need to create a new instance for every row.
-     * </p>
-     *
-     * <p>
-     * If the {@code xmlQuery} parameter is non-null, there will also be code
-     * that compiles the query when the SqlXmlUtil instance is created.
-     * </p>
-     *
-     * @param acb builder for the class in which the generated code lives
-     * @param mb builder for the method that implements this operator
-     * @param xmlQuery the XML query to be executed by the operator, or
-     * {@code null} if this isn't an XMLEXISTS or XMLQUERY operator
-     * @param xmlOpName the name of the operator (ignored if {@code xmlQuery}
-     * is {@code null})
-     */
-    static void pushSqlXmlUtil(
-            ExpressionClassBuilder acb, MethodBuilder mb,
-            String xmlQuery, String xmlOpName) {
-
-        // Create a field in which the instance can be cached.
-        LocalField sqlXmlUtil = acb.newFieldDeclaration(
-                Modifier.PRIVATE | Modifier.FINAL, SqlXmlUtil.class.getName());
-
-        // Add code that creates the SqlXmlUtil instance in the constructor.
-        MethodBuilder constructor = acb.getConstructor();
-        constructor.pushNewStart(SqlXmlUtil.class.getName());
-        constructor.pushNewComplete(0);
-        constructor.putField(sqlXmlUtil);
-
-        // Compile the query, if one is specified.
-        if (xmlQuery == null) {
-            // No query. The SqlXmlUtil instance is still on the stack. Pop it
-            // to restore the initial state of the stack.
-            constructor.pop();
-        } else {
-            // Compile the query. This will consume the SqlXmlUtil instance
-            // and leave the stack in its initial state.
-            constructor.push(xmlQuery);
-            constructor.push(xmlOpName);
-            constructor.callMethod(
-                    VMOpcode.INVOKEVIRTUAL, SqlXmlUtil.class.getName(),
-                    "compileXQExpr", "void", 2);
-        }
-
-        // Read the cached value and push it onto the stack in the method
-        // generated for the operator.
-        mb.getField(sqlXmlUtil);
-    }
-}
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java
index 2d61d2b8..f96fe0f6 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/TernaryOperatorNode.java
@@ -54,7 +54,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
  *
  */
 
-public class TernaryOperatorNode extends OperatorNode
+public class TernaryOperatorNode extends ValueNode
 {
 	String		operator;
 	String		methodName;
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java
index 42128caf..11cba27c 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/compile/UnaryOperatorNode.java
@@ -23,8 +23,11 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 import org.apache.derby.iapi.store.access.Qualifier;
 
+import org.apache.derby.iapi.sql.compile.Visitable;
 import org.apache.derby.iapi.sql.compile.Visitor;
 
+import org.apache.derby.iapi.sql.dictionary.DataDictionary;
+
 import org.apache.derby.iapi.reference.JDBC40Translation;
 import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.reference.ClassName;
@@ -32,11 +35,15 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.services.sanity.SanityManager;
 import org.apache.derby.iapi.services.compiler.MethodBuilder;
 import org.apache.derby.iapi.services.compiler.LocalField;
+import org.apache.derby.iapi.services.io.StoredFormatIds;
 
+import org.apache.derby.iapi.types.StringDataValue;
 import org.apache.derby.iapi.types.TypeId;
 import org.apache.derby.iapi.types.DataTypeDescriptor;
+import org.apache.derby.iapi.types.SqlXmlUtil;
 
 import java.lang.reflect.Modifier;
+import org.apache.derby.impl.sql.compile.ExpressionClassBuilder;
 
 import org.apache.derby.iapi.util.JBitSet;
 import org.apache.derby.iapi.services.classfile.VMOpcode;
@@ -52,7 +59,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
  *
  */
 
-public class UnaryOperatorNode extends OperatorNode
+public class UnaryOperatorNode extends ValueNode
 {
 	String	operator;
 	String	methodName;
@@ -114,6 +121,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	// args required by the operator method call.
 	private Object [] additionalArgs;
 
+	// Class used to hold XML-specific objects required for
+	// parsing/serializing XML data.
+	private SqlXmlUtil sqlxUtil;
+
 	/**
 	 * Initializer for a UnaryOperatorNode.
 	 *
@@ -372,6 +383,12 @@ private void bindXMLParse() throws StandardException
             }
         }
 
+        // Create a new XML compiler object; the constructor
+        // here automatically creates the XML-specific objects 
+        // required for parsing/serializing XML, so all we
+        // have to do is create an instance.
+        sqlxUtil = new SqlXmlUtil();
+
         // The result type of XMLParse() is always an XML type.
         setType(DataTypeDescriptor.getBuiltInDataTypeDescriptor(
                 JDBC40Translation.SQLXML));
@@ -607,6 +624,26 @@ public void generateExpression(ExpressionClassBuilder acb,
 											MethodBuilder mb)
 									throws StandardException
 	{
+		// For XML operator we do some extra work.
+		boolean xmlGen = (operatorType == XMLPARSE_OP) ||
+			(operatorType == XMLSERIALIZE_OP);
+
+		if (xmlGen) {
+		// We create an execution-time object from which we call
+		// the necessary methods.  We do this for two reasons: 1) this
+		// level of indirection allows us to separate the XML data type
+		// from the required XML implementation classes (esp. JAXP and
+		// Xalan classes)--for more on how this works, see the comments
+		// in SqlXmlUtil.java; and 2) this allows us to create the
+		// required XML objects a single time (which we did at bind time
+		// when we created a new SqlXmlUtil) and then reuse those objects
+		// for each row in the target result set, instead of creating
+		// new objects every time; see SqlXmlUtil.java for more.
+			mb.pushNewStart(
+				"org.apache.derby.impl.sql.execute.SqlXmlExecutor");
+			mb.pushNewComplete(addXmlOpMethodParams(acb, mb));
+		}
+
 		String resultTypeName = 
 			(operatorType == -1)
 				? getTypeCompiler().interfaceName()
@@ -627,13 +664,25 @@ public void generateExpression(ExpressionClassBuilder acb,
 			LocalField field = acb.newFieldDeclaration(Modifier.PRIVATE, resultTypeName);
 			mb.getField(field);
 
-            int numArgs = 1;
-
-            // XML operators take extra arguments.
-            numArgs += addXmlOpMethodParams(acb, mb, field);
-
-            mb.callMethod(VMOpcode.INVOKEINTERFACE, null,
-                          methodName, resultTypeName, numArgs);
+			/* If we're calling a method on a class (SqlXmlExecutor) instead
+			 * of calling a method on the operand interface, then we invoke
+			 * VIRTUAL; we then have 2 args (the operand and the local field)
+			 * instead of one, i.e:
+			 *
+			 *  SqlXmlExecutor.method(operand, field)
+			 *
+			 * instead of
+			 *
+			 *  <operand>.method(field).
+			 */
+			if (xmlGen) {
+				mb.callMethod(VMOpcode.INVOKEVIRTUAL, null,
+					methodName, resultTypeName, 2);
+			}
+			else {
+				mb.callMethod(VMOpcode.INVOKEINTERFACE,
+					(String) null, methodName, resultTypeName, 1);
+			}
 
 			/*
 			** Store the result of the method call in the field, so we can re-use
@@ -714,14 +763,11 @@ void acceptChildren(Visitor v)
     /**
      * Add some additional arguments to our method call for
      * XML related operations like XMLPARSE and XMLSERIALIZE.
-     *
-     * @param acb the builder for the class in which the method lives
      * @param mb The MethodBuilder that will make the call.
-     * @param resultField the field that contains the previous result
      * @return Number of parameters added.
      */
     protected int addXmlOpMethodParams(ExpressionClassBuilder acb,
-		MethodBuilder mb, LocalField resultField) throws StandardException
+		MethodBuilder mb) throws StandardException
     {
         if ((operatorType != XMLPARSE_OP) && (operatorType != XMLSERIALIZE_OP))
         // nothing to do.
@@ -752,26 +798,20 @@ protected int addXmlOpMethodParams(ExpressionClassBuilder acb,
 
         /* Else we're here for XMLPARSE. */
 
-        // XMLPARSE is different from other unary operators in that the method
-        // must be called on the result object (the XML value) and not on the
-        // operand (the string value). We must therefore make sure the result
-        // object is not null.
-        MethodBuilder constructor = acb.getConstructor();
-        acb.generateNull(constructor, getTypeCompiler(),
-                         getTypeServices().getCollationType());
-        constructor.setField(resultField);
+        // Push activation, which we use at execution time to
+        // get our saved object (which will hold objects used
+        // for parsing/serializing) back.
+        acb.pushThisAsActivation(mb);
 
-        // Swap operand and result object so that the method will be called
-        // on the result object.
-        mb.swap();
+        // Push our XML object (used for parsing/serializing) as
+        // a saved object, so that we can retrieve it at execution
+        // time.  This allows us to avoid having to re-create the
+        // objects for every row in a given result set.
+        mb.push(getCompilerContext().addSavedObject(sqlxUtil));
 
         // Push whether or not we want to preserve whitespace.
         mb.push(((Boolean)additionalArgs[0]).booleanValue());
-
-        // Push the SqlXmlUtil instance as the next argument.
-        pushSqlXmlUtil(acb, mb, null, null);
-
-        return 2;
+        return 3;
     }
     
     /**
diff --git a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/SqlXmlExecutor.java b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/SqlXmlExecutor.java
index e69de29b..827504ae 100644
--- a/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/SqlXmlExecutor.java
+++ b/db/derby/code/branches/10.8/java/engine/org/apache/derby/impl/sql/execute/SqlXmlExecutor.java
@@ -0,0 +1,275 @@
+/*
+
+   Derby - Class org.apache.derby.impl.sql.execute.SqlXmlExecutor
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.impl.sql.execute;
+
+import org.apache.derby.iapi.error.StandardException;
+import org.apache.derby.iapi.reference.SQLState;
+import org.apache.derby.iapi.sql.Activation;
+
+import org.apache.derby.iapi.types.BooleanDataValue;
+import org.apache.derby.iapi.types.StringDataValue;
+import org.apache.derby.iapi.types.XML;
+import org.apache.derby.iapi.types.XMLDataValue;
+import org.apache.derby.iapi.types.SqlXmlUtil;
+
+/**
+ * This class is really just an execution time "utility" that
+ * makes calls to methods on the XMLDataValue interface.  Instances
+ * of this class are generated at execution time by the various
+ * Derby XML operators--one instance for each row in the target
+ * result set--and then the appropriate operator call is made on
+ * that instance (see, for example, the generateExpression() methods
+ * in UnaryOperatorNode and BinaryOperatorNode).  When an instance
+ * of this class is instantiated, one of the arguments that can be
+ * provided is an id that is used to retrieve an already-constructed
+ * (from compilation time) instance of SqlXmlUtil from the current
+ * Activation.  When it comes time to execute the operator, this class
+ * just makes the appropriate call on the received XMLDataValue object
+ * and passes in the SqlXmlUtil, from which the XMLDataValue can
+ * retrieve compile-time objects.  The XMLDataValue can also make
+ * calls to various XML-specific utilities on the SqlXmlUtil
+ * object.
+ *
+ * Let's take an example.  Assume the statement that the user
+ * wants to execute is:
+ *
+ *   select id from xtable
+ *      where XMLEXISTS('/simple' PASSING BY REF xcol)
+ *
+ * At compilation time we will compile the expression "/simple"
+ * and store the compiled version of the query into an instance
+ * of SqlXmlUtil.  Then we will save that instance of SqlXmlUtil
+ * as an object in the statement activation, from which we will
+ * receive an id that can be used later to retrieve the object
+ * (i.e. to retrieve the SqlXmlUtil).  Then, for *each* row
+ * in xtable, we'll generate the following:
+ *
+ *  boolean result =
+ *    (new SqlXmlExecutor(activation, compileTimeObjectId)).
+ *      XMLExists("/simple", xcol);
+ *
+ * In other words, for each row we create a new instance of
+ * this class and call "XMLExists" on that instance.  Then,
+ * as seen below, we retrieve the SqlXmlUtil from the activation
+ * and pass that into a call to "XMLExists" on the XML value
+ * itself (i.e. xcol).  XMLDataValue.XMLExists() then uses the
+ * methods and objects (which include the compiled query
+ * expression for "/simple") defined on SqlXmlUtil to complete
+ * the operation.
+ * 
+ * Okay, so why do we use this execution-time SqlXmlExecutor class
+ * instead of just generating a call to XMLDataValue.XMLExists()
+ * directly?  The reason is that we only want to compile the XML
+ * query expression once per statement--and where possible we'd
+ * also like to only generate re-usable XML-specific objects
+ * once per statement, as well.  If instead we generated a call to
+ * XMLDataValue.XMLExists() directly for each row, then we would
+ * have to either pass in the expression string and have XMLDataValue
+ * compile it, or we would have to compile the expression string
+ * and then pass the compiled object into XMLDataValue--in either
+ * case, we'd end up compiling the XML query expression (and creating
+ * the corresponding XML-specific objects) once for each row in
+ * the target result set.  By using the "saveObject" functionality
+ * in Activation along with this SqlXmlExecutor class, we make
+ * it so that we only have to compile the XML query expression and
+ * create XML-specific objects once (at compile time), and then
+ * we can re-use those objects for every row in the target
+ * result set.  Yes, we're still creating an instance of this
+ * class (SqlXmlExecutor) once per row, and yes we have to fetch
+ * the appropriate SqlXmlUtil object once per row, but this is
+ * still going to be cheaper than having to re-compile the query
+ * expression and re-create XML objects for every row.
+ * 
+ * So in short, this class allows us to improve the execution-time
+ * performance of XML operators by allowing us to create XML-
+ * specific objects and compile XML query expressions once per
+ * statement, instead of once per row.
+ *
+ * One final note: the reason this class is in this package
+ * instead of the types package is that, in order to retrieve
+ * the compile-time objects, we have to use the "getSavedObject()"
+ * method on the Activation.  But the Activation class is part
+ * of the SQL layer (org.apache.derby.iapi.sql.Activation) and
+ * we want to keep the types layer independent of the SQL layer
+ * because the types can be used during recovery before the SQL
+ * system has booted.  So the next logical choices were the compile
+ * package (impl.sql.compile) or the execution package; of those,
+ * the execution package seems more appropriate since this
+ * class is only instantiated and used during execution, not
+ * during compilation.
+ */
+
+public class SqlXmlExecutor {
+
+    // The activation from which we load the compile-time XML
+    // objects (including the compiled XML query expression in
+    // case of XMLEXISTS and XMLQUERY).
+    private Activation activation;
+    private int sqlXUtilId;
+
+    // Target type, target width and target collation type that 
+    // were specified for an XMLSERIALIZE operator.
+    private int targetTypeId;
+    private int targetMaxWidth;
+    private int targetCollationType;
+
+    // Whether or not to preserve whitespace for XMLPARSE
+    // operator.
+    private boolean preserveWS;
+
+    /**
+     * Constructor 1: Used for XMLPARSE op.
+     * @param activation Activation from which to retrieve saved objects
+     * @param utilId Id by which we find saved objects in activation
+     * @param preserveWS Whether or not to preserve whitespace
+     */
+    public SqlXmlExecutor(Activation activation, int utilId,
+        boolean preserveWS)
+    {
+        this.activation = activation;
+        this.sqlXUtilId = utilId;
+        this.preserveWS = preserveWS;
+    }
+
+    /**
+     * Constructor 2: Used for XMLSERIALIZE op.
+     * @param targetTypeId The string type to which we want to serialize.
+     * @param targetMaxWidth The max width of the target type.
+     * @param targetCollationType The collation type of the target type.
+     */
+    public SqlXmlExecutor(int targetTypeId, int targetMaxWidth, 
+    		int targetCollationType)
+    {
+        this.targetTypeId = targetTypeId;
+        this.targetMaxWidth = targetMaxWidth;
+        this.targetCollationType = targetCollationType;
+    }
+
+    /**
+     * Constructor 3: Used for XMLEXISTS/XMLQUERY ops.
+     * @param activation Activation from which to retrieve saved objects
+     * @param utilId Id by which we find saved objects in activation
+     */
+    public SqlXmlExecutor(Activation activation, int utilId)
+    {
+        this.activation = activation;
+        this.sqlXUtilId = utilId;
+    }
+
+    /**
+     * Make the call to perform an XMLPARSE operation on the
+     * received XML string and store the result in the received
+     * XMLDataValue (or if it's null, create a new one).
+     *
+     * @param xmlText String to parse
+     * @param result XMLDataValue in which to store the result
+     * @return The received XMLDataValue with its content set to
+     *  correspond to the received xmlText, if the text constitutes
+     *  a valid XML document.  If the received XMLDataValue is
+     *  null, then create a new one and set its content to
+     *  correspond to the received xmlText.
+     */
+    public XMLDataValue XMLParse(StringDataValue xmlText, XMLDataValue result)
+        throws StandardException
+    {
+        if (result == null)
+            result = new XML();
+
+        if (xmlText.isNull())
+        {
+            result.setToNull();
+            return result;
+        }
+
+        return result.XMLParse(
+            xmlText.getString(), preserveWS, getSqlXmlUtil());
+    }
+
+    /**
+     * Make the call to perform an XMLSERIALIZE operation on the
+     * received XML data value and store the result in the received
+     * StringDataValue (or if it's null, create a new one).
+     *
+     * @param xmlVal XML value to serialize
+     * @param result StringDataValue in which to store the result
+     * @return A serialized (to string) version of this XML object,
+     *  in the form of a StringDataValue object.  
+     */
+    public StringDataValue XMLSerialize(XMLDataValue xmlVal,
+        StringDataValue result) throws StandardException
+    {
+        return xmlVal.XMLSerialize(result, targetTypeId, targetMaxWidth, 
+        		targetCollationType);
+    }
+
+    /**
+     * Make the call to perform an XMLEXISTS operation on the
+     * received XML data value.
+     *
+     * @param xExpr Query expression to be evaluated
+     * @param xmlContext Context node against which to evaluate
+     *  the expression.
+     * @return True if evaluation of the query expression
+     *  against xmlContext returns at least one item; unknown if
+     *  either the xml value is NULL; false otherwise. 
+     */
+    public BooleanDataValue XMLExists(StringDataValue xExpr,
+        XMLDataValue xmlContext) throws StandardException
+    {
+        return xmlContext.XMLExists(getSqlXmlUtil());
+    }
+
+    /**
+     * Make the call to perform an XMLQUERY operation on the
+     * received XML data value and store the result in the
+     * received result holder (or, if it's null, create a
+     * new one).
+     *
+     * @param xExpr Query expression to be evaluated
+     * @param xmlContext Context node against which to evaluate
+     *  the expression.
+     * @param result XMLDataValue in which to store the result
+     * @return The received XMLDataValue with its content set to
+     *  result of evaulating the query expression against xmlContext.
+     *  If the received XMLDataValue is null, then create a new one
+     *  and set its content to correspond to the received xmlText.
+     */
+    public XMLDataValue XMLQuery(StringDataValue xExpr,
+        XMLDataValue xmlContext, XMLDataValue result)
+        throws StandardException
+    {
+        return xmlContext.XMLQuery(result, getSqlXmlUtil());
+    }
+
+    /**
+     * Return the saved object in this.activation that corresponds to
+     * this.sqlxUtilId.  Assumption is that those fields have been
+     * set by the time we get here.
+     */
+    private SqlXmlUtil getSqlXmlUtil()
+        throws StandardException
+    {
+        return (SqlXmlUtil)
+            activation.getPreparedStatement().getSavedObject(sqlXUtilId);
+    }
+
+}
diff --git a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/suites/XMLSuite.java b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/suites/XMLSuite.java
index f9537af9..25b37d4d 100644
--- a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/suites/XMLSuite.java
+++ b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/suites/XMLSuite.java
@@ -50,7 +50,6 @@ public static Test suite()
         suite.addTest(org.apache.derbyTesting.functionTests.tests.lang.XMLTypeAndOpsTest.suite());
         suite.addTest(org.apache.derbyTesting.functionTests.tests.lang.XMLBindingTest.suite());
         suite.addTest(org.apache.derbyTesting.functionTests.tests.lang.XMLMissingClassesTest.suite());
-        suite.addTest(org.apache.derbyTesting.functionTests.tests.lang.XMLConcurrencyTest.suite());
         
         return suite;
     }
diff --git a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/XMLConcurrencyTest.java b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/XMLConcurrencyTest.java
index f579de7e..e69de29b 100644
--- a/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/XMLConcurrencyTest.java
+++ b/db/derby/code/branches/10.8/java/testing/org/apache/derbyTesting/functionTests/tests/lang/XMLConcurrencyTest.java
@@ -1,197 +0,0 @@
-/*
- *
- * Derby - Class org.apache.derbyTesting.functionTests.tests.lang.XMLConcurrencyTest
- *
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
- * either express or implied. See the License for the specific
- * language governing permissions and limitations under the License.
- */
-package org.apache.derbyTesting.functionTests.tests.lang;
-
-import java.sql.Connection;
-import java.sql.PreparedStatement;
-import java.sql.SQLException;
-import java.sql.Statement;
-import junit.framework.Test;
-import junit.framework.TestSuite;
-import org.apache.derbyTesting.junit.BaseJDBCTestCase;
-import org.apache.derbyTesting.junit.CleanDatabaseTestSetup;
-import org.apache.derbyTesting.junit.JDBC;
-import org.apache.derbyTesting.junit.TestConfiguration;
-import org.apache.derbyTesting.junit.XML;
-
-/**
- * Test that XML operators can be invoked by multiple threads concurrently.
- * Regression test case for DERBY-3870.
- */
-public class XMLConcurrencyTest extends BaseJDBCTestCase {
-
-    /** Create an instance of this test case. */
-    public XMLConcurrencyTest(String name) {
-        super(name);
-    }
-
-    /** Create a suite of all test cases in this class. */
-    public static Test suite() {
-        // XML operators are engine functionality, so run this test in
-        // embedded mode only.
-        if (XML.classpathMeetsXMLReqs()) {
-            return new CleanDatabaseTestSetup(
-                TestConfiguration.embeddedSuite(XMLConcurrencyTest.class)) {
-                    protected void decorateSQL(Statement s)
-                            throws SQLException {
-                        createTestTable(s);
-                    }
-                };
-        } else {
-            return new TestSuite("XMLConcurrencyTest - empty");
-        }
-    }
-
-    /**
-     * Start four threads that execute queries that use all the XML operators.
-     * If each thread manages 100 iterations without failing, running
-     * concurrently with the other threads, the test case passes.
-     */
-    public void testConcurrency() throws Exception {
-        WorkerThread[] allThreads = new WorkerThread[4];
-        for (int i = 0; i < allThreads.length; i++) {
-            allThreads[i] = new WorkerThread(openDefaultConnection(), 100);
-            allThreads[i].start();
-        }
-
-        for (int i = 0; i < allThreads.length; i++) {
-            allThreads[i].join();
-            Throwable t = allThreads[i].throwable;
-            if (t != null) {
-                fail("Worker thread failed", t);
-            }
-        }
-    }
-
-    /**
-     * A thread class that does the actual work in the test.
-     */
-    private class WorkerThread extends Thread {
-        final Connection conn;
-        final int iterations;
-        Throwable throwable;
-
-        WorkerThread(Connection conn, int iterations) {
-            this.conn = conn;
-            this.iterations = iterations;
-        }
-
-        public void run() {
-            try {
-                runXMLTest(conn, iterations);
-            } catch (Throwable t) {
-                throwable = t;
-            }
-        }
-    }
-
-    /**
-     * <p>
-     * Create a table with test data. The table contains three columns:
-     * <p>
-     *
-     * <ol>
-     * <li>
-     * An ID column used to identify the rows and to give a stable ordering.
-     * </li>
-     * <li>
-     * A VARCHAR column holding the string representation of an XML document.
-     * </li>
-     * <li>
-     * An XML column holding the XML representation of the document in the
-     * VARCHAR column.
-     * </li>
-     * </ol>
-     */
-    private static void createTestTable(Statement s) throws SQLException {
-        s.executeUpdate("create table t (id int primary key " +
-                "generated always as identity, vc varchar(100), " +
-                "x generated always as " +
-                "(xmlparse(document vc preserve whitespace)))");
-
-        PreparedStatement ins = s.getConnection().prepareStatement(
-                "insert into t(vc) values ?");
-
-        String[] docs = {
-            "<doc><a x='1'>abc</a><b x='2'>def</b></doc>",
-            "<doc><a x='2'>abc</a><b x='3'>def</b></doc>",
-            "<doc/>",
-            "<a/>",
-            null,
-        };
-
-        for (int i = 0; i < docs.length; i++) {
-            ins.setString(1, docs[i]);
-            ins.executeUpdate();
-        }
-
-        ins.close();
-    }
-
-    /**
-     * Do the work for one of the worker threads. Perform queries that use
-     * all the XML operators. Repeat the queries the specified number of times.
-     *
-     * @param conn the connection on which to execute the queries
-     * @param iterations the number of times each query should be executed
-     */
-    private static void runXMLTest(Connection conn, int iterations)
-            throws SQLException {
-        // Query that tests XMLQUERY and XMLSERIALIZE. Count the number of
-        // nodes with an attribute named x with a value greater than 1.
-        PreparedStatement ps1 = conn.prepareStatement(
-            "select id, xmlserialize(" +
-            "xmlquery('count(//*[@x>1])' passing by ref x empty on empty) " +
-            "as varchar(100)) from t order by id");
-
-        String[][] expected1 = {
-            {"1", "1"}, {"2", "2"}, {"3", "0"}, {"4", "0"}, {"5", null}
-        };
-
-        // Query that tests XMLEXISTS. Find all documents containing a "doc"
-        // node with a nested "a" node whose x attribute is 2.
-        PreparedStatement ps2 = conn.prepareStatement(
-            "select id from t where " +
-            "xmlexists('/doc/a[@x=2]' passing by ref x) " +
-            "order by id");
-
-        String expected2 = "2";
-
-        // Query that tests XMLPARSE and XMLSERIALIZE.
-        PreparedStatement ps3 = conn.prepareStatement(
-            "select count(*) from t where " +
-            "xmlserialize(xmlparse(document vc preserve whitespace) " +
-            "as varchar(100)) = " +
-            "xmlserialize(x as varchar(100))");
-
-        String expected3 = "4";
-
-        for (int i = 0; i < iterations; i++) {
-            JDBC.assertFullResultSet(ps1.executeQuery(), expected1);
-            JDBC.assertSingleValueResultSet(ps2.executeQuery(), expected2);
-            JDBC.assertSingleValueResultSet(ps3.executeQuery(), expected3);
-        }
-
-        ps1.close();
-        ps2.close();
-        ps3.close();
-        conn.close();
-    }
-}
