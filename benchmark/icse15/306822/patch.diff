diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/types/SQLClob.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/types/SQLClob.java
index e1d624e1..e420064d 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/types/SQLClob.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/types/SQLClob.java
@@ -24,6 +24,7 @@
 import org.apache.derby.iapi.types.TypeId;
 import org.apache.derby.iapi.error.StandardException;
 
+import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.services.io.StoredFormatIds;
 
 import org.apache.derby.iapi.services.sanity.SanityManager;
@@ -194,6 +195,49 @@ public Timestamp	getTimestamp(java.util.Calendar cal) throws StandardException
 		throw dataTypeConversion("java.sql.Timestamp");
 	}
 
+    
+    /**
+     * Normalization method - this method may be called when putting
+     * a value into a SQLClob, for example, when inserting into a SQLClob
+     * column.  See NormalizeResultSet in execution.
+     * Per the SQL standard ,if the clob column is not big enough to 
+     * hold the value being inserted,truncation error will result
+     * if there are trailing non-blanks. Truncation of trailing blanks
+     * is allowed.
+     * @param desiredType   The type to normalize the source column to
+     * @param sourceValue   The value to normalize
+     *
+     *
+     * @exception StandardException             Thrown for null into
+     *                                          non-nullable column, and for
+     *                                          truncation error
+     */
+
+    public void normalize(
+                DataTypeDescriptor desiredType,
+                DataValueDescriptor sourceValue)
+                    throws StandardException
+    {
+        // if sourceValue is of type clob, and has a stream,
+        // dont materialize it here (as the goal of using a stream is to
+        // not have to materialize whole object in memory in the server), 
+        // but instead truncation checks will be done when data is streamed in.
+        // (see ReaderToUTF8Stream) 
+        // if sourceValue is not a stream, then follow the same
+        // protocol as varchar type for normalization
+        if( sourceValue instanceof SQLClob)
+        {
+            SQLClob clob = (SQLClob)sourceValue;
+            if (clob.stream != null)
+            {
+                copyState(clob);
+                return;
+            }
+        }
+        
+        super.normalize(desiredType,sourceValue);
+    }
+
 	public void setValue(Time theValue, Calendar cal) throws StandardException
 	{
 		throwLangSetMismatch("java.sql.Time");
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedPreparedStatement.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedPreparedStatement.java
index 72e470b9..642a843e 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedPreparedStatement.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedPreparedStatement.java
@@ -603,14 +603,7 @@ public final void setCharacterStream(int parameterIndex,
 		default:
 			throw dataTypeConversion(parameterIndex, "java.io.Reader");
 		}
-		if (length < 0) //we are doing the check here and not in setCharacterStreamInternal becuase setClob needs to pass -1 for length.
-			throw newSQLException(SQLState.NEGATIVE_STREAM_LENGTH);
 
-		if (reader == null)
-		{
-			setNull(parameterIndex, jdbcTypeId);
-			return;
-		}
 
 		setCharacterStreamInternal(parameterIndex, reader, length);
 	}
@@ -619,21 +612,74 @@ protected void setCharacterStreamInternal(int parameterIndex,
 						Reader reader, int length)
 	    throws SQLException
 	{
+        // currently the max number of chars that can be inserted
+        // into a clob field is Integer.MAX_INT ( 2Gb -1)
+        // setClob or setCharacterStream interfaces will eventually call 
+        // this method and in setClob, a long is casted to an int; hence
+        // check for -ve length
+        if (length < 0) 
+          throw newSQLException(SQLState.NEGATIVE_STREAM_LENGTH);
+      
 		checkStatus();
 
 		int jdbcTypeId = getParameterJDBCType(parameterIndex);
 
 
+        if (reader == null)
+        {
+            setNull(parameterIndex, jdbcTypeId);
+            return;
+        }
+
 		try {
-			ParameterValueSet pvs = getParms();
 
 			LimitReader limitIn = new LimitReader(reader);
-			if (length != -1)
-				limitIn.setLimit(length);
-			ReaderToUTF8Stream utfIn = new ReaderToUTF8Stream(limitIn);
+			ParameterValueSet pvs = getParms();
+            int usableLength = length;
+            ReaderToUTF8Stream utfIn = null;
+
+            // Currently long varchar does not allow for truncation of trailing
+            // blanks.  
+            // For char and varchar types, current mechanism of materializing
+            // when using streams seems fine given their  max limits.
+            // This change is fix for DERBY-352: Insert of clobs using streams
+            // should not materialize the entire stream into memory
+            // In case of clobs, the truncation of trailing blanks is factored
+            // in when reading from the stream without materializing the entire
+            // stream, and so the special casing for clob below.
+            if (jdbcTypeId == Types.CLOB) 
+            {
+                // Need column width to figure out if truncation is needed 
+                DataTypeDescriptor dtd[] = preparedStatement
+                        .getParameterTypes();
+                int colWidth = dtd[parameterIndex - 1].getMaximumWidth();
+
+                // It is possible that the length of the stream passed in is
+                // greater than the column width, in which case the data from
+                // the stream needs to be truncated.
+                // usableLength is the length of the data from stream that can
+                // be inserted which is min(colWidth,length) provided 
+                // length - colWidth has trailing blanks only
+                if (colWidth < length)
+                    usableLength = colWidth;
+                
+                // keep information with the stream about how much data needs 
+                // to be truncated, and colWidth info to give proper truncation
+                // message
+                utfIn = new ReaderToUTF8Stream(
+                            limitIn, colWidth, length - usableLength);
+            }
+            else
+            {
+                utfIn = new ReaderToUTF8Stream(
+                            limitIn,usableLength,length - usableLength);
+            }
+
+            limitIn.setLimit(usableLength);
 
 			/* JDBC is one-based, DBMS is zero-based */
-			pvs.getParameterForSet(parameterIndex - 1).setValue(utfIn, length);
+            pvs.getParameterForSet(
+                parameterIndex - 1).setValue(utfIn,usableLength);
 
 		} catch (StandardException t) {
 			throw EmbedResultSet.noStateChangeException(t);
@@ -1144,7 +1190,23 @@ public void setClob (int i, Clob x)
 		if (x == null)
 			setNull(i, Types.CLOB);
 		else
-			setCharacterStreamInternal(i, x.getCharacterStream(), -1);
+        {
+            // 1. max number of characters that can be inserted into a clob column
+            // is 2Gb-1 which is Integer.MAX_INT.
+            // This means that we do not allow any inserts of clobs where
+            // clob.length() > Integer.MAX_INT. For now, we cast the x.length()
+            // to int as a result. This will work ok for valid clob values that
+            // derby supports. If we ever decide to increase these limits for clobs, in that
+            // case the cast of x.Length() to int would not be appropriate.
+            // 2. Note, x.length() needs to be called before retrieving the
+            // stream using x.getCharacterStream() because EmbedClob.length()
+            // will read from the stream and drain the stream. 
+            // Hence the need to declare this local variable - streamLength
+            int streamLength = (int) x.length();
+
+            setCharacterStreamInternal(i, x.getCharacterStream(), streamLength);
+        }
+        
 	}
 
 	/**
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java
index fd606163..b025921e 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/EmbedResultSet.java
@@ -2566,14 +2566,6 @@ public void updateCharacterStream(int columnIndex, java.io.Reader x,
 			default:
 				throw dataTypeConversion(columnIndex, "java.io.Reader");
 		}
-		if (length < 0) //we are doing the check here and not in updateCharacterStreamInternal becuase updateClob needs to pass -1 for length.
-			throw newSQLException(SQLState.NEGATIVE_STREAM_LENGTH);
-
-		if (x == null)
-		{
-			updateNull(columnIndex);
-			return;
-		}
 		updateCharacterStreamInternal(columnIndex, x, length, "updateCharacterStream");
 	}
 
@@ -2582,11 +2574,63 @@ protected void updateCharacterStreamInternal(int columnIndex,
 	    throws SQLException
 	{
 		try {
+
+            // currently the max number of chars that is allowed in update
+            // via updateCharacterStream or updateClob interface
+            // is Integer.MAX_INT ( 2Gb -1) for clobs.
+            // check for -ve length here 
+            if (length < 0) 
+                throw newSQLException(SQLState.NEGATIVE_STREAM_LENGTH);
+
+            if (reader == null)
+            {
+                updateNull(columnIndex);
+                return;
+            }
+
 			LimitReader limitIn = new LimitReader(reader);
-			if (length != -1)
-				limitIn.setLimit(length);
-			ReaderToUTF8Stream utfIn = new ReaderToUTF8Stream(limitIn);
-			getDVDforColumnToBeUpdated(columnIndex, updateMethodName).setValue(utfIn, length);
+            
+            // length is +ve. at this point, all checks for negative
+            // length has already been done
+            int usableLength = length;
+            ReaderToUTF8Stream utfIn = null;
+
+            // Currently long varchar does not allow for truncation of
+            // trailing blanks.  For char and varchar types, current mechanism 
+            // of materializing when using streams seems fine given their max
+            // limits. This change is fix for DERBY-352: Insert of clobs using
+            // streams should not materialize the entire stream into memory
+            // In case of clobs, the truncation of trailing blanks is
+            // factored in when reading from the stream without materializing
+            // the entire stream, and so the special casing for clob below.
+            if (getColumnType(columnIndex) == Types.CLOB) {
+                // Need column width to figure out if truncation is
+                // needed
+                int colWidth = resultDescription.getColumnDescriptor(
+                        columnIndex).getType().getMaximumWidth();
+
+                // It is possible that the length of the stream passed
+                // in is greater than the column width, in which case the data
+                // from the stream needs to be truncated.
+                // usableLength is the length of the data from stream
+                // that can be used which is min(colWidth,length) provided
+                // length - colWidth has trailing blanks only
+                if (colWidth < length)
+                    usableLength = colWidth;
+
+                // keep information with the stream about how much data
+                // needs to be truncated, and colWidth info to give proper
+                // truncation message
+                utfIn = new ReaderToUTF8Stream(
+                            limitIn, colWidth,     length - usableLength);
+            } else {
+                utfIn = new ReaderToUTF8Stream(
+                            limitIn, usableLength, length - usableLength);
+            }
+
+            limitIn.setLimit(usableLength);
+            getDVDforColumnToBeUpdated(columnIndex, updateMethodName).setValue(
+                    utfIn, length);
 		} catch (StandardException t) {
 			throw noStateChangeException(t);
 		}
@@ -3556,9 +3600,32 @@ public void updateClob(int columnIndex, Clob x) throws SQLException {
             throw dataTypeConversion(columnIndex, "java.sql.Clob");
 
         if (x == null)
+        {
             updateNull(columnIndex);
+        }
         else
-            updateCharacterStreamInternal(columnIndex, x.getCharacterStream(), -1, "updateClob");
+        {
+
+            // 1. max number of characters that can be updated into a clob 
+            // column is 2Gb-1 which is Integer.MAX_INT.
+            // This means that we do not allow any updates of clobs where
+            // clob.length() > Integer.MAX_INT. For now, we cast the x.length()
+            // to int as a result. This will work ok for valid clob values that
+            // derby supports. If we ever decide to increase these limits for 
+            // clobs, in that case the cast of x.Length() to int would not be 
+            // appropriate.
+            //
+            // 2. Note, x.length() needs to be called before retrieving the
+            // stream using x.getCharacterStream() because EmbedClob.length()
+            // will read from the stream and drain the stream.
+            // Hence the need to declare this local variable to store the 
+            // length.  The cast from long to int, can make length -ve.  The 
+            // length will be checked later in updateCharacterStreamInternal
+            int length = (int)x.length();
+
+            updateCharacterStreamInternal(
+                columnIndex, x.getCharacterStream(),length, "updateClob");
+        }
 	}
 
 	/**
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/ReaderToUTF8Stream.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/ReaderToUTF8Stream.java
index e22030d2..3bb308e8 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/ReaderToUTF8Stream.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/jdbc/ReaderToUTF8Stream.java
@@ -28,6 +28,7 @@
 import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.services.i18n.MessageService;
 import org.apache.derby.iapi.services.io.LimitReader;
+import org.apache.derby.iapi.types.TypeId;
 
 /**
 	Converts a java.io.Reader to the on-disk UTF8 format used by Cloudscape.
@@ -47,11 +48,25 @@
     // and converted to UTF8 format
     private final static int BUFSIZE = 32768;
 
-	ReaderToUTF8Stream(LimitReader reader)
+    // Number of characters to truncate from this stream
+    // The SQL standard allows for truncation of trailing spaces 
+    // for clobs,varchar,char.
+    private int charsToTruncate;
+    private final char SPACE =' ';
+    
+    // this stream needs to fit into a column of colWidth
+    // if truncation error happens ,then the error message includes 
+    // information about the column width which is why this variable
+    // is needed.
+    private int colWidth;  
+    
+	ReaderToUTF8Stream(LimitReader reader,int length,int numCharsToTruncate)
 	{
 		this.reader = reader;
 		buffer = new byte[BUFSIZE];
 		blen = -1;
+        this.charsToTruncate = numCharsToTruncate;
+        this.colWidth = length;
 	}
 
 	public int read() throws IOException {
@@ -90,7 +105,8 @@ public int read(byte b[], int off, int len) throws IOException {
 			{
 				if (eof)
 				{
-					return readCount == 0 ? readCount : -1;
+                    // return actual number of bytes read into b[]
+					return readCount > 0 ? readCount : -1;
 				}
 				fillBuffer(0);
 				continue;
@@ -103,6 +119,7 @@ public int read(byte b[], int off, int len) throws IOException {
 			boff += copyBytes;
 			len -= copyBytes;
 			readCount += copyBytes;
+            off += copyBytes;
 
 		}
 
@@ -157,18 +174,51 @@ else if (c > 0x07FF)
 	*/
 	private void checkSufficientData() throws IOException
 	{
-		int remainingBytes = reader.clearLimit();
-
+		// now that we finished reading from the stream; the amount
+        // of data that we can insert,start check for trailing spaces
+        if (charsToTruncate > 0)
+        {
+            reader.setLimit(charsToTruncate);
+            int c = 0;
+            do
+            {
+                c = reader.read();
+                
+                if (c < 0)
+                {
+                    break;
+                }
+                else if (c != SPACE)
+                {
+                    // throw truncation error, wont happen here for any other 
+                    // type except for clob
+                    // hence using TypeId.CLOB_NAME to avoid having to store
+                    // the type information along with this stream.
+                    throw new IOException(
+                        MessageService.getTextMessage(
+                            SQLState.LANG_STRING_TRUNCATION,
+                            TypeId.CLOB_NAME, 
+                            "XXXX", 
+                            String.valueOf(colWidth)));
+                }
+            }
+            while (c == SPACE);
+        }
+
+        int remainingBytes = reader.clearLimit();
 		if (remainingBytes > 0)
 			throw new IOException(MessageService.getTextMessage(SQLState.SET_STREAM_INEXACT_LENGTH_DATA));
 
 		// if we had a limit try reading one more character.
-		// JDBC 3.0 states the stream muct have the correct number of characters in it.
+		// JDBC 3.0 states the stream muct have the correct number of 
+        // characters in it.
+
 		if (remainingBytes == 0) {
 			int c;
 			try
 			{
 				c = reader.read();
+               
 			}
 			catch (IOException ioe) {
 				c = -1;
@@ -214,5 +264,5 @@ public final int available()
        // on this stream
        return (BUFSIZE > remainingBytes ? remainingBytes : BUFSIZE);
     }
-}
+  }
 
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/characterStreams.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/characterStreams.java
index 2832e9b4..1b2e849c 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/characterStreams.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/jdbcapi/characterStreams.java
@@ -62,7 +62,13 @@ public static void main(String[] args) {
 
 			conn.createStatement().executeUpdate("create table charstream(id int GENERATED ALWAYS AS IDENTITY primary key, c char(25), vc varchar(32532), lvc long varchar)");
 
-			setStreams(conn);
+			setStreams(conn,"LONG VARCHAR");
+
+            System.out.println("run test with clob column");
+            conn.createStatement().executeUpdate("drop table charstream");
+            conn.createStatement().executeUpdate("create table charstream(id int GENERATED ALWAYS AS IDENTITY primary key, c char(25), vc varchar(32532), lvc clob)");
+            
+            setStreams(conn,"CLOB");
 
 			conn.close();
 
@@ -98,7 +104,7 @@ private static void expectedException(SQLException sqle) {
             sqle = sqle.getNextException();
         }
     }
-	static void setStreams(Connection conn) throws Exception {
+	static void setStreams(Connection conn,String colType) throws Exception {
 
 		ResultSet rs;
 
@@ -149,8 +155,8 @@ static void setStreams(Connection conn) throws Exception {
 		psi.setString(1, null);
 		psi.setString(2, null);
 		psi.setString(3, null);
-		// test setAsciiStream into LONG VARCHAR
-		System.out.println("\nTest setAsciiStream into LONG VARCHAR");
+		// test setAsciiStream into lvc column
+		System.out.println("\nTest setAsciiStream into "+colType);
 		maxid = getMaxId(conn);
 		setAscii(psi, 3);
 		psq.setInt(1, maxid);
@@ -193,7 +199,7 @@ static void setStreams(Connection conn) throws Exception {
 		psi.setString(3, null);
 
 		// test setCharacterStream into LONG VARCHAR
-		System.out.println("\nTest setCharacterStream into LONG VARCHAR");
+		System.out.println("\nTest setCharacterStream into "+colType);
 		maxid = getMaxId(conn);
 		setCharacter(psi, 3);
 		psq.setInt(1, maxid);
@@ -206,16 +212,16 @@ static void setStreams(Connection conn) throws Exception {
 
 		// now insert long values using streams and check them programatically.
 		System.out.println("setAsciiStream(LONG ASCII STREAMS)");
-		checkAsciiStreams(psDel, psi, psq2, 18, 104, 67);
-		checkAsciiStreams(psDel, psi, psq2, 25, 16732, 14563);
-		checkAsciiStreams(psDel, psi, psq2, 1, 32433, 32673);
-		checkAsciiStreams(psDel, psi, psq2, 0, 32532, 32700);
+		checkAsciiStreams(psDel, psi, psq2, 18, 104, 67,colType);
+		checkAsciiStreams(psDel, psi, psq2, 25, 16732, 14563,colType);
+		checkAsciiStreams(psDel, psi, psq2, 1, 32433, 32673,colType);
+		checkAsciiStreams(psDel, psi, psq2, 0, 32532, 32700,colType);
 
 		System.out.println("setCharacterStream(LONG CHARACTER STREAMS WITH UNICODE)");
-		checkCharacterStreams(psDel, psi, psq2, 14, 93, 55);
-		checkCharacterStreams(psDel, psi, psq2, 25, 19332, 18733);
-		checkCharacterStreams(psDel, psi, psq2, 1, 32433, 32673);
-		checkCharacterStreams(psDel, psi, psq2, 0, 32532, 32700);
+		checkCharacterStreams(psDel, psi, psq2, 14, 93, 55,colType);
+		checkCharacterStreams(psDel, psi, psq2, 25, 19332, 18733,colType);
+		checkCharacterStreams(psDel, psi, psq2, 1, 32433, 32673,colType);
+		checkCharacterStreams(psDel, psi, psq2, 0, 32532, 32700,colType);
 	}
 
 	private static int getMaxId(Connection conn) throws SQLException {
@@ -408,7 +414,7 @@ private static void showCharacterStreamBlock(java.io.Reader r) throws java.io.IO
 	}
 
 	private static void checkAsciiStreams(PreparedStatement psDel, PreparedStatement psi, PreparedStatement psq2,
-				int cl, int vcl, int lvcl)
+				int cl, int vcl, int lvcl,String colType)
 				throws SQLException, java.io.IOException {
 
 		psDel.executeUpdate();
@@ -433,7 +439,7 @@ private static void checkAsciiStreams(PreparedStatement psDel, PreparedStatement
 		System.out.println("DONE");
 
 		is = rs.getAsciiStream(3);
-		System.out.print("AS-LONG VARCHAR-" + lvcl + " ");
+		System.out.print("AS-"+colType+"-" + lvcl + " ");
 		c3AsciiStream.check(is, lvcl, -1);
 		System.out.println("DONE");
 
@@ -453,7 +459,7 @@ private static void checkAsciiStreams(PreparedStatement psDel, PreparedStatement
 		System.out.println("DONE");
 
 		r = rs.getCharacterStream(3);
-		System.out.print("CS-LONG VARCHAR-" + lvcl + " ");
+		System.out.print("CS-"+colType+"-" + lvcl + " ");
 		c3AsciiStream.check(r, lvcl, -1);
 		System.out.println("DONE");
 
@@ -475,7 +481,7 @@ private static void checkAsciiStreams(PreparedStatement psDel, PreparedStatement
 		System.out.println("DONE");
 
 		r = new java.io.StringReader(rs.getString(3));
-		System.out.print("ST-LONG VARCHAR-" + lvcl + " ");
+		System.out.print("ST-"+colType+"-" + lvcl + " ");
 		c3AsciiStream.check(r, lvcl, -1);
 		System.out.println("DONE");
 
@@ -483,7 +489,7 @@ private static void checkAsciiStreams(PreparedStatement psDel, PreparedStatement
 		}
 
 	private static void checkCharacterStreams(PreparedStatement psDel, PreparedStatement psi, PreparedStatement psq2,
-				int cl, int vcl, int lvcl)
+				int cl, int vcl, int lvcl,String colType)
 				throws SQLException, java.io.IOException {
 
 		psDel.executeUpdate();
@@ -507,7 +513,7 @@ private static void checkCharacterStreams(PreparedStatement psDel, PreparedState
 		System.out.println("DONE");
 
 		is = rs.getAsciiStream(3);
-		System.out.print("AS-LONG VARCHAR-" + lvcl + " ");
+		System.out.print("AS-"+colType+"-" + lvcl + " ");
 		c3Reader.check(is, lvcl, -1);
 		System.out.println("DONE");
 
@@ -527,7 +533,7 @@ private static void checkCharacterStreams(PreparedStatement psDel, PreparedState
 		System.out.println("DONE");
 
 		r = rs.getCharacterStream(3);
-		System.out.print("CS-LONG VARCHAR-" + lvcl + " ");
+		System.out.print("CS-"+colType+"-" + lvcl + " ");
 		c3Reader.check(r, lvcl, -1);
 		System.out.println("DONE");
 
@@ -551,7 +557,7 @@ private static void checkCharacterStreams(PreparedStatement psDel, PreparedState
 
 		suv = rs.getString(3);
 		r = new java.io.StringReader(suv);
-		System.out.print("ST-LONG VARCHAR-" + lvcl + " ");
+		System.out.print("ST-"+colType+"-" + lvcl + " ");
 		c3Reader.check(r, lvcl, -1);
 		System.out.println("DONE");
 
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/largedata/LobLimits.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/largedata/LobLimits.java
index e69de29b..87d47618 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/largedata/LobLimits.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/largedata/LobLimits.java
@@ -0,0 +1,1346 @@
+/*
+
+Derby - Class org.apache.derbyTesting.functionTests.tests.largedata.LobLimits
+
+Copyright 2003, 2005 The Apache Software Foundation or its licensors, as applicable.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+*/
+
+package org.apache.derbyTesting.functionTests.tests.largedata;
+
+import java.sql.*;
+import java.io.*;
+
+import org.apache.derby.tools.ij;
+import org.apache.derby.tools.JDBCDisplayUtil;
+
+/**
+* This test is part of the "largedata" suite because this test tests data for
+* lobs to the limits ( ie blob and clob can be 2G-1 maximum) and so this test
+* may take considerable disk space as well as time to run. Hence it is not part
+* of the derbyall suite but should ideally be run at some intervals to test if
+* no regression has occurred.
+*/
+
+public class LobLimits {
+
+   static boolean trace = false;
+   static final int _2GB = 2 * 1024 * 1024* 1024 - 1;
+   static final int _100MB = 100 * 1024 * 1024;
+   static final int MORE_DATA_THAN_COL_WIDTH= (_100MB)+1;
+   static final int NUM_TRAILING_SPACES = 33*1024;
+   
+   static PreparedStatement insertBlob = null;
+   static PreparedStatement selectBlob = null;
+   static PreparedStatement insertClob = null;
+   static PreparedStatement selectClob = null;
+   static PreparedStatement deleteBlob = null;
+   static PreparedStatement deleteClob = null;
+   static PreparedStatement insertBlob2 = null;
+   static PreparedStatement selectBlob2 = null;
+   static PreparedStatement insertClob2 = null;
+   static PreparedStatement selectClob2 = null;
+   static PreparedStatement deleteBlob2 = null;
+   static PreparedStatement deleteClob2 = null;
+
+   static final String DATAFILE = "byteLobLimits.dat";
+
+   static final String CHARDATAFILE = "charLobLimits.txt";
+
+   /**
+    * setup prepared statements and schema for the tests
+    * @param conn
+    * @throws SQLException
+    */
+   private void setup(Connection conn) throws SQLException {
+       System.out.println("-----------------------------------");
+       System.out.println(" START setup");
+
+       conn.setAutoCommit(true);
+       // Create a test table.
+       Statement s = conn.createStatement();
+       try {
+           s.execute("DROP TABLE BLOBTBL");
+       } catch (Exception e) {
+       }
+       try {
+           s.execute("DROP TABLE CLOBTBL");
+       } catch (Exception e) {
+       }
+       try {
+           s.execute("DROP TABLE BLOBTBL2");
+       } catch (Exception e) {
+       }
+       try {
+           s.execute("DROP TABLE CLOBTBL2");
+       } catch (Exception e) {
+       }
+
+       s.execute("CREATE TABLE BLOBTBL (ID INT NOT NULL PRIMARY KEY, "
+               + "POS BIGINT, DLEN BIGINT, CONTENT BLOB(2G))");
+
+       insertBlob = conn
+               .prepareStatement("INSERT INTO BLOBTBL values (?,?,?,?)");
+
+       s.execute("CREATE TABLE CLOBTBL (ID INT NOT NULL PRIMARY KEY,"
+               + "POS BIGINT, DLEN BIGINT, CONTENT CLOB(2G))");
+
+       insertBlob = conn
+               .prepareStatement("INSERT INTO BLOBTBL values (?,?,?,?)");
+       selectBlob = conn
+               .prepareStatement("SELECT CONTENT,DLEN FROM BLOBTBL WHERE ID = ?");
+
+       insertClob = conn
+               .prepareStatement("INSERT INTO CLOBTBL values (?,?,?,?)");
+
+       selectClob = conn
+               .prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL WHERE ID = ?");
+
+       deleteBlob = conn.prepareStatement("DELETE FROM BLOBTBL");
+       deleteClob = conn.prepareStatement("DELETE  from CLOBTBL");
+
+       s.execute("CREATE TABLE BLOBTBL2 (ID INT NOT NULL PRIMARY KEY, "
+               + "POS BIGINT, CONTENT BLOB("+_100MB+"),DLEN BIGINT)");
+
+       insertBlob2 = conn
+               .prepareStatement("INSERT INTO BLOBTBL2 values (?,?,?,?)");
+
+       // Please dont change the clob column width,since tests use this width to 
+       // test for truncation of trailing spaces.
+       s.execute("CREATE TABLE CLOBTBL2 (ID INT NOT NULL PRIMARY KEY,"
+               + "POS BIGINT, CONTENT CLOB("+_100MB+"), DLEN BIGINT)");
+
+       insertBlob2 = conn
+               .prepareStatement("INSERT INTO BLOBTBL2 values (?,?,?,?)");
+       selectBlob2 = conn
+               .prepareStatement("SELECT CONTENT,DLEN FROM BLOBTBL2 WHERE ID = ?");
+
+       insertClob2 = conn
+               .prepareStatement("INSERT INTO CLOBTBL2 values (?,?,?,?)");
+
+       selectClob2 = conn
+               .prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL2 WHERE ID = ?");
+       System.out.println("-----------------------------------");
+       System.out.println(" END setup");
+
+       deleteBlob2 = conn.prepareStatement("DELETE FROM BLOBTBL2");
+       deleteClob2 = conn.prepareStatement("DELETE  from CLOBTBL2");
+       System.out.println("-----------------------------------");
+       System.out.println(" END setup");
+
+   }
+
+   /**
+    * Create an instance of this class and do the test.
+    */
+   public static void main(String[] args) {
+       //trace = Boolean.getBoolean("trace");
+       new LobLimits().runTests(args);
+
+   }
+
+   /**
+    * Create a JDBC connection using the arguments passed in from the harness,
+    * and then run the LOB tests.
+    * 
+    * @param args
+    *            Arguments from the harness.
+    */
+   public void runTests(String[] args) {
+       Connection conn = null;
+       try {
+
+           // use the ij utility to read the property file and
+           // make the initial connection.
+           ij.getPropertyArg(args);
+           conn = ij.startJBMS();
+
+           // do the initial setup,drop and create tables
+           // prepare stmts
+           setup(conn);
+
+           conn.setAutoCommit(false);
+
+           clobTests(conn);
+           blobTests(conn);
+           //cleanup
+           cleanup(conn);
+       } catch (Exception e) {
+           System.out.println("FAIL -- Unexpected exception:");
+           e.printStackTrace(System.out);
+       }
+   }
+
+   /**
+    * Close all prepared statements and connection
+    * @param conn
+    * @throws Exception
+    */
+   private void cleanup(Connection conn) throws Exception {
+       insertBlob.close();
+       selectBlob.close();
+       selectClob.close();
+       insertClob.close();
+       deleteClob.close();
+       deleteBlob.close();
+       insertBlob2.close();
+       selectBlob2.close();
+       selectClob2.close();
+       insertClob2.close();
+       deleteBlob2.close();
+       deleteClob2.close();
+       conn.close();
+       new File(DATAFILE).delete();
+       new File(CHARDATAFILE).delete();
+   }
+
+   /**
+    * tests specific for blobs
+    * @param conn
+    * @throws Exception
+    */
+   private static void blobTests(Connection conn) throws Exception {
+
+       try {
+           // Test - 2Gb blob ( actually it is 2gb -1)
+           // Note with setBinaryStream interface the maximum size for the
+           // stream, can be max value for an int.
+           // Also note, that lobs in derby currently  supports
+           // maximum size of 2gb -1
+
+           // first do insert blob of 2g, 2 rows
+           insertBlob_SetBinaryStream("BlobTest #1", conn, insertBlob, _2GB,
+                   0, 2, _2GB);
+           // do a select to see if the inserts in test above went ok
+           selectBlob("BlobTest #2", conn, selectBlob, _2GB, 0, 1);
+           selectBlob("BlobTest #3", conn, selectBlob, _2GB, 1, 1);
+           
+           // now do a select of one of the 2gb rows and update another 2g row 
+           // using the setBlob api, updated blob is of length 2gb
+           // setBlob,materializes, so disable testfor now.
+           // Bug entry -DERBY-599
+           //selectUpdateBlob("BlobTest #4",conn,selectBlob,_2GB,0,1,1);
+           
+           // Test - generate random data, write to a file, use it to insert
+           // data into blob and then read back and compare if all is ok
+           // currently in fvt ( derbyall), tests check for substrings etc and 
+           // for small amounts of data.  This test will test for 100mb of blob data
+
+           FileOutputStream fos = new FileOutputStream(DATAFILE);
+           RandomByteStream r = new RandomByteStream(new java.util.Random(),
+                   _100MB);
+           // write in chunks of 32k buffer
+           byte[] buffer = new byte[32 * 1024];
+           int count = 0;
+           
+           while((count=r.read(buffer))>=0)
+               fos.write(buffer,0,count);
+
+           fos.flush();
+           fos.close();
+
+           insertBlob2("BlobTest #5.1 ", conn, insertBlob2, _100MB, 0, 1,
+                   _100MB, DATAFILE);
+           selectBlob2("BlobTest #5.2 ", conn, selectBlob2, _100MB, 0, 1,
+                   DATAFILE);
+           // update the 2gb row in blobtbl with the 100mb data and compare if the update
+           // went ok. wont work now, test disabled currently
+           // till DERBY599 is fixed
+           //selectUpdateBlob2("BlobTest #6",conn,selectBlob2,selectBlob,_100MB,0,1,1,DATAFILE);
+                       
+           deleteTable(conn, deleteBlob2, 1);
+           
+       } catch (Exception e) {
+           System.out.println("FAIL -- Unexpected exception:");
+           e.printStackTrace(System.out);
+       }
+
+       conn.commit();
+
+       deleteTable(conn, deleteBlob, 2);
+
+       // ADD  NEW TESTS HERE
+   }
+
+   /**
+    * tests using clobs
+    * @param conn
+    * @throws Exception
+    */
+   private static void clobTests(Connection conn) throws Exception {
+       try {
+           // Test - 2Gb blob
+           // Note with setCharacterStream interface the maximum size for the
+           // stream has to be max value for a int which is (2GB -1 )
+           // first do insert clob of 2g, 2 rows
+           insertClob_SetCharacterStream("ClobTest #1", conn, insertClob,
+                   _2GB, 0, 2, _2GB);
+           // do a select to see if the inserts in test above went ok
+           selectClob("ClobTest #2", conn, selectClob, _2GB, 0, 1);
+           selectClob("ClobTest #3", conn, selectClob, _2GB, 0, 1);
+           // do a select and then update a row of 2gb size: uses getClob
+           selectUpdateClob("ClobTest #4",conn,selectClob,_2GB,0,1,1);
+           
+
+           // Test - generate random data, write to a file, use it to insert
+           // data into clob and then read back and compare if all is ok
+           // currently in fvt ( derbyall), tests check for substrings etc and 
+           // for small amounts of data.  This test will test for 100mb of clob data
+           writeToFile(CHARDATAFILE,new RandomCharReader(new java.util.Random(),_100MB));
+           insertClob2("ClobTest #5.1 ", conn, insertClob2, _100MB, 0, 1,
+                   _100MB, CHARDATAFILE);
+           selectClob2("ClobTest #5.2 ", conn, selectClob2, _100MB, 0, 1,
+                   CHARDATAFILE);
+
+           // Disabled for now, this will materialize, will open 
+           // jira for it.
+           //updateClob2("ClobTest #8.1",conn,selectClob,_100MB,0,0,10,1,CHARDATAFILE);
+
+           // update the 2gb row in clobtbl with the 100mb data and compare if the update
+           // went ok.
+           selectUpdateClob2("ClobTest #8.2",conn,selectClob2,selectClob,_100MB,0,1,1,CHARDATAFILE);
+
+           // test for trailing space truncation
+           // insert 100mb+33k of data which has 33k of trailing space,
+           // into a column of 100mb
+           // insert should be successful, select should retrieve 100mb of data
+           
+           // Generate random data and write to a file, this file will be used
+           // in the verification process after inserts and updates.
+           writeToFile(CHARDATAFILE,new RandomCharReader(new java.util.Random(),
+                   (NUM_TRAILING_SPACES +_100MB),NUM_TRAILING_SPACES));
+           insertClob2("ClobTest #6.1 ", conn, insertClob2,_100MB, 3, 1,
+                   (NUM_TRAILING_SPACES +_100MB), CHARDATAFILE);
+           // select will retrieve data and verify the data inserted. 
+           selectClob2("ClobTest #6.2 ", conn, selectClob2, _100MB, 3, 1,
+                   CHARDATAFILE);
+
+           negativeSpaceTruncationTest("ClobTest #7",conn);
+           
+           // Test - for stream contains a trailing non-space character
+           // insert should throw an error
+           writeToFile(CHARDATAFILE,new RandomCharReader(new java.util.Random(),MORE_DATA_THAN_COL_WIDTH));
+           try
+           {
+               insertClob2("ClobTest #9.1 ", conn, insertClob2,MORE_DATA_THAN_COL_WIDTH, 4, 1,
+                       MORE_DATA_THAN_COL_WIDTH, CHARDATAFILE);
+           }catch(SQLException sqle)
+           {
+               System.out.println("NEGATIVE TEST - Expected Exception: truncation of non-blanks not allowed");
+               expectedException(sqle);
+           }
+           // no row must be retrieved.
+           selectClob2("ClobTest #9.2 ", conn, selectClob2, _100MB, 4, 0,
+                   CHARDATAFILE);
+
+           try
+           {
+               insertClob2("ClobTest #10 ", conn, insertClob2,MORE_DATA_THAN_COL_WIDTH, 4, 1,
+                       MORE_DATA_THAN_COL_WIDTH +1 , CHARDATAFILE);
+           }catch(SQLException sqle)
+           {
+               System.out.println("NEGATIVE TEST - Expected Exception: truncation of non-blanks not allowed and"+
+                       " stream length is one greater than actual length of the stream ");
+               expectedException(sqle);
+           }
+
+           try
+           {
+               insertClob2("ClobTest #11 ", conn, insertClob2,MORE_DATA_THAN_COL_WIDTH, 4, 1,
+                       MORE_DATA_THAN_COL_WIDTH -1 , CHARDATAFILE);
+           }catch(SQLException sqle)
+           {
+               System.out.println("NEGATIVE TEST - Expected Exception: truncation of non-blanks not allowed and"+
+                       " stream length is one less than actual length of the stream ");
+               expectedException(sqle);
+           }
+           deleteTable(conn, deleteClob2, 2);
+       } catch (Exception e) {
+           System.out.println("FAIL -- Unexpected exception:");
+           e.printStackTrace(System.out);
+       }
+
+       try {
+           // give -ve streamlength
+           insertClob_SetCharacterStream("ClobTest #12.1", conn, insertClob,
+                   _100MB, 4, 1, -1);
+       } catch (SQLException sqle) {
+           System.out.println("NEGATIVE TEST - Expected Exception:");
+           expectedException(sqle);
+       }
+
+       selectClob("ClobTest #12.2", conn, selectClob,_100MB, 4, 0);
+
+       deleteTable(conn, deleteClob, 2);
+       
+       // ADD NEW TESTS HERE
+   }
+
+   private static void negativeSpaceTruncationTest(String msg,Connection conn)
+       throws Exception
+   {
+       // Negative test, stream has trailing spaces but the stream length is one 
+       // more than the actual length of the stream
+       try
+       {
+           insertClob2(msg, conn, insertClob2,_100MB, 4, 1,
+               (NUM_TRAILING_SPACES +_100MB - 1), CHARDATAFILE);
+       }catch(SQLException sqle)
+       {
+           System.out.println("EXPECTED EXCEPTION - stream has trailing spaces,but stream "+
+                   " length is 1 less than actual length of stream");
+           expectedException(sqle);
+       }
+
+       try
+       {
+           insertClob2(msg, conn, insertClob2,_100MB, 5, 1,
+               (NUM_TRAILING_SPACES +_100MB + 1), CHARDATAFILE);
+       }catch(SQLException sqle)
+       {
+           System.out.println("EXPECTED EXCEPTION - stream has trailing spaces,but stream "+
+                   " length is 1 greater than actual length of stream");
+           expectedException(sqle);
+       }
+   }
+   
+ 
+   /**
+    * insert blob
+    * @param bloblen   length of blob to insert
+    * @param start     start id value for insert
+    * @param rows      insert rows number of rows
+    * @param streamLength  stream length passed to setBinaryStream(,,length)
+    */
+   private static void insertBlob_SetBinaryStream(String testId,
+           Connection conn, PreparedStatement ps, int bloblen, int start,
+           int rows, int streamLength) throws SQLException {
+       System.out.println("========================================");
+       System.out.println("START " + testId + "insertBlob of size = "
+               + bloblen);
+       long ST = 0;
+       if (trace)
+           ST = System.currentTimeMillis();
+
+       int count = 0;
+       java.util.Random random = new java.util.Random();
+       for (int i = start; i < start + rows; i++) {
+           ps.setInt(1, i);
+           ps.setInt(2, 0);
+           ps.setLong(3, bloblen);
+           ps.setBinaryStream(4, new RandomByteStream(random, bloblen),
+                   streamLength);
+           count += ps.executeUpdate();
+       }
+       conn.commit();
+       if (trace) {
+           System.out.println("Insert Blob (" + bloblen + ")" + " rows= "
+                   + count + " = " + (long) (System.currentTimeMillis() - ST));
+
+       }
+       verifyTest(count, rows, " Rows inserted with blob of size (" + bloblen
+               + ") =");
+       System.out.println("========================================");
+
+   }
+
+   /**
+    * select from blob table (BLOBTBL)
+    * @param bloblen  select expects to retrieve a blob of this length
+    * @param id       id of the row to retrieve
+    * @param expectedRows  number of rows expected to match id
+    */
+   private static void selectBlob(String testId, Connection conn,
+           PreparedStatement ps, int bloblen, int id, int expectedRows)
+           throws SQLException {
+       System.out.println("========================================");
+       System.out.println("START " + testId + " - SELECT BLOB of size = "
+               + bloblen);
+
+       long ST = 0;
+       ResultSet rs = null;
+
+       if (trace)
+           ST = System.currentTimeMillis();
+
+       int count = 0;
+       ps.setInt(1, id);
+       rs = ps.executeQuery();
+
+       while (rs.next()) {
+           count++;
+           Blob value = rs.getBlob(1);
+           long l = value.length();
+           long dlen = rs.getLong(2);
+           if (dlen != l) {
+               System.out.println("FAIL - MISMATCH LENGTHS GOT " + l
+                       + " expected " + dlen + " for row in BLOBTBL with ID="
+                       + id);
+           }
+       }
+       conn.commit();
+
+       verifyTest(count, expectedRows,
+               "Matched rows selected with blob of size(" + bloblen + ") =");
+
+       if (trace) {
+           System.out.println("Select Blob (" + bloblen + ")" + " rows= "
+                   + expectedRows + " = "
+                   + (long) (System.currentTimeMillis() - ST));
+       }
+       System.out.println("========================================");
+   }
+
+   /**
+    * insert blob into BLOBTBL2
+    * @param bloblen   length of blob to insert
+    * @param start     id value for insert
+    * @param rows      insert rows number of rows
+    * @param streamLength  stream length passed to setBinaryStream(,,length)
+    * @param file      filename to match retrieved data against
+    */
+
+   private static void insertBlob2(String testId, Connection conn,
+           PreparedStatement ps, int bloblen, int start, int rows,
+           int streamLength, String file) throws Exception {
+       System.out.println("========================================");
+       System.out.println("START " + testId + "insert Blob of size = "
+               + bloblen);
+       int count = 0;
+       java.util.Random random = new java.util.Random();
+       FileInputStream fis = null;
+
+       long ST = 0;
+       if (trace)
+           ST = System.currentTimeMillis();
+
+       for (int i = start; i < start + rows; i++) {
+           fis = new FileInputStream(file);
+           ps.setInt(1, i);
+           ps.setInt(2, 0);
+           ps.setLong(4, bloblen);
+           ps.setBinaryStream(3, fis, streamLength);
+           count += ps.executeUpdate();
+           fis.close();
+       }
+       conn.commit();
+       if (trace) {
+           System.out.println("Insert Blob (" + bloblen + ")" + " rows= "
+                   + count + " = " + (long) (System.currentTimeMillis() - ST));
+
+       }
+       verifyTest(count, rows, " Rows inserted with blob of size (" + bloblen
+               + ") =");
+       System.out.println("========================================");
+
+   }
+
+   /**
+    * select from blob table (BLOBTBL2)
+    * @param bloblen  select expects to retrieve a blob of this length
+    * @param id       id of the row to retrieve
+    * @param expectedRows  number of rows expected to match id
+    * @param file  name of the file,against which the retrieved data is
+    *              compared
+    */
+   private static void selectBlob2(String testId, Connection conn,
+           PreparedStatement ps, int bloblen, int id, int expectedRows,
+           String file) throws Exception {
+       System.out.println("========================================");
+       System.out.println("START " + testId + " - SELECT BLOB of size = "
+               + bloblen);
+
+       long ST = 0;
+       ResultSet rs = null;
+
+       if (trace)
+           ST = System.currentTimeMillis();
+
+       int count = 0;
+       ps.setInt(1, id);
+       rs = ps.executeQuery();
+
+       while (rs.next()) {
+           count++;
+           Blob value = rs.getBlob(1);
+           long l = value.length();
+           long dlen = rs.getLong(2);
+           if (dlen != l) {
+               System.out.println("FAIL - MISMATCH LENGTHS GOT " + l
+                       + " expected " + dlen + " for row in BLOBTBL with ID="
+                       + id);
+           } else
+               compareBlobToFile(value.getBinaryStream(), file);
+       }
+       conn.commit();
+
+       verifyTest(count, expectedRows,
+               "Matched rows selected with blob of size(" + bloblen + ") =");
+
+       if (trace) {
+           System.out.println("Select Blob (" + bloblen + ")" + " rows= "
+                   + expectedRows + " = "
+                   + (long) (System.currentTimeMillis() - ST));
+       }
+       System.out.println("========================================");
+   }
+
+   /**
+    * Basically this test will do an update using setBlob api -
+    * select row from blobtbl and then update a row in blobtbl 
+    * and verify updated data in blobtbl
+    * @param    ps  select statement from which blob is retrieved
+    * @param    bloblen updating value is of length bloblen
+    * @param    id  id of the row retrieved, for the update
+    * @param    updateId  id of the row that is updated
+    * @param    expectedRows    to be updated
+    */
+   private static void selectUpdateBlob(String testId, Connection conn,
+           PreparedStatement ps, int bloblen, int id, int updateId,
+           int expectedRows) throws Exception {
+       System.out.println("========================================");
+       System.out.println("START " + testId + " - select and then update blob of size= "
+               + bloblen + " - Uses getBlob api");
+
+       ResultSet rs = null;
+
+       ps.setInt(1, id);
+       rs = ps.executeQuery();
+       rs.next();
+       Blob value = rs.getBlob(1);
+       long l = value.length();
+       long dlen = rs.getLong(2);
+       if (dlen != l) {
+           System.out
+                   .println("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
+                           + dlen + " for row in BLOBTBL with ID=" + id);
+       }
+
+       PreparedStatement psUpd = conn
+               .prepareStatement("update BLOBTBL set content=?,dlen =? where id = ?");
+       psUpd.setBlob(1,value);
+       psUpd.setLong(2, l);
+       psUpd.setInt(3, updateId);
+
+       System.out.println("Rows Updated = " + psUpd.executeUpdate());
+       conn.commit();
+
+       // now select and verify that update went through ok.
+       ps.setInt(1, updateId);
+       ResultSet rs2 = ps.executeQuery();
+       rs2.next();
+       Blob updatedValue = rs2.getBlob(1);
+
+       if(updatedValue.length() != l)
+           System.out.println("FAIL - Retrieving the updated blob length does not match "+
+                   "expected length = "+l +" found = "+ updatedValue.length());
+
+       // close resultsets
+       conn.commit();
+       rs.close();
+       rs2.close();
+       psUpd.close();
+       System.out.println("========================================");
+   }
+
+   /**
+    * Basically this test will do an update using setBinaryStream api and verifies the
+    * updated data.  select row from blobtbl2 and then update a row in blobtbl 
+    * and verify updated data in blobtbl
+    * @param    bloblen updating value is of length bloblen
+    * @param    id  id of the row retrieved, for the update
+    * @param    updateId  id of the row that is updated
+    * @param    expectedRows    to be updated  
+    * @param file  name of the file,against which the updated data is
+    *              compared
+    */
+   private static void selectUpdateBlob2(String testId, Connection conn,
+           PreparedStatement ps,PreparedStatement sel,int bloblen, int id, int updateId,
+           int expectedRows,String file) throws Exception {
+       System.out.println("========================================");
+       System.out.println("START " + testId + " - select and then update blob of size= "
+               + bloblen + " - Uses getBlob and setBlob  api");
+
+       ResultSet rs = null;
+       
+       // retrieve row from blobtbl2
+       ps.setInt(1, id);
+       rs = ps.executeQuery();
+       rs.next();
+       Blob value = rs.getBlob(1);
+       long l = value.length();
+       long dlen = rs.getLong(2);
+       if (dlen != l) {
+           System.out
+                   .println("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
+                           + dlen + " for row in BLOBTBL2 with ID=" + id);
+       }
+
+       PreparedStatement psUpd = conn
+               .prepareStatement("update BLOBTBL set content=?,dlen =? where id = ?");
+       psUpd.setBlob(1,value);
+       psUpd.setLong(2, l);
+       psUpd.setInt(3, updateId);
+
+       System.out.println("Rows Updated = " + psUpd.executeUpdate());
+       conn.commit();
+
+       // now select and verify that update went through ok.
+       sel.setInt(1, updateId);
+       ResultSet rs2 = sel.executeQuery();
+       rs2.next();
+       Blob updatedValue = rs2.getBlob(1);
+       
+       if (updatedValue.length() != l)
+       {
+           System.out.println("FAIL - MISMATCH length of updated blob value : expected="+
+                   l+" found ="+updatedValue.length());
+       }
+       else
+           compareBlobToFile(updatedValue.getBinaryStream(),file);
+
+       // close resultsets
+       conn.commit();
+       rs.close();
+       rs2.close();
+       psUpd.close();
+       System.out.println("========================================");
+
+   }
+
+   private static void compareBlobToFile(InputStream lobstream, String filename)
+           throws Exception {
+       FileInputStream file = new FileInputStream(filename);
+       int l = 0;
+       int b = 0;
+       do {
+           l = lobstream.read();
+           b = file.read();
+           if (l != b)
+           {
+               System.out.println("FAIL -- MISMATCH in data stored versus"+
+                       "data retrieved");
+               break;
+           }
+       } while (l != -1 && b != -1);
+   }
+
+   private static void deleteTable(Connection conn, PreparedStatement ps,
+           int expectedRows) throws SQLException {
+       int count = ps.executeUpdate();
+       conn.commit();
+       verifyTest(count, expectedRows, "Rows deleted =");
+   }
+
+   
+   /**
+    * insert clob
+    * @param cloblen   length of clob to insert
+    * @param start     id value for insert
+    * @param rows      insert rows number of rows
+    * @param streamLength  stream length passed to setCharacterStream(...,length)
+    */
+   private static void insertClob_SetCharacterStream(String testId,
+           Connection conn, PreparedStatement ps, int cloblen, int start,
+           int rows, int streamLength) throws SQLException {
+       System.out.println("========================================");
+       System.out.println("START " + testId + "  -insertClob of size = "
+               + cloblen);
+
+       long ST = 0;
+       java.util.Random random = new java.util.Random();
+       int count = 0;
+       if (trace)
+           ST = System.currentTimeMillis();
+
+       for (int i = start; i < start + rows; i++) {
+           ps.setInt(1, i);
+           ps.setInt(2, 0);
+           ps.setLong(3, cloblen);
+           ps.setCharacterStream(4, new RandomCharReader(random, cloblen),
+                   streamLength);
+           count += ps.executeUpdate();
+       }
+       conn.commit();
+       if (trace) {
+           System.out.println("Insert Clob (" + cloblen + ")" + " rows= "
+                   + count + " = " + (long) (System.currentTimeMillis() - ST));
+
+       }
+       verifyTest(count, rows, "Rows inserted with clob of size (" + cloblen
+               + ") = ");
+       System.out.println("========================================");
+
+   }
+
+   /**
+    * select from clob table
+    * @param cloblen  select expects to retrieve a clob of this length
+    * @param id       id of the row to retrieve
+    * @param expectedRows number of rows expected to match id
+    */
+   private static void selectClob(String testId, Connection conn,
+           PreparedStatement ps, int cloblen, int id, int expectedRows)
+           throws SQLException {
+       System.out.println("========================================");
+       System.out.println("START " + testId + " - SELECT CLOB of size = "
+               + cloblen);
+
+       long ST = 0;
+       int count = 0;
+       ResultSet rs = null;
+       if (trace)
+           ST = System.currentTimeMillis();
+
+       ps.setInt(1, id);
+       rs = ps.executeQuery();
+       while (rs.next()) {
+           count++;
+           Clob value = rs.getClob(1);
+           long l = value.length();
+           long dlen = rs.getLong(2);
+           if (dlen != l) {
+               System.out.println("FAIL - MISMATCH LENGTHS GOT " + l
+                       + " expected " + dlen + " for row in CLOBTBL with ID="
+                       + id);
+           }
+
+       }
+       conn.commit();
+       if (trace) {
+           System.out.println("Select Clob (" + cloblen + ")" + " rows= "
+                   + expectedRows + " = "
+                   + (long) (System.currentTimeMillis() - ST));
+
+       }
+
+       verifyTest(count, expectedRows,
+               "Matched rows selected with clob of size(" + cloblen + ") =");
+       System.out.println("========================================");
+
+   }
+
+   /**
+    * insert clob into CLOBTBL2
+    * @param cloblen   length of clob to insert
+    * @param start     id value for insert
+    * @param rows      insert rows number of rows
+    * @param streamLength  stream length passed to setCharacterStream(pos,reader,streamLength)
+    * @param file       name of the file that has data to be inserted
+    */
+   private static void insertClob2(String testId, Connection conn,
+           PreparedStatement ps, int cloblen, int start, int rows,
+           int streamLength, String file) throws Exception {
+       System.out.println("========================================");
+       System.out.println("START " + testId + "insert Clob of size = "
+               + cloblen);
+       int count = 0;
+       FileReader reader = null;
+       long ST = 0;
+       if (trace)
+           ST = System.currentTimeMillis();
+
+       for (int i = start; i < start + rows; i++) {
+           reader = new FileReader(file);
+           ps.setInt(1, i);
+           ps.setInt(2, 0);
+           ps.setLong(4, cloblen);
+           ps.setCharacterStream(3, reader, streamLength);
+           count += ps.executeUpdate();
+           reader.close();
+       }
+       conn.commit();
+       if (trace) {
+           System.out.println("Insert Clob (" + cloblen + ")" + " rows= "
+                   + count + " = " + (long) (System.currentTimeMillis() - ST));
+
+       }
+       verifyTest(count, rows, " Rows inserted with clob of size (" + cloblen
+               + ") =");
+       System.out.println("========================================");
+
+   }
+
+   /**
+    * select from clob table (CLOBTBL2)
+    * @param cloblen  select expects to retrieve a clob of this length
+    * @param id       id of the row to retrieve
+    * @param expectedRows number of rows expected to match id
+    * @param file  filename to compare the retrieved data against
+    */
+   private static void selectClob2(String testId, Connection conn,
+           PreparedStatement ps, int cloblen, int id, int expectedRows,
+           String file) throws SQLException, Exception {
+       System.out.println("========================================");
+       System.out.println("START " + testId + " - SELECT CLOB of size = "
+               + cloblen);
+
+       long ST = 0;
+       ResultSet rs = null;
+
+       if (trace)
+           ST = System.currentTimeMillis();
+
+       int count = 0;
+       ps.setInt(1, id);
+       rs = ps.executeQuery();
+
+       while (rs.next()) {
+           count++;
+           Clob value = rs.getClob(1);
+           long l = value.length();
+           long dlen = rs.getLong(2);
+           if (cloblen != l) {
+               System.out.println("FAIL - MISMATCH LENGTHS GOT " + l
+                       + " expected " + dlen + " for row in CLOBTBL2 with ID="
+                       + id);
+           } else
+               compareClobToFile(value.getCharacterStream(), file, cloblen);
+       }
+       conn.commit();
+
+       verifyTest(count, expectedRows,
+               "Matched rows selected with clob of size(" + cloblen + ") =");
+
+       if (trace) {
+           System.out.println("Select Clob (" + cloblen + ")" + " rows= "
+                   + expectedRows + " = "
+                   + (long) (System.currentTimeMillis() - ST));
+       }
+       System.out.println("========================================");
+   }
+
+   /*
+    * Basically this test will do an update using setClob api -
+    *  select row from clobtbl and then update a row in clobtbl 
+    * and verify updated data in clobtbl 
+    */    
+   private static void selectUpdateClob(String testId, Connection conn,
+           PreparedStatement ps, int cloblen, int id, int updateId,
+           int expectedRows) throws Exception {
+       System.out.println("========================================");
+       System.out.println("START " + testId + " - select and then update clob of size= "
+               + cloblen + " - Uses setClob api");
+
+       ResultSet rs = null;
+
+       ps.setInt(1, id);
+       rs = ps.executeQuery();
+       rs.next();
+       Clob value = rs.getClob(1);
+       long l = value.length();
+       long dlen = rs.getLong(2);
+       if (dlen != l) {
+           System.out
+                   .println("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
+                           + dlen + " for row in CLOBTBL with ID=" + id);
+       }
+
+       PreparedStatement psUpd = conn
+               .prepareStatement("update CLOBTBL set content=?,dlen =? where id = ?");
+       psUpd.setCharacterStream(1, value.getCharacterStream(), (int) l);
+       psUpd.setLong(2, l);
+       psUpd.setInt(3, updateId);
+
+       System.out.println("Rows Updated = " + psUpd.executeUpdate());
+       conn.commit();
+
+       // now select and verify that update went through ok.
+       ps.setInt(1, updateId);
+       ResultSet rs2 = ps.executeQuery();
+       rs2.next();
+       Clob updatedValue = rs2.getClob(1);
+
+       if(updatedValue.length() != l)
+           System.out.println("FAIL - Retrieving the updated clob length does not match "+
+                   "expected length = "+l +" found = "+ updatedValue.length());
+
+       // close resultsets
+       conn.commit();
+       rs.close();
+       rs2.close();
+       psUpd.close();
+       System.out.println("========================================");
+   }
+
+   
+   /*
+    * Basically this test will do an update using setBlob api and verifies the
+    * updated data.  select row from clobtbl2 and then update a row in clobtbl 
+    * and verify updated data in clobtbl against the data in the original file
+    */
+   private static void selectUpdateClob2(String testId, Connection conn,
+           PreparedStatement ps, PreparedStatement sel,int cloblen, int id, int updateId,
+           int expectedRows,String file) throws Exception {
+       System.out.println("========================================");
+       System.out.println("START " + testId + " - select and then update clob of size= "
+               + cloblen + " - Uses setClob api");
+
+       ResultSet rs = null;
+       
+       // retrieve row from clobtbl2
+       ps.setInt(1, id);
+       rs = ps.executeQuery();
+       rs.next();
+       Clob value = rs.getClob(1);
+       long l = value.length();
+       long dlen = rs.getLong(2);
+       if (dlen != l) {
+           System.out
+                   .println("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
+                           + dlen + " for row in CLOBTBL2 with ID=" + id);
+       }
+
+       PreparedStatement psUpd = conn
+               .prepareStatement("update CLOBTBL set content=?,dlen =? where id = ?");
+       psUpd.setClob(1,value);
+       psUpd.setLong(2, l);
+       psUpd.setInt(3, updateId);
+
+       System.out.println("Rows Updated = " + psUpd.executeUpdate());
+       conn.commit();
+
+       // now select and verify that update went through ok.
+       sel.setInt(1, updateId);
+       ResultSet rs2 = sel.executeQuery();
+       rs2.next();
+       Clob updatedValue = rs2.getClob(1);
+       
+       if (updatedValue.length() != l)
+       {
+           System.out.println("FAIL - MISMATCH length of updated clob value , found="+
+                   updatedValue.length() +",expected = "+l);
+       }
+       else
+           compareClobToFile(updatedValue.getCharacterStream(),file,(int)l);
+
+       // close resultsets
+       conn.commit();
+       rs.close();
+       rs2.close();
+       psUpd.close();
+       System.out.println("========================================");
+
+   }
+
+   /*
+    * Basically this test will do an update using updateClob api and verifies the
+    * updated data.  select row from clobtbl2 and then update a row in clobtbl 
+    * and verify updated data in clobtbl against the data in the original file
+    * @param updateRowId    id of the row that needs to be updated
+    */
+   private static void updateClob2(String testId, Connection conn,PreparedStatement sel,
+           int cloblen, int id, int updateRowId,int updateIdVal,
+           int expectedRows,String file) throws Exception {
+       System.out.println("========================================");
+       System.out.println("START " + testId + " - select and then update clob of size= "
+               + cloblen + " - Uses updateClob api");
+
+       
+       PreparedStatement ps1 = conn.prepareStatement("SELECT * FROM CLOBTBL FOR UPDATE", ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
+       PreparedStatement ps = conn.prepareStatement("SELECT CONTENT,DLEN FROM CLOBTBL2 where ID =?");
+        
+       ResultSet rs = null;
+       ps.setInt(1,id);
+       // retrieve row from clobtbl2
+       rs = ps.executeQuery();
+       rs.next();
+       Clob value = rs.getClob(1);
+       long l = value.length();
+       long dlen = rs.getLong(2);
+       if (dlen != l) {
+           System.out
+                   .println("FAIL - MISMATCH LENGTHS GOT " + l + " expected "
+                           + dlen + " for row in CLOBTBL2 with ID=" + id);
+       }
+       
+       ResultSet rs1 = ps1.executeQuery();
+       while (rs1.next()) {
+            if (rs1.getInt(1) == updateRowId)
+            {
+                rs1.updateClob(4, value);
+                rs1.updateInt(1, updateIdVal);
+                rs1.updateInt(2, 0);
+                rs1.updateLong(3, dlen);
+                rs1.updateRow();
+                break;
+            }
+        }
+       // close resultsets
+       conn.commit();
+       rs.close();
+       rs1.close();
+       ps1.close();
+       ps.close();
+       
+       // verify
+       // now select and verify that update went through ok.
+       sel.setInt(1, updateIdVal);
+       ResultSet rs2 = sel.executeQuery();
+       rs2.next();
+       Clob updatedValue = rs2.getClob(1);
+       
+       if (updatedValue.length() != l)
+       {
+           System.out.println("FAIL - MISMATCH length of updated clob value , found="+
+                   updatedValue.length() +",expected = "+l);
+       }
+       else
+           compareClobToFile(updatedValue.getCharacterStream(),file,(int)l);
+
+
+       System.out.println("========================================");
+
+   }
+
+   
+   private static void compareClobToFile(Reader lobstream, String filename,int length)
+           throws Exception {
+       FileReader file = new FileReader(filename);
+       int c1 = 0;
+       int c2 = 0;
+       long count = 0;
+       do {
+           c1 = lobstream.read();
+           c2 = file.read();
+           if (c1 != c2)
+           {
+               System.out.println("FAIL -- MISMATCH in data stored versus data retrieved at " + count);
+               break;
+           }
+           count++;
+           length--;
+       } while (c1 != -1 && c2 != -1 && length > 0);
+   }
+
+   private static void expectedException(SQLException sqle) {
+
+       while (sqle != null) {
+           String sqlState = sqle.getSQLState();
+           if (sqlState == null) {
+               sqlState = "<NULL>";
+           }
+           System.out.println("EXPECTED SQL Exception: (" + sqlState + ") "
+                   + sqle.getMessage());
+
+           sqle = sqle.getNextException();
+       }
+   }
+
+   private static void verifyTest(int affectedRows, int expectedRows,
+           String test) {
+       if (affectedRows != expectedRows)
+           System.out.println("FAIL --" + test + affectedRows
+                   + " , but expected rows =" + expectedRows);
+       else
+           System.out.println(test + affectedRows);
+   }
+   
+   private static void writeToFile(String file,Reader r)
+       throws IOException
+   {
+       // does file exist, if so delete and write to a fresh file
+       File f =new File(file);
+       if (f.exists())
+           f.delete();
+       FileWriter writer = new FileWriter(file);
+       // write in chunks of 32k buffer
+       char[] buffer = new char[32 * 1024];
+       int count = 0;
+       
+       while((count = r.read(buffer)) >=0)
+           writer.write(buffer,0,count);
+       writer.flush();
+       writer.close();
+   }
+}
+
+/**
+ * Class to generate random byte data
+ */
+class RandomByteStream extends java.io.InputStream {
+   private int length;
+
+   private java.util.Random dpr;
+
+   RandomByteStream(java.util.Random dpr, int length) {
+       this.length = length;
+       this.dpr = dpr;
+
+   }
+
+   public int read() {
+       if (length <= 0)
+           return -1;
+
+       length--;
+       return (byte) (dpr.nextInt() >>> 25);
+   }
+
+   public int read(byte[] data, int off, int len) {
+
+       if (length <= 0)
+           return -1;
+
+       if (len > length)
+           len = length;
+
+       for (int i = 0; i < len; i++) {
+           // chop off bits and return a +ve byte value.
+           data[off + i] = (byte) (dpr.nextInt() >>> 25);
+       }
+
+       length -= len;
+       return len;
+   }
+}
+
+/*
+ * Class to generate random char data, generates 1,2,3bytes character.
+ */
+class RandomCharReader extends java.io.Reader {
+   private int length;
+   private int numTrailingSpaces;
+
+   private java.util.Random dpr;
+
+   RandomCharReader(java.util.Random dpr, int length) {
+       this.length = length;
+       this.dpr = dpr;
+       this.numTrailingSpaces = 0;
+   }
+
+   RandomCharReader(java.util.Random dpr, int length,int numTrailingSpaces) {
+       this.length = length;
+       this.dpr = dpr;
+       this.numTrailingSpaces = numTrailingSpaces;
+   }
+
+   private int randomInt(int min, int max) {
+       return dpr.nextInt(max - min) + min;
+   }
+
+   private char getChar() {
+       // return space for trailing spaces.
+       if (length <= numTrailingSpaces)
+       {
+          return ' ';
+       }
+          
+       double drand = dpr.nextDouble();
+       char c = 'a';
+       if (drand < 0.25)
+           c = (char) randomInt((int) 'A', (int) 'Z');
+       else if (drand < 0.5)
+           switch (randomInt(1, 10)) {
+           case 1:
+               c = '\u00c0';
+               break;
+           case 2:
+               c = '\u00c1';
+               break;
+           case 3:
+               c = '\u00c2';
+               break;
+           case 4:
+               c = '\u00ca';
+               break;
+           case 5:
+               c = '\u00cb';
+               break;
+           case 6:
+               c = '\u00d4';
+               break;
+           case 7:
+               c = '\u00d8';
+               break;
+           case 8:
+               c = '\u00d1';
+               break;
+           case 9:
+               c = '\u00cd';
+               break;
+           default:
+               c = '\u00dc';
+               break;
+           }
+       else if (drand < 0.75)
+           c = (char) randomInt((int) 'a', (int) 'z');
+       else if (drand < 1.0)
+           switch (randomInt(1, 10)) {
+           case 1:
+               c = '\u00e2';
+               break;
+           case 2:
+               c = '\u00e4';
+               break;
+           case 3:
+               c = '\u00e7';
+               break;
+           case 4:
+               c = '\u00e8';
+               break;
+           case 5:
+               c = '\u00ec';
+               break;
+           case 6:
+               c = '\u00ef';
+               break;
+           case 7:
+               c = '\u00f6';
+               break;
+           case 8:
+               c = '\u00f9';
+               break;
+           case 9:
+               c = '\u00fc';
+               break;
+           default:
+               c = '\u00e5';
+               break;
+           }
+
+       return c;
+
+   }
+
+   public int read() {
+       if (length <= 0)
+           return -1;
+
+       length--;
+       return getChar();
+   }
+
+   public int read(char[] data, int off, int len) {
+
+       if (length <= 0)
+           return -1;
+
+       if (len > length)
+           len = length;
+
+       for (int i = 0; i < len; i++) {
+           data[off + i] = getChar();
+           length -= 1;
+       }
+
+       return len;
+   }
+
+   public void close() {
+
+   }
+}
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/store/streamingColumn.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/store/streamingColumn.java
index 5091a00b..43c737b7 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/store/streamingColumn.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/store/streamingColumn.java
@@ -63,6 +63,9 @@
 		fileName[3] = "extin/empty.data"; // set up a file with nothing in it
 	}
 
+	private static final int LONGVARCHAR = 1;
+    private static final int CLOB = 2;
+    private static final int VARCHAR = 3;
 
 	public static void main(String[] args) {
 
@@ -92,7 +95,9 @@ public static void main(String[] args) {
 			streamTest5(conn, 0);
 			streamTest5(conn, 1500);
 			streamTest5(conn, 5000);
-			streamTest5(conn, 100000);
+        //  This test fails when running w/ derby.language.logStatementText=true
+        //  see DERBY-595 
+		//	streamTest5(conn, 100000);
 
 			streamTest6(conn, 5000);
 			streamTest7(conn);
@@ -117,6 +122,11 @@ public static void main(String[] args) {
 			// bug 5592 test - any character(including blank character) truncation should give error for long varchars
 			streamTest13(conn);
 
+            // Test clob truncation, behavior similar to varchar
+            // trailingspaces are truncated but if there are trailing non-blanks then
+            // exception is thrown
+            // This test is similar to streamTest12.
+            streamTest14(conn);
 			// turn autocommit on because in JCC, java.sql.Connection.close() can not be
 			// requested while a transaction is in progress on the connection.
 			// If autocommit is off in JCC, the transaction remains active, 
@@ -1072,7 +1082,7 @@ private static void streamTest12(Connection conn) {
 			insertDataUsingStringOrObject(ps, 3, Limits.DB2_VARCHAR_MAXWIDTH, true, true);
 			insertDataUsingStringOrObject(ps, 4, Limits.DB2_VARCHAR_MAXWIDTH, true, false);
 			System.out.println("===> testing trailing blanks using concatenation");
-			insertDataUsingConcat(stmt, 5, Limits.DB2_VARCHAR_MAXWIDTH, true, false);
+			insertDataUsingConcat(stmt, 5, Limits.DB2_VARCHAR_MAXWIDTH, true, VARCHAR);
 
 			// prepare an InputStream from the file which has 3 trailing non-blanks in the end, and hence there would be overflow exception
 			// try this using setAsciiStream, setCharacterStream, setString and setObject
@@ -1081,7 +1091,7 @@ private static void streamTest12(Connection conn) {
 			insertDataUsingStringOrObject(ps, 8, Limits.DB2_VARCHAR_MAXWIDTH, false, true);
 			insertDataUsingStringOrObject(ps, 9, Limits.DB2_VARCHAR_MAXWIDTH, false, false);
 			System.out.println("===> testing trailing non-blank characters using concatenation");
-			insertDataUsingConcat(stmt, 10, Limits.DB2_VARCHAR_MAXWIDTH, false, false);
+			insertDataUsingConcat(stmt, 10, Limits.DB2_VARCHAR_MAXWIDTH, false, VARCHAR);
 
 			rs = stmt.executeQuery("select a, b from testVarChar");
 			streamTestDataVerification(rs, Limits.DB2_VARCHAR_MAXWIDTH);
@@ -1145,6 +1155,73 @@ private static void streamTest13(Connection conn) {
 	}
 
 
+    /**
+     * Test truncation behavior for clobs
+     * Test is similar to streamTest12 except that this test tests for clob column
+     * @param conn
+     */
+    private static void streamTest14(Connection conn) {
+
+        ResultSet rs;
+        Statement stmt;
+
+        //The following 2 files are for testing the truncation in clob
+        //only non-blank character truncation will throw an exception for clob.
+        //max value allowed in clob is 2G-1
+        String fileName1 = "extin/char32675trailingblanks.data"; // set up a file 32675 characters long but with last 3 characters as blanks
+        String fileName2 = "extin/char32675.data"; // set up a file 32675 characters long with 3 extra non-blank characters trailing in the end
+
+        System.out.println("Test 14 - clob truncation tests start from here");
+        try {
+            stmt = conn.createStatement();
+            stmt.executeUpdate("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.storage.pageSize', '4096')");
+            stmt.execute("drop table testConcatenation");
+            stmt.execute("create table testClob (a int, b clob(32672))");
+            //create a table with 4 varchars. This table will be used to try overflow through concatenation
+            
+            stmt.execute("create table testConcatenation (a clob(16350), b clob(16350), c clob(16336), d clob(16336))");
+            stmt.executeUpdate("call SYSCS_UTIL.SYSCS_SET_DATABASE_PROPERTY('derby.storage.pageSize', NULL)");
+            String largeStringA16350 = new String(Formatters.repeatChar("a",16350));
+            String largeStringA16336 = new String(Formatters.repeatChar("a",16336));
+            PreparedStatement ps = conn.prepareStatement("insert into testConcatenation values (?, ?, ?, ?)");
+            ps.setString(1, largeStringA16350);
+            ps.setString(2, largeStringA16350);
+            ps.setString(3, largeStringA16336);
+            ps.setString(4, largeStringA16336);
+            ps.executeUpdate();
+
+            ps = conn.prepareStatement("insert into testClob values(?, ?)");
+
+            // prepare an InputStream from the file which has 3 trailing blanks in the end, so after blank truncation, there won't be any overflow
+            // try this using setAsciiStream, setCharacterStream, setString and setObject
+            insertDataUsingAsciiStream(ps, 1, fileName1, Limits.DB2_VARCHAR_MAXWIDTH);
+            insertDataUsingCharacterStream(ps, 2, fileName1, Limits.DB2_VARCHAR_MAXWIDTH);
+            insertDataUsingStringOrObject(ps, 3, Limits.DB2_VARCHAR_MAXWIDTH, true, true);
+            insertDataUsingStringOrObject(ps, 4, Limits.DB2_VARCHAR_MAXWIDTH, true, false);
+            System.out.println("===> testing trailing blanks using concatenation");
+            insertDataUsingConcat(stmt, 5, Limits.DB2_VARCHAR_MAXWIDTH, true, CLOB);
+
+            // prepare an InputStream from the file which has 3 trailing non-blanks in the end, and hence there would be overflow exception
+            // try this using setAsciiStream, setCharacterStream, setString and setObject
+            insertDataUsingAsciiStream(ps, 6, fileName2, Limits.DB2_VARCHAR_MAXWIDTH);
+            insertDataUsingCharacterStream(ps, 7, fileName2, Limits.DB2_VARCHAR_MAXWIDTH);
+            insertDataUsingStringOrObject(ps, 8, Limits.DB2_VARCHAR_MAXWIDTH, false, true);
+            insertDataUsingStringOrObject(ps, 9, Limits.DB2_VARCHAR_MAXWIDTH, false, false);
+            System.out.println("===> testing trailing non-blank characters using concatenation");
+            insertDataUsingConcat(stmt, 10, Limits.DB2_VARCHAR_MAXWIDTH, false, CLOB);
+
+            rs = stmt.executeQuery("select a, b from testVarChar");
+            streamTestDataVerification(rs, Limits.DB2_VARCHAR_MAXWIDTH);
+    }
+        catch (SQLException e) {
+            dumpSQLExceptions(e);
+        }
+        catch (Throwable e) {
+            System.out.println("FAIL -- unexpected exception:" + e.toString());
+        }
+        System.out.println("Test 14 - clob truncation tests end in here");
+    }
+
 	private static void streamTestDataVerification(ResultSet rs, int maxValueAllowed)
 	throws Exception{
 		ResultSetMetaData met;
@@ -1174,17 +1251,25 @@ private static void streamTestDataVerification(ResultSet rs, int maxValueAllowed
 	//blankPadding
 	//  true means excess trailing blanks
 	//  false means excess trailing non-blank characters
-	//forLongVarChar
-	//  true means testing for long varchar truncation and hence use table testLongVarChars
-	//  false means testing for varchar truncation and hence use table testVarChar
+	//  @param tblType table type, depending on the table type, the corresponding
+    //  table is used. for varchar - testVarChar , for long varchar - testVarChars,
+    //  and for clob - testClob is used
 	private static void insertDataUsingConcat(Statement stmt, int intValue, int maxValueAllowed, boolean blankPadding,
-	 	boolean forLongVarChar)
+	 	int tblType)
 	throws Exception{
 		String sql;
-		if (forLongVarChar)
+        
+        switch(tblType)
+        {
+            case LONGVARCHAR:
 			sql = "insert into testLongVarChars select " + intValue + ", a||b||";
-		else
+                break;
+            case CLOB:
+                sql = "insert into testClob select "+ intValue + ", c||d||";
+                break;
+            default:
 			sql = "insert into testVarChar select "+ intValue + ", c||d||";
+        }
 
 		if (blankPadding) //try overflow with trailing blanks
 			sql = sql.concat("'   ' from testConcatenation");
@@ -1269,7 +1354,7 @@ private static void insertDataUsingCharacterStream(PreparedStatement ps, int int
 			if (file.length() > maxValueAllowed && e.getSQLState().equals("22001")) //truncation error
 				System.out.println("expected exception for data > " + maxValueAllowed + " in length");
 			else
-				dumpSQLExceptions(e);
+				TestUtil.dumpSQLExceptions(e,true);
 	 	}
 	 	filer.close();
 	}
@@ -1292,7 +1377,7 @@ private static void insertDataUsingAsciiStream(PreparedStatement ps, int intValu
 			if (file.length() > maxValueAllowed && e.getSQLState().equals("22001")) //truncation error
 				System.out.println("expected exception for data > " + maxValueAllowed + " in length");
 			else
-				dumpSQLExceptions(e);
+				TestUtil.dumpSQLExceptions(e,true);
 	 	}
 	 	fileIn.close();
 	}
@@ -1413,7 +1498,7 @@ static private void dumpSQLExceptions (SQLException se) {
 		System.out.println("FAIL -- unexpected exception: " + se.toString());
 		se.printStackTrace();
 		while (se != null) {
-			System.out.print("SQLSTATE("+se.getSQLState()+"):");
+			System.out.println("SQLSTATE("+se.getSQLState()+"):"+se.getMessage());
 			se = se.getNextException();
 		}
 	}
