diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/catalog/AliasInfo.java b/db/derby/code/trunk/java/engine/org/apache/derby/catalog/AliasInfo.java
index 86452bfb..66a3d017 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/catalog/AliasInfo.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/catalog/AliasInfo.java
@@ -42,11 +42,13 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	 * Public statics for the various alias types as both char and String.
 	 */
 	public static final char ALIAS_TYPE_UDT_AS_CHAR		= 'A';
+	public static final char ALIAS_TYPE_AGGREGATE_AS_CHAR		= 'G';
 	public static final char ALIAS_TYPE_PROCEDURE_AS_CHAR		= 'P';
 	public static final char ALIAS_TYPE_FUNCTION_AS_CHAR		= 'F';
 	public static final char ALIAS_TYPE_SYNONYM_AS_CHAR             = 'S';	
 
 	public static final String ALIAS_TYPE_UDT_AS_STRING		= "A";
+	public static final String ALIAS_TYPE_AGGREGATE_AS_STRING		= "G";
 	public static final String ALIAS_TYPE_PROCEDURE_AS_STRING		= "P";
 	public static final String ALIAS_TYPE_FUNCTION_AS_STRING		= "F";
 	public static final String ALIAS_TYPE_SYNONYM_AS_STRING  		= "S";
@@ -55,11 +57,13 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 	 * Public statics for the various alias name spaces as both char and String.
 	 */
 	public static final char ALIAS_NAME_SPACE_UDT_AS_CHAR	= 'A';
+	public static final char ALIAS_NAME_SPACE_AGGREGATE_AS_CHAR	= 'G';
 	public static final char ALIAS_NAME_SPACE_PROCEDURE_AS_CHAR	= 'P';
 	public static final char ALIAS_NAME_SPACE_FUNCTION_AS_CHAR	= 'F';
 	public static final char ALIAS_NAME_SPACE_SYNONYM_AS_CHAR       = 'S';
 
 	public static final String ALIAS_NAME_SPACE_UDT_AS_STRING	= "A";
+	public static final String ALIAS_NAME_SPACE_AGGREGATE_AS_STRING	= "G";
 	public static final String ALIAS_NAME_SPACE_PROCEDURE_AS_STRING	= "P";
 	public static final String ALIAS_NAME_SPACE_FUNCTION_AS_STRING	= "F";
 	public static final String ALIAS_NAME_SPACE_SYNONYM_AS_STRING   = "S";
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/AggregateAliasInfo.java b/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/AggregateAliasInfo.java
index e69de29b..b480dc3a 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/AggregateAliasInfo.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/catalog/types/AggregateAliasInfo.java
@@ -0,0 +1,147 @@
+/*
+
+   Derby - Class org.apache.derby.catalog.types.AggregateAliasInfo
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to You under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+      http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derby.catalog.types;
+
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+
+import org.apache.derby.iapi.services.io.Formatable;
+import org.apache.derby.iapi.services.io.StoredFormatIds;
+import org.apache.derby.catalog.AliasInfo;
+import org.apache.derby.catalog.TypeDescriptor;
+
+/**
+ * Describe a G (Aggregate) alias. The AggregateAliasInfo maintains a version stamp so that it
+ * can evolve its persistent form over time.
+ *
+ * @see AliasInfo
+ */
+public class AggregateAliasInfo implements AliasInfo, Formatable
+{
+    ///////////////////////////////////////////////////////////////////////////////////
+    //
+    // CONSTANTS
+    //
+    ///////////////////////////////////////////////////////////////////////////////////
+
+    private static final int FIRST_VERSION = 0;
+
+    ///////////////////////////////////////////////////////////////////////////////////
+    //
+    // STATE
+    //
+    ///////////////////////////////////////////////////////////////////////////////////
+
+    private TypeDescriptor  _forType;
+    private TypeDescriptor  _returnType;
+
+    ///////////////////////////////////////////////////////////////////////////////////
+    //
+    // CONSTRUCTOR
+    //
+    ///////////////////////////////////////////////////////////////////////////////////
+
+    /** no-arg constructor for Formatable machinery */
+	public AggregateAliasInfo() {}
+
+    /** Construct from pieces */
+    public  AggregateAliasInfo
+        (
+         TypeDescriptor forType,
+         TypeDescriptor returnType
+         )
+    {
+        _forType = forType;
+        _returnType = returnType;
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////////
+    //
+    // AliasInfo BEHAVIOR
+    //
+    ///////////////////////////////////////////////////////////////////////////////////
+
+	public boolean isTableFunction() { return false; }
+
+    ///////////////////////////////////////////////////////////////////////////////////
+    //
+    // Formatable BEHAVIOR
+    //
+    ///////////////////////////////////////////////////////////////////////////////////
+
+	/**
+	 * Read this object from a stream of stored objects.
+	 *
+	 * @param in read this.
+	 *
+	 * @exception IOException					thrown on error
+	 * @exception ClassNotFoundException		thrown on error
+	 */
+	public void readExternal( ObjectInput in )
+		 throws IOException, ClassNotFoundException
+	{
+        // as the persistent form evolves, switch on this value
+        int oldVersion = in.readInt();
+
+        _forType = (TypeDescriptor) in.readObject();
+        _returnType = (TypeDescriptor) in.readObject();
+	}
+
+	/**
+	 * Write this object to a stream of stored objects.
+	 *
+	 * @param out write bytes here.
+	 *
+	 * @exception IOException		thrown on error
+	 */
+	public void writeExternal( ObjectOutput out )
+		 throws IOException
+	{
+		out.writeInt( FIRST_VERSION );
+
+        out.writeObject( _forType );
+        out.writeObject( _returnType );
+	}
+ 
+	/**
+	 * Get the formatID which corresponds to this class.
+	 *
+	 *	@return	the formatID of this class
+	 */
+	public	int	getTypeFormatId()	{ return StoredFormatIds.AGGREGATE_INFO_V01_ID; }
+
+    /**
+     * This is used by dblook to reconstruct the aggregate-specific parts of the ddl
+     * needed to recreate this alias.
+     */
+	public String toString() {
+		return "FOR " + _forType.getSQLstring() +
+            " RETURNS " + _returnType.getSQLstring();
+	}
+
+	public String getMethodName()
+	{
+		return null;
+	}
+}
+
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java
index cc704d3e..4157771f 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/RegisteredFormatIds.java
@@ -536,5 +536,6 @@ The offset from the base format number (0 based) gives the offset in the array.
         /* 472 */       "org.apache.derby.impl.sql.catalog.CoreDDFinderClassInfo",
         /* 473 */       "org.apache.derby.impl.sql.catalog.CoreDDFinderClassInfo",
         /* 474 */       "org.apache.derby.catalog.types.UDTAliasInfo",
+        /* 475 */       "org.apache.derby.catalog.types.AggregateAliasInfo",
 };
 }
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java
index 72e0bbe4..2c7e9324 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/services/io/StoredFormatIds.java
@@ -1452,6 +1452,7 @@ and another may restore (read) the object. The implication of this
     public static final int ROUTINE_INFO_V01_ID = (MIN_ID_2 + 451);
     public static final int SYNONYM_INFO_V01_ID = (MIN_ID_2 + 455);
     public static final int UDT_INFO_V01_ID = (MIN_ID_2 + 474);
+    public static final int AGGREGATE_INFO_V01_ID = (MIN_ID_2 + 475);
 
     /******************************************************************
     **
@@ -1904,7 +1905,7 @@ and another may restore (read) the object. The implication of this
      * Make sure this is updated when a new module is added
      */
     public static final int MAX_ID_2 =
-            (MIN_ID_2 + 474);
+            (MIN_ID_2 + 475);
 
     // DO NOT USE 4 BYTE IDS ANYMORE
     static public final int MAX_ID_4 =
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/depend/DependencyManager.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/depend/DependencyManager.java
index f221bd37..521db29f 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/depend/DependencyManager.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/depend/DependencyManager.java
@@ -339,6 +339,8 @@ Enumeration getInvalidDependencies (Provider p,
 
     public static final int DROP_UDT = 50;
 
+    public static final int DROP_AGGREGATE = 51;
+
     /**
      * Extensions to this interface may use action codes > MAX_ACTION_CODE without fear of
      * clashing with action codes in this base interface.
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/AliasDescriptor.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/AliasDescriptor.java
index 12db44a5..cd1bee40 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/AliasDescriptor.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/AliasDescriptor.java
@@ -31,6 +31,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.services.sanity.SanityManager;
 
 import	org.apache.derby.catalog.AliasInfo;
+import	org.apache.derby.catalog.types.AggregateAliasInfo;
 import org.apache.derby.catalog.types.RoutineAliasInfo;
 import	org.apache.derby.catalog.types.UDTAliasInfo;
 
@@ -130,6 +131,10 @@ public String getObjectTypeName()
         {
             return PermDescriptor.UDT_TYPE;
         }
+        else if ( aliasInfo instanceof AggregateAliasInfo )
+        {
+            return PermDescriptor.AGGREGATE_TYPE;
+        }
         else
         {
             if( SanityManager.DEBUG)
@@ -374,6 +379,8 @@ public static final String getAliasType(char nameSpace)
 				return "SYNONYM";
 			case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:
 				return "TYPE";
+			case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
+				return "DERBY AGGREGATE";
 		}
 		return  null;
 	}
@@ -452,6 +459,10 @@ public void drop(LanguageConnectionContext lcc) throws StandardException {
         case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:
             invalidationType = DependencyManager.DROP_UDT;
             break;
+            
+        case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
+            invalidationType = DependencyManager.DROP_AGGREGATE;
+            break;
         }
         
         dm.invalidateFor(this, invalidationType, lcc);
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/PermDescriptor.java b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/PermDescriptor.java
index 06fe0cd8..142cb1ed 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/PermDescriptor.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/iapi/sql/dictionary/PermDescriptor.java
@@ -40,6 +40,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
     // object types
     public static final String SEQUENCE_TYPE = "SEQUENCE";
     public static final String UDT_TYPE = "TYPE";
+    public static final String AGGREGATE_TYPE = "DERBY AGGREGATE";
 
     // permissions
     public static final String USAGE_PRIV = "USAGE";
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/catalog/SYSALIASESRowFactory.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/catalog/SYSALIASESRowFactory.java
index 43cce811..36eccd1b 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/catalog/SYSALIASESRowFactory.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/catalog/SYSALIASESRowFactory.java
@@ -172,6 +172,7 @@ public ExecRow makeRow(TupleDescriptor	td, TupleDescriptor parent)
 					case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:
 					case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR:
 					case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:
+					case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
 						break;
 
 					default:
@@ -302,6 +303,7 @@ public TupleDescriptor buildDescriptor(
 				case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR: 
 				case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR: 
 				case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR: 
+				case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR: 
 					break;
 
 				default: 
@@ -325,6 +327,7 @@ public TupleDescriptor buildDescriptor(
 				case AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR: 
 				case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR: 
 				case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR: 
+				case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR: 
 					break;
 
 				default: 
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CreateAliasNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CreateAliasNode.java
index dfd130ae..bf787840 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CreateAliasNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/CreateAliasNode.java
@@ -21,9 +21,11 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 package	org.apache.derby.impl.sql.compile;
 
+import java.util.List;
 import java.util.Vector;
 import org.apache.derby.catalog.AliasInfo;
 import org.apache.derby.catalog.TypeDescriptor;
+import org.apache.derby.catalog.types.AggregateAliasInfo;
 import org.apache.derby.catalog.types.RoutineAliasInfo;
 import org.apache.derby.catalog.types.SynonymAliasInfo;
 import org.apache.derby.catalog.types.UDTAliasInfo;
@@ -31,6 +33,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 import org.apache.derby.iapi.reference.Limits;
 import org.apache.derby.iapi.reference.SQLState;
 import org.apache.derby.iapi.services.sanity.SanityManager;
+import org.apache.derby.iapi.sql.dictionary.AliasDescriptor;
 import org.apache.derby.iapi.sql.dictionary.DataDictionary;
 import org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;
 import org.apache.derby.iapi.sql.execute.ConstantAction;
@@ -63,6 +66,51 @@ Licensed to the Apache Software Foundation (ASF) under one or more
     public static final int ROUTINE_ELEMENT_COUNT =
         ROUTINE_SECURITY_DEFINER + 1;
 
+    //
+    // These are the names of 1-arg builtin functions which are represented in the
+    // grammar as non-reserved keywords. These names may not be used as
+    // the unqualified names of user-defined aggregates.
+    //
+    // If additional 1-arg builtin functions are added to the grammar, they should
+    // be put in this table.
+    //
+    private static  final   String[]  NON_RESERVED_FUNCTION_NAMES =
+    {
+        "ABS",
+        "ABSVAL",
+        "DATE",
+        "DAY",
+        "LCASE",
+        "LENGTH",
+        "MONTH",
+        "SQRT",
+        "TIME",
+        "TIMESTAMP",
+        "UCASE",
+    };
+
+    //
+    // These are aggregate names defined by the SQL Standard which do not
+    // behave as reserved keywords in Derby.
+    //
+    private static  final   String[]    NON_RESERVED_AGGREGATES =
+    {
+        "COLLECT",
+        "COUNT",
+        "EVERY",
+        "FUSION",
+        "INTERSECTION",
+        "STDDEV_POP",
+        "STDDEV_SAMP",
+        "VAR_POP",
+        "VAR_SAMP",
+    };
+
+    // aggregate arguments
+    public  static  final   int AGG_FOR_TYPE = 0;
+    public  static  final   int AGG_RETURN_TYPE = AGG_FOR_TYPE + 1;
+    public  static  final   int AGG_ELEMENT_COUNT = AGG_RETURN_TYPE + 1;
+
 	private String				javaClassName;
 	private String				methodName;
 	private char				aliasType; 
@@ -95,6 +143,17 @@ public void init(
 
 		switch (this.aliasType)
 		{
+			case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
+				this.javaClassName = (String) targetObject;
+
+				Object[] aggElements = (Object[]) aliasSpecificInfo;
+                TypeDescriptor  aggForType = (TypeDescriptor) aggElements[ AGG_FOR_TYPE ];
+                TypeDescriptor  aggReturnType = (TypeDescriptor) aggElements[ AGG_RETURN_TYPE ];
+
+				aliasInfo = new AggregateAliasInfo( aggForType, aggReturnType );
+				implicitCreateSchema = true;
+                break;
+                
 			case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:
 				this.javaClassName = (String) targetObject;
 				aliasInfo = new UDTAliasInfo();
@@ -262,6 +321,8 @@ public String statementToString()
 	{
 		switch (this.aliasType)
 		{
+		case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
+			return "CREATE DERBY AGGREGATE";
 		case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:
 			return "CREATE TYPE";
 		case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
@@ -342,7 +403,10 @@ public void bindStatement() throws StandardException
             return;
         }
 
-		// Procedures and functions do not check class or method validity until
+        // validity checking for aggregates
+        if ( aliasType == AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR ) { bindAggregate(); }
+        
+		// Aggregates, procedures and functions do not check class or method validity until
 		// runtime execution. Synonyms do need some validity checks.
 		if (aliasType != AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR)
 			return;
@@ -365,6 +429,55 @@ public void bindStatement() throws StandardException
 
 	}
 
+    /** Extra logic for binding user-defined aggregate definitions */
+    private void    bindAggregate() throws StandardException
+    {
+        String                      unqualifiedName = getRelativeName();
+
+        //
+        // A user-defined aggregate cannot have the name of a builtin function which takes 1 argument.
+        //
+        SchemaDescriptor    sysfun = getSchemaDescriptor( "SYSFUN", true );
+        List                        systemFunctions = getDataDictionary().getRoutineList
+            (
+             sysfun.getUUID().toString(), unqualifiedName,
+             AliasInfo.ALIAS_NAME_SPACE_FUNCTION_AS_CHAR
+             );
+
+        for ( int i = 0; i < systemFunctions.size(); i++ )
+        {
+			AliasDescriptor function = (AliasDescriptor) systemFunctions.get(i);
+
+			RoutineAliasInfo routineInfo = (RoutineAliasInfo) function.getAliasInfo();
+			int parameterCount = routineInfo.getParameterCount();
+			if ( parameterCount == 1 )  { throw illegalAggregate(); }
+        }
+        
+        //
+        // Additional builtin 1-arg functions which are represented in the grammar
+        // as non-reserved keywords.
+        //
+        for ( int i = 0; i < NON_RESERVED_FUNCTION_NAMES.length; i++ )
+        {
+            if ( NON_RESERVED_FUNCTION_NAMES[ i ].equals( unqualifiedName ) )  { throw illegalAggregate(); }
+        }
+
+        //
+        // Additional SQL Standard aggregate names which are not represented in
+        // the Derby grammar as reserved keywords.
+        //
+        for ( int i = 0; i < NON_RESERVED_AGGREGATES.length; i++ )
+        {
+            if ( NON_RESERVED_AGGREGATES[ i ].equals( unqualifiedName ) )  { throw illegalAggregate(); }
+        }
+    }
+
+    /** Construct an exception flagging an illegal aggregate name */
+    private StandardException   illegalAggregate()
+    {
+        return StandardException.newException( SQLState.LANG_ILLEGAL_UDA_NAME, getRelativeName() );
+    }
+
     /** Bind the class names for UDTs */
     private void bindParameterTypes( RoutineAliasInfo aliasInfo ) throws StandardException
     {
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/DropAliasNode.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/DropAliasNode.java
index 333bd535..458252aa 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/DropAliasNode.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/compile/DropAliasNode.java
@@ -67,6 +67,10 @@ public void init(Object dropAliasName, Object aliasType)
 	
 		switch (this.aliasType)
 		{
+			case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
+				nameSpace = AliasInfo.ALIAS_NAME_SPACE_AGGREGATE_AS_CHAR;
+				break;
+
 			case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
 				nameSpace = AliasInfo.ALIAS_NAME_SPACE_PROCEDURE_AS_CHAR;
 				break;
@@ -151,6 +155,9 @@ private static String aliasTypeName( char actualType)
 
 		switch ( actualType )
 		{
+			case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
+				typeName = "DERBY AGGREGATE";
+				break;
 			case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
 				typeName = "PROCEDURE";
 				break;
diff --git a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/CreateAliasConstantAction.java b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/CreateAliasConstantAction.java
index a0b4ac68..426c4569 100644
--- a/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/CreateAliasConstantAction.java
+++ b/db/derby/code/trunk/java/engine/org/apache/derby/impl/sql/execute/CreateAliasConstantAction.java
@@ -80,6 +80,10 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 		this.aliasType = aliasType;
 		switch (aliasType)
 		{
+			case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
+				nameSpace = AliasInfo.ALIAS_NAME_SPACE_AGGREGATE_AS_CHAR;
+				break;
+
 			case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
 				nameSpace = AliasInfo.ALIAS_NAME_SPACE_PROCEDURE_AS_CHAR;
 				break;
@@ -117,6 +121,10 @@ public	String	toString()
 
 		switch (aliasType)
 		{
+			case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
+				type = "CREATE DERBY AGGREGATE ";
+				break;
+
 			case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
 				type = "CREATE PROCEDURE ";
 				break;
@@ -224,7 +232,32 @@ public void	executeConstantAction( Activation activation )
 									 aliasInfo, null);
 
 		// perform duplicate rule checking
-		switch (aliasType) {
+        switch (aliasType)
+        {
+        case AliasInfo.ALIAS_TYPE_AGGREGATE_AS_CHAR:
+
+            AliasDescriptor duplicateAlias = dd.getAliasDescriptor( sd.getUUID().toString(), aliasName, nameSpace );
+            if ( duplicateAlias != null )
+            {
+                throw StandardException.newException( SQLState.LANG_OBJECT_ALREADY_EXISTS, ads.getDescriptorType(), aliasName );
+            }
+
+            // also don't want to collide with 1-arg functions by the same name
+            java.util.List funcList = dd.getRoutineList( sd.getUUID().toString(), aliasName, AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR );
+            for ( int i = 0; i < funcList.size(); i++ )
+            {
+				AliasDescriptor func = (AliasDescriptor) funcList.get(i);
+
+				RoutineAliasInfo funcInfo = (RoutineAliasInfo) func.getAliasInfo();
+                if ( funcInfo.getParameterCount() == 1 )
+                {
+                    throw StandardException.newException
+                        ( SQLState.LANG_BAD_UDA_OR_FUNCTION_NAME, schemaName, aliasName );
+                }
+			}
+            
+            break;
+            
 		case AliasInfo.ALIAS_TYPE_UDT_AS_CHAR:
 
             AliasDescriptor duplicateUDT = dd.getAliasDescriptor( sd.getUUID().toString(), aliasName, nameSpace );
@@ -232,28 +265,31 @@ public void	executeConstantAction( Activation activation )
             break;
             
 		case AliasInfo.ALIAS_TYPE_PROCEDURE_AS_CHAR:
-		case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:
-		{
 
-			java.util.List list = dd.getRoutineList(
-				sd.getUUID().toString(), aliasName, aliasType);
-			for (int i = list.size() - 1; i >= 0; i--) {
+            vetRoutine( dd, sd, ads );
+            break;
+
+		case AliasInfo.ALIAS_TYPE_FUNCTION_AS_CHAR:
 
-				AliasDescriptor proc = (AliasDescriptor) list.get(i);
+            vetRoutine( dd, sd, ads );
 
-				RoutineAliasInfo procedureInfo = (RoutineAliasInfo) proc.getAliasInfo();
-				int parameterCount = procedureInfo.getParameterCount();
-				if (parameterCount != ((RoutineAliasInfo) aliasInfo).getParameterCount())
-					continue;
+            // if this is a 1-arg function, make sure there isn't an aggregate
+            // by the same qualified name
 
-				// procedure duplicate checking is simple, only
-				// one procedure with a given number of parameters.
-				throw StandardException.newException(SQLState.LANG_OBJECT_ALREADY_EXISTS,
-												ads.getDescriptorType(),
-												aliasName);
+            int paramCount = ((RoutineAliasInfo) aliasInfo).getParameterCount();
+            if ( paramCount == 1 )
+            {
+                AliasDescriptor aliasCollision = dd.getAliasDescriptor
+                    ( sd.getUUID().toString(), aliasName, AliasInfo.ALIAS_NAME_SPACE_AGGREGATE_AS_CHAR );
+                if ( aliasCollision != null )
+                {
+                    throw StandardException.newException
+                        ( SQLState.LANG_BAD_UDA_OR_FUNCTION_NAME, schemaName, aliasName );
 			}
 		}
+            
 		break;
+
 		case AliasInfo.ALIAS_TYPE_SYNONYM_AS_CHAR:
 			// If target table/view exists already, error.
 			TableDescriptor targetTD = dd.getTableDescriptor(aliasName, sd, tc);
@@ -316,4 +352,36 @@ public void	executeConstantAction( Activation activation )
 
         adjustUDTDependencies( lcc, dd, ads, true );
 	}
+
+    /** Common checks to be performed for functions and procedures */
+    private void    vetRoutine
+        (
+         DataDictionary dd,
+         SchemaDescriptor sd,
+         AliasDescriptor ads
+         )
+        throws StandardException
+    {
+        java.util.List list = dd.getRoutineList( sd.getUUID().toString(), aliasName, aliasType );
+        
+        for (int i = list.size() - 1; i >= 0; i--)
+        {
+            AliasDescriptor proc = (AliasDescriptor) list.get(i);
+            
+            RoutineAliasInfo procedureInfo = (RoutineAliasInfo) proc.getAliasInfo();
+            int parameterCount = procedureInfo.getParameterCount();
+            if (parameterCount != ((RoutineAliasInfo) aliasInfo).getParameterCount())
+            { continue; }
+            
+            // procedure duplicate checking is simple, only
+            // one procedure with a given number of parameters.
+            throw StandardException.newException
+                (
+                 SQLState.LANG_OBJECT_ALREADY_EXISTS,
+                 ads.getDescriptorType(),
+                 aliasName
+                 );
+        }
+    }
+        
 }
diff --git a/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java b/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java
index 8e86a977..16ecdcb3 100644
--- a/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java
+++ b/db/derby/code/trunk/java/shared/org/apache/derby/shared/common/reference/SQLState.java
@@ -1124,6 +1124,8 @@ The message identifier (ie. the value that matches a field in this class)
 	String LANG_WINDOW_LIMIT_EXCEEDED                                  = "42ZC1";
 	String LANG_WINDOW_FUNCTION_CONTEXT_ERROR                          = "42ZC2";
 
+	String LANG_ILLEGAL_UDA_NAME                                  = "42ZC3";
+
 	//following 3 matches the DB2 sql states
 	String LANG_DECLARED_GLOBAL_TEMP_TABLE_ONLY_IN_SESSION_SCHEMA = "428EK";
 	String LANG_NOT_ALLOWED_FOR_DECLARED_GLOBAL_TEMP_TABLE = "42995";
@@ -1370,6 +1372,7 @@ The message identifier (ie. the value that matches a field in this class)
     String LANG_TOO_MUCH_CONTENTION_ON_SEQUENCE                 = "X0Y84.T";
 	String LANG_UNKNOWN_SEQUENCE_PREALLOCATOR                                = "X0Y85.S";
 	String LANG_CANT_FLUSH_PREALLOCATOR                                = "X0Y86.S";
+	String LANG_BAD_UDA_OR_FUNCTION_NAME                                = "X0Y87.S";
 
 
 	// TEMPORARY EXECUTION RESTRICTIONS
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/UserDefinedAggregatesTest.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/UserDefinedAggregatesTest.java
index e69de29b..5ebb8682 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/UserDefinedAggregatesTest.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/UserDefinedAggregatesTest.java
@@ -0,0 +1,296 @@
+/*
+
+   Derby - Class org.apache.derbyTesting.functionTests.tests.lang.UserDefinedAggregatesTest
+
+   Licensed to the Apache Software Foundation (ASF) under one or more
+   contributor license agreements.  See the NOTICE file distributed with
+   this work for additional information regarding copyright ownership.
+   The ASF licenses this file to you under the Apache License, Version 2.0
+   (the "License"); you may not use this file except in compliance with
+   the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
+ */
+
+package org.apache.derbyTesting.functionTests.tests.lang;
+
+import java.sql.CallableStatement;
+import java.sql.Connection;
+import java.sql.DriverManager;
+import java.sql.ParameterMetaData;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.ResultSetMetaData;
+import java.util.HashMap;
+
+import junit.framework.Test;
+import org.apache.derbyTesting.junit.TestConfiguration;
+import org.apache.derbyTesting.junit.JDBC;
+
+/**
+ * <p>
+ * Test user defined aggregates. See DERBY-672.
+ * </p>
+ */
+public class UserDefinedAggregatesTest  extends GeneratedColumnsHelper
+{
+    ///////////////////////////////////////////////////////////////////////////////////
+    //
+    // CONSTANTS
+    //
+    ///////////////////////////////////////////////////////////////////////////////////
+
+    public static final String OBJECT_EXISTS = "X0Y68";
+    public static final String ILLEGAL_AGGREGATE = "42ZC3";
+    public static final String NAME_COLLISION = "X0Y87";
+
+    ///////////////////////////////////////////////////////////////////////////////////
+    //
+    // STATE
+    //
+    ///////////////////////////////////////////////////////////////////////////////////
+
+    ///////////////////////////////////////////////////////////////////////////////////
+    //
+    // CONSTRUCTOR
+    //
+    ///////////////////////////////////////////////////////////////////////////////////
+
+
+    /**
+     * Create a new instance.
+     */
+
+    public UserDefinedAggregatesTest(String name)
+    {
+        super(name);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////////
+    //
+    // JUnit BEHAVIOR
+    //
+    ///////////////////////////////////////////////////////////////////////////////////
+
+
+    /**
+     * Construct top level suite in this JUnit test
+     */
+    public static Test suite()
+    {
+        return TestConfiguration.defaultSuite(UserDefinedAggregatesTest.class);
+    }
+
+    ///////////////////////////////////////////////////////////////////////////////////
+    //
+    // TESTS
+    //
+    ///////////////////////////////////////////////////////////////////////////////////
+
+    /**
+     * <p>
+     * Basic syntax.
+     * </p>
+     */
+    public void test_01_basicSyntax() throws Exception
+    {
+        Connection conn = getConnection();
+
+        goodStatement( conn, "create schema uda_schema\n" );
+        goodStatement( conn, "create schema uda_schema2\n" );
+        goodStatement( conn, "create schema uda_schema3\n" );
+
+        // some good aggregate creations
+        goodStatement( conn, "create derby aggregate mode for int external name 'foo.bar.Wibble'" );
+        goodStatement( conn, "create derby aggregate uda_schema.mode2 for int external name 'foo.bar.Wibble'" );
+
+        // can't create an aggregate with an existing name
+        expectExecutionError
+            ( conn, OBJECT_EXISTS, "create derby aggregate mode for int external name 'foo.bar.Wibble'" );
+        expectExecutionError
+            ( conn, OBJECT_EXISTS, "create derby aggregate uda_schema.mode2 for int external name 'foo.bar.Wibble'" );
+        
+        // only RESTRICTed drops allowed now
+        expectCompilationError( SYNTAX_ERROR, "drop derby aggregate mode" );
+
+        // successfully drop an aggregate
+        goodStatement( conn, "drop derby aggregate mode restrict" );
+
+        // can't create an aggregate with the same name as a 1-arg function
+        // but no collision with 2-arg function names
+        goodStatement
+            ( conn, "create function uda_schema3.agg_collide( a int ) returns int language\n" +
+              "java parameter style java external name 'Foo.f'" );
+        goodStatement
+            ( conn, "create function uda_schema3.agg_nocollide( a int, b int ) returns int language java\n" +
+              "parameter style java external name 'Foo.f'" );
+        expectExecutionError
+            ( conn, NAME_COLLISION, "create derby aggregate uda_schema3.agg_collide for int external name 'foo.bar.Wibble'" );
+        goodStatement
+            ( conn, "create derby aggregate uda_schema3.agg_nocollide for int external name 'foo.bar.Wibble'" );
+
+        goodStatement
+            ( conn, "create function agg_collide( a int ) returns int language java parameter style java external name 'Foo.f'" );
+        goodStatement
+            ( conn, "create function agg_nocollide( a int, b int ) returns int language java parameter style java external name 'Foo.f'" );
+        expectExecutionError( conn, NAME_COLLISION, "create derby aggregate agg_collide for int external name 'foo.bar.Wibble'" );
+        goodStatement( conn, "create derby aggregate agg_nocollide for int external name 'foo.bar.Wibble'" );
+
+        // can't create a 1-arg function with same name as an aggregate
+        goodStatement
+            ( conn, "create derby aggregate func_collide for int external name 'foo.bar.Wibble'" );
+        goodStatement
+            ( conn, "create derby aggregate func_nocollide for int external name 'foo.bar.Wibble'" );
+        expectExecutionError
+            ( conn, NAME_COLLISION,
+              "create function func_collide( a int ) returns int language java parameter style java external name 'Foo.f'" );
+        goodStatement
+            ( conn, "create function func_nocollide( a int, b int ) returns int language java parameter style java external name 'Foo.f'" );
+        
+        goodStatement
+            ( conn, "create derby aggregate uda_schema3.func_collide for int external name 'foo.bar.Wibble'" );
+        goodStatement
+            ( conn, "create derby aggregate uda_schema3.func_nocollide for int external name 'foo.bar.Wibble'" );
+        expectExecutionError
+            ( conn, NAME_COLLISION,
+              "create function uda_schema3.func_collide( a int ) returns int language java parameter style java external name 'Foo.f'" );
+        goodStatement
+            ( conn, "create function uda_schema3.func_nocollide( a int, b int ) returns int language\n" +
+              "java parameter style java external name 'Foo.f'" );
+        
+        // can't drop a schema which still has an aggregate in it
+        expectExecutionError( conn, NON_EMPTY_SCHEMA, "drop schema uda_schema restrict" );
+
+        // drop the aggregate, then drop the schema
+        goodStatement( conn, "drop derby aggregate uda_schema.mode2 restrict" );
+        goodStatement( conn, "drop schema uda_schema restrict" );
+
+        // can't drop a non-existent aggregate
+        expectCompilationError( NONEXISTENT_OBJECT, "drop derby aggregate mode restrict" );
+        expectCompilationError( NONEXISTENT_OBJECT, "drop derby aggregate mode1 restrict" );
+        expectCompilationError( NONEXISTENT_OBJECT, "drop derby aggregate uda_schema2.mode restrict" );
+    }
+
+    /**
+     * <p>
+     * Don't allow aggregates to have the names of builtin functions with 1 argument.
+     * See also DERBY-5901.
+     * </p>
+     */
+    public void test_02_builtinConflicts() throws Exception
+    {
+        Connection conn = getConnection();
+
+        // 1 argument bad
+        badAggregate( conn, ILLEGAL_AGGREGATE, "abs" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "absval" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "acos" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "asin" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "atan" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "ceil" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "ceiling" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "cos" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "cosh" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "cot" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "date" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "day" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "degrees" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "exp" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "floor" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "lcase" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "length" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "ln" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "log" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "log10" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "month" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "radians" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "rand" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "sign" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "sin" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "sinh" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "sqrt" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "tan" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "tanh" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "time" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "timestamp" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "ucase" );
+
+        // no conflict with 2 argument builtin functions
+        goodStatement( conn, "create derby aggregate locate for int external name 'foo.bar.Wibble'" );
+        goodStatement( conn, "drop derby aggregate locate restrict" );
+    }
+    private void    badAggregate( Connection conn, String expectedSQLState, String name ) throws Exception
+    {
+        String  ddl = "create derby aggregate " + name + " for int external name 'foo.bar.Wibble'";
+        
+        expectCompilationError( expectedSQLState, ddl );
+    }
+
+    /**
+     * <p>
+     * Various 1-arg operators and SQL aggregates should not be legal aggregate names because they
+     * are supposed to be reserved keywords.
+     * See also DERBY-5901.
+     * </p>
+     */
+    public void test_03_keywordConflicts() throws Exception
+    {
+        Connection conn = getConnection();
+
+        // 1-arg functions which are reserved keywords
+        badAggregate( conn, SYNTAX_ERROR, "bigint" );
+        badAggregate( conn, SYNTAX_ERROR, "char" );
+        badAggregate( conn, SYNTAX_ERROR, "double" );
+        badAggregate( conn, SYNTAX_ERROR, "hour" );
+        badAggregate( conn, SYNTAX_ERROR, "integer" );
+        badAggregate( conn, SYNTAX_ERROR, "ltrim" );
+        badAggregate( conn, SYNTAX_ERROR, "lower" );
+        badAggregate( conn, SYNTAX_ERROR, "minute" );
+        badAggregate( conn, SYNTAX_ERROR, "rtrim" );
+        badAggregate( conn, SYNTAX_ERROR, "second" );
+        badAggregate( conn, SYNTAX_ERROR, "smallint" );
+        badAggregate( conn, SYNTAX_ERROR, "trim" );
+        badAggregate( conn, SYNTAX_ERROR, "upper" );
+        badAggregate( conn, SYNTAX_ERROR, "varchar" );
+        badAggregate( conn, SYNTAX_ERROR, "year" );
+
+        // SQL aggregates which are reserved keywords
+        badAggregate( conn, SYNTAX_ERROR, "any" );
+        badAggregate( conn, SYNTAX_ERROR, "avg" );        
+        badAggregate( conn, SYNTAX_ERROR, "max" );        
+        badAggregate( conn, SYNTAX_ERROR, "min" );        
+        badAggregate( conn, SYNTAX_ERROR, "some" );
+        badAggregate( conn, SYNTAX_ERROR, "sum" );        
+    }
+
+    /**
+     * <p>
+     * Various aggregates defined by the SQL Standard do not appear in the Derby
+     * grammar as reserved keywords. They are, nonetheless, illegal as the names
+     * of user-defined aggregates.
+     * See also DERBY-5901.
+     * </p>
+     */
+    public void test_04_nonReservedAggregateConflicts() throws Exception
+    {
+        Connection conn = getConnection();
+
+        badAggregate( conn, ILLEGAL_AGGREGATE, "collect" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "count" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "every" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "fusion" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "intersection" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "stddev_pop" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "stddev_samp" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "var_pop" );
+        badAggregate( conn, ILLEGAL_AGGREGATE, "var_samp" );
+    }
+
+}
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java
index cb7b51bb..54472f8f 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/lang/_Suite.java
@@ -207,6 +207,7 @@ public static Test suite() {
         suite.addTest(RestrictedVTITest.suite());
         suite.addTest(UDTTest.suite());
         suite.addTest(UDTPermsTest.suite());
+        suite.addTest(UserDefinedAggregatesTest.suite());
         suite.addTest(BooleanValuesTest.suite());
         suite.addTest(AlterColumnTest.suite());
         suite.addTest(UserLobTest.suite());
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_10.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_10.java
index 04415aa4..a49fa7f7 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_10.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/functionTests/tests/upgradeTests/Changes10_10.java
@@ -57,6 +57,9 @@ Licensed to the Apache Software Foundation (ASF) under one or more
     //
     ///////////////////////////////////////////////////////////////////////////////////
 
+    private static  final   String  SYNTAX_ERROR = "42X01";
+    private static  final   String  HARD_UPGRADE_REQUIRED = "XCL47";
+
     ///////////////////////////////////////////////////////////////////////////////////
     //
     // STATE
@@ -164,4 +167,37 @@ private void    vetProcs( Statement s, String procCall,
             }
         }
     }
+
+    /**
+     * Verify upgrade behavior for user-defined aggregates.
+     */
+    public  void    testUDAs()  throws Exception
+    {
+        Statement st = createStatement();
+
+        String  createUDA = "create derby aggregate mode for int external name 'foo.bar.Wibble'";
+        String  dropUDA = "drop derby aggregate mode restrict";
+
+        switch ( getPhase() )
+        {
+        case PH_CREATE: // create with old version
+        case PH_POST_SOFT_UPGRADE: // soft-downgrade: boot with old version after soft-upgrade
+            assertStatementError( SYNTAX_ERROR, st, createUDA );
+            assertStatementError( SYNTAX_ERROR, st, dropUDA );
+            break;
+            
+        case PH_SOFT_UPGRADE: // boot with new version and soft-upgrade
+            assertStatementError( HARD_UPGRADE_REQUIRED, st, createUDA );
+            assertStatementError( HARD_UPGRADE_REQUIRED, st, dropUDA );
+            break;
+            
+        case PH_HARD_UPGRADE: // boot with new version and hard-upgrade
+            st.execute( createUDA );
+            st.execute( dropUDA );
+            break;
+        }
+        
+        st.close();
+    }
+    
 }
diff --git a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/junit/JDBC.java b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/junit/JDBC.java
index 9d1d0d11..139358b9 100644
--- a/db/derby/code/trunk/java/testing/org/apache/derbyTesting/junit/JDBC.java
+++ b/db/derby/code/trunk/java/testing/org/apache/derbyTesting/junit/JDBC.java
@@ -323,6 +323,12 @@ public static void dropSchema(DatabaseMetaData dmd, String schema) throws SQLExc
         psf.setString(2, schema);
         rs = psf.executeQuery();
         dropUsingDMD(s, rs, schema, "ALIAS", "TYPE");        
+  
+        // drop aggregates
+        psf.setString(1, "G" );
+        psf.setString(2, schema);
+        rs = psf.executeQuery();
+        dropUsingDMD(s, rs, schema, "ALIAS", "DERBY AGGREGATE");        
         psf.close();
   
         // Synonyms - need work around for DERBY-1790 where
@@ -407,7 +413,12 @@ private static void dropUsingDMD(
 		{
             String objectName = rs.getString(mdColumn);
             String raw = dropLeadIn + JDBC.escape(schema, objectName);
-            if ( "TYPE".equals( dropType )  || "SEQUENCE".equals( dropType ) ) { raw = raw + " restrict "; }
+            if (
+                "TYPE".equals( dropType )  ||
+                "SEQUENCE".equals( dropType ) ||
+                "DERBY AGGREGATE".equals( dropType )
+                )
+            { raw = raw + " restrict "; }
             ddl.add( raw );
 		}
 		rs.close();
diff --git a/db/derby/code/trunk/java/tools/org/apache/derby/impl/tools/dblook/DB_Alias.java b/db/derby/code/trunk/java/tools/org/apache/derby/impl/tools/dblook/DB_Alias.java
index 61627e0a..1f4bbcfd 100644
--- a/db/derby/code/trunk/java/tools/org/apache/derby/impl/tools/dblook/DB_Alias.java
+++ b/db/derby/code/trunk/java/tools/org/apache/derby/impl/tools/dblook/DB_Alias.java
@@ -33,6 +33,7 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 public class DB_Alias
 {
+    private static final char AGGREGATE_TYPE = 'G';
     private static final char UDT_TYPE = 'A';
     private static final char PROCEDURE_TYPE = 'P';
     private static final char FUNCTION_TYPE = 'F';
@@ -42,13 +43,13 @@ Licensed to the Apache Software Foundation (ASF) under one or more
 
 	/* ************************************************
 	 * Generate the DDL for all stored procedures,
-	 * functions, and UDTs in a given database and write it to
+	 * functions, aggregates, and UDTs in a given database and write it to
 	 * output via Logs.java.
 	 * @param conn Connection to the source database.
 	 * @param at10_6 True if the database is at 10.6 or higher
 	 ****/
 
-	public static void doProceduresFunctionsAndUDTs(Connection conn, boolean at10_6 )
+	public static void doPFAU(Connection conn, boolean at10_6 )
 		throws SQLException {
 
 		// First do stored procedures.
@@ -59,7 +60,7 @@ public static void doProceduresFunctionsAndUDTs(Connection conn, boolean at10_6
              "WHERE ALIASTYPE=?");
 
         //
-        // UDTs come before procedures and functions right now because
+        // UDTs come before procedures, functions, and aggregates right now because
         // procedures and functions can have args and return values which
         // have UDT types. If we add functions to the signatures of UDTs,
         // then we will have to do some trickier dependency analysis in order
@@ -72,6 +73,7 @@ public static void doProceduresFunctionsAndUDTs(Connection conn, boolean at10_6
         }
         generateDDL( ps, PROCEDURE_TYPE );	// PROCEDURE_TYPE => for PROCEDURES
 		generateDDL( ps, FUNCTION_TYPE );	// FUNCTION_TYPE => for FUNCTIONS
+		generateDDL( ps, AGGREGATE_TYPE );
 
         ps.close();
 
@@ -131,6 +133,7 @@ private static void generateDDL(ResultSet rs, char aliasType)
                 case UDT_TYPE: Logs.reportMessage( "DBLOOK_UDTHeader" ); break;
                 case PROCEDURE_TYPE: Logs.reportMessage( "DBLOOK_StoredProcHeader" ); break;
                 case FUNCTION_TYPE: Logs.reportMessage( "DBLOOK_FunctionHeader" ); break;
+                case AGGREGATE_TYPE: Logs.reportMessage( "DBLOOK_AggregateHeader" ); break;
                 }
 				Logs.reportString("----------------------------------------------\n");
 			}
@@ -140,7 +143,7 @@ private static void generateDDL(ResultSet rs, char aliasType)
 				dblook.expandDoubleQuotes(aliasName));
 			fullName = procSchema + "." + fullName;
 
-			String creationString = createProcFuncOrUDTString(
+			String creationString = createPFAUString(
 				fullName, rs, aliasType);
 			Logs.writeToNewDDL(creationString);
 			Logs.writeStmtEndToNewDDL();
@@ -162,7 +165,7 @@ private static void generateDDL(ResultSet rs, char aliasType)
 	 *   returned, as a String.
 	 ****/
 
-	private static String createProcFuncOrUDTString(String aliasName,
+	private static String createPFAUString(String aliasName,
 		ResultSet aliasInfo, char aliasType) throws SQLException
 	{
 
@@ -173,13 +176,19 @@ private static String createProcFuncOrUDTString(String aliasName,
         case UDT_TYPE: alias.append( "TYPE " ); break;
         case PROCEDURE_TYPE: alias.append("PROCEDURE "); break;
         case FUNCTION_TYPE: alias.append("FUNCTION "); break;
+        case AGGREGATE_TYPE: alias.append("DERBY AGGREGATE "); break;
         }
 		alias.append(aliasName);
 		alias.append(" ");
 
 		String params = aliasInfo.getString(2);
 
-        if ( aliasType != UDT_TYPE )
+        if ( aliasType == AGGREGATE_TYPE )
+        {
+            alias.append( params );
+            alias.append( " " );
+        }
+        else if ( aliasType != UDT_TYPE )
         {
             // Just grab the parameter part; we'll get the method name later.
             alias.append(params.substring(params.indexOf("("), params.length()));
@@ -195,7 +204,11 @@ private static String createProcFuncOrUDTString(String aliasName,
             alias.append("' ");
             alias.append( params );
         }
-        else
+        else if ( aliasType == AGGREGATE_TYPE )
+        {
+            alias.append("' ");
+        }
+        else if ( aliasType != AGGREGATE_TYPE )
         {
             alias.append(".");
             // Get method name from parameter string fetched above.
diff --git a/db/derby/code/trunk/java/tools/org/apache/derby/tools/dblook.java b/db/derby/code/trunk/java/tools/org/apache/derby/tools/dblook.java
index 361a267e..339ccabc 100644
--- a/db/derby/code/trunk/java/tools/org/apache/derby/tools/dblook.java
+++ b/db/derby/code/trunk/java/tools/org/apache/derby/tools/dblook.java
@@ -532,7 +532,7 @@ private void go()
 			if (tableList == null) {
 			// Don't do these if user just wants table-related objects.
                 DB_Jar.doJars(sourceDBName, this.conn, at10_9);
-				DB_Alias.doProceduresFunctionsAndUDTs(this.conn, at10_6 );
+				DB_Alias.doPFAU(this.conn, at10_6 );
 			}
 
 			DB_Table.doTables(this.conn, tableIdToNameMap);
