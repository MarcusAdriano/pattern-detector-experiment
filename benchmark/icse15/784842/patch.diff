diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/ChecksumManager.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/ChecksumManager.java
index d9b3fae6..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/ChecksumManager.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/ChecksumManager.java
@@ -1,475 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.cassandra.io;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.lang.reflect.Method;
-import java.nio.MappedByteBuffer;
-import java.nio.channels.FileChannel;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-import java.util.zip.Adler32;
-
-import org.apache.cassandra.config.DatabaseDescriptor;
-import org.apache.cassandra.utils.FileUtils;
-import org.apache.cassandra.utils.LogUtil;
-import org.apache.log4j.Logger;
-
-/**
- * This class manages the persistence of checksums and keeps
- * them in memory. It maintains a mapping of data files on
- * disk to their corresponding checksum files. It is also
- * loads the checksums in memory on start up.
- * 
- * @author alakshman
- *
- */
-public class ChecksumManager
-{    
-    private static Logger logger_ = Logger.getLogger(ChecksumManager.class);
-    /* Keeps a mapping of checksum manager instances to data file */
-    private static Map<String, ChecksumManager> chksumMgrs_ = new HashMap<String, ChecksumManager>();
-    private static Lock lock_ = new ReentrantLock();
-    private static final String checksumPrefix_ = "Checksum-";
-    private static final int bufferSize_ = 8*1024*1024;
-    private static final long chunkMask_ = 0x00000000FFFFFFFFL;
-    private static final long fileIdMask_ = 0x7FFFFFFF00000000L;
-    /* Map where checksums are cached. */
-    private static Map<Long, Long> chksums_ = new HashMap<Long, Long>();
-
-    public static ChecksumManager instance(String dataFile) throws IOException
-    {
-        ChecksumManager chksumMgr = chksumMgrs_.get(dataFile);
-        if ( chksumMgr == null )
-        {
-            lock_.lock();
-            try
-            {
-                if ( chksumMgr == null )
-                {
-                    chksumMgr = new ChecksumManager(dataFile);
-                    chksumMgrs_.put(dataFile, chksumMgr);
-                }
-            }
-            finally
-            {
-                lock_.unlock();
-            }
-        }
-        return chksumMgr;
-    }
-    
-    /* TODO: Debug only */
-    public static ChecksumManager instance(String dataFile, String chkSumFile) throws IOException
-    {
-        ChecksumManager chksumMgr = chksumMgrs_.get(dataFile);
-        if ( chksumMgr == null )
-        {
-            lock_.lock();
-            try
-            {
-                if ( chksumMgr == null )
-                {
-                    chksumMgr = new ChecksumManager(dataFile, chkSumFile);
-                    chksumMgrs_.put(dataFile, chksumMgr);
-                }
-            }
-            finally
-            {
-                lock_.unlock();
-            }
-        }
-        return chksumMgr;
-    }
-    
-    /**
-     * This method returns true if the file specified is a 
-     * checksum file and false otherwise.
-     * 
-     * @param file we are interested in.
-     * @return true if checksum file false otherwise.
-     */
-    public static boolean isChecksumFile(String file)
-    {
-        return file.contains(ChecksumManager.checksumPrefix_);
-    }
-    
-    /**
-     * On start read all the check sum files on disk and
-     * pull them into memory.
-     * @throws IOException
-     */
-    public static void onStart() throws IOException
-    {
-        String[] directories = DatabaseDescriptor.getAllDataFileLocations(); 
-        List<File> allFiles = new ArrayList<File>();
-        for ( String directory : directories )
-        {
-            File file = new File(directory);
-            File[] files = file.listFiles();
-            for ( File f : files )
-            {
-                if ( f.getName().contains(ChecksumManager.checksumPrefix_) )
-                {
-                    allFiles.add(f);
-                }
-            }
-        }
-        
-        for ( File file : allFiles )
-        {                           
-            int fId = ChecksumManager.getChecksumFileId(file.getName());
-            RandomAccessFile chksumRdr = new RandomAccessFile(file, "r");            
-            long size = chksumRdr.length();
-            int chunk = 0;
-            
-            while ( chksumRdr.getFilePointer() != size )
-            {
-                long value = chksumRdr.readLong();
-                long key = ChecksumManager.key(fId, ++chunk);
-                chksums_.put(key, value);
-            }
-        }
-    }
-    
-    /**
-     * On delete of this dataFile remove the checksums associated with
-     * this file from memory, remove the check sum manager instance.
-     * 
-     * @param dataFile data file that is being deleted.
-     * @throws IOException
-     */
-    public static void onFileDelete(String dataFile) throws IOException
-    {
-        File f = new File(dataFile);
-        long size = f.length();
-        int fileId = ChecksumManager.getFileId(f.getName());
-        int chunks = (int)(size >> 16L);
-        
-        for ( int i = 0; i < chunks; ++i )
-        {
-            long key = ChecksumManager.key(fileId, i);
-            chksums_.remove(key);
-        }
-        
-        /* remove the check sum manager instance */
-        chksumMgrs_.remove(dataFile);
-        String chksumFile = ChecksumManager.constructChksumFileNameFromDataFileName(f);
-        FileUtils.delete(chksumFile);
-    }
-    
-    private static long key(int fileId, int chunkId)
-    {
-        long key = 0;
-        key |= fileId;
-        key <<= 32;
-        key |= chunkId;
-        return key;
-    }
-    
-    public static int getFileId(String file)
-    {
-        String filename = new File(file).getName();
-        /*
-         * File name is of the form <table>-<column family>-<index>-Data.db.
-         * Always split and then use the value which is at index length - 2.
-         */
-        String[] peices = filename.split("-");
-        return Integer.parseInt( peices[peices.length - 2] );
-    }
-    
-    static void close(String dataFile) throws IOException
-    {
-        ChecksumManager.chksumMgrs_.get(dataFile).close();
-    }
-    
-    private static int getChecksumFileId(String file)
-    {
-        String filename = new File(file).getName();
-        /*
-         * File name is of the form <table>-<column family>-Checksum-<index>.db.
-         * This tokenizer will strip the .db portion.
-         */
-        String[] peices = filename.split("-");
-        return Integer.parseInt( peices[3] );
-    }
-    
-    private static String constructChksumFileNameFromDataFileName(File file)
-    {
-        String directory = file.getParent();
-        String f = file.getName();
-        /* we need the table and the column family name. */
-        String[] peices = f.split("-");
-        /* we need the index part of the file name */
-        int fId = ChecksumManager.getFileId(f);
-        String chkSumFile = directory + System.getProperty("file.separator") + peices[0] + "-" + peices[1] + "-" + checksumPrefix_ + fId + "-" + "Data" + ".db";
-        return chkSumFile;
-    }
-    
-    private RandomAccessFile raf_;
-    private Adler32 adler_ = new Adler32();
-    
-    ChecksumManager(String dataFile) throws IOException
-    {
-        File file = new File(dataFile);
-        String chkSumFile = ChecksumManager.constructChksumFileNameFromDataFileName(file);
-        raf_ = new BufferedRandomAccessFile(chkSumFile, "rw");
-    }
-    
-    /* TODO: Remove later. */
-    ChecksumManager(String dataFile, String chkSumFile) throws IOException
-    {
-        File file = new File(dataFile);
-        String directory = file.getParent();
-        String f = file.getName();
-        int fId = ChecksumManager.getFileId(f);        
-        raf_ = new BufferedRandomAccessFile(chkSumFile, "rw");
-        
-        file = new File(chkSumFile);        
-        ChecksumReader chksumRdr = new ChecksumReader(file.getAbsolutePath(), 0L, file.length());
-                    
-        int chunk = 0;
-        while ( !chksumRdr.isEOF() )
-        {
-            long value = chksumRdr.readLong();
-            long key = ChecksumManager.key(fId, ++chunk);
-            chksums_.put(key, value);
-        }
-    }
-    
-    /**
-     * Log the checksum for the the specified file and chunk
-     * within the file.
-     * @param fileId id associated with the file
-     * @param chunkId chunk within the file.
-     * @param buffer for which the checksum needs to be calculated.
-     * @throws IOException
-     */
-    void logChecksum(int fileId, int chunkId, byte[] buffer)
-    {
-        logChecksum(fileId, chunkId, buffer, 0, buffer.length);
-    }
-    
-    /**
-     * Log the checksum for the the specified file and chunk
-     * within the file.
-     * @param fileId id associated with the file
-     * @param chunkId chunk within the file.
-     * @param buffer for which the checksum needs to be calculated.
-     * @param startoffset offset to start within the buffer
-     * @param length size of the checksum buffer.
-     * @throws IOException
-     */
-    void logChecksum(int fileId, int chunkId, byte[] buffer, int startOffset, int length)
-    {
-        try
-        {            
-            adler_.update(buffer, startOffset, length);
-            long chksum = adler_.getValue();
-            adler_.reset();
-            /* log checksums to disk */
-            raf_.writeLong(chksum);
-            /* add the chksum to memory */
-            long key = ChecksumManager.key(fileId, chunkId);
-            chksums_.put(key, chksum);
-        }
-        catch ( IOException ex )
-        {
-            logger_.warn( LogUtil.throwableToString(ex) );
-        }
-    }
-    
-    /**
-     * Validate checksums for the data in the buffer.
-     * @file name of the file from which data is being
-     *       read.
-     * @chunkId chunkId
-     * @param buffer with data for which checksum needs to be 
-     *        verified.
-     * @throws IOException
-     */
-    void validateChecksum(String file, int chunkId, byte[] buffer) throws IOException
-    {                
-        validateChecksum(file, chunkId, buffer, 0, buffer.length);
-    }
-    
-    /**
-     * Validate checksums for the data in the buffer for the region
-     * that is encapsulated in the section object
-     * @file name of the file from which data is being
-     *       read.
-     * @chunkId chunkId     
-     * @param buffer with data for which checksum needs to be 
-     *        verified.
-     * @param startOffset within the buffer
-     * @param length of the data whose checksum needs to be verified.
-     * @throws IOException
-     */
-    void validateChecksum(String file, int chunkId, byte[] buffer, int startOffset, int length) throws IOException
-    {            
-        int fId = ChecksumManager.getFileId(file);
-        long key = ChecksumManager.key(fId, chunkId);
-        adler_.update(buffer, startOffset, length);
-        long currentChksum = adler_.getValue();
-        adler_.reset();
-        long oldChksum = chksums_.get(key);
-        if ( currentChksum != oldChksum )
-        {                                   
-            throw new IOException("Checksums do not match in file " + file + " for chunk " + chunkId + ".");
-        }        
-    }
-    
-    
-    /**
-     * Get the checksum for the specified file's chunk
-     * @param fileId id associated with the file.
-     * @param chunkId chunk within the file.
-     * @return associated checksum for the chunk
-     */
-    long getChecksum(int fileId, int chunkId)
-    {        
-        long key = ChecksumManager.key(fileId, chunkId);
-        return chksums_.get(key);
-    }
-    
-    /**
-     * Close the file handler.
-     * 
-     * @throws IOException
-     */
-    void close() throws IOException
-    {
-        raf_.close();
-    }
-    
-    public static void main(String[] args) throws Throwable
-    {
-        ChecksumReader rdr = new ChecksumReader("C:\\Engagements\\Cassandra\\Checksum-1.db");
-        while ( !rdr.isEOF() )
-        {
-            System.out.println(rdr.readLong());
-        }
-        rdr.close();
-    }
-}
-
-/**
- * ChecksumReader is used to memory map the checksum files and
- * load the data into memory.
- * 
- * @author alakshman
- *
- */
-class ChecksumReader 
-{
-    private static Logger logger_ = Logger.getLogger(ChecksumReader.class);
-    private String filename_;
-    private MappedByteBuffer buffer_;
-
-    ChecksumReader(String filename) throws IOException
-    {
-        filename_ = filename;
-        File f = new File(filename);
-        map(0, f.length());
-    }
-    
-    ChecksumReader(String filename, long start, long end) throws IOException
-    {        
-        filename_ = filename;
-        map(start, end);
-    }
-
-    public void map() throws IOException
-    {
-        RandomAccessFile file = new RandomAccessFile(filename_, "rw");
-        try
-        {
-            buffer_ = file.getChannel().map(FileChannel.MapMode.READ_ONLY, 0, file.length() );
-            buffer_.load();
-        }
-        finally
-        {
-            file.close();
-        }
-    }
-
-    public void map(long start, long end) throws IOException
-    {
-        if ( start < 0 || end < 0 || end < start )
-            throw new IllegalArgumentException("Invalid values for start and end.");
-
-        RandomAccessFile file = new RandomAccessFile(filename_, "rw");
-        try
-        {
-            if ( end == 0 )
-                end = file.length();
-            buffer_ = file.getChannel().map(FileChannel.MapMode.READ_ONLY, start, end);
-            buffer_.load();
-        }
-        finally
-        {
-            file.close();
-        }
-    }
-
-    void unmap(final Object buffer)
-    {
-        AccessController.doPrivileged( new PrivilegedAction<MappedByteBuffer>()
-                {
-            public MappedByteBuffer run()
-            {
-                try
-                {
-                    Method getCleanerMethod = buffer.getClass().getMethod("cleaner", new Class[0]);
-                    getCleanerMethod.setAccessible(true);
-                    sun.misc.Cleaner cleaner = (sun.misc.Cleaner)getCleanerMethod.invoke(buffer,new Object[0]);
-                    cleaner.clean();
-                }
-                catch(Throwable e)
-                {
-                    logger_.debug( LogUtil.throwableToString(e) );
-                }
-                return null;
-            }
-                });
-    }
-    
-    public long readLong() throws IOException
-    {
-        return buffer_.getLong();
-    }
-    
-    public boolean isEOF()
-    {
-        return ( buffer_.remaining() == 0 );
-    }
-
-    
-    public void close() throws IOException
-    {
-        unmap(buffer_);
-    }
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/ChecksumRandomAccessFile.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/ChecksumRandomAccessFile.java
index 347b2467..e69de29b 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/ChecksumRandomAccessFile.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/ChecksumRandomAccessFile.java
@@ -1,456 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.cassandra.io;
-
-import java.io.*;
-import java.util.Arrays;
-import java.util.Random;
-
-import org.apache.cassandra.utils.FBUtilities;
-
-
-/**
- * A <code>ChecksumRandomAccessFile</code> is like a
- * <code>RandomAccessFile</code>, but it uses a private buffer so that most
- * operations do not require a disk access.
- * <P>
- * 
- * Note: The operations on this class are unmonitored. Also, the correct
- * functioning of the <code>RandomAccessFile</code> methods that are not
- * overridden here relies on the implementation of those methods in the
- * superclass.
- * Author : Avinash Lakshman ( alakshman@facebook.com) & Prashant Malik ( pmalik@facebook.com )
- */
-
-public final class ChecksumRandomAccessFile extends RandomAccessFile
-{ 
-    private static enum ChecksumOperations
-    {
-        LOG,
-        VERIFY
-    }
-    
-    static final int LogBuffSz_ = 16; // 64K buffer
-    private static final int checksumSz_ = (1 << LogBuffSz_); // 64K
-    public static final int BuffSz_ = (1 << LogBuffSz_);
-    static final long BuffMask_ = ~(((long) BuffSz_) - 1L);
-    
-    /*
-     * This implementation is based on the buffer implementation in Modula-3's
-     * "Rd", "Wr", "RdClass", and "WrClass" interfaces.
-     */
-    private boolean dirty_; // true iff unflushed bytes exist
-    private boolean closed_; // true iff the file is closed
-    private long curr_; // current position in file
-    private long lo_, hi_; // bounds on characters in "buff"
-    private byte[] buff_; // local buffer
-    private long maxHi_; // this.lo + this.buff.length
-    private boolean hitEOF_; // buffer contains last file block?
-    private long diskPos_; // disk position
-    private String filename_; // file name
-    
-    /*
-     * To describe the above fields, we introduce the following abstractions for
-     * the file "f":
-     * 
-     * len(f) the length of the file curr(f) the current position in the file
-     * c(f) the abstract contents of the file disk(f) the contents of f's
-     * backing disk file closed(f) true iff the file is closed
-     * 
-     * "curr(f)" is an index in the closed interval [0, len(f)]. "c(f)" is a
-     * character sequence of length "len(f)". "c(f)" and "disk(f)" may differ if
-     * "c(f)" contains unflushed writes not reflected in "disk(f)". The flush
-     * operation has the effect of making "disk(f)" identical to "c(f)".
-     * 
-     * A file is said to be *valid* if the following conditions hold:
-     * 
-     * V1. The "closed" and "curr" fields are correct:
-     * 
-     * f.closed == closed(f) f.curr == curr(f)
-     * 
-     * V2. The current position is either contained in the buffer, or just past
-     * the buffer:
-     * 
-     * f.lo <= f.curr <= f.hi
-     * 
-     * V3. Any (possibly) unflushed characters are stored in "f.buff":
-     * 
-     * (forall i in [f.lo, f.curr): c(f)[i] == f.buff[i - f.lo])
-     * 
-     * V4. For all characters not covered by V3, c(f) and disk(f) agree:
-     * 
-     * (forall i in [f.lo, len(f)): i not in [f.lo, f.curr) => c(f)[i] ==
-     * disk(f)[i])
-     * 
-     * V5. "f.dirty" is true iff the buffer contains bytes that should be
-     * flushed to the file; by V3 and V4, only part of the buffer can be dirty.
-     * 
-     * f.dirty == (exists i in [f.lo, f.curr): c(f)[i] != f.buff[i - f.lo])
-     * 
-     * V6. this.maxHi == this.lo + this.buff.length
-     * 
-     * Note that "f.buff" can be "null" in a valid file, since the range of
-     * characters in V3 is empty when "f.lo == f.curr".
-     * 
-     * A file is said to be *ready* if the buffer contains the current position,
-     * i.e., when:
-     * 
-     * R1. !f.closed && f.buff != null && f.lo <= f.curr && f.curr < f.hi
-     * 
-     * When a file is ready, reading or writing a single byte can be performed
-     * by reading or writing the in-memory buffer without performing a disk
-     * operation.
-     */
-    
-    /**
-     * Open a new <code>BufferedRandomAccessFile</code> on <code>file</code>
-     * in mode <code>mode</code>, which should be "r" for reading only, or
-     * "rw" for reading and writing.
-     */
-    public ChecksumRandomAccessFile(File file, String mode) throws IOException
-    {
-        super(file, mode);
-        this.init(file.getAbsolutePath(), 0);
-    }
-    
-    public ChecksumRandomAccessFile(File file, String mode, int size) throws IOException
-    {
-        super(file, mode);
-        this.init(file.getAbsolutePath(), size);
-    }
-    
-    /**
-     * Open a new <code>BufferedRandomAccessFile</code> on the file named
-     * <code>name</code> in mode <code>mode</code>, which should be "r" for
-     * reading only, or "rw" for reading and writing.
-     */
-    public ChecksumRandomAccessFile(String name, String mode) throws IOException
-    {
-        super(name, mode);
-        this.init(name, 0);
-    }
-    
-    public ChecksumRandomAccessFile(String name, String mode, int size) throws FileNotFoundException
-    {
-        super(name, mode);
-        this.init(name, size);
-    }
-    
-    private void init(String name, int size)
-    {
-        this.dirty_ = this.closed_ = false;
-        this.lo_ = this.curr_ = this.hi_ = 0;
-        this.buff_ = (size > BuffSz_) ? new byte[size] : new byte[BuffSz_];
-        this.maxHi_ = (long) BuffSz_;
-        this.hitEOF_ = false;
-        this.diskPos_ = 0L;
-        this.filename_ = name;
-    }
-    
-    public void close() throws IOException
-    {
-        this.flush();
-        this.closed_ = true;
-        super.close();
-    }
-    
-    /**
-     * Flush any bytes in the file's buffer that have not yet been written to
-     * disk. If the file was created read-only, this method is a no-op.
-     */
-    public void flush() throws IOException
-    {
-        this.flushBuffer();
-    }
-    
-    private void doChecksumOperation(ChecksumOperations chksumOps) throws IOException
-    {        
-        int buffSz = buff_.length;
-        /*
-         * If the diskPos_ is at the buffer boundary then return 
-         * diskPos_ - 1 else return the actual diskPos_.
-        */        
-        long currentPosition = ( (diskPos_ % buffSz) == 0 ) ? diskPos_ - 1 : diskPos_;
-        /* Tells me which buffered chunk I am in. */
-        long chunk = (currentPosition / buffSz) + 1; 
-        /* Number of checksum chunks within a buffer */
-        int chksumChunks = buff_.length / checksumSz_;  
-        /* Position of the start of the previous buffer boundary */
-        long pos = (chunk == 0) ? 0 : (chunk - 1)*buffSz;
-        int startOffset = 0;
-        int chksumChunkId = (int)(chksumChunks*(chunk - 1) + 1);
-        do
-        {            
-            int fId = ChecksumManager.getFileId(filename_);               
-            switch( chksumOps )
-            {
-                case LOG:                    
-                    ChecksumManager.instance(filename_).logChecksum(fId, chksumChunkId++, buff_, startOffset, checksumSz_);
-                    break;
-                case VERIFY:
-                    ChecksumManager.instance(filename_).validateChecksum(filename_, chksumChunkId++, buff_, startOffset, checksumSz_);
-                    break;
-            }
-            pos += checksumSz_;
-            startOffset += checksumSz_;
-        }
-        while ( pos < currentPosition );
-    }
-    
-    /**
-     * Flush any dirty bytes in the buffer to disk. 
-    */
-    private void flushBuffer() throws IOException
-    {
-        if (this.dirty_)
-        {
-            if (this.diskPos_ != this.lo_)
-                super.seek(this.lo_);
-            int len = (int) (this.curr_ - this.lo_);            
-            super.write(this.buff_, 0, len);
-            this.diskPos_ = this.curr_;
-            this.dirty_ = false;
-            /* checksum the data before we write to disk */
-            doChecksumOperation(ChecksumOperations.LOG);
-        }
-    }
-    
-    /**
-     * Read at most "this.buff.length" bytes into "this.buff", returning the
-     * number of bytes read. If the return result is less than
-     * "this.buff.length", then EOF was read.
-     */
-    private int fillBuffer() throws IOException
-    {
-        int cnt = 0;
-        int rem = this.buff_.length;
-        int n = -1;
-        while (rem > 0)
-        {
-            n = super.read(this.buff_, cnt, rem);
-            if (n < 0)
-                break;
-            cnt += n;
-            rem -= n;
-        }
-        if (this.hitEOF_ = (cnt < this.buff_.length))
-        {
-            // make sure buffer that wasn't read is initialized with -1
-            Arrays.fill(this.buff_, cnt, this.buff_.length, (byte) 0xff);             
-        }                
-        this.diskPos_ += cnt;
-        return cnt;
-    }
-    
-    /**
-     * This method positions <code>this.curr</code> at position <code>pos</code>.
-     * If <code>pos</code> does not fall in the current buffer, it flushes the
-     * current buffer and loads the correct one.<p>
-     * 
-     * On exit from this routine <code>this.curr == this.hi</code> iff <code>pos</code>
-     * is at or past the end-of-file, which can only happen if the file was
-     * opened in read-only mode.
-     */
-    public void seek(long pos) throws IOException
-    {
-        if (pos >= this.hi_ || pos < this.lo_)
-        {
-            // seeking outside of current buffer -- flush and read
-            this.flushBuffer();
-            this.lo_ = pos & BuffMask_; // start at BuffSz boundary
-            this.maxHi_ = this.lo_ + (long) this.buff_.length;
-            if (this.diskPos_ != this.lo_)
-            {
-                super.seek(this.lo_);
-                this.diskPos_ = this.lo_;
-            }
-            int n = this.fillBuffer();
-            if ( n > 0 )
-            {
-                doChecksumOperation(ChecksumOperations.VERIFY);
-            }
-            this.hi_ = this.lo_ + (long) n;
-        }
-        else
-        {
-            // seeking inside current buffer -- no read required
-            if (pos < this.curr_)
-            {
-                // if seeking backwards, we must flush to maintain V4
-                this.flushBuffer();
-            }
-        }
-        this.curr_ = pos;
-    }
-    
-    public long getFilePointer()
-    {
-        return this.curr_;
-    }
-    
-    public long length() throws IOException
-    {
-        return Math.max(this.curr_, super.length());
-    }
-    
-    public int read() throws IOException
-    {
-        if (this.curr_ >= this.hi_)
-        {
-            // test for EOF
-            // if (this.hi < this.maxHi) return -1;
-            if (this.hitEOF_)
-                return -1;
-            
-            // slow path -- read another buffer
-            this.seek(this.curr_);
-            if (this.curr_ == this.hi_)
-                return -1;
-        }
-        byte res = this.buff_[(int) (this.curr_ - this.lo_)];
-        this.curr_++;
-        return ((int) res) & 0xFF; // convert byte -> int
-    }
-    
-    public int read(byte[] b) throws IOException
-    {
-        return this.read(b, 0, b.length);
-    }
-    
-    public int read(byte[] b, int off, int len) throws IOException
-    {
-        if (this.curr_ >= this.hi_)
-        {
-            // test for EOF
-            // if (this.hi < this.maxHi) return -1;
-            if (this.hitEOF_)
-                return -1;
-            
-            // slow path -- read another buffer
-            this.seek(this.curr_);
-            if (this.curr_ == this.hi_)
-                return -1;
-        }
-        len = Math.min(len, (int) (this.hi_ - this.curr_));
-        int buffOff = (int) (this.curr_ - this.lo_);
-        System.arraycopy(this.buff_, buffOff, b, off, len);
-        this.curr_ += len;
-        return len;
-    }
-    
-    public void write(int b) throws IOException
-    {
-        if (this.curr_ >= this.hi_)
-        {
-            if (this.hitEOF_ && this.hi_ < this.maxHi_)
-            {
-                // at EOF -- bump "hi"
-                this.hi_++;
-            }
-            else
-            {
-                // slow path -- write current buffer; read next one
-                this.seek(this.curr_);
-                if (this.curr_ == this.hi_)
-                {
-                    // appending to EOF -- bump "hi"
-                    this.hi_++;
-                }
-            }
-        }
-        this.buff_[(int) (this.curr_ - this.lo_)] = (byte) b;
-        this.curr_++;
-        this.dirty_ = true;
-    }
-    
-    public void write(byte[] b) throws IOException
-    {
-        this.write(b, 0, b.length);
-    }
-    
-    public void write(byte[] b, int off, int len) throws IOException
-    {
-        while (len > 0)
-        {
-            int n = this.writeAtMost(b, off, len);
-            off += n;
-            len -= n;
-            this.dirty_ = true;
-        }
-    }
-    
-    /*
-     * Write at most "len" bytes to "b" starting at position "off", and return
-     * the number of bytes written.
-     */
-    private int writeAtMost(byte[] b, int off, int len) throws IOException
-    {
-        if (this.curr_ >= this.hi_)
-        {
-            if (this.hitEOF_ && this.hi_ < this.maxHi_)
-            {
-                // at EOF -- bump "hi"
-                this.hi_ = this.maxHi_;
-            }
-            else
-            {
-                // slow path -- write current buffer; read next one
-                this.seek(this.curr_);
-                if (this.curr_ == this.hi_)
-                {
-                    // appending to EOF -- bump "hi"
-                    this.hi_ = this.maxHi_;
-                }
-            }
-        }
-        len = Math.min(len, (int) (this.hi_ - this.curr_));
-        int buffOff = (int) (this.curr_ - this.lo_);
-        System.arraycopy(b, off, this.buff_, buffOff, len);
-        this.curr_ += len;
-        return len;
-    }
-    
-    public static void main(String[] args) throws Throwable
-    {
-        
-        RandomAccessFile raf = new ChecksumRandomAccessFile("C:\\Engagements\\Table-ColumnFamily-1-Data.dat", "rw");
-        byte[] bytes = new byte[32*1024];
-        Random random = new Random();
-        
-        for ( int i = 0; i < 16; ++i )
-        {
-            random.nextBytes(bytes);
-            raf.write(bytes);
-        }
-        raf.close();
-        
-        String file = "C:\\Engagements\\Checksum-1.db";
-        ChecksumManager.instance("C:\\Engagements\\Table-ColumnFamily-1-Data.dat", file);
-        
-        raf = new ChecksumRandomAccessFile("C:\\Engagements\\Table-ColumnFamily-1-Data.dat", "rw", 4*1024*1024);
-        bytes = new byte[32*1024];
-        
-        for ( int i = 0; i < 16; ++i )
-        {           
-            raf.readFully(bytes);
-        }
-        raf.close();
-       
-    }
-}
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/SSTable.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/SSTable.java
index 1611e9ab..44bb04c0 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/SSTable.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/SSTable.java
@@ -89,8 +89,6 @@ public static void delete(String dataFile) throws IOException
     {
         /* remove the cached index table from memory */
         indexMetadataMap_.remove(dataFile);
-        /* Delete the checksum file associated with this data file */
-        ChecksumManager.onFileDelete(dataFile);
 
         deleteWithConfirm(new File(dataFile));
         deleteWithConfirm(new File(indexFilename(dataFile)));
diff --git a/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/SequenceFile.java b/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/SequenceFile.java
index 749f9367..f5ecb7a4 100644
--- a/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/SequenceFile.java
+++ b/incubator/cassandra/trunk/src/java/org/apache/cassandra/io/SequenceFile.java
@@ -228,34 +228,6 @@ protected void init(String filename, int size) throws IOException
         }
     }
 
-    public static class ChecksumWriter extends Writer
-    {
-
-        ChecksumWriter(String filename, int size) throws IOException
-        {
-            super(filename, size);
-        }
-
-        @Override
-        protected void init(String filename) throws IOException
-        {
-            init(filename, 0);
-        }
-
-        @Override
-        protected void init(String filename, int size) throws IOException
-        {
-            File file = new File(filename);
-            file_ = new ChecksumRandomAccessFile(file, "rw", size);
-        }
-
-        @Override
-        public void close() throws IOException
-        {
-            super.close();
-            ChecksumManager.close(filename_);
-        }
-    }
 
     public static class ConcurrentWriter extends AbstractWriter
     {
@@ -1113,22 +1085,6 @@ protected void init(String filename) throws IOException
         }
     }
 
-    public static class ChecksumReader extends Reader
-    {
-        private int size_;
-
-        ChecksumReader(String filename, int size) throws IOException
-        {
-            super(filename);
-            size_ = size;
-        }
-
-        protected void init(String filename) throws IOException
-        {
-            file_ = new ChecksumRandomAccessFile(filename, "r", size_);
-        }
-    }
-
     private static Logger logger_ = Logger.getLogger(SequenceFile.class);
     public static final short utfPrefix_ = 2;
     public static final String marker_ = "Bloom-Filter";
